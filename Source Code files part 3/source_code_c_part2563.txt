_);  

	cxx.Disable();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Ee\mix\m7cases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  M7CASES.CPP
//
//  Created by :            Date :
//      MichMa              	12/15/93
//
//  Description :
//      Implementation of the CMix7Cases class
//

#include "stdafx.h"
#include "m7cases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CMix7Cases, CDebugTestSet, "Mixed7", 11, CMixSubSuite)


void CMix7Cases::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CMix7Cases::Run(void)

	{
	if(!fProjectReady)
		{
		InitProject("mix");
		bps.SetBreakpoint("break_here");
		fProjectReady = TRUE;
		}
	else
		dbg.Restart();

	dbg.Go();
	cxx.Enable();

	WriteLog(cxx.ExpressionValueIs("((stlong1 != (d1 < *pd3)) || (stlong7 ^= (stlong2 /= stlong6)))", 1) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong2", 0) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong7", 7) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("((stlong3 << ( ! stlong8)) - (stlong4 |= (stlong6 && stlong3)))", -2) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong4", 5) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("((stlong2 & (stlong7 * stlong6)) < (( - stlong4) % stlong3))", 0) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("(((stlong1 ^ stlong4) && f4) - (d1 = ((stlong5)-- )))", -4.0000000000000) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong5", 4) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("d1", 5.0000000000000) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("((f2 /= (stlong2 - *pd1)) + (stlong8 && (d2 + *pf1)))", 0.560000) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("f2", -0.440000) ? PASSED : FAILED, "line = %d\n", __LINE__);

	cxx.Disable();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Ee\mix\m6cases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  M6CASES.CPP
//
//  Created by :            Date :
//      MichMa              	12/15/93
//
//  Description :
//      Implementation of the CMix6Cases class
//

#include "stdafx.h"
#include "m6cases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CMix6Cases, CDebugTestSet, "Mixed6", 14, CMixSubSuite)


void CMix6Cases::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CMix6Cases::Run(void)

	{
	if(!fProjectReady)
		{
		InitProject("mix");
		bps.SetBreakpoint("break_here");
		fProjectReady = TRUE;
		}
	else
		dbg.Restart();

	dbg.Go();
	cxx.Enable();

	WriteLog(cxx.ExpressionValueIs("((stlong8 <<= (stlong7 > stlong5)) >= ((stlong1 * stlong7) & stlong1))", 1) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong8", 16) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("((stlong1 << ( ++ stlong2)) - (((stlong3)++ ) ^ stlong4))", 1) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong3", 4) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong2", 3) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("((stlong1 <<= (stlong4 - stlong2)) == (*pf3 /= ((*pf1)-- )))", 0) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("f1", 0.100000) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("f3", 3.00000) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong1", 2) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("((stlong5 && ( ++ stlong8)) ^ (((stlong7)++ ) == stlong3))", 1) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong7", 8) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong8", 17) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("((( - stlong7) % stlong5) == (*pd2 *= (d1 != *pf1)))", 0) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("d2", 2.2000000000000) ? PASSED : FAILED, "line = %d\n", __LINE__);

	cxx.Disable();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Ee\mix\m8cases.h ===
///////////////////////////////////////////////////////////////////////////////
//  M8CASES.H
//
//  Created by :            Date :
//      MichMa              	12/15/93
//
//  Description :
//      Declaration of the CMix8Cases class
//

#ifndef __M8CASES_H__
#define __M8CASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\core\dbgset.h"
#include "mixsub.h"

///////////////////////////////////////////////////////////////////////////////
//  CMix8Cases class

class CMix8Cases : public CDebugTestSet

	{
	DECLARE_TEST(CMix8Cases, CMixSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);
	};

#endif //__M8CASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Ee\mix\m7cases.h ===
///////////////////////////////////////////////////////////////////////////////
//  M7CASES.H
//
//  Created by :            Date :
//      MichMa              	12/15/93
//
//  Description :
//      Declaration of the CMix7Cases class
//

#ifndef __M7CASES_H__
#define __M7CASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\core\dbgset.h"
#include "mixsub.h"

///////////////////////////////////////////////////////////////////////////////
//  CMix7Cases class

class CMix7Cases : public CDebugTestSet

	{
	DECLARE_TEST(CMix7Cases, CMixSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);
	};

#endif //__M7CASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Ee\mix\m8cases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  M8CASES.CPP
//
//  Created by :            Date :
//      MichMa              	12/15/93
//
//  Description :
//      Implementation of the CMix1Cases class
//

#include "stdafx.h"
#include "m8cases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CMix8Cases, CDebugTestSet, "Mixed8", 17, CMixSubSuite)


void CMix8Cases::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CMix8Cases::Run(void)

	{
	if(!fProjectReady)
		{
		InitProject("mix");
		bps.SetBreakpoint("break_here");
		fProjectReady = TRUE;
		}
	else
		dbg.Restart();

	dbg.Go();
	cxx.Enable();

	WriteLog(cxx.ExpressionValueIs("((stlong2 /= (stlong1 + stlong4)) % (stlong8 /= (stlong3 &= stlong6)))", 0) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong3", 2) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong8", 4) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong2", 0) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("((stlong7 %= (stlong2 + stlong3)) < (stlong4 >>= (stlong8 /= stlong1)))", 0) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong8", 4) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong4", 0) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong7", 1) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("(((d1 * d1) + stlong2) - (*pd4 += (*pf2 /= stlong6)))", -3.5566666746140) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("f2", 0.366667) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("d4", 4.7666666746140) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("((stlong7 | ( - stlong1)) * (stlong8 <<= (stlong6 &= stlong3)))", -16) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong6", 2) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong8", 16) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("((stlong4 >>= (stlong5 >>= stlong6)) + (d1 || ( ! f3)))", 1) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong5", 1) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong4", 0) ? PASSED : FAILED, "line = %d\n", __LINE__);

	cxx.Disable();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Ee\mix\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Ee\mix\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Ee\mix\m9cases.h ===
///////////////////////////////////////////////////////////////////////////////
//  M9CASES.H
//
//  Created by :            Date :
//      MichMa              	12/15/93
//
//  Description :
//      Declaration of the CMix9Cases class
//

#ifndef __M9CASES_H__
#define __M9CASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\core\dbgset.h"
#include "mixsub.h"

///////////////////////////////////////////////////////////////////////////////
//  CMix9Cases class

class CMix9Cases : public CDebugTestSet

	{
	DECLARE_TEST(CMix9Cases, CMixSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);
	};

#endif //__M9CASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Ee\mix\mixsub.h ===
///////////////////////////////////////////////////////////////////////////////
//  MIXSUB.H
//
//  Created by :            Date :
//      MichMa              	12/03/93
//
//  Description :
//      Declaration of the CMixSubSuite class
//

#ifndef __MIXSUB_H__
#define __MIXSUB_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif


///////////////////////////////////////////////////////////////////////////////
// CMixSubSuite class

class CMixSubSuite : public CIDESubSuite
	{
	public:
		DECLARE_SUBSUITE(CMixSubSuite)
		DECLARE_TESTLIST()
	protected:
		void CleanUp(void);
	};

extern BOOL fProjectReady;

#endif //__MIXSUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Ee\mix\m9cases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  M9CASES.CPP
//
//  Created by :            Date :
//      MichMa              	12/15/93
//
//  Description :
//      Implementation of the CMix9Cases class
//

#include "stdafx.h"
#include "m9cases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CMix9Cases, CDebugTestSet, "Mixed9", 11, CMixSubSuite)


void CMix9Cases::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CMix9Cases::Run(void)

	{
	if(!fProjectReady)
		{
		InitProject("mix");
		bps.SetBreakpoint("break_here");
		fProjectReady = TRUE;
		}
	else
		dbg.Restart();

	dbg.Go();
	cxx.Enable();

 	WriteLog(cxx.ExpressionValueIs("(((*pd4 - d4) == d3) != (((stlong5)++ ) >> stlong4))", 0) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong5", 6) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("((stlong6 & (stlong7 >> stlong1)) > (stlong4 &= (stlong2 ^ stlong8)))", 1) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong4", 0) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("((( - f4) && *pf3) || ((d3 != *pd1) && *pd3))", 1) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("((*pd1 += (*pd2 < d4)) == (stlong2 %= (stlong7 += stlong6)))", 0) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong7", 13) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong2", 2) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("d1", 2.1000000000000) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("(((stlong3 % stlong6) % stlong7) >= (stlong4 >>= (stlong3 & stlong8)))", 1) ? PASSED : FAILED, "line = %d\n", __LINE__);
	WriteLog(cxx.ExpressionValueIs("stlong4", 0) ? PASSED : FAILED, "line = %d\n", __LINE__);

	cxx.Disable();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Lfn\filesub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		WinslowF		
//
//	Description :
//		implementation of the CFILENAMESubSuite class
//

#include "stdafx.h"
#include "FILEsub.h"

#include "FILEcase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CFILENAMESubSuite

IMPLEMENT_SUBSUITE(CFILENAMESubSuite, CIDESubSuite, "DBG filename test", "WinslowF")

BEGIN_TESTLIST(CFILENAMESubSuite)
	TEST(CFILENAMEIDETest, RUN)
END_TESTLIST()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Lfn\filecase.h ===
///////////////////////////////////////////////////////////////////////////////
//	FILEcase.h
//
//	Created by :			
//		WinslowF
//
//	Description :
//		Declaration of the CFILENAMEIDETest Class
//

#ifndef __FILEcase_H__
#define __FILEcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "filesub.h"

//
//	Macros
//
#define VERIFY_TEST_SUCCESS(TestCase)\
	((TestCase) == ERROR_SUCCESS)

#define VERIFY_BP_SUCCESS(BpCase)\
	((BpCase) != NULL)

// ComboBox index for Tools.Options.Debug Memory window format
#define MEM_WIN_ASCII	1
///////////////////////////////////////////////////////////////////////////////
//	CFILENAMEIDETest class

class CFILENAMEIDETest : public CTest
{
	DECLARE_TEST(CFILENAMEIDETest, CFILENAMESubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

// Test Cases
protected:
	void CopyFile(CString szFrom, CString szTo);
	void SetUp(void);
// Data
protected:
	/*
		Project/General
	*/
	CString		m_strCurDir;
	CString		m_szSourceDir;
	CString		m_szTestDir;
	CString		m_szProject;
	CString		m_szProjectFiles;
	CString		m_szNewIntermediateDir;
	CString		m_szNewOutputDir;
	CString		m_szErrorText;
	CString		m_szComment;
 	PROJOPTIONS ProjOptions;
  	COProject	proj;
	/*
		Breakpoint
	*/
	CString			m_szBPLocation;
	bp				*bpString;
	COBreakpoints	bp;

	/*
		Disassembly
	*/
	CString			m_szDisasm;

	/*
		Quick Watch
	*/
	CString			m_szQWExpr1;
	CString			m_szQWExpr2;
	
	/*
		Memory
	*/
	CString			m_szMemBuf;
	CString			m_szMem1;
	CString			m_szMem2;

	CODebug		dbg;
	COExpEval	qw;
	
// Test Cases
protected:
	BOOL CreateFileNameList(CStringList *szFileList);
	BOOL CreateBuildProject( void );
	BOOL CreateProject( void );    // not really a dbg test
	BOOL SetBreakpoints( void );
	BOOL ReadDBCSource( void );
	BOOL ReadDBCDisasm( void );
	BOOL QuickWatchTest( void );
	BOOL MemoryTest( void );
	BOOL ENDThisTest( void );
	void CopySourceFiles();

// Test Cases
protected:

};


#endif //__FILEcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Ee\mix\mixsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  MIXSUB.CPP
//
//  Created by :            Date :
//      MichMa              	12/03/93
//
//  Description :
//      implementation of the CMixSubSuite class
//

#include "stdafx.h"
#include "mixsub.h"
#include "afxdllx.h"
#include "..\..\core\cleanup.h"

#include "m1cases.h"
#include "m2cases.h"
#include "m3cases.h"
#include "m4cases.h"
#include "m5cases.h"
#include "m6cases.h"
#include "m7cases.h"
#include "m8cases.h"
#include "m9cases.h"
#include "m10cases.h"
#include "m11cases.h"
#include "m12cases.h"
#include "m13cases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


/////////////////////////////////////////////////////////////////////////////
// CMixSubSuite

IMPLEMENT_SUBSUITE(CMixSubSuite, CIDESubSuite, "EE - Mixed", "VCQA Debugger")

BEGIN_TESTLIST(CMixSubSuite)
	TEST(CMix1Cases, RUN)
	TEST(CMix2Cases, RUN)
	TEST(CMix3Cases, RUN)
	TEST(CMix4Cases, RUN)
	TEST(CMix5Cases, RUN)
	TEST(CMix6Cases, RUN)
	TEST(CMix7Cases, RUN)
	TEST(CMix8Cases, RUN)
	TEST(CMix9Cases, RUN)
	TEST(CMix10Cases, RUN)
	TEST(CMix11Cases, RUN)
	TEST(CMix12Cases, RUN)
	TEST(CMix13Cases, RUN)
END_TESTLIST()

void CMixSubSuite::CleanUp(void)
	{
	::CleanUp();
	}

BOOL fProjectReady = FALSE;

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Lfn\filesub.h ===
///////////////////////////////////////////////////////////////////////////////
//	FILEsub.h
//
//	Created by :			
//		WinslowF
//
//	Description :
//		Declaration of the CFILENAMESubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CFILENAMESubSuite class

class CFILENAMESubSuite : public CIDESubSuite
{
	DECLARE_SUBSUITE(CFILENAMESubSuite)

	DECLARE_TESTLIST()
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Lfn\filecase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	FILEcase.CPP
//											 
//	Created by :			
//		WinslowF		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "FILEcase.h"	
#include <string.h>

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 

/*
	Source files in szSrcDir
*/
static CString szSrcMainFile	= "mainfile";
static CString szSrc2ndFile		= "file2";
static CString szTestMainFile	= "testfile";
static CString szTest2ndFile	= "xx";
static CString szTestDir		= "test";
static CString szOpenFile		= "Names.TXT";
static CString szErrFile		= "FilErr.Log";
static CString szRootDir		= "testroot";


/*
	Source directory
*/
static CString szSrcDir		= "src";

static CString szBackslash = "\\";

IMPLEMENT_TEST(CFILENAMEIDETest, CTest, "DBG filename test", -1, CFILENAMESubSuite)

void CFILENAMEIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CFILENAMEIDETest::CopyFile(CString szFrom, CString szTo)
{
	CString	szDestination = m_szTestDir+szBackslash+szTo;

	SetFileAttributes(szDestination,FILE_ATTRIBUTE_NORMAL);				// Unset READONLY
	::CopyFile( m_szSourceDir+szBackslash+szFrom, szDestination, FALSE );
	SetFileAttributes(szDestination,FILE_ATTRIBUTE_NORMAL);				// Unset READONLY
}

void CFILENAMEIDETest::Run(void)
{
	XSAFETY;

	UIDebug dbgUI;
	CStringList szFileList;
	POSITION pos;

	/*
		Copy project from src to test directory.
	*/
	if( VERIFY_TEST_SUCCESS( CreateFileNameList(&szFileList) ) )
	{
		m_szErrorText = "Can't create filename list";
		m_pLog->Comment( m_szErrorText );
	}
	

	for( pos = szFileList.GetHeadPosition(); pos != NULL; )
	{
		szTest2ndFile = szFileList.GetNext( pos );
	
		Sleep(10);
		SetUp();
		
		m_szErrorText = "<<======== Filename test for directory " + m_szTestDir + " and filename " + szTest2ndFile + "========>>";
		m_pLog->Comment( m_szErrorText );

		m_szErrorText = "->>CreateBuild project";
		m_pLog->Comment( m_szErrorText );
		EXPECT( CreateBuildProject() );
		m_szErrorText = "->>Set break points";
		m_pLog->Comment( m_szErrorText );
		EXPECT( SetBreakpoints() );
		EXPECT( ReadDBCSource() );
		EXPECT(dbgUI.ShowDockWindow(IDW_OUTPUT_WIN, TRUE));
		m_szErrorText = "->>Show registers";
		m_pLog->Comment( m_szErrorText );
		EXPECT(dbgUI.ShowDockWindow(IDW_CPU_WIN, TRUE));
		m_szErrorText = "->>Show callstack";
		m_pLog->Comment( m_szErrorText );
		EXPECT(dbgUI.ShowDockWindow(IDW_CALLS_WIN, TRUE));
		EXPECT(dbg.SetSteppingMode(SRC));	
		EXPECT( ReadDBCDisasm() );
		m_szErrorText = "->>QuickWatch test";
		m_pLog->Comment( m_szErrorText );
		EXPECT( QuickWatchTest() );
		m_szErrorText = "->>Memory test";
		m_pLog->Comment( m_szErrorText );
		EXPECT( MemoryTest() );
		m_szErrorText = "->>End test";  
		m_pLog->Comment( m_szErrorText );
		EXPECT( ENDThisTest() );
	}

	XSAFETY;
}


BOOL CFILENAMEIDETest::CreateFileNameList(CStringList *szFileList)
{
	char* psz = m_strCurDir.GetBufferSetLength(_MAX_DIR);
	CStdioFile f1;


	GetCurrentDirectory(_MAX_DIR - 1, psz);
	m_strCurDir.ReleaseBuffer(-1);
	if( m_strCurDir.Right(1) != '\\' )
		m_strCurDir += szBackslash;

	m_szSourceDir	= m_strCurDir + szSrcDir;

	if( !f1.Open( m_szSourceDir + szBackslash + szOpenFile,
		CFile::modeRead | CFile::typeText ) )
	{
		m_szErrorText = "Can't open datafile " + szOpenFile;
		m_pLog->Comment( m_szErrorText );
		f1.Close();
		return FALSE;
	}
	char buf[256];

	while(f1.ReadString( buf, 256 ) != NULL)
	{
		if (buf[0] != '#')
		{
			if (buf[strlen(buf) - 1] == '\n')
				buf[strlen(buf) - 1] = '\0';
			szFileList->AddTail(buf);
		}
	}
	f1.Close();
	return TRUE;
}


BOOL CFILENAMEIDETest::CreateBuildProject( void )
{

	BOOL bResult = TRUE;
	UIOptionsTabDlg	uiopt;


// the IDE's UI has changed regarding setting fonts and this no longer works.
// Temporarily will not be used until have time to change cafe.
#if 0  
	if( VERIFY_TEST_SUCCESS( !uiopt.SetOption(TAB_FONTS, VCPP32_IDC_FONTLIST, "Fixedsys" )) )
	{
		m_szErrorText = "Default font set to Fixedsys failed";
		m_pLog->Comment( m_szErrorText );
		/*
			Clean up??? How to recover from this?
		*/
	}
	else
	{
//		MST.WButtonClick(GetLabel(VCPP32_IDC_USEASDEFAULT));
		MST.WButtonClick(GetLabel(IDOK));				//	uiopt.Close(); is broken
	}
#endif

	if( VERIFY_TEST_SUCCESS( CreateProject() ) )
	{
		m_szErrorText = "Internal makefile "+m_szProject+" could not be created";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(!proj.RebuildAll(6)) )
	{
		m_szErrorText = "Build of "+m_szProject+" failed";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}

	return bResult;
}

/*
** create the project.  Instead of using a static .mak file which 
** becomes obsolete with changes to the project facility, create
** the project each time.  The project source files are static.
** We also get some freebies regarding setting target, because
** since we generate the makefile on the desired platform it will
** be the default target.
*/
BOOL CFILENAMEIDETest::CreateProject( void )
{
	m_pLog->Comment( "	-> Project.New" );
	if ( proj.NewProject( CONSOLE_APP, ProjOptions.szName, GetUserTargetPlatforms(), ProjOptions.szDir) != ERROR_SUCCESS)
	{
		m_szErrorText = "	unable to create new project";
		m_pLog->Comment( m_szErrorText );
		return FALSE;
	}

	CopySourceFiles();

	m_pLog->Comment( "	-> Project.Addfiles" );
	if ( proj.AddFiles( m_szProjectFiles ) != ERROR_SUCCESS)
	{
		m_szErrorText = "	adding files to project failed";
		m_pLog->Comment( m_szErrorText );
		return FALSE;
	}

	// workaround to the new project window (it can be hiden at this time)
	proj.ActivateProjWnd();

	//set intermediate directory
	m_pLog->Comment( "	-> Project.SetProjProperty" );
	if ( proj.SetProjProperty(CT_GENERAL,
			VPROJ_IDC_OUTDIRS_INT, 
			m_szNewIntermediateDir) != ERROR_SUCCESS)
	{
		m_szErrorText = "	setting intermediated directory failed";
		m_pLog->Comment( m_szErrorText );
		return FALSE;
	}

	//set output directory
	m_pLog->Comment( "	-> Project.SetProjOutputDir" );
	if (proj.SetProjProperty(CT_GENERAL,
			VPROJ_IDC_OUTDIRS_TRG, 
			m_szNewOutputDir) != ERROR_SUCCESS)
	{
		m_szErrorText = "	setting output directory failed";
		m_pLog->Comment( m_szErrorText );
		return FALSE;
	}

	return TRUE;
}

void CreateDirectoryLong(const char *path)
{
	char CurrentDir[_MAX_DIR], StartDir[_MAX_DIR], buf[_MAX_DIR], szPath[_MAX_DIR];
	char *chPtr;

	GetCurrentDirectory(_MAX_DIR - 1, CurrentDir);
	strcpy(StartDir, CurrentDir);
	strcpy (szPath, path);
	chPtr = strchr(szPath, '\\');
	while(chPtr)
	{
		*chPtr = '\0';
		strcpy(buf, szPath);
		CreateDirectory(buf, NULL);
		GetCurrentDirectory(_MAX_DIR - 1, CurrentDir);
		SetCurrentDirectory(CurrentDir + szBackslash + buf);
		strcpy(szPath, ++chPtr);
		chPtr = strchr(szPath, '\\');
	}

	strcpy(buf, szPath);
	CreateDirectory(buf, NULL);
	SetCurrentDirectory(StartDir);
	
}


void CFILENAMEIDETest::SetUp()
{

	char* psz = m_strCurDir.GetBufferSetLength(_MAX_DIR);

	m_szComment		= "This is a comment";
	m_szMem1		= "0123";
	m_szMem2		= "4567";

	GetCurrentDirectory(_MAX_DIR - 1, psz);
	m_strCurDir.ReleaseBuffer(-1);
	if( m_strCurDir.Right(1) != '\\' )
		m_strCurDir += szBackslash;

	char bufDir[_MAX_DIR];
	char *chLS;

	strcpy(bufDir, szTest2ndFile);	// Get complete path filename.
	chLS = strrchr(bufDir, '\\');	// Check for directory path existence
	if(chLS)
	{
		*chLS = '\0';
		szTest2ndFile = ++chLS;		// separate filename from path
		szTestDir = "test\\";
		szTestDir += bufDir;		// get directory path only

		// check for " in the filename.
		chLS = strrchr(szTest2ndFile, '"');
		if(chLS)
		{
			strcpy(bufDir, "\"");
			strcat(bufDir, szTest2ndFile);
			chLS = strrchr(bufDir, '"');
			*chLS = '\0';
			strcpy(bufDir, ".cpp\"");
			szTest2ndFile = bufDir;
		}
		else
			szTest2ndFile += ".cpp";	


	// check for " in the directory name.
		strcpy(bufDir, szTestDir);
		chLS = strchr(bufDir, '\"');
		if(chLS)
		{
			strcat(bufDir, "\"");
			szTestDir = bufDir;
		}
	}
	else
	{
		szTestDir = "test";

	// check for " in the filename.
		strcpy(bufDir, szTest2ndFile);
		chLS = strrchr(bufDir, '\"');
		if(chLS)
		{
			*chLS = '\0';
			strcat(bufDir, ".cpp\"");
			szTest2ndFile = bufDir;
		}
		else
			szTest2ndFile += ".cpp";
	}

// now szTest2ndFile has the correct filename
// and sztestDir has the corect directory

	szRootDir = m_strCurDir + "test";

	m_szSourceDir	= m_strCurDir + szSrcDir;

	chLS = strchr(szTestDir, '\"');
	if(chLS)
	{
		chLS++;
		m_szTestDir		= "\"" + m_strCurDir + chLS;
	}
	else
		m_szTestDir		= m_strCurDir + szTestDir;

	m_szProject		= m_szTestDir + szBackslash + szSrcMainFile;

	m_szBPLocation	= "{," + szTest2ndFile + ",}file_two";
	m_szQWExpr1		= "{file_two," + szTest2ndFile + ",}pch==glbDBNumbers";
	m_szQWExpr2		= "(int)*pch";

	m_szProjectFiles	= m_szTestDir + "\\*.cpp";
	m_szNewIntermediateDir = m_szTestDir + szBackslash + szTestMainFile;
	m_szNewOutputDir = m_szTestDir + szBackslash + szTestMainFile;

	ProjOptions.szDir	= m_szTestDir;
	ProjOptions.szName	= szTestMainFile;
	ProjOptions.iType	= CONSOLE_APP;
	ProjOptions.szNewSubDir = "";		// WinslowF for M3 work around  -> should be - m_szTestDir;


//	KillAllFiles((const char*) szTestDir+szBackslash+szTestMainFile, TRUE);
	KillAllFiles((const char*) szTestDir, TRUE);
	/*
		Copy mbctest.mak project to m_szTestDir from the m_szSourceDir
	*/
//	CreateDirectoryLong( (const char*) szTestDir);  

}

void CFILENAMEIDETest::CopySourceFiles()
{
	// create the new filename to copy
	CString NewTest2File;
	char bufDir[_MAX_DIR];
	char *chLS;
	char *chLS2;
	
	//m_szTestDir		= m_szTestDir + szBackslash + szTestMainFile;	// WinslowF Proj.New() change

	strcpy(bufDir, m_szTestDir);
	chLS = strrchr(bufDir, '\"');
	chLS2 = strchr(szTest2ndFile, '\"');
	if(chLS || chLS2)
	{
		if(chLS && chLS2)
		{
			chLS = '\0';
			NewTest2File	= bufDir + szBackslash +  ++chLS2;
		}
		else if(chLS)
		{
			chLS = '\0';
			NewTest2File	= bufDir + szBackslash + szTest2ndFile;
		}
		else if(chLS2)
		{
		//	NewTest2File	= "\"";
			NewTest2File += bufDir + szBackslash +  ++chLS2;
			chLS2 = strrchr(NewTest2File, '\"');
			*chLS2 = '\0';
		}

	}
	else
		NewTest2File	= m_szTestDir + szBackslash + szTest2ndFile;

	
	CStdioFile filerr;
	char buffer[20];
	int openerr = FALSE;
	int err;

	if( !filerr.Open( m_szSourceDir + szBackslash + szErrFile,
		CFile::modeCreate | CFile::modeWrite | CFile::typeText ) )
	{
		m_szErrorText = "Can't open error file" + szOpenFile;
		m_pLog->Comment( m_szErrorText );
		filerr.Close();
		openerr = TRUE;
	}

	::CopyFile( m_szSourceDir + szBackslash + szSrcMainFile+".cpp", m_szTestDir + szBackslash  + szTestMainFile +".cpp", FALSE );
	if(!openerr)
	{
		err = GetLastError();
		itoa(err, buffer, 10);
		filerr.WriteString( buffer );
		filerr.WriteString( "\n" );
	}
	::CopyFile( m_szSourceDir + szBackslash + szSrcMainFile+".h",   m_szTestDir + szBackslash  + szSrcMainFile+".h", FALSE );
	if(!openerr)
	{
		err = GetLastError();
		itoa(err, buffer, 10);
		filerr.WriteString( buffer );
		filerr.WriteString( "\n" );
	}
	::CopyFile( m_szSourceDir + szBackslash + szSrc2ndFile+".cpp",  NewTest2File, FALSE );
	if(!openerr)
	{
		err = GetLastError();
		itoa(err, buffer, 10);
		filerr.WriteString( buffer );
		filerr.WriteString( "\n" );
		filerr.Close();
	}

	::SetFileAttributes( m_szTestDir + szBackslash + szTestMainFile+".cpp" , FILE_ATTRIBUTE_NORMAL );	// Remove RO flag
	::SetFileAttributes( m_szTestDir + szBackslash + szSrcMainFile+".h" , FILE_ATTRIBUTE_NORMAL );	// Remove RO flag
	::SetFileAttributes( NewTest2File, FILE_ATTRIBUTE_NORMAL );	// Remove RO flag


	Sleep(10);
}


BOOL CFILENAMEIDETest::SetBreakpoints( void )
{

	BOOL bResult = TRUE;
	
	bp.ClearAllBreakpoints();

	if( VERIFY_BP_SUCCESS(!bp.SetBreakpoint(m_szBPLocation)) )
	{
		m_szErrorText = "Could not set breakpoint on "+m_szBPLocation;
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}

	return bResult;
}

BOOL CFILENAMEIDETest::ReadDBCSource( void )
{

	BOOL bResult = TRUE;
	int NStep;


#if defined( _MIPS_ )
	NStep = 2;
#else
	NStep = 3;
#endif



	if( VERIFY_TEST_SUCCESS(dbg.Go()) )
	{
		m_szErrorText = "This is a comment";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}

	else
	{
		MST.WFndWnd(szTest2ndFile, FW_FOCUS);
	
		 if( VERIFY_TEST_SUCCESS(dbg.StepOver(NStep, NULL, m_szComment )) )	  // "This is a comment"
		{
			m_szErrorText = "Read comment "+m_szComment+" in source failed, via StepOver";
			m_pLog->Comment( m_szErrorText );
			bResult = FALSE;
		}

	}

	return bResult;
}

BOOL CFILENAMEIDETest::ReadDBCDisasm( void )
{

	BOOL bResult = TRUE;
	UIDebug	dbgUI;
	UIDAM uidam = dbgUI.ShowDockWindow(IDW_DISASSY_WIN);

	if( VERIFY_TEST_SUCCESS(uidam.IsActive()) )
	{
		m_szErrorText = "Disassembly window is not active";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else
	{
		m_szDisasm = uidam.GetInstruction(-1,1);

		if( VERIFY_TEST_SUCCESS(m_szDisasm.Find(m_szComment) ) )	// position 58
		{
			m_szErrorText = "Read comment string "+m_szComment+
							" in disasm window failed";
			m_pLog->Comment( m_szErrorText );
			bResult = FALSE;
		}
	}

	dbgUI.ShowDockWindow(IDW_DISASSY_WIN, FALSE);
	return bResult;
}

BOOL CFILENAMEIDETest::QuickWatchTest( void )
{

	BOOL bResult = TRUE;

	if( VERIFY_TEST_SUCCESS(dbg.SetSteppingMode(SRC)) )
	{
		m_szErrorText = "Set debug stepping mode to SRC failed";
		m_pLog->Comment( m_szErrorText );
	}
	else if( VERIFY_TEST_SUCCESS(dbg.StepOver(2)) )
	{
		m_szErrorText = "Stepping over 2 lines failed";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(qw.Enable()) )
	{
		m_szErrorText = "Quick watch dialog could not be enabled (1st time)";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(qw.ExpressionValueIs( m_szQWExpr1, 1 )) )
	{
		m_szErrorText = "Quick watch expression: "+m_szQWExpr1+"did not equal 1";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(qw.Disable()) )
	{
		m_szErrorText = "Quick watch dialog could not be disabled (1st time)";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(dbg.StepOver(1)) )
	{
		m_szErrorText = "Stepping over 1 line failed";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(qw.Enable()) )
	{
		m_szErrorText = "Quick watch dialog could not be enabled (2nd time)";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(qw.ExpressionValueIs( m_szQWExpr2, 48 )) )
	{
		m_szErrorText = "Quick watch expression: "+m_szQWExpr2+"did not equal 48";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(qw.Disable()) )
	{
		m_szErrorText = "Quick watch dialog could not be disabled (2nd time)";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}

	return bResult;
}

BOOL CFILENAMEIDETest::MemoryTest( void )
{

	BOOL bResult = TRUE;
	UIOptionsTabDlg	uiopt;
	UIMemory		uimem;
	COSource		src;	// WinslowF - added to call GoToLine. It's not in UIWB any more.
	UIDebug			dbgUI;

	UIWB.SetMemoryFormat(MEM_FORMAT_ASCII);			// Re-enable after fixed
	if( VERIFY_TEST_SUCCESS(!uiopt.SetOption(TAB_DEBUG, VCPP32_IDC_DEBUG_FORMAT, MEM_WIN_ASCII )) )
	{
		m_szErrorText = "Memory window to ASCII mode failed";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else 
	{
		MST.WButtonClick(GetLabel(IDOK));				//	uiopt.Close(); is broken
		uimem = dbgUI.ShowDockWindow(IDW_MEMORY_WIN);
		if( VERIFY_TEST_SUCCESS(uimem.IsActive()) )
		{
			m_szErrorText = "Memory window was not active";
			m_pLog->Comment( m_szErrorText );
			bResult = FALSE;
		}
		else if( VERIFY_TEST_SUCCESS(src.GoToLine("*pch")) )
		{
			m_szErrorText = "Could not goto address of *pch";
			m_pLog->Comment( m_szErrorText );
			bResult = FALSE;
		}
		else
		{
			// This grabs 4 characters (4 bytes)
			m_szMemBuf = uimem.GetCurrentChars(4);
			m_szErrorText = "Retrieved: uimem.GetCurrentChars(4) = "+m_szMemBuf;
			m_pLog->Comment( m_szErrorText );

			if( VERIFY_TEST_SUCCESS(!m_szMemBuf.Compare(m_szMem1)) )
			{
				m_szErrorText = "string from memory differed, check src code.";
				m_pLog->Comment( m_szErrorText );
				bResult = FALSE;
			}
		
			// set 8 bytes (8 characters)
			if( VERIFY_TEST_SUCCESS(uimem.SetCurrentChars(m_szMem2)) )
			{
				m_szErrorText = "Setting memory with "+m_szMem2+" failed";
				m_pLog->Comment( m_szErrorText );
				bResult = FALSE;
			}
			m_szMemBuf = uimem.GetCurrentChars(8);
			m_szErrorText = "Retrieved: uimem.GetCurrentChars(8) = "+ m_szMem2 + m_szMem2;
			m_pLog->Comment( m_szErrorText );

			if( VERIFY_TEST_SUCCESS(!m_szMemBuf.Compare(m_szMem2 + m_szMem2)) )
			{
				m_szErrorText = "string "+m_szMem2+" from memory differed, "
								"check src code.";
				m_pLog->Comment( m_szErrorText );
				bResult = FALSE;
			}
		}
		dbgUI.ShowDockWindow(IDW_MEMORY_WIN, FALSE);
	}

	return bResult;
}

BOOL CFILENAMEIDETest::ENDThisTest( void )
{
	BOOL bResult = TRUE;

	/* if( VERIFY_TEST_SUCCESS ( dbg.StopDebugging(6) ) );
	{
		m_szErrorText = "can't stop debugging";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}

	if( VERIFY_TEST_SUCCESS ( proj.Close() ) );
	{
		m_szErrorText = "can't close the project";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	*/
	UIWBFrame  dbgFrame;

	dbg.StopDebugging();
	Sleep(10);
	dbgFrame.CloseAllWindows();
//	dbgFrame.CloseProject();
	Sleep(10);
	KillAllFiles((const char*) szRootDir, TRUE);
	Sleep(20);

return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Lfn\bin\src\file2.cpp ===
#include "mainfile.h"

TCHAR glbDBNumbers[21];

int file_two()
{
TCHAR *pch = glbDBNumbers;
TCHAR *t1 = "9876543210", *t2 = "0123456789";

_tcscpy( glbDBNumbers, STR_NUMBERS ); //            This is a comment

_tccpy( pch, t1 );

/*
	pch now points to '9' character
*/

_tccpy( pch, t2 );

return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Lfn\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		WinslowF		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Lfn\bin\src\mainfile.h ===
#define _MBCS
#include <stdio.h>
#include <tchar.h>

#define STR_NUMBERS "0123456789"

extern TCHAR glbDBNumbers[21];

int main(int,char *[]);
int file_two(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Lfn\bin\src\mainfile.cpp ===
#include "mainfile.h"

TCHAR *glbString1 = "Global string one";
TCHAR *glbString2 = "Global string two";


int main( int argc, char *argv[] )
{
TCHAR *locString1 = "Local string one";
TCHAR *locString2 = "Local string two";
TCHAR *locString3 = "Local String three";		// Days of the week
TCHAR locStrArray[10];

locStrArray[0] = 'O';
locStrArray[1] = 'L';
locStrArray[2] = 'Y';
locStrArray[3] = 'M';
locStrArray[4] = 'P';
locStrArray[5] = 'U';
locStrArray[6] = 'S';
locStrArray[7] = '\0';

file_two();

printf( "%s %s\n", glbString1, glbString2 );
printf( "%s %s\n", locString1, locString2 );
printf( "Is this local string 3?: %s\n", locString3 );
printf( "Global string in file2?: %s\n", glbDBNumbers );

return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\MBC_Sniff\Bin\src\file2.cpp ===
#include "mbctest.h"

TCHAR glbDBNumbers[21];

int file_two()
{
TCHAR *pch = glbDBNumbers;
TCHAR *t1 = "", *t2 = "O";				// = 8be0,O= 824f

_tcscpy( glbDBNumbers, DBC_NUMBERS );		// Copy PQRBBB

_tccpy( pch, t1 );

/*
	pch now points to '' DBCS character
*/

_tccpy( pch, t2 );


return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Lfn\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		WinslowF		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\MBC_Sniff\Bin\src\mbctest.h ===
#define _MBCS
#include <stdio.h>
#include <tchar.h>

#define DBC_NUMBERS "OPQRSTUVWX"

extern TCHAR glbDBNumbers[21];

int main(int,char *[]);
int file_two(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\MBC_Sniff\src\dbg_sub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CDbg_mbcSubSuite class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "Dbg_sub.h"

#include "Dbg_case.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CDbg_mbcSubSuite

IMPLEMENT_SUBSUITE(CDbg_mbcSubSuite, CIDESubSuite, "DBG MBC Sniff Tests", "MichMa X64633")

BEGIN_TESTLIST(CDbg_mbcSubSuite)
	TEST(CDbg_mbcIDETest, RUN)
END_TESTLIST()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\MBC_Sniff\src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\MBC_Sniff\src\dbcstr.h ===
/* strings */
#define IDS_TESTMAINFILE    11
#define IDS_TEST2NDFILE		12
#define IDS_TESTDIR			13
#define	IDS_COMMENT			14
#define IDS_MEM1			15
#define IDS_MEM2			16
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\MBC_Sniff\Bin\src\mbctest.cpp ===
#include "mbctest.h"

TCHAR *glbHiragana = "Ȃ͂܂";
TCHAR *glbKatakana = "AJT^in}p";


int main( int argc, char *argv[] )
{
TCHAR *locHiragana = "Ⴕサ傶Ⴖザƃ";
TCHAR *locKatakana = "ACEGIVVVWWWbg@BFtH";
TCHAR *locKanji    = "ΐ؋y";		// Days of the week
TCHAR locSBKana[10];

/*
	d         iJ^Jij
	D
*/
locSBKana[0] = '';
locSBKana[1] = '';
locSBKana[2] = '';
locSBKana[3] = '';
locSBKana[4] = '';
locSBKana[5] = '\0';

file_two();

_tprintf( "%s %s\n", glbHiragana, glbKatakana );
_tprintf( "Single byte kana: %s\n", locSBKana );
_tprintf( "Days of the week: %s\n", locKanji );
_tprintf( "DB Numbers      : %s\n", glbDBNumbers );

return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\MBC_Sniff\src\dbg_sub.h ===
///////////////////////////////////////////////////////////////////////////////
//	Dbg_sub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CDbg_mbcSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CDbg_mbcSubSuite class

class CDbg_mbcSubSuite : public CIDESubSuite
{
	DECLARE_SUBSUITE(CDbg_mbcSubSuite)

	DECLARE_TESTLIST()
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\MBC_Sniff\src\dbg_case.h ===
///////////////////////////////////////////////////////////////////////////////
//	Dbg_case.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CDbg_mbcIDETest Class
//

#ifndef __Dbg_case_H__
#define __Dbg_case_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "dbg_sub.h"

//
//	Macros
//
#define VERIFY_TEST_SUCCESS(TestCase)\
	((TestCase) == ERROR_SUCCESS)

#define VERIFY_BP_SUCCESS(BpCase)\
	((BpCase) != NULL)

// ComboBox index for Tools.Options.Debug Memory window format
#define MEM_WIN_ASCII	1
///////////////////////////////////////////////////////////////////////////////
//	CDbg_mbcIDETest class

class CDbg_mbcIDETest : public CTest
{
	DECLARE_TEST(CDbg_mbcIDETest, CDbg_mbcSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

// Test Cases
protected:
	void CopyFile(CString szFrom, CString szTo);
	void SetUp(void);
// Data
protected:
	/*
		Project/General
	*/
	CString		m_strCurDir;
	CString		m_szSourceDir;
	CString		m_szTestDir;
	CString		m_szProject;
	CString		m_szProjectFiles;
	CString		m_szNewIntermediateDir;
	CString		m_szNewOutputDir;
	CString		m_szErrorText;
	CString		m_szComment;
 	PROJOPTIONS ProjOptions;
  	COProject	proj;
	/*
		Breakpoint
	*/
	CString			m_szBPLocation;
	bp				*bpString;
	COBreakpoints	bp;

	/*
		Disassembly
	*/
	CString			m_szDisasm;

	/*
		Quick Watch
	*/
	CString			m_szQWExpr1;
	CString			m_szQWExpr2;
	
	/*
		Memory
	*/
	CString			m_szMemBuf;
	CString			m_szMem1;
	CString			m_szMem2;

	CODebug		dbg;
	COExpEval	qw;
	
// Test Cases
protected:
	BOOL CreateFileNameList(CStringList *szFileList);
	BOOL CreateBuildProject( void );
	BOOL CreateProject( void );    // not really a dbg test
	BOOL SetBreakpoints( void );
	BOOL ReadDBCSource( void );
	BOOL ReadDBCDisasm( void );
	BOOL QuickWatchTest( void );
	BOOL MemoryTest( void );
	BOOL ENDThisTest( void );

// Test Cases
protected:

};

void CreateDirectoryLong(const char *path);

#endif //__Dbg_case_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\MBC_Sniff\src\src\mbctest.cpp ===
#include "mbctest.h"

TCHAR *glbHiragana = "Ȃ͂܂";
TCHAR *glbKatakana = "AJT^in}p";


int main( int argc, char *argv[] )
{
TCHAR *locHiragana = "Ⴕサ傶Ⴖザƃ";
TCHAR *locKatakana = "ACEGIVVVWWWbg@BFtH";
TCHAR *locKanji    = "ΐ؋y";		// Days of the week
TCHAR locSBKana[10];

/*
	d         iJ^Jij
	D
*/
locSBKana[0] = '';
locSBKana[1] = '';
locSBKana[2] = '';
locSBKana[3] = '';
locSBKana[4] = '';
locSBKana[5] = '\0';

file_two();

_tprintf( "%s %s\n", glbHiragana, glbKatakana );
_tprintf( "Single byte kana: %s\n", locSBKana );
_tprintf( "Days of the week: %s\n", locKanji );
_tprintf( "DB Numbers      : %s\n", glbDBNumbers );

return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\MBC_Sniff\src\src\mbctest.h ===
#define _MBCS
#include <stdio.h>
#include <tchar.h>

#define DBC_NUMBERS "OPQRSTUVWX"

extern TCHAR glbDBNumbers[21];

int main(int,char *[]);
int file_two(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\MBC_Sniff\src\dbg_case.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Dbg_case.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "Dbg_case.h"	
#include "dbcstr.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
/* #define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS
*/												 

/*
	Source files in szSrcDir
*/
static CString szSrcMainFile	= "mbctest";
static CString szSrc2ndFile		= "file2";

/*
	Destination files in szTestDir
*/
CString szTestMainFile;  // the dbc string will be loaded from sniff.rc
CString szTest2ndFile;   // the dbc string will be loaded from sniff.rc

/*
	Source directory
*/
static CString szSrcDir		= "src";

/*
	Destination directory
*/
CString szTestDir = "test";       // the dbc string will be loaded from sniff.rc


static CString szBackslash = "\\";

IMPLEMENT_TEST(CDbg_mbcIDETest, CTest, "DBG MBC test", -1, CDbg_mbcSubSuite)

void CDbg_mbcIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CDbg_mbcIDETest::Run(void)
{
	UIDebug dbgUI;
	UIOptionsTabDlg uifn;

	XSAFETY;

	/*
		Copy project from src to test directory.  test will be a DBC dir.
	*/
	SetUp();
	
		IME.Open();
		Sleep(500);
		IME.Enable(); 
		Sleep(500); 
		IME.SetMode(CIME::HIRAGANA, 2);

//		Set a J font
//		uifn.SetFont(13 /*"lr@SVbN" */); // This should be set by default now.

		m_szErrorText = "->>CreateBuild project";
		m_pLog->Comment( m_szErrorText );
		EXPECT( CreateBuildProject() );
		m_szErrorText = "->>Set break points";
		m_pLog->Comment( m_szErrorText );
		EXPECT( SetBreakpoints() );
		EXPECT( ReadDBCSource() );
//		EXPECT(dbgUI.ShowDockWindow(IDW_OUTPUT_WIN, TRUE));	// it works fine but returns FALSE which makes test failing 
		dbgUI.ShowDockWindow(IDW_OUTPUT_WIN);
		m_szErrorText = "->>Show registers";
		m_pLog->Comment( m_szErrorText );
		EXPECT(dbgUI.ShowDockWindow(IDW_CPU_WIN, TRUE));
		m_szErrorText = "->>Show callstack";
		m_pLog->Comment( m_szErrorText );
		EXPECT(dbgUI.ShowDockWindow(IDW_CALLS_WIN, TRUE));
		EXPECT(dbg.SetSteppingMode(SRC));	
		EXPECT( ReadDBCDisasm() );
		m_szErrorText = "->>QuickWatch test";
		m_pLog->Comment( m_szErrorText );
		EXPECT( QuickWatchTest() );
		m_szErrorText = "->>Memory test";
		m_pLog->Comment( m_szErrorText );
		EXPECT( MemoryTest() );

		IME.SetMode(CIME::ALPHA, 1);

		m_szErrorText = "->>End test";  
		m_pLog->Comment( m_szErrorText );
		EXPECT( ENDThisTest() );

	XSAFETY;


}


void CDbg_mbcIDETest::CopyFile(CString szFrom, CString szTo)
{
	CString	szDestination = m_szTestDir+szBackslash+szTo;

	SetFileAttributes(szDestination,FILE_ATTRIBUTE_NORMAL);				// Unset READONLY
	::CopyFile( m_szSourceDir+szBackslash+szFrom, szDestination, FALSE );
	SetFileAttributes(szDestination,FILE_ATTRIBUTE_NORMAL);				// Unset READONLY
}


void CDbg_mbcIDETest::SetUp()
{


	char* psz = m_strCurDir.GetBufferSetLength(_MAX_DIR);


	/*
	** obtain the dbc names from the string table.
	*/

    szTestMainFile.LoadString (IDS_TESTMAINFILE);
    szTest2ndFile.LoadString (IDS_TEST2NDFILE);
    szTestDir.LoadString (IDS_TESTDIR);
    m_szComment.LoadString (IDS_COMMENT);
    m_szMem1.LoadString (IDS_MEM1);
    m_szMem2.LoadString (IDS_MEM2);


	GetCurrentDirectory(_MAX_DIR - 1, psz);
	m_strCurDir.ReleaseBuffer(-1);
	if( m_strCurDir.Right(1) != '\\' )
		m_strCurDir += szBackslash;

	m_szSourceDir	= m_strCurDir + szSrcDir;
	m_szTestDir		= m_strCurDir + szTestDir;

	// delete test dir so we don't get error when re-creating project.
	KillAllFiles(m_szTestDir, TRUE);

//	m_szProject		= m_szTestDir+szBackslash+szTestMainFile+".mak";
	m_szProject		= m_szTestDir+szBackslash+szTestMainFile;

	m_szBPLocation	= "{,"+szTest2ndFile+".cpp,}file_two";
	m_szQWExpr1		= "{file_two,"+szTest2ndFile+".cpp,}pch==glbDBNumbers";
	m_szQWExpr2		= "(int)*pch";

	m_szProjectFiles	= m_szTestDir + "\\*.cpp";
	m_szNewIntermediateDir = m_szTestDir;
	m_szNewOutputDir = m_szTestDir;

	ProjOptions.szDir	= m_strCurDir;
	ProjOptions.szName	= szTestMainFile;
	ProjOptions.iType	= CONSOLE_APP;
	ProjOptions.szNewSubDir = szTestDir;


//	KillAllFiles((const char*) szTestDir, TRUE);
	/*
		Copy mbctest.mak project to m_szTestDir from the m_szSourceDir
	*/
 	CreateDirectoryLong( (const char*) szTestDir);  

	::CopyFile( m_szSourceDir + szBackslash + szSrcMainFile+".h",   m_szTestDir + szBackslash + szSrcMainFile+".h", FALSE );
	::CopyFile( m_szSourceDir + szBackslash + szSrcMainFile+".cpp", m_szTestDir + szBackslash + szTestMainFile+".cpp", FALSE );
	::CopyFile( m_szSourceDir + szBackslash + szSrc2ndFile+".cpp",  m_szTestDir + szBackslash + szTest2ndFile+".cpp", FALSE );

	// SetFileAttributes( m_szProject, FILE_ATTRIBUTE_NORMAL );	// Remove RO flag

	::SetFileAttributes( m_szTestDir + szBackslash + szSrcMainFile+".h" , FILE_ATTRIBUTE_NORMAL );	// Remove RO flag
	::SetFileAttributes( m_szTestDir + szBackslash + szTestMainFile+".cpp" , FILE_ATTRIBUTE_NORMAL );	// Remove RO flag
	::SetFileAttributes( m_szTestDir + szBackslash + szTest2ndFile+".cpp" , FILE_ATTRIBUTE_NORMAL );	// Remove RO flag

	Sleep(10);
}


///////////////////////////////////////////////////////////////////////////////
//	Test Cases


BOOL CDbg_mbcIDETest::CreateBuildProject(  )
{

	BOOL bResult = TRUE;
	UIOptionsTabDlg	uiopt;


// the IDE's UI has changed regarding setting fonts and this no longer works.
// Temporarily will not be used until have time to change cafe.
#if 0  
	if( VERIFY_TEST_SUCCESS( !uiopt.SetOption(TAB_FONTS, VCPP32_IDC_FONTLIST, "Fixedsys" )) )
	{
		m_szErrorText = "Default font set to Fixedsys failed";
		m_pLog->Comment( m_szErrorText );
		/*
			Clean up??? How to recover from this?
		*/
	}
	else
	{
//		MST.WButtonClick(GetLabel(VCPP32_IDC_USEASDEFAULT));
		MST.WButtonClick(GetLabel(IDOK));				//	uiopt.Close(); is broken
	}
#endif

	if( VERIFY_TEST_SUCCESS( CreateProject() ) )
	{
		m_szErrorText = "Internal makefile "+m_szProject+" could not be created";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(!proj.RebuildAll(6)) )
	{
		m_szErrorText = "Build of "+m_szProject+" failed";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}

	return bResult;	
}

/*
** create the project.  Instead of using a static .mak file which 
** becomes obsolete with changes to the project facility, create
** the project each time.  The project source files are static.
** We also get some freebies regarding setting target, because
** since we generate the makefile on the desired platform it will
** be the default target.
*/
BOOL CDbg_mbcIDETest::CreateProject( void )
{
	m_pLog->Comment( "	-> Project.New" );
	if ( proj.New( ProjOptions ) != ERROR_SUCCESS)
	{
		m_szErrorText = "unable to create new project";
		m_pLog->Comment( m_szErrorText );
		return FALSE;
	}

	m_pLog->Comment( "	-> Project.Addfiles" );
	if ( proj.AddFiles( m_szProjectFiles ) != ERROR_SUCCESS)
	{
		m_szErrorText = "adding files to project failed";
		m_pLog->Comment( m_szErrorText );
		return FALSE;
	}

	// workaround to the new project window (it can be hiden at this time)
	proj.ActivateProjWnd();

	//set intermediate directory
	m_pLog->Comment( "	-> Project.SetProjProperty" );
	if ( proj.SetProjProperty(CT_GENERAL,
			VPROJ_IDC_OUTDIRS_INT, 
			m_szNewIntermediateDir) != ERROR_SUCCESS)
	{
		m_szErrorText = "setting intermediated directory failed";
		m_pLog->Comment( m_szErrorText );
		return FALSE;
	}

	//set output directory
	m_pLog->Comment( "	-> Project.SetProjOutputDir" );
	if (proj.SetProjProperty(CT_GENERAL,
			VPROJ_IDC_OUTDIRS_TRG, 
			m_szNewOutputDir) != ERROR_SUCCESS)
	{
		m_szErrorText = "setting output directory failed";
		m_pLog->Comment( m_szErrorText );
		return FALSE;
	}

	return TRUE;
}

BOOL CDbg_mbcIDETest::SetBreakpoints(  )
{

	BOOL bResult = TRUE;
	
	bp.ClearAllBreakpoints();

	if( VERIFY_BP_SUCCESS(!bp.SetBreakpoint(m_szBPLocation)) )
	{
		m_szErrorText = "Could not set breakpoint on "+m_szBPLocation;
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	return bResult;	
}

void CreateDirectoryLong(const char *path)
{
	char CurrentDir[_MAX_DIR], StartDir[_MAX_DIR], buf[_MAX_DIR], szPath[_MAX_DIR];
	char *chPtr;

	GetCurrentDirectory(_MAX_DIR - 1, CurrentDir);
	strcpy(StartDir, CurrentDir);
	strcpy (szPath, path);
	chPtr = strchr(szPath, '\\');
	while(chPtr)
	{
		*chPtr = '\0';
		strcpy(buf, szPath);
		CreateDirectory(buf, NULL);
		GetCurrentDirectory(_MAX_DIR - 1, CurrentDir);
		SetCurrentDirectory(CurrentDir + szBackslash + buf);
		strcpy(szPath, ++chPtr);
		chPtr = strchr(szPath, '\\');
	}

	strcpy(buf, szPath);
	CreateDirectory(buf, NULL);
	SetCurrentDirectory(StartDir);
	
}

BOOL CDbg_mbcIDETest::ReadDBCSource(  )
{

	BOOL bResult = TRUE;
	int NStep;


#if defined( _MIPS_ )
	NStep = 2;
#else
	NStep = 3;
#endif


	if( VERIFY_TEST_SUCCESS(dbg.Go()) )
	{
		m_szErrorText = "Go to breakpoint";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}

	else if( VERIFY_TEST_SUCCESS(dbg.StepOver(NStep, NULL, m_szComment )) )	  // "OPQRBBB"
	{
		m_szErrorText = "Read DBC comment "+m_szComment+" in source failed, via StepOver";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}

	return bResult;	
}

BOOL CDbg_mbcIDETest::ReadDBCDisasm(  )
{

	BOOL bResult = TRUE;
	UIDebug	dbgUI;
	UIDAM uidam = dbgUI.ShowDockWindow(IDW_DISASSY_WIN);

	if( VERIFY_TEST_SUCCESS(uidam.IsActive()) )
	{
		m_szErrorText = "Disassembly window is not active";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else
	{
		m_szDisasm = uidam.GetInstruction(-1,1);

		if( VERIFY_TEST_SUCCESS(m_szDisasm.Find(m_szComment)) )	// position 58??? I don't think so.
		{
			m_szErrorText = "Read DBC comment string "+m_szComment+
							" in disasm window failed";
			m_pLog->Comment( m_szErrorText );
			bResult = FALSE;
		}
	}

	return bResult;	
}

BOOL CDbg_mbcIDETest::QuickWatchTest( void )
{

	BOOL bResult = TRUE;

	if( VERIFY_TEST_SUCCESS(dbg.SetSteppingMode(SRC)) )
	{
		m_szErrorText = "Set debug stepping mode to SRC failed";
		m_pLog->Comment( m_szErrorText );
	}
	else if( VERIFY_TEST_SUCCESS(dbg.StepOver(2)) )
	{
		m_szErrorText = "Stepping over 2 lines failed";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(qw.Enable()) )
	{
		m_szErrorText = "Quick watch dialog could not be enabled (1st time)";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(qw.ExpressionValueIs( m_szQWExpr1, 1 )) )
	{
		m_szErrorText = "Quick watch expression: "+m_szQWExpr1+"did not equal 1";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(qw.Disable()) )
	{
		m_szErrorText = "Quick watch dialog could not be disabled (1st time)";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(dbg.StepOver(1)) )
	{
		m_szErrorText = "Stepping over 1 line failed";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(qw.Enable()) )
	{
		m_szErrorText = "Quick watch dialog could not be enabled (2nd time)";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(qw.ExpressionValueIs( m_szQWExpr2, -126 )) )
	{
		m_szErrorText = "Quick watch expression: "+m_szQWExpr2+"did not equal -117";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else if( VERIFY_TEST_SUCCESS(qw.Disable()) )
	{
		m_szErrorText = "Quick watch dialog could not be disabled (2nd time)";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}

	return bResult;	
}

BOOL CDbg_mbcIDETest::MemoryTest( void )
{

	BOOL bResult = TRUE;
	UIOptionsTabDlg	uiopt;
	UIMemory		uimem;
	COSource		src;	// WinslowF - added to call GoToLine. It's not in UIWB any more.
	UIDebug			dbgUI;

	UIWB.SetMemoryFormat(MEM_FORMAT_ASCII);			// Re-enable after fixed
	if( VERIFY_TEST_SUCCESS(!uiopt.SetOption(TAB_DEBUG, VCPP32_IDC_DEBUG_FORMAT, MEM_WIN_ASCII )) )
	{
		m_szErrorText = "Memory window to ASCII mode failed";
		m_pLog->Comment( m_szErrorText );
		bResult = FALSE;
	}
	else 
	{
		MST.WButtonClick(GetLabel(IDOK));				//	uiopt.Close(); is broken
		uimem = dbgUI.ShowDockWindow(IDW_MEMORY_WIN);
		if( VERIFY_TEST_SUCCESS(uimem.IsActive()) )
		{
			m_szErrorText = "Memory window was not active";
			m_pLog->Comment( m_szErrorText );
			bResult = FALSE;
		}
		else if( VERIFY_TEST_SUCCESS(src.GoToLine("*pch")) )
		{
			m_szErrorText = "Could not goto address of *pch";
			m_pLog->Comment( m_szErrorText );
			bResult = FALSE;
		}
		else
		{
			uimem = dbgUI.ShowDockWindow(IDW_MEMORY_WIN);
			// This grabs 4 DBC characters (8 bytes)
			m_szMemBuf = uimem.GetCurrentChars(4);
			m_szErrorText = "Retrieved: uimem.GetCurrentChars(4) = "+m_szMemBuf;
			m_pLog->Comment( m_szErrorText );

			if( VERIFY_TEST_SUCCESS(!m_szMemBuf.Compare(m_szMem1)) )
			{
				m_szErrorText = "DBC string from memory differed, check src code.";
				m_pLog->Comment( m_szErrorText );
				bResult = FALSE;
			}
		
			// set 12 bytes (8 characters)
			if( VERIFY_TEST_SUCCESS(uimem.SetCurrentChars(m_szMem2)) )
			{
				m_szErrorText = "Setting memory with "+m_szMem2+" failed";
				m_pLog->Comment( m_szErrorText );
				bResult = FALSE;
			}

			m_szMemBuf = uimem.GetCurrentChars(8);
			m_szErrorText = "Retrieved: uimem.GetCurrentChars(8) = "+m_szMem2;
			m_pLog->Comment( m_szErrorText );

			if( VERIFY_TEST_SUCCESS(!m_szMemBuf.Compare(m_szMem2)) )
			{
				m_szErrorText = "DBC string "+m_szMem2+" from memory differed, "
								"check src code.";
				m_pLog->Comment( m_szErrorText );
				bResult = FALSE;
			}
		}
	}
	return bResult;	
}

BOOL CDbg_mbcIDETest::ENDThisTest( void )
{
	BOOL bResult = TRUE;

	UIWBFrame  dbgFrame;

	dbg.StopDebugging();
	Sleep(10);
	dbgFrame.CloseAllWindows();
	Sleep(10);
//	KillAllFiles((const char*) szTestDir, TRUE);
	Sleep(20);

return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Scenarios\ISAPIDebugging\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\MBC_Sniff\src\src\file2.cpp ===
#include "mbctest.h"

TCHAR glbDBNumbers[21];

int file_two()
{
TCHAR *pch = glbDBNumbers;
TCHAR *t1 = "", *t2 = "O";				// = 8be0,O= 824f

_tcscpy( glbDBNumbers, DBC_NUMBERS );		// Copy PQRBBB

_tccpy( pch, t1 );

/*
	pch now points to '' DBCS character
*/

_tccpy( pch, t2 );


return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\MBC_Sniff\src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Scenarios\ISAPIDebugging\ISAPIDebuggingSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	ISAPIDebuggingSubsuite.h
//
//	Created by: MichMa		Date: 11/20/97
//
//	Description:
//		Declaration of CISAPIDebuggingSubsuite

#ifndef __ISAPIDEBUGGINGSUBSUITE_H__
#define __ISAPIDEBUGGINGSUBSUITE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CISAPIDebuggingSubsuite class

class CISAPIDebuggingSubsuite : public CIDESubSuite

{
	DECLARE_SUBSUITE(CISAPIDebuggingSubsuite)
	DECLARE_TESTLIST();

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
};

#endif //__ISAPIDEBUGGINGSUBSUITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Scenarios\ISAPIDebugging\ISAPIDebuggingSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ISAPIDebuggingSubsuite.cpp
//
//	Created by: MichMa		Date: 11/20/97
//
//	Description:
//		Implementation of CISAPIDebuggingSubsuite

#include "stdafx.h"
#include "afxdllx.h"
#include "ISAPIDebuggingSubsuite.h"
#include "ISAPIDebuggingCases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CISAPIDebuggingSubsuite

IMPLEMENT_SUBSUITE(CISAPIDebuggingSubsuite, CIDESubSuite, "ISAPI Debugging Scenario", "MichMa")

BEGIN_TESTLIST(CISAPIDebuggingSubsuite)
	TEST(CISAPIDebuggingCases, RUN)
END_TESTLIST()

void CISAPIDebuggingSubsuite::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Scenarios\ISAPIDebugging\ISAPIDebuggingCases.h ===
///////////////////////////////////////////////////////////////////////////////
//	ISAPIDebuggingCases.h
//
//	Created by: MichMa		Date: 11/20/97
//
//	Description:
//		Declaration of CISAPIDebuggingCases

#ifndef __ISAPIDEBUGGINGCASES_H__
#define __ISAPIDEBUGGINGCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "ISAPIDebuggingSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CISAPIDebuggingCases class

class CISAPIDebuggingCases : public CTest

{
	DECLARE_TEST(CISAPIDebuggingCases, CISAPIDebuggingSubsuite)

public:
	// Operations
	virtual void Run(void);
};

#endif //__ISAPIDEBUGGINGCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Scenarios\ISAPIDebugging\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Scenarios\ISAPIDebugging\ISAPIDebuggingCases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ISAPIDebuggingCases.cpp
//
//	Created by: MichMa		Date: 11/20/97
//
//	Description:
//		Implementation of CISAPIDebuggingCases

#include "stdafx.h"
#include "ISAPIDebuggingCases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CISAPIDebuggingCases, CTest, "ISAPI Debugging Scenario", -1, CISAPIDebuggingSubsuite)


void CISAPIDebuggingCases::Run(void)

{
	// support layer objects we will use for this scenario.
	COProject prj;
	COHTML html;
	CODebug dbg;
	COBreakpoints bps;
	COStack stk;
	COSource src;
	COExpEval ee;
	COLocals locals;
	CORegisters regs;
	CODAM dam;
	COMemory mem;

	// we need to know the system drive, system root, and computer name to figure out where to put 
	// the isapi extension dll, the html page that calls it, and also how to browse the page.
	char szBuffer[_MAX_PATH];
	GetEnvironmentVariable("SystemDrive", szBuffer, _MAX_PATH);
	CString strSysDrive = szBuffer;
	GetEnvironmentVariable("SystemRoot", szBuffer, _MAX_PATH);
	CString strSysRoot = szBuffer;
	GetEnvironmentVariable("COMPUTERNAME", szBuffer, _MAX_PATH);
	CString strComputerName = szBuffer;

	// set the base name for the project and html page we will be using, dependent on the os language.
	// TODO(michma 11/21/97): does iis/ie support spaces and/or mbcs chars in isapi extensions or html pages?
	CString strProjBase;
	//if(GetSystem() & SYSTEM_DBCS)
	//	strProjBase = "[\\]^{|}Aa`@~ ISAPI Extension";
	//else
		strProjBase = "ISAPIExtension";

	// clean up the last isapi extension project used (if any).
	KillAllFiles(strProjBase);
	
	// set the name and location of the atl com server project. we also want the project to be added to
	// the current workspace, and made a subproject of the main app project.
	CProjWizOptions *pISAPIExtensionWizOpt = new(CISAPIExtensionWizOptions);
	pISAPIExtensionWizOpt->m_strLocation = GetCWD();
	pISAPIExtensionWizOpt->m_strName = strProjBase;	
	
	// create the isapi extension project.
	if(prj.New(pISAPIExtensionWizOpt) == ERROR_SUCCESS)
		LOG->RecordSuccess("Create ISAPI Extension project named '%s'.", strProjBase);
	else
	{
		LOG->RecordFailure("Create ISAPI Extension project named '%s'.", strProjBase);
		return;
	}
	
	// open the main source file of the isapi extension project.
	if(src.Open(strProjBase + ".cpp") == ERROR_SUCCESS)
		LOG->RecordSuccess("Open source file '%s.cpp'.", strProjBase);
	else
	{
		LOG->RecordFailure("Open source file '%s.cpp'.", strProjBase);
		return;
	}

	// find the Default function of the ISAPI extension so we can add code in and around it.
	if(src.Find("void CISAPIExtensionExtension::Default"))
		LOG->RecordSuccess("Find Default function of ISAPI extension.");
	else
	{
		LOG->RecordFailure("Find Default function of ISAPI extension.");
		return;
	}

	// add code in and around the Default function of the ISAPI extension.
	LOG->RecordInfo("Adding code in and around the Default function of the ISAPI extension.");
	src.TypeTextAtCursor("{HOME}int global = 0;{ENTER 2}");
	src.TypeTextAtCursor("void func(void)", TRUE);
	src.TypeTextAtCursor("{ENTER}");
	src.TypeTextAtCursor("{", TRUE);
	src.TypeTextAtCursor("{TAB}// first line of func.{ENTER}");
	src.TypeTextAtCursor("global");
	src.TypeTextAtCursor("++;", TRUE);
	src.TypeTextAtCursor("{ENTER}");
	src.TypeTextAtCursor("}", TRUE);
	src.TypeTextAtCursor("{TAB}// line after global changes.{ENTER 2}{DOWN 2}");
	src.TypeTextAtCursor("{TAB}int local = 0;{ENTER}{DOWN 2}");
	src.TypeTextAtCursor("func();", TRUE);
	src.TypeTextAtCursor("{TAB}// first call to func.{ENTER}");
	src.TypeTextAtCursor("func();", TRUE);
	src.TypeTextAtCursor("{TAB}// second call to func.{ENTER}");
	src.TypeTextAtCursor("while(0);", TRUE);
	src.TypeTextAtCursor("{TAB}// line after second call to func.{ENTER}{DOWN 4}");
	src.TypeTextAtCursor("local");
	src.TypeTextAtCursor("++;", TRUE);
	src.TypeTextAtCursor("{ENTER}");

	// build the project.
	if(prj.Build() == ERROR_SUCCESS)
		LOG->RecordSuccess("Build '%s' project.", strProjBase);
	else
	{
		LOG->RecordFailure("Build '%s' project.", strProjBase);
		return;
	}
	
	// verify no errors or warnings were generated.
	int iErr, iWarn;
	if(prj.VerifyBuild(TRUE, &iErr, &iWarn, TRUE) == ERROR_SUCCESS)
		LOG->RecordSuccess("Verify build of '%s' project.", strProjBase);
	else
	{
		LOG->RecordFailure("Verify build of '%s' project.", strProjBase);
		return;
	}

	// copy the isapi extension dll to the scripts directory of the server (overwrite if it exists).
	if(CopyFile(strProjBase + "\\Debug\\" + strProjBase + ".dll", 
				strSysDrive + "\\InetPub\\scripts\\" + strProjBase + ".dll", FALSE))
		LOG->RecordSuccess("Copy ISAPI extension '%s' to the scripts directory of the server.", strProjBase + ".dll");
	else
	{
		LOG->RecordFailure("Copy ISAPI extension '%s' to the scripts directory of the server.", strProjBase + ".dll");
		return;
	}

	// create the html page that will call the isapi extension.
	if(html.Create(strProjBase, strProjBase) == ERROR_SUCCESS)
		LOG->RecordSuccess("Create HTML page named '%s.htm'.", strProjBase);
	else
	{
		LOG->RecordFailure("Create HTML page named '%s.htm'.", strProjBase);
		return;
	}

	// add the form that calls the isapi extension to the html page.
	LOG->RecordInfo("Adding the form that calls the ISAPI Extension to the HTML page.");
	html.TypeTextAtCursor("<form METHOD=\"POST\" ACTION=\"\\scripts\\" + strProjBase + ".dll\">{ENTER}");
	html.TypeTextAtCursor("<input type=\"submit\" value=\"Submit\">{ENTER}");
	html.TypeTextAtCursor("</form>{ENTER}");
	
	// save the changes to the html page.
	if(html.Save() == ERROR_SUCCESS)
		LOG->RecordSuccess("Saving changes to '%s.htm' HTML page.", strProjBase);
	else
	{
		LOG->RecordFailure("Saving changes to '%s.htm' HTML page.", strProjBase);
		return;
	}

	// copy the html page to the www root of the server (overwrite if it exists).
	if(CopyFile(strProjBase + "\\" + strProjBase + ".htm",
				strSysDrive + "\\InetPub\\wwwroot\\" + strProjBase + ".htm", FALSE))
		LOG->RecordSuccess("Copy HTML page '%s' to the www root of the server.", strProjBase + ".htm");
	else
	{
		LOG->RecordFailure("Copy HTML page '%s' to the www root of the server.", strProjBase + ".htm");
		return;
	}

	// set the executable for the debug session to be inetinfo.exe.
	if(prj.SetLocalTarget(strSysRoot + "\\system32\\inetsrv\\inetinfo.exe") == ERROR_SUCCESS)
		LOG->RecordSuccess("Set executable for debug session to 'inetinfo.exe'.");
	else
	{
		LOG->RecordFailure("Set executable for debug session to 'inetinfo.exe'.");
		return;
	}

	// set the program arguments for inetinfo.exe.
	if(prj.SetProgramArguments("-e W3Svc") == ERROR_SUCCESS)
		LOG->RecordSuccess("Set program arguments for 'inetinfo.exe' to '-e W3Svc'.");
	else
	{
		LOG->RecordFailure("Set program arguments for 'inetinfo.exe' to '-e W3Svc'.");
		return;
	}

	// set a bp in the Default function of the isapi extension.
	if(bps.SetBreakpoint("C" + strProjBase + "Extension::Default"))
		LOG->RecordSuccess("Set a bp in the 'Default' function of the ISAPI extension.");
	else
	{
		LOG->RecordFailure("Set a bp in the 'Default' function of the ISAPI extension.");
		return;
	}

	// launch inetinfo.exe under the debugger.
	if(dbg.Go(NULL, NULL, NULL, WAIT_FOR_RUN))
		LOG->RecordSuccess("Launch 'inetinfo.exe' under the debugger.");
	else
	{
		LOG->RecordFailure("Launch 'inetinfo.exe' under the debugger.");
		return;
	}

	// give inetinfo.exe a few seconds to publish the server. if we launch internet explorer too quickly after
	// inetinfo.exe, the server won't be published yet and ie won't find the html page.
	Sleep(10000);

	// CreateProcess() params for internet explorer.
   	STARTUPINFO siStartInfo;
	PROCESS_INFORMATION piProcInfo;
	// this is the minium initialization of STARTUPINFO required for CreateProcess() to work.
	memset(&siStartInfo, 0, sizeof(STARTUPINFO));
	siStartInfo.cb = sizeof(STARTUPINFO);
	siStartInfo.wShowWindow = SW_SHOWDEFAULT;
	// create the command line that will launch internet explorer and browse the html page that calls the isapi extension.
	strcpy(szBuffer, "iexplore.exe http://" + strComputerName + "/" + strProjBase + ".htm");

	// launch internet explorer and browse the html page that calls the isapi extension.
	SetLastError(0);
	
	if(CreateProcess(NULL, szBuffer, NULL, NULL, TRUE, 0, NULL, NULL, &siStartInfo, &piProcInfo))
		LOG->RecordSuccess("Launch Internet Explorer and browse HTML page '%s.htm'.", strProjBase);
	else
	{
		LOG->RecordFailure("Launch Internet Explorer and browse HTML page '%s.htm'. Error == %d.", 
			strProjBase, GetLastError());
		return;
	}
	
	// wait around 60 seconds looking for internet explorer with the html page loaded.
	// the default name that visual studio gives new html pages is "Document Title".
	if(MST.WFndWndWait("Document Title", FW_PART, 60))
		LOG->RecordSuccess("Verify that Internet Explorer has loaded html page '%s.htm'.", strProjBase);		
	else
	{
		LOG->RecordFailure("Verify that Internet Explorer has loaded html page '%s.htm'.", strProjBase);		
		return;
	}

	// submit html page form that calls the isapi extension (3 tabs puts focus on the "Submit" button).
	MST.DoKeys("{TAB 3}");
	MST.DoKeys("{ENTER}");

	// wait around 5 seconds in case a security alert dlg comes up.
	if(MST.WFndWndWaitC(GetLocString(IDSS_YES), "Button", FW_DEFAULT, 5))
		MST.WButtonClick(GetLocString(IDSS_YES));

	// wait for the debugger to break in the isapi extension's Default function.
	if(dbg.Wait(WAIT_FOR_BREAK))
		LOG->RecordSuccess("Wait for debugger to break in ISAPI extension's 'Default' function.");		
	else
	{
		LOG->RecordFailure("Wait for debugger to break in ISAPI extension's 'Default' function.");		
		return;
	}

	// verify that the current function is the ISAPI Extension's Default function.
	if(stk.CurrentFunctionIs("C" + strProjBase + "Extension::Default"))
		LOG->RecordSuccess("Verify current function is ISAPI Extension's 'Default' function.");		
	else
	{
		LOG->RecordFailure("Verify current function is ISAPI Extension's 'Default' function.");		
		return;
	}

	// enable disassembly debugging.
	if(dam.Enable())
		LOG->RecordSuccess("Enable disassembly debugging.");
	else
	{
		LOG->RecordFailure("Enable disassembly debugging.");
	}

	// enable access to registers.
	if(regs.Enable())
		LOG->RecordSuccess("Enable access to registers.");
	else
	{
		LOG->RecordFailure("Enable access to registers.");
	}
	
	// get back into source mode.
	dbg.SetSteppingMode(SRC);

	// find the first call to the function we added ("func()").
	if(src.Find("func();"))
		LOG->RecordSuccess("Find first call to function we added (\"func()\").");
	else
	{
		LOG->RecordFailure("Find first call to function we added (\"func()\").");
		return;
	}
	
	// step to cursor.
	if(dbg.StepToCursor())
		LOG->RecordSuccess("Step to cursor.");
	else
	{
		LOG->RecordFailure("Step to cursor.");
		return;
	}

	// verify debugger landed on first call to func().
	if(dbg.CurrentLineIs("first call to func"))
		LOG->RecordSuccess("Verify debugger landed on first call to func().");
	else
	{
		LOG->RecordFailure("Verify debugger landed on first call to func().");
		return;
	}

	// step over a function.
	if(dbg.StepOver())
		LOG->RecordSuccess("Step over a function.");
	else
	{
		LOG->RecordFailure("Step over a function.");
		return;
	}

	// verify debugger landed on second call to func().
	if(dbg.CurrentLineIs("second call to func"))
		LOG->RecordSuccess("Verify debugger landed on second call to func().");
	else
	{
		LOG->RecordFailure("Verify debugger landed on second call to func().");
		return;
	}

	// step into a function.
	if(dbg.StepInto())
		LOG->RecordSuccess("Step into a function.");
	else
	{
		LOG->RecordFailure("Step into a function.");
		return;
	}

	// verify debugger landed on first line of func().
	if(dbg.CurrentLineIs("first line of func"))
		LOG->RecordSuccess("Verify debugger landed on first line of func().");
	else
	{
		LOG->RecordFailure("Verify debugger landed on first line of func().");
		return;
	}

	// verify current function is func().
	if(stk.CurrentFunctionIs("func"))
		LOG->RecordSuccess("Verify current function is func().");		
	else
	{
		LOG->RecordFailure("Verify current function is func().");		
		return;
	}

	// step out of a function.
	if(dbg.StepOut())
		LOG->RecordSuccess("Step out of a function.");
	else
	{
		LOG->RecordFailure("Step out of a function.");
		return;
	}

	// verify debugger landed on line after second call to func().
	if(dbg.CurrentLineIs("line after second call to func"))
		LOG->RecordSuccess("Verify debugger landed on line after second call to func().");
	else
	{
		LOG->RecordFailure("Verify debugger landed on line after second call to func().");
		return;
	}

	// verify that the current function is the ISAPI Extension's Default function.
	if(stk.CurrentFunctionIs("C" + strProjBase + "Extension::Default"))
		LOG->RecordSuccess("Verify current function is ISAPI Extension's 'Default' function.");		
	else
	{
		LOG->RecordFailure("Verify current function is ISAPI Extension's 'Default' function.");		
		return;
	}

	// find the first call to func() again. the search should wrap here.
	if(src.Find("func();"))
		LOG->RecordSuccess("Find first call to func() again.");
	else
	{
		LOG->RecordFailure("Find first call to func() again.");
		return;
	}

	// set next statement.
	if(dbg.SetNextStatement())
		LOG->RecordSuccess("Set next statement.");
	else
	{
		LOG->RecordFailure("Set next statement.");
		return;
	}

	// verify the debugger landed on the first call to func().
	if(dbg.CurrentLineIs("first call to func"))
		LOG->RecordSuccess("Verify debugger landed on first call to func().");
	else
	{
		LOG->RecordFailure("Verify debugger landed on first call to func().");
		return;
	}

	// set a global data breakpoint.
	if(bps.SetBreakOnExpr("global", COBP_TYPE_IF_EXP_CHANGED))
		LOG->RecordSuccess("Set a global data breakpoint.");
	else
	{
		LOG->RecordFailure("Set a global data breakpoint.");
		return;
	}

	// go until the global data breakpoint is hit.
	if(dbg.Go())
		LOG->RecordSuccess("Go until the global data breakpoint is hit.");
	else
	{
		LOG->RecordFailure("Go until the global data breakpoint is hit.");
		return;
	}
	
	// verify the value of the global.
	if(ee.ExpressionValueIs("global", 3))
		LOG->RecordSuccess("Verify that value of global is 3.");		
	else
	{
		LOG->RecordFailure("Verify that value of global is 3.");		
		return;
	}

	// verify the debugger landed on the line after the global changes.
	if(dbg.CurrentLineIs("line after global changes"))
		LOG->RecordSuccess("Verify debugger landed on line after global changes.");
	else
	{
		LOG->RecordFailure("Verify debugger landed on line after global changes.");
		return;
	}

	// verify that the current function is func().
	if(stk.CurrentFunctionIs("func"))
		LOG->RecordSuccess("Verify current function is func().");		
	else
	{
		LOG->RecordFailure("Verify current function is func().");		
		return;
	}

	// navigate the stack back to the Default function.
	if(stk.NavigateStack(1))
		LOG->RecordSuccess("Navigate the stack back to the ISAPI Extension's 'Default' function.");		
	else
	{
		LOG->RecordFailure("Navigate the stack back to the ISAPI Extension's 'Default' function.");		
		return;
	}

	// verify the current line is the second call to func().
	if(dbg.CurrentLineIs("second call to func"))
		LOG->RecordSuccess("Verify current line is the second call to func().");
	else
	{
		LOG->RecordFailure("Verify current line is the second call to func().");
		return;
	}

	// verify that the local variable 'local' exists.
	if(locals.VerifyLocalInfo("local", "0", "int", NOT_EXPANDABLE))
		LOG->RecordSuccess("Verify that the local variable 'local' exists.");
	else
	{
		LOG->RecordFailure("Verify that the local variable 'local' exists.");
		return;
	}

	// navigate the stack back to func().
	if(stk.NavigateStack(0))
		LOG->RecordSuccess("Navigate the stack back to func().");		
	else
	{
		LOG->RecordFailure("Navigate the stack back to func().");		
		return;
	}

	// verify that the current function is func().
	if(stk.CurrentFunctionIs("func"))
		LOG->RecordSuccess("Verify current function is func().");		
	else
	{
		LOG->RecordFailure("Verify current function is func().");		
		return;
	}

	// verify the current line is the line after global changes.
	if(dbg.CurrentLineIs("line after global changes"))
		LOG->RecordSuccess("Verify current line is the line after global changes.");
	else
	{
		LOG->RecordFailure("Verify current line is the line after global changes.");
		return;
	}

	// verify that the local variable 'local' does not exist.
	if(locals.LocalDoesNotExist("local"))
		LOG->RecordSuccess("Verify that the local variable 'local' does not exist.");
	else
	{
		LOG->RecordFailure("Verify that the local variable 'local' does not exist.");
		return;
	}

	// change value of global via expression evaluator.
	if(ee.SetExpressionValue("global", 4))
		LOG->RecordSuccess("Change value of global to 4 via expression evaluator.");
	else
	{
		LOG->RecordFailure("Change value of global to 4 via expression evaluator.");
		return;
	}

	// verify value of global via memory dump.
	if(mem.MemoryDataIs("global", 4))
		LOG->RecordSuccess("Verify that value of global is 4 via memory dump.");
	else
	{
		LOG->RecordFailure("Verify that value of global is 4 via memory dump.");
		return;
	}

	// clear all breakpoints.
	if(bps.ClearAllBreakpoints())
		LOG->RecordSuccess("Clear all breakpoints.");		
	else
	{
		LOG->RecordFailure("Clear all breakpoints.");		
		return;
	}

	// restart inetinfo.exe
	if(dbg.Restart())
		LOG->RecordSuccess("Restart 'inetinfo.exe'.");		
	else
	{
		LOG->RecordFailure("Restart 'inetinfo.exe'.");		
		return;
	}

	// stop debugging inetinfo.exe.
	if(dbg.StopDebugging())
		LOG->RecordSuccess("Stop debugging 'inetinfo.exe'.");		
	else
	{
		LOG->RecordFailure("Stop debugging 'inetinfo.exe'.");		
		return;
	}
	
	// close the isapi extension project.
	if(prj.Close() == ERROR_SUCCESS)
		LOG->RecordSuccess("Close the ISAPI extension project.");		
	else
	{
		LOG->RecordFailure("Close the ISAPI extension project.");		
		return;
	}

	// terminate internet explorer.
	if(TerminateProcess(piProcInfo.hProcess, 0))
		LOG->RecordSuccess("Terminate Internet Explorer.");		
	else
	{
		LOG->RecordFailure("Terminate Internet Explorer.");		
		return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\loopnt.src\mainloop.cpp ===
// mainloop.cpp
#include <iostream.h>
#include <conio.h>
#include <fstream.h>


#include <stdlib.h>
#include <stdio.h>
#include <time.h>


//#include <afxdb.h>
#include <windows.h>

#include "thread.h"
#include "cppodbc.h"

#undef _MSC_VER
#ifdef _MSC_VER
#include <crtdbg.h>
#ifndef _CRTDBG_MAP_ALLOC
#define _CRTDBG_MAP_ALLOC
#endif
#endif

//for display synchronization
CRITICAL_SECTION csCriticalSection; 

// ERROR/MSG Strings

enum  { MAXPATH=512 };
enum  { MAXSTRINGS = 15};
char * strings[MAXSTRINGS] = { "Debug 0",                   //0
"If this text prints there was an error!!!\n"};           //1

// Debug String

enum  { MAXSTRLEN = 1024,MAXSTRLEN_P1 = 1025};
char * pcDebugString[MAXSTRLEN_P1];

// Program ID/HELP

static char *pcName    = " loop \n";
static char *pcVersion = "0.00\n";
static char *pcPurpose = "The puropse of this program is execute multiple "
"stored procedures\n each in a separate thread.\n";

static char *cmdlinehelp = "\n"
"Usage:   Main     [/options]\n\n"
"Options:      Description\n"
" ? H h        : Help Option will Display this Help Screen.\n"
" l n          : n=Number of times to run the sp's listed in the file(loops). default=1\n"
" s n          : n=Seconds of delay between loops. default=0\n"
" f string     : File which contains DSN's and SP's to run.\n"
"eg. c:\\main /f sp.txt\n\n"
"The format ofthe file is:\n"
"line1 number of sp's to execute:n\n"
"line2 the connection string specifing the data source\n"
"line3 stored procedure to execute\n"
"remaining lines will mimic lines 2 & 3 for additional sp's to execute\n"
"eg. File for two sp's.\n"
"2\nDSN=ChrisKoz4;DATABASE=PUBS;UID=SA;PWD=\nbyRoyalty 20\n"
"DSN=johnba2;DATABASE=PUBS;UID=SA;PWD=\nvartest2\n\n";


void vOutputHeader(void)
{
	cout << pcName;
	cout << "Version "<< pcVersion << endl;
	cout << pcPurpose;
	cout << "MS     bwp" << endl;
	
	cout << "Compiled using:"<< endl;
#ifdef __BORLANDC__
	cout << "Borland   Ver "<<__BORLANDC__<<endl;
#endif
#ifdef _MSC_VER
	cout << "MICROSOFT   Ver "<<_MSC_VER<<endl;
#endif
	
	cout << "Compiled on " << __DATE__<< " at "<< __TIME__<< endl;
}

void help(char *help_string)
{
	cout<<help_string<<endl;
	cout<<"Help::"<<endl;
	cout<<cmdlinehelp << endl;
	vOutputHeader();
	exit(1);
}

int cvtarg(char * pc)     // This fn provides parsing of the cmdline args
{                         // supporting the usage of /x or -x (2 char)
	int i = 0;              // arguments
	int firstbyte,secondbyte;
	
#ifdef __BORLANDC__
    firstbyte = 1;
    secondbyte = 0;
#else                     // MSC or MOTO
    firstbyte = 0;
    secondbyte = 1;
#endif
	
	if( strlen(pc) == 2)
	{
		i = (int) pc[firstbyte];
		i = i << 8;
		i += (int) pc[secondbyte];
	}
	else i = (int) pc[0];
	
	return(i);
}

typedef struct
{
	TCHAR * strConnectString;
	TCHAR * strSP;
	CThread * pct;
	int i;
}structODBC, *pstructODBC;


DWORD dwSQLThread(pstructODBC podbc)
{
	//   cout << "Thread::Running" << GetCurrentThreadId() << " " <<podbc->strConnectString << endl;
	Sleep(GetCurrentThreadId() % 10000);
	//  cout <<podbc->i << " Thread:: " << GetCurrentThreadId() << " " <<podbc->strConnectString << " :sp= "<<podbc->strSP <<" " << (GetCurrentThreadId() % 10000) << endl;
	
	if(podbc != NULL)
	{
		CODBCExec a;
//serialize the SQLConnect calls, because AutMgr hangs
//on multiple connections comming to fast
		BOOL bRes;
		try 
		{ 
			EnterCriticalSection(&csCriticalSection); 
			bRes=a.fConnect(podbc->strConnectString);
			LeaveCriticalSection(&csCriticalSection); 
		}catch(...)
		{
			LeaveCriticalSection(&csCriticalSection);
			throw;
		}
		if(bRes==TRUE)
		{
			if(a.fExecSql(podbc->strSP))
			{
				//      cout <<"Thread:: " << GetCurrentThreadId() << " " <<podbc->strConnectString << " :sp= "<<podbc->strSP <<" Executed." << endl;
				a.vDumpResults();
			    EnterCriticalSection(&csCriticalSection); 
				cout <<"Thread:: " << GetCurrentThreadId() << " " <<podbc->strConnectString << " :sp= "<<podbc->strSP <<" Executed." << endl;
				LeaveCriticalSection(&csCriticalSection); 

			}
			else
			{
				EnterCriticalSection(&csCriticalSection); 
				cout <<"Thread:: " << GetCurrentThreadId() << " " <<podbc->strConnectString << " :sp= "<<podbc->strSP <<" Failed to execute."<< endl;
				LeaveCriticalSection(&csCriticalSection); 
			}
			a.vDisconnect();
		}
		else
		{
			EnterCriticalSection(&csCriticalSection); 
			cout << "Thread::Failed to connect to " << GetCurrentThreadId() << " " <<podbc->strConnectString << endl;
			LeaveCriticalSection(&csCriticalSection); 
		}
		delete [] podbc->strConnectString;
		delete [] podbc->strSP;
		delete podbc->pct;
		delete podbc;
	}  // end if(podbc!=NULL)
	return 0;
}


int  main(int argc, char *argv[])
{ 
	
	
/*	
#ifdef _MSC_VER
	int nDbgFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
	nDbgFlag |= _CRTDBG_LEAK_CHECK_DF;    // turn on leak checking
	//  nDbgFlag &= !_CRTDBG_LEAK_CHECK_DF;  // turn off leak checking
	nDbgFlag |= _CRTDBG_CHECK_ALWAYS_DF;
	_CrtSetDbgFlag(nDbgFlag);
	nDbgFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
	if( nDbgFlag & _CRTDBG_LEAK_CHECK_DF)
		cout << "DEBUG checking for memory leaks." << endl;
	else
		cout << "DEBUG checking for memory leaks NOT SET UP CORRECTLY!" << endl;
#endif
*/	
	
	ifstream ifs; // file streams to hold message and recipient file names
	CThread * pcthread = NULL;       // threads
	pstructODBC  pODBCstruct = NULL; // dsn/sp's
	pstructODBC  pODBC = NULL; // dsn/sp's
	int n = 0;                       // number of sp's to run from file
	int nLoops = 1 ;
	int nSec = 0;
	BOOL bAllocOK = TRUE;
	
	while((argc--) > 1 )
	{
		**argv++;
		//  cout << "ARG[" << argc+1 << "]= " << *argv << endl;
		//  cout << " hex *((short*) *argv) = " << hex << *((short*) *argv) <<"\n";
		switch(cvtarg(*argv))
		{
		case '-h': case 'h': case '/h':
		case '-H': case 'H': case '/H':
		case '-?': case '?': case '/?': help("");
			break;
		case '-l': case 'l': case '/l':
			**argv++; if((argc--) <= 1) help("Number of loops must be specified.\n");
			nLoops = atoi(*argv);
			break;
		case '-s': case 's': case '/s':
			**argv++; if((argc--) <= 1) help("Time delay between loops must be specified.\n");
			nSec = atoi(*argv);
			break;
		case '-f': case 'f': case '/f':
			**argv++; if((argc--) <= 1) help("No DSN/SP File specified.\n");
			ifs.open(*argv, ios::nocreate);
			if(!ifs.good())
				help("Could NOT open DSN/SP file.\n");
			break;
		default: cout <<(*argv) << "\n"; help("Invalid argument.\n");
			break;
		}  // end switch
	}  // end while
	
	cout << nSec << " second delay between loops" << endl;
	// read in the data for the dsn/sp's
	
	if(!ifs.good())
		help("Could NOT open DSN/SP file.\n");
	
	InitializeCriticalSection(&csCriticalSection);

	if(ifs.is_open())
	{
		TCHAR char256[256 + 1];
		
		if(ifs.getline(char256,256,'\n'))    // get # sp's
		{
			n = atoi(char256);
			EnterCriticalSection(&csCriticalSection); 
			cout << n << " Threads will be run."<< endl;
			LeaveCriticalSection(&csCriticalSection); 

		}
		
		if( n> 0)
		{
			pODBCstruct = new structODBC[n];
		}
		
		if(pODBCstruct != NULL)
		{
			int i;
			
			for(i = 0;i<n;i++)
			{
				pODBCstruct[i].strConnectString = NULL;
				pODBCstruct[i].strSP = NULL;
				pODBCstruct[i].pct = NULL;
			}
			
			for(i=0;i<n;i++)
			{
				if(ifs.getline(char256,256,'\n')) // get DSN
				{
					pODBCstruct[i].strConnectString = new TCHAR[strlen(char256) +1];
					if(pODBCstruct[i].strConnectString != NULL)
						strcpy(pODBCstruct[i].strConnectString,char256);
					else bAllocOK = FALSE;
				}
				
				if(ifs.getline(char256,256,'\n')) // get SP
				{
					pODBCstruct[i].strSP = new TCHAR[strlen(char256) +1];
					if(pODBCstruct[i].strSP != NULL)
						strcpy(pODBCstruct[i].strSP,char256);
					else bAllocOK = FALSE;
					
				}
			}
			
			ifs.close();
			
			if(bAllocOK)
			{
				for(int k=0;k< nLoops; k++)
				{	
					EnterCriticalSection(&csCriticalSection); 
					cout << "loop " << (k+1) << "/"<< nLoops << endl;
					LeaveCriticalSection(&csCriticalSection); 
					// allocate threads 
					
					for(int i=0;i<n;i++)
					{ 
						pODBC = new structODBC;
						if(pODBC != NULL)
						{
							pODBC->strConnectString = NULL;
							pODBC->strSP = NULL;
							pODBC->pct = NULL;
							pODBC->i = k;
							
							pODBC->strConnectString = new TCHAR[strlen(pODBCstruct[i].strConnectString) +1];
							if(pODBC->strConnectString != NULL)
							{
								strcpy(pODBC->strConnectString,pODBCstruct[i].strConnectString);
								
								pODBC->strSP = new TCHAR[strlen(pODBCstruct[i].strSP) +1];
								if(pODBC->strSP  != NULL)
									strcpy(pODBC->strSP ,pODBCstruct[i].strSP);
								else bAllocOK = FALSE;
							}
							else bAllocOK = FALSE;
							
							
							if(bAllocOK)
							{
								if(pODBC->pct = new CThread)
								{ 	  		   // create threads
									pcthread = pODBC->pct;
									
									if (pcthread->bCreate((PTHREAD_START_ROUTINE)dwSQLThread,(LPVOID)  pODBC))
									{
										if(pcthread->bStart())
										{
											//           cout << "Main::Started Thread "<< i <<" "<< pcthread->GetTID() <<endl;
										}
										else
										{
											EnterCriticalSection(&csCriticalSection); 
											cout << "Main::Could Not Start Thread " << i <<" "<< pcthread->dwGetTID() << endl;
											LeaveCriticalSection(&csCriticalSection); 
										}
										//            cout << "Main::Created Thread " << i <<" "<< pcthread->dwGetTID() << endl;
									} 
									else 
									{
										EnterCriticalSection(&csCriticalSection); 
										cout << "Main::Did Not Create Thread " << i << endl;
										LeaveCriticalSection(&csCriticalSection); 
									}
								} // end if new CThread
							} // end if (bAllocOK)
						} // end if (pODBC != NULL)
					}  // end for(int i=0;i<n;i++)
					Sleep(nSec*1000);
				} // end  for(int k=0;k< nLoops; k++)
				
			} // end if(bAllocOK)
		}
		else help ("Memory allocation error");
	}
	else  help("Must specify a file containing the sp's to execute.");

	cout << "Main::Press any key to exit." << endl;
	WaitForKeystroke();
	
	if( pODBCstruct != NULL)
	{ 
		for(int i = 0;i<n;i++)
		{
			if(pODBCstruct[i].strConnectString != NULL)
				delete [] (pODBCstruct[i].strConnectString);
			if(pODBCstruct[i].strSP != NULL)
				delete [] (pODBCstruct[i].strSP);
		}
		delete []pODBCstruct;
	}

	DeleteCriticalSection(&csCriticalSection);

	return 0;
} // main
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\loopnt.src\Thread.cpp ===
// thread.cpp
#include "thread.h"
#include <iostream.h>
#include <conio.h>    // _kbhit, _getch



BOOL
CThread::
bCreate(LPSECURITY_ATTRIBUTES lpsa/*=NULL*/,
		DWORD dwss/*=0*/)
{
	if(m_hThread == 0)
	{
		m_hThread = CreateThread(
			lpsa,     // pointer to thread security attributes
			dwss,     // initial thread stack size, in bytes  0 == default size
			m_ptfn,   // pointer to thread function
			m_lpvThreadParm,  // argument for new thread
			CREATE_SUSPENDED, // creation flags
			&m_dwThreadID);   // pointer to returned thread identifier);
	}
	else return FALSE;   // already created
	return(m_hThread!= 0);
}

BOOL
CThread::
bCreate(LPTHREAD_START_ROUTINE ptfn, 
        LPVOID lpv,
		LPSECURITY_ATTRIBUTES lpsa/*=NULL*/,
		DWORD dwss/*=0*/)
{
	if(m_hThread == 0)
	{
		m_ptfn = ptfn;
		m_lpvThreadParm=lpv;
		
		m_hThread = CreateThread(
			lpsa,     // pointer to thread security attributes
			dwss,     // initial thread stack size, in bytes  0 == default size
			m_ptfn,   // pointer to thread function
			m_lpvThreadParm,  // argument for new thread
			CREATE_SUSPENDED, // creation flags
			&m_dwThreadID);   // pointer to returned thread identifier);
	}
	else return FALSE;   // already created
	return(m_hThread!= 0);
}

DWORD
CThread::
dwResume(void)
{
	return ResumeThread( m_hThread);
}

DWORD
CThread::
dwSuspend(void)
{
	return SuspendThread( m_hThread);
}

BOOL
CThread::
bTerminate(void)
{
	BOOL bRC = TerminateThread(m_hThread,0);
	if(bRC)
	{
		m_dwThreadID = 0;
		m_hThread = 0;
	}
	return bRC;
}


DWORD  dwtestfn(int n)
{
	cout << "dwtestfn " << n <<endl;
	return(n);
}

void WaitForKeystroke(void)
{
	while( !_kbhit() )
		Sleep(100);
	_getch();
}


/*
#if defined CTHREAD_MAIN_TEST

int main(void)
{
	CThread ct((PTHREAD_START_ROUTINE)dwtestfn,(LPVOID) 2);
	CThread ct2((PTHREAD_START_ROUTINE)dwtestfn,(LPVOID) 3);
	cout << "Main" << endl;
	//  cout << ct.debugCall((LPVOID) 1) << endl;
	
	if (ct.bCreate())
	{
		cout << "Created Thread "<< dwGetTID() << endl;
		if(ct.bStart())
			cout << "Started Thread "<< dwGetTID() << endl;
		else
			cout << "Could Not Start Thread "<< dwGetTID() << endl;
	}
	else cout << "Did Not Create Thread" << endl;
	
	if(ct.dwSuspend()!= 0xFFFFFFFF) cout << "Thread Suspended" << endl;
	else cout << "Error Thread not Suspended" << endl;
	//  cout << hex << ct.dwSuspend() << endl;
	
	Sleep(1000);
	
	if(ct.dwResume()!= 0xFFFFFFFF) cout << "Thread Resumed" << endl;
	else cout << "Error Thread not Resumed" << endl;
	//  cout << hex <<ct.dwResume() << endl;
	
	if (ct2.bCreate())
	{
		if(ct2.bStart())
			cout << "Started Thread2 "<< dwGetTID() <<endl;
		else
			cout << "Could Not Start Thread2 "<< dwGetTID() <<endl;
	}
	else cout << "Did Not Create Thread 2" << endl;
	cout << "Press any key to Exit"<< endl;
	Sleep(2000);
	WaitForKeystroke();

	return 0;
}

#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\loopnt.src\Cppodbc.h ===
//cpodbc.h
// history:
//  basic outline taken from inside odbc cpp sample
//  modified by bartonp 4/96

#ifndef _CPPODBC_DEFS
#define _CPPODBC_DEFS
#include <Windows.h>
#include <sql.h>
#include <sqlext.h>

#define RC_SUCCESSFUL(rc) (!((rc)>>1))
#define RC_NOTSUCCESSFUL(rc) ((rc)>>1)

//  Class CODBCExec - Allows user to connect, execute, and disconnect from
//  a data source.
class CODBCExec
{
 private:
        // ODBC handles and data
  HENV      m_henv;                 // Environment handle
  HDBC      m_hdbc;                 // Connection handle
  HSTMT     m_hstmt;                // Statement handle

        // Execution settings
        //
  TCHAR      m_szDSN[SQL_MAX_DSN_LENGTH]; // Data source name
  TCHAR      m_szDBMS[128];  // Database name

        // Private access member functions
        //
  void GatherConnectInfo(void);
  void vEnumerateErrors(HENV henv,      // Environment handle
                        HDBC hdbc,      // Connection handle
                        HSTMT hstmt,    // Statement handle
                        LPSTR pszState = NULL);  


 public:
        // Construction/destruction
        //
  CODBCExec();
  ~CODBCExec();

        // ODBC member functions
        //
  BOOL fConnect(LPCSTR pszConnStr, 
	            UWORD SQLAsyncEnable = SQL_ASYNC_ENABLE_OFF);
  BOOL fExecSql(LPCSTR pszSqlStr);
  void vDisconnect(void);

        // Access member functions
        //
  inline LPCSTR GetDSNName(void);
  inline LPCSTR GetDBMSName(void);

  HDBC hdbcGetHDBC(void) { return m_hdbc;} 
  HENV henvGetHENV(void) { return m_henv;} 

  void vDumpResults(void);

        // Status member functions
        //
  inline BOOL IsConnected(void);
  void vShowAllErrors(void);

};

//
// Access member functions
//

inline LPCSTR CODBCExec::GetDSNName(void)
{
  return m_szDSN;
}

inline LPCSTR CODBCExec::GetDBMSName(void)
{
  return m_szDBMS;
}

//
// Status member functions
//

inline BOOL CODBCExec::IsConnected(void)
{
  return (NULL != m_hdbc);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\loopnt.src\Cppodbc.cpp ===
// cppodbc.cpp

#include "cppodbc.h"
#include "iostream.h"  // cout in vEnumerateErrors

extern CRITICAL_SECTION csCriticalSection; 

/////////////////////////////////////////////////////////////////////////////
// CODBCExec::CODBCExec - ctor
//
// Returns:  Nothing
/////////////////////////////////////////////////////////////////////////////
CODBCExec::
CODBCExec()
: m_henv(NULL),
m_hdbc(NULL),
m_hstmt(NULL)
{
	*m_szDSN = '\0';
	*m_szDBMS = '\0';
}

/////////////////////////////////////////////////////////////////////////////
// CODBCExec::~CODBCExec - dtor
//
// Returns:  Nothing
/////////////////////////////////////////////////////////////////////////////
CODBCExec::
~CODBCExec()
{
	// Delete any storage we have left
	//
	
	// Disconnect if the user forgot to do so.
	//
	if(m_hdbc) vDisconnect();
}

/////////////////////////////////////////////////////////////////////////////
// CODBCExec::GatherConnectInfo - Gather information the user may want
//
// Returns:  Nothing
/////////////////////////////////////////////////////////////////////////////

void 
CODBCExec::
GatherConnectInfo(void)
{
	RETCODE         rc;
	
	// Data source name is good for window titles and new connections
	//
	rc = SQLGetInfo(m_hdbc,
		SQL_DATA_SOURCE_NAME,
		m_szDSN,
		sizeof(m_szDSN),
		NULL);
	if(RC_NOTSUCCESSFUL(rc)) 
	{
		*m_szDSN = '\0';
		vShowAllErrors();
	}
	// DBMS names is a good source of generic capabilites
	//
	rc = SQLGetInfo(m_hdbc,
		SQL_DBMS_NAME,
		m_szDBMS,
		sizeof(m_szDBMS),
		NULL);
	if(RC_NOTSUCCESSFUL(rc))
	{
		*m_szDBMS = '\0';
		vShowAllErrors();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CODBCExec::fConnect - Connect to a data source using the caller's string.
//
// Returns:  TRUE if successful, FALSE on error
/////////////////////////////////////////////////////////////////////////////
BOOL 
CODBCExec::
fConnect(LPCSTR pszConnStr,                    // Input connection string
		 UWORD SQLAsyncEnable /*=SQL_ASYNC_ENABLE_OFF*/) // or ENABLE_ON
{
	RETCODE         rc;
	
	if( m_hdbc != NULL) vDisconnect();
	
	// Allocate the environment handle for this application
	//
	rc = SQLAllocEnv(&m_henv);
	if(RC_SUCCESSFUL(rc)) 
	{
		// Allocate a connection handle
		//
		rc = SQLAllocConnect(m_henv, &m_hdbc);
		if(RC_SUCCESSFUL(rc)) 
		{
			
			SQLSetConnectOption(m_hdbc, SQL_ASYNC_ENABLE, SQLAsyncEnable);
			
			// Connect to the data source of choice
			SWORD swSL = 0;
			if(pszConnStr != NULL) swSL =strlen(pszConnStr);
			else swSL = 0; 
			
			rc = SQLDriverConnect(m_hdbc, NULL,
				(UCHAR FAR *)pszConnStr, swSL, //SQL_NTS,
				NULL, 0, NULL,
				SQL_DRIVER_COMPLETE);
			if(RC_SUCCESSFUL(rc)) 
			{
				// Allocate a statement handle
				//
				rc = SQLAllocStmt(m_hdbc, &m_hstmt);
				if(RC_SUCCESSFUL(rc)) 
				{
					GatherConnectInfo();
					return TRUE;
				} // alloc stmt
			} // connect
		} // alloc hdbc
	} // alloc henv
	// An error occurred. Show the messages to the user and
	// free up any handles that were allocated.
	//
	vShowAllErrors();
	vDisconnect();

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CODBCExec::fExecSql - Execute a SQL statement, check for return values,
//                                      then retrieve them if present.
//
// Returns:  TRUE if successful, FALSE on error
/////////////////////////////////////////////////////////////////////////////

BOOL 
CODBCExec::
fExecSql(LPCSTR pszSqlStr)  // SQL string to execute
{
	RETCODE         rc;
	BOOL            fRtn = TRUE;
	
	if(pszSqlStr == NULL) return FALSE;
	
	// Execute the statement directly
	//
	rc = SQLExecDirect(m_hstmt, (UCHAR FAR *)pszSqlStr, SQL_NTS);
	//  while(rc = SQLExecDirect(m_hstmt, (UCHAR FAR *)pszSqlStr, SQL_NTS) == SQL_STILL_EXECUTING)
	//  { Sleep(1000); }
	
	if(RC_SUCCESSFUL(rc) || rc == SQL_STILL_EXECUTING)
	{
		fRtn = TRUE;
	}
	else
	{
		vShowAllErrors();
		fRtn = FALSE;
	}
	return fRtn;
}

/////////////////////////////////////////////////////////////////////////////
// CODBCExec::vDisconnect - Disconnect from a data source.
//
// Returns:  TRUE if successful, FALSE on error
/////////////////////////////////////////////////////////////////////////////
void 
CODBCExec::
vDisconnect(void)
{
	if(m_hstmt)
		SQLFreeStmt(m_hstmt, SQL_DROP);
	if(m_hdbc) 
	{
		SQLDisconnect(m_hdbc);
		SQLFreeConnect(m_hdbc);
	}
	if(m_henv) SQLFreeEnv(m_henv);
	m_hstmt = NULL;
	m_hdbc = NULL;
	m_henv = NULL;
	*m_szDSN = '\0';
	*m_szDBMS = '\0';
}

void 
CODBCExec::
vShowAllErrors(void)
{
	vEnumerateErrors(m_henv,m_hdbc,m_hstmt);
}

/////////////////////////////////////////////////////////////////////////////
// vEnumerateErrors - Iterate all errors on valid handles
//
// Returns:  Nothing
/////////////////////////////////////////////////////////////////////////////
void 
CODBCExec::
vEnumerateErrors(HENV henv,      // Environment handle
                 HDBC hdbc,      // Connection handle
                 HSTMT hstmt,    // Statement handle
                 LPSTR pszState /* = NULL*/)  // Return of last state, NULL is valid
{
	RETCODE                 rc;
	SDWORD                  lNativeError;
	char                    szState[6];
	char                    szMsg[SQL_MAX_MESSAGE_LENGTH];
	
	EnterCriticalSection(&csCriticalSection); 
	cout << "ERROR: " << endl;
	if(m_szDSN != NULL)  cout << m_szDSN << " ";
	if(m_szDBMS != NULL) cout << m_szDBMS << endl;
	
	if(henv==NULL) 
		cout << "Environment handle == NULL, no error enumerated." << endl;

	rc = SQLError(henv, hdbc, hstmt,
		(UCHAR FAR *)szState, &lNativeError,
		(UCHAR FAR *)szMsg, sizeof(szMsg), NULL);
	
	while(RC_SUCCESSFUL(rc)) 
	{
		// Display error for user
		//
		//iMessageBox(hDlg, MB_ICONEXCLAMATION | MB_OK,
		//                                szODBC, szODBCMsg,
		//                                (LPSTR)szState, lNativeError, (LPSTR)szMsg);
		cout << szState << " " << lNativeError  << " " <<szMsg << endl;
		// Store the state if user wants it
		//
		if(pszState) lstrcpy(pszState, szState);
		
		// Go for next error
		//
		rc = SQLError(henv, hdbc, hstmt,
			(UCHAR FAR *)szState, &lNativeError,
			(UCHAR FAR *)szMsg, sizeof(szMsg), NULL);
		//    while( (rc = SQLError(henv, hdbc, hstmt,
		//                (UCHAR FAR *)szState, &lNativeError,
		//                (UCHAR FAR *)szMsg, sizeof(szMsg), NULL))== SQL_STILL_EXECUTING)
		//    {  Sleep(1000);}
		
	}
	cout << rc << endl;
	LeaveCriticalSection(&csCriticalSection); 

}



void 
CODBCExec::
vDumpResults(void)
{
	const int ci = 257;
	TCHAR    tcData[ci];
	RETCODE  rc1,rc2;
	SDWORD   cbSize;
	
	do
	{
		for(rc1=SQLFetch(m_hstmt); RC_SUCCESSFUL(rc1); rc1= SQLFetch(m_hstmt))
		{
			int i = 1;
			for(rc2 = SQLGetData(m_hstmt,i++,SQL_C_CHAR,tcData,ci - 1,&cbSize);
			RC_SUCCESSFUL(rc2);
			rc2 = SQLGetData(m_hstmt,i++,SQL_C_CHAR,tcData,ci - 1,&cbSize))
				cout << tcData <<  " ";
			cout << endl;
		}
	}
	while( RC_SUCCESSFUL(SQLMoreResults(m_hstmt))); 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\loopnt.src\Thread.h ===
// thread.h
// history:
//  written by bartonp 4/96

#ifndef THREAD_H
#define THREAD_H
#include <windows.h>


//HANDLE CreateThread(
//    LPSECURITY_ATTRIBUTES lpThreadAttributes,// pointer to thread security attributes
//    DWORD dwStackSize,          // initial thread stack size, in bytes
//    LPTHREAD_START_ROUTINE lpStartAddress,   // pointer to thread function
//    LPVOID lpParameter,   // argument for new thread
//    DWORD dwCreationFlags,// creation flags
//    LPDWORD lpThreadId    // pointer to returned thread identifier);
//typedef DWORD (WINAPI *PTHREAD_START_ROUTINE)(LPVOID lpThreadParameter);
//typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;


class CThread
{
 public:
//  CThread(DWORD (WINAPI * ptfn)( LPVOID)): m_ptfn(ptfn) {}
  CThread(LPTHREAD_START_ROUTINE ptfn,LPVOID lpv): m_ptfn(ptfn),
                                        m_dwThreadID(0),
                                        m_hThread(NULL),
                                        m_lpvThreadParm(lpv)
                                        {};
  CThread(void): m_ptfn(NULL),
                 m_dwThreadID(0),
                 m_hThread(NULL),
                 m_lpvThreadParm(NULL) {};
  virtual ~CThread(void) { if(m_hThread != 0) CloseHandle(m_hThread); }

  BOOL  bCreate(LPSECURITY_ATTRIBUTES lpsa=NULL,DWORD dwss = 0);
  BOOL  bCreate(LPTHREAD_START_ROUTINE ptfn, 
	            LPVOID lpv,
				LPSECURITY_ATTRIBUTES lpsa=NULL,
				DWORD dwss = 0);
  BOOL  bStart(void) { return (dwResume() != 0xFFFFFFFF);}
  DWORD dwSuspend(void);
  DWORD dwResume(void);
  BOOL  bTerminate(void);
  DWORD dwGetTID(void) { return m_dwThreadID; }
 private:
//   DWORD (WINAPI *m_ptfn)( LPVOID  ); // pointer to thread fn
   LPTHREAD_START_ROUTINE m_ptfn;       // pointer to thread fn
   HANDLE                 m_hThread;    // thread handle
   DWORD                  m_dwThreadID; // thread id
   LPVOID                 m_lpvThreadParm; // thread parm


 public:  // debug calls
	unsigned long  debugCall(LPVOID lpv) 
	{ 
		return( m_ptfn(lpv)); 
	}
	unsigned long  debugCall(void)
	{
		return( m_ptfn(m_lpvThreadParm));
	}
};

void WaitForKeystroke(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\childfrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "ODBCMT.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\childfrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\editdlg.h ===
// EditSPDlg.h : header file
//
#include "ODBCDoc.h"
#include "resource.h"
/////////////////////////////////////////////////////////////////////////////
// CEditSPDlg dialog

class CEditSPDlg : public CDialog
{
// Construction
public:
	CEditSPDlg(CODBCMTDoc *pDoc,CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEditSPDlg)
	enum { IDD = IDD_EDITSP };
	CComboBox	m_DSNCombo;
	CEdit	m_SPEdit;
	UINT	m_Delay;
	UINT	m_NoThreads;
	CString	m_SPName;
	//}}AFX_DATA

	CODBCMTDoc *m_pDoc;
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditSPDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEditSPDlg)
	afx_msg void OnApply();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeDsn();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\editdlg.cpp ===
// EditSPDlg.cpp : implementation file
//

#include "stdafx.h"
#include "EditDlg.h"
#include "ODBCMT.h"
#include "ODBCThrd.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditSPDlg dialog


CEditSPDlg::CEditSPDlg(CODBCMTDoc *pDoc,CWnd* pParent /*=NULL*/)
	: CDialog(CEditSPDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEditSPDlg)
	m_Delay = 0;
	m_NoThreads = 0;
	m_SPName = _T("");
	//}}AFX_DATA_INIT
	m_pDoc=pDoc;
}


void CEditSPDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditSPDlg)
	DDX_Control(pDX, IDC_DSN, m_DSNCombo);
	DDX_Control(pDX, IDC_SPNAME, m_SPEdit);
	DDX_Text(pDX, IDC_DELAY, m_Delay);
	DDV_MinMaxUInt(pDX, m_Delay, 0, 10000);
	DDX_Text(pDX, IDC_NOTHREADS, m_NoThreads);
	DDV_MinMaxUInt(pDX, m_NoThreads, 1, 50);
	DDX_Text(pDX, IDC_SPNAME, m_SPName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEditSPDlg, CDialog)
	//{{AFX_MSG_MAP(CEditSPDlg)
	ON_BN_CLICKED(IDC_APPLY, OnApply)
	ON_CBN_SELCHANGE(IDC_DSN, OnSelchangeDsn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditSPDlg message handlers

void CEditSPDlg::OnApply() 
{
	CComboBox *pComboBox = (CComboBox*)GetDlgItem(IDC_DSN);
	ASSERT(pComboBox!=NULL);
	int icol=pComboBox->GetCurSel();
	if(icol==CB_ERR)
		return;
	UpdateData(TRUE);
	CODBCThread *pTempThreadPTR = (CODBCThread*)m_pDoc->m_ThreadArray.GetAt(icol);
	pTempThreadPTR->m_pSPName=m_SPName;
	pTempThreadPTR->m_msecs=m_Delay;
	pTempThreadPTR->m_Threads=m_NoThreads;
}

BOOL CEditSPDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	//fill the combo with the proper value from database
	CODBCThread *pTempThreadPTR;
	CComboBox *pComboBox = (CComboBox*)GetDlgItem(IDC_DSN);
	ASSERT(pComboBox!=NULL);
	pComboBox->ResetContent( ); // clear old columns
	for(long icol=0; icol<m_pDoc->m_iCountConect; icol++)
	{
		pTempThreadPTR = (CODBCThread*)m_pDoc->m_ThreadArray.GetAt(icol);
		CString name=pTempThreadPTR->m_pSPName+" : ";
		name=name+pTempThreadPTR->m_Connect;
	 	pComboBox->AddString(name);//add its name to the list
	}
	pComboBox->SetCurSel(m_pDoc->m_iCountConect-1); //last one selected

	m_SPName=pTempThreadPTR->m_pSPName;
	m_Delay=pTempThreadPTR->m_msecs;
	m_NoThreads=pTempThreadPTR->m_Threads;
	UpdateData(FALSE);
	m_SPEdit.SetFocus();
	return FALSE;  // return TRUE unless you set the focus to a control
	
}

void CEditSPDlg::OnSelchangeDsn() 
{
	CComboBox *pComboBox = (CComboBox*)GetDlgItem(IDC_DSN);
	ASSERT(pComboBox!=NULL);
	long icol=pComboBox->GetCurSel();
	if(icol==CB_ERR)
		return;
//	OnApply(); //applies the changes to the new selection

	CODBCThread *pTempThreadPTR = (CODBCThread*)m_pDoc->m_ThreadArray.GetAt(icol);
	m_SPName=pTempThreadPTR->m_pSPName;
	m_Delay=pTempThreadPTR->m_msecs;
	m_NoThreads=pTempThreadPTR->m_Threads;
	UpdateData(FALSE);
}

void CEditSPDlg::OnOK() 
{
	OnApply();
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "ODBCMT.h"
#include "ODBCThrd.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_RUNNING, OnUpdateRunning)
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_FORRUN, OnUpdateRunning)
	ON_MESSAGE(WM_USER_RUN_PROGRESS, OnRunProgress)
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
	ID_INDICATOR_FORRUN,
	ID_INDICATOR_RUNNING
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnUpdateRunning(CCmdUI* pCmdUI)
{
	// It is necessary to enable the  status bar pane, so that
	// the text will be displayed.
	pCmdUI->Enable();
}


LRESULT CMainFrame::OnRunProgress(WPARAM wParam, LPARAM lParam)
{
	char buffer[20];
	if(lParam==0)
	{
		_itoa(wParam,buffer,10);
		m_wndStatusBar.SetPaneText(
		m_wndStatusBar.CommandToIndex(ID_INDICATOR_RUNNING), buffer);
	}
	else
	{
		_itoa(wParam,buffer,10);
		m_wndStatusBar.SetPaneText(
		m_wndStatusBar.CommandToIndex(ID_INDICATOR_FORRUN), buffer);
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	afx_msg void OnUpdateRunning(CCmdUI* pCmdUI);
	LRESULT OnRunProgress(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\odbcdoc.h ===
// ODBCMTDoc.h : interface of the CODBCMTDoc class
//
/////////////////////////////////////////////////////////////////////////////
#ifndef __ODBCMTDOC_H__
#define __ODBCMTDOC_H__

class CODBCMTDoc : public CDocument
{
private:
	CRITICAL_SECTION m_critsecRunning; //protects access to m_iCountRunning 

protected: // create from serialization only
	CODBCMTDoc();
	DECLARE_DYNCREATE(CODBCMTDoc)

// Attributes
public:
	CSize m_sizeDSN;
// Operations
public:
	// void NotifyStatus();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CODBCMTDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

	void CreateAndExecute(BOOL Async=FALSE,int NbRuns=1);
	void ExecutionDone();


// Implementation
public:
	virtual ~CODBCMTDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

public:
	CObArray	m_ThreadArray;
	int			m_iCountConect;
	int			m_iCountRunning; //no of threads running
	int			m_iCountWaiting; //no of thread groups queued for run
// Generated message map functions
protected:
	//{{AFX_MSG(CODBCMTDoc)
	afx_msg void OnCreateConnection();
	afx_msg void OnEditConnect();
	afx_msg void OnConnectConnect();
	afx_msg void OnConnectDisconnect();
	afx_msg void OnConnectKillAll();
	afx_msg void OnCreateThreads();
	afx_msg void OnExecuteAll();
	afx_msg void OnThreadKillAll();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

#endif
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\odbcdoc.cpp ===
// ODBCMTDoc.cpp : implementation of the CODBCMTDoc class
//

#include "stdafx.h"

#include "ODBCThrd.h"
#include "ODBCMT.h"

#include "ODBCDoc.h"
#include "EditDlg.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CODBCMTDoc

IMPLEMENT_DYNCREATE(CODBCMTDoc, CDocument)

BEGIN_MESSAGE_MAP(CODBCMTDoc, CDocument)
	//{{AFX_MSG_MAP(CODBCMTDoc)
	ON_COMMAND(ID_CONNECT_ADD, OnCreateConnection)
	ON_COMMAND(ID_CONNECT_EDIT, OnEditConnect)
	ON_COMMAND(ID_CONNECT_RECONNECT, OnConnectConnect)
	ON_COMMAND(ID_CONNECT_DISCONNECT, OnConnectDisconnect)
	ON_COMMAND(ID_CONNECT_CLEAR, OnConnectKillAll)
	ON_COMMAND(ID_CREATE_THREAD, OnCreateThreads)
	ON_COMMAND(ID_EXECUTE_ALL, OnExecuteAll)
	ON_COMMAND(ID_THREAD_KILL_ALL, OnThreadKillAll)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CODBCMTDoc construction/destruction

CODBCMTDoc::CODBCMTDoc()
{
	// TODO: add one-time construction code here
	InitializeCriticalSection(&m_critsecRunning);
	m_iCountConect = 0;
	::PostMessage(AfxGetMainWnd()->m_hWnd,WM_USER_RUN_PROGRESS,
		m_iCountRunning = 0,0); //running
	::PostMessage(AfxGetMainWnd()->m_hWnd,WM_USER_RUN_PROGRESS,
		m_iCountWaiting = 0,1); //waiting
	m_sizeDSN=CSize(200,200);
}

CODBCMTDoc::~CODBCMTDoc()
{
	CODBCThread* pTempThreadPTR;

	while (m_iCountConect--) {
		pTempThreadPTR = (CODBCThread*)m_ThreadArray.GetAt(m_iCountConect);

		pTempThreadPTR->KillThread();

		m_ThreadArray.RemoveAt(m_iCountConect);
		delete pTempThreadPTR;
	}
	DeleteCriticalSection(&m_critsecRunning);
	::PostMessage(AfxGetMainWnd()->m_hWnd,WM_USER_RUN_PROGRESS,
		m_iCountRunning = 0,0); //running
	::PostMessage(AfxGetMainWnd()->m_hWnd,WM_USER_RUN_PROGRESS,
		m_iCountWaiting = 0,1); //waiting
}

BOOL CODBCMTDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CODBCMTDoc serialization

void CODBCMTDoc::Serialize(CArchive& ar)
{
	char buffer[12]; //for storing the number
	if (ar.IsStoring())
	{
//		ar << m_iCountConect;
//		ar << m_sizeDSN;
		for(int i=0;i<m_iCountConect;i++)
		{
			CODBCThread *pTempThreadPTR = (CODBCThread*)m_ThreadArray.GetAt(i);
			
			ar.WriteString(pTempThreadPTR->m_pSPName);ar.WriteString("\n");
//			ar << pTempThreadPTR->m_Threads;
			sprintf(buffer,"  %-6d",pTempThreadPTR->m_msecs);
			ar.WriteString(buffer);
			ar.WriteString(pTempThreadPTR->m_Connect);ar.WriteString("\n");
		}
	} //storing
	else
	{
//		ar >> m_iCountConect;
//		ar >> m_sizeDSN;
		m_iCountConect=0;
		m_sizeDSN.cx=200;m_sizeDSN.cy=200; //arbitrary, event. calculate later
		CString strProc;
		CString strConnect;
		do
		{
			if(ar.ReadString(strProc)==FALSE ||
				ar.ReadString(strConnect)==FALSE)
				break;
			CODBCThread *pthreadnext=new CODBCThread;
			pthreadnext->m_pSPName=strProc;
			strConnect.TrimLeft();
			pthreadnext->m_Threads=1; //one by default (although stored otherwise before)
			pthreadnext->m_msecs=atoi(strcpy(buffer,strConnect.Left(6)));
			pthreadnext->m_Connect=strConnect.Right(strConnect.GetLength()-6);
			
			//create new DataSource, Recordset
			CDatabase *pdbnext= new CDatabase;
			pdbnext->SetLoginTimeout(30);
			pdbnext->SetQueryTimeout(1000);
			// pdbnext->SetConnect(dsnConnect); can't do that
			
			// replace Datasource & Recordset in new thread
			pthreadnext->m_pDatasource=pdbnext;
			pthreadnext->m_pRecSet = new CRecordset(pthreadnext->m_pDatasource);
			
			
			POSITION pos = GetFirstViewPosition();
			ASSERT(pos != NULL);
			CView* pView = GetNextView(pos);
			ASSERT(pView != NULL);
			pthreadnext->m_hwndNotifyStatus = pView->m_hWnd;  //  Set up for status report
			
			
			m_ThreadArray.Add(pthreadnext);
			m_iCountConect++;
		}while(1);

	} //reading
}

/////////////////////////////////////////////////////////////////////////////
// CODBCMTDoc diagnostics

#ifdef _DEBUG
void CODBCMTDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CODBCMTDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CODBCMTDoc commands

/*
** void CODBCMTDoc::OnCreateThread()
*/
void CODBCMTDoc::OnCreateConnection() 
{
	
	CODBCThread *thread=new CODBCThread;

	// Browse to user for the connection
	
	if (!thread->ConnectDatasource()) 
	{
		/*  
		To Do:  Generate an internal error condition
		Get rid of the thread and clean up the Array from the calling routine
		*/
		delete thread;
		return;  
	}
	
	// Prepare the SQL statement
	
	if(!thread->GetNewSP()) 
	{
		/*  
		To Do:  Generate an internal error condition
		Get rid of the thread and clean up the Array from the calling routine
		*/
		delete thread;
		return;
	};
	
	//create the events for thread synchronization


	POSITION pos = GetFirstViewPosition();
	ASSERT(pos != NULL);
	CView* pView = GetNextView(pos);
	ASSERT(pView != NULL);
	thread->m_hwndNotifyStatus = pView->m_hWnd;  //  Set up for status report


	m_ThreadArray.Add(thread);
	m_iCountConect++;
	
	int i;

	for(i=1;i<int(thread->m_Threads);i++)
	{	// create the rest of the threads

		CODBCThread *pthreadnext=new CODBCThread;
		// *pthreadnext=thread;
		pthreadnext->m_pSPName=thread->m_pSPName;
		pthreadnext->m_Threads=thread->m_Threads;
		pthreadnext->m_msecs=thread->m_msecs;

		Sleep(thread->m_msecs);
		
		//create new DataSource, Recordset
		CDatabase *pdbnext= new CDatabase;
		pdbnext->SetLoginTimeout(30);
		pdbnext->SetQueryTimeout(1000);
		pdbnext->Open( NULL, FALSE, FALSE, thread->m_Connect );
		
		// replace Datasource & Recordset in new thread
		pthreadnext->m_pDatasource=pdbnext;
		pthreadnext->m_pRecSet = new CRecordset(pthreadnext->m_pDatasource);
		pthreadnext->RetrieveConnect();

		POSITION pos = GetFirstViewPosition();
		ASSERT(pos != NULL);
		CView* pView = GetNextView(pos);
		ASSERT(pView != NULL);
		pthreadnext->m_hwndNotifyStatus = pView->m_hWnd;  //  Set up for status report
	
				
		m_ThreadArray.Add(pthreadnext);
		m_iCountConect++;
	}
	int length=thread->m_Connect.GetLength();
	if(length>m_sizeDSN.cx)
		m_sizeDSN.cx=length;
	UpdateAllViews(NULL);	
}


void CODBCMTDoc::OnEditConnect() 
{
	if (!m_iCountConect) return;
	CEditSPDlg dlg(this);
	if(dlg.DoModal() == IDOK)
	{
		int i;
		for(i=0;i<m_iCountConect;i++)
		{
			CODBCThread *pTempThreadPTR = (CODBCThread*)m_ThreadArray.GetAt(i);
			int length=pTempThreadPTR->m_Connect.GetLength();
			if(length>m_sizeDSN.cx)
				m_sizeDSN.cx=length;
		}
		UpdateAllViews(NULL);
	}
}

void CODBCMTDoc::OnConnectConnect()
{  // reconnects all connections in thread table
		int i;
		for(i=0;i<m_iCountConect;i++)
		{
			CODBCThread *pTempThreadPTR = (CODBCThread*)m_ThreadArray.GetAt(i);
			CString dsnConnect=pTempThreadPTR->m_Connect;
			if(pTempThreadPTR->m_pDatasource->Open( NULL, FALSE, FALSE, dsnConnect )==0)
				TRACE("Failed to open Datasource: %d\n",dsnConnect);
	 		Sleep(pTempThreadPTR->m_msecs);
		}
}

void CODBCMTDoc::OnConnectDisconnect()
{  // kills all threads  & disconnects all connections in thread table
	//  does not destroy the connection information
	OnThreadKillAll();
	int i;
		for(i=0;i<m_iCountConect;i++)
		{
			CODBCThread *pTempThreadPTR = (CODBCThread*)m_ThreadArray.GetAt(i);
			pTempThreadPTR->m_pDatasource->Close( );
		}
}
		
void CODBCMTDoc::OnConnectKillAll()
{  // kills all threads  & disconnects all connections in thread table
	// destroy the connection information (document is clean)
	OnThreadKillAll();
	while(m_iCountConect>0)
	{
		CODBCThread *pTempThreadPTR;
		pTempThreadPTR = (CODBCThread*)m_ThreadArray.GetAt(--m_iCountConect);
		pTempThreadPTR->KillThread(); //waits INFINITE time
		m_ThreadArray.RemoveAt(m_iCountConect);
		delete pTempThreadPTR;
	}
}

void CODBCMTDoc::OnCreateThreads()
{	// creates all threads and leaves them in a paused statte
	// if they exist, they are stopped & paused
	CODBCThread* pTempThreadPTR;

	for (int i = 0; i < m_iCountConect; i++) {
 		pTempThreadPTR = (CODBCThread*)m_ThreadArray.GetAt(i);
		pTempThreadPTR->CreateThreads();
	}
}

/*
** void CODBCMTDoc::OnExecuteAll()
*/
void CODBCMTDoc::OnExecuteAll() 
{//TODO: reconnect all threads 
//	(the best would be to reconnect inside each thread)
//  when executing all while not connected
	if (!m_iCountConect) return;
	BOOL allowrun=FALSE;
	EnterCriticalSection(&m_critsecRunning);
	if(m_iCountRunning==0)  //here allow chain
		allowrun=TRUE;
	if(allowrun==FALSE)
	{
		::PostMessage(AfxGetMainWnd()->m_hWnd,WM_USER_RUN_PROGRESS,
			++m_iCountWaiting,1);
		TRACE("Threads scheduled to run\n");
		return;
	}
	LeaveCriticalSection(&m_critsecRunning);
	TRACE("\n\n");

	CODBCThread* pTempThreadPTR;

	for (int i = 0; i < m_iCountConect; i++) 
	{
 		pTempThreadPTR = (CODBCThread*)m_ThreadArray.GetAt(i);
		if(pTempThreadPTR->m_pDatasource->IsOpen())
		{
			if(pTempThreadPTR->ActivateThread()!=FALSE)
			{
				EnterCriticalSection(&m_critsecRunning);
				m_iCountRunning++;
				LeaveCriticalSection(&m_critsecRunning);
			}
		}
		else
		{
			if(pTempThreadPTR->ActivateThread()!=FALSE)
			{
				EnterCriticalSection(&m_critsecRunning);
				m_iCountRunning++;
				LeaveCriticalSection(&m_critsecRunning);
				::PostMessage(AfxGetMainWnd()->m_hWnd,WM_USER_RUN_PROGRESS,
					m_iCountRunning,0);
				Sleep(pTempThreadPTR->m_msecs);
			}
		}
	}
	::PostMessage(AfxGetMainWnd()->m_hWnd,WM_USER_RUN_PROGRESS,
		m_iCountRunning,0);
}



void CODBCMTDoc::OnThreadKillAll() 
{
	CODBCThread* pTempThreadPTR;
	int i;
	for(i=0; i < m_iCountConect; i++) 
	{
		pTempThreadPTR = (CODBCThread*)m_ThreadArray.GetAt(i);
		pTempThreadPTR->KillThread(); //waits IINFINITE time
	}
	::PostMessage(AfxGetMainWnd()->m_hWnd,WM_USER_RUN_PROGRESS,
		m_iCountRunning = 0,0);
}

// call when you want to reconnect & execute all threads
// without getting through UI
void CODBCMTDoc::CreateAndExecute(BOOL Assync /* =FALSE */, int NbRuns /* =1 */)
{
	if(Assync==FALSE)
		OnConnectConnect();
	OnCreateThreads();
	m_iCountWaiting=NbRuns; //executed once
	::PostMessage(AfxGetMainWnd()->m_hWnd,WM_USER_RUN_PROGRESS,
		--m_iCountWaiting,1);
	if(m_iCountWaiting<0)m_iCountWaiting=0; //safety
	OnExecuteAll();	
}



// called when the execution of threads is done
void CODBCMTDoc::ExecutionDone()
{
	BOOL nextexec=FALSE;
	// Thread ID should be passed in
	// Find the correct Arrey entry point and get the SP name
	// Display SP name 
	// If there are any results, display that as well

	EnterCriticalSection(&m_critsecRunning);
	if(--m_iCountRunning<0)m_iCountRunning=0; //safety
	if(m_iCountRunning==0 && m_iCountWaiting>0)  //here allow chain
		nextexec=TRUE;
	LeaveCriticalSection(&m_critsecRunning);
	::PostMessage(AfxGetMainWnd()->m_hWnd,WM_USER_RUN_PROGRESS,
		m_iCountRunning,0);
	if(nextexec)
	{
		::PostMessage(AfxGetMainWnd()->m_hWnd,WM_USER_RUN_PROGRESS,
			--m_iCountWaiting,1);
		if(m_iCountWaiting<0)m_iCountWaiting=0; //safety
		OnExecuteAll();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\odbcmt.cpp ===
// ODBCMT.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ODBCMT.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "ODBCDoc.h"
#include "ODBCView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CODBCCommandLineInfo: public CCommandLineInfo
{
public:
	int m_commandrun;
	CODBCCommandLineInfo::CODBCCommandLineInfo():CCommandLineInfo()
	{
		m_commandrun=0;
	}
	virtual void ParseParam(LPCTSTR lpszParam,BOOL bFlag,BOOL bLast)
	{
		if(bFlag==TRUE && (*lpszParam=='r' || *lpszParam=='R'))
		{
			if(lpszParam[1]==0)
				m_commandrun=1; //default
			else if(lpszParam[1]=='=' || lpszParam[1]==':')
				m_commandrun=atoi(lpszParam+2); //after '=' or ':'
		}
		CCommandLineInfo::ParseParam(lpszParam,bFlag,bLast);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CODBCMTApp

BEGIN_MESSAGE_MAP(CODBCMTApp, CWinApp)
	//{{AFX_MSG_MAP(CODBCMTApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CODBCMTApp construction

CODBCMTApp::CODBCMTApp()
{
	m_commandrun=0;
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CODBCMTApp object

CODBCMTApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CODBCMTApp initialization

BOOL CODBCMTApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif
	SetRegistryKey(_T("Microsoft"));
	LoadStdProfileSettings(16);  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_ODBCMTTYPE,
		RUNTIME_CLASS(CODBCMTDoc),
		RUNTIME_CLASS(CChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CODBCMTView));
	AddDocTemplate(pDocTemplate);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// Parse command line for standard shell commands, DDE, file open
	CODBCCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);
	if(cmdInfo.m_commandrun!=0 &&
		cmdInfo.m_nShellCommand==CCommandLineInfo::FileOpen)
		m_commandrun=cmdInfo.m_commandrun;
	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
	{
		m_commandrun=0;
		return FALSE;
	}
	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CODBCMTApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CODBCMTApp commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\odbcthrd.h ===
/*
**
**	File name ODBCTHread.h
**
*/

#include "afxdb.h"

#define WM_USER_NOTIFY_STATUS (WM_USER)
#define WM_USER_RUN_PROGRESS (WM_USER+1)

class CODBCThread : public CObject
{
public:
	CODBCThread();

	virtual ~CODBCThread();

public:
	HANDLE m_hEventStartExecute;
	HANDLE m_hSemaphoreExecDone;
	HANDLE m_hEventKillExecuteThread;
	HANDLE m_hEventAllThreadKilled;
	HANDLE m_hEventAllThreadExecuted;

//	CWinThread* m_pWorkerThread;
	HWND m_hwndNotifyStatus;

public:
	CString		m_pSPName;
	UINT		m_Threads;
	UINT		m_msecs;
	CDatabase	*m_pDatasource;
	CString		m_Connect;
	CRecordset	*m_pRecSet;
	BOOL		m_ThreadsExist;
public:
	BOOL ActivateThread();
	BOOL ConnectDatasource();
	void CODBCThread::RetrieveConnect();
	BOOL GetNewSP();
   	void CreateThreadEvents();
	void CloseThreadEvents();
	BOOL CreateThreads();
	BOOL KillThread();
 };

UINT ODBCThreadProc(LPVOID pParam /* CODBCThreadInfo ptr */);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\odbcthrd.cpp ===
/*
**
** File name: ODBCThread.cpp
** 
*/

#include "stdafx.h"
#include "ODBCThrd.h"
#include "SPDLG.h"


void ExecuteSQLSP(LPVOID pParam)
{
 	CODBCThread* pODBCThreadInfo = (CODBCThread*)pParam;

	TRY
	{
// 		RETCODE retcode;
//		retcode = SQLExecDirect(pODBCThreadInfo->m_pRecSet->m_hstmt, spchar, 12);

//		pODBCThreadInfo->m_pRecSet->m_strSort = _T("colRecID");
//		pODBCThreadInfo->m_pRecSet->m_strFilter = _T("");
		 if(pODBCThreadInfo->m_pDatasource->IsOpen()==0)
		 {
			 CString dsnConnect=pODBCThreadInfo->m_Connect;
			 pODBCThreadInfo->m_pDatasource->Open( NULL, FALSE, FALSE, dsnConnect);
		 }


		//  the following is just a test
		/*
		Get Field value
		*/
//		CDBVariant var;
//		pODBCThreadInfo->m_pRecSet->GetFieldValue(_T("colRecID"),var);

		/* 
		Get Field Info
		*/

//		CODBCFieldInfo FieldInfo;
//		pODBCThreadInfo->m_pRecSet->GetODBCFieldInfo(_T("colRecID"),FieldInfo);	

		TRACE("Before %s\n", LPCSTR(pODBCThreadInfo->m_pSPName));
     	pODBCThreadInfo->m_pDatasource->ExecuteSQL(pODBCThreadInfo->m_pSPName);
		TRACE("After  %s\n", LPCSTR(pODBCThreadInfo->m_pSPName));
	}
	CATCH(CDBException, e)
	{
		// The error code is in e->m_nRetCode
		TRACE("Error in %s: %s\n", LPCSTR(pODBCThreadInfo->m_pSPName),
			LPCSTR(e->m_strError));
	}
	END_CATCH
  	

}

UINT ODBCThreadProc(LPVOID pParam)
{
//	DWORD dwExitCode;
	long proccount;

	CODBCThread* pODBCThreadInfo = (CODBCThread*)pParam;
#pragma warning (disable: 4390)
	if (WaitForSingleObject(pODBCThreadInfo->m_hSemaphoreExecDone, /*INFINITE*/0))
		; //i hope here nothing bad hapens (always returns)
	while (TRUE)
	{
//		bRecalcCompleted = FALSE;

		// Wait for signal to start executing SPs
		if (WaitForSingleObject(pODBCThreadInfo->m_hEventStartExecute, INFINITE)
			!= WAIT_OBJECT_0)
			break;
		//check the semaphore count by calling Release & WaitForSingleObject
		// the first thread shd lock the exit by resetting the event
		ReleaseSemaphore(pODBCThreadInfo->m_hEventStartExecute,1,&proccount);
		WaitForSingleObject(pODBCThreadInfo->m_hEventStartExecute, INFINITE);
		// if(UINT(proccount+1)==pODBCThreadInfo->m_Threads) // I'm the first thread in this group entering the execution
		// always first - only one thread per connection
			ResetEvent(pODBCThreadInfo->m_hEventAllThreadExecuted);
		// the last thread shd unlock the exit by seting the event
		if(proccount==0) // I'm the last thread in this group entering the execution
			SetEvent(pODBCThreadInfo->m_hEventAllThreadExecuted);

		// Exit the thread if the main application sets the "Kille execute"
		// event. The main application will set the "start execute" event
		// before setting the "kill execute" event.

		if (WaitForSingleObject(pODBCThreadInfo->m_hEventKillExecuteThread, 0)
			== WAIT_OBJECT_0)
			break; // Terminate this thread by existing the proc.


		// Reset event to indicate "not done", that is, recalculation is in progress.
//		ResetEvent(pODBCThreadInfo->m_hEventExecuteDone);

		ExecuteSQLSP(pParam);

		::PostMessage(pODBCThreadInfo->m_hwndNotifyStatus,
			WM_USER_NOTIFY_STATUS, 0, 0);
  
		// wait here (ssynchronize) all threads in a group
		if (WaitForSingleObject(pODBCThreadInfo->m_hEventAllThreadExecuted, INFINITE)
			!= WAIT_OBJECT_0)
			break; 

	}

	ReleaseSemaphore(pODBCThreadInfo->m_hSemaphoreExecDone,1,&proccount);
	// if(UINT(proccount+1)==pODBCThreadInfo->m_Threads) // I'm the last thread in this group
	// always the last - always one thread per connection
		SetEvent(pODBCThreadInfo->m_hEventAllThreadKilled);

	return 0;
#pragma warning (default: 4390)
}


CODBCThread::CODBCThread()
{
	m_ThreadsExist = FALSE;
	m_pRecSet=NULL;
	m_pDatasource=NULL;

}



void CODBCThread::CreateThreadEvents()
{
	/*
	Create necessary event objects
	*/
 	m_hEventStartExecute = CreateSemaphore(NULL, 0, 2 /* no - only one thread per connection m_Threads+1  */, NULL);		
	// manual reset to allow multiple threads, initially reset
	m_hSemaphoreExecDone = CreateSemaphore(NULL, 1 /* m_Threads no - only one thread per connection*/, m_Threads, NULL);
	//  initially set to number of threads
	m_hEventKillExecuteThread = CreateEvent(NULL, FALSE, FALSE, NULL);	// auto reset, initially reset
	m_hEventAllThreadKilled = CreateEvent(NULL, FALSE, FALSE, NULL);// auto reset, initially reset
	m_hEventAllThreadExecuted=CreateEvent(NULL, TRUE, FALSE, NULL);
	// manual reset, to allow multiple thread to pass

	ASSERT(m_hEventStartExecute != NULL);
	ASSERT(m_hSemaphoreExecDone != NULL);
	ASSERT(m_hEventKillExecuteThread != NULL);
	ASSERT(m_hEventAllThreadKilled != NULL);
	ASSERT(m_hEventAllThreadExecuted != NULL);
}


CODBCThread::~CODBCThread()
{

//	DWORD dwExitCode;

//TO DO (suspicious - must check if it's set)
//	if (m_pWorkerThread != NULL &&
//	GetExitCodeThread(m_pWorkerThread->m_hThread, &dwExitCode) &&
//	dwExitCode == STILL_ACTIVE)
	if(m_ThreadsExist)
	{
		long number;
		SetEvent(m_hEventKillExecuteThread);
		// do{ //no: only one thread per connection
		ReleaseSemaphore(m_hEventStartExecute,1,&number);
		// }while(number < long(m_Threads));
		CloseThreadEvents();
		m_pDatasource->Close();

		WaitForSingleObject(m_hEventAllThreadKilled, INFINITE);
	}

	if(m_pRecSet!=NULL)
		delete m_pRecSet;
	if(m_pDatasource!=NULL)
		delete m_pDatasource;

//	m_pWorkerThread = NULL;

}

BOOL CODBCThread::ConnectDatasource()
{
	m_pDatasource = new CDatabase;

	m_pDatasource->SetLoginTimeout(30);
	m_pDatasource->SetQueryTimeout(1000);
	//m_pDatasource->SetSynchronousMode(TRUE);

	if (!m_pDatasource->Open(NULL)) {
		delete m_pDatasource;
		m_pDatasource=NULL;
		return FALSE;
	}

	m_pRecSet = new CRecordset(m_pDatasource);
	RetrieveConnect();
	
	return TRUE;
}

void CODBCThread::RetrieveConnect()
{	//retrieves the important part of the connsction string from m_pDatasource
	char fullconnect[1024];
	strncpy(fullconnect,m_pDatasource->GetConnect(),1024);
	CString connectbuf;

	char *token;
	token = strtok(fullconnect,";");
	for(;token != NULL;token = strtok( NULL, ";" )) 
	{
		if(strstr(token,"APP=")==token)
			continue; //skip APP
		if(strstr(token,"WSID=")==token)
			continue; //skip WSID
		if(strstr(token,"LANGUAGE=")==token)
			continue; //skip WSID
		connectbuf+=token;
		connectbuf+=';';
	}
	m_Connect=connectbuf.Left(connectbuf.GetLength()-1);
}



BOOL CODBCThread::GetNewSP()
{
	CNewSPDlg dlg;

	if (dlg.DoModal() == IDOK) 
	{
		m_pSPName = dlg.m_SPName;
		m_Threads = dlg.m_NoThreads;
		m_msecs   = dlg.m_Delay;
		return TRUE;
	} 
	else 
	{
		return FALSE;
	}
}


BOOL CODBCThread::CreateThreads()
{
	// The events are initially set or reset in the CreateEvent call;
	// but they may be left in an improperly initialized state if
	// a worker thread has been previously started and then prematurely
	// killed.  Set/reset the events to the proper initial state.
	// Set the "start recalc" event last, since it is the event the
	// triggers the starting of the worker thread recalculation.

	if(	m_ThreadsExist == FALSE)
	{
		CreateThreadEvents();
		ResetEvent(m_hEventKillExecuteThread);
		ResetEvent(m_hEventAllThreadKilled);
		ResetEvent(m_hEventAllThreadExecuted);

	/*	m_pWorkerThread = */
		// UINT i;
		// for(i=0;i<m_Threads;i++)
		//only one thread per connection
		AfxBeginThread(ODBCThreadProc, this);
		m_ThreadsExist = TRUE;
		// RecalcDone() will be called by the view when the thread sends a
		// WM_USER_RECALC_DONE message.
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CODBCThread::ActivateThread()
{
	long number,active;
//	ReleaseSemaphore(m_hEventStartExecute,0,&active); value 0 does not work
//	if(active=!0)
//		TRACE("Didn't start all threads, %d are still waiting...",active);
	if(m_ThreadsExist == FALSE)
	{
		TRACE("Thread %s: not created\n",m_pSPName);
		return FALSE;
	}
	active=ReleaseSemaphore(m_hEventStartExecute,1 /* m_Threads (no, only one thread per connection*/ ,&number);
	return TRUE;
	//SetEvent(m_hEventStartExecute);
}

BOOL CODBCThread::KillThread()
{
	long number;
	if(m_ThreadsExist == FALSE)
	{
		TRACE("Thread %s: nothing to kill\n",m_pSPName);
		return FALSE;
	}
	SetEvent(m_hEventKillExecuteThread);
	// do{ TODO only one thread
		ReleaseSemaphore(m_hEventStartExecute,1,&number);
	// }while(number < long(m_Threads));
//	SetEvent(m_hEventStartExecute);
	
	WaitForSingleObject(m_hEventAllThreadKilled, INFINITE);

	CloseThreadEvents();
	m_ThreadsExist = FALSE;
	return TRUE;
}

void CODBCThread::CloseThreadEvents()
{
 	CloseHandle(m_hEventStartExecute);
	CloseHandle(m_hSemaphoreExecDone);
	CloseHandle(m_hEventKillExecuteThread);
	CloseHandle(m_hEventAllThreadKilled);
	CloseHandle(m_hEventAllThreadExecuted);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\odbcmt.h ===
// ODBCMT.h : main header file for the ODBCMT application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CODBCMTApp:
// See ODBCMT.cpp for the implementation of this class
//

class CODBCMTApp : public CWinApp
{
public:
	CODBCMTApp();
	int m_commandrun;
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CODBCMTApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CODBCMTApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\odbcview.cpp ===
// ODBCMTView.cpp : implementation of the CODBCMTView class
//

#include "stdafx.h"
#include "ODBCMT.h"

#include "ODBCDoc.h"
#include "ODBCView.h"
#include "ODBCThrd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CODBCMTView

IMPLEMENT_DYNCREATE(CODBCMTView, CScrollView)

BEGIN_MESSAGE_MAP(CODBCMTView, CScrollView)
	ON_MESSAGE(WM_USER_NOTIFY_STATUS, OnExecuteDone)
	//{{AFX_MSG_MAP(CODBCMTView)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CScrollView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CScrollView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CScrollView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CODBCMTView construction/destruction

CODBCMTView::CODBCMTView()
{
	// TODO: add construction code here

}

CODBCMTView::~CODBCMTView()
{
}

BOOL CODBCMTView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CScrollView::PreCreateWindow(cs);
}

void CODBCMTView::OnInitialUpdate()
{
	SetScrollSizes(MM_TEXT, GetDocument()->m_sizeDSN);
	CScrollView::OnInitialUpdate();
	int nb_runs=((CODBCMTApp*)AfxGetApp())->m_commandrun;
	if(nb_runs!=0)
	{	// the run was found on the command line
		GetDocument()->CreateAndExecute(TRUE,nb_runs);
		((CODBCMTApp*)AfxGetApp())->m_commandrun=0; // clear the cmnd line
	}
}

/////////////////////////////////////////////////////////////////////////////
// CODBCMTView drawing

void CODBCMTView::OnDraw(CDC* pDC)
{
	CODBCMTDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	int screenpos;
	int count;
   	for(count=0,screenpos=0; 
		count<pDoc->m_iCountConect; 
		count++,screenpos+=15)
	{
		int column=0;
		CString strproc;
		CODBCThread *pThread=(CODBCThread*)(pDoc->m_ThreadArray[count]);
		strproc = pThread->m_pSPName;
	//	while(1)
	//	{
	//		strcol= pDoc->m_resultList.GetNext( pos );
	//		if(strcol=="\n")
	//			break;
	//	}
		pDC->TextOut(column,screenpos,strproc);
		column+=20;screenpos+=15;
		pDC->TextOut(column,screenpos,pThread->m_Connect);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CODBCMTView printing

BOOL CODBCMTView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default CScrollView preparation
	return CScrollView::OnPreparePrinting(pInfo);
}

void CODBCMTView::OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo)
{
	// Default CScrollView begin printing.
	CScrollView::OnBeginPrinting(pDC, pInfo);
}

void CODBCMTView::OnEndPrinting(CDC* pDC, CPrintInfo* pInfo)
{
	// Default CScrollView end printing
	CScrollView::OnEndPrinting(pDC, pInfo);
}

/////////////////////////////////////////////////////////////////////////////
// CODBCMTView diagnostics

#ifdef _DEBUG
void CODBCMTView::AssertValid() const
{
	CScrollView::AssertValid();
}

void CODBCMTView::Dump(CDumpContext& dc) const
{
	CScrollView::Dump(dc);
}

CODBCMTDoc* CODBCMTView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CODBCMTDoc)));
	return (CODBCMTDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CODBCMTView message handlers

 /*

LRESULT CRecalcView::OnNotifyStatus(WPARAM, LPARAM)
{
	GetDocument()->NotifyStatus();
	return 0;
}
*/


LRESULT CODBCMTView::OnExecuteDone(WPARAM wParam, LPARAM lParam)
{

	GetDocument()->ExecutionDone();
	return 0;
}

void CODBCMTView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	SetScrollSizes(MM_TEXT, GetDocument()->m_sizeDSN);
	CScrollView::OnUpdate(pSender,lHint,pHint);		
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\spdlg.h ===
// SPDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewSPDlg dialog

#include "resource.h"

class CNewSPDlg : public CDialog
{
// Construction
public:
	CNewSPDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewSPDlg)
	enum { IDD = IDD_NEWSP };
	CEdit	m_SPEdit;
	UINT	m_NoThreads;
	UINT	m_Delay;
	CString	m_SPName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewSPDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewSPDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ODBCMT.rc
//
#define IDD_ABOUTBOX                    100
#define ID_INDICATOR_FORRUN             101
#define ID_INDICATOR_RUNNING            102
#define IDR_MAINFRAME                   128
#define IDR_ODBCMTTYPE                  129
#define IDD_NEWSP                       130
#define IDD_EDITSP                      131
#define IDC_SPNAME                      1000
#define IDC_NOTHREADS                   1001
#define IDC_DELAY                       1002
#define IDC_APPLY                       1003
#define IDC_DSN                         1004
#define ID_CREATE_THREAD                32771
#define ID_THREAD_KILL_ALL              32772
#define ID_EXECUTE_ALL                  32773
#define ID_ADD_CONNECT                  32775
#define ID_EDIT_CONNECT                 32776
#define ID_EDIT_DISCONNECT              32777
#define ID_CONNECT_CLEAR                32778
#define ID_CONNECT_DISCONNECT           32779
#define ID_CONNECT_EDIT                 32780
#define ID_CONNECT_ADD                  32781
#define ID_CONNECT_RECONNECT            32782

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32784
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\odbcview.h ===
// ODBCMTView.h : interface of the CODBCMTView class
//
/////////////////////////////////////////////////////////////////////////////

class CODBCMTView : public CScrollView
{
protected: // create from serialization only
	CODBCMTView();
	DECLARE_DYNCREATE(CODBCMTView)

// Attributes
public:
	CODBCMTDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CODBCMTView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CODBCMTView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	LRESULT OnExecuteDone(WPARAM wParam, LPARAM lParam);

	//{{AFX_MSG(CODBCMTView)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in ODBCMTView.cpp
inline CODBCMTDoc* CODBCMTView::GetDocument()
   { return (CODBCMTDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\spdlg.cpp ===
// SPDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ODBCMT.h"
#include "SPDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewSPDlg dialog


CNewSPDlg::CNewSPDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNewSPDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewSPDlg)
	m_NoThreads = 1;
	m_Delay = 0;
	m_SPName = _T("");
	//}}AFX_DATA_INIT

}


void CNewSPDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewSPDlg)
	DDX_Control(pDX, IDC_SPNAME, m_SPEdit);
	DDX_Text(pDX, IDC_NOTHREADS, m_NoThreads);
	DDV_MinMaxUInt(pDX, m_NoThreads, 1, 50);
	DDX_Text(pDX, IDC_DELAY, m_Delay);
	DDV_MinMaxUInt(pDX, m_Delay, 0, 10000);
	DDX_Text(pDX, IDC_SPNAME, m_SPName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewSPDlg, CDialog)
	//{{AFX_MSG_MAP(CNewSPDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewSPDlg message handlers

BOOL CNewSPDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	m_SPEdit.SetFocus();

	return FALSE;  // return TRUE unless you set the focus to a control
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ODBCMT.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Bin\odbcmt.src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Src\sdi.h ===
///////////////////////////////////////////////////////////////////////////////
//	SQLSDI.H
//
//	Created by :			Updated :
//		ChrisKoz			9/15/96
//
//	Description :
//		Declaration of the CSQLSDICases class
//			Test cases for the SQL Debugger
//

#ifndef __SQLSDI_H__
#define __SQLSDI_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CSQLSDICases class
class CAddDSNTest : public CTest
{
	DECLARE_TEST(CAddDSNTest, CSniffDriver)

// Operations
	
public:
	virtual void Run(void);
	int SetBP(BPInfo *pBPInfo,CString &Server,CString &DataBase);

// Utility Functions
protected:
	BOOL ActivateContextMenu();
	BOOL ContextMenuChoice(CString strChoice);
	BOOL ActivatePropertiesWindow();
	BOOL bFileComp( CString cstrFile0, CString cstrFile1);

// Data
protected:

// Test Cases
protected:
	int CheckNodeProperties(LPCSTR Name);
	int SetBPOnStmt(CString Name,CString Stmt);

};



class CBuildTest : public CTest
{
	DECLARE_TEST(CBuildTest, CSniffDriver)

// Operations
protected:
	BOOL VerifyBP(void);
	void SetDebugTarget(void);
	BOOL BuildProject(void);

public:
	virtual void Run(void);
	virtual BOOL CBuildTest::RunAsDependent(void);

};

class CInprocTest : public CTest
{
	DECLARE_TEST(CInprocTest, CSniffDriver)

// Operations
	
public:
	virtual void Run(void);
};

class CAppTest : public CTest
{
	DECLARE_TEST(CAppTest, CSniffDriver)

// data
protected:
	CODebug m_coDebug;
// Operations
	
public:
	virtual void Run(void);
//	BOOL Wait(int WAIT);
	BOOL HitBreakpoints();


};


#endif //__SQLSDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Src\sdi.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SQLSDI.CPP
//
//	Created by :			Updated :
//		CHRISKOZ			5/15/97
//
//	Description :
//		Implementation of the CSQLSDICases class
//			Test cases for the SQL debugger
//

#include "stdafx.h"
#include "sniff.h"
#include "sdi.h"

#include <objbase.h>
#include <initguid.h>
#include "evnthdlr.h" //MSDEV object model

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


IMPLEMENT_TEST(CAddDSNTest,CTest, NULL, -1, CSniffDriver)
IMPLEMENT_TEST(CBuildTest, CTest, NULL, -1, CSniffDriver)
IMPLEMENT_TEST(CInprocTest,CTest, NULL, -1, CSniffDriver)
IMPLEMENT_TEST(CAppTest,   CTest, NULL, -1, CSniffDriver)

////////////////////////////////////////////////
// sets the project as an active one
//	  projectNo - 1-based number of the project to be activated
//
//
void SetActiveProject(int projectNo)
{
	ASSERT(projectNo>0);
	UIWB.DoCommand(IDM_PROJ_ACTIVEPROJMENU, DC_MNEMONIC);
	Sleep(500);
	for(int i=0;i<projectNo;i++)
	{
		MST.DoKeys("{DOWN}");
		Sleep(500);  
	}
	MST.DoKeys("{ENTER}");	//select
} // SetActiveProject

///////////////////////////////////////////////////////////////////////////////////////
// CAddDSNTest
///////////////////////////////////////////////////////////////////////////////////////
void CAddDSNTest::Run(void)
{
	
	// !!! Replace with string resources for localization
	CSniffDriver* pSubSuite = GetSubSuite();
	pSubSuite->OpenProject();

	BOOL bResult=pSubSuite->m_prj.NewProject(DATABASE_PROJECT,
		pSubSuite->m_AppName + "1",GetCWD()+pSubSuite->m_AppName,
		GetUserTargetPlatforms(),TRUE);
	for(int ind=0;ind<pSubSuite->m_Servers;ind++)
	{
		bResult=pSubSuite->m_prj.AddSQLDataSource(
			pSubSuite->m_svrtable[ind].m_DSN,pSubSuite->m_svrtable[ind].m_User,
			pSubSuite->m_svrtable[ind].m_Psw,pSubSuite->m_svrtable[ind].m_DataBase);
		if(!GetLog()->RecordCompare(bResult == ERROR_SUCCESS, 
					"Opening the SQL Server '%s' database %s.",
					pSubSuite->m_svrtable[ind].m_Server,
					pSubSuite->m_svrtable[ind].m_DSN))
			throw CTestException("Cannot establish the connection; unable to continue.\n", 
					CTestException::causeOperationFail);
		if(pSubSuite->SelectDatabase(
			pSubSuite->m_svrtable[ind].m_Server,
			pSubSuite->m_svrtable[ind].m_DataBase)
			==ERROR_SUCCESS)
		{
			LPCSTR szScript=pSubSuite->m_svrtable[ind].m_SpScripts;
			for(szScript=strtok((LPSTR)szScript,"\n\t ");szScript!=NULL;szScript=strtok(NULL,"\n\t "))
			{
				UIWB.OpenFile(m_strCWD + szScript);
				UIWB.DoCommand(IDM_TOOLS_RUNMENU, DC_MNEMONIC); //&Tools.&Run
				UIMessageBox wndMsgBox;
				if (wndMsgBox.AttachActive())// If we can attach, an error must've occurred.
				{
					char title[128];
					::GetWindowText(wndMsgBox, title, 128);
					if(MST.WFndWndWait("Server Error(s)"/*GetLocString()*/, FW_PART, 0))
					{
						LOG->Comment("'Server Error(s)' message box detected while executing '%s' script", szScript);
					}
					else
					{
						LOG->Comment("Unknown (%s) message box detected while executing '%s' script",title, szScript);
					}
					throw CTestException("Cannot execute setup SQL script. Unable to continue\n",
						CTestException::causeOperationFail);
					//wndMsgBox.ButtonClick(); //does not work for server error(s)
					MST.DoKeys("{ENTER}");
				}
			} //for m_SpScripts

		} //SelectDatabase
	} //for m_Servers
	UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);

	//setting the breakpoints on the stored procedures
	//make the first project the active one
	SetActiveProject(1); //active the native C++ project

	WaitForInputIdle(g_hTargetProc, 5000); // wait while project switched
	BPInfo *pbpTable=pSubSuite->BPTable;
	for(int i=0;i<pSubSuite->m_BPs;i++)
	{
		struct CSniffDriver::serverinfo *srvinfo=pSubSuite->m_svrtable+pbpTable[i].ServerInd;
		if(SetBP(&pbpTable[i],srvinfo->m_Server,srvinfo->m_DataBase)!=ERROR_SUCCESS)
			LOG->RecordInfo("Failed to set the BP in %s, on: %s",
			pbpTable[i].Proc,pbpTable[i].Stmt);
		if(pbpTable[i].HitCount==0)
		{
			LOG->RecordInfo("Disabling the breakpoint: %s", pbpTable[i].Stmt);
			UIBreakpoints UIBP;
			if(UIBP.Activate()==FALSE)
			{
				LOG->RecordFailure("Couldn't activate Breakpoints dialog");
			}
			else
			{
				if(UIBP.Disable(i)==FALSE)
					LOG->RecordFailure("Couldn't disable the BP");
				UIBP.Close();
			}
		}
	}
	pSubSuite->m_prj.Close(TRUE);
	pSubSuite->m_projOpen=0;
}

//Sets the breakpoint on the SP
// Stmt - Statement to set the BR on (usually the first word)
// Server - server name to take it from
// DataBase - database name to take it from
// ProcName - name of the procedure
// Table - name of the table if this is a trigger (NULL if the procedure)
int CAddDSNTest::SetBP(BPInfo *pBPInfo,CString &Server,CString &DataBase)
{
	CString ProcName=pBPInfo->Proc;
	CString Stmt=pBPInfo->Stmt;
    GetLog()->RecordInfo("Setting breakpoint on: %s in procedure %s",Stmt, ProcName);
	char strname[256];
	strncpy(strname,ProcName,255);
	if(ProcName.Find(";")>0)
	{	// trigger name - must go through tables
		GetSubSuite()->ExpandTable(Server,DataBase,strtok(strname,";"));
		strcpy(strname,strtok(NULL,";"));
		MST.DoKeys(strname);
	}
	else
	{
		GetSubSuite()->ExpandProcedureNode(Server,DataBase);
		MST.DoKeys(strname);
	}
	int ret=CheckNodeProperties(strname);
	if(ret!=ERROR_ERROR)
	{
		GetLog()->RecordSuccess("Found the procedure: %s",ProcName);
		ret=SetBPOnStmt(/*ProcName*/strname,Stmt);
		LOG->RecordCompare(ret == ERROR_SUCCESS,
			"Setting BP on procedure: %s",ProcName);
		UIWorkspaceWindow wnd; //same as DoKeys("%VK") returns to the workspace

	}
	GetSubSuite()->CollapseObjects();
	return ret;
}


int CAddDSNTest::CheckNodeProperties(LPCSTR Name)
{
	MST.DoKeys("%({Enter})"); //bring up the properties
	BOOL bFound = FALSE;
	int ret=ERROR_SUCCESS;
	int nSec = 10;
	while (!bFound && ret == ERROR_SUCCESS)
	{
		// Attempt to open the property page for the Data Source
		
		
		CString str;
		MST.WGetText(NULL, str); //should be "<Object type> Properties"
		if(str.Find(GetLocString(IDSS_PROP_TITLE))>0)
		{
			if(nSec>2)nSec=2; //properties window is up, but XTRA safety required!
		}
		//TODO add check for the object type
		if (MST.WStaticExists(Name))
			//TODO add when applicable for each object  && MST.WStaticExists(pMember->GetType())) 
		{
			bFound = TRUE;
		}
		else
		{
			if (--nSec > 0) // If we still have some waiting time...
			{
				GetLog()->RecordInfo("Waiting up to %d more second(s) for properties of %s...", 
					nSec,Name);
				Sleep(1000);
			}
			else                // We've timed out.
			{       
				GetLog()->RecordFailure(
					"Timeout waiting for properties of: %s",Name);
				ret = ERROR_ERROR;
			}
		}
	} //while
	MST.DoKeys("{Escape}"); // close the property page
	return ret;
}
/////////////////////////////////////////////////////////////////////
//	Sets the bpreakpoint in the SP or trigger highlithed in the workspace
//	on the specified statement
// Opens the source window for the object type != TABLE or VIEW
// checks the source window could be opened, finds the Stmt and put BP
// Params:
//	Name - name of the SP or trigger (without table name)
//	Stmt - first few characters uniquely identifying Stmt within the SP/trigger scope
//			(without the leading blanks)
// RETURNS: ERROR_SUCCESS if OK
////////////////////////////////////////////////////////////////////
int CAddDSNTest::SetBPOnStmt(CString Name,CString Stmt)
{
	int ret = ERROR_SUCCESS;
	Name.MakeUpper();
	Stmt.MakeUpper();

//	MST.DoKeys("+({F10})");		// Bring up the popup context menu.
	Sleep(1000); //xtra safety
//	CString strOpenMenuItem = GetLocString(IDSS_FO_TITLE);

//	if (!MST.WMenuExists(strOpenMenuItem)) //This one GPFs due to wrong calling convention
//	int count;
//	if((count=MST.WMenuCount())==0) 
//		ret = ERROR_NO_DEFINITION;	//this does not work, MenuCount always returns 0

	MST.DoKeys("{Enter}");
//	MST.DoKeys("O"); //for open, provided the lack of better handle
	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
	Sleep(1000);							// Wait for message box to arrive.

//	UIMessageBox wndMsgBox;
//	if (wndMsgBox.AttachActive())			// If we can attach, then an error must've occurred.
//	{
//		ret = ERROR_NO_DEFINITION;
//		wndMsgBox.ButtonClick();
//	}
//	else									// A source window must've become active.
	{
		COSource SrcFile;
//		CString title=DataInfo->m_strServer+"!"+DataInfo->m_strName;	
// TODO: change to better title	when available
		CString title=Name;
		title.MakeUpper();

//		SrcFile.AttachActiveEditor();
		if(MST.WFndWnd(title, FW_PART | FW_FOCUS)==NULL )
		{
			LOG->RecordFailure("Didn't find the title source window: %s",title);
			ret=ERROR_ERROR;
		}
		ret= SrcFile.Find(Stmt);
		if(ret==TRUE)
		{
			MST.DoKeys("{F9}");
			LOG->RecordSuccess("BP on stmnmt: %s in proc: %s",Stmt,Name);
			return ERROR_SUCCESS;
		}
		return ERROR_ERROR;
	}
	
	return ret;
}



///////////////////////////////////////////////////////////////////////////////
//	Utility Functions
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////
// CBuildTest
///////////////////////////////////////////////////////////////////////////////////////

BOOL CBuildTest::RunAsDependent(void)
{
	return TRUE; //run always if needed
}

void CBuildTest::Run(void)
{
	GetSubSuite()->OpenProject();
	VerifyBP();
	SetDebugTarget();
	BuildProject();
}



BOOL CBuildTest::VerifyBP(void)
{
	UIBreakpoints UIBP;
	GetLog()->RecordInfo("Verifying SQL Breakpoints...");
	if(UIBP.Activate()==FALSE)
	{
		LOG->RecordFailure("Couldn't activate Breakpoints dialog");
		return FALSE;
	}
	int count=UIBP.GetCount()-1; // funny bug - GetCount() returns count+1
	if(count!=GetSubSuite()->m_BPs)
		LOG->RecordFailure("Only %d breakpoints recovered. Expected %d",count,GetSubSuite()->m_BPs);
	//TODO don't check the location here
	//make sure  you validate the pwd on edit code
	//but check if you can hit edit code from here
	//would be nice to check each BP being enabled, but no good COBP function exist
	//consider OLE Aut for this purpose
	UIBP.Close();
	return TRUE;
}



void CBuildTest::SetDebugTarget(void)
{
	CString DebugTrg=GetLocString(IDSS_WIN32_DEBUG);
	BOOL bPass = GetSubSuite()->m_prj.SetTarget(DebugTrg);
	LOG->RecordCompare(bPass==ERROR_SUCCESS,"Setting target to %s", DebugTrg);
}


BOOL CBuildTest::BuildProject(void)
{
	BOOL bResult;

	// get the project from the subsuite
	COProject* pPrj = &(GetSubSuite()->m_prj);

	GetLog()->RecordInfo("Building project...");

	// build the project
	GetLog()->RecordCompare(pPrj->Build( 60 ) == ERROR_SUCCESS, "Building project.");


	GetLog()->RecordInfo("Verifying the build...");

	// verify the build
	bResult = GetLog()->RecordCompare(pPrj->VerifyBuild(TRUE) == ERROR_SUCCESS, "Verifying build.");
	if (!bResult) {
		throw CTestException("CSysBuildTest::BuildProject: cannot build the Application project; unable to continue.", CTestException::causeOperationFail);
	}
	return bResult;
}


BOOL StoredProcParam(LPCSTR Params=NULL);
///////////////////////////////////////////////////////////////////////////////////////
// CInprocTest
///////////////////////////////////////////////////////////////////////////////////////
void CInprocTest::Run(void)
{
	CSniffDriver *pSubSuite=GetSubSuite();
	pSubSuite->OpenProject();
	BPInfo *pbpTable=pSubSuite->BPTable;
//REVIEW: CHRISKOZ, I have to force the password at the begining,
//	because the login dialogs come unpredictably without any relation to BPs	
	int ret=ERROR_SUCCESS;
	for(int indsvr=0;indsvr<pSubSuite->m_Servers;indsvr++)
	if(pSubSuite->m_svrtable[indsvr].m_Psw.GetLength()!=0 &&
		pSubSuite->m_projOpen<0)
	{	//	ForcePasword();
			LPCSTR ServerName=pSubSuite->m_svrtable[indsvr].m_Server;
			LPCSTR DataBase=pSubSuite->m_svrtable[indsvr].m_DataBase;
			UIWorkspaceWindow wnd;
			Sleep(1000); //Xtra safety
			wnd.ActivateDataPane();
			
			LOG->RecordInfo("Forcing the Login dialog to validate password");
			Sleep(1000); //Xtra safety
			MST.DoKeys("{Left}{Left}{Left}{Right}"); //expand the datasources
			Sleep(1000); //Xtra safety
			//TODO this sequence can be changed
			MST.DoKeys(DataBase,TRUE);
			MST.DoKeys(" (",TRUE);
			MST.DoKeys(ServerName,TRUE);
				
			MST.DoKeys("(%{Enter})"); //bring up the properties

			int bResult=pSubSuite->m_prj.ValidatePassword(
			pSubSuite->m_svrtable[indsvr].m_User,
			pSubSuite->m_svrtable[indsvr].m_Psw,
			pSubSuite->m_svrtable[indsvr].m_DataBase);
			if(bResult!=ERROR_SUCCESS)
			{
				ret=ERROR_ERROR;
				break;
			}
	} //force pasword
	if(ret==ERROR_SUCCESS)
		pSubSuite->m_projOpen=1;
//force password

	SetActiveProject(2); //active SQL project
	for(int ind=0;ind<pSubSuite->m_BPs;ind++)
	{
		int svrno=pbpTable[ind].ServerInd;
		UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);
		UIBreakpoints UIBP;
		GetLog()->RecordInfo("Openning SPs with SQL Breakpoints...");
		if(UIBP.Activate()==FALSE)
		{
			LOG->RecordFailure("Couldn't activate Breakpoints dialog");
//			return FALSE;
			return;
		}
		int count=UIBP.GetCount()-1; // funny bug - GetCount() returns count+1
		MST.WListItemClk(GetLabel(0x7d0),ind+1); //select the item from BP list
		MST.WButtonClick(GetLabel(0x7d1)); // edit code
		// start 3D debugging for the active window
		BOOL bPass = TRUE;
		CODebug debug;
		// hack: the SQL Server Login dialog must be validated
		if(pSubSuite->m_svrtable[svrno].m_Psw.GetLength()!=0 &&
			pSubSuite->m_projOpen<0)
		{
			if(pSubSuite->m_prj.ValidatePassword(
				pSubSuite->m_svrtable[svrno].m_User,
				pSubSuite->m_svrtable[svrno].m_Psw,
				pSubSuite->m_svrtable[svrno].m_DataBase)==ERROR_SUCCESS)
			pSubSuite->m_projOpen=1;
			else MST.WButtonClick(GetLabel(IDCANCEL));
		}
		WaitForInputIdle(g_hTargetProc, 5000);
		Sleep(2000); //safety: MSDev returns out of Idle but the debug is inactive for some obscure reason
		CString str;
		MST.WGetText(NULL, str); //should be the name of the SP window
		// TODO - write the procedure to check the window title
		// CheckCurrentSP(
		//	CString str /*window title or NULL if active*/
		//	CString Proc /* pbpTable[ind].Proc */ )
		GetLog()->RecordInfo("Opened the SP window: %s",str);
		
		if(pbpTable[ind].Proc.Find(';')>0)
			continue; // do not try to debug the trigger
		GetLog()->RecordInfo("Debugging SP: %s",pbpTable[ind].Proc);

//		if((bPass=debug.Go())==FALSE)
		for(int cnt=0;cnt<3;cnt++)
		{	//assume 3 times here. You'd better read it from params
			if(cnt==0)
			{
				MST.DoKeys("{F5}"); //debug
				bPass=StoredProcParam(); //waits for break
			}
			else if(cnt==1)
			{	// do StepInto two (2) times
				bPass=debug.StepInto(2,NULL,NULL,NULL,WAIT_FOR_BREAK);
			}
			else // cnt==2
			{
				bPass=UIWB.Go(WAIT_FOR_BREAK);
			}
			if(bPass==FALSE)
			{
//				while(1) //remove this line later
//					Sleep(100000);
				LOG->RecordFailure("Didn't break in 3D debugging");
				throw CTestException("SQL debugging broken; unable to continue.\nCheck if AutMgr32 is running.\nCheck this machine's & server's error log.\n", 
					CTestException::causeOperationFail);
				break;
			}
		}
		if(bPass==FALSE)
			break;
		if((bPass=debug.StopDebugging())==FALSE)
		{
//			while(1) //remove this line later
//				Sleep(100000);
			LOG->RecordFailure("Didn't stopped 3D debugging");
			throw CTestException("3D debugging broken; unable to continue.\nCheck if AutMgr32 is running.\nCheck this machine's & server's error log.\n", 
				CTestException::causeOperationFail);
			break;
		}
		GetLog()->RecordSuccess("Debugging SP: %s",pbpTable[ind].Proc);
	} //for
	UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);
}


////////////////////////////////////////////////////////////////////
// Waits for the MS Developper St [break] title
// Meanwhile, dismiss the SP params dialog
//
// RETURN - TRUE if success, otherwise FALSE 
////////////////////////////////////////////////////////////////////
BOOL StoredProcParam(LPCSTR Params /*=NULL*/)
{
	int nSec=60;
	BOOL bFound=FALSE;
	while (nSec>0)
	{
		CString str;
		CString szTitleBreak  = "[";
		szTitleBreak+=GetLocString(IDSS_DBG_BREAK);
		szTitleBreak+="]";
		MST.WGetText(NULL, str); //should be ServerName - APPNAME"
		nSec--;
		if(str.Find(GetLocString(IDSS_WORKBENCH_TITLEBAR))>=0 &&
			str.Find(szTitleBreak)>=0)
		{
			LOG->RecordSuccess("Found the break in the window title");
			Sleep(1000); //break in window title is up, but XTRA safety required!
			bFound = TRUE;
			break;
		}
		else if(str.Find(GetLocString(IDSS_RUN_STOREDPROC)) >=0)
		{	// the SQL param dlg popped up
			//TODO maybe do not run something which requires the param
			MST.WButtonClick(GetLabel(IDOK)); // accept defaults
		}
		else
		{	if (nSec > 0) // If we still have some waiting time...
			{
			LOG->RecordInfo("Current wnd title: %s",str);
			LOG->RecordInfo("Expected wnd title: %s %s",
				GetLocString(IDSS_WORKBENCH_TITLEBAR),szTitleBreak);
			LOG->RecordInfo("Waiting up to %d more second(s) for an expected window",nSec);
			Sleep(1000);
			}
			else                // We've timed out.
				LOG->RecordFailure("Timeout waiting for the Devstudio window");
		}
	} //while */
	return bFound;
}

///////////////////////////////////////////////////////////////////////////////////////
// CAppTest
///////////////////////////////////////////////////////////////////////////////////////
BOOL  WaitForAppWnd(CString &StrTitle);

void CAppTest::Run(void)
{
	::OleInitialize(NULL);
	CSniffDriver* pSubSuite = GetSubSuite();
	BOOL bPass =pSubSuite->OpenProject();
	int ret=ERROR_SUCCESS;
	for(int indsvr=0;indsvr<pSubSuite->m_Servers;indsvr++)
	if(pSubSuite->m_svrtable[indsvr].m_Psw.GetLength()!=0 &&
		pSubSuite->m_projOpen<0)
	{	//	ForcePasword();
			LPCSTR ServerName=pSubSuite->m_svrtable[indsvr].m_Server;
			LPCSTR DataBase=pSubSuite->m_svrtable[indsvr].m_DataBase;
			UIWorkspaceWindow wnd;
			Sleep(1000); //Xtra safety
			wnd.ActivateDataPane();
			
			LOG->RecordInfo("Forcing the Login dialog to validate password");
			Sleep(1000); //Xtra safety
			MST.DoKeys("{Left}{Left}{Left}{Right}"); //expand the datasources
			Sleep(1000); //Xtra safety
			//TODO this sequence can be changed
			MST.DoKeys(DataBase,TRUE);
			MST.DoKeys(" (",TRUE);
			MST.DoKeys(ServerName,TRUE);
				
			MST.DoKeys("(%{Enter})"); //bring up the properties

			BOOL bResult=pSubSuite->m_prj.ValidatePassword(
			pSubSuite->m_svrtable[indsvr].m_User,
			pSubSuite->m_svrtable[indsvr].m_Psw,
			pSubSuite->m_svrtable[indsvr].m_DataBase);
			if(bResult!=ERROR_SUCCESS)
			{
				ret=ERROR_ERROR;
				break;
			}
	} //force pasword
	if(ret==ERROR_SUCCESS)
		pSubSuite->m_projOpen=1;
//force password

	SetActiveProject(1); // active the native C++ project
	{ //obsolete - same as CBuildTest::SetDebugTarget()
		CString DebugTrg=GetLocString(IDSS_WIN32_DEBUG);
		bPass = GetSubSuite()->m_prj.SetTarget(DebugTrg);
	}
	//review CHRISKOZ: default file to grab is the FIRST server name from tha server table
	CString strArguments=pSubSuite->m_SuiteParams->GetTextValue("APPCMD", GetSubSuite()->m_svrtable[0].m_Server + " /r");
	bPass=GetSubSuite()->m_prj.SetProgramArguments(strArguments);
	LOG->RecordCompare(bPass==ERROR_SUCCESS,"Setting argument");
 	
	int debugcount=pSubSuite->m_SuiteParams->GetIntValue("DEBUGCOUNT", 1);
	bPass=TRUE;
	while(debugcount>0 && bPass==TRUE)
	{
		//	use UIWB.Go rather thsn CODebug.go here, because you do want the focus to be on the APP
		// bPass=UIWB.Go(NOWAIT); //does not work, hangs sometimes
		bPass=TRUE;MST.DoKeys("{F5}");Sleep(5000);//instead the prev line
		LOG->RecordCompare(bPass==TRUE,"Lanching ODBC application");
		if(bPass==FALSE)
			break;
		//wait until ODBC app gets the focus if you launched with /r option

		/*	BOOL  bFound=WaitForAppWnd(APPNAME +" - "+GetSubSuite()->m_Server);
		if(bFound==TRUE)
		{
			LOG->RecordInfo("Now hitting the <APPLICATION> menu...");
			MST.DoKeys("%CR");	//reconnect all (temporary test)
			Sleep(10000);		//safety
			MST.DoKeys("%TC");	// create threads
			Sleep(1000);
			MST.DoKeys("%TE");	// execute threads
			Sleep(1000);
		}
		bFound=Wait(WAIT_FOR_BREAK); //just wait, no F5 key
		//bFound = m_coDebug.Go(NULL, NULL, NULL, WAIT_FOR_BREAK); */
		bPass=HitBreakpoints();	//we'll see how it runs
		debugcount--;
		UIWB.Activate(); //focus problem when debugee running
		UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);
	}
	LOG->RecordInfo("Uninitalizing OLE...");
	::OleUninitialize();
}


BOOL  WaitForAppWnd(CString &StrTitle)
{
	BOOL bFound=FALSE;
	int nSec = 30;
	CString strExpect=StrTitle;
	strExpect.MakeUpper();
	while (nSec>0)
	{
		CString str;
		MST.WGetText(NULL, str); //should be ServerName - APPNAME"
		str.MakeUpper();
		if(str.Find(strExpect)>=0)
		{
			Sleep(1000); //APP window is up, but XTRA safety required!
			bFound = TRUE;
			break;
		}
		else if (--nSec > 0) // If we still have some waiting time...
		{
			LOG->RecordInfo("Current wnd title: %s",str);
			LOG->RecordInfo("Expected wnd title: %s",strExpect);
			LOG->RecordInfo("Waiting up to %d more second(s) for App window...",nSec);
			Sleep(1000);
		}
		else                // We've timed out.
		{
			LOG->RecordFailure("Timeout waiting for the App window");
		}
	} //while */
	return bFound;
}


BOOL WaitState(IDebugger *pDbg,int WAIT);

////////////////////////////////////////////////////////////////////
// Retreives pointers to the app,debugger,doc objects in DevStudio
// Hits run in debugger object and calculates the locations stopped
//
// RETURN - TRUE if success, otherwise FALSE 
////////////////////////////////////////////////////////////////////
BOOL CAppTest::HitBreakpoints()
{
	BOOL bPass=TRUE;
	int hitcount[100]; //I hope 100 is MAX big enough
	int nb_hits=0; //number times breakpoints must be hit
	BPInfo *pbpTable=GetSubSuite()->BPTable;
	for(int i=0;i<GetSubSuite()->m_BPs;i++)
	{
		hitcount[i]=pbpTable[i].HitCount;
		nb_hits+=hitcount[i];
	}
//	BOOL debugide=GetSubSuite()->GetIDE()->GetSettings()->GetBooleanValue(settingDebugBuild);

	IApplication *pApp=UIWB.m_pEventHandler->m_pApp;
	IDebugger *pDbg=UIWB.m_pEventHandler->m_pDbg;
//short lived interfaces we must get from IApplication
	ITextDocument	*pDoc = NULL;
	ITextSelection	*pSel = NULL;
	ITextWindow		*pTextWin = NULL;
	IUnknown	*pUnk = NULL;
	IDispatch	*pDisp = NULL;
	HRESULT hr;
	try 
	{
		while(--nb_hits>=0)
		{
			WaitStepInstructions("Looping in Debugger Object...");
			bPass=WaitState(pDbg,WAIT_FOR_BREAK);  // wait for break in the IDE title
			if(bPass==FALSE)
			{
				pDbg->Stop();
				throw CTestException("Cannot break in the debugger; Unable to continue.\n", 
					CTestException::causeOperationFail);
			}		
			if(FAILED(hr=pApp->get_ActiveDocument(&pDisp))
			|| FAILED(hr=pDisp->QueryInterface(IID_ITextDocument, (void**)&pDoc)))
		        throw CTestException("COM error in OLEAUT.\n", 
						CTestException::causeOperationFail);
			pDisp->Release();pDisp=NULL;
				#ifdef _DEBUG
				LOG->RecordInfo("\tGot the text document");
				#endif
			if(FAILED(hr=pDoc->get_Selection(&pDisp))
			|| FAILED(hr=pDisp->QueryInterface(IID_ITextSelection, (void**)&pSel)))
		        throw CTestException("COM error in OLEAUT.\n", 
						CTestException::causeOperationFail);
			pDisp->Release();pDisp=NULL;
				#ifdef _DEBUG
				LOG->RecordInfo("\tGot the text selection");
				#endif
			BSTR bstrline;			
			BSTR bstrcaption;
			long lineno;
			pDoc->get_Name(&bstrline); //doc name always empty for SP
		    if(FAILED(hr=pDoc->get_ActiveWindow(&pDisp))
			|| FAILED(hr=pDisp->QueryInterface(IID_ITextWindow, (void**)&pTextWin)))
		        throw CTestException("COM error in OLEAUT.\n", 
						CTestException::causeOperationFail);
			pDisp->Release();pDisp=NULL;

			pTextWin->get_Caption(&bstrcaption);

			LOG->RecordInfo("Current wnd : %S", bstrcaption);
			pSel->SelectLine();
			pSel->get_Text(&bstrline);
				#ifdef _DEBUG
				LOG->RecordInfo("\tGot the current line text");
				#endif
			CString strFound;
			strFound.Format("%S",bstrline);
			strFound.TrimRight(); //get rid of tabs & EOL
			
			pSel->get_CurrentLine(&lineno);
				#ifdef _DEBUG
				LOG->RecordInfo("\tGot the current line number");
				#endif
			LOG->RecordInfo("Current line: '%s' #%d", strFound, lineno);


			LOG->RecordInfo("%d BPs left to be hit...",nb_hits);
			if(bPass==FALSE)
			{
				pDbg->Stop();
				break; //we didn't succeed - escape
			}
			strFound.TrimLeft();
			CString strCaption;
			strCaption.Format("%S", bstrcaption); 
			strCaption = strCaption.SpanExcluding(":");
			strCaption.TrimRight();
			for(int ind=0;ind<GetSubSuite()->m_BPs;ind++)
			{
				if(strFound.Find(pbpTable[ind].Stmt)==0) //must be match @1 character of the line
//				if(pbpTable[ind].Proc==strCaption)	//does not work for triggers
				{
					LOG->RecordInfo("Hit BP on stmnmt: %s in proc: %s",
					pbpTable[ind].Stmt,pbpTable[ind].Proc);
					hitcount[ind]--; //change local count table only
					break;
				}
			}  
			if(nb_hits>0)
			{
				LOG->RecordInfo("Hitting GO...");
				hr=pDbg->Go();
				//hr=pApp->ExecuteCommand(L"DebugGo"); //TODO: we need a BSTR rather than short* here
			}
			else
			{
				LOG->RecordInfo("Hitting STOP...");
				hr=pDbg->Stop();
				//hr=pApp->ExecuteCommand(L"DebugStopDebugging"); //TODO: we need a BSTR rather than short* here
				WaitState(pDbg,WAIT_FOR_TERMINATION);  // wait for termination
			}
			if(FAILED(hr))
		        throw CTestException("COM error in OLEAUT.\n", 
					CTestException::causeOperationFail);

			pDoc->Release();pDoc=NULL;
			pSel->Release();pSel=NULL;
			pTextWin->Release();pTextWin=NULL;
		} //while 
		if(bPass==TRUE)
		for(int i=0;i<GetSubSuite()->m_BPs;i++)
			if(hitcount[i]!=0)
			{
				LOG->RecordInfo("%d BP not hit %d times",i,hitcount[i]);
				bPass=FALSE;
			}
		LOG->RecordCompare(bPass!=FALSE,"Pass count in each BP hit");
    } 
	catch(...) 
	{ //catch all exceptions & do not rethrow as the interfaces must be released
        if(FAILED(hr))
			LOG->RecordFailure("COM error Code = %08lx" /*\n\tCode meaning = %s"*/, hr);
	}
	if(pDoc != NULL)pDoc->Release();
	if(pSel != NULL)pSel->Release();
	if(pTextWin != NULL)pTextWin->Release();
	if(pUnk != NULL)pUnk->Release();
	if(pDisp != NULL)pDisp->Release();
	return bPass;
} //CAppTest::HitBreakpoints()


//void dump_com_error(_com_error &e)
//{
//    LOG->RecordFailure("Hit a COM error!\n\tCode = %08lx\n\tCode meaning = %s",
//		e.Error(), e.ErrorMessage());
//}







////////////////////////////////////////////////////////////////////
// waits for devstudio active window with break in tile
// pDbg - pointer to the debugger object in DevStudio
// WAIT - WAIT_FOR_BREAK or WAIT_FOR_TERMINATION or WAIT_FOR_RUN
////////////////////////////////////////////////////////////////////
BOOL WaitState(IDebugger *pDbg,int WAIT)
{
	BOOL bSuccess=FALSE;
	int nSec=60;
	DsExecutionState expState;
	CString str_State;
	if(WAIT==WAIT_FOR_BREAK)
	{
		expState=dsBreak;
		str_State="break";
	}
	if(WAIT==WAIT_FOR_RUN)
	{
		expState=dsRunning;
		str_State="run";
	}
	if(WAIT==WAIT_FOR_TERMINATION)
	{
		expState=dsNoDebugee;
		str_State="finish";
	}
	while (nSec>0)
	{
		nSec-=2;
		DsExecutionState currentState;
		pDbg->get_State(&currentState);
		if(currentState==expState)
		{
			LOG->RecordSuccess("The debugger %ss", str_State);
			Sleep(1000); //break in window title is up, but XTRA safety required!
			bSuccess = TRUE;
			break;
		}
		else 
		{	
			if (nSec > 0) // If we still have some waiting time...
			{
				LOG->RecordInfo("Waiting up to %d more second(s) for an expected state",nSec);
				Sleep(2000);
			}
			else
			{
                // We've timed out.
				if(currentState==dsBreak)
					str_State="break";
				if(currentState==dsRunning)
					str_State="run";
				if(currentState==dsNoDebugee)
					str_State="finish";
				LOG->RecordInfo("Current Devstudio state: %s",str_State);
				LOG->RecordFailure("Timeout waiting for the correct state");				
			}
		}
	} //while */
	return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		Precompiled header for the VRes Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Bin\dlldbgee\dll.h ===
typedef int FAR PASCAL CallBackFCN();

__declspec(dllexport) int FAR callback(CallBackFCN lpfnCallBack, int x);
__declspec(dllexport) int  FAR  foo( int paramA, int paramB );
__declspec(dllexport) int  FAR  recursive_dll(int lim , int code);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Src\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      SNIFF.CPP
//
//      Created by :                    Updated:
//			Chriskoz                    9/15/96
//
//      Description :
//              implementation of the CSniffTest class
//

#include <process.h>
#include "stdafx.h"
#include "afxdllx.h"
#include "sniff.h"

#include "sdi.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

IMPLEMENT_SUBSUITE(CSniffDriver, CIDESubSuite, "SQLDebug Test", "ChrisKoz")
// IMPLEMENT_DESTROYSUBSUITE(CSniffDriver)


BEGIN_TESTLIST(CSniffDriver)
	BOOL brun;
	char buff[1024];
	m_AppName=m_SuiteParams->GetTextValue("APPNAME", "ODBCMT");  // or LOOPNT
	m_AppCmd=m_SuiteParams->GetTextValue("APPCMD", "<default>");// shld be <servername> /r
	CString strBPTableFile=m_SuiteParams->GetTextValue("BPTABLE", "sdibp.def");
	CString debugcount=m_SuiteParams->GetTextValue("DEBUGCOUNT", "1");

	brun=(m_SuiteParams->GetBooleanValue("DONTREBUILD", FALSE)==FALSE);
TEST(CAddDSNTest, (brun?RUN:DONTRUN))
	strcpy(buff,"Set SQLBPs - ");
	strcat(buff,strBPTableFile);
	pTest->SetName(buff);
TEST(CBuildTest, (brun?RUN:DONTRUN))
	strcpy(buff,"Ver.BPs,build ");
	strcat(buff,m_AppName);
	pTest->SetName(buff);
TEST(CInprocTest, RUN)
	strcpy(buff,"3D SQL Debug - ");
	strcat(buff,"1 time(s)");
	pTest->SetName(buff);		
	brun=!(m_SuiteParams->GetBooleanValue("LEGO", FALSE)!=FALSE
	||	CMDLINE->GetBooleanValue("LEGO", FALSE)!=FALSE);
TEST(CAppTest, (brun?RUN:DONTRUN))	// DEPENDENCY(CBuildTest)
	strcpy(buff,m_AppName);
	strcat(strcat(buff," "),m_AppCmd);
	strcat(buff," - ");
	strcat(strcat(buff,debugcount)," time(s)");
	pTest->SetName(buff);		
END_TESTLIST()


void CSniffDriver::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);
	// gather all command line info 
	m_AppName=m_SuiteParams->GetTextValue("APPNAME", "ODBCMT");  // or LOOPNT
	::CreateDirectory(m_strCWD + m_AppName, NULL); //create just in case it does not exist
	m_AppCmd=m_SuiteParams->GetTextValue("APPCMD", "GALSQL1 /r");			// or <servername> /r
	CString strBPTableFile=m_SuiteParams->GetTextValue("BPTABLE", "sdibp.def");

	// Read DataBase info into m_Server, m_DataBase, m_User, m_Psw, m_DSN
	GetDataInfo(strBPTableFile);
	// register >REG file or create the .DSN file
	if(RegisterAll()!=ERROR_SUCCESS)
		throw CTestException("Can't register the components. Unable to continue", CTestException::causeOperationFail);
	m_projOpen=0; //hack - proj->IsOpen() does not work
}

///////////////////////////////////////////////////////////////////
// Helper function to provide the data from the outer filename
// retreives the information from each line of the file in a form
// <TableName;><Procname> <Statement name>;<HitCount>
//where		TableName - name of table for trigger (empty for SP)
//			ProcName  - name of SP/trigger
//			Statement name - string (witthout ';') unique ident of the line
//			HitCount  - number of times BP is supposed to be hit.
//						BP wiil be  disabled if HitCount==0
void CSniffDriver::GetDataInfo(CString &strBPTableFile)
{
    CStdioFile fileVerify(m_strCWD + strBPTableFile,
		CFile::modeRead | CFile::typeText);

    CString str;
    const int len=100;
    char buf[len];
	int ind=0,indserver=0;
	CString strDelimiter("***");
	CString strEnd("$$$");

	BOOL done=FALSE;
	while(!done && fileVerify.ReadString(buf, len) && indserver<MAX_SRVTABLE)
	{
		if (strstr(buf,strEnd)==buf) //end of strings
			break;
		m_svrtable[indserver].m_Server=strtok(buf," ");
		m_svrtable[indserver].m_DataBase=strtok(NULL," ");
		m_svrtable[indserver].m_User=strtok(NULL," ");
		m_svrtable[indserver].m_Psw=strtok(NULL," ");
		TrimString(&m_svrtable[indserver].m_Server);
		TrimString(&m_svrtable[indserver].m_DataBase);
		TrimString(&m_svrtable[indserver].m_User);
		TrimString(&m_svrtable[indserver].m_Psw);
		if(m_svrtable[indserver].m_Server.Find("DSN=")==0)
		{
			m_svrtable[indserver].m_Server=m_svrtable[indserver].m_Server.Right(m_svrtable[indserver].m_Server.GetLength()-4);
			m_svrtable[indserver].m_DSN=m_strCWD + m_AppName + "\\" + m_svrtable[indserver].m_Server + ".DSN";
		}
		else
			m_svrtable[indserver].m_DSN="Test"+m_svrtable[indserver].m_Server;

		// Now get the information about the datasource BPS
		while (fileVerify.ReadString(buf, len) && ind<MAX_BPTABLE)
		{ //read info for one server
			str = buf;
			TrimString(&str);

			if (!str.IsEmpty() && str.GetAt(0) != ';')
			{
				if (str.Find(strDelimiter)==0)
				{
					char *pScripts = buf+strlen(strDelimiter);
					m_svrtable[indserver].m_SpScripts=pScripts;
					break;
				}
				else if(strstr(buf,strEnd)==buf)
				{
					done=TRUE;
					break;
				}
				else 
				{
				BPTable[ind].Proc=strtok(buf, " \t"); // valid ProcName
				BPTable[ind].Stmt=strtok(NULL, ";");// Stmt string
				BPTable[ind].HitCount=atoi(strtok(NULL, ";")); //hit count
				TrimString(&BPTable[ind].Proc);
				TrimString(&BPTable[ind].Stmt);
				BPTable[ind].ServerInd=indserver;
				ind++;
				}
			}
		} //while
		indserver++;
	}
	m_BPs=ind;
	m_Servers=indserver;
} //GetDataInfo


BOOL CSniffDriver::RegisterAll()
{
	for(int ind=0;ind<m_Servers;ind++)
	if(m_svrtable[ind].m_DSN.Right(4)==".DSN")
	{
		CStdioFile fileDSN(m_svrtable[ind].m_DSN, CFile::modeCreate | CFile::modeWrite | CFile::typeText);
		
		fileDSN.WriteString("[ODBC]\nDRIVER=SQL Server\nUID=");
		fileDSN.WriteString(m_svrtable[ind].m_User);
		
		fileDSN.WriteString("\nDATABASE=");
		fileDSN.WriteString(m_svrtable[ind].m_DataBase);
		
		fileDSN.WriteString("\nWSID=");
		DWORD len = MAX_COMPUTERNAME_LENGTH+1;
		char lpszNetName[MAX_COMPUTERNAME_LENGTH+1];
		if (!GetComputerName(lpszNetName, &len))
			strcpy(lpszNetName, "[Error calling GetComputerName()]");
		fileDSN.WriteString(lpszNetName);
		
		fileDSN.WriteString("\nAPP=");
		CString str;
		str.Format("%s - Owner: %s", (LPCSTR)GetName(), (LPCSTR)GetOwner());
		fileDSN.WriteString(str);
		
		fileDSN.WriteString("\nSERVER=");
		fileDSN.WriteString(m_svrtable[ind].m_Server);
		fileDSN.WriteString("\n");
	}
	
	if(_spawnlp( _P_WAIT, "regedit.exe", "regedit.exe", "/s",
		  m_strCWD + "SDI.REG", NULL )==-1)
	{
		AfxMessageBox("REG file registration failed");
		return ERROR_ERROR;		
	}
	
	return ERROR_SUCCESS;

}


void CSniffDriver::CleanUp(void)
{
	if (m_prj.IsOpen()) {
		m_prj.Close();
	}
	// gather all command line info 
	m_AppName=m_SuiteParams->GetTextValue("APPNAME", "ODBCMT");
	::CreateDirectory(m_strCWD + m_AppName, NULL); //create just in case it does not exist

	// remove the project directory
	if(m_SuiteParams->GetBooleanValue("DONTCLEAN", FALSE)==FALSE)
	{
		KillAllFiles(m_strCWD + m_AppName + "\\", FALSE);
		CopyTree(m_strCWD + m_AppName + ".SRC\\",m_strCWD + m_AppName + "\\");
	}
	m_projOpen=0;
	// call the base class
	CIDESubSuite::CleanUp();
}

BOOL CSniffDriver::OpenProject(void)
{
	BOOL bResult;
	
	// set the project's filename
	CString strProjFile = m_strCWD + m_AppName + "\\" + m_AppName + ".DSW";

	// open the project
	GetLog()->RecordInfo("Opening the project file '%s'...", (LPCSTR)strProjFile);

	// if the project's already open, no need to open it again
	if (m_projOpen!=0) 
	{
		GetLog()->RecordSuccess("The project '%s' is already open.", (LPCSTR)(m_prj.GetFullPath()));
		bResult=TRUE;
	}
	else {
		// open the project
		bResult = GetLog()->RecordCompare((m_prj.Open(strProjFile, 0) == ERROR_SUCCESS), "Opening the project file '%s'.", (LPCSTR)strProjFile);
		if (!bResult) {
			throw CTestException("CBuildTest::OpenProject: cannot open project; unable to continue.", CTestException::causeOperationFail);
		}
		m_projOpen=-1; // DSN not pwd validated
	}
	return bResult;
}

////////////////////////////////////////////////////////////////////////////
// utility functions
void CSniffDriver::CollapseObjects()
{
	MST.DoKeys("{Left}"); // goto the table
	Sleep(500); 			// Xtra Wait
	MST.DoKeys("{NUMPAD-}");// collapse table tree
	Sleep(500); 			// Xtra Wait
	MST.DoKeys("{Left}"); // goto the parent node
	Sleep(500); 			// Xtra Wait
	MST.DoKeys("{NUMPAD-}"); // collapse the expanded object
	Sleep(500); 			// Xtra Wait
	MST.DoKeys("{Left}"); // goto the parent node
	Sleep(500); 			// Xtra Wait
	MST.DoKeys("{NUMPAD-}");// collapse objects' tree
}

void CSniffDriver::ExpandTable(CString &Server,CString &DBName,LPCSTR strTableName)
{
	ExpandDatabase(Server,DBName);
	ExpandTableNode(Server,DBName);
	MST.DoKeys(strTableName);
	Sleep(2000); 			// Wait so next key isn't included in search
	MST.DoKeys("{NUMPAD+}");
	Sleep(500); 			// Xtra Wait
}



BOOL CSniffDriver::SelectDatabase(CString &Server,CString &strDBName)
{
	UIWorkspaceWindow wnd;
 	int ret=ERROR_SUCCESS;
	Sleep(1000); //Xtra safety
	wnd.ActivateDataPane();

	MST.DoKeys("^{HOME}");				// Go to top of tree
	MST.DoKeys("{NUMPAD-}");
	Sleep(500);
	MST.DoKeys("{NUMPAD+}");	// deploy the first level
	Sleep(500);
	//TODO this sequence can be changed
	MST.DoKeys(strDBName,TRUE);
	MST.DoKeys(" (",TRUE);
	MST.DoKeys(Server,TRUE);
	
	MST.DoKeys("%({Enter})"); //bring up the properties
	BOOL bReady = FALSE;
	int nSec = 5;
	while (!bReady && ret == ERROR_SUCCESS)
	{
			// Attempt to open the property page for the Data Source
			

			CString str;
			MST.WGetText(NULL, str);
	//		if(str.Find(GetLocString(IDSS_PROP_TITLE))>0)
	//			nSec=2; //properties window is up, but XTRA safety required!
			if (MST.WStaticExists(Server) && MST.WStaticExists(strDBName))
			{
				LOG->RecordSuccess("Found the DataSource properties");
				bReady = TRUE;
			}
			else
			{
				if (--nSec > 0)	// If we still have some waiting time...
				{
//					LOG->RecordInfo("Waiting up to %d more second(s) for datasource properties...", nSec);
					Sleep(1000);
				}
				else				// We've timed out.
				{
					LOG->RecordInfo("Didn't find the Datasource properties");
					ret = ERROR_ERROR;
				}
			}
	} //while
	MST.DoKeys("{Escape}");
	Sleep(2001); //timing problem hit when switched to mstest4.0
	return ret;		
}

int CSniffDriver::ExpandDatabase(CString &Server,CString &strDBName)
{
	if (SelectDatabase(Server,strDBName)!=ERROR_SUCCESS) 
	{
		return ERROR_ERROR;
	}
	MST.DoKeys("{NUMPAD-}");
	Sleep(500);
	MST.DoKeys("{NUMPAD+}");
	Sleep(500);
	return ERROR_SUCCESS;
}


void CSniffDriver::ExpandProcedureNode(CString &Server,CString &strDBName)
{
	ExpandDatabase(Server,strDBName);
	MST.DoKeys(GetLocString(IDSS_STOREDPROC)); //"Stored Procedures"
	Sleep(2000);						// Wait so next key isn't included in search
	MST.DoKeys("{NUMPAD+}");			// Expand the procedure node
	Sleep(500); 			// Xtra Wait
}


void CSniffDriver::ExpandTableNode(CString &Server,CString &strDBName)
{
	ExpandDatabase(Server,strDBName);
	MST.DoKeys(GetLocString(IDSS_TABLE)); // "Table"
	Sleep(2000);						// Wait so next key isn't included in search
	MST.DoKeys("{NUMPAD+}");			// Expand the Table node
	Sleep(500); 			// Xtra Wait
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Bin\dlldbgee\dll.c ===
/*DOC************************************************************************
**
** Suite : Callstack
** File  : foodll.c       DLL calls
**
** Purpose : test Codeview callstack
**
** General : callstack
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV420
**
** Revision History :
**
**DOC*************************************************************************/
#include <windows.h>
#include "main.h"
#include "dll.h"

int Global;

///////////////////////////////////////////////////////////////////////////
//INT WINAPI DllEntryPoint(HANDLE hInst, ULONG ulRbc, LPVOID lpReserved) {
int  WINAPI DllEntryPoint(HANDLE hInst, ULONG ulRbc, LPVOID lpReserved) {
// ulRbc is reason bieng called
    return 1;
} /* DllEntryPoint */


////////////////////////////////////////////////////////////////////////////

int FAR  foo( int paramA, int paramB )
{
   int Sum;
START:
   Global=3;
   Sum = paramA+paramB;
   return Global;
END:;
};


///////////////////////////////////////////////////////////////////////////
int  FAR recursive_dll(int lim , int reset)
{
    static cnt=0;
    static limit=0;

START:
    if (reset)
    {
        cnt=0;
        limit=lim;
    }
    cnt++;
    if (cnt < limit )
    {
        recursive_dll(cnt, FALSE);
    }
END:;
    return cnt;
}



///////////////////////////////////////////////////////////////////////////
int FAR callback(CallBackFCN lpfnCallBack, int x)
{
    int cnt;
    int sum;
    int tmp;

START:
    cnt=0;
    sum=0;
    tmp=0;
    for (cnt=0; cnt < x ; cnt++)
    {
        tmp = (*lpfnCallBack)();
        sum=sum+tmp;
    };
    return sum;
END:;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\SdiSniff\Src\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		Chriskoz			9/5/96
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#define MAX_BPTABLE 30
#define MAX_SRVTABLE 5 

///////////////////////////////////////////////////////////////////////////////
// CSniffDriver class

class BPInfo{
public:
	CString Proc;			//form of TABLE;TRIGGER if this is trigger
	CString Stmt;			//statement begining
	int		ServerInd;		//index of a server in servers table
	int		HitCount;		//how many times the BP is supposed to be hit
};

class CSniffDriver : public CIDESubSuite
{
	DECLARE_SUBSUITE(CSniffDriver)

	DECLARE_TESTLIST()

// Data members
public:
	CString m_AppName;			//name of the workspace to be open
	CString m_AppCmd;			//command arguments for the app
	COProject m_prj;			//project being open
	int		 m_projOpen;		//==0 closed, ==1 open ==-1 open, not pwd validated
	struct serverinfo
	{
		CString  m_DSN;				//data source name
		CString  m_Server;			//server name
		CString  m_User;			//user name
		CString  m_Psw;				//password
		CString  m_DataBase;		//database (might be different for same servers)
		CString  m_SpScripts;		//list of (blank separ) scripts to exec on setup
	}m_svrtable[MAX_SRVTABLE];
	int m_Servers;
	BPInfo BPTable[MAX_BPTABLE];
	int m_BPs;
// Member functions
BOOL RegisterAll();
void GetDataInfo(CString &bpTableFile);



// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
	virtual void CleanUp(void);

// utility functions
	BOOL OpenProject(void);
	void CollapseObjects();
	void ExpandTable(CString &Server,CString &DBName,LPCSTR strTableName);
	BOOL SelectDatabase(CString &Server,CString &strDBName);
	int ExpandDatabase(CString &Server,CString &strDBName);
	void ExpandProcedureNode(CString &Server,CString &strDBName);
	void ExpandTableNode(CString &Server,CString &strDBName);

};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Bin\dlldbgee\main.c ===
/*--------------------------------------------------------
   foo.C -- a hellowin.c vairiant, (c) Charles Petzold, 1990

  --------------------------------------------------------*/

#include <windows.h>
#define IDM_EXIT  100

LONG WINAPI WndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam);
int MyPostMessage( HWND hwnd );

extern int foo();
extern int recursive_dll();
extern int FAR callback();
int WINAPI mycallbackfcn();
int global;

int WINAPI  WinMain (HANDLE hInstance, HANDLE hPrevInstance,
                         LPSTR lpszCmdLine, int nCmdShow)
{

     static char szAppName[] = "foo" ;
     HWND        hwnd ;
     MSG         msg ;
     WNDCLASS    wndclass ;

     if (!hPrevInstance)
          {
          wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
          wndclass.lpfnWndProc   = WndProc ;
          wndclass.cbClsExtra    = 0 ;
          wndclass.cbWndExtra    = 0 ;
          wndclass.hInstance     = hInstance ;
          wndclass.hIcon         = LoadIcon(hInstance, szAppName); // Icon name from .rc
          wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
          wndclass.hbrBackground = GetStockObject (WHITE_BRUSH) ;
          wndclass.lpszMenuName  = szAppName ;
          wndclass.lpszClassName = szAppName ;

          RegisterClass (&wndclass) ;
          }

     hwnd = CreateWindow (szAppName,         // window class name
                    szAppName, 				// window caption
                    WS_OVERLAPPEDWINDOW,     // window style
                    CW_USEDEFAULT,           // initial x position
                    CW_USEDEFAULT,           // initial y position
                    CW_USEDEFAULT,           // initial x size
                    CW_USEDEFAULT,           // initial y size
                    NULL,                    // parent window handle
                    NULL,                    // window menu handle
                    hInstance,               // program instance handle
                    NULL) ;                  // creation parameters
     if (hwnd==0) {   //window not created
         return 1;
     }

     ShowWindow (hwnd, nCmdShow) ;
     UpdateWindow (hwnd) ;
     PostMessage( hwnd, WM_NULL, (WORD)0, (DWORD)0);

     while (GetMessage (&msg, NULL, 0, 0))
          {
          TranslateMessage (&msg) ;
          DispatchMessage (&msg) ;
          }
     return msg.wParam ;
     }


LONG WINAPI WndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam)
     {
     HDC         hdc ;
     PAINTSTRUCT ps ;
     RECT        rect ;
     static HANDLE hInst;
     static FARPROC pCB;
     int local;
     int localx;

     switch (message)
          {
          case WM_CREATE:
               hInst= ((LPCREATESTRUCT) lParam)->hInstance;
               ////////////// MAKE TESTING CALLS HERE  /////////
               local= foo(1 , 2);
               localx= recursive_dll(3 , FALSE);
CALL_CALLBACK:;
               pCB = MakeProcInstance(mycallbackfcn, hInst);
               global= callback(pCB, 4);

               for (local=0; local < 4; local++)
               {
                   for (global=10; global < 13; global++)
                   {
                       localx=local+global;
                   };
               };	//	_MIPS_:local is incremented
               global=0;
               localx=local/global;
               return 0 ;

          case WM_PAINT:
               hdc = BeginPaint (hwnd, &ps) ;
               GetClientRect (hwnd, &rect) ;
               DrawText (hdc, "Hello, Windows!", -1, &rect,
                          DT_SINGLELINE | DT_CENTER | DT_VCENTER) ;
               EndPaint (hwnd, &ps) ;
               return 0 ;

          case WM_COMMAND:        /* message: command from application menu */
               switch( wParam )
                  {
                  case IDM_EXIT:
                       DestroyWindow(hwnd);
                       break;
                  }
               break;

          case WM_DESTROY:
               PostQuitMessage (0) ;
               return 0 ;

          case WM_NULL:
               MyPostMessage(hwnd);
               return 0 ;
          }

     return DefWindowProc (hwnd, message, wParam, lParam) ;
}

int MyPostMessage( HWND hwnd )
{
    static int count = 0;
    if ( count < 5 )
    {
         PostMessage( hwnd, WM_PAINT, (WORD)0, (DWORD)0);
         PostMessage( hwnd, 0x0040, (WORD)0, (DWORD)0);
    }
    return count++;
}


int WINAPI mycallbackfcn()
{
   int x;

START:
   x=1;
   x=x+3;
   return x;
END:;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Bin\dlldbgee\main.h ===
#define TRUE    1
#define FALSE   0

#ifndef WIN32
  #ifndef FAR
    #define FAR                 _far
  #endif
typedef unsigned long ULONG;
typedef unsigned long INT;

#else
  #ifndef FAR
    #define FAR
  #endif
#endif

#pragma warning(disable:4102)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Bin\prtdbgee\types.h ===
/*
 	File:		Types.h
 
 	Contains:	Basic Macintosh data types.
 
 	Version:	Technology:	System 7.5
 				Package:	Universal Interfaces 2.1 in MPW Latest on ETO #18
 
 	Copyright:	 1984-1995 by Apple Computer, Inc.
 				All rights reserved.
 
 	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter
 				stack.  Include the file and version information (from above)
 				in the problem description and send to:
 					Internet:	apple.bugs@applelink.apple.com
 					AppleLink:	APPLE.BUGS
 
*/

#ifndef __TYPES__
#define __TYPES__


#ifdef  _MSC_VER
#include <MSVCMac.h>
#endif

#ifndef __CONDITIONALMACROS__
#include <ConditionalMacros.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if PRAGMA_ALIGN_SUPPORTED
#pragma options align=mac68k
#endif

#if PRAGMA_IMPORT_SUPPORTED
#pragma import on
#endif

#ifndef NULL
#if !defined(__cplusplus) && (defined(__SC__) || defined(THINK_C))
#define NULL ((void *) 0)
#else
#define NULL 0
#endif
#endif
#ifndef nil
#define nil NULL
#endif

enum {
	noErr						= 0
};

typedef unsigned char Byte;

typedef signed char SignedByte;

typedef Byte UInt8;

typedef SignedByte SInt8;

typedef unsigned short UInt16;

typedef signed short SInt16;

typedef unsigned long UInt32;

typedef signed long SInt32;

typedef UInt16 UniChar;

typedef char *Ptr;

typedef Ptr *Handle;

typedef long Fixed;

typedef Fixed *FixedPtr;

typedef long Fract;

typedef Fract *FractPtr;

struct _extended80 {
	short							exp;
	short							man[4];
};
struct _extended96 {
	short							exp[2];
	short							man[4];
};
#if GENERATING68K 
#if defined(__MWERKS__)
/* Note: Metrowerks on 68K doesn't declare 'extended' or 'comp' implicitly. */
typedef long double extended;
typedef struct comp { long hi,lo; } comp;

#elif defined(THINK_C)
/* Note: THINK C doesn't declare 'comp' implicitly and needs magic for 'extended' */
typedef struct { short man[4]; } comp;
typedef struct _extended80 __extended;	/*  <-- this line is magic */
typedef __extended extended;

#endif
/* 
Note: on PowerPC extended is undefined.
      on 68K when mc68881 is on, extended is 96 bits.  
             when mc68881 is off, extended is 80 bits.  
      Some old toolbox routines require an 80 bit extended so we define extended80
*/
#if GENERATING68881
typedef struct _extended80 extended80;

typedef extended extended96;

#else
typedef extended extended80;

typedef struct _extended96 extended96;

#endif
#else
typedef struct _extended80 extended80;

typedef struct _extended96 extended96;

#endif
/*
Note: float_t and double_t are "natural" computational types
      (i.e.the compiler/processor can most easily do floating point
	  operations with that type.) 
*/
#if GENERATINGPOWERPC
/* on PowerPC, double = 64-bit which is fastest.  float = 32-bit */
typedef float float_t;

typedef double double_t;

#else
/* on 68K, long double (a.k.a. extended) is always the fastest.  It is 80 or 96-bits */
typedef long double float_t;

typedef long double double_t;

#endif
struct wide {
	SInt32							hi;
	UInt32							lo;
};
typedef struct wide wide, *WidePtr;

struct UnsignedWide {
	UInt32							hi;
	UInt32							lo;
};
typedef struct UnsignedWide UnsignedWide, *UnsignedWidePtr;

#if defined(__SC__) && !defined(__STDC__) && defined(__cplusplus)
	class __machdl HandleObject {};
#if !GENERATINGPOWERPC
	class __pasobj PascalObject {};
#endif
#endif

enum {
	false,
	true
};

typedef unsigned char Boolean;


enum {
	v,
	h
};

typedef SInt8 VHSelect;

typedef long (*ProcPtr)();
typedef pascal void (*Register68kProcPtr)(void);
typedef ProcPtr *ProcHandle;

#if	USESROUTINEDESCRIPTORS
typedef struct RoutineDescriptor *UniversalProcPtr, **UniversalProcHandle;

#else
typedef ProcPtr UniversalProcPtr, *UniversalProcHandle;

#endif
typedef unsigned char Str255[256], Str63[64], Str32[33], Str31[32], Str27[28], Str15[16];

typedef unsigned char *StringPtr, **StringHandle;

typedef const unsigned char *ConstStr255Param;

typedef ConstStr255Param ConstStr63Param, ConstStr32Param, ConstStr31Param, ConstStr27Param, ConstStr15Param;

#ifdef __cplusplus
inline unsigned char StrLength(ConstStr255Param string) { return (*string); }
#else
#define StrLength(string) (*(unsigned char *)(string))
#endif
#if OLDROUTINENAMES
#define Length(string) StrLength(string)
#endif
typedef short OSErr;

typedef short ScriptCode;

typedef short LangCode;

typedef unsigned long FourCharCode;


enum {
	normal						= 0,
	bold						= 1,
	italic						= 2,
	underline					= 4,
	outline						= 8,
	shadow						= 0x10,
	condense					= 0x20,
	extend						= 0x40
};

typedef unsigned char Style;

typedef FourCharCode OSType;

typedef FourCharCode ResType;

typedef OSType *OSTypePtr;

typedef ResType *ResTypePtr;

struct Point {
	short							v;
	short							h;
};
typedef struct Point Point;

typedef Point *PointPtr;

struct Rect {
	short							top;
	short							left;
	short							bottom;
	short							right;
};
typedef struct Rect Rect;

typedef Rect *RectPtr;

/*
	kVariableLengthArray is used in array bounds to specify a variable length array.
	It is ususally used in variable length structs when the last field is an array
	of any size.  Before ANSI C, we used zero as the bounds of variable length 
	array, but that is illegal in ANSI C.  Example:
	
		struct FooList 
		{
			short 	listLength;
			Foo		elements[kVariableLengthArray];
		};
*/

enum {
	kVariableLengthArray		= 1
};

/* Numeric version part of 'vers' resource */
struct NumVersion {
	UInt8							majorRev;					/*1st part of version number in BCD*/
	UInt8							minorAndBugRev;				/*2nd & 3rd part of version number share a byte*/
	UInt8							stage;						/*stage code: dev, alpha, beta, final*/
	UInt8							nonRelRev;					/*revision level of non-released version*/
};
typedef struct NumVersion NumVersion;

/* 'vers' resource format */
struct VersRec {
	NumVersion						numericVersion;				/*encoded version number*/
	short							countryCode;				/*country code from intl utilities*/
	Str255							shortVersion;				/*version number string - worst case*/
	Str255							reserved;					/*longMessage string packed after shortVersion*/
};
typedef struct VersRec VersRec;

typedef VersRec *VersRecPtr, **VersRecHndl;

typedef struct OpaqueRef *KernelID;

typedef SInt32 OSStatus;

typedef void *LogicalAddress;

/*
	Who implements what debugger functions:
	
	Name			MacsBug				SADE		Macintosh Debugger
	----------		-----------			-------		-----------------------------
	Debugger		yes					no			InterfaceLib maps to DebugStr
	DebugStr		yes					no			yes
	Debugger68k		yes					no			InterfaceLib maps to DebugStr
	DebugStr68k		yes					no			InterfaceLib maps to DebugStr
	debugstr		yes					no			InterfaceLib maps to DebugStr
	SysBreak		no, for SADE		yes			InterfaceLib maps to SysError
	SysBreakStr		no, for SADE		yes			InterfaceLib maps to SysError
	SysBreakFunc	no, for SADE		yes			InterfaceLib maps to SysError

*/
extern pascal void Debugger(void)
 ONEWORDINLINE(0xA9FF);
extern pascal void DebugStr(ConstStr255Param debuggerMsg)
 ONEWORDINLINE(0xABFF);
extern pascal void Debugger68k(void)
 ONEWORDINLINE(0xA9FF);
extern pascal void DebugStr68k(ConstStr255Param debuggerMsg)
 ONEWORDINLINE(0xABFF);
#if CGLUESUPPORTED
extern void debugstr(const char *debuggerMsg);
#endif
extern pascal void SysBreak(void)
 THREEWORDINLINE(0x303C, 0xFE16, 0xA9C9);
extern pascal void SysBreakStr(ConstStr255Param debuggerMsg)
 THREEWORDINLINE(0x303C, 0xFE15, 0xA9C9);
extern pascal void SysBreakFunc(ConstStr255Param debuggerMsg)
 THREEWORDINLINE(0x303C, 0xFE14, 0xA9C9);

#if PRAGMA_IMPORT_SUPPORTED
#pragma import off
#endif

#if PRAGMA_ALIGN_SUPPORTED
#pragma options align=reset
#endif

#ifdef __cplusplus
}
#endif

#endif /* __TYPES__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Src\debugger.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Debugger.cpp
//
//	Created by :			Date :
//		Waynebr					2/18/94
//
//	Description :
//		Debugger tests helpers
//

#include "stdafx.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
//	Debugging helpers

int ReturnCode =0;
bp  * ReturnBP =0;

void LogResult(int result,LPCSTR szoperation, int code=0) {
	CString szextra;
	//if (code==0)  szextra="Error Code="+itoa(code);
	if (!result) {
		LOG->RecordFailure(szextra + szoperation);
	}
	else {
		LOG->RecordInfo(szextra + szoperation);
	}
};

//
//	Returns the current directory of the first time this function was called.
//
LPCSTR HomeDir()
{
	static CString szCurDir;

	if( szCurDir.IsEmpty() )
	{
		char* psz = szCurDir.GetBufferSetLength(_MAX_DIR);

		GetCurrentDirectory(_MAX_DIR - 1, psz);
		szCurDir.ReleaseBuffer(-1);
		if( szCurDir.Right(1) != '\\' )
			szCurDir += "\\";
	}
 	return szCurDir;
 }

//
//	Returns the fully qualified path with szAddPath appended to the sniff dir.	
//
 LPCSTR FullPath( LPCSTR szAddPath )
 {
	static CString szFilespec;

	szFilespec = HomeDir();
	szFilespec += szAddPath;

	return szFilespec;
 }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Src\debugger.h ===
///////////////////////////////////////////////////////////////////////////////
//	Debugger.H
//
//	Created by :			Date :
//		Waynebr					2/18/94
//
//	Description :
//		Debugger tests helpers
//

#ifndef __DEBUGGER_H__
#define __DEBUGGER_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
//	Debugging helpers

extern int ReturnCode;
extern bp  * ReturnBP;
extern void LogResult(int result,LPCSTR szoperation, int code=0);
extern LPCSTR HomeDir(void);
extern LPCSTR FullPath(LPCSTR szAddPath);

#define EXPECT_TRUE(f)    ((f)?LogResult(TRUE,#f):LogResult(FALSE,#f));
#define EXPECT_SUCCESS(f) (((ReturnCode=(f))==0)?LogResult(TRUE,#f):LogResult(FALSE,#f,ReturnCode));
#define EXPECT_VALIDBP(f) (((ReturnBP=(f))!=NULL)?LogResult(TRUE,#f):LogResult(FALSE,#f));


#endif //__DEBUGGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Src\prtcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	PRTCASES.H
//
//	Created by :			Date :
//		MichMa					10/5/94
//
//	Description :
//		Declaration of the CPortableDbgCases class
//

#ifndef __PRTCASES_H__
#define __PRTCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"


///////////////////////////////////////////////////////////////////////////////
//	CPortableDbgCases class

class CPortableDbgCases : public CTest

{
	DECLARE_TEST(CPortableDbgCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);
};

#endif //__PRTCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Src\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSniffDriver class

class CSniffDriver : public CIDESubSuite
{
	DECLARE_SUBSUITE(CSniffDriver)

	DECLARE_TESTLIST();

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
	virtual void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Src\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		implementation of the CSniffDriver class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "sniff.h"

#include "prtcases.h"
#include "wincases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

IMPLEMENT_SUBSUITE(CSniffDriver, CIDESubSuite, "Debugger Sniff Test", "MichMa")

BEGIN_TESTLIST(CSniffDriver)
	TEST(CPortableDbgCases, RUN)
	TEST(CWin32DbgCases, RUN)
END_TESTLIST()

void CSniffDriver::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);
}

void CSniffDriver::CleanUp(void)
{
	// close all windows
	UIWB.CloseAllWindows();

	KillFile("debugger\\prtdbgee", "*.mdp");
	KillFile("debugger\\prtdbgee", "*.opt");
	KillFile("debugger\\prtdbgee", "*.ncb");
	KillFile("debugger\\dlldbgee", "*.mdp");
	KillFile("debugger\\dlldbgee", "*.opt");
	KillFile("debugger\\dlldbgee", "*.ncb");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Src\prtcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      PRTCASES.CPP
//
//      Created by :                    Date :
//              MichMa                                  10/5/94
//
//      Description :
//              Portable debugger sniff tests

#include "stdafx.h"
#include "prtcases.h"
#include "debugger.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CPortableDbgCases, CTest, "Portable Tests", -1, CSniffDriver)


void CPortableDbgCases::Run(void)

{
	UIDAM uidam;
	COMemory mem;
	COProject prj;
	CODebug dbg;
	COBreakpoints bp;
	COStack stk;
	COExpEval cxx;
	COConnection *pconnec = GetSubSuite()->GetIDE()->GetConnectionInfo();

	#if defined(_MIPS_)                                             
		prj.Open(FullPath("prtdbgee\\win32mips.exe")); 
    #elif defined(_ALPHA_)
        prj.Open(FullPath("prtdbgee\\win32alpha.exe"));
	#else
		prj.Open(FullPath("prtdbgee\\win32x86.exe"));
	#endif
	
	pconnec->SetAll();

	if(pconnec->GetUserConnections() != CONNECTION_LOCAL)
	{
	#if defined(_MIPS_)                                             
 		prj.SetRemotePath("win32mips.exe");
		prj.UpdateRemoteFile("prtdbgee\\win32mips.exe");
	#elif defined(_ALPHA_)
		prj.SetRemotePath("win32alpha.exe");
		prj.UpdateRemoteFile("prtdbgee\\win32alpha.exe");
	#else
		prj.SetRemotePath("win32x86.exe");
		prj.UpdateRemoteFile("prtdbgee\\win32x86.exe");
	#endif
	}

	bp.ClearAllBreakpoints();                                                                       // Clear All Breakpoints Just in case
 
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));                                          // Prepare for source mode stepping
	EXPECT_TRUE(dbg.StepInto(1,NULL,"WinMain("));                           // Trace to start debugging

	uidam.Activate();
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));  
	EXPECT_TRUE(UIDebug::ShowDockWindow(IDW_MEMORY_WIN, TRUE));
	EXPECT_TRUE(UIDebug::ShowDockWindow(IDW_CPU_WIN, TRUE));
	EXPECT_TRUE(UIDebug::ShowDockWindow(IDW_CALLS_WIN, TRUE));

	EXPECT_TRUE(dbg.StopDebugging(ASSUME_NORMAL_TERMINATION));      // Stop debugging
	EXPECT_TRUE(dbg.GetDebugState()==NotDebugging);                         // Verify stopped
	
	EXPECT_TRUE(dbg.StepOver(2,NULL,"obj_a    obj_a1;"));           // Step to start debugging
	EXPECT_TRUE(dbg.StepOver(3,NULL,"obj_ab   obj_ab1;"));          // Step  Over fcns (constructor)
	EXPECT_TRUE(dbg.StepInto(1,NULL,NULL,"obj_ab::obj_ab"));        // Trace Into fcn  (constructor)
	EXPECT_TRUE(dbg.StepInto(1,NULL,NULL,"obj_a::obj_a"));          // Trace Into fcn  (constructor)
	EXPECT_VALIDBP(bp.SetBreakpoint());                                                     // Set simple Breakpint on this line
	EXPECT_TRUE(dbg.StepOut(1,NULL,NULL,"obj_ab::obj_ab"));         // Execute To Previous frame,(StepOut)
	EXPECT_TRUE(dbg.StepInto(1,NULL,NULL,"obj_b::obj_b"));          // Trace Into fcn  (constructor)
	EXPECT_TRUE(dbg.StepOut(1,NULL,NULL,"obj_ab::obj_ab"));         // Execute To Previous frame,(StepOut)
	EXPECT_TRUE(dbg.StepInto(4,NULL,"obj_v_ab obj_v_ab1;","WinMain("));//Trace thru and out of fnc

	EXPECT_TRUE(dbg.StepOver(1,NULL,"obj_a()","obj_a::obj_a")); // Step function with bp, hit bp
	EXPECT_TRUE(dbg.StepOut(1,NULL,NULL,"obj_v_ab::obj_v_ab"));     // Execute To Previous frame,(StepOut)
	EXPECT_TRUE(dbg.StepOut(1,NULL,NULL,"WinMain("));                               // Execute To Previous frame,(StepOut)
	
	EXPECT_TRUE(dbg.StepToCursor(258,NULL,"@258"));                         // Move Cursor to line, Execute to cursor (StepToCursor)
	
	EXPECT_TRUE(dbg.StepInto(2,NULL,NULL,"fooclass::print("));

	EXPECT_TRUE(stk.NavigateStack(1)>0);                                                      // Naviage callstack back to parent fcn
	EXPECT_TRUE(dbg.VerifyCurrentLine("@259"));                                     // Verify cursor is at correct line
	EXPECT_TRUE(cxx.ExpressionValueIs("f.id",2));
	// Verify locals of prev frame accessable

	EXPECT_TRUE(cxx.SetExpressionValue("f.id",7));                          // Verify locals of prev frame writable
	EXPECT_TRUE(dbg.StepOut(1,NULL,"@259"));                                        // Execute To Previous frame,(StepOut)

	EXPECT_TRUE(cxx.ExpressionValueIs("f.id",7));                           // Verify locals of prev frame accessable

	EXPECT_VALIDBP(bp.SetBreakpoint("DURING","(Int==2)",COBP_TYPE_IF_EXP_TRUE,0)); //Breakpoint at loc if expr true
	EXPECT_TRUE(dbg.Go("DURING"));                                                          // Go and verify we hit BP  ******  needs to handle BP hit dialog
	EXPECT_TRUE(cxx.ExpressionValueIs("Int",2));                            // Verify expression is TRUE
	EXPECT_VALIDBP(bp.SetBreakOnExpr("(Int==4)",COBP_TYPE_IF_EXP_TRUE,0)); //Breakpoint if expr true
	EXPECT_TRUE(dbg.Go());                                                                          // Go and verify we hit BP  ******  needs to handle BP hit dialog               
	EXPECT_TRUE(cxx.ExpressionValueIs("Int",4));                            // Verify expression is TRUE
	EXPECT_TRUE(bp.ClearAllBreakpoints());                                  // Clear All Breakpoints

	EXPECT_VALIDBP(bp.SetBreakpoint("fooclass::print(char *)"));// Breakpoint on overloaded function
	EXPECT_TRUE(dbg.Go(NULL,NULL,"fooclass::print("));                      // Go and verify we hit BP
	EXPECT_TRUE(dbg.StepOut());                                                                     // Execute To Previous frame,(StepOut) 

	EXPECT_TRUE(cxx.ExpressionValueIs("((*(obj_a*)(&obj_ab1))).common",1)); // some quick EE testing

	#if !defined( _MIPS_ )   // temporarily exclude function evaluation on mips
		EXPECT_TRUE(cxx.ExpressionValueIs("buddy()",-2));       
	#endif

	EXPECT_TRUE(mem.MemoryDataIs("((*(obj_a*)(&obj_ab1))).common", 1));

	EXPECT_TRUE(bp.ClearAllBreakpoints());                                                  // Clear All Breakpoints
	
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.Restart());                                                                             // Restart debugger
	EXPECT_TRUE(dbg.VerifyCurrentLine("WinMain("));                 // Verify at correct line (first)
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,ASSUME_NORMAL_TERMINATION));  // Execute to debuggee termination
	EXPECT_TRUE(dbg.GetDebugState()==NotDebugging);                                 // Verify we terminated

	UIWB.CloseAllWindows();                                                                                 // Clean up
	prj.Close();
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Bin\prtdbgee\prtdbgee.cpp ===
/********************************************************************/
/*                        testx.cxx, C++ features                   */
/*                                                                  */
/*  designed to explore most c++ specific features                  */
/********************************************************************/
//  MAKE MAIN => LOCAL all               *** NYI in c700
//  #define make_local 1

#include <windows.h>

#define stream_io  1                     // comment out to use printf's

#ifdef stream_io
#include <iostream.h>
#else
#include <stdio.h>
#endif

#ifdef _M_MPPC
#include <macos/types.h>
#endif

/******************* function prototypes & global functions *************/
int foo();
//int func(int INT, int & rint, const int CINT, fooclass & fc_obj,int defualt=111);
int buddy();

int foo() {
   return 5;
};



/******************************************************************/
/*********************  main here makes rest local  ***************/
/******************************************************************/
#ifdef make_local
int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow) {
#endif

/*********************** FOOCLASS **********************/
class fooclass {
private:
  long private_val;
protected:
  long protect_val;
public:
  static int static_val;
  long public_val;
  int id;

  friend int buddy();                 // friend function

  fooclass();
  fooclass(fooclass &);
  ~fooclass();
  void print(int x);
  void print(char *str);
  void print(int x, char *str);
  void hi();
  static int static_func() {
     return 9;
  };
  fooclass  operator+(fooclass arg){  // overloaded operator
       return arg;                    // return second operand (so a+b=b)
  };
  void operator=(fooclass& arg){  // overloaded operator =
       if (this == &arg) return;
#ifdef stream_io
    cout<<"** Overload Assignment(=) id="<<id<<"  private_val "<<private_val<<" -> "<<arg.private_val<<"\n";
#else
   printf("** Overload Assignment(=) id=%d  private_val %ld -> %ld \n",id,private_val,arg.private_val);
#endif
       private_val=arg.private_val;   // return second operand (so a=b)
  };
  operator int() {                    // return private value
      return (int)private_val;        // conversion operator
  };
  inline void inlinefunc() {          // inline function
      private_val++;
      print("inline func called: incr private val");
   };
};

/******************** define function for fooclass ************/
 int fooclass::static_val=1;

  fooclass::fooclass() {              // constructor for fooclass
    id=static_val;
#ifdef stream_io
    cout<<"** Constructor called  id="<<id<<"  ref_count= "<<id<<"\n";
#else
   printf("** Constructor called  id=%d  ref_count= %d\n",id,id);
#endif
    static_val++;
    private_val=-2*id;
    public_val=0;
    protect_val=1;
  };

  fooclass::fooclass(fooclass & a) {     // Copy constructor for fooclass
    id=static_val;
#ifdef stream_io
    cout<<"** Copy Constructor called  id="<<id<<"  ref_count= "<<id<<"\n";
#else
   printf("** Copy Constructor called  id=%d  ref_count= %d\n",id,id);
#endif
    static_val++;
    private_val=a.private_val;
  };

  fooclass::~fooclass() {             // destructor for fooclass
    static_val--;
#ifdef stream_io
    cout<<"** Destructor called  id="<<id<<"  ref_count= "<<static_val<<"\n";
#else
   printf("** Destructor called  id=%d  ref_count= %d\n",id,static_val);
#endif
  };

  void fooclass::print(int x) {       // overloaded member functions

#ifdef stream_io
   cout<<"int: "<<x<<"\n";
#else
   printf("int: %d\n",x);
#endif

  };

  void fooclass::print(char *str) {   // use c++ lib stream functions

#ifdef stream_io
   cout<<"string: "<<str<<"\n";
#else
   printf("string: %s\n",str);
#endif

};

  void fooclass::print(int x, char *str) {   // use c++ lib stream functions

#ifdef stream_io
    cout<<"Result: "<<x<<" \t "<<str<<"\n";
#else
   printf("Result: %d \t %s\n",x,str);
#endif

  };

  void fooclass::hi() {               //  simple member function
    print("hello world");
    private_val=-20;
  };



/**********************  Object A,B,AB,VAB classes *****************/
class obj_a {
public:
   int a_num;
   int common;
   virtual int common_func() {return 1;};
   obj_a() {
       a_num=1;
       common=1;
   };
};
class obj_b {
public:
   int b_num;
   int common;
   virtual int common_func() {return 2;};
   obj_b() {
       b_num=2;
       common=2;
   };
};
class obj_aa: public obj_a {
public:
   int aa_num;
   int common;
   int common_func() {return 3;};
   obj_aa() {
       aa_num=3;
       common=3;
   };
};
class obj_ab: public obj_a, public obj_b {
public:
   int ab_num;
   int common;
   int common_func() {return 3;};
   obj_ab() {
       ab_num=3;
       common=3;
   };
};
class obj_v_ab: virtual public obj_a, virtual public obj_b {
public:
   int v_ab_num;
   int common_func() {return 4;};
   obj_v_ab() {
       v_ab_num=4;
   };
};


/***************       function to check parameter features   *********/
int func(int INT, int & rint, const int CINT, fooclass & fc_obj,int defualt=111) {
//   CINT=100;                // CONST can't be on Left Hand Side
   INT=99;
   rint=101;
   fc_obj.public_val=98;
   return defualt;
};


/******************** Global Object *******************************/
fooclass fclass3;


/********************          friend function    **************************/
int buddy() {
     return (int)fclass3.private_val;
};

namespace n {int i = 1;};

/******************************************************************/
/************    main starts, here (unless above main used)  ******/
/******************************************************************/
#ifndef make_local
int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow) {
#endif

obj_a    obj_a1;                      // OBJECT A,B,AB,VAB stuff
obj_b    obj_b1;
obj_aa   obj_aa1;
obj_ab   obj_ab1;
obj_v_ab obj_v_ab1;

fooclass f,fclass, fclass2;
fooclass * foo_obj_ptr=&f;

int h=0;
int i=0;
int j=0;
int k=0;
int number=0;
int &ref=number;
const int Const=8;
const int Const_Arr[3]={0,1,2};

f.print("=========== C900 C++ Functionality tests =============");

/************** assigning tests *****************/
f.print("=========== Assignment tests ====================");
k=0;
obj_ab1.ab_num=12;
f.print(obj_ab1.ab_num,"Expect 12 \t[Public Var Mult Inherit]");
obj_v_ab1.v_ab_num=55;
f.print(obj_v_ab1.v_ab_num,"Expect 55 \t[Public Var Mult Inherit]");
obj_a1.a_num=33;
BEFORE:
for (int Int=0; Int < Const; Int++)
DURING:
   obj_a1.a_num++;

AFTER:
f.print(obj_a1.a_num,"Expect 41 \t[Public Var No Inherit] \t(33+8)");



/************** function call tests ***************/

f.print("=========== Function call tests =================");
f.print(1);              // check overloaded print()
f.print("ok, [ '1' then 'ok' expected]");   // check overloaded print()
f.print(0,"Expect 0  \t[testing overloaded print() with two parms]");

f.print(foo(), "Expect 5 \t[ foo() returns 5 ]"); // simple reg (non-oop) func
h=buddy();               // friend function
f.print(h, "Expect -2 \t[Friend function]");
if (h != (-2)) f.print("Error: friend function");
fclass3.inlinefunc();          // inline function
f.print(buddy(), "Expect -1 \t[Friend function]");
f.hi();                  // set private_val=-20, print hello world
f.print(     f.static_val, "Expect 5 \t[Static class data (f.static_val)]");
f.print(fclass.static_val, "Expect 5 \t[Static class data (fclass.static_val)]");
h=50+f;                  // implict call to int() conversion operator
f.print(h, "Expect 30 \t[conversion operator]");
fclass3=f+fclass2;       // overloaded operator
f.print(buddy(), "Expect -8 \t[prv_val from fclass2]");
h=10+fclass3;
f.print(h, "Expect 2 \t[overloaded operator (conv opr too)] \t(10-8)");
f.print(f.static_func(), "Expect 9 \t[Static function]");



/*************** other stuff  *************/
f.print("=========== other tests ===========================");
// add new, dispose (destructor) stuff here


/****** OBJECT A,B,AB,VAB tests ****************/
f.print("=========== A,B,AB,VAB [inheritence] tests ========");
f.print(obj_a1.common_func(),   "Expect 1  \t[  NO   Inherit]");
f.print(obj_b1.common_func(),   "Expect 2  \t[  NO   Inherit]");
f.print(obj_aa1.common_func(),  "Expect 3  \t[Single Inherit]");
f.print(obj_ab1.common_func(),  "Expect 3  \t[Multiple Inherit]");
f.print(obj_v_ab1.common_func(),"Expect 4  \t[Virtual Multiple]");



/******   func() tests ******************/
DA_FUNC:
f.print("=========== func() call tests ===================");
i=func(number, number, number, fclass, 88);
  if (i != 88)               f.print(i,"Error: \tdefualt args [expected 88]");
  if (fclass.public_val!=98) f.print(fclass.public_val,"Error \tref parms [expected 98]");
  if (number==101)           f.print(number,"Error ? \tconst parm func(&x,const x) x changes");
j=func(k, number, number, fclass);
  if (j != 111)              f.print(j,"Error:  \tdefualt args [expected 111]");
  if (fclass.public_val!=98) f.print(fclass.public_val,"Error:  \tref parms [expected 98]");
  f.print(k,"Expect 0 \tsince call by value");


f.print("=========== Testing completed  ==================");
f.print("=========== Implict destruction now  ============");

return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Src\wincases.h ===
///////////////////////////////////////////////////////////////////////////////
//	WINCASES.H
//
//	Created by :			Date :
//		MichMa					10/5/94
//
//	Description :
//		Declaration of the CWin32DbgCases class
//

#ifndef __WINCASES_H__
#define __WINCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"


///////////////////////////////////////////////////////////////////////////////
//	CWin32DbgCases class

class CWin32DbgCases : public CTest

{
	DECLARE_TEST(CWin32DbgCases, CSniffDriver)

// Operations
public:
	virtual void Run(void);
};

#endif //__WINCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\baseposi.cpp ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*  Bounce - Creates a new thread each time the letter 'a'is typed.
 *  Each thread bounces a happy face of a different color around the screen.
 *  All threads are terminated when the letter 'Q' is entered.
 *
 *  This program requires the multithread library. For example, compile
 *  with the following command line:
 *      CL /MT BOUNCE.C
 */

//#include <windows.h>
//#include <stdlib.h>
//#include <string.h>
//#include <stdio.h>
//#include <conio.h>
//#include <process.h>

// #define MAX_THREADS  32
#define MAX_THREADS  2
	
	
/* getrandom returns a random number between min and max, which must be in
 * integer range.
 /				
*#define getrandom( min, max ) ((rand() % (int)(((max) + 1) - (min))) + (min))

void main( void );                     /*Thread 1: main */
void KbdFunc( void  );                 /*Keyboard input, thread dispatch */
void BounceProc( char * MyID );        /*  Threads 2 to n: display */
void ClearScreen( void );              /*  Screen clear */
void ShutDown( void );                 /*Program shutdown */
void WriteTitle( int ThreadNum );	   /*	Display title bar information */

HANDLE  hConsoleOut;				   /* Handle to the console */
HANDLE  hRunMutex;                     /* "Keep Running" mutex */
HANDLE  hScreenMutex;                  /* "Screen update" mutex  */
int		ThreadNr;				       /* Number of threads started */
CONSOLE_SCREEN_BUFFER_INFO csbiInfo;   /* Console information */
BOOLEAN Sound = FALSE;

void main()                            /* Thread One */
{
    /* Get display screen information & clear the screen.*/
    hConsoleOut = GetStdHandle( STD_OUTPUT_HANDLE );
    GetConsoleScreenBufferInfo( hConsoleOut, &csbiInfo );
    ClearScreen();
    WriteTitle( 0 );
    /* Create the mutexes and reset thread count. */
    hScreenMutex = CreateMutex( NULL, FALSE, NULL );   /* Cleared */
    hRunMutex = CreateMutex( NULL, TRUE, NULL );       /* Set */
    ThreadNr = 0;

    /* Start waiting for keyboard input to dispatch threads or exit. */
    KbdFunc();

    /* All threads done. Clean up handles. */
    CloseHandle( hScreenMutex );
    CloseHandle( hRunMutex );
    CloseHandle( hConsoleOut );
}

void ShutDown( void )                  /* Shut down threads */
{
	while ( ThreadNr > 0 )
	{
			/* Tell thread to die and record its death. */
		    ReleaseMutex( hRunMutex );
			ThreadNr--;	
	}
    /* Clean up display when done */
    WaitForSingleObject( hScreenMutex, INFINITE );
    ClearScreen();
}

void KbdFunc( void )                   /* Dispatch and count threads. */       
{
    int         KeyInfo;                        

    do
    {
        KeyInfo = _getch();
        if( tolower( KeyInfo ) == 'a' && ThreadNr < MAX_THREADS ) 
        {
            ThreadNr++;
            _beginthread( BounceProc, 0, &ThreadNr );
            WriteTitle( ThreadNr );
        }
        if( tolower( KeyInfo ) == 's' ) 
        {
            Sound = !Sound;
            WriteTitle( ThreadNr );
        }
    } while( tolower( KeyInfo ) != 'q' );

    ShutDown();
}

void BounceProc( char *MyID )                 
{
    char      MyCell, OldCell;
	WORD	  MyAttrib, OldAttrib;
	char	  BlankCell = 0x20;
    COORD     Coords, Delta;
    COORD     Old = {0,0};
	DWORD	  Dummy;

/* Generate update increments and initial display coordinates. */
    srand( (unsigned) *MyID * 3 );
    Coords.X = getrandom( 0, csbiInfo.dwSize.X - 1 );
    Coords.Y = getrandom( 0, csbiInfo.dwSize.Y - 1 );
    Delta.X = getrandom( -3, 3 );
    Delta.Y = getrandom( -3, 3 );

    /* Set up "happy face" & generate color attribute from thread number.*/
    if( *MyID > 16)
        MyCell = 0x01;                 /* outline face */
    else
        MyCell = 0x02;                 /* solid face */
    MyAttrib =  *MyID & 0x0F;          /* force black background */

    do
    {
        /* Wait for display to be available, then lock it. */
        WaitForSingleObject( hScreenMutex, INFINITE );

        /* If we still occupy the old screen position, blank it out. */
        ReadConsoleOutputCharacter( hConsoleOut, &OldCell, 1, Old, &Dummy );
        ReadConsoleOutputAttribute( hConsoleOut, &OldAttrib, 1, Old, &Dummy );
        if (( OldCell == MyCell ) && (OldAttrib == MyAttrib))
            WriteConsoleOutputCharacter( hConsoleOut, &BlankCell, 1, Old, &Dummy );

        /* Draw new face, then clear screen lock */
		WriteConsoleOutputCharacter( hConsoleOut, &MyCell, 1, Coords, &Dummy );
		WriteConsoleOutputAttribute( hConsoleOut, &MyAttrib, 1, Coords, &Dummy );
        ReleaseMutex( hScreenMutex );

        /* Increment the coordinates for next placement of the block. */
        Old.X = Coords.X;
        Old.Y = Coords.Y;
        Coords.X += Delta.X;
        Coords.Y += Delta.Y;

		/* If we are about to go off the screen, reverse direction */
        if( Coords.X < 0 || Coords.X >= csbiInfo.dwSize.X )
        {
            Delta.X = -Delta.X;
            if (Sound) Beep( 400, 50 );
        }
        if( Coords.Y < 0 || Coords.Y > csbiInfo.dwSize.Y )
        {
            Delta.Y = -Delta.Y;
            if (Sound) Beep( 600, 50 );
        }
	}
    /* Repeat while RunMutex is still taken. */
	while ( WaitForSingleObject( hRunMutex, 75L ) == WAIT_TIMEOUT );
}

void WriteTitle( int ThreadNum )
{
	char	NThreadMsg[80];

    sprintf( NThreadMsg, "Threads: %02d.  Press 'A' to start a thread, 'S' to toggle sound,'Q' to quit.", ThreadNum );
    SetConsoleTitle( NThreadMsg );
}

void ClearScreen( void )
{
	DWORD	dummy;
	COORD	Home = { 0, 0 };
	FillConsoleOutputCharacter( hConsoleOut, ' ', csbiInfo.dwSize.X * csbiInfo.dwSize.Y, Home, &dummy );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Sniff\Src\wincases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	WINCASES.CPP
//
//	Created by :			Date :
//		MichMa					10/5/94
//
//	Description :
//		Win32-specific debugger sniff tests

#include "stdafx.h"
#include "wincases.h"
#include "debugger.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CWin32DbgCases, CTest, "Win32-specific DLL Tests", -1, CSniffDriver)


void CWin32DbgCases::Run(void)

{
	UIDAM uidam;
	CODebug dbg;
	COBreakpoints bp;
	COStack stk;
	COExpEval cxx;
	COProject prj;
	int before, after;

	COConnection *pconnec = GetSubSuite()->GetIDE()->GetConnectionInfo();

	#if defined(_MIPS_)	
		prj.Open(FullPath("dlldbgee\\mipsmain.exe"));					// open the debuggee.
    #elif defined(_ALPHA_)
        prj.Open(FullPath("dlldbgee\\alphamain.exe"));
	#else
		prj.Open(FullPath("dlldbgee\\x86main.exe"));
		pconnec->SetAll();
	#endif

	if(pconnec->GetUserConnections() != CONNECTION_LOCAL)
	{
	#if defined(_MIPS_)
		prj.SetRemotePath("mipsmain.exe");
		prj.UpdateRemoteFile("dlldbgee\\mipsmain.exe");
		prj.UpdateRemoteFile("dlldbgee\\mipsdll.dll");
	#elif defined(_ALPHA_)
		prj.SetRemotePath("alphamain.exe");
		prj.UpdateRemoteFile("dlldbgee\\alphamain.exe");
		prj.UpdateRemoteFile("dlldbgee\\alphadll.dll");
	#else
		prj.SetRemotePath("x86main.exe");
		prj.UpdateRemoteFile("dlldbgee\\x86main.exe");
		prj.UpdateRemoteFile("dlldbgee\\x86dll.dll");
	#endif
	}

	bp.ClearAllBreakpoints();									// Clear All Breakpoints Just in case
	EXPECT_VALIDBP(bp.SetBreakpoint("WndProc"));				// Set simple Breakpint on this function
	EXPECT_TRUE(dbg.Go("WndProc"));								// Go and verify we hit BP

	uidam.Activate();
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));						// Prepare for source mode stepping
	EXPECT_TRUE(UIDebug::ShowDockWindow(IDW_MEMORY_WIN, TRUE));
	EXPECT_TRUE(UIDebug::ShowDockWindow(IDW_CPU_WIN, TRUE));
	EXPECT_TRUE(UIDebug::ShowDockWindow(IDW_CALLS_WIN, TRUE));
	
	EXPECT_TRUE(bp.ClearAllBreakpoints());						// Clear All Breakpoints
	EXPECT_VALIDBP(bp.SetBreakpoint("{,dll.c,}foo"));		// Breakpoint on DLL func w/context operator
	EXPECT_TRUE(dbg.Go(NULL,NULL,"foo"));						// Go and verify we hit BP
	EXPECT_TRUE(dbg.StepOut(1,NULL,"local= foo(1 , 2);","WndProc"));// Execute To Previous frame, out of DLL

	EXPECT_TRUE(dbg.StepInto(2,NULL,NULL,"recursive_dll"));		// Trace from exe Into DLL fcn
		
	EXPECT_VALIDBP(bp.SetBreakpoint("{,,x86main.exe}mycallbackfcn"));// Breakpoint on callback function (in exe)
	EXPECT_TRUE(dbg.Go("mycallbackfcn"));						// Go and verify we hit BP
	EXPECT_TRUE(dbg.StepOut(1,NULL,"(*lpfnCallBack)()"));		// Execute To Previous frame,(out of exe, back to DLL)
	EXPECT_TRUE(bp.ClearAllBreakpoints());						// Clear All Breakpoints
#if !defined( _MIPS_ )	
	EXPECT_TRUE(dbg.StepInto(5,"mycallbackfcn"));				// Step  Into callback function
#else
	//
	//	MIPS handles loop differently.
	//	Takes one less step to get back to function call.
	//
	EXPECT_TRUE(dbg.StepInto(4,"mycallbackfcn"));				// Step  Into callback function
#endif
	EXPECT_VALIDBP(bp.SetBreakpoint("{,main.c,}@92"));			// Breakpoint on callback function (in exe)
	EXPECT_TRUE(dbg.Go(NULL,"@92","WndProc"));					// Execute To Previous frame,out of DLL

	EXPECT_TRUE(bp.ClearAllBreakpoints());						// Clear All Breakpoints
	EXPECT_VALIDBP(bp.SetBreakpoint("global",COBP_TYPE_IF_EXP_CHANGED,1)); //Breakpoint if expr changed
	EXPECT_TRUE(cxx.GetExpressionValue("global", &before));		// Get expression's value before execution
#if !defined( _MIPS_ )	
	EXPECT_TRUE(dbg.Go(NULL,"global++"));						// Go and verify we hit BP
#else
	//
	//	MIPS specific behavior.
	//
	EXPECT_TRUE(dbg.Go(NULL,"localx=local+global"));			// Go and verify we hit BP
#endif
	EXPECT_TRUE(cxx.GetExpressionValue("global", &after));		// Get expression's value after execution
	EXPECT_TRUE((before != after));								// Verify expression changed

	EXPECT_TRUE(bp.ClearAllBreakpoints());						// Clear All Breakpoints
	EXPECT_VALIDBP(bp.SetBreakpoint("(global+local==14)",COBP_TYPE_IF_EXP_TRUE,1)); //Breakpoint if expr true
	// REVIEW (michma): timing problem in ide (not cafe), won't fix.
	Sleep(1000);
	EXPECT_TRUE(dbg.Go());										// Go and verify we hit BP
	EXPECT_TRUE(cxx.ExpressionValueIs("(global+local)",14));	// Verify expression true

	/* exception handling
	EXPECT_TRUE(bp.ClearAllBreakpoints());						// Clear All Breakpoints
	EXPECT_TRUE(dbg.Go());										// Go and verify we hit BP
	// handle exception dialog
	*/

	EXPECT_TRUE(dbg.SetNextStatement(101));						// Move Cursor, Set Next statement to be executed
	
	// ***break on message stuff goes here***
/*
	EXPECT_VALIDBP(bp.SetBreakOnMsg("{,,x86main.exe}WndProc","WM_PAINT",BK_MESSAGE)); // Set Breakpoint on message
	EXPECT_TRUE(dbg.Go("WndProc"));								// Go and verify we hit BP
	EXPECT_TRUE(dbg.StepInto());								// Step  Into WndProc
	EXPECT_TRUE(cxx.ExpressionValueIs("message",15));			// Verify message=16 (WM_PAINT)

	EXPECT_TRUE(bp.ClearAllBreakpoints());						// Clear All Breakpoints
	EXPECT_VALIDBP(bp.SetBreakpoint("@109"));					// Set simple Breakpint on this line
	EXPECT_TRUE(dbg.Go(NULL,"@109"));							// Go and verify we hit BP
	EXPECT_TRUE(dbg.SetNextStatement("MyPostMessage(hwnd)"));	// Set execution to MyPostMessage()
	EXPECT_TRUE(dbg.SetNextStatement(125));						// Set execution to MyPostMessage()
	EXPECT_TRUE(bp.ClearAllBreakpoints());						// Clear All Breakpoints
	EXPECT_VALIDBP(bp.SetBreakOnMsg("{,,x86main.exe}WndProc","Window",BK_CLASS));// Set Breakpoint on message class
	EXPECT_TRUE(dbg.Go("WndProc"));								// Go and verify we hit BP
	EXPECT_TRUE(dbg.StepInto());								// Step  Into WndProc
	EXPECT_TRUE(cxx.ExpressionValueIs("message",15));			// Verify message=16 (WM_PAINT)

	
	EXPECT_TRUE(bp.ClearAllBreakpoints());						// Clear All Breakpoints
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0))  						// Execute debuggee NO Waiting
	EXPECT_TRUE(dbg.Break())									// Break debuggee execution
	EXPECT_TRUE(dbg.GetDebugState()==Debug_Break);				//  	Verify we broke?

    */
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase0.cpp ===
// This is a Source Editor test file for select, cut, copy, delete, paste, undo, and redo  This is a Source Editor test file
/****************************** Module Header *******************************
* Module Name: select.c
*
* Contains routines for selecting and positioning controls.
*
* Functions:()
*    SelectControl2()
*    RedrawSelection()
*    OutlineSelectHide()
*    OutlineSelectSetRect()
*    PositionControl2()
*    SizeCtrlToText()
*    QueryTextExtent()
*
* Comments:
*
****************************************************************************/

// // #include "dlgedit.h"
// // #include "dlgfuncs.h"
// // #include "dlgextrn.h"


STATICFN VOID InvalidateDlgHandles(VOID);
STATICFN VOID (VOID);
	STATICFN 	VOID 	OutlineSelOutlineSelectHideectSetRect(INT x, INT y);
		STATICFN 	HANDLE 	PositionControl2(		NPCTYPE npc, PRECT prc, HANDLE hwpi);
STATICFN BOOL SizeCtrlToText(NPCTYPE npc);
STATICFN INT QueryTextExtent(HWND hwnd, LPTSTR pszText, BOOL fWordBreak); 
			  Shown = FALSE;  // no tabs
			  Shown = FALSE;  // tabs and spaces
				Shown = FALSE;  // tabs and no spaces
              Shown = FALSE   // spaces and no tabs
                              
static POINT gptOutlineSelect; 
static RECT grcOutlineSelect;
static RECT grcOutlineSelectLimit;
static BOOL gfOutlineSelect
 
                                                                                                                                                                                    /**********************************************************************
 SelectControl

 This routine selects a control, showing its drag window and handles.
 If fCheckShift is TRUE and the shift key is down, this routine adds
 the control to the existing selection, unless the control is already
 selected, in which case it is removed from the existing selection.

       This routine handles the case where a controls is clicked on to select
       it, and this may cause other controls to be unselected.  If it is
                    known for sure that a control should be selected or added to the
       existing selection, SelectControl2 can be used instead.

    Arguments:
      NPCTYPE npc      = The control to select.
      BOOL fCheckShift = TRUE if the state of the shift key should be
                      taken into consideration.

   Returns:
   The return will be FALSE if the control was just unselected.

***********************************************************************/

BOOL SelectControl(
    NPCTYPE npc,
    BOOL fCheckShift)
{
int bogus[]; // ASDFGHJKL: "ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop \QWERYTUIOP|asdfghjkl;ASDFGHJKL:ASDFGHJKL:"ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:
    BOOL fShiftDown;
    BOOL fSelectDone = TRUE;

    if (npc->pwcd->iType == W_DIALOG) {
        if (gnpcSel == npc)
            return TRUE;

        CancelSelection(FALSE);
        SelectControl2(npc, FALSE);
			printf ("qwertuyiop\QWERYTUIOP|asdfghjkl ASDFGHJKL qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:");

    }
    else {
        if (fCheckShift)
            fShiftDown = (GetKeyState(VK_SHIFT) & 0x8000) ? TRUE : FALSE;
        else
            fShiftDown = FALSE;

        if (npc->fSelected) {
            /*
             * If the shift key is down, and they are NOT trying to
             * select the dialog, toggle the selection of this control
             * to off.
             */
            if (fShiftDown && npc->pwcd->iType != W_DIALOG) {
                UnSelectControl(npc);
                CalcSelectedRect();
                fSelectDone = FALSE;
            }
            else {
                if (gnpcSel == npc)
                    return TRUE;
                else
                    SelectControl2(npc, FALSE);
            }
        }
        else {
            /*
             * If they are NOT holding the shift key down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase20.cpp ===
tabs		spaces     more tabs			end.
		tabs		spaces     more tabs			end.
			tabs		spaces     more tabs			end.
	tabs		spaces     more tabs			end.	tabs		spaces     more tabs			end.
No leading tabs		just here.
No leading tabs		just here.
	tabs		spaces     more tabs			end.
No leading tabs		just here.	tabs		spaces     more tabs			end.
No leading tabs		just here.			tabs		spaces     more tabs			end.	tabs		spaces     more tabs			end.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase12.cpp ===
// This is a Source Editor test file for select, cut, copy, delete, paste, undo, and redo  This is a Source Editor test file
/****************************** Module Header *******************************
* M
*
* C
*
* F
*  
*  
*  
*  
*  
*  
*  
*
* C
*
**********/

// 
// 
// 


STA
STA
INT y);
T prc, HANDLE hwpi);
STA
STAak); 



   
   
sta
sta
sta
sta
 
                                                                                                                  /**********************************************************************
 Se

 Th
 If
 th
 se

   o select
    is
   or added to the
   

   
   
   
   

   
   

*****/

BOO
   
   
{
int \QWERYTUIOP|asdfghjkl;ASDFGHJKL:ASDFGHJKL:"ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:
   
   

   
   
   

   
   
yiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:");

   
   
   
   LSE;
   
   

   
   
   
   l
             * to off.
             */
            if (fShiftDown && npc->pwcd->iType != W_DIALOG) {
                UnSelectControl(npc);
                CalcSelectedRect();
                fSelectDone = FALSE;
            }
            else {
                if (gnpcSel == npc)
                    return TRUE;
                else
                    SelectControl2(npc, FALSE);
            }
        }
        else {
            /*
             * If they are NOT holding the shift key down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase21.cpp ===
tabs		spaces     more tabs			end.
		tabs		spaces     more tabs			end.
			tabs		spaces     more tabs			end.
	tabs		spaces     more tabs			end.	tabs		spaces     more tabs			end.
No leading tabs		just here.
No leading tabs		just here.
	tabs		spaces     more tabs			end.
No leading tabs		just here.	tabs		spaces     more tabs			end.
No leading tabs		just here.			tabs		spaces     more tabs			end.	tabs		spaces     more tabs			end.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase1.cpp ===
// This is a Source Editor test file for select, cut, copy, delete, paste, undo, and redo  This is a Source Editor test file
/****************************** Module Header *******************************
* Module Name: select.c
*
* Contains routines for selecting and positioning controls.
*
* Functions:()
*    SelectControl2()
*    RedrawSelection()
*    OutlineSelectHide()
*    OutlineSelectSetRect()
*    PositionControl2()
*    SizeCtrlToText()
*    QueryTextExtent()
*
* Comments:
*
****************************************************************************/

// // #include "dlgedit.h"
// // #include "dlgfuncs.h"
// // #include "dlgextrn.h"


STATICFN VOID InvalidateDlgHandles(VOID);
STATICFN VOID (VOID);
	STATICFNe {
            /*
             * If they are NOT holding the shift key down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase10.cpp ===
// This is a Source Editor test file for select, cut, copy, delete, paste, undo, and redo  This is a Source Editor test file
/****************************** Module Header *******************************
* M
*
* C
*
* F
*  
*  
*  
*  
*  
*  
*  
*
* C
*
**********/

// 
// 
// 


STA
STA
INT y);
T prc, HANDLE hwpi);
STA
STAak); 



   
   
sta
sta
sta
sta
 
                                                                                                                  /**********************************************************************
 Se

 Th
 If
 th
 se

   o select
    is
   or added to the
   

   
   
   
   

   
   

*****/

BOO
   
   
{
int \QWERYTUIOP|asdfghjkl;ASDFGHJKL:ASDFGHJKL:"ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:
   
   

   
   
   

   
   
yiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:");

   
   
   
   LSE;
   
   

   
   
   
   l
             * to off.
             */
            if (fShiftDown && npc->pwcd->iType != W_DIALOG) {
                UnSelectControl(npc);
                CalcSelectedRect();
                fSelectDone = FALSE;
            }
            else {
                if (gnpcSel == npc)
                    return TRUE;
                else
                    SelectControl2(npc, FALSE);
            }
        }
        else {
            /*
             * If they are NOT holding the shift key down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase28.cpp ===
tabs		spaces     more tabs			end.
			tabs		spaces     more tabs			end.
				tabs		spaces     more tabs			end.
	tabs		spaces     more tabs			end.	tabs		spaces     more tabs			end.
No leading tabs		just here.
No leading tabs		just here.
	tabs		spaces     more tabs			end.
No leading tabs		just here.	tabs		spaces     more tabs			end.
No leading tabs		just here.			tabs		spaces     more tabs			end.	tabs		spaces     more tabs			end.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase23.cpp ===
// This is a Source Editor test file for select, cut, copy, delete, paste, undo, and redo  This is a Source Editor test file
/****************************** Module Header *******************************
* Module Name: select.c
*
* Contains routines for selecting and positioning controls.
*
* Functions:()
*    SelectControl2()
*    RedrawSelection()
*    OutlineSelectHide()
*    OutlineSelectSetRect()
*    PositionControl2()
*    SizeCtrlToText()
*    QueryTextExtent()
*
* Comments:
*
****************************************************************************/

// // #include "dlgedit.h"
// // #include "dlgfuncs.h"
// // #include "dlgextrn.h"


STATICFN VOID InvalidateDlgHandles(VOID);
STATICFN VOID (VOID);
	STATICFN 	VOID 	OutlineSelOutlineSelectHideectSetRect(INT x, INT y);
		STATICFN 	HANDLE 	PositionControl2(		NPCTYPE npc, PRECT prc, HANDLE hwpi);
STATICFN BOOL SizeCtrlToText(NPCTYPE npc);
STATICFN INT QueryTextExtent(HWND hwnd, LPTSTR pszText, BOOL fWordBreak); 
			  Shown = FALSE;  // no tabs
			  Shown = FALSE;  // tabs and spaces
				Shown = FALSE;  // tabs and no spaces
			  Shown = FALSE   // spaces and no tabs
                  
static POINT gptOutlineSelect; 
static RECT grcOutlineSelect;
static RECT grcOutlineSelectLimit;
static BOOL gfOutlineSelect

																																													/**********************************************************************
 SelectControl

 This routine selects a control, showing its drag window and handles.
 If fCheckShift is TRUE and the shift key is down, this routine adds
 the control to the existing selection, unless the control is already
 selected, in which case it is removed from the existing selection.

	   This routine handles the case where a controls is clicked on to select
	   it, and this may cause other controls to be unselected.  If it is
					known for sure that a control should be selected or added to the
       existing selection, SelectControl2 can be used instead.

    Arguments:
      NPCTYPE npc      = The control to select.
      BOOL fCheckShift = TRUE if the state of the shift key should be
                      taken into consideration.

   Returns:
   The return will be FALSE if the control was just unselected.

***********************************************************************/

BOOL SelectControl(
    NPCTYPE npc,
    BOOL fCheckShift)
{
int bogus[]; // ASDFGHJKL: "ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop \QWERYTUIOP|asdfghjkl;ASDFGHJKL:ASDFGHJKL:"ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:
    BOOL fShiftDown;
    BOOL fSelectDone = TRUE;

    if (npc->pwcd->iType == W_DIALOG) {
        if (gnpcSel == npc)
            return TRUE;

        CancelSelection(FALSE);
        SelectControl2(npc, FALSE);
			printf ("qwertuyiop\QWERYTUIOP|asdfghjkl ASDFGHJKL qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:");

    }
    else {
        if (fCheckShift)
            fShiftDown = (GetKeyState(VK_SHIFT) & 0x8000) ? TRUE : FALSE;
        else
            fShiftDown = FALSE;

        if (npc->fSelected) {
            /*
             * If the shift key is down, and they are NOT trying to
             * select the dialog, toggle the selection of this control
             * to off.
             */
            if (fShiftDown && npc->pwcd->iType != W_DIALOG) {
                UnSelectControl(npc);
                CalcSelectedRect();
                fSelectDone = FALSE;
            }
            else {
                if (gnpcSel == npc)
                    return TRUE;
                else
                    SelectControl2(npc, FALSE);
            }
        }
        else {
            /*
             * If they are NOT holding the shift key down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase31.cpp ===
// This is a Source Editor test file for select, cut, copy, delete, paste, undo, and redo  This is a Source Editor test file
/****************************** Module Header *******************************
* Module Name: select.c
*
* Contains routines for selecting and positioning controls.
*
* Functions:()
*    SelectControl2()
*    RedrawSelection()
*    OutlineSelectHide()
*    OutlineSelectSetRect()
*    PositionControl2()
*    SizeCtrlToText()
*    QueryTextExtent()
*
* Comments:
*
****************************************************************************/

// // #include "dlgedit.h"
// // #include "dlgfuncs.h"
// // #include "dlgextrn.h"


STATICFN VOID InvalidateDlgHandles(VOID);
STATICFN VOID (VOID);
	STATICFN 	VOID 	OutlineSelOutlineSelectHideectSetRect(INT x, INT y);
	!@#$&*_`-= ;:| <>,./ositionControl2(		NPCTYPE npc, PRECT prc, HANDLE hwpi);
STATICFN BOOL SizeCtrlToText(NPCTYPE npc);
STATICFN INT QueryTextExtent(HWND hwnd, LPTSTR pszText, BOOL fWordBreak); 
			  Shown = FALSE;  // no tabs
			  Shown = FALSE;  // tabs and spaces
				Shown = FALSE;  // tabs and no spaces
              Shown = FALSE   // spaces and no tabs
                              
static POINT gptOutlineSelect; 
static RECT grcOutlineSelect;
static RECT grcOutlineSelectLimit;
static BOOL gfOutlineSelect
 
                                                                                                                                                                                    /**********************************************************************
 SelectControl

 This routine selects a control, showing its drag window and handles.
 If fCheckShift is TRUE and the shift key is down, this routine adds
 the control to the existing selection, unless the control is already
 selected, in which case it is removed from the existing selection.

       This routine handles the case where a controls is clicked on to select
       it, and this may cause other controls to be unselected.  If it is
                    known for sure that a control should be selected or added to the
       existing selection, SelectControl2 can be used instead.

    Arguments:
      NPCTYPE npc      = The control to select.
      BOOL fCheckShift = TRUE if the state of the shift key should be
                      taken into consideration.

   Returns:
   The return will be FALSE if the control was just unselected.

***********************************************************************/

BOOL SelectControl(
    NPCTYPE npc,
    BOOL fCheckSqwertyuiop 1234567890 asdfghjkl zxcvbnm QWERTYUIOP ASDFGHJKL ZXCVBNM
{
int bogus[]; // ASDFGHJKL: "ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop \QWERYTUIOP|asdfghjkl;ASDFGHJKL:ASDFGHJKL:"ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:
    BOOL fShiftDown;
    BOOL fSelectDone = TRUE;

    if (npc->pwcd->iType == W_DIALOG) {
        if (gnpcSel == npc)
            return TRUE;

        CancelSelectitabFALS backspac tab	 quote'double quote" backslash\ question?
        SelectControl2(npc, FALSE);
			printf ("qwertuyiop\QWERYTUIOP|asdfghjkl ASDFGHJKL qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:");

    }
    else {
        if (fCheckShift)
            fShiftDown = (GetKeyState(VK_SHIFT) & 0x8000) ? TRUE : FALSE;
        else
            fShiftDown = FALSE;

        if (npc->fSelected) {
            /*
             * If the shift key is down, and they are NOT trying to
             * select the dialog, toggle the selection of this control
             * to off.
             */
            if (fShiftDown && npc->pwcd->iType != W_DIALOG) {
                UnSelectControl(npc);
                CalcSelectedRect();
                fSelectDone = FALSE;
            }
            else {
                if (gnpcSel == npc)
                    return TRUE;
                else
                    SelectControl2(npc, FALSE);
            }
        }
        else {
            /*
             * If they are NOT holding the shift key down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase22.cpp ===
// This is a Source Editor test file for select, cut, copy, delete, paste, undo, and redo  This is a Source Editor test file
/****************************** Module Header *******************************
* Module Name: select.c
*
* Contains routines for selecting and positioning controls.
*
* Functions:()
*    SelectControl2()
*    RedrawSelection()
			*    OutlineSelectHide()
			*    OutlineSelectSetRect()
			*    PositionControl2()
			*    SizeCtrlToText()
			*    QueryTextExtent()
			*
			* Comments:
			*
			****************************************************************************/

			// // #include "dlgedit.h"
			// // #include "dlgfuncs.h"
			// // #include "dlgextrn.h"


			STATICFN VOID InvalidateDlgHandles(VOID);
			STATICFN VOID (VOID);
				STATICFN 	VOID 	OutlineSelOutlineSelectHideectSetRect(INT x, INT y);
					STATICFN 	HANDLE 	PositionControl2(		NPCTYPE npc, PRECT prc, HANDLE hwpi);
			STATICFN BOOL SizeCtrlToText(NPCTYPE npc);
			STATICFN INT QueryTextExtent(HWND hwnd, LPTSTR pszText, BOOL fWordBreak); 
						  Shown = FALSE;  // no tabs
						  Shown = FALSE;  // tabs and spaces
							Shown = FALSE;  // tabs and no spaces
						  Shown = FALSE   // spaces and no tabs
                              
			static POINT gptOutlineSelect; 
			static RECT grcOutlineSelect;
			static RECT grcOutlineSelectLimit;
			static BOOL gfOutlineSelect
 
																																																/**********************************************************************
			 SelectControl

			 This routine selects a control, showing its drag window and handles.
			 If fCheckShift is TRUE and the shift key is down, this routine adds
			 the control to the existing selection, unless the control is already
			 selected, in which case it is removed from the existing selection.

				   This routine handles the case where a controls is clicked on to select
				   it, and this may cause other controls to be unselected.  If it is
								known for sure that a control should be selected or added to the
       existing selection, SelectControl2 can be used instead.

    Arguments:
      NPCTYPE npc      = The control to select.
      BOOL fCheckShift = TRUE if the state of the shift key should be
                      taken into consideration.

   Returns:
   The return will be FALSE if the control was just unselected.

***********************************************************************/

BOOL SelectControl(
    NPCTYPE npc,
    BOOL fCheckShift)
{
int bogus[]; // ASDFGHJKL: "ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop \QWERYTUIOP|asdfghjkl;ASDFGHJKL:ASDFGHJKL:"ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:
    BOOL fShiftDown;
    BOOL fSelectDone = TRUE;

    if (npc->pwcd->iType == W_DIALOG) {
        if (gnpcSel == npc)
            return TRUE;

        CancelSelection(FALSE);
        SelectControl2(npc, FALSE);
			printf ("qwertuyiop\QWERYTUIOP|asdfghjkl ASDFGHJKL qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:");

    }
    else {
        if (fCheckShift)
            fShiftDown = (GetKeyState(VK_SHIFT) & 0x8000) ? TRUE : FALSE;
        else
            fShiftDown = FALSE;

        if (npc->fSelected) {
            /*
             * If the shift key is down, and they are NOT trying to
             * select the dialog, toggle the selection of this control
             * to off.
             */
            if (fShiftDown && npc->pwcd->iType != W_DIALOG) {
                UnSelectControl(npc);
                CalcSelectedRect();
                fSelectDone = FALSE;
            }
            else {
                if (gnpcSel == npc)
                    return TRUE;
                else
                    SelectControl2(npc, FALSE);
            }
        }
        else {
            /*
             * If they are NOT holding the shift key down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase27.cpp ===
// This is a Source Editor test file for select, cut, copy, delete, paste, undo, and redo  This is a Source Editor test file
/****************************** Module Header *******************************
* Module Name: select.c
*
* Contains routines for selecting and positioning controls.
*
* Functions:()
*    SelectControl2()
*    RedrawSelection()
*    OutlineSelectHide()
*    OutlineSelectSetRect()
*    PositionControl2()
*    SizeCtrlToText()
*    QueryTextExtent()
*
* Comments:
*
****************************************************************************/

// // #include "dlgedit.h"
// // #include "dlgfuncs.h"
// // #include "dlgextrn.h"


STATICFN VOID InvalidateDlgHandles(VOID);
STATICFN VOID (VOID);
	STATICFN 	VOID 	OutlineSelOutlineSelectHideectSetRect(INT x, INT y);
		STATICFN 	HANDLE 	PositionControl2(		NPCTYPE npc, PRECT prc, HANDLE hwpi);
STATICFN BOOL SizeCtrlToText(NPCTYPE npc);
STATICFN INT QueryTextExtent(HWND hwnd, LPTSTR pszText, BOOL fWordBreak); 
			  Shown = FALSE;  // no tabs
			  Shown = FALSE;  // tabs and spaces
				Shown = FALSE;  // tabs and no spaces
			  Shown = FALSE   // spaces and no tabs
                  
static POINT gptOutlineSelect; 
static RECT grcOutlineSelect;
static RECT grcOutlineSelectLimit;
static BOOL gfOutlineSelect

																																													/**********************************************************************
 SelectControl

 This routine selects a control, showing its drag window and handles.
 If fCheckShift is TRUE and the shift key is down, this routine adds
 the control to the existing selection, unless the control is already
 selected, in which case it is removed from the existing selection.

	   This routine handles the case where a controls is clicked on to select
	   it, and this may cause other controls to be unselected.  If it is
					known for sure that a control should be selected or added to the
       existing selection, SelectControl2 can be used instead.

    Arguments:
      NPCTYPE npc      = The control to select.
      BOOL fCheckShift = TRUE if the state of the shift key should be
                      taken into consideration.

   Returns:
   The return will be FALSE if the control was just unselected.

***********************************************************************/

BOOL SelectControl(
    NPCTYPE npc,
    BOOL fCheckShift)
{
int bogus[]; // ASDFGHJKL: "ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop \QWERYTUIOP|asdfghjkl;ASDFGHJKL:ASDFGHJKL:"ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:
    BOOL fShiftDown;
    BOOL fSelectDone = TRUE;

    if (npc->pwcd->iType == W_DIALOG) {
        if (gnpcSel == npc)
            return TRUE;

        CancelSelection(FALSE);
        SelectControl2(npc, FALSE);
			printf ("qwertuyiop\QWERYTUIOP|asdfghjkl ASDFGHJKL qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:");

    }
    else {
        if (fCheckShift)
            fShiftDown = (GetKeyState(VK_SHIFT) & 0x8000) ? TRUE : FALSE;
        else
            fShiftDown = FALSE;

        if (npc->fSelected) {
            /*
             * If the shift key is down, and they are NOT trying to
             * select the dialog, toggle the selection of this control
             * to off.
             */
            if (fShiftDown && npc->pwcd->iType != W_DIALOG) {
                UnSelectControl(npc);
                CalcSelectedRect();
                fSelectDone = FALSE;
            }
            else {
                if (gnpcSel == npc)
                    return TRUE;
                else
                    SelectControl2(npc, FALSE);
            }
        }
        else {
            /*
             * If they are NOT holding the shift key down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase34.cpp ===
// This is a Source Editor test file for select, cut, copy, delete, paste, undo, and redo  This is a Source Editor test file
/****************************** Module Header *******************************
* Module Name: select.c
*
* Contains routines for selecting and positioning controls.
*
* Functions:()
*    SelectControl2()
*    RedrawSelection()
*    OutlineSelectHide()
*    OutlineSelectSetRect()
*    PositionControl2()
*    SizeCtrlToText()
*    QueryTextExtent()
*
* Comments:
*
****************************************************************************/

// // #include "dlgedit.h"
// // #include "dlgfuncs.h"
// // #include "dlgextrn.h"


STATICFN VOID InvalidateDlgHandles(VOID);
STATICFN VOID (VOID);
	STATICFN 	VOID 	OutlineSelOutlineSelectHideectSetRect(INT x, INT y);
	!@#$&*_`-= ;:| <>,./	STATICFN 	HANDLE 	PositionControl2(		NPCTYPE npc, PRECT prc, HANDLE hwpi);
STATICFN BOOL SizeCtrlToText(NPCTYPE npc);
STATICFN INT QueryTextExtent(HWND hwnd, LPTSTR pszText, BOOL fWordBreak); 
			  Shown = FALSE;  // no tabs
			  Shown = FALSE;  // tabs and spaces
				Shown = FALSE;  // tabs and no spaces
              Shown = FALSE   // spaces and no tabs
                              
static POINT gptOutlineSelect; 
static RECT grcOutlineSelect;
static RECT grcOutlineSelectLimit;
static BOOL gfOutlineSelect
 
                                                                                                                                                                                    /**********************************************************************
 SelectControl

 This routine selects a control, showing its drag window and handles.
 If fCheckShift is TRUE and the shift key is down, this routine adds
 the control to the existing selection, unless the control is already
 selected, in which case it is removed from the existing selection.

       This routine handles the case where a controls is clicked on to select
       it, and this may cause other controls to be unselected.  If it is
                    known for sure that a control should be selected or added to the
       existing selection, SelectControl2 can be used instead.

    Arguments:
      NPCTYPE npc      = The control to select.
      BOOL fCheckShift = TRUE if the state of the shift key should be
                      taken into consideration.

   Returns:
   The return will be FALSE if the control was just unselected.

***********************************************************************/

BOOL SelectControl(
    NPCTYPE npc,
    BOOL fCheckSqwertyuiop 1234567890 asdfghjkl zxcvbnm QWERTYUIOP ASDFGHJKL ZXCVBNMhift)
{
int bogus[]; // ASDFGHJKL: "ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop \QWERYTUIOP|asdfghjkl;ASDFGHJKL:ASDFGHJKL:"ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:
    BOOL fShiftDown;
    BOOL fSelectDone = TRUE;

    if (npc->pwcd->iType == W_DIALOG) {
        if (gnpcSel == npc)
            return TRUE;

        CancelSelectitab	 backspace tab	 quote'double quote" backslash\ question?on(FALSE);
        SelectControl2(npc, FALSE);
			printf ("qwertuyiop\QWERYTUIOP|asdfghjkl ASDFGHJKL qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:");

    }
    else {
        if (fCheckShift)
            fShiftDown = (GetKeyState(VK_SHIFT) & 0x8000) ? TRUE : FALSE;
        else
            fShiftDown = FALSE;

        if (npc->fSelected) {
            /*
             * If the shift key is down, and they are NOT trying to
             * select the dialog, toggle the selection of this control
             * to off.
             */
            if (fShiftDown && npc->pwcd->iType != W_DIALOG) {
                UnSelectControl(npc);
                CalcSelectedRect();
                fSelectDone = FALSE;
            }
            else {
                if (gnpcSel == npc)
                    return TRUE;
                else
                    SelectControl2(npc, FALSE);
            }
        }
        else {
            /*
             * If they are NOT holding the shift key down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase3.cpp ===
// This is a Source Editor test file for select, cut, copy, delete, paste, undo, and redo  This is a Source Editor test file
/****************************** Module Header *******************************
* Module Name: select.c
*
* Contains routines for selecting and positioning controls.
*
* Functions:()
*    SelectControl2()
*    RedrawSelection()
*    OutlineSelectHide()
*    OutlineSelectSetRect()
*    PositionControl2()
*    SizeCtrlToText()
*    QueryTextExtent()
*
* Comments:
*
****************************************************************************/

// // #include "dlgedit.h"
// // #include "dlgfuncs.h"
// // #include "dlgextrn.h"


STATICFN VOID InvalidateDlgHandles(VOID);
STATICFN VOID (VOID);
	STATey down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase4.cpp ===
// This is a Source Editor test file for select, cut, copy, delete, paste, undo, and redo  This is a Source Editor test file
/***/****************************** Module Header *******************************
* Module Name: select.c
*
* Contains routines for selecting and positioning controls.
*
* Functions:()
*    SelectControl2()
*    RedrawSelection()
*    OutlineSelectHide()
*    OutlineSelectSetRect()
*    PositionControl2()
*    SizeCtrlToText()
*    QueryTextExtent()
*
* Comments:
*
****************************************************************************/

// // #include "dlgedit.h"
// // #include "dlgfuncs.h"
// // #include "dlgextrn.h"


STATICFN VOID InvalidateDlgHandles(VOID);
STATICFN VOID (VOID);
	STATICFN 	VOID 	OutlineSelOutlineSelectHideectSetRect(INT x, INT y);
		STATICFN 	HANDLE 	PositionControl2(		NPCTYPE npc, PRECT prc, HANDLE hwpi);
STATICFN BOOL SizeCtrlToText(NPCTYPE npc);
STATICFN INT QueryTextExtent(HWND hwnd, LPTSTR pszText, BOOL fWordBreak); 
              Shown = FALSE;
 
                             
static POINT gptOutlineSelect; 
static RECT grcOutlineSelect;
static RECT grcOutlineSelectLimit;
static BOOL gfOutlineSelect
 
                                                                                                                                                                                    /**********************************************************************
 SelectControl

 This routine selects a control, showing its drag window and handles.
 If fCheckShift is TRUE and the shift key is down, this routine adds
 the control to the existing selection, unless the control is already
 selected, in which case it is removed from the existing selection.

       This routine handles the case where a controls is clicked on to select
       it, and this may cause other controls to be unselected.  If it is
                    known for sure that a control should be selected or added to the
       existing selection, SelectControl2 can be used instead.

    Arguments:
      NPCTYPE npc      = The control to select.
      BOOL fCheckShift = TRUE if the state of the shift key should be
                      taken into consideration.

   Returns:
   The return will be FALSE if the control was just unselected.

***********************************************************************/

BOOL SelectControl(
    NPCTYPE npc,
    BOOL fCheckShift)
{
int bogus[]; // ASDFGHJKL: "ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop \QWERYTUIOP|asdfghjkl;ASDFGHJKL:ASDFGHJKL:"ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:
    BOOL fShiftDown;
    BOOL fSelectDone = TRUE;

    if (npc->pwcd->iType == W_DIALOG) {
        if (gnpcSel == npc)
            return TRUE;

        CancelSelection(FALSE);
        SelectControl2(npc, FALSE);
			printf ("qwertuyiop\QWERYTUIOP|asdfghjkl ASDFGHJKL qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:");

    }
    else {
        if (fCheckShift)
            fShiftDown = (GetKeyState(VK_SHIFT) & 0x8000) ? TRUE : FALSE;
        else
            fShiftDown = FALSE;

        if (npc->fSelected) {
            /*
             * If the shift key is down, and they are NOT trying to
             * select the dialog, toggle the selection of this control
             * to off.
             */
            if (fShiftDown && npc->pwcd->iType != W_DIALOG) {
                UnSelectControl(npc);
                CalcSelectedRect();
                fSelectDone = FALSE;
            }
            else {
                if (gnpcSel == npc)
                    return TRUE;
                else
                    SelectControl2(npc, FALSE);
            }
        }
        else {
            /*
             * If they are NOT holding the shift key down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
*************************** Module Header *******************************
* Module Name: select.c
*
* Contains routines for selecting and positioning controls.
*
* Functions:()
*    SelectControl2()
*    RedrawSelection()
*    OutlineSelectHide()
*    OutlineSelectSetRect()
*    PositionControl2()
*    SizeCtrlToText()
*    QueryTextExtent()
*
* Comments:
*
****************************************************************************/

// // #include "dlgedit.h"
// // #include "dlgfuncs.h"
// // #include "dlgextrn.h"


STATICFN VOID InvalidateDlgHandles(VOID);
STATICFN VOID (VOID);
	STATICFNey down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase7.cpp ===
// This is a Source Editor test file for select, cut, copy, delete, paste, undo, and redo  This is a Source Editor test file
/****************************** Module Header *******************************
* Module Name: select.c
*
* Contains routines for selecting and positioning controls.
*
* Functions:()
*    SelectControl2()
*    RedrawSelection()
*    Outlused instead.

    Arguments:
      NPCTYPE npc      = The control to select.
      BOOL fCheckShift = TRUE if the state of the shift key should be
                      taken into consideration.

   Returns:
   The return will be FALSE if the control was just unselected.

***********************************************************************/

BOOL SelectControl(
    NPCTYPE npc,
    BOOL fCheckShift)
{
int bogus[]; // ASDFGHJKL: "ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop \QWERYTUIOP|asdfghjkl;ASDFGHJKL:ASDFGHJKL:"ZXCVBNM<>?asdfghjkl;'ZXCVBNM<>?qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:
    BOOL fShiftDown;
    BOOL fSelectDone = TRUE;

    if (npc->pwcd->iType == W_DIALOG) {
        if (gnpcSel == npc)
            return TRUE;

        CancelSelection(FALSE);
        SelectControl2(npc, FALSE);
			printf ("qwertuyiop\QWERYTUIOP|asdfghjkl ASDFGHJKL qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:qwertuyiop\QWERYTUIOP|asdfghjkl;ASDFGHJKL:");

    }
    else {
        if (fCheckShift)
            fShiftDown = (GetKeyState(VK_SHIFT) & 0x8000) ? TRUE : FALSE;
        else
            fShiftDown = FALSE;

        if (npc->fSelected) {
            /*
             * If the shift key is down, and they are NOT trying to
             * select the dialog, toggle the selection of this control
             * to off.
             */
            if (fShiftDown && npc->pwcd->iType != W_DIALOG) {
                UnSelectControl(npc);
                CalcSelectedRect();
                fSelectDone = FALSE;
            }
            else {
                if (gnpcSel == npc)
                    return TRUE;
                else
                    SelectControl2(npc, FALSE);
            }
        }
        else {
            /*
             * If they are NOT holding the shift key down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\hello.cpp ===
// simple project to test command line tools macros
#include <stdio.h>
int main (void)
{
	printf ("Hello World\n");
	// no return value to get warning
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\edbase9.cpp ===
// This is a Source Editor test file for select, cut, copy, delete, paste, undo, and redo  This is a Source Editor test file
/****************************** Module Header *******************************
* Module Name: select.c
*
* C(npc, FALSE);
            }
        }
        else {
            /*
             * If they are NOT holding the shift key down, or the
             * dialog is selected, cancel the selection first.
             */
            if (!fShiftDown || gcd.npc->fSelected == TRUE)
                CancelSelection(FALSE);

            SelectControl2(npc, FALSE);
        }
    }

    StatusUpdate();
    StatusSetEnable();

    return fSelectDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Bin\baseln\smartok.cpp ===
#include "me.h"
#ifdef _AFTER_ROCKCONCERT
static char* IM_NOT_SURPRISED = "That you are deaf now."
#endif
ChildFrame::CChildFrame()
{
	int horse;
	static char horsename = "Mr.Ed";
	char array[5];
	for (horse = 0; horse <= 5; horse++)
	{
		array[horse] = "a";
	}
}
CChildFrame::~CChildFrame()
{
}
BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// Dumb comments here
	return CMDIChildWnd::PreCreateWindow(cs);
}
class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();
	// Attributes
public:
	// Operations
public:
	// Overrides
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
protected:
	DECLARE_MESSAGE_MAP()
};
class CBogusStuff : public CBlahBlah
{
public:
	virtual BOOL DumDeeDoo(NOTHING& xx);
}
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadBitmap(IDE_MAINFRAME) ||
		!m_wndToolBar.SetButtons(buttons,
		sizeof(buttons)/sizeof(UINT)))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;
	}
}
void dumbfunction(int param1,
				  char *argv1[],
				  int argvx)
{
	int argv;
	char comstring[100];
	for (i=1; i <= 2; i++){
		strcat(comstring,argv[i]);
		exit(1);
	}
	if ((ofile = fopen(output,"wt")) == NULL){
		printf("Ah, fooey!\n")p;
		exit(1);
	}
}
char* string1 = "This is the string /
and it is continued on this line /
and also on this line";
	char* string2 = "This is also /
	a string that is comtinued on /
	another line";
	/* This is a comment section which includes code lines
	main()
	{
	char* junk = "String";
	for (i=0; i <= 5; i++){
	junk[i] = "Z";
	printf("%s",junk[i]);
	}
	}
	*/
switch(card_drawn)
{
case ACE_OF_SPADES:
	printf("You win!\n");
	break;
case JOKER:
	printf("Wild card!\n");
	break;
case JACK:
	switch(color)
	{
	case RED:
		printf("Red jack\n");
		break;
	case BLACK:
		printf("Black jack - but not blackjack.\n");
		break;
	}
	case QUEEN_OF_CLUBS:
		printf("Ouch!\n");
		break;
}
	switch(onecase)
	{
	case ONE:
		{
			DoSomething;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Src\edsncase.h ===
///////////////////////////////////////////////////////////////////////////////
//	edsncase.h
//
//	Created by :			
//		GeorgeCh
//
//	Description :
//		Declaration of the Edsnif01TestSet Class
//

#include "resource.h"

#ifndef __EDSNCASE_H__
#define __EDSNCASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "edsntype.h"
#include "emulcase.h"

#define ID_EDIT_COLUMN "^+{F8}"

///////////////////////////////////////////////////////////////////////////////
//	Sniff test classes

class SmartIndent : public CTest
{
	DECLARE_TEST(SmartIndent, EditorSniff)

public:
	virtual void Run(void);
	// Test cases --------------
	virtual	BOOL PoundCases();
	virtual BOOL Code1();
	virtual	BOOL Class1();
	virtual BOOL Code2();
	virtual BOOL Strings();
	virtual	BOOL MultiLineComments();
	virtual	BOOL CaseSwitch();

};


class EdsnifSelection : public CTest
{
	DECLARE_TEST(EdsnifSelection, EditorSniff)

public:
	virtual void Run(void);

// Test cases
	virtual BOOL CutCpyDelPst01( );
	virtual BOOL CutCpyDelPst02( );
	virtual BOOL CutCpyDelPst03( );
	virtual BOOL CutCpyDelPst04( );
};

class EdsnifTabIndent : public CTest
{
	DECLARE_TEST(EdsnifTabIndent, EditorSniff)

public:
	virtual void Run(void);

// Test cases

	virtual BOOL EnterTabs01( );
};

class EdsnifOvrInsert : public CTest
{
	DECLARE_TEST(EdsnifOvrInsert, EditorSniff)

public:
	virtual void Run(void);

// Test cases

	virtual BOOL OvrInsert01();	
};

class EdsnifToolsMenu : public CTest
{
	DECLARE_TEST(EdsnifToolsMenu, EditorSniff)

public:
	virtual void Run(void);
	// since this class is a base class for tests, it must have a ctor
	// that takes all test parameters for proper base class initialization

// Test cases

	virtual BOOL SaveOutputWindow(CString strOutputName);
	virtual BOOL AddTool(CString strToolPath,
							 CString strArguments,
							 CString strMenuText,
 							 int     OutputForm);
	virtual BOOL Verify(CString strTestName,
						CString strArguments,
						CString strMenuText,
						CString strShortCut,
						int     CompareMethod,
						int     OutputForm,
						BOOL	FILEOPEN);
	virtual BOOL General( );
};

BOOL PositionVerify(COSource testSource,
						int testCol1,
						int testLine1,
						int baseCol1,
						int baseLine1,
						LPCTSTR KeysToDo);

BOOL PositionSetup(COSource testSource,
						int testCol1,
						int testLine1,
						LPCTSTR KeysToDo);
BOOL LocationVerify(COSource testSource,
						int baseCol1,
						int baseLine1);


/*
class EdsnifEmulations : public CTest
{
	DECLARE_TEST(EdsnifEmulations, EditorSniff)

public:
	virtual void Run(void);
	// since this class is a base class for tests, it must have a ctor
	// that takes all test parameters for proper base class initialization
	virtual BOOL Emulations(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename = NULL);

// Test cases

//	virtual BOOL General( );
};
*/


class cVC2Position : public CTest
{
	DECLARE_TEST(cVC2Position, EditorSniff)

public:
	virtual void Run(void);

	virtual BOOL VC2Position( );
};

class cVC3Position : public CTest
{
	DECLARE_TEST(cVC3Position, EditorSniff)

public:
	
	virtual void Run(void);

	virtual BOOL VC3Position( );
};

class cBriefPosition : public CTest
{
	DECLARE_TEST(cBriefPosition, EditorSniff)

public:
	
	virtual void Run(void);

	virtual BOOL BriefPosition( );
};

class cEpsilonPosition : public CTest
{
	DECLARE_TEST(cEpsilonPosition, EditorSniff)

public:
	
	virtual void Run(void);

	virtual BOOL EpsilonPosition( );
};


#endif //__EDSNCASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Src\edsntype.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      edsntype.CPP
//
//      Created by :                    
//              GeorgeCh                
//
//      Description :
//              implementation of the Edsnif01Driver class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "edsntype.h"
#include "edsncase.h"
#include "emulcase.h"
#include "macrcase.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_SUBSUITE(EditorSniff, CIDESubSuite, "Source Edit Sniff", "MHopkins x60946")

// Fill out the test list
BEGIN_TESTLIST(EditorSniff)
	TEST(SmartIndent, RUN)
	TEST(EdsnifTabIndent, RUN)
	TEST(EdsnifOvrInsert, RUN)
	TEST(EdsnifToolsMenu, DONTRUN)
	TEST(cVC3Position, RUN)
	TEST(cVC2Position, RUN)
	TEST(cBriefPosition, DONTRUN)
	TEST(cEpsilonPosition, DONTRUN)
  TEST(CMacroTestCases, DONTRUN)
END_TESTLIST()

void EditorSniff::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Src\edsntype.h ===
///////////////////////////////////////////////////////////////////////////////
//	edsntype.h
//
//	Created by :			
//		GeorgeCh
//
//	Description :
//		Declaration of the Edsnif01Driver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// Edsnif01Driver class

class EditorSniff : public CIDESubSuite
{
	DECLARE_SUBSUITE(EditorSniff)

	DECLARE_TESTLIST();

	// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Src\macrcase.h ===
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//      macrcase.CPP
//
//      Created by :                    Date :
//        Craigs                          7/17/96
//
//      Description :
//        Declaration of the CMacroTestCases class
//

#ifndef __MACROCASES_H__
#define __MACROCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "edsntype.h"
#include "emulcase.h"

///////////////////////////////////////////////////////////////////////////////
// CMacroTestCases class

class CMacroTestCases : public CTest
{
  DECLARE_TEST(CMacroTestCases, EditorSniff)

// Operations
public:
	virtual void Run(void);

// Data
protected:

// Test Cases
protected:
};

#endif //__MACROCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Src\edsncase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	edsncase.CPP
// 
//	Created by
//		GeorgeCh
//
//	Description : 
//		Editor Sniff 01 
//	Date		Person		Comments
//	--------	---------	-----------
//	6/26/95		mikepie		Smart Indent added as an UNDOable
//							command. Modified sniff accordingly.
//				


#include "stdafx.h"
#include "edsncase.h"
#include "support.h"
// #include "emulcase.h"


#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

#define NOTCARE 0
#define WINDOUT 1					 
#define FILEOUT	2
#define NUMERAL 1
#define TEXTUAL 2
#define ARGLINE 3

#define SMART_INDENT_ON  1
#define SMART_INDENT_OFF 0

void SmartIndentMode(int mode)
{
	UIOptionsTabDlg tabdlg ;
	
	COSource  sourc;
	sourc.Create() ; 
	tabdlg.ShowTabsTab() ;
	MST.DoKeys("{TAB}");	// Move focus into window

	if (mode == SMART_INDENT_ON)
	{		  
		tabdlg.SetAutoIndentMode(SMART);	// S(m)art Indent
		//tabdlg.SetSmartIndentOption(CLOSING,100);	// Indent (C)losing brace on
	}
	else
	{
			tabdlg.SetAutoIndentMode(DEFAULT); // (D)efault
	}

	MST.DoKeys("{ENTER}");	// OK
	MST.DoKeys("^({F4})");	// Close new window
}	

UICustomizeTabDlg TCT;

static BOOL FirstTest = TRUE;


IMPLEMENT_TEST(SmartIndent, CTest, "Smart Indent", -1, EditorSniff)
void SmartIndent::Run(void)
{
	COSource  sourc;
	SmartIndentMode(SMART_INDENT_ON);
	
	sourc.Create();

	PoundCases();
	Code1();
	Class1();
	Code2();
	Strings();
	MultiLineComments();
	CaseSwitch();

	int removeold = 0;
	removeold = remove(m_strCWD + "testout\\SmartOut.cpp");	
	if (removeold != 0)
		m_pLog->RecordInfo("Couldn't remove %stestout\\SmartOut.cpp",m_strCWD);
	
	UIWB.SaveFileAs(m_strCWD + "testout\\SmartOut.cpp") ;

	int iresult = 0;
	m_pLog->RecordInfo("Comparing test output to %sbaseln\\SmartOk.cpp...",m_strCWD);
	iresult = CompareFiles(m_strCWD + "testout\\SmartOut.cpp",m_strCWD +"baseln\\SmartOk.cpp",1);

	m_pLog->RecordCompare(iresult == CF_SAME, 
		"Compare of output file %stestout\\SmartOut.cpp.",m_strCWD);

	// Close the window
	//MST.DoKeys("^{F4}");
	UIWB.CloseAllWindows();
	
}

BOOL SmartIndent::PoundCases()
{
CString temp;
	temp.LoadString(IDS_STRING1); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING2); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING3); MST.DoKeys(temp); 
	temp.LoadString(IDS_STRING4); MST.DoKeys(temp);
	
	return(TRUE);
}

BOOL SmartIndent::Code1()
{
	CString temp;
	temp.LoadString(IDS_STRING5); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING6); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING7); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING8); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING9); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING10); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING11); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING12); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING13); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING14); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING15); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING16); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING17); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING18); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING19); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING20); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING21); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING22); MST.DoKeys(temp);

	return(TRUE);
}

BOOL SmartIndent::Class1()
{
	CString temp;
	temp.LoadString(IDS_STRING23); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING24); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING25); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING26); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING27); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING28); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING29); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING30); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING31); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING32); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING33); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING34); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING35); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING36); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING37); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING38); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING39); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING40); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING41); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING42); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING43); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING44); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING45); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING46); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING47); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING48); MST.DoKeys(temp);
	return(TRUE);
}

BOOL SmartIndent::Code2()
{
	CString temp;
	temp.LoadString(IDS_STRING49); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING50); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING51); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING52); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING53); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING54); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING55); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING56); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING57); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING58); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING59); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING60); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING61); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING62); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING63); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING64); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING65); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING66); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING67); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING68); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING69); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING70); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING71); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING72); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING73); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING74); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING75); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING76); MST.DoKeys(temp);
	
	return(TRUE);
}

BOOL SmartIndent::Strings()
{
	CString temp;
	temp.LoadString(IDS_STRING77); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING78); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING79); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING80); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING81); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING82); MST.DoKeys(temp);
	
	return(TRUE);
}

BOOL SmartIndent::MultiLineComments()
{
	CString temp;
	temp.LoadString(IDS_STRING83); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING84); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING85); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING86); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING87); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING88); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING89); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING90); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING91); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING92); MST.DoKeys(temp);
		
	return(TRUE);
}

BOOL SmartIndent::CaseSwitch()
{
	CString temp;
	temp.LoadString(IDS_STRING93); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING94); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING95); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING96); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING97); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING98); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING99); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING100); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING101); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING102); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING103); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING104); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING105); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING106); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING107); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING108); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING109); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING110); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING111); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING112); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING113); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING114); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING115); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING116); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING117); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING118); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING119); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING120); MST.DoKeys(temp);
	temp.LoadString(IDS_STRING121); MST.DoKeys(temp);

	return(TRUE);
}


IMPLEMENT_TEST(EdsnifSelection, CTest, "Selection Tests", -1, EditorSniff)
void EdsnifSelection::Run(void)
{

	COSource  sourc;
	COSource  sourc2;

	SmartIndentMode(SMART_INDENT_OFF);
	
	// copy over writable versions of some baseline files
	if (FirstTest)
	{
		KillAllFiles("TESTOUT", FALSE);
		sourc.Open(m_strCWD + "baseln\\EdBase0.cpp" );
		sourc.SaveAs(m_strCWD + "testout\\EdBase0.cpp", TRUE);
		sourc.Close();
    }
	FirstTest = FALSE;

	sourc2.Open(m_strCWD + "baseln\\EdBase1.cpp" );
	sourc2.SaveAs(m_strCWD + "testout\\EdBase1.cpp", TRUE);
	sourc2.Close();

	// CutCpyDelPst01( );	// stream cut, paste, undo, redo
	// CutCpyDelPst02( );  // stream copy, paste, undo, redo
	CutCpyDelPst03( );
	// CutCpyDelPst04( ); CAFE problems prevent use of this test yet

}

IMPLEMENT_TEST(EdsnifTabIndent, CTest, "Tab/Indent tests", -1, EditorSniff)

void EdsnifTabIndent::Run(void)
{
	COSource  sourc;

	SmartIndentMode(SMART_INDENT_OFF);

	// Needs to be set again here for looping
	sourc.SelectEmulations(EMULATE_VC2);

	if (FirstTest)
	{
		KillAllFiles("TESTOUT", FALSE);
		sourc.Open(m_strCWD + "baseln\\EdBase0.cpp" );
		sourc.SaveAs(m_strCWD + "testout\\EdBase0.cpp", TRUE);
		sourc.Close();
    }
	FirstTest = FALSE;

	EnterTabs01( );     // enter tabs 	// Wait for new drop to reenable

}

IMPLEMENT_TEST(EdsnifOvrInsert, CTest, "Overtype/Insert tests", -1, EditorSniff)

void EdsnifOvrInsert::Run(void)
{

	SmartIndentMode(SMART_INDENT_OFF);

	COSource  sourc;
	
	// Needs to be set again here for looping
	sourc.SelectEmulations(EMULATE_VC2);

	if (FirstTest)
	{
		KillAllFiles("TESTOUT", FALSE);
		sourc.Open(m_strCWD + "baseln\\EdBase0.cpp" );
		sourc.SaveAs(m_strCWD + "testout\\EdBase0.cpp", TRUE);
		sourc.Close();
    }
	FirstTest = FALSE;

	OvrInsert01( );		// Overtype and insert modes

}

IMPLEMENT_TEST(EdsnifToolsMenu, CTest, "Tools menu tests", -1, EditorSniff)

void EdsnifToolsMenu::Run(void)
{
	SmartIndentMode(SMART_INDENT_OFF);
	
	COProject proj1;
	CString hellofiles;

	hellofiles = "copy " + m_strCWD + "baseln\\hello.* " + m_strCWD + "testout";

	if (FirstTest)
		KillAllFiles("TESTOUT", FALSE);
    FirstTest = FALSE;

	system (hellofiles);

	proj1.Open(m_strCWD + "testout\\hello.mak" );
// TODO UIProjOptionsTabDlg::SetDebugOption when Enrique implements it
	MST.DoKeys("%PS");
	//MST.DoKeys("{RIGHT}");
	MST.DoKeys("^({TAB})");
	MST.DoKeys("%U");
	MST.DoKeys("Argument");
	MST.DoKeys("{ENTER}");
	proj1.Close();

	General();

}

 // create source with jagged right edge for selection tests
 
BOOL EdsnifSelection::CutCpyDelPst01( )
{
	COSource  sourc;
	COSource  sourc2;
	COSource  sourc3;
	int iresult= 0;

	// SetTestName("CCDP01_2");
	// UNDO and compare, 
	// UNDO buffer lost when file is saved so must restore and cut first
    // This is no longer true - streamline
	sourc2.Open(m_strCWD + "testout\\EdBase0.cpp" );
	sourc2.SelectText( 1,2,118,2 );
	UIWB.DoCommand(ID_EDIT_CUT,DC_ACCEL);
	UIWB.DoCommand(ID_EDIT_UNDO,DC_ACCEL);
	UIWB.DoCommand(ID_EDIT_REDO,DC_ACCEL);
	sourc2.SaveAs(m_strCWD + "testout\\CCDP01_3.cpp", TRUE);
	iresult = CompareFiles(m_strCWD + "testout\\CCDP01_3.cpp",m_strCWD + "baseln\\EdBase1.cpp",1);
	if (iresult != CF_SAME)
	{
		m_pLog->RecordFailure("FAILED CCDP01_3/EdBase1.cpp REDO Stream Cut result = %d", iresult);
	}
	else m_pLog->RecordInfo("PASSED REDO Stream Cut result = %d", iresult);
	sourc2.Close();

return(TRUE);
}

BOOL EdsnifSelection::CutCpyDelPst02( )
{
	COSource  sourc;
	COSource  sourc2;
	COSource  sourc3;
	COSource  sourc4;
	int iresult= 0;

	// UNDO paste and compare
	// SetTestName("CCDP02_5");
	sourc3.Open(m_strCWD + "testout\\EdBase0.cpp" );
	sourc3.SelectText( 1,2,120,22 );
	UIWB.DoCommand(ID_EDIT_COPY,DC_MENU);
	sourc3.SetCursor ( 1,2 );
	UIWB.DoCommand(ID_EDIT_PASTE,DC_MENU);
	UIWB.DoCommand(ID_EDIT_UNDO,DC_MENU);
	UIWB.DoCommand(ID_EDIT_REDO,DC_MENU);
	sourc3.SaveAs(m_strCWD + "testout\\CCDP02_6.cpp", TRUE);
	iresult = CompareFiles(m_strCWD + "testout\\CCDP02_6.cpp",m_strCWD + "baseln\\EdBase0.cpp",1);
	if (iresult != CF_SAME)
	{
		m_pLog->RecordFailure("FAILED CCDP02_6/EdBase0 REDO Stream Paste result = %d", iresult);
	}
	else m_pLog->RecordInfo("PASSED REDO Stream Paste result = %d", iresult);
	sourc3.Close();

	return(TRUE);
}

BOOL EdsnifSelection::CutCpyDelPst03( )
{
	COSource  sourc;
	COSource  sourc2;
	COSource  sourc3;
	int iresult= 0;
	 
	// UNDO and compare  TODO change this to a shortcut
	// SetTestName("CCDP03_8");
	sourc2.Open(m_strCWD + "testout\\EdBase0.cpp" );
	sourc2.SelectText( 50,50,10,10 );
	UIWB.DoCommand(ID_EDIT_CLEAR,DC_MNEMONIC);
	UIWB.DoCommand(ID_EDIT_UNDO,DC_ACCEL);
	UIWB.DoCommand(ID_EDIT_REDO,DC_ACCEL);
	sourc3.SaveAs(m_strCWD + "testout\\CCDP03_9.cpp", TRUE);
	iresult = CompareFiles(m_strCWD + "testout\\CCDP03_9.cpp",m_strCWD + "baseln\\EdBase9.cpp",1);
	if (iresult != CF_SAME)
	{
		m_pLog->RecordFailure("FAILED CCDP03_9/EdBase9 REDO Stream Delete result = %d", iresult);
	}
	else m_pLog->RecordInfo("PASSED REDO Stream Delete result = %d", iresult);
	sourc3.Close();
	
return(TRUE);
}

BOOL EdsnifSelection::CutCpyDelPst04( )
{

	COSource  sourc;
	COSource  sourc2;
	COSource  sourc3;
	COSource  sourc4;
	COSource  sourc5;
	COSource  sourc6;
	int iresult= 0;
	 
	// Select a column, CUT, compare to baseline
	// SetTestName("CCDP04_A");
	sourc.Open(m_strCWD + "testout\\EdBase0.cpp" );
	sourc.SetCursor( 3, 4 );
	MST.DoKeys(ID_EDIT_COLUMN); // enter column mode
	sourc.SetCursor( 90, 70 );
	UIWB.DoCommand(ID_EDIT_CUT,DC_ACCEL);
	sourc.SaveAs(m_strCWD + "testout\\CCDP04_A.cpp", TRUE);
	iresult = CompareFiles(m_strCWD + "testout\\CCDP04_A.cpp",m_strCWD + "baseln\\EdBase10.cpp",1);
	if (iresult != CF_SAME)
	{
		m_pLog->RecordFailure("FAILED CCDP04_A/EdBase10 Column Select and Cut result = %d", iresult);
	}
	else m_pLog->RecordInfo("PASSED Column Select and Cut result = %d", iresult);

	// UNDO and compare
	// SetTestName("CCDP04_B");
	UIWB.DoCommand(ID_EDIT_UNDO,DC_ACCEL);
	sourc.SaveAs(m_strCWD + "testout\\CCDP04_B.cpp", TRUE);
	iresult = CompareFiles(m_strCWD + "testout\\CCDP04_B.cpp",m_strCWD +"testout\\EdBase0.cpp",1);
	if (iresult != CF_SAME)
	{
		m_pLog->RecordFailure("FAILED CCDP04_B/EdBase0 UNDO Column Cut result = %d", iresult);
	}
	else m_pLog->RecordInfo("PASSED UNDO Column Cut result = %d", iresult);

	// SetTestName("CCDP04_C");
	UIWB.DoCommand(ID_EDIT_REDO,DC_ACCEL);
	sourc.SaveAs(m_strCWD + "testout\\CCDP04_C.cpp", TRUE);
	sourc.Close();
	iresult = CompareFiles(m_strCWD + "testout\\CCDP04_C.cpp",m_strCWD + "baseln\\EdBase12.cpp",1);
	if (iresult != CF_SAME)
	{
		m_pLog->RecordFailure("FAILED CCDP04_C/EdBase12 REDO Column Cut result = %d", iresult);
	}
	else m_pLog->RecordInfo("PASSED REDO Column Cut result = %d", iresult);

	// now paste in the original cut and compare
	// SetTestName("CCDP04_D");
	sourc4.Open(m_strCWD + "testout\\EdBase0.cpp" );
	sourc4.SetCursor( 3, 4 );
	MST.DoKeys(ID_EDIT_COLUMN); // enter column mode
	sourc4.SetCursor( 90, 70 );
	UIWB.DoCommand(ID_EDIT_CUT,DC_ACCEL);
	sourc4.SetCursor( 3, 4 );
	UIWB.DoCommand(ID_EDIT_PASTE,DC_ACCEL);
	sourc4.SaveAs(m_strCWD + "testout\\CCDP04_D.cpp", TRUE);
	iresult = CompareFiles(m_strCWD + "testout\\CCDP04_D.cpp",m_strCWD +"testout\\EdBase0.cpp",1);
	if (iresult != CF_SAME)
	{
		m_pLog->RecordFailure("FAILED CCDP04_D/EdBase0 Column Paste result = %d", iresult);
	}
	else m_pLog->RecordInfo("PASSED Column Paste result = %d", iresult);
	 
	// UNDO paste and compare						
	// SetTestName("CCDP04_E");
	sourc4.Open(m_strCWD + "testout\\EdBase0.cpp" );
	sourc4.SetCursor( 3, 4 );
	MST.DoKeys(ID_EDIT_COLUMN); // enter column mode
	sourc4.SetCursor( 90, 70 );
	UIWB.DoCommand(ID_EDIT_CUT,DC_ACCEL);
	sourc4.SetCursor( 3, 4 );
	UIWB.DoCommand(ID_EDIT_PASTE,DC_ACCEL);
	UIWB.DoCommand(ID_EDIT_UNDO,DC_ACCEL);
	sourc4.SaveAs(m_strCWD + "testout\\CCDP04_E.cpp", TRUE);
	iresult = CompareFiles(m_strCWD + "testout\\CCDP04_E.cpp",m_strCWD + "baseln\\EdBase12.cpp",1);
	if (iresult != CF_SAME)
	{
		m_pLog->RecordFailure("FAILED CCDP04_E/EdBase12 UNDO Column Paste result = %d", iresult);
	}
	else m_pLog->RecordInfo("PASSED UNDO Column Paste result = %d", iresult);

	// REDO paste and compare
	// SetTestName("CCDP04_F");
	UIWB.DoCommand(ID_EDIT_REDO,DC_ACCEL);
	sourc4.SaveAs(m_strCWD + "testout\\CCDP04_F.cpp", TRUE);
	iresult = CompareFiles(m_strCWD + "testout\\CCDP04_F.cpp",m_strCWD +"testout\\EdBase0.cpp",1);
	if (iresult != CF_SAME)
	{
		m_pLog->RecordFailure("FAILED CCDP04_F/EdBase0 REDO Column Paste result = %d", iresult);
	}
	else m_pLog->RecordInfo("PASSED REDO Column Paste result = %d", iresult);
	sourc4.Close();
	 
	return(TRUE);
}


BOOL EdsnifTabIndent::EnterTabs01( )
{

	COSource  sourc2;
	COSource  sourc3;
	COSource  sourc4;
	COSource  sourc5;
	COSource  sourc6;
	COSource  sourc7;
	COSource  sourc8;
	COSource  sourc9;
	COSource  sourc10;
	int iresult= 0;

	// Open file copy text, insert text, compare to baseline
	sourc2.Create();
	
	CString strTest("\ttabs\t\tspaces     more tabs\t\t\tend.");
	CString strTest2("No leading tabs\t\tjust here.");
	CString strClip;
	CString strEmpty("");
	CString strTwoTabs("\t\t");

	// SetTestName("ET01_1");
	EmptyClip();
	MST.DoKeys( strTest );	
	UIWB.DoCommand( ID_EDIT_SELECT_ALL,DC_MENU );
	UIWB.DoCommand( ID_EDIT_CUT,DC_MENU );
	GetClipText( strClip );
	if (strClip != strTest) 	  // see if tabs are entered correctly
	{
		m_pLog->RecordFailure("FAILED ET01_1 Enter tabs");
	}
	else m_pLog->RecordInfo("PASSED Enter tabs 1");
	
	// SetTestName("ET01_2");
	MST.DoKeys( strTest );
	MST.DoKeys( "{ENTER}" );
	MST.DoKeys( strTest );
	MST.DoKeys( "{ENTER}" );
	MST.DoKeys( strTest );
	MST.DoKeys( "{ENTER}" );
	MST.DoKeys( "{HOME}{HOME}" );
	MST.DoKeys( strTest );
	MST.DoKeys( strTest );
	MST.DoKeys( "{ENTER}" );
	MST.DoKeys( strTest );
	MST.DoKeys( strTest );

	MST.DoKeys( "{HOME}{HOME}" );
	MST.DoKeys( strTest2 );
	MST.DoKeys( "{ENTER}" );
	MST.DoKeys( strTest2 );
	MST.DoKeys( "{ENTER}" );
	MST.DoKeys( strTest );
	MST.DoKeys( "{ENTER}" );
	MST.DoKeys( "{HOME}{HOME}" );
	MST.DoKeys( strTest2 );
	MST.DoKeys( strTest );
	MST.DoKeys( "{ENTER}" );
	MST.DoKeys( strTest2 );

	Sleep(1000);
	sourc2.SaveAs(m_strCWD + "testout\\ET01_2.cpp", TRUE);
	Sleep(1000);
	iresult = CompareFiles(m_strCWD + "testout\\ET01_2.cpp",m_strCWD + "baseln\\EdBase21.cpp",1);
	if (iresult != CF_SAME)
	{
		m_pLog->RecordFailure("FAILED ET01_2/EdBase21 Enter tabs result = %d", iresult);
	}
	else m_pLog->RecordInfo("PASSED Enter tabs 2");
	sourc2.Close();


    // UNDO Indent
	// SetTestName("ET01_7");
	sourc7.Open(m_strCWD + "testout\\EdBase0.cpp" );
	sourc7.SelectText( 10,10,51,84 );
	sourc7.TypeTextAtCursor( "{TAB}{TAB}{TAB}" );
	
	UIWB.DoCommand(ID_EDIT_UNDO,DC_ACCEL);
	UIWB.DoCommand(ID_EDIT_UNDO,DC_ACCEL);
	UIWB.DoCommand(ID_EDIT_UNDO,DC_ACCEL);
	
	sourc7.SaveAs(m_strCWD + "testout\\ET01_7.cpp", TRUE);
	
	iresult = CompareFiles(m_strCWD + "testout\\ET01_7.cpp",m_strCWD + "baseln\\EdBase0.cpp",1);
	
	if (iresult != CF_SAME)
	{
		m_pLog->RecordFailure("FAILED ET01_7/EdBase0 Undo unindent result = %d", iresult);
	}
	else m_pLog->RecordInfo("PASSED Undo unindent result = %d", iresult);

    // REDO Indent
	// SetTestName("ET01_8");
	UIWB.DoCommand(ID_EDIT_REDO,DC_ACCEL);
	UIWB.DoCommand(ID_EDIT_REDO,DC_ACCEL);
	UIWB.DoCommand(ID_EDIT_REDO,DC_ACCEL);
	Sleep(1000);

	sourc7.SaveAs(m_strCWD + "testout\\ET01_8.cpp", TRUE);

	iresult = CompareFiles(m_strCWD + "testout\\ET01_8.cpp",m_strCWD + "baseln\\EdBase22.cpp",1);

	if (iresult != CF_SAME)
	{
		m_pLog->RecordFailure("FAILED ET01_8/EdBase22 Redo Unindent result = %d", iresult);
	}
	else m_pLog->RecordInfo("PASSED Redo Unindent result = %d", iresult);

	sourc7.Close();

	return(TRUE);
}


BOOL EdsnifOvrInsert::OvrInsert01( )
{
	COSource  sourc1;
	COSource  sourc2;
	COSource  sourc3;
	COSource  sourc4;
	COSource  sourc5;
	COSource  sourc6;
	int iresult= 0;
	int i;
	
	CString strTest1("qwertyuiop 1234567890 asdfghjkl zxcvbnm QWERTYUIOP ASDFGHJKL ZXCVBNM");  // 13
	CString strTest2("tab\t backspace tab\t quote\'double quote\" backslash\\ question\?");  // 13
	CString strTest3("!@#$&*_`-= ;:| <>,./");												   // 5
	//   ~^+%[]{}()   These chars have special MST usage don't use without {}
	// Open file, Overtype text, compare to baseline
	// SetTestName("OI01_1");

	// Open file, Insert text, UNDO, REDO, compare to baseline
	// SetTestName("OI01_6");
	sourc6.Open(m_strCWD + "testout\\EdBase0.cpp" );
	sourc6.SetCursor( 66,17 );
	sourc6.TypeTextAtCursor( strTest1 );
	sourc6.SetCursor( 76,22 );
	sourc6.TypeTextAtCursor( strTest2 );
	sourc6.SetCursor( 28,2 );
	sourc6.TypeTextAtCursor( strTest3 );

	for (i=0;i<32;i++) {	// total number of undos for three strings
		UIWB.DoCommand(ID_EDIT_UNDO,DC_ACCEL);
		Sleep(100);
	}

	Sleep(2000);
	
	if (UIWB.IsCommandEnabled(ID_EDIT_UNDO))
	{
		 m_pLog->RecordFailure("FAILED OI01_6 UNDO still enabled",0);		 
	}
	
	for (i=0;i<32;i++) {	// total number of undos for three strings
		UIWB.DoCommand(ID_EDIT_REDO,DC_ACCEL);
		Sleep(100);
	}

	Sleep(2000);
	
	if (UIWB.IsCommandEnabled(ID_EDIT_REDO))
	{
		 m_pLog->RecordFailure("FAILED OI01_6 REDO still enabled",0);		 
	}

	sourc6.SaveAs(m_strCWD + "testout\\OI01_6.cpp", TRUE);
	iresult = CompareFiles(m_strCWD + "testout\\OI01_6.cpp",m_strCWD + "baseln\\EdBase34.cpp",1);
	
	if (iresult != CF_SAME)
	{
		m_pLog->RecordFailure("FAILED OI01_6/EdBase34 REDO typing result = %d", iresult);
	}
	else m_pLog->RecordInfo("PASSED REDO typing result = %d", iresult);
	sourc6.Close();

	return(TRUE);
}



BOOL EdsnifToolsMenu::AddTool(CString strToolPath,
							 CString strArguments,
							 CString strMenuText,
 							 int     OutputForm)
{
/*	TCT.ShowPage(TAB_TOOLS,3);	            // Tools.Customize.Tools
	MST.DoKeys("%A");						// select Add
	MST.DoKeys(strToolPath);
	MST.DoKeys("{ENTER}");					// OK
	MST.DoKeys("%n");						// select arguments
	MST.DoKeys(strArguments);
	if (OutputForm == WINDOUT)              
		MST.DoKeys("%w");					// redirect to output
 	MST.DoKeys("%e");						// Close window on exit
	MST.DoKeys("%m");						// select Menu Text
	MST.DoKeys(strMenuText);
	MST.DoKeys("{ENTER}");					// OK
	*/
COWorkSpace CwkSpc ;
	CwkSpc.AddTool(strMenuText,strToolPath,strArguments,m_strCWD,0,OutputForm,0);
	return TRUE;
}


BOOL EdsnifToolsMenu::SaveOutputWindow(CString strOutputName)
{	
	UIOutput OutWin;
	OutWin.Activate();
	UIFileSaveAsDlg SaveOutWin = UIWB.FileSaveAsDlg();
	EXPECT( SaveOutWin.IsValid() );
	SaveOutWin.SetName(strOutputName);
	SaveOutWin.OK(TRUE);
	return TRUE;
}

BOOL EdsnifToolsMenu::Verify(CString strTestName,
							CString strArguments,
							CString strMenuText,
							CString strShortCut,
							int     CompareMethod,
							int     OutputForm,
							BOOL	FILEOPEN)
{
	CString KeysToDo = "%T" + strShortCut;
	CString strToolPath("switches.exe");
	CString strToolOut = m_strCWD + "testout\\switches.out";
	CString strToolExe = m_strCWD + "switches.exe";
	CString strOutputName = m_strCWD + "testout\\tools" + strShortCut + ".out";
	CString strSwitchName = m_strCWD + "testout\\switch" + strShortCut + ".out";
	CString strTestFile;
	int iresult= 0;	
	int cresult= 0;	// column 
	int lresult= 0;	// line
	COSource copy1;

	KillFile(NULL,strToolOut,TRUE);		   // switches.out at this point
	// execute Tool
	// TODO check menu for tool before executing
	MST.DoKeys(KeysToDo);
	// TODO check for switches.out before proceeding
	Sleep(100);  // just to make sure switches.exe has time to save file

	// decide which file will be used for test output
	if (CompareMethod == WINDOUT) // save output window and use it
	{
		SaveOutputWindow(strOutputName);
		Sleep(40); 
	    strTestFile = strOutputName;
	}
	else // OutputForm == FILEOUT  use file written directly by tool
	{
		copy1.Open(strToolOut);
		copy1.SaveAs(strSwitchName);
		copy1.Close();
// TODO need to fail if file can't be opened
		strTestFile = strSwitchName;
	}

	// first search for any "$" and fail if there is one
	iresult =  FindStrInFile(strTestFile,"$",1);
	if (iresult != 0)
	{
		 m_pLog->RecordFailure("FAILED Probable translated macro = %d", iresult);
		return FALSE;
	}
	else  // added with following cutour
	{
		m_pLog->RecordInfo("PASSED Add and run Tool", 1);
		return(TRUE);
	}
/*  Too much trouble for sniff test, just hit it once
	if (FILEOPEN == FALSE)
	{
		// search for "comstring:" only, no random data
      	iresult = CompareFiles(strTestFile,m_strCWD + "baseln\\swstring.out",1);
		if (iresult != CF_SAME) 
		{
			m_pLog->RecordFailure("FAILED comstring contains trash = %d", iresult);
			return FALSE;
		}
	}
	else switch (OutputForm)
		{
			case NUMERAL: // look for Line:6 and Col:23
					lresult =  FindStrInFile(strTestFile,"L:6",1);
					cresult =  FindStrInFile(strTestFile,"C:23",1);
					iresult = lresult+cresult;
					if ((cresult == 0) && (lresult == 0))
					{
						 m_pLog->RecordFailure("FAILED Line or Column number incorrect = %d", iresult);
						return FALSE;
					}
					else
					{
						m_pLog->RecordInfo("PASSED L/C Add and run Tool", 0);
						return TRUE;
					}
				break;	
			case TEXTUAL: // look for selected word "value"
					iresult =  FindStrInFile(strTestFile,"value",1);
					if (iresult == 0)
					{
						m_pLog->RecordFailure("FAILED Curtext incorrect = %d", iresult);
						return FALSE;
					}
					else
					{
						m_pLog->RecordInfo("PASSED CT Add and run Tool", 0);
						return TRUE;
					}
				break;
			case ARGLINE: // look for selected word "Argument"
					iresult =  FindStrInFile(strTestFile,"Argument",1);
					if (iresult == 0)
					{
						m_pLog->RecordFailure("FAILED Cmdline incorrect = %d", iresult);
						return FALSE;
					}
					else
					{
						m_pLog->RecordInfo("PASSED CL Add and run Tool", 0);
						return TRUE;
					}
				break;
// TODO find out the path from coprject.h GetDir() and build the paths
			case NOTCARE: // can't use hard coded paths for portable test 
				iresult = CompareFiles(strTestFile,m_strCWD,1);
				if (iresult != CF_SAME)
				{
					m_pLog->RecordFailure("FAILED Path Add and run Tool = %d", iresult);
					return FALSE;
				}
				else
				{
					m_pLog->RecordInfo("PASSED PP Add and run Tool", 0);
					return TRUE;
				}
				break;
		}

	m_pLog->RecordInfo("FAILED Unknown Add and run Tool", 1);
	return(FALSE);
  */

  }

BOOL EdsnifToolsMenu::General( )
{
	COSource outwind;
	COSource outfile;
	COSource source1;
	COProject proj1;
//	CString strBaseName = m_strCWD + "baseln\\base" + strShortCut + ".out";
	CString strToolOut = m_strCWD + "switches.out";
	CString strToolExe = m_strCWD + "switches.exe";

		// SetTestName(strTestName);
	KillFile(NULL,strToolOut,TRUE);		   // switches.out at this point

	proj1.Open(m_strCWD + "testout\\hello.mak" );
	source1.Open(m_strCWD + "testout\\hello.cpp");
//	source1.SelectText( 6,18,6,23 ); // select word "value" 

	// must close whetever else is open before starting
	AddTool(strToolExe,"${(}FilePath{)}",            "File    &1",NOTCARE);
	AddTool(strToolExe,"${(}FileName)}",			 "FileName&2",NOTCARE);
	AddTool(strToolExe,"${(}FileExt)}",				 "FileExt &5",NOTCARE);
	AddTool(strToolExe,"${(}WkspDir{)}${(}WkspName)","Proj    &4",NOTCARE);
	AddTool(strToolExe,"${(}TargetPath{)}",          "Target  &7",NOTCARE);
//	AddTool(strToolExe,"${(}TargetName)}",			 "TarName &j",NOTCARE);
//	AddTool(strToolExe,"${(}TargetExt)}",			 "TarExt  &k",NOTCARE);
//	AddTool(strToolExe,"${(}TargetArgs)}",			 "TarArgs &l",NOTCARE);
	AddTool(strToolExe,"${(}TargetDir)}",			 "TarDir  &3",NOTCARE);
	AddTool(strToolExe,"${(}CurLine)}",				 "CurLine &6",NOTCARE);
	AddTool(strToolExe,"${(}CurCol{)}",              "Column  &8",NUMERAL);
	AddTool(strToolExe,"${(}CurText)}",				 "CurText &9",NOTCARE);
	AddTool(strToolExe,"${(}CurDir)}",				 "CurDir  &0",NOTCARE);
																 
	Verify("Tools01","${(}FilePath{)}",            "File   &1","1",FILEOUT,NOTCARE,TRUE);
	Verify("Tools04","${(}WkspDir{)}${(}WkspName)","Proj   &4","4",FILEOUT,NOTCARE,TRUE);
	Verify("Tools07","${(}TargetPath{)}",          "Target &7","7",FILEOUT,NOTCARE,TRUE);
//	Verify("Tools08","${(}CurCol{)}",              "Column &8","8",WINDOUT,NUMERAL,FALSE);

	source1.Close();
	proj1.Close();

	return(TRUE);
}


IMPLEMENT_TEST(cVC2Position, CTest, "VC2 Position Emulation tests", -1, EditorSniff)

void cVC2Position ::Run(void)
{
	if (FirstTest)
		KillAllFiles(m_strCWD + "TESTOUT", FALSE);
    FirstTest = FALSE;

	SmartIndentMode(SMART_INDENT_OFF);
	VC2Position( );
};

IMPLEMENT_TEST(cVC3Position, CTest, "VC3 Position Emulation tests", -1, EditorSniff)

void cVC3Position ::Run(void)
{
	if (FirstTest)
		KillAllFiles(m_strCWD + "TESTOUT", FALSE);
    FirstTest = FALSE;

	SmartIndentMode(SMART_INDENT_OFF);
	VC3Position( );
};

IMPLEMENT_TEST(cBriefPosition, CTest, "Brief Position Emulation tests", -1, EditorSniff)

void cBriefPosition ::Run(void)
{
	if (FirstTest)
		KillAllFiles(m_strCWD + "TESTOUT", FALSE);
    FirstTest = FALSE;

	SmartIndentMode(SMART_INDENT_OFF);
	BriefPosition( );
};

IMPLEMENT_TEST(cEpsilonPosition, CTest, "Epsilon Position Emulation tests", -1, EditorSniff)
 
void cEpsilonPosition ::Run(void)
{
	if (FirstTest)
		KillAllFiles(m_strCWD + "TESTOUT", FALSE);
    FirstTest = FALSE;

	SmartIndentMode(SMART_INDENT_OFF);
	EpsilonPosition( );
};

/*
IMPLEMENT_TEST(EdsnifEmulations, CTest, "Emulations Base Class", -1, EditorSniff)

// since this class is a base class for tests, it must have a ctor
// that takes all test parameters for proper base class initialization
Emulations::Emulations(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename)
: CTest(pSubSuite, szName, nExpectedCompares, szListFilename)
{
}
*/

BOOL PositionVerify(COSource testSource,
					 int testLine1,
					 int testCol1,
					 int baseLine1,
					 int baseCol1,
					 LPCTSTR KeysToDo)
{
	int iresult= 0;	
	int CurrentLine = 0;
	int CurrentCol = 0;

	testSource.AttachActiveEditor();
	if ((testLine1 > 0)&&(testCol1 > 0)) 
		testSource.SetCursor(testLine1,testCol1);  // else stay put
	MST.DoKeys(KeysToDo);
	CurrentLine = testSource.GetCurrentLine();
	CurrentCol = testSource.GetCurrentColumn();

// Set the position so if the check below fails, we'll still be in the right place for the
// next command.
	testSource.SetCursor(baseLine1,baseCol1);

	if ((CurrentLine != baseLine1) && (CurrentCol != baseCol1)) 	
	{
		LOG->RecordFailure("FAILED %s  Base L:%d C:%d Current L:%d C:%d",KeysToDo,baseLine1,baseCol1,CurrentLine,CurrentCol);  //debug
	}
	else LOG->RecordInfo("PASSED %s",KeysToDo);
	return(TRUE);
}


BOOL PositionSetup(COSource testSource,
				   int testLine1,
				   int testCol1,
				   LPCTSTR KeysToDo)
{
// This function exists only as a dummy to setup the position for the following command
// We don't know what the final position will be
	testSource.AttachActiveEditor();
	testSource.SetCursor(testLine1,testCol1);
	MST.DoKeys(KeysToDo);

	return(TRUE);
}

BOOL LocationVerify(COSource testSource,
							 int baseLine1,
							 int baseCol1)
{
	int iresult= 0;	
	int CurrentLine = 0;
	int CurrentCol = 0;

	testSource.AttachActiveEditor();

	CurrentLine = testSource.GetCurrentLine();
	CurrentCol = testSource.GetCurrentColumn();

	if ((CurrentLine != baseLine1) && (CurrentCol != baseCol1)) 	
	{
		LOG->RecordFailure("FAILED Base L:%d C:%d Current L:%d C:%d",baseLine1,baseCol1,CurrentLine,CurrentCol);  //debug
		MST.DoKeys("{ESC 2}");
		testSource.SetCursor(baseLine1,baseCol1);
	    MST.DoKeys("{RIGHT}");

		return(FALSE);  // move on to next test
	}  
	else LOG->RecordInfo  ("PASSED Base L:%d C:%d",baseLine1,baseCol1);  //debug

	return(TRUE);
}

BOOL cBriefPosition::BriefPosition( )
{
	COSource t;
	COSource b;
	t.Open(m_strCWD + "baseln\\baseposi.cpp");
	t.SelectEmulations(EMULATE_BRIEF);

//	PositionVerify(testSource,testLine1,testCol1,baseLine1,baseCol1,KeysToDo)

 	PositionVerify(t,95,37,95,27,KeyCommand[CursorBackWord][EMULATE_BRIEF]);
 	PositionVerify(t,140,75,1,1,KeyCommand[CursorBeginDocument][EMULATE_BRIEF]);
 	PositionVerify(t,6,1,6,23,KeyCommand[CursorBeginLine][EMULATE_BRIEF]);

 	PositionVerify(t,7,1,7,66,KeyCommand[CursorBriefEnd][EMULATE_BRIEF]);
 	PositionVerify(t,8,43,8,1,KeyCommand[CursorBriefHome][EMULATE_BRIEF]);
 	PositionVerify(t,137,52,138,52,KeyCommand[CursorDown][EMULATE_BRIEF]);
 	PositionVerify(t,137,52,183,1,KeyCommand[CursorEndDocument][EMULATE_BRIEF]);
 	PositionVerify(t,2,1,2,23,KeyCommand[CursorEndLine][EMULATE_BRIEF]);
 	PositionVerify(t,2,1,3,1,KeyCommand[CursorForwardWord][EMULATE_BRIEF]);
 	PositionVerify(t,2,81,3,1,KeyCommand[CursorForwardWord][EMULATE_BRIEF]);
 	PositionVerify(t,182,2,183,1,KeyCommand[CursorForwardWord][EMULATE_BRIEF]);
 	PositionVerify(t,183,1,183,1,KeyCommand[CursorForwardWord][EMULATE_BRIEF]);
 	PositionVerify(t,92,66,92,9,KeyCommand[CursorHome][EMULATE_BRIEF]);

	t.SelectEmulations(EMULATE_VC3); // leave in known state
	t.AttachActiveEditor();
	t.SaveAs(m_strCWD + "testout\\briefpos.cpp", TRUE);
	t.Close();
	return(TRUE);
}


BOOL cVC2Position::VC2Position( )
{
	COSource t;
	t.Open(m_strCWD + "baseln\\baseposi.cpp");
	t.SelectEmulations(EMULATE_VC2);

 	PositionVerify(t,92,46,89,1,KeyCommand[BackEpsilonSentence][EMULATE_VC2]);
 	PositionVerify(t,95,37,95,27,KeyCommand[CursorBackWord][EMULATE_VC2]);
 	PositionVerify(t,140,75,1,1,KeyCommand[CursorBeginDocument][EMULATE_VC2]);
 	PositionVerify(t,137,52,138,52,KeyCommand[CursorDown][EMULATE_VC2]);
 	PositionVerify(t,137,52,183,1,KeyCommand[CursorEndDocument][EMULATE_VC2]);
 	PositionVerify(t,2,1,2,23,KeyCommand[CursorEndLine][EMULATE_VC2]);
 	PositionVerify(t,2,1,2,81,KeyCommand[CursorForwardWord][EMULATE_VC2]);

	t.SelectEmulations(EMULATE_VC3); // leave in known state
	t.AttachActiveEditor();
	t.SaveAs(m_strCWD + "testout\\vc2posi.cpp", TRUE);
	t.Close();
	return(TRUE);
}

BOOL cVC3Position::VC3Position( )
{
	COSource t;
	COSource b;
	t.Open(m_strCWD + "baseln\\baseposi.cpp");
	t.SelectEmulations(EMULATE_VC3);

 	// If these two don't pass, VC3 emulation is not selected
	// pass only if virtual space if off
 	PositionVerify(t,6,1,5,2,KeyCommand[CursorLeft][EMULATE_VC3]);   
	// Nobody but VC uses this stupid syntax
	// Nore has such compiler problems	
	
//    t.Find("\\{\\{\".*\"\\}\\!\\{\'.*\'\\}\\}",FALSE,FALSE,TRUE);     

	PositionVerify(t,95,37,95,27,KeyCommand[CursorBackWord][EMULATE_VC3]);
 	PositionVerify(t,140,75,1,1,KeyCommand[CursorBeginDocument][EMULATE_VC3]);
 	PositionVerify(t,137,52,138,52,KeyCommand[CursorDown][EMULATE_VC3]);
 	PositionVerify(t,137,52,183,1,KeyCommand[CursorEndDocument][EMULATE_VC3]);
 	PositionVerify(t,2,1,2,23,KeyCommand[CursorEndLine][EMULATE_VC3]);
 	PositionVerify(t,2,1,2,81,KeyCommand[CursorForwardWord][EMULATE_VC3]);
	   
 	PositionSetup(t,3,12,KeyCommand[CursorBeginDocument][EMULATE_VC3]);
	t.AttachActiveEditor();
    t.Find("NULL");
    LocationVerify(t,59,37);
 	PositionSetup(t,59,37,KeyCommand[FindNext][EMULATE_VC3]);
    LocationVerify(t,59,50);
 	PositionSetup(t,59,46,KeyCommand[FindPrev][EMULATE_VC3]);
    LocationVerify(t,59,37);

	// Test reverse search 
	t.Find("ClearScreen");
	m_pLog->RecordInfo("Testing backword search");
	MST.DoKeys("+{F3}");
	
	LocationVerify(t,56,16);
	// End reverse search test.
		   
	t.SaveAs(m_strCWD + "testout\\vc3posi.cpp", TRUE);
	t.Close();
	return(TRUE);
}


BOOL cEpsilonPosition::EpsilonPosition( )
{
	COSource t;
	COSource b;
	t.Open(m_strCWD + "baseln\\baseposi.cpp");
	t.SelectEmulations(EMULATE_EPSILON);

// Order of following pairs must be maintained for End/BeginWindow to work in test
 	PositionVerify(t,140,75,1,1,KeyCommand[CursorBeginDocument][EMULATE_EPSILON]);
 	PositionVerify(t,4,35,1,1,KeyCommand[CursorBeginWindow][EMULATE_EPSILON]);
 	PositionVerify(t,166,22,183,1,KeyCommand[CursorEndDocument][EMULATE_EPSILON]);
 	PositionVerify(t,166,26,183,1,KeyCommand[CursorEndWindow][EMULATE_EPSILON]);

 	PositionSetup(t,98,1,KeyCommand[CursorPageUp][EMULATE_EPSILON]);
 	PositionVerify(t,-1,-1,98,1,KeyCommand[CursorPageDown][EMULATE_EPSILON]);
 	PositionSetup(t,77,1,KeyCommand[CursorPageDown][EMULATE_EPSILON]);
 	PositionVerify(t,-1,-1,77,1,KeyCommand[CursorPageUp][EMULATE_EPSILON]);

	m_pLog->RecordInfo("END Epsilon Position Verify Tests");

	t.SelectEmulations(EMULATE_VC3); // leave in known state
	t.AttachActiveEditor();
	t.SaveAs(m_strCWD + "testout\\epsiposi.cpp", TRUE);
	t.Close();
	return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Src\emulcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	emulcase.h
//
//	Created by :			
//		GeorgeCh
//
//	Description :
//		Declaration of the Edsnif01TestSet Class
//

#ifndef __EMULCASE_H__
#define __EMULCASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

// enum Editor {VC2,VC3,Brief,Epsilon};

// Edit stuff
#define BackEpsilonParagraph 	0        
#define BackEpsilonSentence		1        
#define CapitalizeEpsilonWord	2        
#define ColumnSelect			3        
#define CursorBackWord			4        
#define CursorBeginDocument		5        
#define CursorBeginLine			6        
#define CursorBeginWindow		7        
#define CursorBriefEnd			8        
#define CursorBriefHome			9        
#define CursorDown		 		10       
#define CursorEndDocument		11       
#define CursorEndLine			12       
#define CursorEndWindow			13       
#define CursorForwardWord		14       
#define CursorHome				15       
#define CursorLeft				16       
#define CursorLeftWindow		17       
#define CursorPageDown			18       
#define CursorPageUp			19       
#define CursorRight				20       
#define CursorRightWindow		21       
#define CursorUp				22       
#define DeleteBlankLines        23      
#define DeleteHorizontalSpace   24      
#define DeleteNextWord          25      
#define DeletePreviousWord      26      
#define DeleteToBeginningOfLine 27      
#define DeleteToEndOfLine       28      
#define EditCopy                29      
#define EditCut                 30      
#define EditCutLine             31      
#define EditDelete              32      
#define EditDeleteLine          33      
#define EditLowerCase           34      
#define EditPaste               35      
#define EditProperties          36      
#define EditRedo                37      
#define EditRedoChanges         38      
#define EditSelectAll           39      
#define EditUndo                40      
#define EditUndoChanges         41      
#define EditUpperCase           42      
#define ForwardEpsilonParagraph 43      
#define ForwardEpsilonSentence  44      
#define HighlightEpsilonRegion  45      
#define IndentEpsilonRegion     46      
#define IndentLines             47      
#define KillEpsilonRegion       48      
#define KillEpsilonSentence     49      
#define LineSelect              50      
#define LowerCaseEpsilonWord    51      
#define MarkEpsilonParagraph    52      
#define StreamSelectExclusive   53      
#define StreamSelectInclusive   54      
#define SwapAncorPoint          55      
#define TabifyLines             56      
#define ToggleOverstrike        57      
#define ToggleTabDisplay        58      
#define TransposeCharacters     59
#define TransposeLines          60
#define TransposeWords          61
#define UnindentLines           62
#define UntabifyLines           63
#define UpperCaseEpsilonWord    64
#define EditBookmarks           65
#define NextDef                 66
#define PreviousDef             67
#define SearchAgain             68
#define SearchClearMarks        69
#define SearchCondDown          70
#define SearchCondUp            71
#define Bookmark10              72
#define Bookmark1               73
#define Bookmark2               74
#define Bookmark3               75
#define Bookmark4               76
#define Bookmark5               77
#define Bookmark6               78
#define Bookmark7               79
#define Bookmark8               80
#define Bookmark9               81
#define DropEpsMark             82
#define dFind                    83
#define FindNext                84
#define FindNextWord            85
#define FindPrev                86
#define FindPrevWord            87
#define GoTo                    88
#define GoToDef                 89
#define GoToTag                 90
#define GoToFile                91
#define GoToRef                 92
#define MatchBrace              93
#define NextMark                94
#define NextEpsMark             95
#define NextErrorTag            96
#define PreviousMark            97 
#define PreviousTag             98 
#define Replace                 99 
#define ToggleMark              100
#define SearchTool              101
#define SelectCondDown          102
#define SelectCondUp            103
#define ToggleCase              104
#define ToggleRE                105
#define ToggleSearchForWord     106
                                
// Add one to array subscript for 0
                                
static LPCTSTR KeyCommand[107][8] = { 
//                               VC2         VC3         Brief,      Epsilon,     C_VC2,      C_VC3,      C_Brief,    C_Epsilon
/* BackEpsilonParagraph     */  {"%{UP}",    "%{UP}",    "",         "(%[)",      "",         "",         "",         "%{UP}"},   
/* BackEpsilonSentence      */  {"^%{LEFT}", "^%{LEFT}", "",         "(%A)",      "",         "",         "",         "^{UP}"},   
/* CapitalizeEpsilonWord    */  {"",         "",         "",         "(%C)",      "",         "",         "",         ""},        
/* ColumnSelect             */  {"^+{F8}",   "^+{F8}",   "%C",       "(^X)(+3)",  "",         "",         "",         ""},      
/* CursorBackWord           */  {"^{LEFT}",  "^{LEFT}",  "^{LEFT}",  "(%B)",      "",         "",         "^+{LEFT}", "^{LEFT}"}, 
/* CursorBeginDocument      */  {"^{HOME}",  "^{HOME}",  "^{PGUP}",  "(%<)",      "",         "",         "",         "^{HOME}"}, 
/* CursorBeginLine          */  {"",         "",         "",         "",          "",         "",         "",         ""},        
/* CursorBeginWindow        */  {"",         "",         "^{HOME}",  "(%,)",      "",         "",         "",         "{HOME}"},  
/* CursorBriefEnd           */  {"",         "",         "{END}",    "",          "",         "",         "",         ""},        
/* CursorBriefHome          */  {"",         "",         "{HOME}",   "",          "",         "",         "",         ""},        
/* CursorDown               */  {"{DOWN}",   "{DOWN}",   "{DOWN}",   "^N",        "",         "",         "",         "{DOWN}"},      
/* CursorEndDocument        */  {"^{END}",   "^{END}",   "^{PGDN}",  "(%>)",      "",         "",         "",         "^{END}"},  
/* CursorEndLine            */  {"{END}",    "{END}",    "",         "(%{RIGHT})","",         "",         "",         "^E"},      
/* CursorEndWindow          */  {"",         "",         "^{END}",   "(%.)"      ,"",         "",         "",         "{END}"},   
/* CursorForwardWord        */  {"^{RIGHT}", "^{RIGHT}", "^{RIGHT}", "(%F)"      ,"",         "",         "",         "^{RIGHT}"},
/* CursorHome               */  {"{HOME}",   "{HOME}",   "",         "%{LEFT}"   ,"",         "",         "",         "^A"},        
/* CursorLeft               */  {"{LEFT}",   "{LEFT}",   "{LEFT}",   "^B"        ,"",         "",         "+{LEFT}",  "{LEFT}"},        
/* CursorLeftWindow         */  {"",         "",         "+{HOME}",  ""          ,"",         "",         "",         ""},        
/* CursorPageDown           */  {"{PGDN}",   "{PGDN}",   "{PGDN}",   "{PGDN}"    ,"",         "",         "",         "^V"},        
/* CursorPageUp             */  {"{PGUP}",   "{PGUP}",   "{PGUP}",   "{PGUP}"    ,"",         "",         "",         "%V"},        
/* CursorRight              */  {"{RIGHT}",  "{RIGHT}",  "{RIGHT}",  "^f"        ,"",         "",         "",         "{RIGHT}"},        
/* CursorRightWindow        */  {"",         "",         "+{END}",   ""          ,"",         "",         "",         ""},        
/* CursorUp                 */  {"{UP}",     "{UP}",     "{UP}",     "^P"        ,"",         "",         "",         "{UP}"},        
/* DeleteBlankLines         */  {"",         "",         "",         "(^X)(^O)"  ,"",         "",         "",         ""},
/* DeleteHorizontalSpace    */  {"",         "",         "",         "%\\"       ,"",         "",         "",         ""},
/* DeleteNextWord           */  {"^{DEL}",   "^{DEL}",   "%{BS}",    "%D"        ,"",         "",         "",         ""},        
/* DeletePreviousWord       */  {"^{BS}",    "^{BS}",    "^{BS}",    "%{BS}"     ,"",         "",         "",         ""},        
/* DeleteToBeginningOfLine  */  {"",         "",         "^K",       ""          ,"",         "",         "",         ""},
/* DeleteToEndOfLine        */  {"",         "",         "%K",       ""          ,"",         "",         "",         ""},
/* EditCopy                 */  {"^C",       "^C",       "{NUMPAD+}","%W"        ,"^{INS}",   "^{INS}",   "^{INS}",   "^C"},
/* EditCut                  */  {"^X",       "^X",       "{NUMPAD-}","+{DEL}"    ,"+{DEL}",   "+{DEL}",   "+{DEL}",   ""},
/* EditCutLine              */  {"^Y",       "^Y",       "",         "^K"        ,"",         "",         "",         ""},
/* EditDelete               */  {"{DEL}",    "{DEL}",    "{DEL}",    "^D"        ,"",         "",         "",         "{DEL}"},
/* EditDeleteLine           */  {"",         "",         "%D",       ""          ,"",         "",         "",         ""},
/* EditLowerCase            */  {"^U",       "^U",       "^{DOWN}",  ""          ,"",         "",         "",         ""},
/* EditPaste                */  {"^V",       "^V",       "{INS}",    "^V"        ,"+{INS}",   "+{INS}",   "+{INS}",   "^Y"},
/* EditProperties           */  {"%{ENTER}", "%{ENTER}", "%{ENTER}", "(%{ENTER})","",         "",         "",         ""},
/* EditRedo                 */  {"^A",       "^A",       "^U",       "(^X)(R)"   ,"",         "",         "^A",       "{F10}"},
/* EditRedoChanges          */  {"",         "",         "",         "(^X)(^R)"  ,"",         "",         "",         "^{F10}"},
/* EditSelectAll            */  {"",         "",         "",         ""          ,"",         "",         "",         ""},
/* EditUndo                 */  {"^Z",       "^Z",       "{NUMPAD*}","(^X)(U)"   ,"%{BS}",    "%{BS}",    "%U",       "{F9}"},
/* EditUndoChanges          */  {"",         "",         "",         "(^X)(^U)"  ,"",         "",         "",         "^{F9}"},
/* EditUpperCase            */  {"^+U",      "^+U",      "^{UP}",    ""          ,"",         "",         "",         ""},
/* ForwardEpsilonParagraph  */  {"%{DOWN}",  "%{DOWN}",  "",         "(%])"      ,"",         "",         "",         "%{DOWN}"},
/* ForwardEpsilonSentence   */  {"^%{RIGHT}","^%{RIGHT}","",         "(%E)"      ,"",         "",         "",         "^{DOWN}"},
/* HighlightEpsilonRegion   */  {"^H",       "^H",       "",         "(^X)(^H)"  ,"",         "",         "",         ""},
/* IndentEpsilonRegion      */  {"^%I",      "^%I",      "",         ""          ,"",         "",         "",         "^%{BS}"},
/* IndentLines              */  {"",         "",         "",         ""          ,"",         "",         "",         ""},
/* KillEpsilonRegion        */  {"^%w",      "^%w",      "",         "^w"        ,"",         "",         "",         ""},
/* KillEpsilonSentence      */  {"^%K",      "^%K",      "",         "%K"        ,"",         "",         "",         ""},
/* LineSelect               */  {"^%{F8}",   "^%{F8}",   "%L",       ""          ,"",         "",         "",         ""},
/* LowerCaseEpsilonWord     */  {"",         "",         "",         "(%L)"      ,"",         "",         "",         ""},
/* MarkEpsilonParagraph     */  {"",         "",         "",         "%H"        ,"",         "",         "",         ""},
/* StreamSelectExclusive    */  {"^+A",      "^+A",      "%A",       "%@"        ,"",         "",         "",         "^2"},
/* StreamSelectInclusive    */  {"^+I",      "^+I",      "%M",       ""          ,"",         "",         "",         ""},
/* SwapAncorPoint           */  {"^+X",      "^+X",      "^+X",      "(^X)(^X)"  ,"",         "",         "",         ""},
/* TabifyLines              */  {"^+T",      "^+T",      "",         "(^X)(%T)"  ,"",         "",         "",         ""},
/* ToggleOverstrike         */  {"{INS}",    "{INS}",    "%I",       "{INS}"     ,"",         "",         "",         ""},
/* ToggleTabDisplay         */  {"^%T",      "^%T",      "^%T",      ""          ,"",         "",         "",         ""},
/* TransposeCharacters      */  {"",         "",         "",         "^T"        ,"",         "",         "",         ""},
/* TransposeLines           */  {"",         "",         "",         "(^X)(^T)"  ,"",         "",         "",         ""},
/* TransposeWords           */  {"",         "",         "",         "(%T)"      ,"",         "",         "",         ""},
/* UnindentLines            */  {"",         "",         "",         ""          ,"",         "",         "",         ""},
/* UntabifyLines            */  {"^+ ",      "^+ ",      "",         "(^X)(%I)"  ,"",         "",         "",         ""},
/* UpperCaseEpsilonWord     */  {"",         "",         "",         "(%U)"      ,"",         "",         "",         ""},
/* EditBookmarks            */  {"",         "",         "%J",       "(^X)(/)"   ,"",         "",         "",         "(^X)(J)"},
/* NextDef                  */  {"+{NUMPAD+}","+{NUMPAD+}","^{NUMPAD+}",""       ,"",         "",         "",         ""},
/* PreviousDef              */  {"+{NUMPAD-}","+{NUMPAD-}","",       ""          ,"",         "",         "",         ""},
/* SearchAgain              */  {"",         "",         "+{F5}",    ""          ,"",         "",         "",         ""},
/* SearchClearMarks         */  {"",         "",         "",         ""          ,"",         "",         "",         ""},
/* SearchCondDown           */  {"^.",       "^.",       "^.",       ""          ,"",         "",         "",         ""},
/* SearchCondUp             */  {"^,",       "^,",       "^,",       ""          ,"",         "",         "",         ""},
/* Bookmark10               */  {"",         "",         "%0",       ""          ,"",         "",         "",         ""},
/* Bookmark1                */  {"",         "",         "%1",       ""          ,"",         "",         "",         ""},
/* Bookmark2                */  {"",         "",         "%2",       ""          ,"",         "",         "",         ""},
/* Bookmark3                */  {"",         "",         "%3",       ""          ,"",         "",         "",         ""},
/* Bookmark4                */  {"",         "",         "%4",       ""          ,"",         "",         "",         ""},
/* Bookmark5                */  {"",         "",         "%5",       ""          ,"",         "",         "",         ""},
/* Bookmark6                */  {"",         "",         "%6",       ""          ,"",         "",         "",         ""},
/* Bookmark7                */  {"",         "",         "%7",       ""          ,"",         "",         "",         ""},
/* Bookmark8                */  {"",         "",         "%8",       ""          ,"",         "",         "",         ""},
/* Bookmark9                */  {"",         "",         "%9",       ""          ,"",         "",         "",         ""},
/* DropEpsMark              */  {"",         "",         "",         "%/"        ,"",         "",         "",         ""},
/* Find                     */  {"%{F3}",    "%{F3}",    "%{F3}",    "%{F3}"     ,"",         "",         "",         ""},
/* FindNext                 */  {"{F3}",     "{F3}",     "",         ""          ,"",         "",         "",         ""},
/* FindNextWord             */  {"^{F3}",    "^{F3}",    "",         ""          ,"",         "",         "",         ""},
/* FindPrev                 */  {"+{F3}",    "+{F3}",    "+{F3}",    "+{F3}"     ,"",         "",         "",         ""},
/* FindPrevWord             */  {"^+{F3}",   "^+{F3}",   "",         ""          ,"",         "",         "",         ""},
/* GoTo                     */  {"^G",       "^G",       "^G",       "(^X)(G)"   ,"",         "",         "",         ""},
/* GoToDef                  */  {"%{F1}",    "%{F1}",    "{F11}",    "(^X)(,)"   ,"{F11}",    "{F11}",    "",         "%{F1}"},
/* GoToTag                  */  {"",         "",         "",         ""          ,"",         "",         "",         ""},
/* GoToFile                 */  {"^+G",      "^+G",      "^+G",      "^+G"       ,"",         "",         "",         ""},
/* GoToRef                  */  {"%{F1}",    "%{F1}",    "%{F1}",    "%{F1}"     ,"+{F11}",   "+{F11}",   "+{F11}",   "+{F11}"},
/* MatchBrace               */  {"^]",       "^M",       "^]",       ""          ,"^+]",      "^+M",      "^M",       ""},
/* NextMark                 */  {"{F2}",      "{F2}",    "",         ""          ,"",         "",         "",         ""},
/* NextEpsMark              */  {"",          "",        "",         "%J"        ,"",         "",         "",         ""},
/* NextErrorTag             */  {"{F4}",      "{F4}",    "^N",       "(^X)(^N)"  ,"",         "",         "",         ""},
/* PreviousMark             */  {"+{F2}",     "+{F2}",   "",         ""          ,"",         "",         "",         ""},
/* PreviousTag              */  {"+{F4}",     "+{F4}",   "+{F4}",    "(^X)(^P)"  ,"",         "",         "",         "+{F4}"},
/* Replace                  */  {"",          "",        "",         ""          ,"",         "",         "",         ""},
/* ToggleMark               */  {"^{F2}",     "^{F2}",   "",         ""          ,"",         "",         "",         ""},
/* SearchTool               */  {"%A",        "%A",      "^f",       ""          ,"^f",       "^f",       "",         ""},
/* SelectCondDown           */  {"^+.",       "^+.",     "^+.",      ""          ,"",         "",         "",         ""},
/* SelectCondUp             */  {"^+,",       "^+,",     "^+,",      ""          ,"",         "",         "",         ""},
/* ToggleCase               */  {"",          "",        "^{F5}",    ""          ,"",         "",         "",         ""},
/* ToggleRE                 */  {"",          "",        "^{F6}",    ""          ,"",         "",         "",         ""},
/* ToggleSearchForWord      */  {"",          "",        "",         ""          ,"",         "",         "",         ""},
};


///////////////////////////////////////////////////////////////////////////////
//	Sniff test classes

#endif //__EMULCASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		GeorgeCh		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Src\macrcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      macrcase.CPP
//
//      Created by :                    Date :
//        Craigs                          7/17/96
//
//      Description :
//              Implementation of the CMacroTestCases class
//

#include "stdafx.h"
#include "macrcase.h"
#include "w32repl.h"
#include "support.h"
										 
#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;        

IMPLEMENT_TEST(CMacroTestCases, CTest, "Macro Tests", -1, EditorSniff)

void CMacroTestCases::Run(void)
{
  COClipboard ClipBoard;
	XSAFETY;
  UICustomizeTabDlg CstmzDlg ;

  CstmzDlg.ShowAddIn_MacroPg() ;
  CstmzDlg.BrowseForMacroFiles();
    
  MST.DoKeys(m_strCWD+"111__V36.vbs");
  Sleep(6000);
  MST.WButtonClick(GetLabel(IDOK)) ; 

  //Give VBS time to parse (more than enough)
  WaitForInputIdle(g_hTargetProc, 6000);

  MST.DoKeys("{TAB}");
  MST.DoKeys("{TAB}");
  MST.DoKeys("{TAB}");
  MST.DoKeys("{DOWN}");
  MST.DoKeys("111__V36");
  MST.DoKeys(" ");

  MST.DoKeys("{ESC}");   

  //Create a new file
  COSource sourc ;
  
  sourc.Create() ;
  //Add Some text to the file
  ClipBoard.Empty();
  MST.DoKeys("This is a test of the VBS system, this is only a test: (Beeeeeep)");
  MST.DoKeys("+{HOME}");
  MST.DoKeys("^c");  

  CString ClipText = ClipBoard.GetText();
  
  //Bring up the tools->macro dialog
  UIMacrosDlg macroDlg ;
  macroDlg.Display() ;
  macroDlg.SelectMacroFile("111_V36");
  macroDlg.SelectMacro("TestActive");
  ClipBoard.Empty();
  macroDlg.RunMacro() ;

   if (ClipText != ClipBoard.GetText())
  {
    m_pLog->RecordCriticalError("Expected and actual output do not match");
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		GeorgeCh		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Editor\Sniff\Src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ed_usa.rc
//
#define IDS_STRING1                     44001
#define IDS_STRING2                     44002
#define IDS_STRING3                     44003
#define IDS_STRING4                     44004
#define IDS_STRING5                     44005
#define IDS_STRING6                     44006
#define IDS_STRING7                     44007
#define IDS_STRING8                     44008
#define IDS_STRING9                     44009
#define IDS_STRING10                    44010
#define IDS_STRING11                    44011
#define IDS_STRING12                    44012
#define IDS_STRING13                    44013
#define IDS_STRING14                    44014
#define IDS_STRING15                    44015
#define IDS_STRING16                    44016
#define IDS_STRING17                    44017
#define IDS_STRING18                    44018
#define IDS_STRING19                    44019
#define IDS_STRING20                    44020
#define IDS_STRING21                    44021
#define IDS_STRING22                    44022
#define IDS_STRING23                    44023
#define IDS_STRING24                    44024
#define IDS_STRING25                    44025
#define IDS_STRING26                    44026
#define IDS_STRING27                    44027
#define IDS_STRING28                    44028
#define IDS_STRING29                    44029
#define IDS_STRING30                    44030
#define IDS_STRING31                    44031
#define IDS_STRING32                    44032
#define IDS_STRING33                    44033
#define IDS_STRING34                    44034
#define IDS_STRING35                    44035
#define IDS_STRING36                    44036
#define IDS_STRING37                    44037
#define IDS_STRING38                    44038
#define IDS_STRING39                    44039
#define IDS_STRING40                    44040
#define IDS_STRING41                    44041
#define IDS_STRING42                    44042
#define IDS_STRING43                    44043
#define IDS_STRING44                    44044
#define IDS_STRING45                    44045
#define IDS_STRING46                    44046
#define IDS_STRING47                    44047
#define IDS_STRING48                    44048
#define IDS_STRING49                    44049
#define IDS_STRING50                    44050
#define IDS_STRING51                    44051
#define IDS_STRING52                    44052
#define IDS_STRING53                    44053
#define IDS_STRING54                    44054
#define IDS_STRING55                    44055
#define IDS_STRING56                    44056
#define IDS_STRING57                    44057
#define IDS_STRING58                    44058
#define IDS_STRING59                    44059
#define IDS_STRING60                    44060
#define IDS_STRING61                    44061
#define IDS_STRING62                    44062
#define IDS_STRING63                    44063
#define IDS_STRING64                    44064
#define IDS_STRING65                    44065
#define IDS_STRING66                    44066
#define IDS_STRING67                    44067
#define IDS_STRING68                    44068
#define IDS_STRING69                    44069
#define IDS_STRING70                    44070
#define IDS_STRING71                    44071
#define IDS_STRING72                    44072
#define IDS_STRING73                    44073
#define IDS_STRING74                    44074
#define IDS_STRING75                    44075
#define IDS_STRING76                    44076
#define IDS_STRING77                    44077
#define IDS_STRING78                    44078
#define IDS_STRING79                    44079
#define IDS_STRING80                    44080
#define IDS_STRING81                    44081
#define IDS_STRING82                    44082
#define IDS_STRING83                    44083
#define IDS_STRING84                    44084
#define IDS_STRING85                    44085
#define IDS_STRING86                    44086
#define IDS_STRING87                    44087
#define IDS_STRING88                    44088
#define IDS_STRING89                    44089
#define IDS_STRING90                    44090
#define IDS_STRING91                    44091
#define IDS_STRING92                    44092
#define IDS_STRING93                    44093
#define IDS_STRING94                    44094
#define IDS_STRING95                    44095
#define IDS_STRING96                    44096
#define IDS_STRING97                    44097
#define IDS_STRING98                    44098
#define IDS_STRING99                    44099
#define IDS_STRING100                   44100
#define IDS_STRING101                   44101
#define IDS_STRING102                   44102
#define IDS_STRING103                   44103
#define IDS_STRING104                   44104
#define IDS_STRING105                   44105
#define IDS_STRING106                   44106
#define IDS_STRING107                   44107
#define IDS_STRING108                   44108
#define IDS_STRING109                   44109
#define IDS_STRING110                   44110
#define IDS_STRING111                   44111
#define IDS_STRING112                   44112
#define IDS_STRING113                   44113
#define IDS_STRING114                   44114
#define IDS_STRING115                   44115
#define IDS_STRING116                   44116
#define IDS_STRING117                   44117
#define IDS_STRING118                   44118
#define IDS_STRING119                   44119
#define IDS_STRING120                   44120
#define IDS_STRING121                   44121

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\datacase.cpp ===
//////////////////////////////////////////////////////////////////////////////
//	DATACASE.CPP
//
//	Created by :			Date :
//		ChrisKoz					2/01/96
//
//	Description :
//		Implementation of the CSrcDataCases class
//

#include "stdafx.h"
#include "syscase.h"
#include "datacase.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;



///////////////////////////////////////////////////////////////////////////////
//	CTablesTest class
IMPLEMENT_TEST(CTablesTest, CTest, "Table/View/Dgrm objects", -1, CDataSubSuite)

void CTablesTest::Run(void)
{
	CDataSubSuite *pSuite=GetSubSuite();
	pSuite->OpenDataProject();
	if(pSuite->ForcePassword(&pSuite->m_DataInfo)!=ERROR_SUCCESS)
	{
			GetLog()->RecordFailure("Coudn't find the DataSource - %s",
				GetSubSuite()->m_DataInfo.m_strDSN);
			throw CTestException("Cannot reopen the Datasource connection; unable to continue.", 
				CTestException::causeOperationFail);
	}
	// now we are at the DataSource Node let's examine the tables
	MST.DoKeys("{Right}"); //expand the tables of active datasource
	if (WaitForInputIdle(g_hTargetProc, 60000) == WAIT_TIMEOUT)
		GetLog()->RecordFailure("Coudn't deploy the tables");
	
	TestTableObjects();
	GetSubSuite()->m_prj.Close(TRUE); GetSubSuite()->m_projOpen=0;
} //CTablesTest::Run


void CTablesTest::TestTableObjects()
{
	CDataSubSuite *pSuite=GetSubSuite();
	CDataInfo *info=&pSuite->m_DataInfo;


    GetLog()->RecordInfo("Checking object of database: %s", info->GetName());

	UIWorkspaceWindow wnd;

	for(POSITION pos = info->m_listMembers.GetHeadPosition();
		pos!=NULL;info->m_listMembers.GetNext(pos))
	{
		CObjectInfo* pMember=info->m_listMembers.GetAt(pos);// has members.
		if(pMember->m_Type!=CObjectInfo::TABLE &&
				  pMember->m_Type!=CObjectInfo::VIEW &&
				  pMember->m_Type!=CObjectInfo::DIAGRAM)
			continue; //test only tables/diagrams
		char name[256];
		switch(pMember->m_Type)
		{
			case CObjectInfo::TABLE:
				pSuite->ExpandTableNode("");
				break;
			case CObjectInfo::VIEW:
				pSuite->ExpandViewNode("");
				break;
			case CObjectInfo::DIAGRAM:
				pSuite->ExpandDiagramsNode("");
				break;
			default:
				continue; // object type not supported
		} //switch
		strncpy(name,pMember->GetName(),255);
		MST.DoKeys(name);
		if(pSuite->CheckObjectProp(pMember)!=ERROR_ERROR)
		{
			char ob_typename[128];
			int ret;
			GetLog()->RecordSuccess("Found the %s name: '%s'",pMember->GetTypeName(),name);
			if(pMember->m_Type!=CObjectInfo::DIAGRAM)
			{	//tables & views open as queries
				strncpy(ob_typename,GetLocString(IDSS_QUERY),128);
				ret=OpenGridView(name,ob_typename,pMember->m_strParams); //open table or view
			}
			else if(pMember->m_Type==CObjectInfo::DIAGRAM)
			{
				strncpy(ob_typename,pMember->GetTypeName(),128);
				ret=OpenDiagView(name,ob_typename,pMember->m_strParams); //open diagram
			}
			LOG->RecordCompare(ret==ERROR_SUCCESS,
				"Openning the %s name: '%s'",ob_typename,name);
			wnd.Activate(); //returns to the project workspace
		}
//		pSuite->CollapseObjects((pMember->m_Type!=CObjectInfo::TRIGGER)?0:1); //not here
		pSuite->CollapseObjects(0);
	}	//for
	pSuite->CollapseObjects(1);	//final collapse of all objects
} //TestTableObjects


/////////////////////////////////////////////////////////////////////
// Opens the source window for the object type  TABLE or VIEW
// and checks the grup by query operations
// RETURNS: ERROR_SUCCESS if OK
////////////////////////////////////////////////////////////////////
int CTablesTest::OpenGridView(LPCSTR pszName,CString strType,CString &Params)
{
	COSource srcFile;
	int ret = ERROR_SUCCESS;
	CString Name=pszName;
	Name.MakeUpper();

	MST.DoKeys("{Enter}"); //for open, provided the lack of better handle
	for(int i=0;i<5;i++)
	{ //must do it five times because idling is done in intervals
		WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
		Sleep(1000);							// Wait for message box to arrive.
	}
	UIMessageBox wndMsgBox;
	if (wndMsgBox.AttachActive())			// If we can attach, then an error must've occurred.
	{
		CString str;
		MST.WGetText(HWND (wndMsgBox), str);
		LOG->RecordInfo("'%s' message box detected", str);
		if(MST.WStaticExists("Unable to open"))
			LOG->RecordInfo("Unable to open the object");
		wndMsgBox.ButtonClick();
		ret = ERROR_ERROR;
	}
	else									// A source window must've become active.
	{
		CString title=CString(pszName) +" : "+strType;	

		srcFile.AttachActiveEditor();
		HWND hwnd=UIWB.GetActiveEditor(); //don't know how to take the handler from COSource

		CString str;
		MST.WGetText(hwnd, str); //should be MDI window
		LOG->RecordCompare((str.Find(title) !=-1),
			"Find the source window for object: %s",pszName);
	}
	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for opening the query
	Sleep(1000); //safety (idle is usu hit when query is running
	WaitForInputIdle(g_hTargetProc, 5000); //safety	
	UIWB.DoCommand(IDM_QUERY_GROUPBYMENU, DC_MNEMONIC); //&Query.&Group By
	WaitForInputIdle(g_hTargetProc, 5000); //safety
	Sleep(500);
	UIWB.DoCommand(IDM_QUERY_VERIFYMENU, DC_MNEMONIC); // &Query.&Verify SQL Syntax
	Sleep(500);

	if(wndMsgBox.AttachActive())		
	{	// If we can attach, then a login error must've occurred.
		BOOL bResult=MST.WStaticExists(GetLocString(IDSS_SQLSYNTAX_OK));
		LOG->RecordCompare(bResult,"Verify GROUP BY query option");	
		wndMsgBox.ButtonClick(); //Get rid of the message
	}
	WaitForInputIdle(g_hTargetProc, 5000);
	UIWB.DoCommand(IDM_TOOLS_RUNMENU, DC_MENU); //&Tools.&Run
	WaitForInputIdle(g_hTargetProc, 5000);
//check message box & the result
	Sleep(5000); //let WinNT recover the memory
	srcFile.Close();
	Sleep(2000); //let WinNT recover the memory
	return ret;
} //CTablesTest::OpenGridView

/////////////////////////////////////////////////////////////////////
// Opens the source window for the object type  DIAGRAM
// and checks 
// Params - list of the tables to check
// RETURNS: ERROR_SUCCESS if OK
////////////////////////////////////////////////////////////////////
int LocalFindChildWindow(HWND WHandle,CString &ChildTitle);
int CTablesTest::OpenDiagView(LPCSTR pszName,CString strType,CString &Params)
{
	COSource srcFile;
	int ret = ERROR_SUCCESS;
	CString Name=pszName;
	Name.MakeUpper();

	MST.DoKeys("{Enter}"); //for open, provided the lack of better handle
	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
	Sleep(2000);							// Wait for message box to arrive.

	UIMessageBox wndMsgBox;
	if (wndMsgBox.AttachActive())			// If we can attach, then an error must've occurred.
	{
		CString str;
		MST.WGetText(HWND (wndMsgBox), str);
		LOG->RecordInfo("'%s' message box detected", str);
		if(MST.WStaticExists("Unable to open"))
			LOG->RecordInfo("Unable to open the object");
		wndMsgBox.ButtonClick();
		ret=ERROR_ERROR;
	}
	else									// A source window must've become active.
	{
		CString title=CString(pszName) +" : "+strType;	

		srcFile.AttachActiveEditor();
		HWND hwnd=UIWB.GetActiveEditor(); //don't know how to take the handler from COSource

		CString str;
		MST.WGetText(hwnd, str); //should be MDI window
		LOG->RecordCompare((str.Find(title) !=-1),
			"Find the source window for object: %s",pszName);
		int imod=0;
#if 0 //windows of type GridWndClass inside the diagram do not have titles anymore
//enable this tables inside diagram check when find better way to do that
		char szparam[512];
		strncpy(szparam,Params,512);
		str=strtok(szparam," ");
		while(str.IsEmpty()==0)
		{
			LOG->RecordInfo("...Searching for window '%s' in the diagram...",str);
			if(FindChildWindow(hwnd, str, "GridWnd")==NULL)
			{
				LOG->RecordFailure("Didn't find window '%s' in the diagram",str);
				break;
			}
/*
			BOOL temptest=(MST.WFndWndC(str.GetBufferSetLength(255),"GridWndClass",FW_ACTIVE)!=0);
			str.ReleaseBuffer(-1);
			LOG->RecordCompare(temptest==TRUE,"Find '%s' child",str);
*/
			str=strtok(NULL," ");
		}
#endif
		Sleep(10000); //let WinNT recover the memory
		srcFile.Close();
		Sleep(5000); //let WinNT recover the memory
	}
	return ret;
} //CTablesTest::OpenDiagView


int LocalFindChildWindow(HWND WHandle,CString &ChildTitle)
{
	char szFound[80];
	HWND childhwnd;
	for(int i=0;i<5;i++)
	{	int nbsiblings=0;
		childhwnd=::GetWindow(WHandle,GW_CHILD);		
		childhwnd=::GetWindow(childhwnd,GW_CHILD);		
		childhwnd=::GetWindow(childhwnd,GW_CHILD);		
		childhwnd=::GetWindow(childhwnd,GW_CHILD);		
		while(childhwnd!=NULL)
		{
			::GetWindowText(childhwnd, szFound, 80);
			TRACE("--%d:child no:%d--:Found the Diagram child: %s\n",i,++nbsiblings,szFound);
			if(szFound[0]!=0 && ChildTitle.Find(szFound)==0)	
			{
				return ERROR_SUCCESS;
			}
			childhwnd=::GetWindow(childhwnd,GW_HWNDNEXT);
		}
		Sleep(1000);
	}
	return ERROR_ERROR;
}  //FindChildWindow
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\datacase.h ===
///////////////////////////////////////////////////////////////////////////////
//	DATACASE.H
//
//	Created by :			Date :
//		ChrisKoz					2/02/96
//
//	Description :
//		Declaration of classes for DataPane Verification
//

#ifndef __DATACASE_H__
#define __DATACASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"



///////////////////////////////////////////////////////////////////////////////
//	CDataCases class
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// CTablesTest: Check Pubs DB tables on the SQL server

class CTablesTest: public CTest
{
	DECLARE_TEST(CTablesTest, CDataSubSuite)

public:
	virtual void Run(void);

	void TestTableObjects();
	int OpenGridView(LPCSTR pszName,CString strType,CString &Params);
	int OpenDiagView(LPCSTR pszName,CString strType,CString &Params);
};



#endif //__DATACASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\davcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	DAVCASES.H
//
//	Created by :			Date :
//              ChrisKoz                                  9/9/97
//
//	Description :
//		Declaration of the Davinci Designers tools test cases
//

#ifndef __DAVCASES_H__
#define __DAVCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CDavinciTest

class CDavinciTest: public CTest
{
	DECLARE_TEST(CDavinciTest, CDataSubSuite)

public:
	virtual void Run(void);
	virtual	BOOL RunAsDependent(void);

	void DataBaseDesignerTest(LPCSTR szTable);
	void ViewDesignerTest(LPCSTR szTable,int nrows,BOOL bIsView);
//	void QueryDesignerTest(LPCSTR szTable,int nrows);

//utility functions
private:
	LPCSTR GetDavinciPathFromReg(void);
};



#endif // DAVCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\davcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      DAVCASE.CPP
//
//      Created by :                    Date :
//              ChrisKoz                                  9/9/97
//
//      Description :
//              Implementation of the Davinci Designers tools test cases
//

#include "stdafx.h"
#include <io.h>
#include "davcase.h"
#include "sniff.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


/////////////////////////////////////////////////////////////////////////////////
//TESTHOOK.DLL entry points
/*extern "C"*/ typedef LRESULT (APIENTRY* PInitializeTestHook)(HWND hwndTarget, ULONG ulSize);
extern "C" typedef LRESULT (APIENTRY* PSendMessageTestHook)(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern "C" typedef LRESULT (APIENTRY* PUninitializeTestHook)(HWND hwndTarget);
extern "C" typedef LRESULT (APIENTRY* PSendGridMessageTestHook)(HWND hwndView, HWND hwndGrid,UINT uMsg, WPARAM wParam, LPARAM lParam);
//extern "C" typedef LRESULT (APIENTRY* PFormatResourceString)(PCH paszResult, const UINT cchResultMax, PCH paszFormat, 
//										VARIANT *pvarArg1, VARIANT *pvarArg2, VARIANT *pvarArg3, VARIANT *pvarArg4, VARIANT *pvarArg5);
//extern "C" typedef LRESULT (APIENTRY* PReplaceText)(PCH szFilename, PCH szReplacement, LONG lLeft, LONG lTop, LONG lRight, LONG lBottom);
//extern "C" typedef LRESULT (APIENTRY* PSystem)(PCH szCommand);
extern "C" typedef LRESULT (APIENTRY* PGetGridChecksum)(HWND hwndView, HWND hwndGrid, USHORT *pwChecksum);


PInitializeTestHook InitializeTestHook;
PSendMessageTestHook SendMessageTestHook;
PUninitializeTestHook UninitializeTestHook;
PSendGridMessageTestHook SendGridMessageTestHook;
PGetGridChecksum GetGridChecksum;

static char strCLSID[40]; //CLSID for the data designer window  //{E9B0E6D4-811C-11D0-AD51-00A0C90F5739}
static char queryCLSID[40]; //CLSID for the query designer window

///////////////////////////////////////////////////////////////////////////////
//	CDavinciTest class

IMPLEMENT_TEST(CDavinciTest, CTest, NULL, -1, CDataSubSuite)

BOOL CDavinciTest::RunAsDependent(void)
{
		return FALSE; //never run because it confuses
}

/////////////////////////////////////////////////////////////
//utility function(s)
//TODO(chriskoz) - change the COSource to the new class which would represent database 
// diagrams - Tables, Views, Queries
//returns !=NULL - if you can attach to the active editor & it's caption is valid
//		  ==NULL - cannot attach to the active editor
HWND AddNewDataItem(CString &strDataBase,CString &strDataItem,COSource &SrcFile)
{
    LOG->RecordInfo("Adding new %s to the project", strDataItem);
	MST.DoKeys("%ID"); // "&Insert" "New &Database Item..." UIWB.DoCommand(IDM_INSERT_DATAOBJECT, DC_MNEMONIC);
	if(!MST.WFndWnd("Insert Database Item"/*GetLocString()*/, FW_PART))
	{
		LOG->RecordInfo("Couldn't find Insert Database Item dialog");
		return 0;
	}
	MST.WComboItemClk(GetLabel(/*TODO(chriskoz)*/0x410),strDataBase);
	MST.WListItemClk(GetLabel(/*TODO(chriskoz)*/0x40c),strDataItem);
	MST.WButtonClick(GetLabel(IDOK)) ;
	WaitForInputIdle(g_hTargetProc, 10000);	// Wait for Davinci components to be loaded.
	SrcFile.AttachActiveEditor();
	HWND hwnd=UIWB.GetActiveEditor(); //don't know how to take the handler from COSource
	CString str;
	MST.WGetText(hwnd, str); //should be text window
	if(str.Find(strDataItem)<0) // the active editor title wrong
	{
		if(strDataItem == "Local Query")
		{//damn string is "Local Query" in the listbox while "Query" in document tilte
			if(str.Find(GetLocString(IDSS_QUERY))<0)
				hwnd=NULL;
		}
		else
			hwnd=NULL;
	}
	return hwnd;
} //AddNewDataItem



LPCSTR CDavinciTest::GetDavinciPathFromReg()
{
//poke into registry to retreive the Davinci CLSID & path of the Davinci components
	static char szPath[MAX_PATH]; //REVIEW: MAX_PATH is always > 40 ??
	DWORD size;
	DWORD type = REG_SZ;
	HKEY hSubKey;
//take the Query Designer key
	LONG lResult = RegOpenKeyEx( HKEY_CLASSES_ROOT, "MSDTQueryDesigner2\\Clsid", 0, 
					KEY_QUERY_VALUE, &hSubKey );
	if(lResult != ERROR_SUCCESS)
	{
		LOG->RecordFailure("Query Designer Registry operation failed: %d", lResult);
		return NULL;
	}
	size = MAX_PATH;
	lResult = RegQueryValueEx( hSubKey, NULL /*??Default*/, NULL, 
					&type, (LPBYTE)szPath, &size);  
	RegCloseKey( hSubKey );
	if(lResult != ERROR_SUCCESS)
	{
		LOG->RecordFailure("Query Designer Registry operation failed: %d", lResult);
		return NULL;
	}
	strncpy(queryCLSID, szPath, 40);
//take the Data Designer key
	lResult = RegOpenKeyEx( HKEY_CLASSES_ROOT, "MSDTDatabaseDesigner2\\Clsid", 0, 
					KEY_QUERY_VALUE, &hSubKey );
	if(lResult != ERROR_SUCCESS)
	{
		LOG->RecordFailure("DataBase Designer Registry operation failed: %d", lResult);
		return NULL;
	}
	size = MAX_PATH;
	lResult = RegQueryValueEx( hSubKey, NULL /*??Default*/, NULL, 
					&type, (LPBYTE)szPath, &size);  
	RegCloseKey( hSubKey );
	if(lResult != ERROR_SUCCESS)
	{
		LOG->RecordFailure("DataBase Designer Registry operation failed: %d", lResult);
		return NULL;
	}
	strncpy(strCLSID, szPath, 40);
//take the path from InProc server of DataBase Designer key
	strcat(strcat(strcpy(szPath,"CLSID\\"), strCLSID), "\\InprocServer32");
	lResult = RegOpenKeyEx( HKEY_CLASSES_ROOT, szPath, 0, 
					KEY_QUERY_VALUE, &hSubKey );
	if(lResult != ERROR_SUCCESS)
	{
		LOG->RecordFailure("DataBase Designer path from Registry failed: %d", lResult);
		return NULL;
	}
	size = MAX_PATH;
	lResult = RegQueryValueEx( hSubKey /*HKEY_CLASSES_ROOT*/, NULL /*??Default*/, NULL, 
					&type, (LPBYTE)szPath, &size);
	RegCloseKey( hSubKey );
	if(lResult != ERROR_SUCCESS)
	{
		LOG->RecordFailure("DataBase Designer path from Registry failed: %d", lResult);
		return NULL;
	}
	_strupr(szPath); //We'd better use uppercase
	char *filename=strrchr(szPath, '\\');
	if(strstr(szPath, ".DLL") !=NULL)
	{
		*filename = 0; //get rid of filename
	}
	return szPath;
}//end of registry operations	


#include <AFXDISP.H>

void CDavinciTest::Run(void)
{
	LPCSTR pdav_path=GetDavinciPathFromReg();
	if(pdav_path == NULL)
	{
		LOG->RecordFailure("Failed to retrieve MsDesigners components. Are they registered?");
		return;
	}
	CDataSubSuite *pSuite=GetSubSuite();
	pSuite->OpenDataProject();
	if(pSuite->ForcePassword(&pSuite->m_DataInfo)!=ERROR_SUCCESS)
	{
			GetLog()->RecordFailure("Coudn't find the DataSource - %s",
				GetSubSuite()->m_DataInfo.m_strDSN);
			throw CTestException("Cannot reopen the Datasource connection; unable to continue.", 
				CTestException::causeOperationFail);
	}
	// now we are at the DataSource Node let's examine the tables
	MST.DoKeys("{Right}"); //expand the tables of active datasource
	if (WaitForInputIdle(g_hTargetProc, 60000) == WAIT_TIMEOUT)
		LOG->RecordFailure("Coudn't deploy the tables");
	
	CString strTable = pSuite->m_SuiteParams->GetTextValue("DESIGNTABLE", "sales");
	int nrows = pSuite->CleanAndInsertTable(strTable);	//here m_ComputerName is established

	HINSTANCE hTestHookDLL = NULL;
	if(!SetCurrentDirectory(pdav_path) )  //TODO how to determine the location?
	{
		LOG->RecordFailure("SetCurrentDirectory failed");
		return;
	}
	CoInitialize(NULL);
	hTestHookDLL = ::LoadLibrary(m_strCWD + "TESTHOOK.DLL");
	if (hTestHookDLL == NULL) 
	{
		LOG->RecordFailure("Unable to load TESTHOOK library. GetLastError: %d", GetLastError());
		CoUninitialize();
		return;
	}
	if(!SetCurrentDirectory(m_strCWD) )
	{
		LOG->RecordFailure("SetCurrentDirectory back to CWD failed");
		::FreeLibrary(hTestHookDLL);
		CoUninitialize();
		return;
	}
	InitializeTestHook = (PInitializeTestHook)::GetProcAddress(hTestHookDLL, "LrInitializeTestHook");
	SendMessageTestHook = (PSendMessageTestHook)::GetProcAddress(hTestHookDLL, "LrSendMessageTestHook");
	UninitializeTestHook = (PUninitializeTestHook)::GetProcAddress(hTestHookDLL, "LrUninitializeTestHook");
	SendGridMessageTestHook = (PSendGridMessageTestHook)::GetProcAddress(hTestHookDLL, "LrSendGridMessageTestHook");
	GetGridChecksum = (PGetGridChecksum)::GetProcAddress(hTestHookDLL, "LrGetGridChecksum");
	if(!InitializeTestHook || !SendMessageTestHook || !UninitializeTestHook || !SendGridMessageTestHook || !GetGridChecksum)
	{
		LOG->RecordFailure("Unable to find TESTHOOK entry points");
		::FreeLibrary(hTestHookDLL);
		CoUninitialize();
		return;
	}

	DataBaseDesignerTest(strTable+pSuite->m_Computername); //table name is appended by computer name for uniqueness
//	/*Query*/ViewDesignerTest(strTable+pSuite->m_Computername,nrows,FALSE);
	ViewDesignerTest(strTable+pSuite->m_Computername,nrows,TRUE);
	/*Query*/ViewDesignerTest(strTable+pSuite->m_Computername,nrows,FALSE);


	::FreeLibrary(hTestHookDLL);
	CoUninitialize();
	//close all windows & collapse the data pane
	MST.DoKeys("%Wo"); //UIWB.DoCommand(ID_FILE_WINDOWS_CLOSEALL, DC_MNEMONIC); //save it

	UIWorkspaceWindow wnd;
	wnd.ActivateDataPane();
	pSuite->CollapseObjects(-1); //collapse the whole tree
	pSuite->m_prj.Close(TRUE); pSuite->m_projOpen=0;
} //CDavinciTest::Run()


#include "davinc\grid.h"
#include "davinc\testhook.h"
void CDavinciTest::DataBaseDesignerTest(LPCSTR szTable)
{
	CDataSubSuite *pSuite=GetSubSuite();
	CString strComboitem = CString(PROJNAME) + ": " + 
		pSuite->m_DataInfo.m_strDataBase + 
		" (" + pSuite->m_DataInfo.m_strServer + ")";
	COSource diagramDoc;
	HWND hwnd; //have to have diagramDoc separately, because of ESD of COSource class
	if( (hwnd=AddNewDataItem(strComboitem, GetLocString(IDSS_DIAGRAM), diagramDoc)) !=NULL )
	{
		pSuite->ForcePassword(&pSuite->m_DataInfo); //new collapse
		MST.DoKeys("{Right}"); //expand the tables of active datasource
		pSuite->ExpandTableNode("");
		MST.DoKeys(szTable);
		CObjectInfo member;
		member.m_strName=szTable;
		member.m_Type = CObjectInfo::TABLE;
		member.m_strOwner = "dbo"; //TODO the current user is the owner
		if(pSuite->CheckObjectProp(&member)!=ERROR_ERROR)
		{
			UIWB.DoCommand(ID_EDIT_COPY, DC_ACCEL);	// REVIEW: is there a better way? (D&D does not work in CAFE)
			Sleep(1000); //safety

			//REVIEW(chriskoz) bad thing but I have no better idea how to set focus 			
			//diagramDoc.Activate(); does not exist
			RECT rcPage;
			GetClientRect(hwnd, &rcPage);
			ClickMouse( VK_LBUTTON ,hwnd, (rcPage.left + rcPage.right)/2, 
				(rcPage.top+rcPage.bottom)/2);	  // Click on the window
			MST.WFndWndWait(GetLocString(IDSS_DIAGRAM), FW_FOCUS | FW_PART, 2);
			UIWB.DoCommand(ID_EDIT_PASTE, DC_MNEMONIC); // (DC_ACCEL)Ctrl-V does not work in IDE;	// REVIEW: is there a better way? (D&D does not work in CAFE)
			//diagramDoc.Paste(); //bogus, just calling DoCommand(ID_EDIT_PASTE) I have to make new class more robust 			
			Sleep(2000);
			WaitForInputIdle(g_hTargetProc, 10000);
			MST.DoKeys("%VbP"); //"&View" "Ta&ble" "&Pporerties" //change the table display to the grid	UIWB.DoCommand(IDM_VIEW_TABLEPROP, DC_MNEMONIC);
			Sleep(1000);
			WaitForInputIdle(g_hTargetProc, 10000);
		}
		else
		{
			LOG->RecordFailure("%s table not found in the database", szTable);
			return;
		}

		HWND hschema=MST.WFndWndC(strCLSID, "MSPaneWindow", FW_DEFAULT);
		ASSERT(hschema);
		LRESULT res = InitializeTestHook(hschema, 8192);
		ASSERT(res == S_OK);
		//......
		char szTables[256];
		res = SendMessageTestHook(hschema, WM_ListTables, sizeof(szTables)/sizeof(char), (LPARAM)szTables);
		ASSERT(res == S_OK);
		LOG->RecordCompare(strstr(szTables,szTable)!=NULL, "Find the table %s in the diagram", szTable);
//		ObjectLocation Location;
//		res = SendMessageTestHook(hschema, WM_TableLocation, (WPARAM)&Location, (LPARAM)szTable);
		HWND hgrid = (HWND)SendMessageTestHook(hschema, WM_HwndGridOfFieldList, 0, (LPARAM)szTable);  //grid changes as you change the properties
		ASSERT(hgrid);

		GCLS sGCLS;
		char buff[256];
		sGCLS.cbBuf = sizeof(buff)/sizeof(char)-1;
		sGCLS.lpb = (BYTE*)buff;		

		res = SendGridMessageTestHook(hschema, hgrid, G_GETORG, 0, (LPARAM)&sGCLS );
		ASSERT(res==S_OK && sGCLS.irow == 1 && sGCLS.icol == 1);

		MST.DoKeys("{Enter}"); Sleep(500); //set the edit focus on a first cell
		res = SendGridMessageTestHook(hschema, hgrid, G_GETFOCUS, 0, (LPARAM)&sGCLS );
		ASSERT(res==S_OK && sGCLS.irow == 1 && sGCLS.icol == 1);
		sGCLS.icol = 1; //col in grid displaying the column name
		for(sGCLS.irow = 1; sGCLS.irow<256; sGCLS.irow++) //256 is the safety number
		{
			buff[0]=0;
			res = SendGridMessageTestHook(hschema, hgrid, G_GETDATA, 0, (LPARAM)&sGCLS );
			ASSERT(res==S_OK && sGCLS.lpb == (BYTE*)buff && sGCLS.cbBuf == sizeof(buff)/sizeof(char)-1);
			if(strlen(buff) == 0)
			{ // sGCLS.irow holds number of rows+1
				break;
			}
			MST.DoKeys("{DOWN}"); //set the edit focus on a next row
		}
		 ASSERT(sGCLS.irow<256);
		// sGCLS.irow shows the first empty row - place to describe the new table column
		DWORD nextrow=sGCLS.irow;
		res = SendGridMessageTestHook(hschema, hgrid, G_GETFOCUS, 0, (LPARAM)&sGCLS );
		ASSERT(res == S_OK && sGCLS.irow == nextrow && sGCLS.icol == 1);

//		res = SendGridMessageTestHook(hschema, hgrid, G_SETFOCUS, 0, (LPARAM)&sGCLS );
//		ASSERT(res == S_OK);
//this one hangs CAFE(?)  		res = SendGridMessageTestHook(hschema, hgrid, G_BEGINEDIT, 0, (LPARAM)&sGCLS );


#ifdef __CHRISKOZ___
//set the text by mean of Davinci hooks
		strcpy(buff, "new_chardefault");
  		res = SendGridMessageTestHook(hschema, hgrid, G_SETDATA, 0, (LPARAM)&sGCLS );
		ASSERT(res==S_OK && sGCLS.lpb == (BYTE*)buff && sGCLS.cbBuf == sizeof(buff)/sizeof(char)-1);
		
  		res = SendGridMessageTestHook(hschema, hgrid, G_UPDATE, 0, (LPARAM)&sGCLS );
		ASSERT(res==S_OK && sGCLS.lpb == (BYTE*)buff && sGCLS.cbBuf == sizeof(buff)/sizeof(char)-1);
#else
//set the text by mean of typing
		MST.DoKeys("new_chardefault");
		MST.DoKeys("{Enter}");	
#endif
		// sGCLS shld still point to the cell I typed text into
		buff[0]=0;
		res = SendGridMessageTestHook(hschema, hgrid, G_GETDATA, 0, (LPARAM)&sGCLS );
		ASSERT(res==S_OK && sGCLS.lpb == (BYTE*)buff && sGCLS.cbBuf == sizeof(buff)/sizeof(char)-1);
		LOG->RecordCompare(strcmp(buff,"new_chardefault")==0,"Added new column to the table %s",szTable);
		
		buff[0]=0;sGCLS.icol = 2; //the next cell describes the type
		res = SendGridMessageTestHook(hschema, hgrid, G_GETDATA, 0, (LPARAM)&sGCLS );
		ASSERT(res==S_OK && sGCLS.lpb == (BYTE*)buff && sGCLS.cbBuf == sizeof(buff)/sizeof(char)-1);
		LOG->RecordCompare(strcmp(buff,"char")==0, "Default column type 'char' displayed");
		res = UninitializeTestHook(hschema);
		ASSERT(res==S_OK);

//TODO make the real Save method out of source diagram class
		MST.DoKeys("%FS"); //&File.&Save
		UIMessageBox wndMsgSaveAs;
		LOG->RecordCompare(wndMsgSaveAs.AttachActive(), "Save as diagram dialog");
		// wndMsgSaveAs.AttachActive() TODO: title shld be "Save As"
		CString strDiagram = CString(szTable) + " diagram";
		MST.WEditSetText(GetLabel(0x1e24), strDiagram);
		wndMsgSaveAs.ButtonClick(IDOK);
		Sleep(1000);
		WaitForInputIdle(g_hTargetProc, 10000);

		MST.DoKeys("%FC"); //TODO Close method for entire diagram
		WaitForInputIdle(g_hTargetProc, 10000);

		pSuite->ForcePassword(&pSuite->m_DataInfo); //new collapse
		MST.DoKeys("{Right}"); //expand the tables of active datasource
		WaitForInputIdle(g_hTargetProc, 10000);
//check the column "new_chardefault" is in the table "sales1" in data pane
		pSuite->ExpandTable(szTable);
		LOG->RecordCompare(pSuite->CheckObjectProp(&member)!=ERROR_ERROR,"Find table %s", szTable);
		MST.DoKeys("new_chardefault", TRUE);Sleep(500);
		member.m_strName="new_chardefault";
		member.m_Type = CObjectInfo::TABLE; //TODO: bogus, column type is not added yet
		member.m_strOwner = "dbo";
		LOG->RecordCompare(pSuite->CheckObjectProp(&member)!=ERROR_ERROR, "Find the column: %s","new_chardefault");

		pSuite->CollapseObjects(1);

		
//check the diagram in the diagram folder
		pSuite->ExpandDiagramsNode("");
		MST.DoKeys(strDiagram);
		member.m_strName=strDiagram;
		member.m_Type = CObjectInfo::DIAGRAM;
		member.m_strOwner = "dbo"; //TODO owner shld be the current user
		LOG->RecordCompare(pSuite->CheckObjectProp(&member)!=ERROR_ERROR, "'%s' diagram found in data pane",strDiagram);
		
	}
	else
	{
		LOG->RecordFailure("Didn't add new diagram");
	}
}



void CDavinciTest::ViewDesignerTest(LPCSTR szTable,int nrows,BOOL bIsView)
{
	CDataSubSuite *pSuite=GetSubSuite();
	CString strComboitem = CString(PROJNAME) + ": " + 
		pSuite->m_DataInfo.m_strDataBase + 
		" (" + pSuite->m_DataInfo.m_strServer + ")";
	COSource viewDoc;
	HWND hwnd; //have to have viewDoc separately, because of ESD of COSource class
	if( (hwnd=AddNewDataItem(strComboitem, 
		bIsView?GetLocString(IDSS_VIEW):CString("Local Query") /*GetLocString(IDSS_QUERY)*/,
		viewDoc)) !=NULL )
	{
//in addition, we need the Query Diagram Pane
		HWND hdiagram=MST.WFndWndC("Query Diagram Pane", "Desktop", FW_DEFAULT);
		ASSERT(hdiagram);

		pSuite->ForcePassword(&pSuite->m_DataInfo); //new collapse
		MST.DoKeys("{Right}"); //expand the tables of active datasource
		pSuite->ExpandTableNode("");
		MST.DoKeys(szTable);
		CObjectInfo member;
		member.m_strName=szTable;
		member.m_Type = CObjectInfo::TABLE;
		member.m_strOwner = "dbo"; //TODO the current user
		if(pSuite->CheckObjectProp(&member)!=ERROR_ERROR)
		{
			UIWB.DoCommand(ID_EDIT_COPY, DC_ACCEL);	// REVIEW: is there a better way? (D&D does not work in CAFE)
			Sleep(1000); //safety

			//REVIEW(chriskoz) bad thing but I have no better idea how to set focus 			
			//diagramDoc.Activate(); does not exist
			RECT rcPage;
			GetClientRect(hdiagram, &rcPage); //must click on a diagram pane
			ClickMouse( VK_LBUTTON ,hdiagram, (rcPage.left + rcPage.right)/2, 
				(rcPage.top+rcPage.bottom)/2);	  // Click on the window //TODO: find better way to set the correct focus
			MST.WFndWndWait(GetLocString(IDSS_DIAGRAM), FW_FOCUS | FW_PART, 2); //TODO: what did I mean here in Diagram procedure?????
			UIWB.DoCommand(ID_EDIT_PASTE, DC_MNEMONIC); // (DC_ACCEL)Ctrl-V does not work in IDE;	// REVIEW: is there a better way? (D&D does not work in CAFE)
			//viewDoc.Paste(); //bogus, just calling DoCommand(ID_EDIT_PASTE) I have to make new class more robust 			
			Sleep(2000);
			WaitForInputIdle(g_hTargetProc, 10000);
			//TODO  obsolete in Query design MST.DoKeys("%VbP"); //"&View" "Ta&ble" "&Pporerties" //change the table display to the grid	UIWB.DoCommand(IDM_VIEW_TABLEPROP, DC_MNEMONIC);
			Sleep(1000);
			WaitForInputIdle(g_hTargetProc, 10000);
		}
		else
		{
			LOG->RecordFailure("%s table not found in the database", szTable);
			return;
		}


//select all columns
		MST.DoKeys("{Home}");Sleep(500);
		MST.DoKeys(" "); //space selects the current column
		HWND hschema=MST.WFndWndC(queryCLSID, "MSPaneWindow", FW_DEFAULT);
		ASSERT(hschema);
		HWND hResults=::GetWindow(hschema,GW_CHILD);		
		hResults =::GetWindow(hResults,GW_HWNDNEXT);
		hResults =::GetWindow(hResults,GW_HWNDNEXT); //REVIEW(chriskoz): AdamU sais result pane is always the third sibling
		LRESULT res = InitializeTestHook(hschema, 8192);
		ASSERT(res == S_OK);

if(!bIsView)
{	//add groupping & verifyibg SQL syntax for query
	UIWB.DoCommand(IDM_QUERY_GROUPBYMENU, DC_MNEMONIC); //&Query.&Group By
	WaitForInputIdle(g_hTargetProc, 5000); //safety
	Sleep(500);
	UIWB.DoCommand(IDM_QUERY_VERIFYMENU, DC_MNEMONIC); // &Query.&Verify SQL Syntax
	Sleep(500);
	UIMessageBox wndMsgBox;
	if(wndMsgBox.AttachActive())		
	{
		BOOL bResult=MST.WStaticExists(GetLocString(IDSS_SQLSYNTAX_OK));
		LOG->RecordCompare(bResult,"Verify GROUP BY query option");	
		wndMsgBox.ButtonClick(); //Get rid of the message
	}
	WaitForInputIdle(g_hTargetProc, 5000);
	//REVIEW(chriskoz) : I don't do it for View, because no menu entries are accessible (bug!)
}

	LOG->RecordInfo("Running the Query...");
	UIWB.DoCommand(IDM_TOOLS_RUNMENU, DC_MENU); //&Tools.&Run
//TODO: how to wait until execution is done?
	Sleep(2000); //temporary
	WaitForInputIdle(g_hTargetProc, 5000); //temporary

//verify the table displays the coret column
/*query*/		UINT tablesID[10];
/*query*/		ANSIDiagramTableInfo TableInfo;
/*query*/		res = SendMessageTestHook(hschema, WM_DiagramEnumTables, 10, (LPARAM)tablesID);
				ASSERT(res == 1);  //one table only
/*query*/		res = SendMessageTestHook(hschema, WM_DiagramTableInfo, tablesID[0], (LPARAM)&TableInfo); //sales1 must be only one table
				ASSERT(res == S_OK);
		LOG->RecordCompare(strcmp(TableInfo.strName,szTable)==0,"Add table %s to the query",szTable);
		
		UINT columnID[10];
		res = SendMessageTestHook(hschema, WM_DiagramEnumTableColumns, tablesID[0], (LPARAM)columnID);
		LOG->RecordCompare(res==TableInfo.cColumns,"Correct number of columns displayed by grid");
 
		ANSIDiagramColumnInfo ColumnInfo;
		for(int iColumn=0; iColumn < TableInfo.cColumns; iColumn++)
		{
			res = SendMessageTestHook(hschema, WM_DiagramTableColumnInfo, columnID[iColumn], (LPARAM)&ColumnInfo);
			ASSERT(res == S_OK);
			//check the column name and if only 0-column is checked
			if(iColumn == 0)
			{
				LOG->RecordCompare(strchr(ColumnInfo.strName, '*')!=NULL, "First column must be '*'"); 
				if(bIsView)
					LOG->RecordCompare(ColumnInfo.lStateClick == 2, "First column selected");
			}
			else
			{
				LOG->RecordCompare(ColumnInfo.lStateClick == 1, "Column #%d not selected", iColumn);
				if(bIsView)
				{ //TODO compare the panes with the columns in result pane
					GCLS sGCLS;
					char buff[256];
					sGCLS.cbBuf = sizeof(buff)/sizeof(char)-1;
					sGCLS.lpb = (BYTE*)buff;		
					sGCLS.irow = 0;  sGCLS.icol = iColumn;
					res = SendGridMessageTestHook(hschema, hResults, G_GETDATA, 0, (LPARAM)&sGCLS );
					ASSERT(res==S_OK);
					LOG->RecordCompare(strcmp(buff,ColumnInfo.strName)==0, "Match colname. Design pane: '%s', result pane: '%s'", ColumnInfo.strName, buff);
				}
			}

		} //for
		//the last column must be the one entered before
		LOG->RecordCompare(strcmp(ColumnInfo.strName,"new_chardefault")==0,"Match the last colname entered 'new_chardefault'");



		if(bIsView)
		{ //verify thet nrows were displayed in the grid by view
			GCLS sGCLS;
			char buff[256];
			sGCLS.cbBuf = sizeof(buff)/sizeof(char)-1;
			sGCLS.lpb = (BYTE*)buff;
			//GROWS dummygrows;
			//memset(&dummygrows, 0, sizeof(dummygrows) );
			//res = SendGridMessageTestHook(hschema, hResults, GCL_GETNUMROWS, 0, (LPARAM)&dummygrows ); //does not work: returns 80004005
			//LOG->RecordInfo("Number of rows: %d",res);
			for( sGCLS.irow = 1,  sGCLS.icol = 1; sGCLS.irow <256 /*safety*/; sGCLS.irow++)
			{				
				res = SendGridMessageTestHook(hschema, hResults, G_SETORG, 0, (LPARAM)&sGCLS ); //maybe it forces the grid to update the rest of rows?
				ASSERT(res==S_OK);
				Sleep(500); //Is there better way to make sure we update all?
				//res = SendGridMessageTestHook(hschema, hResults, G_UPDATE, 0, 0 ); //hangs CAFE (likely because it waits for SETORG to finish & deadlocks
				//ASSERT(res==S_OK);
				res = SendGridMessageTestHook(hschema, hResults, G_GETDATA, 0, (LPARAM)&sGCLS );
				ASSERT(res==S_OK);
				if(buff[0]==0)
					break;
			}
			LOG->RecordCompare(--sGCLS.irow == (UINT)nrows,"Number of rows as in SQL script");
		}
		else
		{//verify that number of nrows is displayed by Query
			GCLS sGCLS;
			char buff[256];
			sGCLS.cbBuf = sizeof(buff)/sizeof(char)-1;
			sGCLS.lpb = (BYTE*)buff;		
			sGCLS.irow = 1;  sGCLS.icol = 1;
			res = SendGridMessageTestHook(hschema, hResults, G_GETDATA, 0, (LPARAM)&sGCLS );
			ASSERT(res==S_OK);
			LOG->RecordCompare(atoi(buff)==nrows,"Number of rows as in SQL script");
		}
		
		res = UninitializeTestHook(hschema);
		ASSERT(res==S_OK);

//TODO make the real Save method out of source diagram class
		MST.DoKeys("%FS"); //&File.&Save
		UIMessageBox wndMsgSaveAs;
		LOG->RecordCompare(wndMsgSaveAs.AttachActive(), "Save As");
		// wndMsgSaveAs.AttachActive() TODO: title shld be "Save As"
		CString strViewQueryname;
if(bIsView)
{
		strViewQueryname =  CString(szTable) +" view";
		MST.WEditSetText(GetLabel(0x1e24),strViewQueryname);
}
else
{
		strViewQueryname =  CString(szTable) +" query";
#pragma message(__LOC__ "get rid of the full path here when the bug is fixed")
		MST.WEditSetText(GetLabel(0x480),m_strCWD + PROJDIR + strViewQueryname); //different save as dialog (it saves into the workspace)
}
		wndMsgSaveAs.ButtonClick(IDOK);
		Sleep(1000);
		WaitForInputIdle(g_hTargetProc, 10000);

		MST.DoKeys("%FC"); //TODO Close method for entire diagram/view/query
		WaitForInputIdle(g_hTargetProc, 10000);
		if(bIsView)
		{ //check the "sales1 view" is in the workspace
		pSuite->ForcePassword(&pSuite->m_DataInfo); //new collapse
		MST.DoKeys("{Right}"); //expand the tables of active datasource
		WaitForInputIdle(g_hTargetProc, 10000);

		pSuite->ExpandViewNode("");
		MST.DoKeys(strViewQueryname);
		member.m_strName=strViewQueryname;
		member.m_Type = CObjectInfo::VIEW;
		member.m_strOwner = "dbo"; //TODO owner is current user
		LOG->RecordCompare(pSuite->CheckObjectProp(&member)!=ERROR_ERROR, "'%s' view found in data pane",strViewQueryname);
		}
		else
		{	//check "sales1 query" is in file view
			UIWorkspaceWindow wnd;
			wnd.ActivateBuildPane(); //haha, what a name!!! Query has nothing to do with build
			MST.DoKeys("{DOWN}{HOME}");
			MST.DoKeys("{NUMPAD*}"); //TODO: assuming there is only one DB project expand the whole damn thing
			MST.DoKeys(strViewQueryname);
			//TODO check the properties of the object (possible?)
			Sleep(500);
			MST.DoKeys("%({Enter})"); //bring up the properties
			LOG->RecordCompare(MST.WStaticExists(strViewQueryname), "find query in file pane");
			MST.DoKeys("{Escape}"); // close the property page
		}

	}
	else
	{
		LOG->RecordFailure("Didn't add new %s", bIsView?"view":"query");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\sniff.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      SNIFF.CPP
//
//      Created by :                    Date :
//              RickKr                                  8/30/93
//
//      Description :
//              implementation of the CSniffDriver class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "sniff.h"
#include <process.h>

#include "syscase.h"
#include "spcase.h"
#include "datacase.h"
#include "davcase.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

int ImeInit = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CSniffDriver

IMPLEMENT_SUBSUITE(CDataSubSuite, CIDESubSuite, NULL, "ChrisKoz")

BEGIN_TESTLIST(CDataSubSuite)
	CString strDSNFile=m_SuiteParams->GetTextValue("DSN", "sql.def");
	m_strName=CString("Data Pane, DSN=") + strDSNFile;
	BOOL bDavinci=m_SuiteParams->GetBooleanValue("DESIGNERS", FALSE);
TEST(CConnectTest, RUN)
TEST(CDavinciTest, bDavinci?RUN:DONTRUN)	DEPENDENCY(CConnectTest)
	CString strTable=m_SuiteParams->GetTextValue("DESIGNTABLE", "sales");
	strTable = "Designers on table - " + strTable;
	pTest->SetName(strTable);		
TEST(CTablesTest, bDavinci?DONTRUN:RUN)	DEPENDENCY(CConnectTest)
TEST(CSPTest, bDavinci?DONTRUN:RUN)		DEPENDENCY(CConnectTest)
//	if ((GetSystem() & SYSTEM_DBCS) != 0) { // Only if on a DBC system
//		TEST(CSourceTestCases, DONTRUN)
//	}
END_TESTLIST()

void CDataSubSuite::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
	ExpectedMemLeaks(0);

	CString strDSNFile=m_SuiteParams->GetTextValue("DSN", "sql.def");

	m_DataInfo.GetDataInfo(m_strCWD,strDSNFile);
	if(RegisterAll()!=ERROR_SUCCESS)
		throw CTestException("Can't register the components. Unable to continue", CTestException::causeOperationFail);

	m_projOpen=0; //hack - proj->IsOpen() does not work
}

//inserts the script to generate the table/cleanup the views/diagrams
//creates the new views/diagrams with name (%MACHINE)sqlTableName
//RETURN - returns how many rows have been generated (how many insert statements)
//the current database context is assumed
int CDataSubSuite::CleanAndInsertTable(LPCSTR sqlTableName)
{
	CString m_Dest=m_strCWD + PROJDIR;
	int ret=CopySQLFile(m_strCWD, m_Dest, CString(sqlTableName) + ".SQL");
	
	UIWB.OpenFile( m_Dest + sqlTableName + ".SQL");
	UIWB.DoCommand(IDM_TOOLS_RUNMENU, DC_MENU); //&Tools.&Run
	Sleep(3000); //no other way to determine if it's finished

	UIMessageBox wndMsgBox;
	if (wndMsgBox.AttachActive())// If we can attach, an error must've occurred.
	{
		char title[128];
		::GetWindowText(wndMsgBox, title, 128);
//		if(MST.WFndWndWait("Server Error(s)"/*GetLocString()*/, FW_PART, 0))
//			LOG->Comment("'Server Error(s)' message box detected");
//		else
		{
			LOG->RecordFailure("Unknown (%s) message box detected while running the cleanup script",title);

		}
		//wndMsgBox.ButtonClick(); //does not work for server error(s)
		MST.DoKeys("{ENTER}");
	}
	return ret;
}

int CDataSubSuite::CopySQLFile(CString &m_Source,CString &m_Dest,LPCSTR FName)
{
	CStdioFile fileDest(m_Dest + FName, CFile::modeCreate | CFile::modeWrite | CFile::typeText);
	CStdioFile fileSource(m_Source + FName, 	CFile::modeRead | CFile::typeText);


    CString str;
    const int len=255;
    char buf[len],dest[len];
	char *pservername,*prestline;

	int nrows=0;
	while(fileSource.ReadString(buf, len))
	{
		while((pservername=strstr(buf,"$(MACHINE)"))!=NULL)
		{
			prestline=pservername+strlen("$(MACHINE)");
			pservername[0]=0; //cut the "$(MACHINE)"
			strcat(strcat(strcpy(dest,buf),m_Computername),prestline); //store new line in dest
			strcpy(buf,dest); //line back to buf
		}
		fileDest.WriteString(buf);
		if(strstr(buf,"insert ") == buf)
			nrows++;
//		fileDest.WriteString("\n");  //looks like the CRLF is included in "buf" string
	}	
	return nrows;
} //CopySQLFile()



BOOL CDataSubSuite::RegisterAll()
{
	DWORD len = MAX_COMPUTERNAME_LENGTH+1;
	char lpszNetName[MAX_COMPUTERNAME_LENGTH+1];
	if (!GetComputerName(lpszNetName, &len) || lpszNetName[0]==0)
	{  //computer name must be valid & non empty
		strcpy(lpszNetName, "[Error calling GetComputerName()]");
		LOG->RecordFailure(lpszNetName);
		return ERROR_ERROR;		
	}
	m_Computername=lpszNetName;

	if(m_DataInfo.m_strDSN.Right(4)==".DSN")
	{
    CStdioFile fileDSN(m_DataInfo.m_strDSN, 
		CFile::modeCreate | CFile::modeWrite | CFile::typeText);

	fileDSN.WriteString("[ODBC]\nDRIVER=SQL Server\nUID=");
	fileDSN.WriteString(m_DataInfo.m_strUser);

	fileDSN.WriteString("\nDATABASE=");
	fileDSN.WriteString(m_DataInfo.m_strDataBase);

	fileDSN.WriteString("\nWSID=");
	fileDSN.WriteString(lpszNetName);

	fileDSN.WriteString("\nAPP=");
	CString str;
	str.Format("%s - Owner: %s", (LPCSTR)GetName(), (LPCSTR)GetOwner());
	fileDSN.WriteString(str);

	fileDSN.WriteString("\nSERVER=");
	fileDSN.WriteString(m_DataInfo.m_strServer);
	fileDSN.WriteString("\n");
	}

	if(_spawnlp( _P_WAIT, "regedit.exe", "regedit.exe", "/s",
		  m_strCWD + "SQL.REG", NULL )==-1)
	{
		LOG->RecordFailure("REG file registration failed");
		return ERROR_ERROR;		
	}
	return ERROR_SUCCESS;
}

void CDataSubSuite::CleanUp(void)
{
	if (m_prj.IsOpen()) {
		m_prj.Close();
	}
	m_DataInfo.ClearAll();
	// remove the project directory
	KillAllFiles(m_strCWD + PROJDIR, TRUE);	
	if(m_DataInfo.m_strDSN.Right(4)==".DSN")
		::DeleteFile(m_DataInfo.m_strDSN);
	m_projOpen=0;
	// call the base class
	CIDESubSuite::CleanUp();
}

///////////////////////////////////////////////////////////////////
// Helper functions to manipulate the data workspace
//
void CDataSubSuite::OpenDataProject()
{
	if(!m_projOpen)
	{
		CString strPrjName=m_strCWD + PROJDIR + PROJNAME + ".DSW";
		if(m_prj.Open(strPrjName)!=ERROR_SUCCESS)
			GetLog()->RecordFailure("Coudn't open project - %s",strPrjName);
		else
		{
			m_projOpen=-1;
			Sleep(2000); //safety
		}
	}
} //OpenDataProject

//
BOOL CDataSubSuite::ForcePassword(CDataInfo *pDataInfo)
{
	LPCSTR ServerName=pDataInfo->m_strServer;
	LPCSTR DataBase=pDataInfo->m_strDataBase;
	int ret=ERROR_SUCCESS;
	UIWorkspaceWindow wnd;
	Sleep(1000); //Xtra safety
	wnd.ActivateDataPane();
	CollapseObjects(-1); //collapse the whole tree
	LOG->RecordInfo("Forcing the Login dialog to validate pasword");
	Sleep(1000); //Xtra safety
	MST.DoKeys("{Left}{Left}{Left}{Right}"); //expand the datasources
	Sleep(1000); //Xtra safety
	//TODO this sequence can be changed
	MST.DoKeys(DataBase,TRUE);
	MST.DoKeys(" (",TRUE);
	MST.DoKeys(ServerName,TRUE);
		
	MST.DoKeys("%({Enter})"); //bring up the properties

	if(pDataInfo->m_strPassWord.GetLength()!=0 &&
		m_projOpen<0)
	{
		BOOL bResult=m_prj.ValidatePassword(
		pDataInfo->m_strUser,
		pDataInfo->m_strPassWord,
		pDataInfo->m_strDataBase);
		if(bResult==ERROR_SUCCESS)
			m_projOpen=1;
		else
			return ERROR_ERROR;
	}

	BOOL bReady = FALSE;
	int nSec = 5;
	while (!bReady && ret == ERROR_SUCCESS)
	{
			// Attempt to open the property page for the Data Source
			

			CString str;
			MST.WGetText(NULL, str);
	//		if(str.Find("Properties")>0)
	//			nSec=2; //properties window is up, but XTRA safety required!
			if (MST.WStaticExists(ServerName) && MST.WStaticExists(DataBase))
			{
				LOG->RecordSuccess("Found the DataSource properties");
				bReady = TRUE;
			}
			else
			{
				if (--nSec > 0)	// If we still have some waiting time...
				{
//					LOG->RecordInfo("Waiting up to %d more second(s) for datasource properties...", nSec);
					Sleep(1000);
				}
				else				// We've timed out.
				{
					LOG->RecordInfo("Didn't find the Datasource properties");
					ret = ERROR_ERROR;
				}
			}
	} //while
	MST.DoKeys("{Escape}"); //get rid of property window
	wnd.ActivateDataPane(); //workspace loses focus when password validated
	return ret;		
} //ForcePassword

int CDataSubSuite::CheckObjectProp(CObjectInfo* pMember)
{
	MST.DoKeys("%({Enter})"); //bring up the properties
	BOOL bFound = FALSE;
	int ret=ERROR_SUCCESS;
	int nSec = 10;
	while (!bFound && ret == ERROR_SUCCESS)
	{
	// Attempt to open the property page for the Data Source
	

		CString str;
		MST.WGetText(NULL, str); //should be "<Object type> Properties"
		if(str.Find(GetLocString(IDSS_PROP_TITLE))>0)
		{
			if(nSec>2)nSec=2; //properties window is up, but XTRA safety required!
		}
//TODO add check for the object type (remember that COLUMN type is not introduced into GetTypeMember() yet)
		char name[256];
		strncpy(name, pMember->GetName(), 256);
		if(pMember->m_Type==CObjectInfo::TRIGGER)
		{
			strtok(name,";");
			char *pname=strtok(NULL,";");
			if(pname)
				strcpy(name,pname);
		}
		if (MST.WStaticExists(name))
//TODO add when applicable for each object	&& MST.WStaticExists(pMember->GetTypeName())) 
		{
			bFound = TRUE;
		}
		else
		{
			if (--nSec > 0)	// If we still have some waiting time...
			{
			GetLog()->RecordInfo("Waiting up to %d more second(s) for properties of %s...", 
				nSec,pMember->GetName());
			Sleep(1000);
			}
			else				// We've timed out.
			{		
				GetLog()->RecordFailure(
					"Timeout waiting for properties of %s name: '%s'",
					pMember->GetTypeName(),pMember->GetName());
				ret = ERROR_ERROR;
			}
		}
	} //while
	MST.DoKeys("{Escape}"); // close the property page
	return ret;
} //CheckObjectProp


void CDataSubSuite::ExpandProcedureNode(CString strDBName)
{
//	ExpandDatabase(strDBName);
	MST.DoKeys(GetLocString(IDSS_STOREDPROC)); //"Stored Procedures"
	Sleep(2000);						// Wait so next key isn't included in search
	MST.DoKeys("{NUMPAD+}");			// Expand the Table node
}


void CDataSubSuite::ExpandTableNode(CString strDBName)
{
//	ExpandDatabase(strDBName);
	MST.DoKeys(GetLocString(IDSS_TABLE)); // "Table"
	Sleep(2000);						// Wait so next key isn't included in search
	MST.DoKeys("{NUMPAD+}");			// Expand the Table node
}

void CDataSubSuite::ExpandDiagramsNode(CString strDBName)
{
//	ExpandDatabase(strDBName);
	MST.DoKeys(GetLocString(IDSS_DIAGRAM)); // "Database Diagrams"
	Sleep(2000);						// Wait so next key isn't included in search
	MST.DoKeys("{NUMPAD+}");			// Expand the Table node
}


void CDataSubSuite::ExpandViewNode(CString strDBName)
{
//	ExpandDatabase(strDBName);
	MST.DoKeys(GetLocString(IDSS_VIEW)); // "View"
	Sleep(2000);						// Wait so next key isn't included in search
	MST.DoKeys("{NUMPAD+}");			// Expand the Table node
}

void CDataSubSuite::CollapseObjects(int isTrigger)
{
	if(isTrigger>0)
	{
		MST.DoKeys("{Left}"); // goto the table
		MST.DoKeys("{NUMPAD-}");// collapse table tree
	}
	if(isTrigger>=0)
	{
		MST.DoKeys("{NUMPAD-}"); // collapse the expanded object
		MST.DoKeys("{Left}"); // goto the parent node
		MST.DoKeys("{NUMPAD-}");// collapse objects' tree
	}
	else 
	{ //collapse the whole tree
		MST.DoKeys("{Home}");
		MST.DoKeys("{NUMPAD-}");
	}
}

void CDataSubSuite::ExpandTable(CString strTableName)
{
//	ExpandDatabase(strDBName);
	ExpandTableNode("");
	MST.DoKeys(strTableName);
	Sleep(2000); 			// Wait so next key isn't included in search
	MST.DoKeys("{NUMPAD+}");
}

BOOL CDataSubSuite::SelectDatabase(CString strDBName)
{
	if (1 /*!ActivateDataPane()*/) {
		m_pLog->RecordFailure("Couldn't activate the DataView");
		return FALSE;
	}

	MST.DoKeys("^{HOME}");				// Go to top of tree
	MST.DoKeys(strDBName);				// Select database
	Sleep(2000);						// Wait so next key isn't included in search
	
	return TRUE;
}

BOOL CDataSubSuite::RefreshDatabase(CString strDBName)
{
	if (1/*!ActivateDataPane()*/) {
		m_pLog->RecordFailure("Couldn't activate the DataView");
		return FALSE;
	}

	SelectDatabase(strDBName);
	MST.DoKeys("+{F10}");				// Shift+F10 brings up context menu
	Sleep(1000);

  	MST.DoKeys("{HOME}{ENTER}"); //usually, the refresh is the first command

	return TRUE;
}


//void CTablesTest::ExpandDatabase(CString strDBName)
//{
//	SelectDatabase(strDBName);
//	MST.DoKeys("{NUMPAD+}");
//}


///////////////////////////////////////////////////////////////////
// Helper functions to provide the data from the outer filename
//
CObjectInfo::~CObjectInfo()
{
	ClearAll();
}

CDataInfo::~CDataInfo()
{
	ClearAll();
}

void CDataInfo::ClearAll()
{ 
    m_strDataBase.Empty();
	m_strDSN.Empty();
	m_strServer.Empty();
	m_strUser.Empty();
	m_strPassWord.Empty();
    
	POSITION pos = m_listMembers.GetHeadPosition();
	while(pos != NULL)
	{
		delete m_listMembers.GetAt(pos);
		m_listMembers.GetNext(pos);
	}

	m_listMembers.RemoveAll();
}

void CObjectInfo::ClearAll()
{ 
    m_strName.Empty(); 
}

void CDataInfo::GetDataInfo(CString &DirName,CString &FileName)
{
    CStdioFile fileVerify(DirName+FileName, CFile::modeRead | CFile::typeText);
  	const int len=256;
	char buf[len];
	CString str("");

	// DataBase info comes first.
	if(fileVerify.ReadString(buf, len)==0)
	{
		LOG->RecordFailure("No SQL.BAS file found");
		return; //error
	}
	m_strServer=strtok(buf," ");
	m_strDataBase=strtok(NULL," ");
	m_strUser=strtok(NULL," ");
	m_strPassWord=strtok(NULL," ");
	TrimString(&m_strServer);
	TrimString(&m_strDataBase);
	TrimString(&m_strUser);
	TrimString(&m_strPassWord);
	if(m_strServer.Find("DSN=")==0)
	{
		m_strServer=m_strServer.Right(m_strServer.GetLength()-4);
		m_strDSN=DirName + m_strServer + ".DSN";
	}
	else
		m_strDSN="Test"+m_strServer;

    // Now get rest of information, if any.
    CString strDelimiter("***");
    BOOL bDone = FALSE;

    while (!bDone && fileVerify.ReadString(buf, len))
    {
        str = buf;
        TrimString(&str);

        if (!str.IsEmpty() && str.GetAt(0) != ';')
        {
            if (str == strDelimiter)
                bDone = TRUE;
			else 
			{
				CObjectInfo* pNew = new CObjectInfo();
				if(str.Find("TABLE") == 0)
				{	pNew->m_Type=CObjectInfo::TABLE;}
				if(str.Find("VIEW") == 0)
				{	pNew->m_Type=CObjectInfo::VIEW;}
				if(str.Find("DIAGRAM") == 0)
				{	pNew->m_Type=CObjectInfo::DIAGRAM;}
				if(str.Find("PROC") == 0)
				{	pNew->m_Type=CObjectInfo::PROC;}
				if(str.Find("TRIGGER") == 0)
				{	pNew->m_Type=CObjectInfo::TRIGGER;}
				if(str.Find("ADHOC") == 0)
				{	pNew->m_Type=CObjectInfo::ADHOC;}
				if(str.Find("NEWPROC") == 0)
				{	pNew->m_Type=CObjectInfo::NEWPROC;}
				strtok(buf, " "); // TABLE or VIEW or PROC or any valid object
				str=strtok(NULL, ",\n");
				pNew->m_strName	= str;
				TrimString(&pNew->m_strName);
				str=strtok(NULL, ",\n");
				pNew->m_strParams=str;
				TrimString(&pNew->m_strParams);
				str=strtok(NULL, ",\n");
				pNew->m_strOwner=str;
				TrimString(&pNew->m_strOwner);
				m_listMembers.AddTail(pNew);
			}
        }
    }
} //GetDataInfo


// EOF - sniff.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\spcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      SPCASE.CPP
//
//      Created by :                    Date :
//              ChrisKoz                                  1/25/96
//
//      Description :
//              Implementation of the SPCase
//

#include "stdafx.h"
#include <io.h>
#include "spcase.h"
#include "sniff.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

///////////////////////////////////////////////////////////////////////////////
//	CSPTest class
BOOL ExecSPParam(LPCSTR Params=NULL);
BOOL ExecSPParam(LPCSTR Params /*=NULL*/)
{
	int nSec=2;
	CString str;
	int ret=ERROR_SUCCESS;
	BOOL bExecuting=FALSE;
	while (nSec>0)
	{
		MST.WGetText(NULL, str);
		if(Params!=NULL &&
			str.Find(GetLocString(IDSS_RUN_STOREDPROC)) >=0)
		{
			LPCSTR pparam=strtok((char*)Params," \t\n");
			while(pparam!=NULL)
			{
				MST.DoKeys(pparam); //suply next param
				MST.DoKeys("{Down}"); //go to the next row in a grid
				pparam=strtok(NULL," \t\n");
			}
			MST.WButtonClick(GetLabel(IDOK)); // accept params
			bExecuting=TRUE;
			Sleep(2000);
			break;
		}
		if (nSec > 0) // If we still have some waiting time...
		{
			LOG->RecordInfo("Current wnd title: %s",str);
			LOG->RecordInfo("Waiting up to %d more second(s) for SP to execute",nSec);
			nSec--;
			Sleep(1000);
		}
	} //while */
	UIMessageBox wndMsgBox;
	if (wndMsgBox.AttachActive())// If we can attach, an error must've occurred.
	{
		char title[128];
		::GetWindowText(wndMsgBox, title, 128);
		if(MST.WFndWndWait("Server Error(s)"/*GetLocString()*/, FW_PART, 0))
			LOG->Comment("'Server Error(s)' message box detected");
		else
		{
			LOG->Comment("Unknown (%s) message box detected",title);
			ret = ERROR_ERROR;
		}
		//wndMsgBox.ButtonClick(); //does not work for server error(s)
		MST.DoKeys("{ENTER}");
	}
//TODO: maybe wait for the message about the execution finished
	return ret;
} //ExecSPParam

//create the new stored procedure
void NewSP(LPCSTR filename)
{	
	MST.DoKeys("+{F10}");
	Sleep(1000); //xtra safety
	MST.DoKeys("W"); //new stored proc



	COSource srcFile;

	srcFile.AttachActiveEditor();
	UIWB.DoCommand(ID_EDIT_SELECT_ALL, DC_MNEMONIC); //select all
	CStdioFile fileSource(filename,	CFile::modeRead | CFile::typeText);
    const int len=255;
    char buf[len];
	while(fileSource.ReadString(buf, len))
	{
		MST.DoKeys(buf,TRUE,3000);
		MST.DoKeys("{ENTER}{HOME}",FALSE,1000);
	}
	UIWB.DoCommand(ID_FILE_SAVE, DC_MNEMONIC); //save it
	::WaitForInputIdle(g_hTargetProc, 5000);
} //NewSP



IMPLEMENT_TEST(CSPTest, CTest, "SP/Trigger/AdHoc objects", -1, CDataSubSuite)


void CSPTest::Run(void)
{
	CDataSubSuite *pSuite=GetSubSuite();
	pSuite->OpenDataProject();
	if(pSuite->ForcePassword(&pSuite->m_DataInfo)!=ERROR_SUCCESS)
	{
		GetLog()->RecordFailure("Coudn't find the DataSource - %s",
			GetSubSuite()->m_DataInfo.m_strDSN);
		throw CTestException("Cannot reopen the Datasource connection; unable to continue.", 
			CTestException::causeOperationFail);
	}
	// now we are at the DataSource Node let's examine the tables
	MST.DoKeys("{Right}"); //expand the tables of active datasource
	if (WaitForInputIdle(g_hTargetProc, 60000) == WAIT_TIMEOUT)
		GetLog()->RecordFailure("Coudn't deploy the tables");
	
	TestSPTrigObjects();
	GetSubSuite()->m_prj.Close(TRUE); GetSubSuite()->m_projOpen=0;
} //CSPTest::Run()


void CSPTest::TestSPTrigObjects()
{
	CDataSubSuite *pSuite=GetSubSuite();
	CDataInfo *info=&pSuite->m_DataInfo;


    GetLog()->RecordInfo("Checking object of database: %s", info->GetName());

	UIWorkspaceWindow wnd;



	for(POSITION pos = info->m_listMembers.GetHeadPosition();
		pos!=NULL;info->m_listMembers.GetNext(pos))
	{
		CObjectInfo* pMember=info->m_listMembers.GetAt(pos);// has members.
		if(pMember->m_Type==CObjectInfo::TABLE ||
				  pMember->m_Type==CObjectInfo::VIEW ||
				  pMember->m_Type==CObjectInfo::DIAGRAM)
			continue; // dont test tables/diagrams
		char name[256];
		switch(pMember->m_Type)
		{
			case CObjectInfo::PROC:
			case CObjectInfo::NEWPROC:
				pSuite->ExpandProcedureNode("");
				break;
			case CObjectInfo::TRIGGER:
				strncpy(name,pMember->GetName(),255);
				pSuite->ExpandTable(strtok(name,";")); 
				// (trigger & columns go under table)
				break;
			case CObjectInfo::ADHOC:
				pSuite->ExpandTableNode("");//whatever node makes it here
				break;
			default:
				continue; // object type not supported
		} //switch
		strncpy(name,pMember->GetName(),255);
		if(pMember->m_Type==CObjectInfo::TRIGGER)
		{
			strtok(name,";");
			strcpy(name,strtok(NULL,";"));
		}
// if(ADHOC) do not DoKeys but open from file do not open source view
				//then execute like SP
//if(NEWPROC) do not fail on checkproperties but hit new SP and insert the contents from file
				//then execute like SP
		if(pMember->m_Type==CObjectInfo::ADHOC)
		{
			MST.DoKeys("{DOWN}"); //make it as if some particular table was affected
			UIWB.OpenFile(m_strCWD + pMember->m_strName);
			UIWB.DoCommand(IDM_TOOLS_RUNMENU, DC_MENU); //&Tools.&Run
			BOOL bResult=ExecSPParam(); //no parameters
		}
		else
		{
			if(pMember->m_Type==CObjectInfo::NEWPROC)
			{	// make new stored procedure & get the text from pMember->m_strOwner;
				MST.DoKeys(name, TRUE);Sleep(500);
				MST.DoKeys("%({Enter})"); //bring up the properties
				if(MST.WFndWndWaitC(name, "Static", FW_FULL, 2))
				{ //correct SP highlighted
					MST.DoKeys("{Escape}"); // close the property page
					MST.DoKeys("{Delete}");
					if(MST.WFndWndWait(GetLocString(IDSS_WORKBENCH_TITLEBAR), FW_PART, 2) &&
						MST.WFndWndWaitC(CString("'")+name+"'", "Static", FW_PART, 2))
						MST.DoKeys("{ENTER}"); //OK - delete the proc
					else
						LOG->Comment("Stored Proc: '%s' not found in wkpce",name);
				}
				else
				{
					MST.DoKeys("{Escape}"); // close the property page
					LOG->Comment("Stored Proc: '%s' not found in wkpce",name);
				}
				pSuite->ExpandProcedureNode("");
				NewSP(m_strCWD+pMember->m_strOwner);
				// since we never know where we are after expanding non-exisitng object
				// we are forced to start from the top
				pSuite->ForcePassword(&pSuite->m_DataInfo);
				MST.DoKeys("{Right}"); //expand the tables of active datasource
				pSuite->ExpandProcedureNode("");
			}

			MST.DoKeys(name, TRUE);Sleep(500);
			if(pSuite->CheckObjectProp(pMember)!=ERROR_ERROR)
			{
				char ob_typename[128];
				GetLog()->RecordSuccess("Found the %s name: '%s'",pMember->GetTypeName(),name);
				strncpy(ob_typename,pMember->GetTypeName(),128);
				OpenSourceView(name,ob_typename,info); //openning trigger or SP
				if(pMember->m_Type==CObjectInfo::PROC ||
				   pMember->m_Type==CObjectInfo::NEWPROC)
				{
					LOG->RecordInfo("Running the Stored Procedure...");
					UIWB.DoCommand(IDM_TOOLS_RUNMENU, DC_MENU); //&Tools.&Run
					WaitForInputIdle(g_hTargetProc, 5000);
					BOOL bResult=ExecSPParam(pMember->m_strParams);
					LOG->RecordCompare(bResult==ERROR_SUCCESS,"Run the SP");
				}
				else //pMember->m_Type==CObjectInfo::
				{ //Don't do anything for trigger
				}
			}
		}
		wnd.Activate(); //returns to the project workspace
		pSuite->CollapseObjects((pMember->m_Type!=CObjectInfo::TRIGGER)?0:1);
	}	// end for
	pSuite->CollapseObjects(1);	//final collapse of all objects
} //TestSPTrigObjects


/////////////////////////////////////////////////////////////////////
// Opens the source window for the object type != TABLE or VIEW
// and checks the create statement
// RETURNS: ERROR_SUCCESS if OK
////////////////////////////////////////////////////////////////////
int CSPTest::OpenSourceView(LPCSTR pszName,CString strType,
										CDataInfo *DataInfo)

{
	int ret = ERROR_SUCCESS;
	CString Name=pszName;
	Name.MakeUpper();
	CString Type="NOTHING";
	if(strType==GetLocString(IDSS_TRIGGER)) //Trigger
		Type="TRIGGER";
	if(strType==GetLocString(IDSS_STOREDPROC)) //Stored Procedure
		Type="PROC";
	MST.DoKeys("{Enter}"); //for open, provided the lack of better handle
	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
	Sleep(1000);							// Wait for message box to arrive.

	UIMessageBox wndMsgBox;
	if (wndMsgBox.AttachActive())			// If we can attach, then an error must've occurred.
	{
		ret = ERROR_NO_DEFINITION;
		wndMsgBox.ButtonClick();
	}
	else									// A source window must've become active.
	{
		COSource SrcFile;
//		CString title=DataInfo->m_strServer+"!"+DataInfo->m_strName;	
// Excruciatingly Stupid Design: server name is no part of the title anymore
		CString title=CString(pszName) + " : "+strType;	

		SrcFile.AttachActiveEditor();
		HWND hwnd=UIWB.GetActiveEditor(); //don't know how to take the handler from COSource

		CString str;
		MST.WGetText(hwnd, str); //should be text window
		if(str.Find(title) ==-1)
		{
			LOG->RecordInfo("Didn't find the source window for object: %s",pszName);
			ret=ERROR_ERROR;
		}
		CString strFound;int cont=10;
		MST.DoKeys("^{HOME}");
		do{ // skip comments
			MST.DoKeys("+({End})"); // Select to end of line.
			strFound = SrcFile.GetSelectedText();
			strFound.TrimLeft();
			strFound.MakeUpper();
			MST.DoKeys("{Left}{Down}");
		}while((strFound.GetLength( ) == 0 || strFound.Find("--") == 0) && --cont!=0);

		// Remove spaces from both the source and target strings for comparison.

		if (strFound.Find("CREATE") == -1 ||
			strFound.Find(Name) == -1 ||
			strFound.Find(Type) == -1)
		{
			LOG->RecordFailure("Didn't find the create statment for object: %s",pszName);
			ret = ERROR_ERROR;
		}
	}
	
	return ret;
} //CSPTest::OpenSourceView
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\spcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	SRCCASES.H
//
//	Created by :			Date :
//		DavidGa					4/11/94
//
//	Description :
//		Declaration of the CSrcTestCases class
//

#ifndef __SRCCASES_H__
#define __SRCCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
//	CSourceTestCases class

class CSPTest : public CTest
{
	DECLARE_TEST(CSPTest, CDataSubSuite)

// Data
public:

// Operations
public:
	virtual void Run(void);

// Test Cases
	void TestSPTrigObjects();
	int OpenSourceView(LPCSTR pszName,CString strType,CDataInfo *DataInfo);
public:
};

#endif //__SRCCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\sniff.h ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.H
//
//	Created by :			Date :
//		TomWh					11/1/93
//
//	Description :
//		Declaration of the CSniffDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#define PROJNAME "Data Base Proj"
#define PROJDIR "Data Base Proj\\"

// Stuff needed for Data View verification.

// BEGIN_CLASS_HELP
// ClassName: CObjectInfo
// BaseClass: none
// Category: Project
// END_CLASS_HELP

struct CObjectInfo
{
	enum TYPE { TABLE, VIEW, DIAGRAM, PROC, TRIGGER, ADHOC, NEWPROC};
//	enum ACCESS { PUBLIC, PRIVATE, PROTECTED, GLOBAL };

	CString		m_strName;			// Name of member.
	CString		m_strParams;		// Parameters 
	// actually params for PROC/NEWPROC, or table owner for TRIGGER)
	CString		m_strOwner;			//owner of this object
	TYPE		m_Type; 			// Type TABLE, PROC, ...

	~CObjectInfo();

    void ClearAll();

    LPCSTR GetName() const { ASSERT(!m_strName.IsEmpty()); return (LPCSTR)m_strName; }
	CString GetTypeName() const {
		if(m_Type==TABLE) 
			return GetLocString(IDSS_TABLE); //Table
		if(m_Type==VIEW) 
			return GetLocString(IDSS_VIEW); //View
		if(m_Type==DIAGRAM) 
			return GetLocString(IDSS_DIAGRAM); //Database Diagram
		if(m_Type==PROC || m_Type==NEWPROC) 
			return GetLocString(IDSS_STOREDPROC); //Stored Procedure
		if(m_Type==TRIGGER) 
			return GetLocString(IDSS_TRIGGER); //Trigger
		if(m_Type==ADHOC) 
			return CString(""); 
		return CString(""); 
	}

};

// BEGIN_CLASS_HELP
// ClassName: CClassInfo
// BaseClass: none
// Category: Project
// END_CLASS_HELP
struct CDataInfo 
{
    CString m_strDataBase;					// Name of database.
    CString m_strDSN;				// Name of datasource.
	CString m_strServer;				// Server name
	CString m_strUser;					// user name
	CString m_strPassWord;				// Password for user
	CTypedPtrList<CPtrList, CObjectInfo*> m_listMembers;
	void GetDataInfo(CString &DirName,CString &FileName);
	~CDataInfo();

    void ClearAll();
    LPCSTR GetName() const { return (LPCSTR)m_strDataBase; }
};


///////////////////////////////////////////////////////////////////////////////
// CSysSubSuite class

class CDataSubSuite : public CIDESubSuite
{
	DECLARE_SUBSUITE(CDataSubSuite)

	DECLARE_TESTLIST()

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
	virtual void CleanUp(void);
protected:
	BOOL RegisterAll();
// data
public:
	CDataInfo m_DataInfo;		//database in project's DAataPana
	COProject m_prj;			//project being open
	int m_projOpen;	// 0 closed, 1 open, -1 open with no pwd validated
	CString m_Computername;

//operations
	void OpenDataProject();
	BOOL ForcePassword(CDataInfo *pDataInfo);
	int CheckObjectProp(CObjectInfo* pMember);


	BOOL SelectDatabase(CString strDBName);
	BOOL RefreshDatabase(CString strDBName);
	void ExpandProcedureNode(CString strDBName);
	void ExpandTableNode(CString strDBName);
	void ExpandDiagramsNode(CString strDBName);
	void ExpandViewNode(CString strDBName);
	void ExpandTable(CString strTableName);
	void CollapseObjects(BOOL isTrigger);
	void ExpandDatabase(CString strDBName);
//utilities preparing the database
	int CDataSubSuite::CleanAndInsertTable(LPCSTR sqlTableName);
	int CDataSubSuite::CopySQLFile(CString &m_Source,CString &m_Dest,LPCSTR FName);
};


#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\syscase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      SYSCASES.CPP
//
//      Created by :                    Date :
//              ChrisKoz                                  1/25/96
//
//      Description :
//              Implementation of the creation & classview in Galileo project
//

#include "stdafx.h"
#include <io.h>
#include "syscase.h"
#include "sniff.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

///////////////////////////////////////////////////////////////////////////////
//	CConnectTest class


IMPLEMENT_TEST(CConnectTest, CTest, "Connect to SQL server", -1, CDataSubSuite)

BOOL CConnectTest::RunAsDependent(void)
{
		return FALSE; //never run because it confuses
	// name of the project file
	// if(!GetSubSuite()->m_prj.IsOpen())  this does not work
/*	if(!GetSubSuite()->m_projOpen)
	{
		CString strPrjName=m_strCWD + PROJDIR + PROJNAME + ".DSW";
		if(GetSubSuite()->m_prj.Open(strPrjName)!=ERROR_SUCCESS)
			GetLog()->RecordFailure("Coudn't open project - %s",strPrjName);
		else
		{
			GetSubSuite()->m_projOpen=-1;
			Sleep(2000); //safety
		}
	} */
//	if(FindDataInWkspace(&GetSubSuite()->m_DataInfo)==ERROR_SUCCESS)
//	{

//		return FALSE;
//	}
//	else {
//		return TRUE;
//	}
}



void CConnectTest::Run(void)
{
	BOOL bResult=ERROR_ERROR;
	// if(!GetSubSuite()->m_prj.IsOpen())  this does not work
/*	if(!GetSubSuite()->m_projOpen) I nuked the old C++ project stuff
	{
		CString strPrjName=m_strCWD + PROJDIR + PROJNAME + ".DSW";
		if(GetSubSuite()->m_prj.Open(strPrjName)!=ERROR_SUCCESS)
			GetLog()->RecordFailure("Coudn't open project - %s",strPrjName);
		else
		{
			GetSubSuite()->m_projOpen=-1;
			Sleep(2000);
		}
	} */
//	if((bResult=FindDataInWkspace(&GetSubSuite()->m_DataInfo))!=ERROR_SUCCESS)
//	{
		CDataInfo *pDataInfo=&GetSubSuite()->m_DataInfo;
		bResult=GetSubSuite()->m_prj.NewProject(DATABASE_PROJECT,
			CString(PROJNAME),GetCWD()+PROJDIR,GetUserTargetPlatforms(),TRUE);
		bResult=GetSubSuite()->m_prj.AddSQLDataSource(
			pDataInfo->m_strDSN,
			pDataInfo->m_strUser,
			pDataInfo->m_strPassWord,
			pDataInfo->m_strDataBase);
//	}
	if(!GetLog()->RecordCompare(bResult == ERROR_SUCCESS, 
					"Opening the SQL Server '%s' database %s.",
					GetSubSuite()->m_DataInfo.m_strServer,
					GetSubSuite()->m_DataInfo.m_strDataBase))
		throw CTestException("Cannot establish the connection; unable to continue.", 
				CTestException::causeOperationFail);
	GetSubSuite()->m_prj.Close(TRUE); GetSubSuite()->m_projOpen=0;	
} //CConnectTest::Run()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\davinc\cmpmsg.h ===
/*============================================================================
Microsoft Access

Microsoft Confidential.
Copyright 1992 Microsoft Corporation. All Rights Reserved.

	Component Message Range Definitions

Don't start any lower than 400 because we run into Projects private
messages that they accidently send to other applications
============================================================================*/

#ifdef __cplusplus
extern "C" {
#endif

#define WM_FORMSTART	(WM_USER + 400)
#define WM_TBSTART		(WM_USER + 490)
#define WM_DOCSTART 	(WM_USER + 500)
#define WM_KTSTART		(WM_USER + 600)
#define WM_ECLSTART 	(WM_USER + 700)
#define WM_DEMSTART		(WM_USER + 800)
#define WM_OESTART		(WM_USER + 900)
#define WM_SUISTART		(WM_USER + 1100)
#define WM_QRYSTART 	(WM_USER + 1200)
#define WM_PRINTSTART	(WM_USER + 1300)
#define WM_DSKSTART 	(WM_USER + 1400)
#define WM_DBCSTART 	(WM_USER + 1500)
#define WM_MAINSTART	(WM_USER + 1600)
#define WM_FEDTSTART	(WM_USER + 1700)
#define WM_GRIDSTART	(WM_USER + 1800)
#define WM_DRAGSTART	(WM_USER + 1900)
#define WM_GRIDXSTART	(WM_USER + 2000)
#define WM_BUILDSTART	(WM_USER + 2050)
#define WM_SRELSTART	(WM_USER + 2100)
#define WM_DDESUPSTART	(WM_USER + 2200)
#define WM_MODSTART		(WM_USER + 2300)

// These two messages are here because they are shared between OLE and DDE
#define WM_PROCESSDDEEXECUTE	WM_DDESUPSTART + 0
#define WM_PROCESSDDEREQUEST	WM_DDESUPSTART + 1


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\davinc\dspconst.h ===
#if !defined(DSPCONST_H_INCLUDED_)
#define DSPCONST_H_INCLUDED_

/*============================================================================
Microsoft Access

Microsoft Confidential.
Copyright 1992 Microsoft Corporation. All Rights Reserved.

Component: misc

File: dspconst.h

Display constants shared by multiple components
(e.g. FEDT, DispSz, forms, grid)
============================================================================*/
#ifndef _DSPCONST_H
#define _DSPCONST_H

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************

		Alignment codes

*****************************************************************/

#define alnGeneral			0
#define alnLeft				1
#define alnCenter			2
#define alnRight			3
#define alnCenterIfFit		4	/* center if text fits, else left align */
#define alnMax				5
#define alnNil				((BYTE)-1)	/* NEVER stored!!! used only as a return
										value */
#define alnDef			alnGeneral

/*****************************************************************

		Color id codes

*****************************************************************/

#define crBlack 		RGB(0x00,0x00,0x00)
#define crGrey			RGB(0x80,0X80,0x80)
#define crWhite 		RGB(0xff,0xff,0xff)
#define crRed 			RGB(0xff,0x00,0x00)
#define crGreen 		RGB(0x00,0xff,0x00)
#define crBlue  		RGB(0x00,0x00,0xff)
#define crYellow 		RGB(0xff,0xff,0x00)
#define crMagenta 		RGB(0xff,0x00,0xff)
#define crCyan  		RGB(0x00,0xff,0xff)
#define crNil 			((COLORREF)-1)

#define crLtGray		RGB(192, 192, 192)
#define crDkGray		RGB(64, 64, 64)

#define crLtGrey		crLtGray
#define crDkGrey		crDkGray
#define crGray			crGrey

// Win95 colors
// tearoff palette colors.  Comments are from Excel, meaningless to us.
#define crPal01		0x000000L
#define crPal02		0xFFFFFFL
#define crPal03		0x0000FFL
#define crPal04		0x00FF00L
#define crPal05		0xFF0000L
#define crPal06		0x00FFFFL
#define crPal07		0xFF00FFL
#define crPal08		0xFFFF00L
#define crPal09		0x000080L
#define crPal10		0x008000L
#define crPal11		0x800000L
#define crPal12		0x008080L
#define crPal13		0x800080L
#define crPal14		0x808000L
#define crPal15		0xC0C0C0L
#define crPal16		0x808080L
#define crPal17		RGB(0x99,0x99,0xff) // 24 Fill 1
#define crPal18		RGB(0x99,0x33,0x66) // 25 Fill 2
#define crPal19		RGB(0xff,0xff,0xcc) // 26 Fill 3  // warning! change this or it's 
#define crPal20		RGB(0xa6,0xca,0xf0) // 27 Fill 4 // and you must change 
#define crPal21		RGB(0x66,0x00,0x99) // 28 Fill 5 // (colorful 2)
#define crPal22		RGB(0xff,0x7c,0x80) // 29 Fill 6
#define crPal23		RGB(0x00,0x99,0xcc) // 30 Fill 7
#define crPal24		RGB(0xcc,0xcc,0xff) // 31 Fill 8
#define crPal25		RGB(0x00,0x00,0x80) // 32 Line 1
#define crPal26		RGB(0xff,0x00,0xff) // 33 Line 2
#define crPal27		RGB(0xff,0xff,0x00) // 34 Line 3
#define crPal28		RGB(0x00,0xff,0xff) // 35 Line 4
#define crPal29		RGB(0x80,0x00,0x80) // 36 Line 5
#define crPal30		RGB(0x80,0x00,0x00) // 37 Line 6
#define crPal31		RGB(0x00,0x80,0x80) // 38 Line 7
#define crPal32		RGB(0x00,0x00,0xff) // 39 Line 8
#define crPal33		RGB(0x00,0xcc,0xff) // 40
#define crPal34		RGB(0x66,0xff,0xff) // 41
#define crPal35		RGB(0xcc,0xff,0xcc) // 42
#define crPal36		RGB(0xff,0xff,0x99) // 43
#define crPal37		RGB(0xa6,0xca,0xf0) // 44  //(Sys9)
#define crPal38		RGB(0xcc,0x99,0xcc) // 45
#define crPal39		RGB(0xcc,0x99,0xff) // 46
#define crPal40		RGB(0xe3,0xe3,0xe3) // 47
#define crPal41		RGB(0x33,0x66,0xff) // 48
#define crPal42		RGB(0x33,0xcc,0xcc) // 49
#define crPal43		RGB(0x33,0x99,0x33) // 40
#define crPal44		RGB(0x99,0x99,0x33) // 51
#define crPal45		RGB(0x99,0x66,0x33) // 52
#define crPal46		RGB(0x99,0x66,0x66) // 53
#define crPal47		RGB(0x66,0x66,0x99) // 54
#define crPal48		RGB(0x96,0x96,0x96) // 55
#define crPal49		RGB(0x33,0x33,0xcc) // 56
#define crPal50		RGB(0x33,0x66,0x66) // 57
#define crPal51		RGB(0x00,0x33,0x00) // 58
#define crPal52		RGB(0x33,0x33,0x00) // 59
#define crPal53		RGB(0x66,0x33,0x00) // 60
#define crPal54		RGB(0x99,0x33,0x66) // 61
#define crPal55		RGB(0x33,0x33,0x99) // 62
#define crPal56		RGB(0x42,0x42,0x42) // 63
	
/*****************************************************************

		Pattern id codes

*****************************************************************/

#define patNil		0
#define patSolid	1
#define patBitMin	1
#define patBitMax	32

/*****************************************************************

		Structures

*****************************************************************/

typedef struct TXTINFO
	{
	COLORREF crTxt;		/* text color */
	UINT ifm;			/* index to font of this item */
			/* (really type IFM, but don't want to include fontmast.h et al.) */
	BYTE aln;			/* alignment.  If general, always left-align. */
	} TXTINFO;

typedef struct _brshinfo
	{
	HBR hbr;			/* brush */
	COLORREF crBkg;		/* background color - to optimize for solid brushes */
	BOOLB fPatterned;	/* is brush patterned? */
	BOOLB fTransparent; /* is background supposed to be transparent? */
	} BRSHINFO;
	
typedef struct _bdrinfo
	{
	union		// CONSIDER: making these one once grid uses KT borders
		{
		DPOINT dpt;		/* border width; 0 for transparent */
		RECT	rcpMarg;	/* amount to deflate cell RECT before Paint */
		};
	BYTE appear;		/* 3D appearance (0 = normal) */
	BOOL fTransparent;	/* is border clear? */
	COLORREF crBkg;		/* background color */
	INT iLnStyle;	/* Line pattern - 0=solid, 1=dashed, etc */
	} BDRINFO;
	

/* Constants used to simulate double-clicks for the shared fedt; from _sdm.h */
#define	dxDoubleClick	4
#define	dyDoubleClick	2
#ifdef __cplusplus
}
#endif
#endif // _DSPCONST_H

#endif // !defined(DSPCONST_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\davinc\grid.h ===
#if !defined(GRID_H_INCLUDED_)
#define GRID_H_INCLUDED_

/*============================================================================
Microsoft Access

Microsoft Confidential.
Copyright 1992 Microsoft Corporation. All Rights Reserved.

Component: Grid

File: Public include file for the grid component

#include "dspconst.h"	// for TXTINFO for grid.h
#include "collect.h"	// for EC for grid.h
============================================================================*/

#ifndef _GRID_H
#define _GRID_H

//#include "es.h"
#include "stdapp.h"
#include "dspconst.h"

#ifdef __cplusplus
extern "C" {
#endif


typedef	DWORD	ICOL;
typedef	DWORD	IROW;
typedef	DWORD	ICLRW;		/* used for either columns or rows */

#define icolNil     ((ICOL) ~0)
#define icolBndNil	((ICOL) ~1)
#define irowNil     ((IROW) ~0)
#define iclrwNil    ((ICLRW) ~0)
#define wicolNil   	icolNil
#define wirowNil    irowNil

/* segGrid declaration */
extern	struct _gi far *pgi;
extern SEG segGrid;

typedef struct GRID 
	{ 
	DWORD	grfGa;			/* grid attributes (see below) */ 
	DWORD	grfGaEx;			/* extended grid attributes (see below) */ 
		/* pointer to client's callback routine (required): */
	DWORD	(FAR *lpfnlClientProc)(HWND hwnd, UINT wm, UINT wParam, DWORD lParam);
	HWND	hwndParent;			/* handle to parent window (required) */
	RECTD		rcd;				/* location in parent's client coordinates */
	BYTE	crowFixed, ccolFixed;	/* number of fixed rows/columns */ 
	INT		crow, ccol;			/* grid dimensions (incl. fixed rows/cols) */ 
	INT		dxtColDft;			/* default column width (in TWIPS) */
	INT		dytRowDft;			/* default row height (in TWIPS) */
	DWORD	dwClient;			/* client info to be passed back via GCL_INIT */
	UINT	cfCustom;			/* 432: custom CF to use in place of text & csv */
	} GRID;		/* GRID information */ 

typedef	GRID FAR *LPGRID;

typedef struct GV 
	{
	BRSHINFO	brshBk;					/* background brush info */ 
	HBR		hbrGlns, hbrGlnsFixed;		/* grid-line brushes */ 
	UINT appearLines;	// raised, sunken, normal
	} GV;			/* Grid Visuals */ 

typedef GV FAR *LPGV;

/* Space for a long (4 bytes) is allocated with the window, for client use. */
#define ibGridClient	(ibWndSeg+sizeof(SEG))

#ifdef __cplusplus
#pragma warning(disable:4200)       // zero-size array
#endif // __cplusplus

typedef struct _gca
	{
	UINT	grfGca;			/* grid cell attribute flags (see defs below) */ 
	TXTINFO	txtinfo;		/* color, font, alignment */
	BRSHINFO brshinfo;		/* brush, color, fPatterned, fTransparent */
	BDRINFO	bdrinfo;		/* rcpMarg, appearance */

	UINT	hkcl;			/* control type identifier */

		/* grid cell data: */
	UINT	cbKt;			/* amount of extra control data in rgbKt */ 
	BYTE	rgbKt[];		/* grid control definition (size varies) */
	} GCA;					/* Grid Cell Attributes */ 

typedef GCA FAR *LPGCA;
typedef GCA BP(segGrid)		PGCA;
typedef GCA BPP(segGrid)	PPGCA;
typedef PPGCA BP(segGrid)	PPPGCA;

#define PktOfPpgca(ppgca)			PktOfPgca(*(ppgca))
#define	PktOfPgca(pgca)				(&(pgca)->rgbKt)

/* NOTE: returned lpkt is only valid until the next allocation in seg */
#define	LpktOfPgktd(pgktd) \
		(PktOfPgca(*(GCA LBP)(pgktd)->ppgca))
#define	LpktOfPgcad(pgcad) \
		(PktOfPgca(*(GCA LBP)(pgcad)->ppgca))

#define	FreePpgcaInSeg(ppgca,seg)	FreePpb(seg,ppgca)

typedef struct _gc 
	{
	PPGCA	ppgca;			/* grid cell attributes */

		/* grid cell data: */
	UINT	cbData;			/* amount of extra cell data in rgbData */ 
	BYTE	rgbData[];		/* client definable data (variable size) */ 
	} GC;					/* Grid Cell */ 

typedef GC FAR *LPGC;
typedef GC BP(segGrid)		PGC;
typedef GC BPP(segGrid)		PPGC;
typedef PPGC BP(segGrid)	PPPGC;

#ifdef __cplusplus
#pragma warning(default:4200)       // zero-size array
#endif // __cplusplus

/* Grid Attributes */
#define fGaLargeValues	0x00000001	/* allow cells to hold > cchGridMax bytes
									   of data; implies !fGaHoldData */
#define fGaSelRc		0x00000002	/* allow rectangular selection of multiple cells (not supported in V1) */
#define fGaSelDisc		0x00000004	/* allow disontiguous selections */
#define fGaSelRow		0x00000008	/* allow row selections */
#define fGaInsRow		0x00000010	/* allow insertion of new rows */
#define fGaClipRow		0x00000020	/* allow cut/copy/paste of rows */
#define fGaDelRow		0x00000040	/* allow deletion of rows */
#define fGaDragRow		0x00000080	/* allow row dragging (=reorder=move=cut/paste) */
#define fGaSelCol		0x00000100	/* allow column selections */
#define fGaInsCol		0x00000200	/* allow insertion of new columns */
#define fGaClipCol		0x00000400	/* allow cut/copy/paste of columns */
#define fGaDelCol		0x00000800	/* allow deletion of columns */
#define fGaDragCol		0x00001000	/* allow column dragging (=reorder=move=cut/paste) */
#define fGaSizeCol		0x00002000	/* allow column width dragging */
#define fGaSizeRow		0x00004000	/* allow row height dragging */
#define fGaScrollVert	0x00008000	/* allow vertical scrolling */
#define fGaDispVert		0x00010000	/* draw vertical grid lines */
#define fGaScrollHorz	0x00020000	/* allow horizontal scrolling */
#define fGaDispHorz		0x00040000	/* draw horizontal grid lines */
#define	fGaBordered		0x00080000	/* give the grid window a border */
#define	fGaDiffWidths	0x00100000	/* columns can have different widths */
#define	fGaDiffHeights	0x00200000	/* rows can have different heights */
#define fGaHoldData		0x00400000	/* grid will store the textual data */
#define fGaDynamicRows	0x00800000	/* grid must query client for # of rows */

									// WARNING - If you use fGaNeverActive for any other type 
									// ( other then dropdown combos )
									// you need to add a new style to id dropdown combos for WGridEvnet WM_MOUSEMOVE
#define fGaNeverActive	0x01000000	/* grid can never get the Windows focus
									   (used for dropdown combos) */
									
#define fGaHookKeys		0x02000000	/* give client a shot at all key/char msgs */
#define fGaFixed3D		0x04000000	/* display fixed cells as 3D-raised */
#define	fGaListbox		0x08000000	/* look and act like a single-select listbox */
#define fGaColumnar		0x10000000	/* set for grids having a column for each
									   element (e.g. query design) rather than
									   a row; may affect keyboard interface */
#define	fGaStaticRows	0x20000000	/* maintain the same total number of rows
									   even when rows of data are deleted */
#define fGaPinLastRow	0x40000000	/* don't scroll bottom row to top - 
									   assumed if fGaListbox, only valid if
									   !fGaDiffHeights */
#define	fGaAllowUndo	0x80000000	/* have the grid store Undo state */

/* extended attributes follow */
#define fGaExDragRc		0x00000001	/* allow drag-drop of rectangular selection */
#define fGaExLboxMult	0x00000002	/* if fGaListbox and fGaSelDisc, then a 
										listbox uses LBS_EXTENDEDSEL selection 
										model, if this is also set, 
										LBS_MULTIPLESEL model is used. */
#define fGaExAnimateRows 0x00000004	/* animate row deletes/inserts */
#define fGaExDiffOutside 0x00000008 /* erase outside of grid with desk color */
#define fGaExThumbtips	 0x00000010	/* Draw thumbtips when vertical thumb dragged */
#define fGaExCustomCf	 0x00000020	/* client names the clipboard format to be used for text-based ops (see 432) */
#define fGaExNoLiveScroll	0x00000040	/* Don't scroll while dragging thumb */
#define fGaExSunken			0x00000080  /* Grid is to be drawn with WS_EX_CLIENTEDGE style */
/* Grid Cell Attributes */
#define fGcaHoldData	0x0002	/* grid will store the textual data */
#define fGcaRefillData	0x0004	/* refill to get real data after every
								   user-commit (to show formatting, etc.) */
#define fGcaNoClickThru	0x0008	/* when unselected cell clicked, select it but
							 	   don't pass click through to cell proc */
#define fGcaDisabled	0x0010	/* cell cannot receive the focus */	
#define fGcaLocked		0x0020	/* cell can get focus but cannot be changed */							 
#define fGcaNotGrayed	0x0040	/* cell text not grayed even though disabled */							 
#define fGcaForceGetData 0x0080	/* always do GCL_GETDATA even if after DataMac
									ie. do not optimize for after end of data
									(useful for selection columns) */
#define fGcaForceStatic	0x0100	/* Pass fDsStatic to DispSzPb, even though
									it's not really a static item */							 
#define fGcaAuxButton	0x0200	/* It's an aux button -- don't paint if its not
								   enabled, don't let the user get here using
								   movement keys. */
#define fGcaCantTab		0x0400	/* cell can receive the focus via mouse click, 
									but not from key strokes */	

/* Grid Column/Row Attributes (also stored in grfGca) */
#define	fGcaNoSizeCol	0x1000	/* allow click & drag column resizing */
#define	fGcaNoSizeRow	0x2000	/* allow click & drag row resizing */
#define	fGcaNoSelCol	0x4000	/* allow column selection */
#define	fGcaNoSelRow	0x8000	/* allow row selection */

/* The following structures (GCID, GCAD, GKTD, GCLS, GROWS, GSIZ, GMID,
   GFUNC, GPOS, GSCR, GRPR) are used only as parameter blocks, never
   allocated or stored */

typedef struct GCID
	{
	ICOL	icol;
	IROW	irow;
	} GCID;		/* Grid Cell IDentifier */

typedef GCID FAR *LPGCID;

struct GCMD
	Derived(GCID)

	UINT wHt;		// hit region
	EndDerived;

typedef struct GCMD GCMD;
typedef GCMD FAR *LPGCMD;

/* return flags for WGridHitTest: */
#define wHtNone		0x0000
#define wHtTopGcol	0x0100
#define wHtSelGcol	0x0200
#define wHtSizeGcol	0x0300
#define wHtTopGrow	0x0400
#define wHtSelGrow	0x0500
#define wHtSizeGrow	0x0600
#define wHtSelGc	0x0800
#define wHtInGc		0x1000
#define wHtOutside	0x2000
#define wHtDisabled	0x4000
#define wHtDragSel	0x8000

struct GCAD
	Derived(GCID)

		/* this field is only used for G_SETCELLATTRS */
	UINT	grfSet;			/* mask of bits describing which attributes should
							   be set */

		/* this field is only used for G_GETCELLATTRS */
	SEG seg;				/* Grid's seg which PPGCA refers to */

		/* these fields may be used for either GET or SET */
	PPGCA	ppgca;		  	/* holds GCA allocated in grid's seg */

	GCA		gca;			/* at the end as its variable-length */
	EndDerived;	/* Grid Cell Attribute Descriptor */
	
typedef struct GCAD GCAD;
typedef GCAD FAR *LPGCAD;

typedef struct _gktd
	{
	SEG		seg;			/* returned grid's seg in which to allocate PPB
							   members of the desired KT */
	PPGCA	ppgca;			/* returned GCA containing a default control
							   instance of type hkcl */
	} GKTD;		/* Grid Kontrol Type Descriptor */

typedef GKTD FAR *LPGKTD;


struct GCLS
	Derived(GCID)
	union
		{
		DWORD	cb;		   /* length of data on a SETDATA */
		DWORD	cbBuf;	   /* size of buffer on a GETDATA */
		};
	union
		{
		CHAR	FAR *lsz;	/* hope to get rid of null termination */
		BYTE	FAR *lpb;
		};

	DWORD	cbActual;		/* client need only fill this on a GCL_GETDATA */
	union
		{					/* client should ensure these are initially 0: */
		LONG	ibStart;	/* starting point when getting data
							 * (G_GETDATA / GCL_GETDATA)*/
		BOOL	fNotDone;	/* flag used in Saving large values (GCL_SETDATA) */
		};

	/* these 2 fields are used on a GCL_GETDATA msg to get text formatting
	   info from clients that support it; all others can simply ignore them */
	struct TFIB *ptfib;	/* pointer to Text Formatting Info Block */
	INT dx;
	BOOL fUseFmt;		/* retrieved formatted data? */
	EndDerived;		/* Grid CLient String */
	
typedef struct GCLS GCLS;
typedef GCLS FAR *LPGCLS;

struct GCPRIV
	Derived(GCID)
	UINT	wId;			/* information identifier */

	VOID	FAR *lpv;		/* buffer pointer: use is wId-dependent */	

	EndDerived;		/* grid cell private info request */

typedef struct GCPRIV GCPRIV;
typedef GCPRIV FAR *LPGCPRIV;

typedef struct _grows
	{
	BOOL	fMoreRows;	/* client sets to FALSE if return value is final */
	UINT	wNum;		/* either wNumMin or wNumFinal (see below) */
	IROW	irowMin;	/* if wNumMin, return value must be either > irowMin
						   or final */
	UINT	crowScrollBelow;	/* if fMoreRows, scrollbar range max will be
								   set this far beyond the number of data rows
								   returned  */
	} GROWS;	/* used only for GCL_GETNUMROWS */

typedef GROWS FAR *LPGROWS;

/* possible values of GROWS.wNum: */
#define	wNumMin		1
#define	wNumFinal	2
#define	wNumReset	4

typedef struct _gsiz
	{
	union
		{
		ICOL	icol;
		IROW	irow;
		ICLRW	iclrw;
		};
	union
		{
		UINT	ccol;
		UINT	crow;
		UINT	cclrw;
		};
	union
		{
		UINT	dxtNew;
		UINT	dytNew;
		UINT	dtNew;
		};
	union
		{	/* when resizing multiple rows/cols, this will hold the old size
			   of the last one */
		UINT	dxtOld;
		UINT	dytOld;
		UINT	dtOld;
		};
	} GSIZ;	/* used only for G_SHOWCOLS/ROWS, GCN_SETCOLWIDTH/ROWHEIGHT */
	
typedef GSIZ FAR *LPGSIZ;

typedef struct _gmid
	{
	union
		{
		ICOL	icolSrc;
		IROW	irowSrc;
		ICLRW	iclrwSrc;
		};
	union
		{
		ICOL	icolDst;
		IROW	irowDst;
		ICLRW	iclrwDst;
		};
	union
		{
		LONG	ccol;
		LONG	crow;
		LONG	cclrw;
		};
	} GMID;	/* used for G/GCL_QRYMOV/INSERT/DELETECOLS/ROWS */
	
typedef GMID FAR *LPGMID;

struct _gfunc
	Derived(GCID)	/* cell identifier, use if wParam != 0 */
	UINT	(*pfn)(struct KPB *, LPVOID);
	LPVOID	lpvArg;
	EndDerived;		/* used only for G_CALLFUNC */

typedef struct _gfunc GFUNC;
typedef GFUNC FAR *LPGFUNC;

struct _gpos
	Derived(GCID)	/* cell (icol, irow) containing ptc, returned by grid */
	POINT		ptc;	/* point in client coordinates of the grid */
	EndDerived;		/* used only for G_GCIDOFPOS */

typedef struct _gpos GPOS;
typedef GPOS FAR *LPGPOS;

typedef	struct RCG
	{	/* like RECT, this rectangle doesn't include icolRight & irowBot */
	ICOL	icolLeft;
	IROW	irowTop;
	ICOL	icolRight;		
	IROW	irowBot;
	} RCG;	/* ReCtangle of Grid coordinates */

typedef RCG FAR		*LPRCG;

struct RCGSEL
	Derived(RCG)
	BYTE	grfSelTyp;
	BYTE	grfSelAnchor;
	EndDerived;			/* ReCtangular chunk of Grid SELection */

typedef struct RCGSEL RCGSEL;
typedef RCGSEL FAR	*LPRCGSEL;

typedef struct _gscr
	{
	INT		iFirst;
	INT		iLast;
	INT		iMult;	/* Actual Range = indicated range * iMult */
	BOOL	fHideScrollbar;
	} GSCR;		/* Grid SCRoll range */

typedef GSCR FAR	*LPGSCR;

typedef struct _gkpb
	{
	UINT (*pfnClient)(struct KPB *, LPVOID);
	struct KPB *pkpb;
	LPVOID lpv;
	UINT *pwRet;
	} GKPB;		/* used only by GCL_KPBCALL */

typedef GKPB FAR	*LPGKPB;

typedef struct _gnil
	{
	ICOL icol;
	IROW irow;
	CHAR FAR *lpch;
	UINT cch;
	} GNIL;		/* used only by GCN_NOTINLISTEVENT */

// Return values for GCN_NOTINLISTEVENT -- duplicated in ktcombo.h
//#define DATA_ERRCONTINUE	0
//#define DATA_ERRDISPLAY		1
//#define DATA_ERRADDED		2

typedef GNIL FAR	*LPGNIL;

typedef struct _gwpb
	{
	UINT (*pfnWpbHandler)(struct _wpb *);
	struct _wpb *pwpb;
	UINT *pwRet;
	} GWPB;		/* used only by GCL_WPBCALL */

typedef GWPB FAR	*LPGWPB;

struct GRPR
	Derived(RCG)				/* contains cell range to be printed */
	BOOLB	fPrintFixedCols;	/* if TRUE, fixed columns will be printed */
	BOOLB	fPrintFixedRows;	/* if TRUE, fixed rows will be printed */
	EndDerived;			/* GRid Print Range; used only by GCL_PRINT */

typedef struct GRPR GRPR;
typedef GRPR FAR	*LPGRPR;

/* types of grid selection (note that components of the grid selection
   (RCGSELs) must have grfSelTyp == fSelGcol or fSelGrow (fSelGc & fSelAll
   won't be supported in V1)): */
#define	bSelNil		0x00
#define	fSelGc		0x01
#define	fSelGcol	0x02
#define	fSelGrow	0x04
#define fSelAll		0x08

/* the overall selection (pgi->bSeltyp) can also contain these flags */
#define fSelComplex	0x10	/* contains mix of Gc, Gcol & Grow */
#define fSelDiscon	0x20	/* multiple components of Gc, Gcol or Grow */

/* anchor points: */
#define fSelLeft	0x01
#define fSelRight	0x02
#define fSelTop		0x04
#define fSelBot		0x08

/* flags for GridPaint, DrawGcs: */
#define	fDgPrint	0x0001
#define	fDgWipeData	0x0002
#define	fDgTryClip	0x0004
#define fDgNoGridLn	0x0008

typedef	HANDLE	HGDATA;

#define	cchGridMax	1024	/* maximum string length in a HoldData grid */	
#define	crowGridDft	 200	/* default no. of rows if client specifies -1 */
#define	crowScrollDft	100	/* for grids with dynamic no. of rows assume 
							   this many past irowDataMac unless client
							   overrides via GCL_GETNUMROWS msg */

/* structure for the G_GRIDLINES message */
typedef struct _glns
	{
	UINT appearLines;
	UINT grfLines;
	COLORREF crLines;
	UINT grfSet;
	} GLNS, *LPGLNS;

/* flags for grfLines */
#define fGlnNone	0
#define fGlnHoriz	1
#define fGlnVert	2
#define fGlnBoth	3
#define fGlnV2		0xFF	// take setting from v2.0

/* flags for grfSet */
#define fSetAppear	0x0001
#define fSetLines	0x0002
#define fSetColor	0x0003
#define fSetAll		(fSetAppear | fSetLines | fSetColor)

/* bits for GCL_KEYMSG */
#define	bitfFromKt		0x0001
#define bitfNoAccel		0x0002
#define bitfOnlyAccel	0x0004

/* Grid CLient messages:

Sent to the Grid CLient callback by the grid; the client is responsible for
displaying alerts before returning error values to the grid.

GCL_INIT: Guaranteed to be the first message sent to the client proc, sent
	right after the window has been initialized
 Criteria:
 wParam: HWND of new grid window
 lParam: DWORD client passed to HwndGridCreate in lpgrid->dwClient
 Return: 0L if successful, error != 0 if unsuccessful (will cause
	HwndGridCreate to fail/ErrJump)

GCL_GETDATA: Gets the cell string from the client
 Criteria: !fGaHoldData, !fGcaHoldData
 wParam: 
 lParam: LP to GCLS in DS pointing to icol, irow, pb & cbMax of buffer to
 	copy string into, and data offset ibStart; user should return the actual
 	size of its data (which might be > than cbMax) in cbActual
 Return: 0L if successful, error != 0 if unsuccessful
 	NOTE: If buffer not large enough, client should return error with
 		  required size in gcls.cb.

GCL_SETDATA: Tries to commit the modified cell string to the client
 Criteria: 
 wParam:
 lParam: LPGCLS pointing to icol, irow, buffer containing string, size
 Return: 0L if successful, != 0 if unsuccessful or disallowed by client
	NOTE: If the client saves the data that the grid was about to save, then
	  they should return idaInternalWarnSaveData to the grid to let it know
	  that the save succeeded (and thus no error should be reported) but that
	  the grid doesn't need to do any more work.

GCL_QUERYFOCUS: Request to set the focus to the specified cell. Sent before
	any action is taken. Don't send a G_SETFOCUS msg here to have the
	currency moved elsewhere; instead just update LPGCID->icol/irow.
	NOTE: this msg is sent when a disabled cell is clicked on to allow the
	client to set the focus elsewhere as a result. It is also sent when the
	cell becoming current already is (though GCL_SETFOCUS won't be)
 Criteria: 
 wParam: UINT *pgrfGcSet; if wGcSetCur, only changes currency; if wGcSetCaret
 		 also sets caret; if wGcSetFocus also tries to move input focus.
 		 Client may modify this.
 lParam: LPGCID specifying icol, irow; client may modify this to cause a
 	different cell to get the focus.
 Return: 0L if allowed; != 0 to disallow (client should display error)

GCL_SETFOCUS: Attempt to set the focus to the specified cell.  Sent after
	contents of current cell have been committed.
 Criteria: 
 wParam: if wGcSetCur, only changes currency; if wGcSetCaret also sets caret;
		 if wGcSetFocus also tries to move input focus
 lParam: LPGCID specifying icol, irow
 Return: 0L if successful; != 0 if unsuccessful (client should display error)

GCL_MOUSEACTIVATE: Notify client that a grid window has been clicked on,
	giving it the opportunity to preempt the BUTTONDOWN
 Criteria: 
 wParam: mouse msg # (from WM_MOUSEACTIVATE)
 lParam: LPGCID specifying icol, irow where the click occurred
 Return: 0L by default; != 0 to eat the ensuing WM_?BUTTONDOWN msg

GCL_BEGINEDIT: Pre-emptable notification that a cell's value has changed
 Criteria: 
 wParam: 
 lParam: LPGCID specifying icol, irow
 Return: 0L if allowed; != 0 to disallow (client should display error)

GCL_QUERYDROPOBJECT: ask client whether it is willing to accept a drop
 Criteria: 
 wParam:
 lParam: LPGRDROP containing DROP, ICOL, IROW
 Return: 0 to decline object drop, != 0 to accept

GCL_DROPOBJECT: inform client that an object is being dropped on it
 Criteria: 
 wParam:
 lParam: LPGRDROP containing DROP, ICOL, IROW
 Return: 0 if object drop fails, != 0 if successful

GCL_GETNUMROWS: ask client for current, minimum or final # of rows
 Criteria: fGaDynamicRows
 wParam: 
 lParam: GROWS FAR *: client sets fMoreRows to FALSE if # returned is final;
 	wNum is wNumFinal if final # required, wNumMin if minimum # required
 	(if # returned is less than the irowMin it must be final
 	 i.e. fMoreRows must be FALSE).
 	Client can also set lpgrows->crowScrollBelow to the desired number
 	of rows between the returned row count and the scrollbar range maximum.
 Return: DWORD containing the # of rows

GCL_KEYMSG: give client a chance to intercept a key msg (gets called for
	every WM_CHAR or WM_KEYDOWN message that will otherwise go to the
	grid's current control.
	CLIENTS: how are you using this? what would you like to see in lParam?
 Criteria: 
 wParam: WPB * describing the message
 lParam: Information bits, bitfFromKt if key msg is being handled by a KT's 
	 wndproc, bitfNoAccel if client should look for accelerators, bitfOnlyAccel 
	 if client should ONLY look for accelerators
 Return: 0 to let message go to control, != 0 to intercept

GCL_MOUSEMSG: give client a chance to intercept a mouse message
 Criteria: 
 wParam: WPB * describing the message
 lParam: LPGCMD containing icol, irow clicked on
 Return: 0 to let message go to control, != 0 to intercept

GCL_LBOXSEL: The selection in a listbox has changed.
 Criteria: fGaListbox
 wParam: TRUE if the focus is in the listbox (focus rect displayed around
 	the selection), FALSE otherwise
 lParam: IROW describing the newly selected row
 Return: 0L if allowed; != 0 to disallow

(CONSIDER) GCL_LBOXTRACK: The selection in a listbox is tracking (mouse button still
	down) over a row

GCL_STARTTRACK: The user has initiated a mouse-tracking operation (e.g. row,
	column, cell selection, or row/column resizing).
 Criteria: 
 wParam: the msop code of the mouse operation being initiated
 lParam: LPGCID describing the column, row or cell being selected or sized;
		 if only a row or col is being used, the other value in the gcid will
		 be set to icolNil or irowNil, respectively.
 Return: 0L if allowed; != 0 to disallow


NOTE: the following 6 messages allow the grid client to modify the parameters
	pointed to by ((LPGMID) lParam); if this is desired, the client should
	indicate success by returning 0, as a non-zero return value preempts the
	operation completely.

GCL_QRYINSCOLS: User is inserting grid columns
 Criteria: 
 wParam: TRUE if initiated via a G_INSERTCOLS, FALSE if from UI
 lParam: LPGMID containing icolDst, ccol to insert; see NOTE above
 Return: 0L to allow, != 0 to disallow

GCL_QRYINSROWS: User is inserting grid rows
 Criteria: 
 wParam: TRUE if initiated via a G_INSERTROWS, FALSE if from UI
 lParam: LPGMID containing irowDst, crow to insert; see NOTE above
 Return: 0L to allow, != 0 to disallow

GCL_QRYDELCOLS: User is deleting grid columns
 Criteria: 
 wParam: TRUE if initiated via a G_DELETECOLS, FALSE if from UI
 lParam: LPGMID containing icolSrc, ccol to delete; see NOTE above
 Return: 0L to allow, != 0 to disallow

GCL_QRYDELROWS: User is deleting grid rows
 Criteria: 
 wParam: TRUE if initiated via a G_DELETEROWS, FALSE if from UI
 lParam: LPGMID containing irowSrc, crow to delete; see NOTE above
 Return: 0L to allow, != 0 to disallow

GCL_QRYMOVCOLS: User is moving grid columns
 Criteria: 
 wParam: TRUE if initiated via a G_MOVECOLS, FALSE if from UI
 lParam: LPGMID containing icolSrc, ccol & icolDst to move between;
 	see NOTE above
 Return: 0L to allow, != 0 to disallow

GCL_QRYMOVROWS: User is moving grid rows
 Criteria: 
 wParam: TRUE if initiated via a G_MOVEROWS, FALSE if from UI
 lParam: LPGMID containing irowSrc, crow & irowDst to move between;
 	see NOTE above
 Return: 0L to allow, != 0 to disallow

GCL_SCROLLRANGE: notify client that a scroll bar's range is being set;
	client can alter the scroll range
 wParam: LoByte: scroll bar to range (SB_HORZ or SB_VERT)
 		 HiBYte: TRUE to redraw scrollbar
 lParam: LPGSCR to iMin, iMac defining range
 Return: 0 to allow grid to do it, != 0 if operation performed or preempted
 	by the client

GCL_SCROLLPOS: notify client that a scroll bar's thumb postion is being set;
	client can alter this position.
 wParam: LoByte: scroll bar to range (SB_HORZ or SB_VERT)
 		 HiBYte: TRUE to redraw scrollbar
 lParam: (UINT FAR *) pointing to ithumb position being set to
 Return: 0 to allow grid to do it, != 0 if operation performed or preempted
 	by the client

GCL_BEGINUNDO: let client preempt grid taking ownership of the Undo buffer
 wParam: undo code (see undo.h)
 lParam: The ids for the undo menu item.
 Return: 0 to let grid own the Undo buffer, > 0 if client already called
 	BeginUndoRecord for this undoable action.
(CONSIDER) letting client return < 0 to avoid Undo recording completely

GCL_RECORDUNDO: let client preempt grid recording an undo atom.
 wParam: undo code: one of ungrOpEditCell, ungrOpRowInsert, ungrOpRowDelete,
 			ungrOpRowMove, ungrOpCut, ungrOpResize
 lParam: 
 Return: 0 to let grid record an undo atom, != 0 grid will not record atom

GCL_EMPTYUNDO: let client preempt grid emptying the Undo buffer; in this case
	the client should call EmptyUndo to free this undoable action with the
	same HWND it passed to BeginUndoRecord.
 wParam: 
 lParam: 
 Return: 0 to let grid own the Undo buffer, > 0 if client calls	EmptyUndo itself

GCL_SELCHANGE: The current column or row selection has changed
 Criteria: 
 wParam: grfSelTyp (see bSel* #define's above)
 lParam: LPRCGSEL containing newly added selection rectangle if
 	wParam != bSelNil, 0L if wParam == bSelNil
 Return: 0 to allow, != 0 to preempt. 
 	NOTE: the client can't preempt collapsing the selection

GCL_PRINT: Let the client change the area to be printed
 Criteria: 
 wParam: 
 lParam: LPGRPR containing the grid range that will be printed; the client can
 	modify this
 Return: 0 to allow, != 0 to preempt printing altogether

GCL_INSERTROWS: Insert grid rows, Sent even when client instigated.
 Criteria: 
 wParam: 
 lParam: LPGMID containing irowDst, crow to insert
 Return: 0L to allow, < 0 to disallow

GCL_DELETEROWS: Delete grid rows. Sent even when client instigated.
 Criteria: 
 wParam: 
 lParam: LPGMID containing irowSrc, crow to delete
 Return: 0L to allow, < 0 to disallow

GCL_MOVEROWS: Move grid rows. Sent even when client instigated.
 Criteria: 
 wParam: 
 lParam: LPGMID containing irowSrc, crow & irowDst to move between
 Return: 0L to allow, < 0 to disallow

 **Note on GCL MoveRows/Cols:
	When the GCL Move message is sent, irowSrc is the source row/col
	to start moving from, and irowDst is the destination row/col to
	move to.  However, when the GCL notification message is sent
	this information is historical.  That is to say, if a row
	is moved down, from row 2 to row 6, at GCL_QRYMOVROWS time
	irowSrc is 2 and irowDst is 6.  But when the GCL_MOVEROWS message
	is sent, the move has already occurred, so row 6 is now row 5, because
	row 2 is gone. 	Nonetheless, the value of irowDst is still 6.
	Note too that if the client is calling AdjCci at the time that
	the GCL is sent, this will work correctly, since AdjCci corrects
	for this behavior.  Also, there is no such problem if a row/col
	is moved up.

GCL_GETROB:
 Criteria: 
 wParam:
 lParam: LPGCID pointing to icol
 Return: != 0L if successful, != 0 if unsuccessful

GCL_GETIVRCONTEXT:
 Criteria: 
 wParam:
 lParam:
 Return: >= 0L if successful, ivrNil (-1) if unsuccessful

GCL_GETCCHTEXTMOST: get limit on number of chars in given cell
 Criteria: 
 wParam:
 lParam: LPGCID specifying icol, irow
 Return: 0xfffffff for unlimited, 0L for use grid default, max number of
	characters acceptable by client for this control

GCL_GETPRIVINFO: control request for private info from client
 Criteria: 
 wParam:
 lParam: LPGCPRIV specifying icol, irow, info request, buffer pointer
 Return: != 0L if succesful, 0 if unsuccessful 

GCL_KPBCALL: helper to set up the form state, call the specific client
	routine, and reset the form state back before return.
 Criteria: 
 wParam:
 lParam: LPGKPB specifying the client routine, pkpb, lpv, and pwRet.
 Return: != 0L if client handles, 0 if grid should call the routine itself 
	If client handles, *pwRet is filled in with routine's return value. 

GCL_WPBCALL: helper to set up the form state, call the specific WPB handler,
	and reset the form state back before return.
 Criteria: 
 wParam:
 lParam: LPGWPB specifying the client routine, pwpb,and pwRet.
 Return: != 0L if client handles, 0 if grid should call the routine itself.
	If client handles, *pwRet is filled in with routine's return value. 

GCL_PREPAINT: Sent just before the grid handles a WM_PAINT message
	This gives the client an opportunity to do something before the grid
	paints or to preempt the paint and simply erase.
 wParam:
 lParam:
 Return: 0 to continue with paint, != 0 to erase the background but avoid
 	the paint (so a GCN_POSTPAINT won't be sent)

GCL_REMOTEDATA: Sent to ask if the specified column's data comes from a
	remote source
 wParam: 
 lparam: iCol to check
 Return: TRUE if data is remote, FALSE otherwise

GCL_EXPANDCELL: Sent to ask if expand cell capability is on
 wParam: 
 lparam: iCol to check
 Return: 0 if expand cell capability is off, != 0 if expand cell capability
	is off

GCL_GETCOLTYP: Sent to ask the coltyp of the specified column
 wParam: 
 lparam: iCol to check
 Return: coltyp (unsigned long)

GCL_GETORSCONTEXT:
 wParam:
 lParam:
 Return: orsContxt of the current form

GCL_GETHINST:
 wParam:
 lParam:
 Return: hinst of the current form

GCL_GRIDCURSOR:
 wParam: msop indicating potential grid cursor
 lParam: 0
 Return: 0 to allow cursor, != 0 to disallow

GCL_LOCKBYTES: Get an ILockBytes interface from the grid container
 wParam: VOID ** to store the interface in
 lParam: GCPRIV *, holding icol/irow and wId as BOOL for fWrite
 Return: idaSuccess, or error code

GCL_AUTOCORRECT: Get whether a column can autocorrect
 wParam:
 lParam: icol of column to get info on
 Return: TRUE to allow, FALSE to disallow
 
The following messages are notifications sent from the grid to the client:

GCN_INSERTCOLS: Insert grid columns. Sent even when client instigated.
 Criteria: 
 wParam: 
 lParam: LPGMID containing icolDst, ccol to insert
 Return: ignored (can't be disallowed/rolled back)

GCN_DELETECOLS: Delete grid columns, Sent even when client instigated.
 Criteria: 
 wParam: 
 lParam: LPGMID containing icolSrc, ccol to delete
 Return: ignored (can't be disallowed/rolled back)

GCN_MOVECOLS: Move grid columns. Sent even when client instigated.
 Criteria: 
 wParam: 
 lParam: LPGMID containing icolSrc, ccol & icolDst to move between
 Return: ignored (can't be disallowed/rolled back)

GCN_SETCOLWIDTH: The user has changed the specified column's width.
	If the new value is 0, grid will treat as hidden rather than resized.
 Criteria: fGaSizeCol
 wParam:
 lParam: LPGSIZ containing icol, ccol, dxtNew, dxtOld of last col sized
 Return: 

GCN_SETROWHEIGHT: The user has changed the specified row's height.
	If the new value is 0, grid will treat as hidden rather than resized.
 Criteria: fGaSizeRow
 wParam: 
 lParam: LPGSIZ containing irow, crow, dytNew, dytOld of last row sized
 Return: 

GCN_ACTIVATE: Notify the client of a grid's (de)activation via a WM_SETFOCUS
	or WM_KILLFOCUS message.
 Criteria: 
 wParam: FALSE if being deactivated, TRUE if being activated
 lParam: 
 Return: 


(CONSIDER) GCN_ENTERQUERYDROP: sent when object first dragged over client

(CONSIDER) GCN_EXITQUERYDROP: sent when object stops being dragged over client

GCN_SCROLLBAR: Sent when the grid adds or removes scroll bars
	The client may want to adjust its size, since the addition or removal
	of scroll bars causes the grid to become smaller or larger.
 Criteria: 
 wParam: Scroll bar added (SB_HORZ or SB_VERT)
 lParam: 0 = removed; 1 = added
 Return: Ignored

GCN_FREEZE: Sent when rows or columns are frozen or unfrozen.
 Criteria: 
 wParam: TRUE: rows; FALSE: columns
 lParam: irowMac - the last row that is now frozen
 Return: Ignored

GCN_POSTPAINT: Sent just after the grid handles a WM_PAINT message; will not
	be sent if the client preempted the paint via GCL_PREPAINT.
	This gives the client an opportunity to do something after the grid
	paints.
 wParam:
 lParam:
 Return: Ignored

GCN_FOCUSSET: Sent after the focus has been set to the specified cell,
	only if the focus has actually moved to a different cell.
 wParam:
 lParam: LPGCID specifying icol, irow
 Return: Ignored

GCN_UNDOSTATCHANGE: Notification from a control that its Undo status has changed
 Criteria: 
 wParam:
 lParam: 
 Return: Ignored

GCN_RECURSIVESAVE: Notification to client that grid is about to fail a
 recursive attempt to save a value.  Client can use this notification to
 put up appropriate error mesage.
 wParam:
 lParam:
 Return: Ignored

GCN_SELCHANGED: Notification to client that the grid has finished changing the
  selection and that it has updated all internal structures (so that G_GETSEL
  will return the current selection)
 wParam: grfSelTyp (see bSel* #define's above)
 lParam: LPRCGSEL containing newly added selection rectangle if
 	wParam != bSelNil, 0L if wParam == bSelNil
 Return: Ignored

GCN_NOTINLISTEVENT: Notification to client that a combo match has failed.
 wParam: 0
 lParam: LPGNIL containing information about failed match
 Return: DATA_ERRCONTINUE, DATA_ERRDISPLAY, DATA_ERRADDED

GCN_THUMBTRACK: Sent to client while tracking thumb
 wParam: TRUE if vertical scrollbar, FALSE if horizontal
 lParam: Row that would be scrolled to if thumb released
 Return: Ignored


*/

#define GCL_GETDATA			(WM_GRIDSTART + 0)
#define GCL_SETDATA			(WM_GRIDSTART + 1)
#define GCL_SETFOCUS		(WM_GRIDSTART + 2)
#define	GCL_MOUSEACTIVATE	(WM_GRIDSTART + 3)
#define	GCL_BEGINEDIT		(WM_GRIDSTART + 4)
#define GCL_QUERYFOCUS		(WM_GRIDSTART + 5)
#define GCL_INIT			(WM_GRIDSTART + 6)
#define GCL_QUERYDROPOBJECT	(WM_GRIDSTART + 7)
#define GCL_DROPOBJECT		(WM_GRIDSTART + 8)
#define GCL_GETNUMROWS		(WM_GRIDSTART + 9)
#define GCL_KEYMSG			(WM_GRIDSTART + 10)
#define GCL_QRYINSCOLS		(WM_GRIDSTART + 11)
#define GCL_QRYINSROWS		(WM_GRIDSTART + 12)
#define GCL_QRYDELCOLS		(WM_GRIDSTART + 13)
#define GCL_QRYDELROWS		(WM_GRIDSTART + 14)
#define GCL_QRYMOVCOLS		(WM_GRIDSTART + 15)
#define GCL_QRYMOVROWS		(WM_GRIDSTART + 16)
#define GCL_LBOXSEL			(WM_GRIDSTART + 17)
#define GCL_STARTTRACK		(WM_GRIDSTART + 18)
#define GCL_SELCHANGE		(WM_GRIDSTART + 19)
#define GCL_MOUSEMSG		(WM_GRIDSTART + 20)
#define GCL_SCROLLRANGE		(WM_GRIDSTART + 21)
#define GCL_SCROLLPOS		(WM_GRIDSTART + 22)
#define GCL_BEGINUNDO		(WM_GRIDSTART + 23)
#define GCL_EMPTYUNDO		(WM_GRIDSTART + 24)
#define	GCL_GETPCONTROL		(WM_GRIDSTART + 25)
#define GCL_PRINT			(WM_GRIDSTART + 26)
#define	GCL_GETIVRCONTEXT	(WM_GRIDSTART + 27)
#define GCL_GETCCHTEXTMOST	(WM_GRIDSTART + 28)
#define GCL_GETPRIVINFO		(WM_GRIDSTART + 29)

#define GCN_SETCOLWIDTH		(WM_GRIDSTART + 30)
#define GCN_SETROWHEIGHT	(WM_GRIDSTART + 31)
#define GCN_UNDOSTATCHANGE	(WM_GRIDSTART + 32)
#define GCN_INSERTCOLS		(WM_GRIDSTART + 33)
#define GCL_INSERTROWS		(WM_GRIDSTART + 34)
#define GCN_DELETECOLS		(WM_GRIDSTART + 35)
#define GCL_DELETEROWS		(WM_GRIDSTART + 36)
#define GCN_MOVECOLS		(WM_GRIDSTART + 37)
#define GCL_MOVEROWS		(WM_GRIDSTART + 38)
#define GCN_ENDEDIT			(WM_GRIDSTART + 39)
#define GCN_SCROLLBAR		(WM_GRIDSTART + 40)
#define	GCN_ACTIVATE		(WM_GRIDSTART + 41)
#define	GCN_FREEZE			(WM_GRIDSTART + 42)
#define GCL_PREPAINT		(WM_GRIDSTART + 43)
#define GCN_FOCUSSET		(WM_GRIDSTART + 44)
#define GCN_POSTPAINT		(WM_GRIDSTART + 45)

#define	GCL_KPBCALL			(WM_GRIDSTART + 46)

#define GCL_RECORDUNDO		(WM_GRIDSTART + 47)

#define GCL_WPBCALL			(WM_GRIDSTART + 48)

#define GCL_REMOTEDATA		(WM_GRIDSTART + 49)

#define GCL_EXPANDCELL		(WM_GRIDSTART + 50)

/* GCN_RECURSIVESAVE and GCN_SELCHANGED is defined below, because we're
of acceptable values here. */

/* Grid messages (start at WM_GRIDSTART + 50):

Sent to the Grid window proc by the grid client:

G_GETDATA: Retrieve the text from the grid
			(side effect: if the grid cell is dirty, force a commit.)
 Criteria: fGaHoldData
 wParam: 
	wGetDataNormal		- Standard GETDATA behavior
	wGetDataNoCommit	- Dont commit even if the cell is dirty
 lParam: LPGCLS pointing to icol, irow, buffer length, buffer to
 	copy string into. NOTE: Make sure to set ibstart to be the
	correct value. Random values (esp. with the grid holding data)
	can get nasty!
 Return: 0L if successful, errVal otherwise (e.g. OOM)

G_SETDATA: Initialize the text in the grid
 Criteria: fGaHoldData
 wParam:
	wSetDataNormal		- Standard SETDATA behavior
	wSetDataUpdScroll	- Update scrollbars immediately as necessary
	wSetDataTransient	- Data is "transient". Dont update DataMac
 		 NOTE: optimize by passing wSetDataNormal and sending a
 		 	G_UPDATE(wUpdScroll) msg after all G_SETDATA msgs are sent.
 lParam: LPGCLS pointing to icol, irow, string length (cb), and buffer (lpb/lsz)
 		 to copy string from. NOTE: client can pass cb=0 & lsz != lpNil and
 		 the grid will set gcls.cb=CchLsz(lsz)
 Return: 0L if successful, errVal otherwise (e.g. OOM)

G_CLEARDATA: Free up grid-owned data and invalidate its window
 Criteria: fGaHoldData
 wParam: one of		fGClearAll	- clear all cells
 					fGClearScr	- clear all scrollable cells, not headers
 lParam: unused
 Return: 

G_GETFOCUS: Returns the current cell position (one with the focus)
 Criteria: 
 wParam: if fLboxFocus, then give back real value if in the middle of setting
		 the listbox focus. NOTE: The listbox code is the ONLY code that should
		 use this. It's a mega-hack. See FSetLboxFocus as to why you'd use it.
 lParam: LPGCID containing icolCur, irowCur
 Return: 

G_SETFOCUS: Sets the current cell position (possibly giving it the input focus)
 Criteria: !fGcaDisabled
 wParam: if wGcSetCur, only changes currency; if wGcSetCaret also sets caret;
		 if wGcSetFocus also tries to move input focus if grid already has it
		 (use to wGcForceFocus to ensure the grid gets the input focus),
		 if fGcForceCur is set, force current cell to change even if
		 		commit fails. 
 lParam: LPGCID specifying icol & irow
 Return: 0 if successful

G_GETCOLWIDTH: Get the specified column's width
 Criteria: 
 wParam: != 0 to get pixels, 0 for twips
 lParam: icol 
 Return: MakeLong(column width, 0)

G_GETROWHEIGHT: Get the specified row's height
 Criteria: 
 wParam: != 0 to get pixels, 0 for twips
 lParam: irow
 Return: MakeLong(row height, 0)

G_SETCOLWIDTH: Set the specified column's width
 Criteria: fGaDiffWidths (unless icol == icolNil)
 wParam: column width (in twips), -1 for best fit
 lParam: icol (if == icolNil, changes width of all columns)
 Return: 0 if resized, > 0 if no change, < 0 on error

G_SETROWHEIGHT: Set the specified row's height
 Criteria: fGaDiffHeight unless irow == irowNil
 wParam: row height (in twips)
 lParam: irow (if == irowNil, changes height of all rows)
 Return: 0 if resized, > 0 if no change, < 0 on error

G_SHOWCOLS: Show or hide the specified columns; showing a hidden column will
	set it to the default width.
 Criteria: fGaDiffWidths (unless icol == icolNil)
 wParam: TRUE to show, FALSE to hide
 lParam: LPGSIZ containing icolSrc, ccol defining column range to Show/Hide
 Return: 0 if resized, > 0 if no change, < 0 on error

G_SHOWROWS: Show or hide the specified rows; showing a hidden row will
	set it to the default height.
 Criteria: fGaDiffHeights (unless irow == irowNil)
 wParam: TRUE to show, FALSE to hide
 lParam: LPGSIZ containing irowSrc, crow defining row range to Show/Hide
 Return: 0 if resized, > 0 if no change, < 0 on error

G_FREEZECOLS: Either freeze the specified columns (first moving them to the
	left of all unfrozen cols) or unfreeze all frozen columns
 Criteria: 
 wParam: TRUE to freeze, FALSE to unfreeze
 lParam: LPGMID containing icolSrc, ccol defining column range to freeze if
 	wParam TRUE; unused if wParam FALSE
 Return: 0 if successful, != 0 otherwise

G_FREEZEROWS: Either freeze the specified rows (first moving them above all
	unfrozen rows) or unfreeze all frozen rows
 Criteria: 
 wParam: TRUE to freeze, FALSE to unfreeze
 lParam: LPGMID containing irowSrc, crow defining row range to freeze if
 	wParam TRUE (if NULL, use selected/current rows); unused if wParam FALSE
 Return: 0 if successful, != 0 otherwise

G_GETCELLATTRS: Get the current cell/col/row attributes
 Criteria: 
 wParam: 
 lParam: LPGCAD pointing to icol & irow identifying cell, GCA to hold current
 		 attribute values; if icol == icolNil get row defaults,
 		 if irow == irowNil get col defaults,
 		 if both == Nil get grid defaults, if neither get cell attributes
 Return: 0L always (can't fail)

G_SETCELLATTRS: Set the default column, default row or cell attributes
 Criteria:
 wParam: wNoInval (0) for no invalidation; otherwise may combine:
 	fInvalCellBits to simply repaint,
 	fInvalData to cause control to refill with current data,
 	fInvalAttrs to cause visible controls to reset with current attributes.
 lParam: LPGCAD pointing to icol & irow identifying cell, GCA holding new
 		 attribute values; if icol == icolNil set row defaults,
 		 if irow == irowNil set col defaults,
 		 if both == Nil set grid defaults, if neither set cell attributes

 		 if lpgcad->grfSet != fSetAll then only the attributes described by
 		 this bitmask (see values specified below) will be changed; this
 		 obviates the need for most G_GETCELLATTRS calls
 Return: 0L if successful, errVal otherwise (e.g. OOM)
 	NOTE: if an error value is returned it's the client's responsibility
 		to free any PPGCA previously allocated via a G_CREATEKT call

G_CREATEKT: Allocate and return a PPGCA containing a default KT of the
	specified type. Client should then set all specific KT info (via
	LpktOfPgktd macro) before calling G_SETCELLATTRS.
 Criteria: 
 wParam: hkcl (type of kt) to create
 lParam: LPGKTD returning the allocated PPGCA and SEG it was allocated out of.
 Return: 0 if succesful, != 0 otherwise
	NOTE: if there are errors between this call's successful return and
		a successful return of G_SETCELLATTRS the client must clean up
		via FreePpgcaInSeg (gktd.ppgca, gktd.seg)
	NOTE: The returned PPGCA is owned by the grid, and the grid may
		deallocate it anytime after it has been used in a G_SETCELLATRS call.
		Specifically, G_SETCELLATTRS with fSetPpgca deallocates the
		PPGCA that was previously set.  Therefore, the client should not
		expect to be able to hold on to the PPGCA that this call provides.

G_ACTNOTIFY: Notify the grid of its "active" state (corresponds to Windows
	activation).  Note that this does not itself transfer focus.  When
	client wants grid (or a control within it) to get focus, then client
	should SetKeyFocus to grid.
 Criteria: 
 wParam: != 0 on activation, == 0 on deactivation
 lParam: 
 Return: 

G_INVALCELL: Invalidate the specified cell, row or column
 Criteria: 
 wParam: may combine:
 	fInvalCellBits to simply repaint cell data,
 	fInvalAllBits to erase and repaint,
 	fInvalData to cause current control to refill with current data,
	fInvalDataClean to cause current control to refill with current data only
		if not dirty,
 	fInvalAttrs to cause current control to reset with current attributes.
	fInvalSource to cause current control's data source to get reinitialized
	fInvalSourceCols to cause specified columns' data sources to get reinitialized
	fInvalSourceRows to cause specified rows' data sources to get reinitialized
	
 lParam: LPGCID pointing to icol & irow identifying cell/row/col to invalidate
 		 if icol == icolNil invalidate irow'th row,
 		 if irow == irowNil invalidate icol'th col,
 		 if both == Nil invalidate entire grid
 Return: 

G_UPDATE: Call this to initialize scrollbars after all G_SETDATA calls
 Criteria: fGaHoldData
 wParam: if wLimitRows, set the number of visible rows (irowRegMac) equal to
 		 the number that currently have data (irowDataMac); if wExactRows,
 		 set the number of rows to lParam; if wUnlimitRows, reset the
 		 number of rows to crowsGridDft; if wDynamicRows, reset grid to ask
 		 client for rows as necessary (as for fGaDynamicRows); if wUpdScroll,
 		 simply update the scrollbar.
 lParam: the number of visible rows if wParam == wExactRows
 Return: 

G_INSERTCOLS: Insert grid columns
 Criteria: 
 wParam: UINT # of cols to insert
 lParam: ICOL to insert in front of (if icolNil, uses icolCur)
 Return: 0L if successful, > 0 if canceled, < 0 on error (e.g. OOM)

G_INSERTROWS: Insert grid rows
 Criteria: 
 wParam: UINT # of rows to insert
 lParam: IROW to insert in front of (if irowNil, uses irowCur)
 Return: 0L if successful, > 0 if canceled, < 0 on error (e.g. OOM)

G_DELETECOLS: Delete grid columns
 Criteria: 
 wParam: UINT # of cols to delete
 lParam: ICOL to start deleting at (if icolNil, uses icolCur & dels selection)
 Return: 0L if successful, > 0 if canceled, < 0 on error (e.g. OOM)

G_DELETEROWS: Delete grid rows
 Criteria: 
 wParam: UINT # of rows to delete
 lParam: IROW to start deleting at (if irowNil, uses irowCur & dels selection)
 Return: 0L if successful, > 0 if canceled, < 0 on error (e.g. OOM)

G_MOVECOLS: Move grid columns
 Criteria: 
 wParam: 
 lParam: LPGMID containing icolSrc, ccol & icolDst to move between
 Return: 0L if successful, > 0 if canceled, < 0 on error (e.g. OOM)

G_MOVEROWS: Move grid rows
 Criteria: 
 wParam: 
 lParam: LPGMID containing irowSrc, crow & irowDst to move between
 Return: 0L if successful, > 0 if canceled, < 0 on error (e.g. OOM)

G_GETDATAMAC: Return the number of columns and rows containing data.
 Criteria: 
 wParam: 
 lParam: LPGCID holding icolDataMac, irowDataMac
 Return: 

G_COMMITCELL: Commit the current cell if dirty
	Note: cell will refill with (potentially reformatted) data after commit
 Criteria: 
 wParam: if fGcForceCur, reset dirty flag even if commit fails.
			Note: will still report failure if this flag is set.
		 if fGcForceCommit, will mark cell dirty before trying commit.
 lParam: 
 Return: 0 if successful, != 0 otherwise

G_GRIDLINES: Set grid line options and redraw
 Criteria: 
 wParam: Nothing
 lParam: LPGLNS of options to set
 Return: 

G_DFTROWHEIGHT: get the default row height based on the font of the specified 
				cell/row/column/grid
 Criteria: 
 wParam: != 0 to get pixels, 0 for twips
 lParam: LPGCID pointing to icol & irow identifying cell;
 		 if icol == icolNil get row defaults,
 		 if irow == irowNil get col defaults,
 		 if both == Nil get grid defaults, if neither get cell attributes
 Return: row height (returns grid default if OOM occurs)

G_GETSEL: get the current grid selection (see bSel* #define's above)
 Criteria: 
 wParam: 0 to get first component of selection, 1 to get second (if selection
 	was discontiguous), 2 to get third ...
 lParam: LPRCGSEL returning the desired selection info; if there's no selection
 	 lpgsel->grfSelTyp will be bSelNil and lpgsel->rcg.topleft will hold
 	 (icolCur,irowCur)
 Return: number of components in selection: 0 if Nil, 1 if simple, > 1 if
 	discontiguous ...

G_GETORG: Get the current scroll origin in the grid (i.e. the cell at the
	top left scrollable position)
 Criteria: 
 wParam: 
 lParam: LPGCID returning the icol, irow of the cell at the origin
 Return: 

G_SETORG: Scroll the grid such that the specified cell is in the top left
	scrollable position
 Criteria: 
 wParam: TRUE to invalidate rather than force synchronous update
 lParam: LPGCID specifying the icol, irow to scroll to
 Return: 

G_SETUNDO: Set an explicit rollback point for Undo; Row/Column Delete/Cut/
	Paste/Insert/Move are the implicitly supported Undoable operations
 Criteria: 
 wParam: one of
 	wUndoNormal - save current grid state until next implicit or
 		explicit (G_SETUNDO) Undoable operation (UNUSED?)
	wUndoCapture - save current grid state until next wUndoCapture/Release
		(i.e. don't allow implicit rollback points to override)
	wUndoRelease - release Undo to allow rollback of next implicitly Undoable
		operation that follows
 lParam:
 Return: 0L if successful, != 0L otherwise

G_SETSEL: set the grid selection (see bSel* #define's above)
 Criteria: 
 wParam: 0 to set selection to *lpgsel, 1 to add *lpgsel as a discontiguous
 	component to the current selection
 lParam: LPRCGSEL setting the desired selection info; if there's no selection
 	 lpgsel->grfSelTyp should be bSelNil 
 Return: 0L if successful, > 0 if cancelled, < 0 on error

G_CALLFUNC: Call a specified function with a KPB based on the current cell
 Criteria: 
 wParam: 0 to use current cell, != 0 to use that specified in lParam->icol/irow
 lParam: LPGFUNC specifying the function to call and the arguments to pass it
 Return: the UINT returned from the function (cast to a DWORD)

G_GCIDOFPT: Return the cell containing the specified client coordinate
 Criteria: 
 wParam: 
 lParam: LPGPOS specifying the point (in client coordinates of the grid);
 	the grid coordinates will be returned in the GCID.
 Return: 0 if point is outside the grid (i.e. icol == icolNil || irow == irowNil)
 	!= 0 if within the grid. (CONSIDER: could return hit-code if needed)

G_GETCELRANGE: Return an rcg of the currently visible cells
 wParam:
 lParam: LPRCG used to hold return value
 Return:

G_DESTROY: Initiate the termination of the grid control
 wParam:
 lParam:
 Return:

G_BEGINEDIT: Tell grid to consider current cell to be dirty
 wParam:
 lParam:
 Return: 0L if successful, < 0 otherwise

G_ENDEDIT: Tell grid to consider current cell to be clean
 wParam:
 lParam:
 Return:

G_SELTEXT: Get or set selection range for current cell
 Criteria: Must be text-oriented control -- not a checkbox...
 wParam: 0 if getting, 1 if setting
 lParam: MAKELONG(ichSelMic, ichSelMac) if setting
 Return: MAKELONG(ichSelMic, ichSelMac) if getting. If errors on getting, it
	will return MAKELONG(-1, -1)

G_MAKEVIS: Make a given row/column visible
 wParam: grfVis (see #define's below)
 lParam: LPGCID to cell
 Return: 0L if successful, < 0 otherwise
 
G_SETCOLORS: 
 wParam: not used
 lParam: LPGV defining new grid brushes
 Return: Always returns 0L (successful). Cant fail.
 
G_GETDISPTEXT: Get any part of currently displayed text from one field
 wParam: 
 lParam: LPGCLS pointing to icol, irow, buffer length, buffer to
		 copy string into
 Return: 0L if successful, != 0 othrerwise

G_SETDISPTEXT: Set the given text into the current cell's control
 wParam: 
 lParam: CHAR FAR * lszText. (must be null terminated)
 Return: 0L if successful, != 0 othrerwise

G_FDIRTY: Find out whether the grid is currently dirty or not.
 wParam: not used
 lParam: not used
 Return: 0 if not dirty, != 0 if dirty.

G_PAINTCELLS: Paints a square of cells.
 wParam: not used
 lParam: LPRCG of cells to paint.
 Return: Always returns 0L (successful). Can't fail.

G_ICOLOFID: Returns a unique ID for a column (unique only in the life of the column)
 wParam: not used
 lParam: icol of column to get ID for
 Return: wId for column, 0 if no such column.

G_IDOFICOL: Returns the current icol of the unique ID
 wParam: not used
 lParam: ID to get icol for
 Return: icol for column, icolNil if no such column

G_GRIDTOCLIENT
 wParam: not used
 lParam: LPPOINT in client coordinates
 Return: Always returns 0L (successful). Point in lparam is now in client
		 coordinates

G_PTOFGCID: Return the client coordinates of the specified cell
 Criteria: 
 wParam: 
 lParam: LPGPOS specifying the cell, the grid coordinates will be returned
		 in the POINT.
 Return: 0 if point couldn't fit in the POINT (still will be very large), != 0
		 otherwise

G_SETLBOXSELTYPE: Changes the selection model of a listbox
 wParam: wSingleSel, wExtendedSel, or wMultipleSel
 lParam: not used
 returns: 0
 
G_TOGGLEROW: Turns selection for a specified row on/off
 wParam:
 lParam: irow to change
 returns: 0 if successful, non-zero if not

*/

#define	G_SETDATA		(WM_GRIDSTART + 50)
#define	G_CLEARDATA		(WM_GRIDSTART + 51)
#define	G_GETFOCUS		(WM_GRIDSTART + 52)
#define	G_SETFOCUS		(WM_GRIDSTART + 53)
#define	G_GETCOLWIDTH	(WM_GRIDSTART + 54)
#define	G_GETROWHEIGHT	(WM_GRIDSTART + 55)
#define	G_SETCOLWIDTH	(WM_GRIDSTART + 56)
#define	G_SETROWHEIGHT	(WM_GRIDSTART + 57)
#define	G_GETCELLATTRS	(WM_GRIDSTART + 58)
#define	G_SETCELLATTRS	(WM_GRIDSTART + 59)
#define	G_SHOWCOLS		(WM_GRIDSTART + 60)
#define	G_SHOWROWS		(WM_GRIDSTART + 61)
#define	G_ACTNOTIFY		(WM_GRIDSTART + 62)
#define	G_GETDATA		(WM_GRIDSTART + 63)
#define G_GETORG		(WM_GRIDSTART + 64)
#define G_INVALCELL		(WM_GRIDSTART + 65)
#define G_GETDATAMAC	(WM_GRIDSTART + 66)
#define G_UPDATE		(WM_GRIDSTART + 67)
#define G_INSERTCOLS	(WM_GRIDSTART + 68)
#define G_INSERTROWS	(WM_GRIDSTART + 69)
#define G_DELETECOLS	(WM_GRIDSTART + 70)
#define G_DELETEROWS	(WM_GRIDSTART + 71)
#define G_MOVECOLS		(WM_GRIDSTART + 72)
#define G_MOVEROWS		(WM_GRIDSTART + 73)
#define G_COMMITCELL	(WM_GRIDSTART + 74)
#define G_GRIDLINES		(WM_GRIDSTART + 75)
#define G_DFTROWHEIGHT	(WM_GRIDSTART + 76)
#define G_GETSEL		(WM_GRIDSTART + 77)
#define G_CREATEKT		(WM_GRIDSTART + 78)
#define G_SETORG		(WM_GRIDSTART + 79)
#define G_SETUNDO		(WM_GRIDSTART + 80)
#define G_SETSEL		(WM_GRIDSTART + 81)
#define G_CALLFUNC		(WM_GRIDSTART + 82)
#define G_GCIDOFPT		(WM_GRIDSTART + 83)
#define G_FREEZECOLS	(WM_GRIDSTART + 84)
#define G_FREEZEROWS	(WM_GRIDSTART + 85)
#define G_GETCELRANGE	(WM_GRIDSTART + 86)
#define G_DESTROY		(WM_GRIDSTART + 87)
#define G_ENDEDIT		(WM_GRIDSTART + 88)
#define G_SELTEXT		(WM_GRIDSTART + 89)
#define G_GETDISPTEXT	(WM_GRIDSTART + 90)
#define G_MAKEVIS		(WM_GRIDSTART + 91)
#define G_SETCOLORS		(WM_GRIDSTART + 92)
#define G_SETDISPTEXT	(WM_GRIDSTART + 93)
#define G_BEGINEDIT		(WM_GRIDSTART + 94)
#define G_CROWSHIGH		(WM_GRIDSTART + 95)
#define G_GETCOLORS     (WM_GRIDSTART + 96)
#define G_FDIRTY		(WM_GRIDSTART + 97)
#define G_PAINTCELLS	(WM_GRIDSTART + 98)

/* WM_GRIDEND is WM_GRIDSTART + 99 */

/* We ran out of availiable values for grid messages, so we allocated another
block of 100 values for grid messages */
#define GCN_RECURSIVESAVE	(WM_GRIDXSTART + 0)
#define GCN_SELCHANGED		(WM_GRIDXSTART + 1)
#define GCN_SETFOCUS        (WM_GRIDXSTART + 2)
#define GCN_MOUSEEVENT      (WM_GRIDXSTART + 3)
#define GCN_CHANGE          (WM_GRIDXSTART + 4)
#define GCN_KEYEVENT      	(WM_GRIDXSTART + 5)
#define GCN_NOTINLISTEVENT	(WM_GRIDXSTART + 6)

#define G_ICOLOFID			(WM_GRIDXSTART + 10)
#define G_IDOFICOL			(WM_GRIDXSTART + 11)
#define G_GRIDTOCLIENT		(WM_GRIDXSTART + 12)
#define G_PTOFGCID			(WM_GRIDXSTART + 13)

#define GCL_GETCOLTYP		(WM_GRIDXSTART + 20)
#define GCL_GETHBASMOD		(WM_GRIDXSTART + 21)
#define GCL_GETPUNK			(WM_GRIDXSTART + 22)

#define GCL_GRIDCURSOR		(WM_GRIDXSTART + 23)

#define G_SETLBOXSELTYPE	(WM_GRIDXSTART + 24)
#define GCN_BEGINSELDRAG	(WM_GRIDXSTART + 25)	/* drag-drop interior sel */
#define GCL_LOCKBYTES		(WM_GRIDXSTART + 26)

#define G_TOGGLEROW			(WM_GRIDXSTART + 27)
#define GCL_AUTOCORRECT		(WM_GRIDXSTART + 28)
#define GCN_THUMBTRACK		(WM_GRIDXSTART + 29)
#define G_SETCELLHIGHLIGHT	(WM_GRIDXSTART + 30)
#define G_NOCELLHIGHLIGHT (WM_GRIDXSTART + 31)

/* WM_GRIDXEND is WM_GRIDXSTART + 49 */

/* generic return value for cancelled actions: */
#define	errClientAbort	(1)
#define	errSuccess		(0)
#define errFailure		(-1)

/* Flags for G_CLEARDATA: */
#define	fGClearAll		0x0000	/* default: clear all cell data */
#define	fGClearScr		0x0001	/* only clear scrollable cells' data */
// CONSIDER #define	fGClearCols		0x0002	/* only clear cells in given column range */
// CONSIDER #define	fGClearRows		0x0004	/* only clear cells in given row range */

/* this bit can be OR'ed along with any of those above: */
#define	fGClearAttrs	0x0008	/* also clear all row/col/cell attributes */


#define	fGcSetCur		0x0001	/* sets the current cell */
#define	fGcSetCaret		0x0002	/* gives specified cell the caret */
#define	fGcSetFocus		0x0004	/* gives specified cell the focus ONLY IF the
								   grid or one of its children already has it */
#define	fGcForceFocus	0x0008	/* gives specified cell the focus EVEN IF
								   neither the grid nor any of its children
								   already has it */
#define fGcForceCur 	0x0010	/* force current cell to change, even if commit
								   fails (suppresses error messages) */
#define fGcForceCommit	0x0020	/* force cell to commit even if not dirty */
#define	fGcDelayAct		0x0040	/* delay activation of some controls (e.g. textboxes) */
#define fGcShow			0x0080	/* scroll new current cell into view */
#define fGcByClient		0x0100	/* focus change was by client, not user */
#define	fGcResetCur		0x0200	/* SetCur(FALSE) then SetCur(TRUE) even if
								   currency isn't changing */
#define fGcImmediate	0x0400	/* Set focus immediately */

/* Values for G_SETFOCUS wParam: */

/* to set the current cell: */
#define	wGcSetCur	(fGcSetCur)

/* to set the current cell & give it the caret: */
#define	wGcSetCaret	(fGcSetCur|fGcSetCaret)

/* to set the current cell, scroll it into view, give it the caret & the
   Windows focus (only if the grid or another control already has it): */
#define	wGcSetFocus	(fGcSetCur|fGcSetCaret|fGcSetFocus|fGcShow)

/* to set the current cell, scroll it into view, give it the caret & the
   Windows focus (even if neither the grid nor another control already has it): */
#define	wGcForceFocus	(fGcSetCur|fGcSetCaret|fGcForceFocus|fGcShow)

/* Values for G_UPDATE wParam: */
#define	wUpdScroll		0	/* update both scrollbars based on current data */
#define	wLimitRows		1	/* sets # of rows to those having data */
#define	wUnlimitRows	2	/* resets # of rows to crowGridDft */
#define	wExactRows		3	/* sets # of rows to lParam */
#define	wDynamicRows	4	/* prompts grid to start asking client for # of rows */
#define	wDataRows		5	/* sets # of rows having data (irowDataMac) */
#define	wUpdHScroll		6	/* update horizontal scrollbar based on current data */
#define	wUpdVScroll		7	/* update vertical scrollbar based on current data */
#define wResetDynamic	8	/* for grid w. dynamic rows, reset irowDataMac to irowRegMin */
#define wExactRowsInval	9	/* wExactRows, but don't update immediately */

/* Values for G_GETFOCUS wParam: */
#define fLboxFocus		1	/* see description for G_GETFOCUS */

/* Values for G_INVALCELL wParam: */
#define	fInvalAllBits		0x01	/* invalidates all cells, grid lines and margins */
#define	fInvalCellBits		0x02	/* invalidates all cells */
#define	fInvalData			0x04	/* causes cell data to be refilled (only makes
									   sense where !fGcaHoldData) */
#define	fInvalAttrs			0x08	/* causes cell controls to request new display
									   attributes from the grid */
#define fInvalSource		0x10	/* re-initialize sources for combos */
#define fInvalDataIfClean	0x20	/* cause cell data to be refilled if cell not dirty */
#define fInvalSourceCols	0x40	/* cause specified grid cols to re-init sources */
#define fInvalSourceRows	0x80	/* cause specified grid rows to re-init sources */
#define fInvalDataIfNotCheckDirty 0x100 /* invalidates all cells, except for the case of
											a cell which wants to be treated as dirty,
											but hasn't done a successful FBeginEditKpb.
											Hack to avoid losing work in OLE servers */

#define	wNoInval	0
#define	wInvalAllBits	(fInvalAllBits)
#define	wInvalData		(fInvalData | fInvalCellBits)	
#define	wInvalAttrs		(fInvalAttrs | fInvalCellBits)

/* Values for G_SETDATA */
#define wSetDataNormal		0		/* Standard SETDATA behavior */
#define wSetDataUpdScroll	1		/* Update scrollbars */
#define wSetDataTransient	2		/* Data is "transient". Dont update DataMac */
#define wRecursiveSetData	4		/* Client calling G_SETDATA within
									   GCL_SETDATA notification */

/* Values for G_GETDATA */
#define wGetDataNormal		0		/* Standard GETDATA behavior */
#define wGetDataNoCommit	1		/* Do not commit even if the cell is dirty */

/* Values for G_SETCELLATTRS */
#define	fSetFlags		0x01		/* will |= lpgcad->gca.grfGca */
#define	fUnsetFlags		0x02		/* will &= ~(lpgcad->grfGcaUnset) */
#define	fExactFlags		0x200		/* will = lpgcad->grfGcaUnset */
#define fSetAln			0x04		/* set aln without changing rest of TXTINFO */
#define	fSetTxtinfo		0x08		// CONSIDER: (0x08 | fSetAln)
#define	fSetBrshinfo	0x10
#define fSetBdrinfo		0x20
#define	fSetAttrs		0x40		/* updates everything but control type */
#define	fSetPpgca		0x100		/* will set control type using specified
									   PPGCA */
#define	fSetBkBrsh		0x400		/* grid window's background brush */

/* Values for G_SETUNDO wParam: */
#define	wUndoNormal		0
#define	wUndoCapture	1
#define	wUndoRelease	2

/* Values for G_SETLBOXSELTYPE wParam */
#define	wSingleSel		0
#define	wMultipleSel	1
#define	wExtendedSel	2


/* Values for G_RECORDUNDO wParam */
#define ungrOpEditCell	0
#define ungrOpRowInsert	1
#define ungrOpRowDelete	2
#define ungrOpRowMove	3
#define ungrOpCut		4
#define ungrOpResize	5

/* Values for G_MAKEVIS wParam: */
#define fVisBotRight	0x0001		/* ensure that the cell's bottom right
									   corner is made visible if possible */
#define fVisMakeOrg		0x0002		/* if a scroll is needed, scroll the
									   specified cell to the origin */
#define fVisInval		0x0004		/* avoid a synchronous paint - simply
									   invalidate if scroll is needed */

/* Standard width for a grid's row selector button column */
#define dxtSelectColumn	284

typedef struct _grpi BPP(segPrint)	PPGRPI;

/* Public prototypes: */

PUBLIC VOID InitGrids(VOID);
PUBLIC VOID CleanupGrids(VOID);
PUBLIC DLLIMPORT HWND HwndGridCreate (LPGRID lpgrid, LPGV lpgv);
PUBLIC DLLIMPORT VOID GridInitialize(VOID);
PUBLIC DLLIMPORT VOID GridPaint(HWND hwnd, HDC hdc, RECT rcUpdate, UINT grfDg);
PRIVATE VOID PrtGridJ(HWND hwndGrid,struct _eop BPP(segPrint) ppeop,struct _cip BPP(segPrint) ppcip,UINT	pfmsg);
PRIVATE PPGRPI PpgrpiInit(HWND hwndGrid,INT dxtPage,INT dytPage,
						  BOOL fPrintSelection,BOOL fCheckSizes);
PRIVATE BOOL FLastPrintPpgrpi(PPGRPI ppgrpi,HDC hdc,BOOL fDrawing,BOOL fDataOnly,
							  UINT wPageDesired, LONG ldyAbove,INT xOrgOffset,
							  INT yOrgOffset, struct _mip *pmip, RECT rcClip, INT *pdyt, INT *pdytBorder);
PRIVATE VOID TermPpgrpi(PPGRPI ppgrpi);
PRIVATE HWND HwndOfPpgrpi(PPGRPI ppgrpi);
PRIVATE VOID ResetPpgrpi(PPGRPI ppgrpi);
PRIVATE BOOL FPrintSelection(HWND hwndGrid);
PRIVATE VOID FreePpgrpiNil(PPGRPI ppgrpi);
PRIVATE PPGRPI PpgrpiDupJ(PPGRPI ppgrpi);
#ifdef __cplusplus
}
#endif

#endif _GRID_H

#endif	// !defined(GRID_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\syscase.h ===
///////////////////////////////////////////////////////////////////////////////
//	SYSCASES.H
//
//	Created by :			Date :
//		RickKr					1/25/94
//
//	Description :
//		Declaration of the CSysTestCases class
//

#ifndef __SYSCASES_H__
#define __SYSCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "sniff.h"

///////////////////////////////////////////////////////////////////////////////
// CConnectTest: Connect to the SQL server Data Source

class CConnectTest: public CTest
{
	DECLARE_TEST(CConnectTest, CDataSubSuite)

public:
	virtual void Run(void);
	virtual	BOOL RunAsDependent(void);
};



#endif // SYSCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\davinc\stdapp.h ===
#if !defined(STDAPP_H_INCLUDED_)
#define STDAPP_H_INCLUDED_

/*============================================================================
Microsoft Access

Microsoft Confidential.
Copyright 1992-1993 Microsoft Corporation. All Rights Reserved.

File: stdapp.h

Data types and macros useful for application development
============================================================================*/

#ifndef _STDAPP_H
#define _STDAPP_H

/*===========================================================================
	General Purpose Defines												    
============================================================================*/

/* this macro does nothing, but used for indenting */
#define block

#ifdef __cplusplus
#define EX_C extern "C" 
#else
#define EX_C 
#endif

#if (defined(W95DEF) || defined(ICAP))
#define LOCAL	// so that statics show up in the map file or ICAP profile
#else
#define LOCAL static
#endif
#ifndef NO_C_BUGS   // Can't have static __export because of C8 bug.
#define LOCALEXP
#endif

#include <windowsx.h>

// Turn off warnings for seeing both DLLIMPORT and DLLEXPORT.  The compiler (vc2.0/2.1)
// does the right thing, the stupid warning is just saying that it saw the DLLIMPORT in
// the header file, and the DLLEXPORT in the .c file.  -mgrier 1/11/95
#pragma warning(disable:4273)

#define HUGE
#if !defined(DAVINCI_CUL_USED)
#define EXPORT
#endif // !defined(DAVINCI_CUL_USED)
#define ACCEXPORT WINAPI
#define DLLEXPORT __declspec(dllexport)
#define DLLIMPORT __declspec(dllimport)
#define _export
#define __export
#define _far
#define far
#define __far
#define _near
#define huge
#define _huge
#define _segment HANDLE
#define _loadds
#define _pascal
#define GetWindowValPortable(hwnd,ib) GetWindowLong(hwnd,ib)
#define SetWindowValPortable(hwnd,ib,val) SetWindowLong(hwnd,ib,val)
#define API
#define MAKEINTLONG(i) (i)
#define GETINTLONG(l) (l)

#define INLINE			_inline
#define EXTERN			extern
#if !defined(DAVINCI_CUL_USED)
#define PUBLIC
#define PRIVATE
#endif // !defined(DAVINCI_CUL_USED)

#define	MakeLong(l, h)	MAKELONG(l, h)
#define LowWord(l)		LOWORD(l)
#define HighWord(l)		HIWORD(l)

#define CwFromCch(cch)	(((cch) + 1) / 2)
#define CwFromCb(cb)	(((cb) + 1) / 2)
#define cwof(x)			((sizeof(x) + 1) / 2)

/* size of an st string in bytes (1st byte is number of characters) */
#define CbSt(st)		(*(st)+1)

#define ibWndSeg 0		/* Offset of window word containing the heap selector
						   for the associated object */

#define cchFilenameMax	MAX_PATH
#define cchNameMax		65	/* now a real hungarian max! so names can have only 64 chars (excluding null) */
#define cchFormPrefixMax	31	/* Max length of "Form."/"Report." in US or international */
#define cchProcNameMax 	(cbProcNameMax+1)
#define cchModNameMax	(cchNameMax + cchFormPrefixMax)	/* big enough for the largest CBF module name */
#define cchDocNameMax	cchModNameMax
#define cchStringMax	2048	/* big enough for the largest international string */
#define cchLtoaDecMax	12	/* big enough for ltoa with arg3 == 10 : "-2147483648" */
#define cchExprLim		2048	/* maximum length of unparsed expression */
#define cchKeyMax		257	/* registry key maximum */

// US lcid
#define LCID_US MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT), SORT_DEFAULT)

/* coordinate space limits */
#define GDI_MIN			SHRT_MIN
#define GDI_MAX			SHRT_MAX
#define FIsGdiCoord(l)	(l >= GDI_MIN && l <= GDI_MAX)	/* needs limits.h */

/* count of characters for a possibly unicode static string */
#define cchof(_buf) (sizeof(_buf)/sizeof(TCHAR))

// The Error-Reporting Options... 
#define bitNull			0x0000 // Nothing; as if calling straight to Windows
#define bitErrJump		0x0001 // ErrJump on error; flag will be set to bring
							   // up an alert the next time we hit the idle loop
							   // unless bitNoDispFailed or bitErrMsg also set
#define bitErrMsg		0x0002 // Display an "Out of Memory" alert
#define bitErrJumpMsg	(bitErrJump | bitErrMsg)

EX_C PUBLIC BOOL FStkRoom();

/*****************************************************************

		Appearance codes

*****************************************************************/

#define appearNormal	0
#define appearRaised	1
#define appearSunken	2
#define appearEtched	3
#define appearShadow	4
#define appearChisel	5
#define appearMax		5


/*============================================================================
Constants for determining the current state of app execution

============================================================================*/
#define wAppBeginSession		0
#define wAppInLogonDialog		1
#define wAppRunning				2
#define wAppClosePending		3
#define wAppQueryExitApp		4
#define wAppQueryExitWindows	5
#define wAppExitApp 			6
#define wAppExitWindows			7

#define FInitting() (wAppState <= wAppInLogonDialog)
#define FQuitting()	(wAppState >= wAppExitApp)
/*
	Macros used to declared structures derived from each other.  In C++,
	uses derivation, but in C uses anonymous embedding.  Suppose an FI
	is the same as FOBJ, but with a based handle tacked on the end.

	H-file would read as follows:

	typedef struct FI
		Derived(FOBJ)
		CHAR BPP(segFx) pszName;
		EndDerived FI;

	Generated C++ code:

	typedef struct FI
		: public FOBJ
		{
		CHAR BPP(segFx) pszName;
		} FI;

	Generated C code:

	typedef struct FI
		{
		FOBJ;
		CHAR BPP(segFx) pszName;
		} FI;

*/
		
#ifdef __cplusplus

#define Derived(base)	: public base\
	{

#define Derived2(base1, base2)	: public base1, public base2\
	{

#else
#define Derived(base)	{\
	base;

#define Derived2(base1, base2)	{\
	base1;\
	base2;
	

#endif

#define EndDerived	}

#ifdef __cplusplus
extern "C" {
#endif

/*--------------------------------------------------------------------------
|  General Purpose Data types for Windows Apps							
--------------------------------------------------------------------------*/
typedef int 						ERR;
typedef unsigned char				BOOLB;
typedef _segment 					SEG;
typedef	char *						IB;
typedef char						DT[8];
typedef char						NUM[8];
typedef int							(*PFN)();
typedef long int					(*PFNL)();
typedef	int							CE;
typedef unsigned long 				ULONG;

/* BCS: CS based data */
// for the Mac, if ever #define BCS __declspec(allocate("_CODE"))
#define BCS const

/* BPS: based pointer self */
#define BPS *
#define PP BPS BPS

/* BP: based pointer (based on seg) */
#define BP(seg)	*
#define BPP(seg) BP(seg) BP(seg)
#define BPCS	BCS *
#define BPPCS	BPCS BPCS

#ifndef NO_C_BUGS   // Requiered due to C8 warning errors
#define BPPNULL ((VOID BPPV) NULL)
#endif

/* BP: based pointer (based on void) */
#define BPV *
#define BPPV **
#define BPIB void **

/* LBP: far pointer to a based pointer, based on the seg the far points to
   (i.e. perfect for values returned by PpbAlloc) */
#define LBP BPS FAR *

/* LBPs are now just pointers to pointers.  HeapOfPv returns the heap the 
	memory was allocated from (RegisterHeapPv MUST be called at allocation). */
#define SegOfLp(lp)	HeapOfPv(lp)
#define IbOfLp(lp)	((IB)lp)
#define FreeLbp(lbp)	FreePpb(HeapOfPv(lbp), lbp)
#define FreeLbpNil(lbp)	if (lbp!=NULL) FreeLbp(lbp)

/* primitive data types in upper case */
typedef int 			 INT;
typedef char 			 CHAR;
#ifdef LONG	// Replace the definition of LONG with a typedef
#undef LONG
#endif
typedef long 			 LONG;
typedef short 			 SHORT;
#define UNSIGNED		unsigned
#define CONST			const
#define REGISTER		register
#define DOUBLE			double
#define FLOAT			float

typedef union DPOINT
	{
	struct
		{
		int dx;
		int dy;
		};
	int rgdxy[2];
	} DPOINT;		/* Difference between PoinTs */

typedef union RECTD
	{
	struct
		{
		int left;
		int top;
		int dx;
		int dy;
		};
	struct
		{
//		struct
//			{
//			int x, y;
//			} topleft;
		POINT topleft;
		DPOINT dpt;
		};
	} RECTD;	/* ReCtangle holding dimension Difference */

#define	DxOfRc(prc)	((prc)->right - (prc)->left)
#define	DyOfRc(prc)	((prc)->bottom - (prc)->top)

/*------------------------------------------------------------------------
| API stub outs -- if there's one here, use the alternate
------------------------------------------------------------------------*/

#ifndef DAVINCI

#if !defined(CIRHDCMGR) && (!SOA)
/* Access: Use CreateDCC instead */
#undef CreateDC
#define CreateDC	dontusethisapi
/* Access: Use CreateICC instead */
#undef CreateIC
#define CreateIC	dontusethisapi
/* Access: Use CreateCompatibleDCC instead */
#define CreateCompatibleDC	dontusethisapi
/* Access: Use DeleteDCC instead */
#define DeleteDC	dontusethisapi
/* Access: Use SaveDCC instead */
#define SaveDC	dontusethisapi
/* Access: Use RestoreDCC instead */
#define RestoreDC	dontusethisapi
/* Access: Use SetMapModeC instead */
#define SetMapMode	dontusethisapi
/* Access: Use SelectObjectC instead */
#define SelectObject	dontusethisapi
/* Access: Use SelectRegionC instead */
#define SelectClipRgn	dontusethisapi
/* Access: Use SetTextColorC instead */
#define SetTextColor	dontusethisapi
/* Access: Use SetBkModeC instead */
#define SetBkMode	dontusethisapi
/* Access: Use CreateMetaFileC instead */
#undef CreateMetaFile
#define CreateMetaFile	dontusethisapi
/* Access: Use CloseMetaFileC instead */
#define CloseMetaFile	dontusethisapi
/* Access: Use EnumMetaFileC instead */
#define EnumMetaFile	dontusethisapi
/* Access: Use GetDCC instead */
#define GetDC	dontusethisapi
/* Access: Use ReleaseDCC instead */
#ifndef GRID_DLL
#define ReleaseDC	dontusethisapi
#endif	// GRID_DLL
/* Access: Use GetWindowDCC instead */
#define GetWindowDC	dontusethisapi
/* Access: Use BeginPaintC instead */
#define BeginPaint	dontusethisapi
/* Access: Use EndPaintC instead */
#define EndPaint	dontusethisapi
#endif

//#if !defined(CIRSETFOCUS) && (!SOA)
/* Access: Use SetKeyFocus instead */
//#define SetFocus	dontusethisapi
//#endif

#if !defined(CIRDEFMDICHILDPROC) && (!SOA)
/* Access: Use DefCirMDIChildProc instead */
#undef DefMDIChildProc
#define DefMDIChildProc	dontusethisapi
#endif

#if !defined(CIRDIALOG) && (!SOA)
/* Access: Use CeDlgBoxParam instead */
#undef DialogBox
#define DialogBox	dontusethisapi
#undef DialogBoxIndirect
#define DialogBoxIndirect	dontusethisapi
/* Access: Use CeDlgBoxParam instead */
#undef DialogBoxParam
#define DialogBoxParam dontusethisapi
#undef DialogBoxIndirectParam
#define DialogBoxIndirectParam dontusethisapi
#endif /* CIRDIALOG */

#endif	// DAVINCI

/*------------------------------------------------------------------------
| Win16 Compatibility types -- DO NOT USE FOR NEW CODE!
------------------------------------------------------------------------*/

#pragma pack(1)
typedef struct RECT16
	{
	SHORT left;
	SHORT top;
	SHORT right;
	SHORT bottom;
	} RECT16;
typedef struct POINT16
	{
	SHORT x;
	SHORT y;
	} POINT16;
#pragma pack()

#define POINT16TOPOINT(pt16,pt)	{ \
								(pt).x = (pt16).x; \
								(pt).y = (pt16).y; \
								}
								
#define POINTTOPOINT16(pt,pt16)	{ \
								(pt16).x = (SHORT)(pt).x; \
								(pt16).y = (SHORT)(pt).y; \
								}

#define RECT16TORECT(rc16,rc)	{ \
								(rc).left = (rc16).left; \
								(rc).right = (rc16).right; \
								(rc).top = (rc16).top; \
								(rc).bottom = (rc16).bottom; \
								}
#define RECTTORECT16(rc,rc16)	{ \
								(rc16).left = (SHORT)(rc).left; \
								(rc16).right = (SHORT)(rc).right; \
								(rc16).top = (SHORT)(rc).top; \
								(rc16).bottom = (SHORT)(rc).bottom; \
								}

/*------------------------------------------------------------------------
| other common hungarianized Window's types
|
------------------------------------------------------------------------*/
#define HBR HBRUSH
#define HBMP HBITMAP
#define HCRS HCURSOR

/*------------------------------------------------------------------------
| Null values for special types
------------------------------------------------------------------------*/
#define segNil		((SEG) 0)
#define hdcNil		(HDC)0
#define hfontNil	(HFONT)0
#define hwndNil		(HWND)0
#define	hbrNil		(HBR)0
#define hmenuNil	(HMENU)0
#define hNil		(HANDLE)0
#define lpNil		(VOID FAR *)0
#define hpenNil		(HPEN)0
#define hrgnNil		(HRGN)0
#define hiconNil	(HICON)0
#define hcrsNil		(HCURSOR)0
/*------------------------------------------------------------------------
| CsConst and Errjump defines
------------------------------------------------------------------------*/
#define CsConst(type) BCS type

/* Our dialogs go in cs space */
#define DLG_CONST BCS

/* alias for standard C setjmp function */
#define SetJmp(arg)	setjmp((_JBTYPE*)arg)
#define ENV jmp_buf
#define PENV ENV *

#define FValidSeg(seg)	(seg != segNil)
#define FImplies(f1,f2) (!(f1)||(f2))
#define FOREVER for(;;)

#include <setjmp.h>

EXTERN  ENV *penvError;

	/* macro to declare the environment vars for you.  requires ending ; */
#define DeclareEjd	\
	ENV	envSave;	\
	ENV	*  penvSave

/* segCur==segDefault in preparation for SetJmp call */
#define SetEjd(ejd)		{		\
		Assert(GetCurrentThreadId() == dwMainThreadId);	\
		PushEjd((EJD)(VOID FAR *)ejd);	\
		penvSave = penvError;	\
		penvError = &envSave;	\
		}

#define ResetEjd(ejd)	{			\
		Assert(EjdPop() == (EJD)(VOID FAR *)(ejd));	\
		penvError = penvSave;		\
		}

// The following macros are for convenient and structured handling
// of exceptions. They can be used as follows:
//
//  ErrBegin
//      ... main body of code containing possible ErrJumps
//      MUST NOT "goto" or "return" out of here - use ErrGoto or ErrReturn!
//		don't use "break" or "continue" to get out of here either.
//		control now transfers to line after "ErrEnd"
//  ErrRecover
//      error recovery code - OK to use goto/return. Error code is available
//      in "errEJ" variable.
//		ErrJump(errEJ);	// Propagate exception (optional)
//      return errEJ;   // Return error code (optional)
//		(if no ErrJump/return, code would continue executing after "ErrEnd")
//  ErrEnd
//
//	The ErrRecover section and the code after it are optional, but if used,
//  it must come AFTER the main body of code. The ErrEnd is required.
//  If there is no ErrRecover section, when an exception occurs, the error
//  is trapped and execution resumes after the ErrEnd.
//
// To surround code that is not supposed to contain any ErrJumps, use
//  SafeBegin
//      ... code supposedly not ErrJumping
//      MUST NOT "goto" or "return" out of here - use SafeGoto or SafeReturn!
//		don't use "break" or "continue" to get out of here either.
//  SafeEnd
// This will cause an Assert if the code does indeed ErrJump.
//
//	DON'T EVER JUMP INTO OR OUT OF ONE OF THESE BLOCKS BY USING goto, return,
//	break, continue, or something else I haven't thought of. That will
//	cause bugs galore!
//
//	Also, DON'T PUT ANY FUNCTION CALLS THAT MAY ErrJump INTO THE
//	ErrGoto/ErrReturn MACROS: The errors won't be trapped!
//
//
//	Example code (illustrates use of ErrReturn):
//
//	// Allocate memory; return NULL if out of memory; propagate error
//	//	if any other error is detected (not a very useful routine, but...)
//	PV PvAllocExample
//	(
//	unsigned cb;	// Count of bytes to allocate
//	)
//	{
//		PV pv;
//
//		ErrBegin
//			pv = PvAlloc(cb);
//			ErrReturn(pv);
//		ErrRecover
//			if (errEJ == idaNoMem)
//				ErrReturn(NULL);
//			else
//				ErrJump(errEJ);	// Propagate unexpected error
//		ErrEnd
//	}
//
// or, alternatively:
//
//	// Allocate memory; return NULL if out of memory; propagate error
//	//	if any other error is detected (not a very useful routine, but...)
//	PV PvAllocExample
//	(
//	unsigned cb;	// Count of bytes to allocate
//	)
//	{
//		PV pv;
//
//		ErrBegin
//			pv = PvAlloc(cb);
//		ErrRecover
//			if (errEJ == errOutOfMemory)
//				pv = NULL;
//			else
//				ErrJump(errEJ);	// Propagate unexpected error
//		ErrEnd
//
//		return (pv);
//	}

#define ErrBegin \
    { \
        ENV env;       \
        PENV penvSave;  \
        ERR errEJ;                \
        BOOL fErrRecover = FALSE;	\
		PushEjd((EJD)(VOID FAR *)&env);	\
        penvSave = penvError;   \
        penvError = &env;       \
        if ((errEJ = SetJmp(&env)) == 0)  \
        {

#define ErrGoto(lbl) \
            { \
	        Assert(penvError == &env || penvError == penvSave);  \
			Assert(EjdPop() == (EJD)(VOID FAR *)(&env));	\
			penvError = penvSave; \
			goto lbl; \
			}

#define ErrReturn(val) \
            { \
	        Assert(penvError == &env || penvError == penvSave);  \
			Assert(EjdPop() == (EJD)(VOID FAR *)(&env));	\
			penvError = penvSave; \
			return(val); \
			}

#define ErrRecover \
        }                       \
        else                    \
        {                       \
            Assert(errEJ != 0);  \
			Assert(EjdPop() == (EJD)(VOID FAR *)(&env));	\
			fErrRecover = TRUE;		\
            penvError = penvSave;   \

#define ErrEnd \
        }                       \
        Assert(penvError == &env || penvError == penvSave);  \
		if (!fErrRecover)	\
			Assert(EjdPop() == (EJD)(VOID FAR *)(&env));	\
        penvError = penvSave;   \
    }

#ifdef DEBUG

#define SafeBegin   \
        ErrBegin

#define SafeGoto(lbl) \
            { \
			Assert(EjdPop() == (EJD)(VOID FAR *)(&env));	\
            penvError = penvSave; \
            goto lbl; }

#define SafeReturn(val) \
            { \
			Assert(EjdPop() == (EJD)(VOID FAR *)(&env));	\
            penvError = penvSave; \
            return (val); }

#define SafeExit \
	{ \
	Assert(EjdPop() == (EJD)(VOID FAR *)(&env));	\
	penvError = penvSave; \
	return; }

#define SafeEnd \
        ErrRecover  \
            Assert(FALSE); \
        ErrEnd

#else   // not DEBUG

#define SafeBegin   {

#define SafeGoto(lbl) \
            { \
            goto lbl; }

#define SafeReturn(val) \
            { \
            return val; }

#define SafeExit \
		{ \
		return; }

#define SafeEnd }

#endif  // not DEBUG


/*============================================================================

TrapEjd will execute the code specified by fn and set fejd to TRUE
if an errjump occured during the execution of fn otherwise fejd will
contain false.  Use this in functions where you need to call code that
errjumps on failure but you need a simple TRUE/FALSE success indicator
============================================================================*/

#define TrapEjd(ejd, fejd, fn)	{	\
		SetEjd(ejd); fejd = TRUE;	\
		if (SetJmp(penvError) == 0) \
			{fn; fejd = FALSE;}		\
		ResetEjd(ejd);		\
		}

#define TrapEjdCpp(fejd, fn)	{	\
		penvSave = penvError;	\
		penvError = &envSave;	\
		fejd = TRUE;	\
		if (SetJmp(penvError) == 0) \
			{fn; fejd = FALSE;}		\
		penvError = penvSave;		\
		}
	
/*------------------------------------------------------------------------
| Blt macros
------------------------------------------------------------------------*/
#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* the following Blt* macros (memcpy) DON'T handle src/dest overlap
	- use Blt*O (memmove) macros below if overlap is possible */
#define BltB(pFrom, pTo, cb)	memcpy(pTo, pFrom, cb)
#define BltBF(lpFrom, lpTo, cb)	memcpy((char FAR *)(lpTo), (char FAR *)(lpFrom), (cb))
#define BltW(pFrom, pTo, cw)	memcpy(pTo, pFrom, (cw)*sizeof(UINT))
#define BltWF(lpFrom, lpTo, cw)	memcpy(lpTo, lpFrom, (cw)*sizeof(UINT))

// PUBLIC DWORD BltBH(CONST VOID _huge *, VOID _huge *, DWORD);
#define BltBH(pFrom, pTo, cb) memcpy(pTo, pFrom, cb)

/* the following Blt*O macros (memcpy) DO handle src/dest overlap
   but are slower than the Blt* macros above */
#define BltBO(pFrom, pTo, cb)	memmove(pTo, pFrom, cb)
#define BltBFO(lpFrom, lpTo, cb)	memmove((char FAR *)(lpTo), (char FAR *)(lpFrom), (cb))
#define BltWO(pFrom, pTo, cw)	memmove(pTo, pFrom, (cw)*sizeof(UINT))
#define BltWFO(lpFrom, lpTo, cw)	memmove(lpTo, lpFrom, (cw)*sizeof(UINT))


#define FillB(b, pb, cb)		memset((char *)(pb), (b), (cb))
#define FillBF(b, lpb, cb)		memset((char FAR *)(lpb), (b), (cb))

/* the following string macros are Hungarian-ized and list the source
   string before the destination string (the opposite of C-runtime routines) */
#define CpySz(szFrom, szTo)				lstrcpy(szTo, szFrom)
#define CpyLsz(lszFrom, lszTo)			lstrcpy(lszTo, lszFrom)
#define CpySzCch(szFrom, szTo, cch)		lstrcpyn(szTo, szFrom, (size_t)cch)
#define CpyLszCch(lszFrom, lszTo, cch)	lstrcpyn(lszTo, lszFrom, (size_t)cch)

#define CatSz(szFrom, szTo)		lstrcat(szTo, szFrom)
#define CatLsz(lszFrom, lszTo)	lstrcat(lszTo, lszFrom)

#define CpySt(stFrom, stTo)		memcpy(stTo, stFrom, *(stFrom)+1)
#define CpyLst(lstFrom, lstTo)	memcpy(lstTo, lstFrom, *(lstFrom)+1)

#ifndef DAVINCI
#define CchSz(sz)		((UINT)lstrlen (sz))
#endif	// DAVINCI

#define CchLsz(lsz)		((UINT)lstrlen(lsz))

/*------------------------------------------------------------------------
| Internationalization and Misc string handling macros
------------------------------------------------------------------------*/
/* This function can be made into a function later */
/* CONSIDER: Do we want these as macros? */
#define lMin(l1, l2) ((l1 < l2) ? l1 : l2)
#define lMax(l1, l2) ((l1 < l2) ? l2 : l1)
#define FInRange(w, wLo, wHi)	((unsigned)((w) - (wLo)) <= (unsigned)((wHi) - (wLo)))

/* Character functions. */
#define FIsDigitCh(ch) (ch >= '0' && ch <= '9')
#define ToLowerCh(ch) ((char)LOWORD((LONG)AnsiLower((LPSTR)MAKELONG(ch,0))))
#define ToUpperCh(ch) ((char)LOWORD((LONG)AnsiUpper((LPSTR)MAKELONG(ch,0))))
#define ToLowerLpsz(lpsz) AnsiLower((LPSTR)(lpsz))
#define ToUpperLpsz(lpsz) AnsiUpper((LPSTR)(lpsz))

#define FIsAlphaCh(ch) IsCharAlpha(ch)
#define FIsAlNumCh(ch) IsCharAlphaNumeric(ch)
#define FIsLowerCh(ch) IsCharLower(ch)
#define FIsUpperCh(ch) IsCharUpper(ch)
#define ToLowerLrgch(lrgch, cch) AnsiLowerBuff(lrgch, cch);
#define ToUpperLrgch(lrgch, cch) AnsiUpperBuff(lrgch, cch);

/* CONSIDER: making this a function? */
#define FIsShort(l)	(l >= SHRT_MIN && l <= SHRT_MAX)	/* needs limits.h */
#define FIsWord(dw)	(dw <= USHRT_MAX)					/* needs limits.h */

#ifdef DEBUG			/* DEBUG build macros follow ... */
/*------------------------------------------------------------------------
| Assertion failure support
| Define the module name once.  Include at the top of
| any module which has an assertion check
------------------------------------------------------------------------*/

#ifndef DAVINCI
#define SZASSERT static char szAssert[] = __FILE__
#define SZASSERTH static char szAssertH[] = __FILE__
PUBLIC BOOL AssertFail(LPCSTR lszMsg, LPCSTR lszFile, UINT wLine);
#else
#define szAssert "Grid DLL"
#define szAssertH "Grid DLL"
#endif	// DAVINCI

#ifndef DAVINCI
#ifdef Assert
#undef Assert
#endif
#endif	// DAVINCI

#ifndef DAVINCI
#define Assert(exp) ( (exp) ? 0 : AssertFail(#exp, szAssert, __LINE__) )
#define AssertH(exp) ( (exp) ? 0 : AssertFail(#exp, szAssertH, __LINE__) )

#define AssertMsg(exp, szMsg) ( (exp) ? 0 : \
							AssertFail(szMsg, szAssert, __LINE__) )
#else
#define AssertH(exp)
#define AssertMsg(exp, szMsg)
#endif	// DAVINCI

#define SideAssert(f) Assert(f)
#if !defined(DAVINCI_CUL_USED)
#define Ensure(exp, exp2) {if ((exp) != (exp2)) Assert(FALSE);}
#define EnsureNE(exp, exp2) {if ((exp) == (exp2)) Assert(FALSE);}
#define Implies(f1, f2)         Assert((f1) ? (f2) : fTrue)
#endif // !defined(DAVINCI_CUL_USED)

#else
#define SZASSERT
#define SZASSERTH

#ifndef DAVINCI
#define Assert(exp) (0)
#endif	// DAVINCI

#define AssertH(exp) (0)
#define AssertMsg(exp, szMsg) (0)
#define ErrMsg(sz)
#define SideAssert(f)		(f)

#ifndef DAVINCI
#define Ensure(exp, exp2)	exp;
#define EnsureNE(exp, exp2)	exp;
#endif	// DAVINCI

#define Implies(f1, f2)

#endif /* !DEBUG */

#ifndef RETAIL		/* needed for DEBUG & TESTOPT */

#define DisarmRFS()	DisarmAllRfs()
#define RestoreRFS() RestoreAllRfs()

#else	/* RETAIL */

#define DisarmRFS()
#define RestoreRFS()
#define	SkipFail(id)

#endif /* RETAIL */

/*------------------------------------------------------------------------
|
| Common useful prototypes
|
------------------------------------------------------------------------*/

PUBLIC  VOID ErrJump(INT);

/*------------------------------------------------------------------------
|
| Common useful external declarations
|
------------------------------------------------------------------------*/
extern DLLIMPORT HINSTANCE hInstApp;
extern HDC hdcApp;
extern HWND hwndApp;
extern UINT wAppState;
extern CHAR szNull[];
extern UINT wWinVer;
extern DWORD lPlatform;
extern HINSTANCE hInstIntlDLL;
extern BOOLB fInIdle;
extern DWORD dwMainThreadId;
extern CHAR szAppName[];
extern CHAR *szVisAppName;	// WARNING: Compiles wrong if this is declared [] instead of * !
extern HKEY hKeyProfile;
extern const CHAR szSettingKey[];

#define FIsChicago() (lPlatform == VER_PLATFORM_WIN32_WINDOWS)

// FAdvancedShell() was commented out--I've re-included it (tomva)
#define FAdvancedShell() (LOBYTE(LOWORD(wWinVer)) >= 0x04)

/*============================================================================
Common useful typedefs
============================================================================*/
typedef INT HSBAR;

/*============================================================================

	Component Message Range Definitions

============================================================================*/
	/* include them rather than define them here so we can make
	 * an include file of them very easily.  (can't make an include of stdapp).
	 */
#include "cmpmsg.h"
#ifdef __cplusplus
}
#endif

#endif // _STDAPP_H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ParamHlp\Sniff\Src\ParamHlpCases.h ===
///////////////////////////////////////////////////////////////////////////////
//	ParamHlpCases.h
//
//	Description :
//		Declaration of the CParamHlpCases class
//

#ifndef __ParamHlpCases_H__
#define __ParamHlpCases_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "ParamHlpSuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CParamHlpCases class

class CParamHlpCases : public CTest
{
	DECLARE_TEST(CParamHlpCases, CParamHlpSuite)

// Operations
public:
	virtual void Run(void);
	void EditSource();

// Member variables
public:
	COSource  src;
};

#endif //__ParamHlpCases_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ParamHlp\Sniff\Src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Description :
//		Precompiled header for a CAFE Test
//
//		Includes core CAFE headers for the target of the test.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ENT\DataSniff\Src\davinc\testhook.h ===
//-----------------------------------------------------------------------------
// Microsoft daVinci
//
// Microsoft Confidential
// Copyright 1994 - 1995 Microsoft Corporation. All Rights Reserved.
//
// File: testhook.h
// Area: test hooks
//
// Contents: This file contains the test hook messages and structures
//
// Owner: stevekr
//-----------------------------------------------------------------------------

#ifndef _TESTHOOK_H
#define _TESTHOOK_H

// Typedefs and constants -----------------------------------------------------

#define	MAX_NAME_LEN			256

typedef struct {
	OLE_XPOS_HIMETRIC		himetLeft;
	OLE_YPOS_HIMETRIC		himetTop;
	OLE_XSIZE_HIMETRIC		himetWidth;
	OLE_YSIZE_HIMETRIC		himetHeight;
	} ObjectLocation, *PObjectLocation;

enum LayoutStyle {
	eRectilinear	= 0,	// Schema
	eCircular		= 1,	// Link View radial layout
	eOrgTopToBottom	= 2,	// SDN current
	eOrgLeftToRight = 3,	// Link View horizontal layout
	eOrgRightToLeft = 4,	// the rest are NYI...
	eCyberbolic		= 5
	};

typedef struct {
	LONG			lDiagramZoom;	// zoom level of diagram (1-400)
	LayoutStyle		eLayout;		// current layout style
	BOOL			fDirty;			// diagram dirty flag
	ObjectLocation	olocViewport;	// current visible canvas
	} DiagramInfo, *PDiagramInfo;
//$ CONSIDER:  In the DiagramInfo structure, also list the window title?

typedef struct {
	INT					arrowOneEnd;
	INT					arrowOtherEnd;
	INT					DdsLinestyle;
	INT					PolylineRendition;
	LONG				cLabels;
	LONG				cPoints;
	LONG				cOneCombPoints;
	LONG				cOtherCombPoints;
	CHAR				szLabelName[MAX_NAME_LEN];
	POINT*				rgptConnector;
	} ConnectorInformation, *PConnectorInformation;

// Query Diagram Pane
typedef struct
	{
	WCHAR				strName[MAX_NAME_LEN];
	HWND				hwnd;
	RECT				rcPosition;
	BOOL				fMinimized;
	LONG				cColumns;
	} DiagramTableInfo, *PDiagramTableInfo;

typedef struct
	{
	CHAR				strName[MAX_NAME_LEN];
	HWND				hwnd;
	RECT				rcPosition;
	BOOL				fMinimized;
	LONG				cColumns;
	} ANSIDiagramTableInfo, *PANSIDiagramTableInfo;

// Bit flags for visibility of tables
#define fTableVisibleNone		0x00
#define fTableVisibleYes		0x01
#define fTableVisiblePartial	0x02
#define fTableVisibleObscured	0x04

typedef struct
	{
	WCHAR				strName[MAX_NAME_LEN];
	INT					iecolPosition;
	RECT				rcPosition;
	RECT				rcClick;
	RECT				rcName;
	RECT				rcSortIcon;
	RECT				rcFilterIcon;
	RECT				rcGroupIcon;
	BOOL				fPrimaryKeyCol;
	LONG				lStateClick;
	LONG				lStateSort;
	BOOL				fGrouped;
	LONG				lStateAgg;
	BOOL				fFiltered;
	} DiagramColumnInfo, *PDiagramColumnInfo;

typedef struct
	{
	CHAR				strName[MAX_NAME_LEN];
	INT					iecolPosition;
	RECT				rcPosition;
	RECT				rcClick;
	RECT				rcName;
	RECT				rcSortIcon;
	RECT				rcFilterIcon;
	RECT				rcGroupIcon;
	BOOL				fPrimaryKeyCol;
	LONG				lStateClick;
	LONG				lStateSort;
	BOOL				fGrouped;
	LONG				lStateAgg;
	BOOL				fFiltered;
	} ANSIDiagramColumnInfo, *PANSIDiagramColumnInfo;

typedef struct
	{
	UINT				uIdTableFrom;
	UINT				uIdTableTo;
	UINT				uIdColumnFrom;	// a value of 0 signifies no column
	UINT				uIdColumnTo;	// a value of 0 signifies no column
	RECT				rcExtent;		// value not always available
	LONG				lJoinType;
	LONG				lJoinOp;
	} DiagramJoinLineInfo, *PDiagramJoinLineInfo;

enum SelectionStates {
	eNotSelected = 0,
	ePrimarySelection = 1,
	eSelected = 2,
	};

// WebScope structures
enum LV_IsolationState {
	eNotAvailable = 0,
	eOrphaned = 1,
	eGhosted = 2,
	eGhosted_SC = 3,
	eReadOnly = 4,
	eReadOnly_SC = 5,
	eWorking = 6,
	eCheckedOut_SC = 7,
	eBroken = 8
	};

typedef struct
	{
	WCHAR wszURL[MAX_NAME_LEN];
	ULONG ulLoadState;
	BOOL fExternal;
	WCHAR wszType[MAX_NAME_LEN];
	WCHAR wszTooltip[MAX_NAME_LEN];
	WCHAR wszLabel[MAX_NAME_LEN];
	ObjectLocation locLabel;
	ULONG ulIsolationState;
	} WebObjectInfo, *PWebObjectInfo;

typedef struct
	{
	CHAR strURL[MAX_NAME_LEN];
	LONG ulLoadState;
	LONG fExternal;
	CHAR strType[MAX_NAME_LEN];
	CHAR strTooltip[MAX_NAME_LEN];
	CHAR strLabel[MAX_NAME_LEN];
	ObjectLocation locLabel;
	ULONG ulIsolationState;
	} VBWebObjectInfo, *PVBWebObjectInfo;

// Note: These values are chosen so that a bitwise or of eOutBound with
//			eInBound yields eOutAndInBound.  If you change the values,
//			you may have to modify code that uses them in this way.
enum LV_LinkDirection {
	eOutBound = 1,
	eInBound = 2,
	eOutAndInBound = 3
	};

//	grid message structure
typedef struct {
	HWND	hwndGrid;
	UINT	uMsgGrid;
	BOOL	fWParamByVal;
	BOOL	fLParamByVal;
	union {
		WPARAM	wparamGrid;
		ULONG	cbWParamBuffer;
		};
	union {
		LPARAM	lparamGrid;
		struct {
			ULONG	cbLParamBuffer;
			ULONG	iLParamOffset;
			};
		};
	BYTE	*rgbBuffer;				//	memory used for the buffer
	} GridMessagePacket, *PGridMessagePacket;

enum IsFullyLoadedReturnValues 
	{
	eNotInDiagram = -1,
	eNotFullyLoaded = 0,
	eFullyLoaded = 1,
	};

enum SchemaCommitHookFlags
	{
	eBeginTransaction = 1,
	eCommit = 2,
	eRollback = 4,
	};

typedef struct {
	LONG eViewType;
	} FieldListInfo, *PFieldListInfo;


// Site Designer structures ---------------------------------------------------

// The maximum number of nodes allowed on a given diagram
//	NOTE:  This is not a limit in Site Designer.
//	The problem is that it's difficult to dynamically allocate memory within
//	structures in VB, so we needed to pick a big (constant) number.
#define SDN_MAXNODES	1024

// NodeIDList - used whenever the caller wants a list of nodes to be returned
//	(if fDiagram is TRUE, the caller is requesting visible node controls on
//	the diagram, if fDiagram is FALSE, the caller is requesting nodes from the
//	site structure model in memory).
typedef struct {
	BOOL	fDiagram;	// TRUE if diagram-centered, FALSE if model-centered
	INT		cNodes;		// size of array, in UINTs
	UINT	rgnID[SDN_MAXNODES];	// array of node IDs
	} NodeIDList, *PNodeIDList;

typedef struct {
	ObjectLocation	olocPosition;	// size and position of a node control
									//	(coordinates are canvas himetric)
	ObjectLocation	olocExpand;		// size and position of expand/collapse btn
									//	(himetric, relative to node control)
	ObjectLocation	olocCaption;	// size and position of draggable caption
									//	(himetric relative to node control)
	ObjectLocation	olocEdit;		// size and position of the text box
									//	(himetric relative to node control)
	BOOL			fExpanded;		// TRUE if node is expanded
	BOOL			fExpandVisible;	// TRUE if +/- symbol is visible
	BOOL			fDirty;			// node's dirty flag
	BOOL			fHasEditCtrl;	// TRUE if an edit control is up
	CHAR			strEditText[MAX_NAME_LEN];	// contents of edit control
	UINT			nParentID;		// ID of parent (0 if none on diagram)
	SelectionStates	eSelect;		// selection state
	LayoutStyle		eLayout;		// layout direction of this node control	
	} NodeDiagramInfo, *PNodeDiagramInfo;

typedef struct {
	CHAR	strName[MAX_NAME_LEN];	// name of the node
	CHAR	strFile[MAX_NAME_LEN];	// associated file on the server
	BOOL	fDirty;					// node's dirty flag
	BOOL	fExternal;				// TRUE if not in current project
	UINT	nParentID;				// ID of parent (0 if a root/orphan node)
	} NodeModelInfo, *PNodeModelInfo;

enum SDN_ErrorCodes {
	eInvalidID		= -1,	// given ID doesn't correspond to a valid node
	eDiagramOnly	= -2,	// this message requires fDiagram = TRUE
	eCaughtException = -3,	// something threw!
	eError			= -100	// some other, unspecified error
	};


// Messages -------------------------------------------------------------------
#define WM_DaVinciBase			(WM_USER+1000)
#define WM_DaVinciQueryBase		(WM_DaVinciBase + 200)
#define WM_DaVinciWebScopeBase	(WM_DaVinciBase + 400)
#define WM_DaVinciSDNBase		(WM_DaVinciBase + 600)
//$ CONSIDER: split apart Schema messages from DaVinciBase

//	NOTE:
//		for the below comments, the wParam and lParam refer to those passed in
//		the VB code, not to the wParam and lParam sent to the component


//	----------------------------------------------------------------------------
//	message:		WM_UseTestHooks
//
//	description:	turns on the test hook mechanism for the given hwnd
//
//	wParam:			ignored
//
//	lParam:			size in bytes of shared memory to create
//
//	return value:	return values from CreateFileMapping and MapViewOfFile
//
#define WM_UseTestHooks			(WM_DaVinciBase + 0)

//	----------------------------------------------------------------------------
//	message:		WM_DontUseTestHooks
//
//	description:	turns off the test hook mechanism for the given hwnd
//
//	wParam:			ignored
//
//	lParam:			ignored
//
//	return value:	return values from CloseMapping and UnMapViewOfFile
//
#define WM_DontUseTestHooks			(WM_DaVinciBase + 1)

//	----------------------------------------------------------------------------
//	message:		WM_IsTableLoaded
//
//	description:	determines if a given table is loaded into the component
//
//	wParam:			ignored
//
//	lParam:			ANSI, null terminated string containing the table name
//
//	return value:	< 0	error, 0 table is not loaded, 1 table is loaded
//
#define	WM_IsTableLoaded		(WM_DaVinciBase + 2)

//	----------------------------------------------------------------------------
//	message:		WM_TableLocation
//
//	description:	returns the location and size of the table
//
//	wParam:			a PLocation which gets filled out
//
//	lParam:			ANSI, null terminated string containing the table name
//
//	return value:	< 0 error, S_OK ok
//
#define WM_TableLocation		(WM_DaVinciBase + 3)

//	----------------------------------------------------------------------------
//	message:		WM_ListTables
//
//	description:	returns a list of tables
//
//	wParam:			size in characters of buffer
//
//	lParam:			ANSI, null terminated string which will be filled in with
//					a comma delimited list of table names in quotes
//					"Table1", "this is table 2"
//
//	return value:	
//
#define WM_ListTables			(WM_DaVinciBase + 4)

//	----------------------------------------------------------------------------
//	message:		WM_ListRelationships
//
//	description:	returns a list of relationships
//
//	wParam:			size in characters of buffer
//
//	lParam:			ANSI, null terminated string which will be filled in with
//					a comma delimited list of relationship names in quotes
//
//	return value:	
//
#define WM_ListRelationships	(WM_DaVinciBase + 5)

//	----------------------------------------------------------------------------
//	message:		WM_GetViewport
//
//	description:	returns the location of the top left corner relative to
//					the DDS virtual canvas, and the width and height
//
//	wParam:			a PLocation which gets filled out
//
//	lParam:			ignored
//
//	return value:	
//
#define WM_GetViewport			(WM_DaVinciBase + 6)

//	----------------------------------------------------------------------------
//	message:		WM_ConnectorInfo
//
//	description:	returns the information for the specified connector
//
//	wParam:			a PConnectorInformation which gets filled out
//
//	lParam:			ANSI, null terminated string containing the connector name
//
//	return value:	
//
#define WM_ConnectorInfo		(WM_DaVinciBase + 7)  

//	----------------------------------------------------------------------------
//	message:		WM_IsTableSelected
//
//	description:	is the specified table selected?
//
//	wParam:			ignored
//
//	lParam:			ANSI, null terminated string containing the table name
//
//	return value:	
//
#define WM_IsTableSelected		(WM_DaVinciBase + 8)  

//	----------------------------------------------------------------------------
//	message:		WM_IsRelationshipSelected
//
//	description:	is the specified relationship selected?
//
//	wParam:			ignored
//
//	lParam:			ANSI, null terminated string containing the relationship name
//
//	return value:	
//
#define WM_IsRelationshipSelected		(WM_DaVinciBase + 9)  

//	----------------------------------------------------------------------------
//	message:		WM_IsLoadComplete
//
//	description:	is the background loading complete?
//
//	wParam:			ignored
//
//	lParam:			ignored
//
//	return value:	TRUE if complete, FALSE if not
//
#define WM_IsLoadComplete				(WM_DaVinciBase + 10)  

//	----------------------------------------------------------------------------
//	message:		WM_GridMessage
//
//	description:	wrapper around sendmessage to the grid.  The shared memory
//					must contain a GridMessagePacket.
//
//	wParam:			ignored
//
//	lParam:			ignored
//
//	return value:	return value from the sendmessage to the grid
//
#define WM_GridMessage				(WM_DaVinciBase + 11)  

//	----------------------------------------------------------------------------
//	message:		WM_IsFieldListFullyLoaded
//
//	description:	has the specified field list ocx fully loaded its grid & proxy
//
//	wParam:			ignored
//
//	lParam:			ANSI, null terminated string containing the table name
//
//	return value:	from IsFullyLoadedReturnValues enum:
//		< 0	error, 0 field list is not on diagram, 1 field list is fully loaded.
//
#define WM_IsFieldListFullyLoaded	(WM_DaVinciBase + 12)  

//	----------------------------------------------------------------------------
//	message:		WM_IsRelationLineFullyLoaded
//
//	description:	has the specified relation line ocx fully loaded its proxy
//
//	wParam:			ignored
//
//	lParam:			ANSI, null terminated string containing the relation name
//
//	return value:	from IsFullyLoadedReturnValues enum:
//		< 0	error, 0 relation line is not on diagram, 1 relation line is fully loaded.
//
#define WM_IsRelationLineFullyLoaded	(WM_DaVinciBase + 13)  

//	----------------------------------------------------------------------------
//	message:		WM_HwndGridOfFieldList
//
//	description:	return the grid control hwnd of the specified field list ocx,
//					FORCING it to fully load if the grid and proxy are not yet loaded.
//
//	wParam:			ignored
//
//	lParam:			ANSI, null terminated string containing the table name
//
//	return value:	NULL if error, valid hwnd if Success
//
#define WM_HwndGridOfFieldList		(WM_DaVinciBase + 14)  

//	----------------------------------------------------------------------------
//	message:		WM_SetDelayLoadMode
//
//	description:	turn of delay loading of proxies either on or off.
//
//	wParam:			boolean specifying On (1) or Off (0).
//
//	lParam:			ignored
//
//	return value:	S_OK
//
#define WM_SetDelayLoadMode			(WM_DaVinciBase + 15)  

//	----------------------------------------------------------------------------
//	message:		WM_SetCommitHooks
//
//	description:	turn commit hooks on/off
//
//	wParam:			any combination of SchemaCommitHookFlags
//
//	lParam:			ignored
//
//	return value:	S_OK if ok
//
#define WM_SetCommitHooks			(WM_DaVinciBase + 16)  

//	----------------------------------------------------------------------------
//	message:		WM_GetFieldListInfo
//
//	description:	get info about a particular field list
//
//	wParam:			ignored
//
//	lParam:			ANSI, null terminated string containing the table name
//
//	return value:	S_OK if ok
//
#define WM_GetFieldListInfo			(WM_DaVinciBase + 17)

//	----------------------------------------------------------------------------
//	message:		WM_FirePerformanceEvents
//
//	description:	turn on firing performance events
//	IMPORTANT NOTE:	the performance events are sent using PostMessage rather
//					than SendMessage so that the act of sending them doesn't
//					adversely screw up the timings.  This means that consumers
//					of these messages MUST use GetMessageTime to get the time
//					the message was posted.
//
//	wParam:			ignored
//
//	lParam:			HWND to send the events to
//
//	return value:	S_OK if ok
//
#define WM_FirePerformanceEvents	(WM_DaVinciBase + 18)

//	----------------------------------------------------------------------------
//	message:		WM_AllTablesLoaded
//
//	description:	message to notify test that all tables have been loaded
//
//	wParam:			0
//
//	lParam:			0
//
//	return value:	should always be S_OK
//
#define WM_AllTablesLoaded			(WM_DaVinciBase + 19)

//	----------------------------------------------------------------------------
//	message:		WM_TableLoaded
//
//	description:	message to notify test that one table has been loaded
//
//	wParam:			0
//
//	lParam:			0
//
//	return value:	should always be S_OK
//
#define WM_TableLoaded				(WM_DaVinciBase + 20)

//	---------------------------------------------------------------------------
//	message:		WM_DiagramInfo
//
//	description:	message to determine information about diagram (zoom,
//					viewport size, etc.)
//
//		NOTE:  Only supported by Site Designer at the moment
//
//	wParam:			0
//
//	lParam:			pointer to a DiagramInfo structure
//
//	return value:	negative for error, 0 for success (S_OK)
//
#define WM_DiagramInfo				(WM_DaVinciBase + 21)



// Query test hooks -----------------------------------------------------------

// Diagram pane hooks

//-----------------------------------------------------------------------------
// Message:		WM_DiagramEnumTables
//
// Description:	Used to obtain a list of table ids currently on the diagram
//				surface
//
// wParam:		[IN] Maximum number of elements the passed in array can hold. 
//				If there are more tables on the diagram than wParam, only
//				the first wParam of them are returned, and the return value
//				is wParam. If lParam is NULL, this value is ignored.
//
// lParam:		[OUT] A pointer to an array of UINTs that is used to receive
//				table ids. If this pointer is NULL, a count of the number of
//				tables is returned
//
// Return Value:The number of tables whose ids have been passed back (0..n)
//				if lParam was non-null. If lParam was NULL, it will return
//				the total number of tables currently in the diagram.
//				-ve values to indicate error.
//-----------------------------------------------------------------------------
#define WM_DiagramEnumTables		(WM_DaVinciQueryBase + 0)  

//-----------------------------------------------------------------------------
// Message:		WM_DiagramTableInfo
//
// Description:	Used to obtain info about a particular table (ECL) on the 
//				diagram	surface.
//
// wParam:		[IN] Table ID as a UINT. This must be one of the values
//				returned by the WM_DiagramEnumTables message, otherwise
//				an E_INVALIDARG is returned.
//
// lParam:		[OUT] A pointer to a DiagramTableInfo struct (PDiagramTableInfo)
//				If this is NULL, E_INVALIDARG is returned
//
// Return Value:0 on success, -ve values on failure
//-----------------------------------------------------------------------------
#define WM_DiagramTableInfo			(WM_DaVinciQueryBase + 1)  

//-----------------------------------------------------------------------------
// Message:		WM_DiagramIsTableVisible
//
// Description:	Determines whether the particular table (ECL) on the 
//				diagram	surface is currently visible or hidden
//
// wParam:		[IN] Table ID as a UINT. This must be one of the values
//				returned by the WM_DiagramEnumTables message, otherwise
//				an E_INVALIDARG is returned.
//
// lParam:		unused
//
// Return Value:A group of bit flags. The following describes the meaning of
//				the various bits when set:
//
//				fTableVisibleYes : table is currently in the visible region of
//				the diagram pane
//				fTableVisiblePartial : table is only partially visible if this
//				bit is set. This bit can only be set if fTableVisibleYes is set
//				(If this bit is not set & fTableVisibleYes is set, the table
//				is fully visible)
//				fTableVisibleObscured : table is partially or fully obsured
//				by another table which is above it in the z-order.
//				-ve values on failure
//-----------------------------------------------------------------------------
#define WM_DiagramIsTableVisible	(WM_DaVinciQueryBase + 2)  

//-----------------------------------------------------------------------------
// Message:		WM_DiagramIsTableSelected
//
// Description:	Tells whether the particular table (ECL) is currently selected
//				or not. Note that the table's column may be selected while the
//				table itself may not be selected.
//
// wParam:		[IN] Table ID as a UINT. This must be one of the values
//				returned by the WM_DiagramEnumTables message, otherwise
//				an E_INVALIDARG is returned.
//
// lParam:		Not used
//
// Return Value:1 if selected, 0 if not selected, -ve values on failure
//-----------------------------------------------------------------------------
#define WM_DiagramIsTableSelected	(WM_DaVinciQueryBase + 3)  

//-----------------------------------------------------------------------------
// Message:		WM_DiagramEnumTableColumns
//
// Description:	Used to obtain a list of column ids for a given table which is
//				currently on the diagram surface
//
// wParam:		[IN] Table ID as a UINT. This must be one of the values
//				returned by the WM_DiagramEnumTables message, otherwise
//				an E_INVALIDARG is returned.
//
// lParam:		[OUT] A pointer to an array of UINTs that is used to receive
//				column ids. If this pointer is NULL, a count of the number of
//				columns is returned
//
// Return Value:The number of columns whose ids have been passed back (0..n)
//				if lParam was non-null. If lParam was NULL, it will return
//				the total number of columns in that table
//				-ve values to indicate error.
//
// Note:		Column ids are listed in the order they appear in the table.
//				Also column ids are unique over the entire set of tables in the
//				diagram surface
//-----------------------------------------------------------------------------
#define WM_DiagramEnumTableColumns	(WM_DaVinciQueryBase + 4)  

//-----------------------------------------------------------------------------
// Message:		WM_DiagramTableColumnInfo
//
// Description:	Used to obtain info about a particular column in a table on the 
//				diagram	surface.
//
// wParam:		[IN] Column ID as a UINT. This must be one of the values
//				returned by the WM_DiagramEnumTableColumns message, otherwise
//				an E_INVALIDARG is returned.
//
// lParam:		[OUT] A pointer to a DiagramColumnInfo struct 
//				(PDiagramColumnInfo) If this is NULL, E_INVALIDARG is returned
//
// Return Value:0 on success, -ve values on failure
//-----------------------------------------------------------------------------
#define WM_DiagramTableColumnInfo	(WM_DaVinciQueryBase + 5)  

//-----------------------------------------------------------------------------
// Message:		WM_DiagramIsTableColumnSelected
//
// Description:	Tells whether the particular column is currently selected
//				or not. Note that the table's column may be selected while the
//				table itself may not be selected.
//
// wParam:		[IN] Column ID as a UINT. This must be one of the values
//				returned by the WM_DiagramEnumTableColumns message, otherwise
//				an E_INVALIDARG is returned.
//
// lParam:		Not used
//
// Return Value:1 if selected, 0 if not selected, -ve values on failure
//-----------------------------------------------------------------------------
#define WM_DiagramIsTableColumnSelected	(WM_DaVinciQueryBase + 6)  

//-----------------------------------------------------------------------------
// Message:		WM_DiagramEnumJoinLines
//
// Description:	Used to obtain a list of join line ids currently on the diagram
//				surface
//
// wParam:		[IN] Maximum number of elements the passed in array can hold. 
//				If there are more join lines on the diagram than wParam, only
//				the first wParam of them are returned, and the return value
//				is wParam. If lParam is NULL, this value is ignored.
//
// lParam:		[OUT] A pointer to an array of UINTs that is used to receive
//				join line ids. If this pointer is NULL, a count of the number 
//				of join lines is returned
//
// Return Value:The number of join line ids that have been passed back (0..n)
//				if lParam was non-null. If lParam was NULL, it will return
//				the total number of join lines currently in the diagram.
//				-ve values to indicate error.
//-----------------------------------------------------------------------------
#define WM_DiagramEnumJoinLines		(WM_DaVinciQueryBase + 7)  

//-----------------------------------------------------------------------------
// Message:		WM_DiagramJoinLineInfo
//
// Description:	Used to obtain info about a particular join line on the 
//				diagram	surface.
//
// wParam:		[IN] Join Line ID as a UINT. This must be one of the values
//				returned by the WM_DiagramEnumJoinLines message, otherwise
//				an E_INVALIDARG is returned.
//
// lParam:		[OUT] A pointer to a DiagramJoinLineInfo struct 
//				(PDiagramJoinLineInfo) If NULL, E_INVALIDARG is returned
//
// Return Value:0 on success, -ve values on failure
//-----------------------------------------------------------------------------
#define WM_DiagramJoinLineInfo		(WM_DaVinciQueryBase + 8)  

//-----------------------------------------------------------------------------
// Message:		WM_DiagramIsJoinLineSelected
//
// Description:	Tells whether the particular join line is currently selected
//				or not. 
//
// wParam:		[IN] Join Line ID as a UINT. This must be one of the values
//				returned by the WM_DiagramEnumJoinLines message, otherwise
//				an E_INVALIDARG is returned.
//
// lParam:		Not used
//
// Return Value:1 if selected, 0 if not selected, -ve values on failure
//-----------------------------------------------------------------------------
#define WM_DiagramIsJoinLineSelected	(WM_DaVinciQueryBase + 9)  

//-----------------------------------------------------------------------------
// Message:		WM_GetActivePane
//
// Description:	Returns the hwnd of the currently active pane in the query 
//				designer
//
// wParam:		Not used
//
// lParam:		Not used
//
// Return Value: a valid hwnd, NULL on failure
//-----------------------------------------------------------------------------
#define WM_GetActivePane	(WM_DaVinciQueryBase + 10)  

//-----------------------------------------------------------------------------
// Message:			WM_DataPaneQueryComplete
//
// Description:		Used to notify test when the query result pane 
//					is about to be populated as a result of an executed query
//					(strictly speaking, at the moment when the query is complete).
//
// wParam:			Not used
//
// lParam:			Not used
//
// Return Value:	should always be S_OK
//-----------------------------------------------------------------------------
#define WM_DataPaneQueryComplete	(WM_DaVinciQueryBase + 11)  

//-----------------------------------------------------------------------------
// Message:			WM_LV_GetWebObjectInfo
//
// Description:		Returns information about the webobject specified
//
// wParam:			A pointer to a WebObjectInfo structure to be filled in
//
// lParam:			ANSI, null terminated string containing the Web Object ID.
//
// Return Value:	< 0 error, S_OK ok
//-----------------------------------------------------------------------------
#define WM_LV_GetWebObjectInfo		(WM_DaVinciWebScopeBase + 0)


//----------------------------------------------------------------------------
// message:			WM_LV_WebScopeClusterExpanded
//
// description:		message to notify test that the cluster has been expanded
//
// wParam:			0
//
// lParam:			0
//
// return value:	should always be S_OK
//
#define WM_LV_WebScopeClusterExpanded 	(WM_DaVinciWebScopeBase + 1)

//----------------------------------------------------------------------------
// message:			WM_LV_GetZoomFactor
//
// description:		Return the zoom factor
//
// wParam:			0
//
// lParam:			0
//
// return value:	the zoom factor
//
#define WM_LV_GetZoomFactor	(WM_DaVinciWebScopeBase + 2)

//----------------------------------------------------------------------------
// message:			WM_LV_GetLayoutStyle
//
// description:		Return the layout style
//
// wParam:			0
//
// lParam:			0
//
// return value:	current layout style (enum LayoutStyle)
//
#define WM_LV_GetLayoutStyle	(WM_DaVinciWebScopeBase + 3)

//-----------------------------------------------------------------------------
// Message:			WM_LV_IsWebObjectValid
//
// Description:		Determines if the passed in Web Object ID refers to a
//					currently existing diagram web object.
//
// wParam:			0
//
// lParam:			ANSI, null terminated string containing the Web Object ID.
//
// Return Value:	1 object exists.  0 object does not exist.  <0 error.
//-----------------------------------------------------------------------------
#define WM_LV_IsWebObjectValid		(WM_DaVinciWebScopeBase + 4)

//----------------------------------------------------------------------------
// message:			WM_LV_GetLinkDirection
//
// description:		Return the link direction
//
// wParam:			0
//
// lParam:			0
//
// return value:	current link direction (enum LV_LinkDirection)
//
#define WM_LV_GetLinkDirection	(WM_DaVinciWebScopeBase + 5)

//-----------------------------------------------------------------------------
// Message:			WM_IsConnectorValid
//
// Description:		Determines if the passed in Web Link ID refers to a
//					currently existing diagram connector.
//
// wParam:			0
//
// lParam:			ANSI, null terminated string containing the Web Link ID.
//
// Return Value:	1 object exists.  0 object does not exist.  <0 error.
//-----------------------------------------------------------------------------
#define WM_LV_IsConnectorValid		(WM_DaVinciWebScopeBase + 6)


//-----------------------------------------------------------------------------
//
//	Site Designer test hooks
//
//-----------------------------------------------------------------------------
//	---------------------------------------------------------------------------
//	message:		WM_SDN_EnumerateNodes
//
//	description:	message to enumerate all of the visible nodes on a diagram.
//
//	wParam:			not used
//
//	lParam:			pointer to a NodeIDList structure
//
//	return value:	negative for error, otherwise the number of nodes on the
//					diagram (see SDN_ErrorCodes above)
//
#define WM_SDN_EnumerateNodes			(WM_DaVinciSDNBase + 0)

//	---------------------------------------------------------------------------
//	message:		WM_SDN_NodeDiagramInfo
//
//	description:	message returns diagram-specific information about a given
//					node control
//
//	wParam:			ID of the node we're interested in
//
//	lParam:			pointer to a NodeDiagramInfo structure
//
//	return value:	negative for error, 0 for success (S_OK)
//					 (see SDN_ErrorCodes above)
//
#define WM_SDN_NodeDiagramInfo			(WM_DaVinciSDNBase + 1)

//	---------------------------------------------------------------------------
//	message:		WM_SDN_NodeModelInfo
//
//	description:	message returns model-specific information about a given
//					node.
//
//	wParam:			ID of the node
//
//	lParam:			pointer to a NodeModelInfo structure
//
//	return value:	negative for error, 0 for success (S_OK)
//
#define WM_SDN_NodeModelInfo			(WM_DaVinciSDNBase + 2)

//	---------------------------------------------------------------------------
//	message:		WM_SDN_GetNodeSiblings
//
//	description:	message to return a list of a given node's siblings.
//
//	wParam:			ID of the node we want siblings for
//
//	lParam:			pointer to a NodeIDList structure
//
//	return value:	negative for error, otherwise the number of siblings
//					 (see SDN_ErrorCodes above)
//
#define WM_SDN_GetNodeSiblings			(WM_DaVinciSDNBase + 3)

//	---------------------------------------------------------------------------
//	message:		WM_SDN_GetNodeChildren
//
//	description:	message to determine information about diagram (zoom,
//					viewport size, etc.)
//
//	wParam:			ID of the node we want children of
//
//	lParam:			pointer to a NodeIDList structure
//
//	return value:	negative for error, otherwise the number of children
//					 (see SDN_ErrorCodes above)
//
#define WM_SDN_GetNodeChildren			(WM_DaVinciSDNBase + 4)


//	---------------------------------------------------------------------------
//	message:		WM_SDN_SaveModel
//
//	description:	message to request that the site structure model be saved
//					to a specified output file.
//
//	wParam:			not used
//
//	lParam:			pointer to the null-terminated ANSI filename (full path)
//
//	return value:	negative for error, 0 for success
//
#define WM_SDN_SaveModel				(WM_DaVinciSDNBase + 5)


#endif	// _TESTHOOK_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ParamHlp\Sniff\Src\ParamHlpCases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      ParamHlpCases.cpp
//
//      Description :
//              Implementation of CParamHlpCases

#include "stdafx.h"
#include "ParamHlpCases.h"
#include "TextFile.h"

#define new DEBUG_NEW

#define MTT_TYPEPREFIX 0
#define MTT_TYPEPOSTFIX 1
#define MTT_NAME 2
#define MTT_DESCRIPTION 3

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CParamHlpCases, CTest, "ParamHlp", -1, CParamHlpSuite)

void CParamHlpCases::Run(void)
{
	EditSource();
}

void CParamHlpCases::EditSource()
{
	int		nCount = 0;
	int		nResult;
	LRESULT lLength;
	HWND	hWnd;
	TCHAR*	pText;
	CString strMethod = "malloc";		// Need to put this in a string resource

	m_pLog->Comment("Open a source file.");

	// Open a source file
	nResult = src.Open("ParamHlp01.cpp");

	if (nResult == ERROR_ERROR) {
		m_pLog->RecordFailure("Couldn't open source file ParamHlp01.cpp");
	}
	else {
		// Move down the file to a place where 
		// we can enter some Parameter Help code.
		src.GoToLine(53);
		
		// Wait for Go To dialog to go away
		while ((MST.WFndWnd("Go To", FW_DEFAULT)) && (nCount < 1000)) {
			nCount++;
		}

		MST.DoKeys("{ENTER 2}");
		MST.DoKeys("{UP 2}");

		// while loop through the list of APIs
		CTextFile fileIn;
		CTextFile fileOut;
		
		if (!fileIn.Open("baseln\\Win32API.txt", CFile::modeRead)) {
			m_pLog->RecordFailure("Couldn't open Win32API.txt");
		}
		else {
		
			// Open file to write failures
			fileOut.Open("failures.txt", CFile::modeCreate | CFile::modeWrite);

			while (fileIn.ReadLn(strMethod )) {
				MST.DoKeys(strMethod);
				MST.DoKeys("{(}");

				hWnd = MST.WFndWndWaitC("", "VsTipWindow", FW_DEFAULT, 1);

				if (hWnd == 0) {
					m_pLog->RecordFailure("Couldn't find Parameter Help window. Function: %s", strMethod);
					fileOut.WriteLn(strMethod);
				}
				else {
					if (MST.WIsVisible(hWnd)) {
						// Get the method name
						SendMessage(hWnd, WM_SETTITLETOMETHOD, MTT_NAME, 0);
						lLength = GetWindowTextLength(hWnd) + sizeof(TCHAR);
						pText = new TCHAR[lLength];
						GetWindowText(hWnd, pText, lLength);
				
						if (strcmp(pText, strMethod) != 0) {
							m_pLog->RecordFailure("Parameter Help does not match expectation.\n\t\tParameter Help = '%s'\n\t\tExpected '%s'", pText, strMethod);
							fileOut.WriteLn(strMethod);
						}

						delete [] pText;
					}
					else {
						m_pLog->RecordFailure("Parameter Help window is not visible. Function: %s", strMethod);
						fileOut.WriteLn(strMethod);
					}
				}

				MST.DoKeys("{)};");
				MST.DoKeys("{ENTER}");
			}
			
			fileIn.Close();
			fileOut.Close();
		}

		src.Close();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ParamHlp\Sniff\Src\ParamHlpSuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ParamHlpSuite.cpp
//
//	Description :
//		Implementation of the CParamHlpSuite class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "ParamHlpSuite.h"

// ADD INCLUDES FOR CASES HERE
// EXAMPLE: #include "Feature1Cases.h"
#include "ParamHlpCases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CParamHlpSuite

IMPLEMENT_SUBSUITE(CParamHlpSuite, CIDESubSuite, "ParamHlp", "MHopkins x60946")

BEGIN_TESTLIST(CParamHlpSuite)
// ADD "TEST" ENTRY FOR CASES HERE
// EXAMPLE: TEST(CFeature1Cases, RUN)
	TEST(CParamHlpCases, RUN)
END_TESTLIST()

void CParamHlpSuite::SetUp(BOOL bCleanUp)
{

	int nResult;

	KillAllFiles(m_strCWD + "baseln\\ParamHlp01");
	nResult = prj.NewProject(UIAW_PT_APPWIZ, "ParamHlp01", m_strCWD + "baseln\\ParamHlp01", PLATFORM_WIN32_X86);

	if (nResult == ERROR_SUCCESS) {
		m_pLog->RecordSuccess("Created the project.");
	}
	else {
		m_pLog->RecordFailure("Failed creating project %sbaseln\\ParamHlp01", m_strCWD);
	}

}

void CParamHlpSuite::CleanUp(void)
{

	int nResult;

	// Close the project;
	nResult = prj.Close(FALSE);

	if (nResult != ERROR_SUCCESS) {
		m_pLog->RecordFailure(_T("Failed closing the project."));
	}
	else {
		m_pLog->RecordSuccess(_T("Closed the project."));
	}

	CIDESubSuite::CleanUp();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ParamHlp\Sniff\Src\ParamHlpSuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	ParamHlpSuite.h
//
//	Description :
//		Declaration of the CParamHlpSuite class
//

#ifndef __ParamHlpSuite_H__
#define __ParamHlpSuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#define WM_GETLISTCOUNT     (WM_USER+401) // Return number of items in completion set
#define WM_GETLISTITEMLEN   (WM_USER+402) // Return length of item (0-based index in wParam)
#define WM_GETLISTITEMTEXT  (WM_USER+403) // Copy text of item (index in wParam) to lParam
#define WM_GETLISTMATCH     (WM_USER+404) // Return index of matched (not necessarily selected) item
#define WM_GETLISTSELECTION (WM_USER+405) // Return index of selected item (-1 if nothing selected)
#define WM_GETDESCWINDOW    (WM_USER+406) // Return the window handle of the description window (an edit control)
#define WM_SETTITLETOITEM   (WM_USER+407) // Set the window title of the namelist to the current selection

#define WM_GETMETHODTEXTLEN (WM_USER+502) // Return length of text of current method (methodtexttype in wParam)
#define WM_GETPARMTEXTLEN   (WM_USER+505) // Return length of parameter text (LOWORD(wParam) = parm#,

#define WM_SETTITLETOMETHOD	(WM_USER+509) // Set Window Title to Method name
#define WM_SETTITLETOPARAM	(WM_USER+510) // Set Window Title to Param Text

#define WM_SETTITLETOTEXT   (WM_USER+601) // Set the window title to the text in the window
// #define WM_GETTEXTLEN	(WM_USER+409) // Get the length of the text in the window

///////////////////////////////////////////////////////////////////////////////
// CParamHlpSuite class

class CParamHlpSuite : public CIDESubSuite
{
	DECLARE_SUBSUITE(CParamHlpSuite)

	DECLARE_TESTLIST();

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
	virtual void CleanUp(void);

// data members
public:
	COProject prj;
	COSource  src;
};

#endif //__ParamHlpSuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ParamHlp\Sniff\Src\TextFile.h ===
#include "stdafx.h"

class CTextFile : public CFile
{
public:
	int ReadLn(CString& str);
	void WriteLn(CString str);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ParamHlp\Sniff\Src\TextFile.cpp ===
#include "TextFile.h"


int CTextFile::ReadLn(CString& str)
{
	char *ch = new char;
	int nLength = 0;
	str = "";

	while ((Read(ch, 1)) && (*ch != (char)13)) {
		str += *ch;
		nLength++;
	}

	if (*ch == (char)13) {
		// Eat next char ((char)10)
		Read(ch, 1);
	}

	delete ch;
	return nLength;
}

void CTextFile::WriteLn(CString str)
{
	static long lCount = 0;
	CString strWrite;
	
	strWrite.Format("%d\t%s\r\n", ++lCount, str);

	try {
		Write(strWrite, strWrite.GetLength());
		Flush();
	}
	catch(CFileException e) {
		CString strErr;
		strErr.Format("Failed writing to failures file. Cause:%s", e.m_cause);
		MessageBox(AfxGetMainWnd()->m_hWnd, strErr, "WriteLn Error", MB_OK);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\batchbld\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ParamHlp\Sniff\Src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	stdafx.cpp
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\batchbld\batch1.h ===
///////////////////////////////////////////////////////////////////////////////
//	batch1.H
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Declaration of the Cbatch1Test class

#ifndef __batch1_H__
#define __batch1_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "batchsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CBatchBuildTest1 class

class CBatchBuildTest1 : public CProjectTestSet
{
	DECLARE_TEST(CBatchBuildTest1, CBatchSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL Test1();

// Utilities

};

#endif //__batch1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\batchbld\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\prjset.h ===
///////////////////////////////////////////////////////////////////////////////
//	PRJSET.H
//
//	Created by :			Date :
//		YefimS					4/28/97
//
//	Description :
//		Declaration of base class containing common data and methods for all
//		Project Test Sets.

#ifndef __PRJSET_H__
#define __PRJSET_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

extern int ReturnCode;

#define EXPECT_TRUE(f)    ((f)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f));
#define EXPECT_SUCCESS(f) (((ReturnCode=(f))==0)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f,ReturnCode));
#define EXPECT_TRUE_COMMENT(f,comment) ((f)?LogResult(__LINE__, PASSED,#f,0,#comment):LogResult(__LINE__, FAILED,#f,0,#comment));

// Global variables
#define WSPEXTENSION	".DSW"
#define PRJEXTENSION	".DSP"
#define NEWEXEINTDIR	"EXEInt"
#define NEWEXEOUTDIR	"EXEOut"
#define BUILDRES		"buildres.out"
#define PLATFORMS		PLATFORM_WIN32_X86 + PLATFORM_MAC_68K + PLATFORM_MAC_PPC
//#define V4PROJDIR		"Hello.V4"

#if defined(_MIPS_)
#define TOOLSDIR "tools\\mips"
#elif defined(_ALPHA_)
#define TOOLSDIR "tools\\alpha"
#else
#define TOOLSDIR "tools\\x86"
#endif

// extern CString cstrRelease ;// =  GetLocString(IDSS_BUILD_RELEASE);
// extern CString cstrDebug ;// =  GetLocString(IDSS_BUILD_DEBUG);
extern CString RELEASETARGET; // = " - Win32 " + cstrRelease;
extern CString DEBUGTARGET; // = " - Win32 " + cstrDebug;

///////////////////////////////////////////////////////////////////////////////
//	class CProjectTestSet used as base for project tests

class CProjectTestSet : public CTest
{
//	DECLARE_TEST(CProjectTestSet, CIDESubSuite /*CCORESubSuite*/)
		DECLARE_DYNAMIC(CProjectTestSet)
public:	
	// since this class is a base class for tests, it must have a ctor
	// that takes all test parameters for proper base class initialization
	CProjectTestSet(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename = NULL);

protected: // data
//	CString	m_strProjectDir;
	CString	m_strProjName;
	CString	m_szErrorText;
	int m_platform;
//	CString m_strCurDir;
	CString m_szBuildToolsLoc;
//	CString m_szProjEXELoc;	
	CString m_strProjLoc;	

	COSource src;
	COProject prj;
 	COWorkSpace ws;
	CODebug dbg;
	COBrowse browse;
	COFile file;

//	typedef enum {PROJECT_EXE, PROJECT_DLL} PROJECT_TYPE;
//?	typedef enum {fDefault, fBuildOnly} PROJECT_FLAGS;

	void LogResult(int line, int result,LPCSTR szoperation, int code=0, LPCSTR szComment="");
	LPCSTR HomeDir(void);
	LPCSTR FullPath(LPCSTR szAddPath);
	void LogTestHeader(LPCSTR test_desc_str);
	void LogSubTestHeader(LPCSTR test_desc_str);

	void RemoveTestFiles( CString szProjLoc );
	BOOL TouchFile( CString szFileName );

	BOOL TouchAndVerifyRebuild(
		CString szFileToTouch,
		BOOL	bShouldRebuild = TRUE
		);

	time_t GetFileTime( CString szFileName );
	BOOL SetToolsDir( CString szToolsLoc );
	BOOL RemoveToolsDir( CString szToolsLoc );
	CString GetBldLog();
	BOOL VerifyBuildOccured( BOOL iBuild );
	int VerifyBuildString( LPCSTR verifyString, BOOL fExist = TRUE );
	BOOL CopyProjectSources( LPCSTR szSRCFileLoc, LPCSTR szProjLoc );
	BOOL UpdateBuildVerify( LPCSTR szCurrentFile, LPCSTR szNewFile, LPCSTR szFileString );

};

#endif //__PRJSET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomaw\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\batchbld\batch1.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	batch1.CPP
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Implementation of the CBatchBuildTest1 class

#include "stdafx.h"
#include "batch1.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CBatchBuildTest1, CProjectTestSet, "Doing....", -1, CBatchSubSuite)

void CBatchBuildTest1::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CSuite1Test

void CBatchBuildTest1::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( Test1() );
	XSAFETY;

}


BOOL CBatchBuildTest1::Test1( void )
{
	LogTestHeader("Test1");

// Write the test

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\prjset.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	PRJSET.CPP
//
//	Created by :			Date :
//		YefimS					4/28/97
//
//	Description :
//		Definition of base class containing common data and methods for all
//		Project Test Sets.

#include "stdafx.h"
#include "prjset.h"
#include "guitarg.h"
//#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#define WAIT_FOR_BUILD 8
// I added this because it seems to be missing from this module (t-seanc)
int ReturnCode = 0;

IMPLEMENT_DYNAMIC(CProjectTestSet, CTest)

CProjectTestSet::CProjectTestSet(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename /*= NULL*/)
: CTest(pSubSuite, szName, nExpectedCompares, szListFilename)
{
}

void CProjectTestSet::RemoveTestFiles( CString szProjLoc )
{
	KillAllFiles( szProjLoc );
}
	
BOOL CProjectTestSet::TouchFile( CString szFileName )
{
	m_pLog->RecordInfo("Touching time stamp on %s", szFileName);
	// A FMN to give the OS a chance to commit the File Change
	// It's a Win98 and Win95 feature
	Sleep(3000);
	// make the change
	if ( _utime( szFileName, NULL ) == -1 ) {
		return FALSE;
	}
	Sleep(3000);

	return TRUE;
}

time_t CProjectTestSet::GetFileTime( CString szFileName )
{
	struct _stat buf;
	int result = _stat( szFileName, &buf );
	return( buf.st_mtime );
}

BOOL CProjectTestSet::SetToolsDir(CString szToolsLoc)
{
//	Set build tools directory to point to dummy build tools (which
//	must be provided by us)

	COEnvironment OptionsDirectories;
	
	if ( !VERIFY_TEST_SUCCESS( OptionsDirectories.PrependDirectory(szToolsLoc, DIR_TYPE_EXE, PLATFORM_WIN32_X86)) )
	{
		return FALSE;
	}

	return TRUE;
}

BOOL CProjectTestSet::RemoveToolsDir(CString szToolsLoc)
{
	COEnvironment OptionsDirectories;
	
	if ( !VERIFY_TEST_SUCCESS( OptionsDirectories.RemoveDirectory(szToolsLoc, DIR_TYPE_EXE, PLATFORM_WIN32_X86)) )
	{
		return FALSE;
	}

	return TRUE;
}

CString CProjectTestSet::GetBldLog()
{
	CString BuildRecord;
	CString str;
	
	// Get build data
	UIWB.DoCommand(IDM_WINDOW_ERRORS,DC_ACCEL);  // goto output window
	MST.DoKeys("^{END}");			// goto end
	MST.DoKeys("+^{HOME}");			// select whole build record
	MST.DoKeys("^c");				// copy it
	GetClipText(BuildRecord);       // get text from clipboard
	MST.DoKeys("{ESC}");            // return focus from output window
	BuildRecord.MakeLower();
	return (BuildRecord);
	
};

void CProjectTestSet::LogTestHeader(LPCSTR test_desc_str)
{
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("TEST: %s", test_desc_str);
}

void CProjectTestSet::LogSubTestHeader(LPCSTR test_desc_str)
{
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("SubTest: %s", test_desc_str);
}


void CProjectTestSet::LogResult(int line, int result,LPCSTR szoperation, int code /* 0 */, LPCSTR szComment /* "" */)
{
	CString szOpCom = (CString)szoperation + "  " + szComment;
	if(result == PASSED)
		m_pLog->RecordSuccess("%s", szOpCom);
	else
	{
		CString szextra;
		char chbuf[24];
		szextra = szextra + "Error Code = " + itoa(code, chbuf, 10);
		m_pLog->RecordFailure("LINE %d %s", line, szextra + szOpCom);
	}
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Function: TouchAndVerifyRebuild

	This function sets the last modified time stamp on the file specifed
	to the current time and sends a Build command to DevStudio.  It then
	checks to make sure that the build actually occured.
  
	Parameter: CString szFileToTouch
	
	This should be the path that specifies the file to be touched before
	the rebuild occurs.

	Parameter: BOOL bShouldRebuild

	This parameter specifies whether or not a rebuild is expected to happen.
	If it is TRUE and the build does not happen, that will generate an error.
	If it is FALSE, and the build happens, that will generate an error.  The
	default value for this parameter is TRUE.
	  
	Return Value: BOOL

	This function returns TRUE if the build occurs and FALSE if the build
	does not occur.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
BOOL CProjectTestSet::TouchAndVerifyRebuild
	( 
	CString szFileToTouch,
	BOOL	bShouldRebuild  /* = TRUE */
	)

	{
	// Make sure the string is non-null
//	_ASSERTE(szFileToTouch != NULL);	// bogus assert

	// Make sure the file exists
	OFSTRUCT ofs;
	ofs.cBytes = sizeof(OFSTRUCT);
	if(OpenFile(szFileToTouch, &ofs, OF_EXIST) == HFILE_ERROR)
		{
		m_pLog->RecordFailure(
			_T("%s"), 
			szFileToTouch + _T(": file does not exist.")
			);
		}
	
	// Change the last modified time to the current time
	TouchFile(szFileToTouch);
	
	// Rebuild the project and return whether or not the build happens
	prj.Build(WAIT_FOR_BUILD);
	return VerifyBuildOccured(bShouldRebuild);
	}

BOOL CProjectTestSet::VerifyBuildOccured( BOOL iBuild )
{
	// iBuild == TRUE  -  project should be rebuilt
	// iBuild == FALSE  -  project should not be rebuilt

	// Get the output window contents
	CString szBldLog = GetBldLog();
	if (szBldLog == "")
	{
		m_pLog->RecordFailure("Incorrect build: Output window is empty");
		return FALSE;
	}
	
	int iFoundCompiling = szBldLog.Find (GetLocString(IDSS_OUTPUTWIN_COMPILING));
	int iFoundLinking = szBldLog.Find (GetLocString(IDSS_OUTPUTWIN_LINKING));

	if( iBuild )
	{
		if( (iFoundCompiling < 0) && (iFoundLinking < 0) )
		{
			m_pLog->RecordFailure("Incorrect build: can't find %s or %s",GetLocString(IDSS_OUTPUTWIN_COMPILING), GetLocString(IDSS_OUTPUTWIN_LINKING) );
			m_pLog->RecordInfo(szBldLog);
			return FALSE;
		}
	}
	else
	{
		if ( (iFoundCompiling > 0) || (iFoundLinking > 0) )
		{
			m_pLog->RecordFailure("Nothing changed, the project shouldn't be rebuilt.");
			m_pLog->RecordInfo(szBldLog);
			return FALSE;
		}
	}

	return TRUE;
}

int CProjectTestSet::VerifyBuildString( LPCSTR verifyString, BOOL fExist /* TRUE */ )
{
	int iFoundString;

	// Get the output window contents
	CString szBldLog = GetBldLog();
	CString testString = verifyString;

	// For some reason the output window text is always lower case when extracted.

	testString.MakeLower();
	iFoundString = szBldLog.Find(testString);

	if ( (iFoundString < 0) && fExist )
	{
		m_pLog->RecordFailure("Can't find %s", verifyString);
		m_pLog->RecordInfo(szBldLog);
	}
	
	if ( (iFoundString >= 0) && !fExist )
	{
		m_pLog->RecordFailure("Found %s : it should not be there", verifyString);
		m_pLog->RecordInfo(szBldLog);
	}

	return iFoundString;
}

BOOL CProjectTestSet::CopyProjectSources( LPCSTR szSRCFileLoc, LPCSTR szProjLoc )
{
	CString szPattern		= (CString)szSRCFileLoc + "*.*";

	// Copy sources to the project directory
	WIN32_FIND_DATA ffdImgFile;
    HANDLE hFile = FindFirstFile(szPattern, &ffdImgFile);
    if( hFile != INVALID_HANDLE_VALUE )
    {
        do
        {
			CopyFile( (CString)szSRCFileLoc + ffdImgFile.cFileName, (CString)szProjLoc + ffdImgFile.cFileName, FALSE );
			SetFileAttributes((CString)szProjLoc + ffdImgFile.cFileName, FILE_ATTRIBUTE_NORMAL );
		}
        while( FindNextFile(hFile, &ffdImgFile) );
        EXPECT( GetLastError() == ERROR_NO_MORE_FILES );
		return TRUE;
    }
	else
	{
		m_pLog->RecordFailure("Could not copy sources from %s to %s", szSRCFileLoc, szProjLoc);
		return FALSE;
	}
}

BOOL CProjectTestSet::UpdateBuildVerify( LPCSTR szCurrentFile, LPCSTR szNewFile, LPCSTR szFileString )
{

	if(!CopyFile(szNewFile, szCurrentFile, FALSE))
	{
		_TCHAR szMsg[1024];
		wsprintf(szMsg, "Could not copy \"%s\" to \"%s\".", szNewFile, szCurrentFile);
		m_pLog->RecordFailure(szMsg);
		return FALSE;
	}
	if(!SetFileAttributes(szCurrentFile, FILE_ATTRIBUTE_NORMAL ))
	{
		_TCHAR szMsg[1024];
		wsprintf(szMsg, "Could not set attributes on file \"%s\".", szCurrentFile);
		m_pLog->RecordFailure(szMsg);
		return FALSE;
	}
	TouchFile( szCurrentFile );

	Sleep(500);
	MST.DoKeys("{ENTER}");        // "rc was modified outside of IDE. reload? 

	if (!VERIFY_TEST_SUCCESS( prj.Build(WAIT_FOR_BUILD)))
	{
		m_pLog->RecordFailure("Could not build the Project");
		return FALSE;
	}

	VerifyBuildOccured( TRUE );
	if( VerifyBuildString( szFileString ) <= 0 )
	{
		m_pLog->RecordFailure("Could not find string in the build output");
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomaw\atlcomaw.h ===
/* MIDL: this ALWAYS GENERATED file contains the definitions for the interfaces */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\batchbld\batchsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	batchsub.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CBatchSubSuite class
//

#include "stdafx.h"
#include "batchsub.h"
#include "afxdllx.h"

#include "batch1.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CBatchsubSuite

IMPLEMENT_SUBSUITE(CBatchSubSuite, CIDESubSuite, "Batch Build", "VCQA ProjBuild")

BEGIN_TESTLIST(CBatchSubSuite)
	TEST(CBatchBuildTest1, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomaw\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by atlcomaw.rc
//
#define IDS_PROJNAME 100



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\batchbld\batchsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	batchsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CbatchsubSuite class
//

#ifndef __batchsub_H__
#define __batchsub_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CbatchsubSuite class

class CBatchSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CBatchSubSuite)

	DECLARE_TESTLIST()
protected:
};

#endif //__batchsub_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomaw\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7EFBEC1C_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_STDAFX_H__7EFBEC1C_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7EFBEC1C_CAA8_11D0_84BF_00AA00C00848__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomex\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomaw\new\atlcomaw.cpp ===
// atlcomaw.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f atlcomawps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "atlcomaw.h"

#include "atlcomaw_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	int i =3;
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomaw\new\atlcomaw.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.76 */
/* at Mon Nov 24 12:42:36 1997
 */
/* Compiler settings for atlcomaw.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __atlcomaw_h__
#define __atlcomaw_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ATLCOMAWLib_LIBRARY_DEFINED__
#define __ATLCOMAWLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ATLCOMAWLib
 * at Mon Nov 24 12:42:36 1997
 * using MIDL 3.01.76
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_ATLCOMAWLib;
#endif /* __ATLCOMAWLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomaw\atlcomaw.cpp ===
// atlcomaw.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f atlcomawps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "atlcomaw.h"

#include "atlcomaw_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomaw\new\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by atlcomaw.rc
//
#define IDS_PROJNAME                    100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomex\new\atlcomex.h ===
/* MIDL: this ALWAYS GENERATED file contains the definitions for the interfaces */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlservi\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomex\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7EFBEC29_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_STDAFX_H__7EFBEC29_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7EFBEC29_CAA8_11D0_84BF_00AA00C00848__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomex\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by atlcomex.rc
//
#define IDS_PROJNAME 100

#define IDR_Atlcomex		100


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomex\new\atlcomex.cpp ===
// atlcomex.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f atlcomexps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "atlcomex.h"

#include "atlcomex_i.c"


LONG CExeModule::Unlock()
{
	LONG l = CComModule::Unlock();
	if (l == 0)
	{
#if _WIN32_WINNT >= 0x0400
		if (CoSuspendClassObjects() == S_OK)
			PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#else
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#endif
	}
	return l;
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
	while (*p1 != NULL)
	{
		LPCTSTR p = p2;
		while (*p != NULL)
		{
			if (*p1 == *p++)
				return p1+1;
		}
		p1++;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
	HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
	lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
	HRESULT hRes = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//	instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
//	HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	_ASSERTE(SUCCEEDED(hRes));
	_Module.Init(ObjectMap, hInstance);
	_Module.dwThreadID = GetCurrentThreadId();
	TCHAR szTokens[] = _T("-/");

	int nRet = 0;
	BOOL bRun = TRUE;
	LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
	while (lpszToken != NULL)
	{
		if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
		{
			_Module.UpdateRegistryFromResource(IDR_Atlcomex, FALSE);
			nRet = _Module.UnregisterServer();
			bRun = FALSE;
			break;
		}
		if (lstrcmpi(lpszToken, _T("RegServer"))==0)
		{
			_Module.UpdateRegistryFromResource(IDR_Atlcomex, TRUE);
			nRet = _Module.RegisterServer(TRUE);
			bRun = FALSE;
			break;
		}
		lpszToken = FindOneOf(lpszToken, szTokens);
	}

	if (bRun)
	{
		hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
			REGCLS_MULTIPLEUSE);
		_ASSERTE(SUCCEEDED(hRes));

		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
			DispatchMessage(&msg);

		_Module.RevokeClassObjects();
	}
	int i = 5;
	CoUninitialize();
	return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomex\atlcomex.cpp ===
// atlcomex.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f atlcomexps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "atlcomex.h"

#include "atlcomex_i.c"


LONG CExeModule::Unlock()
{
	LONG l = CComModule::Unlock();
	if (l == 0)
	{
#if _WIN32_WINNT >= 0x0400
		if (CoSuspendClassObjects() == S_OK)
			PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#else
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#endif
	}
	return l;
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
	while (*p1 != NULL)
	{
		LPCTSTR p = p2;
		while (*p != NULL)
		{
			if (*p1 == *p++)
				return p1+1;
		}
		p1++;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
	HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
	lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
	HRESULT hRes = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//	instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
//	HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	_ASSERTE(SUCCEEDED(hRes));
	_Module.Init(ObjectMap, hInstance);
	_Module.dwThreadID = GetCurrentThreadId();
	TCHAR szTokens[] = _T("-/");

	int nRet = 0;
	BOOL bRun = TRUE;
	LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
	while (lpszToken != NULL)
	{
		if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
		{
			_Module.UpdateRegistryFromResource(IDR_Atlcomex, FALSE);
			nRet = _Module.UnregisterServer();
			bRun = FALSE;
			break;
		}
		if (lstrcmpi(lpszToken, _T("RegServer"))==0)
		{
			_Module.UpdateRegistryFromResource(IDR_Atlcomex, TRUE);
			nRet = _Module.RegisterServer(TRUE);
			bRun = FALSE;
			break;
		}
		lpszToken = FindOneOf(lpszToken, szTokens);
	}

	if (bRun)
	{
		hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
			REGCLS_MULTIPLEUSE);
		_ASSERTE(SUCCEEDED(hRes));

		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
			DispatchMessage(&msg);

		_Module.RevokeClassObjects();
	}

	CoUninitialize();
	return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlservi\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by atlservi.rc
//
#define IDS_SERVICENAME 100

#define IDR_Atlservi		100


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlcomex\new\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by atlcomex.rc
//
#define IDS_PROJNAME                    100
#define IDR_Atlcomex                    100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlservi\new\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by atlservi.rc
//
#define IDS_SERVICENAME                 100
#define IDR_Atlservi                    100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\a_dll\a_dll.cpp ===
#include "a_dll.h"

class Inherited : public base1, public base2 {
public:
	void DllExport Func2(void); // Implementation of above
	void DllExport Func1(void); // Implementation of above

private:
	int m_int; 
	void Helper(int); // Helper function for implementation
};

void DllExport Inherited::Func2 (void)
{
	int i = 2;
	m_int =3;
	Helper(i);
}

void DllExport Inherited::Func1 (void)
{
	int i = 0;
}

void Inherited::Helper(int par)
{
	par++;
}

Thread static int g_tls;
/*
void DllExport __stdcall func()
{
  Thread static int l_tls;

  l_tls = 10; // OK: Local tls is correct
  l_tls++;    // OK
  g_tls = 1;  // NG: Debugger don't show correct value in watch window, but executed result is correct. 
  g_tls++;    // NG: For expamle, OutputDebugString(); can show correct value.
}
*/
Inherited inh2;

DllExport base2* func2()
{
	return (base2*)(&inh2);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlservi\new\atlservi.cpp ===
// atlservi.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f atlservips.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "atlservi.h"

#include "atlservi_i.c"


#include <stdio.h>

CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
	while (*p1 != NULL)
	{
		LPCTSTR p = p2;
		while (*p != NULL)
		{
			if (*p1 == *p++)
				return p1+1;
		}
		p1++;
	}
int i = 3;
	return NULL;
}

// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
	HRESULT hr = CoInitialize(NULL);
	if (FAILED(hr))
		return hr;

	// Remove any previous service since it may point to
	// the incorrect file
	Uninstall();

	// Add service entries
	UpdateRegistryFromResource(IDR_Atlservi, TRUE);

	// Adjust the AppID for Local Server or Service
	CRegKey keyAppID;
	LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"));
	if (lRes != ERROR_SUCCESS)
		return lRes;

	CRegKey key;
	lRes = key.Open(keyAppID, _T("{1DEE14F4-CC4B-11D0-84BF-00AA00C00848}"));
	if (lRes != ERROR_SUCCESS)
		return lRes;
	key.DeleteValue(_T("LocalService"));
	
	if (bService)
	{
		key.SetValue(_T("atlservi"), _T("LocalService"));
		key.SetValue(_T("-Service"), _T("ServiceParameters"));
		// Create service
		Install();
	}

	// Add object entries
	hr = CComModule::RegisterServer(bRegTypeLib);

	CoUninitialize();
	return hr;
}

inline HRESULT CServiceModule::UnregisterServer()
{
	HRESULT hr = CoInitialize(NULL);
	if (FAILED(hr))
		return hr;

	// Remove service entries
	UpdateRegistryFromResource(IDR_Atlservi, FALSE);
	// Remove service
	Uninstall();
	// Remove object entries
	CComModule::UnregisterServer();

	CoUninitialize();
	return S_OK;
}

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID)
{
	CComModule::Init(p, h);

	m_bService = TRUE;

	LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}

LONG CServiceModule::Unlock()
{
	LONG l = CComModule::Unlock();
	if (l == 0 && !m_bService)
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
	return l;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
	{
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
		{
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

inline BOOL CServiceModule::Install()
{
	if (IsInstalled())
		return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
	{
		MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
	}

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH];
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

    SC_HANDLE hService = ::CreateService(
		hSCM, m_szServiceName, m_szServiceName,
		SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
		SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
        szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

    if (hService == NULL)
	{
        ::CloseServiceHandle(hSCM);
		MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
		return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
	return TRUE;
}

inline BOOL CServiceModule::Uninstall()
{
	if (!IsInstalled())
		return TRUE;

	SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	if (hSCM == NULL)
	{
		MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
		return FALSE;
	}

	SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

	if (hService == NULL)
	{
		::CloseServiceHandle(hSCM);
		MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
		return FALSE;
	}
	SERVICE_STATUS status;
	::ControlService(hService, SERVICE_CONTROL_STOP, &status);

	BOOL bDelete = ::DeleteService(hService);
	::CloseServiceHandle(hService);
	::CloseServiceHandle(hSCM);

	if (bDelete)
		return TRUE;

	MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////////////
// Logging functions
void CServiceModule::LogEvent(LPCTSTR pFormat, ...)
{
    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
	va_list	pArg;

	va_start(pArg, pFormat);
	_vstprintf(chMsg, pFormat, pArg);
	va_end(pArg);

    lpszStrings[0] = chMsg;

	if (m_bService)
	{
	    /* Get a handle to use with ReportEvent(). */
		hEventSource = RegisterEventSource(NULL, m_szServiceName);
	    if (hEventSource != NULL)
	    {
	        /* Write to event log. */
	        ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
	        DeregisterEventSource(hEventSource);
	    }
	}
	else
	{
		// As we are not running as a service, just write the error to the console.
		_putts(chMsg);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
	{
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
	{
		m_bService = FALSE;
	}
	if (m_bService == FALSE)
		Run();
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    if (m_hServiceStatus == NULL)
	{
        LogEvent(_T("Handler not installed"));
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
	LogEvent(_T("Service stopped"));
}

inline void CServiceModule::Handler(DWORD dwOpcode)
{
	switch (dwOpcode)
	{
	case SERVICE_CONTROL_STOP:
		SetServiceStatus(SERVICE_STOP_PENDING);
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
		break;
	case SERVICE_CONTROL_PAUSE:
		break;
	case SERVICE_CONTROL_CONTINUE:
		break;
	case SERVICE_CONTROL_INTERROGATE:
		break;
	case SERVICE_CONTROL_SHUTDOWN:
		break;
	default:
		LogEvent(_T("Bad service request"));
	}
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
	_Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
	_Module.Handler(dwOpcode); 
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
	m_status.dwCurrentState = dwState;
	::SetServiceStatus(m_hServiceStatus, &m_status);
}

void CServiceModule::Run()
{
	HRESULT hr;

	_Module.dwThreadID = GetCurrentThreadId();

	HRESULT hRes = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//	instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
//	HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

	_ASSERTE(SUCCEEDED(hr));

	// This provides a NULL DACL which will allow access to everyone.
	CSecurityDescriptor sd;
	sd.InitializeFromThreadToken();
	hr = CoInitializeSecurity(sd, -1, NULL, NULL,
		RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
	_ASSERTE(SUCCEEDED(hr));

	hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
	_ASSERTE(SUCCEEDED(hr));

	LogEvent(_T("Service started"));
    SetServiceStatus(SERVICE_RUNNING);

	MSG msg;
	while (GetMessage(&msg, 0, 0, 0))
		DispatchMessage(&msg);

	_Module.RevokeClassObjects();

	CoUninitialize();
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
	HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
	lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
	_Module.Init(ObjectMap, hInstance, IDS_SERVICENAME);
	_Module.m_bService = TRUE;

	TCHAR szTokens[] = _T("-/");

	LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
	while (lpszToken != NULL)
	{
		if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
			return _Module.UnregisterServer();

		// Register as Local Server
		if (lstrcmpi(lpszToken, _T("RegServer"))==0)
			return _Module.RegisterServer(TRUE, FALSE);
		
		// Register as Service
		if (lstrcmpi(lpszToken, _T("Service"))==0)
			return _Module.RegisterServer(TRUE, TRUE);
		
		lpszToken = FindOneOf(lpszToken, szTokens);
	}

	// Are we Service or Local Server
	CRegKey keyAppID;
	LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"));
	if (lRes != ERROR_SUCCESS)
		return lRes;

	CRegKey key;
	lRes = key.Open(keyAppID, _T("{1DEE14F4-CC4B-11D0-84BF-00AA00C00848}"));
	if (lRes != ERROR_SUCCESS)
		return lRes;

	TCHAR szValue[_MAX_PATH];
	DWORD dwLen = _MAX_PATH;
	lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

	_Module.m_bService = FALSE;
	if (lRes == ERROR_SUCCESS)
		_Module.m_bService = TRUE;

	_Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlservi\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1DEE14F7_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_STDAFX_H__1DEE14F7_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:
	HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
	HRESULT UnregisterServer();
	void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID);
    void Start();
	void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
	LONG Unlock();
	void LogEvent(LPCTSTR pszFormat, ...);
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();

//Implementation
private:
	static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
    TCHAR m_szServiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
	DWORD dwThreadID;
	BOOL m_bService;
};

extern CServiceModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1DEE14F7_CC4B_11D0_84BF_00AA00C00848__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\atlservi\atlservi.cpp ===
// atlservi.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f atlservips.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "atlservi.h"

#include "atlservi_i.c"


#include <stdio.h>

CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
	while (*p1 != NULL)
	{
		LPCTSTR p = p2;
		while (*p != NULL)
		{
			if (*p1 == *p++)
				return p1+1;
		}
		p1++;
	}
	return NULL;
}

// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
	HRESULT hr = CoInitialize(NULL);
	if (FAILED(hr))
		return hr;

	// Remove any previous service since it may point to
	// the incorrect file
	Uninstall();

	// Add service entries
	UpdateRegistryFromResource(IDR_Atlservi, TRUE);

	// Adjust the AppID for Local Server or Service
	CRegKey keyAppID;
	LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"));
	if (lRes != ERROR_SUCCESS)
		return lRes;

	CRegKey key;
	lRes = key.Open(keyAppID, _T("{1DEE14F4-CC4B-11D0-84BF-00AA00C00848}"));
	if (lRes != ERROR_SUCCESS)
		return lRes;
	key.DeleteValue(_T("LocalService"));
	
	if (bService)
	{
		key.SetValue(_T("atlservi"), _T("LocalService"));
		key.SetValue(_T("-Service"), _T("ServiceParameters"));
		// Create service
		Install();
	}

	// Add object entries
	hr = CComModule::RegisterServer(bRegTypeLib);

	CoUninitialize();
	return hr;
}

inline HRESULT CServiceModule::UnregisterServer()
{
	HRESULT hr = CoInitialize(NULL);
	if (FAILED(hr))
		return hr;

	// Remove service entries
	UpdateRegistryFromResource(IDR_Atlservi, FALSE);
	// Remove service
	Uninstall();
	// Remove object entries
	CComModule::UnregisterServer();

	CoUninitialize();
	return S_OK;
}

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID)
{
	CComModule::Init(p, h);

	m_bService = TRUE;

	LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}

LONG CServiceModule::Unlock()
{
	LONG l = CComModule::Unlock();
	if (l == 0 && !m_bService)
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
	return l;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
	{
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
		{
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

inline BOOL CServiceModule::Install()
{
	if (IsInstalled())
		return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
	{
		MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
	}

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH];
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

    SC_HANDLE hService = ::CreateService(
		hSCM, m_szServiceName, m_szServiceName,
		SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
		SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
        szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

    if (hService == NULL)
	{
        ::CloseServiceHandle(hSCM);
		MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
		return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
	return TRUE;
}

inline BOOL CServiceModule::Uninstall()
{
	if (!IsInstalled())
		return TRUE;

	SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	if (hSCM == NULL)
	{
		MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
		return FALSE;
	}

	SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

	if (hService == NULL)
	{
		::CloseServiceHandle(hSCM);
		MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
		return FALSE;
	}
	SERVICE_STATUS status;
	::ControlService(hService, SERVICE_CONTROL_STOP, &status);

	BOOL bDelete = ::DeleteService(hService);
	::CloseServiceHandle(hService);
	::CloseServiceHandle(hSCM);

	if (bDelete)
		return TRUE;

	MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////////////
// Logging functions
void CServiceModule::LogEvent(LPCTSTR pFormat, ...)
{
    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
	va_list	pArg;

	va_start(pArg, pFormat);
	_vstprintf(chMsg, pFormat, pArg);
	va_end(pArg);

    lpszStrings[0] = chMsg;

	if (m_bService)
	{
	    /* Get a handle to use with ReportEvent(). */
		hEventSource = RegisterEventSource(NULL, m_szServiceName);
	    if (hEventSource != NULL)
	    {
	        /* Write to event log. */
	        ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
	        DeregisterEventSource(hEventSource);
	    }
	}
	else
	{
		// As we are not running as a service, just write the error to the console.
		_putts(chMsg);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
	{
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
	{
		m_bService = FALSE;
	}
	if (m_bService == FALSE)
		Run();
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    if (m_hServiceStatus == NULL)
	{
        LogEvent(_T("Handler not installed"));
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
	LogEvent(_T("Service stopped"));
}

inline void CServiceModule::Handler(DWORD dwOpcode)
{
	switch (dwOpcode)
	{
	case SERVICE_CONTROL_STOP:
		SetServiceStatus(SERVICE_STOP_PENDING);
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
		break;
	case SERVICE_CONTROL_PAUSE:
		break;
	case SERVICE_CONTROL_CONTINUE:
		break;
	case SERVICE_CONTROL_INTERROGATE:
		break;
	case SERVICE_CONTROL_SHUTDOWN:
		break;
	default:
		LogEvent(_T("Bad service request"));
	}
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
	_Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
	_Module.Handler(dwOpcode); 
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
	m_status.dwCurrentState = dwState;
	::SetServiceStatus(m_hServiceStatus, &m_status);
}

void CServiceModule::Run()
{
	HRESULT hr;

	_Module.dwThreadID = GetCurrentThreadId();

	HRESULT hRes = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//	instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
//	HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

	_ASSERTE(SUCCEEDED(hr));

	// This provides a NULL DACL which will allow access to everyone.
	CSecurityDescriptor sd;
	sd.InitializeFromThreadToken();
	hr = CoInitializeSecurity(sd, -1, NULL, NULL,
		RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
	_ASSERTE(SUCCEEDED(hr));

	hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
	_ASSERTE(SUCCEEDED(hr));

	LogEvent(_T("Service started"));
    SetServiceStatus(SERVICE_RUNNING);

	MSG msg;
	while (GetMessage(&msg, 0, 0, 0))
		DispatchMessage(&msg);

	_Module.RevokeClassObjects();

	CoUninitialize();
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
	HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
	lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
	_Module.Init(ObjectMap, hInstance, IDS_SERVICENAME);
	_Module.m_bService = TRUE;

	TCHAR szTokens[] = _T("-/");

	LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
	while (lpszToken != NULL)
	{
		if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
			return _Module.UnregisterServer();

		// Register as Local Server
		if (lstrcmpi(lpszToken, _T("RegServer"))==0)
			return _Module.RegisterServer(TRUE, FALSE);
		
		// Register as Service
		if (lstrcmpi(lpszToken, _T("Service"))==0)
			return _Module.RegisterServer(TRUE, TRUE);
		
		lpszToken = FindOneOf(lpszToken, szTokens);
	}

	// Are we Service or Local Server
	CRegKey keyAppID;
	LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"));
	if (lRes != ERROR_SUCCESS)
		return lRes;

	CRegKey key;
	lRes = key.Open(keyAppID, _T("{1DEE14F4-CC4B-11D0-84BF-00AA00C00848}"));
	if (lRes != ERROR_SUCCESS)
		return lRes;

	TCHAR szValue[_MAX_PATH];
	DWORD dwLen = _MAX_PATH;
	lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

	_Module.m_bService = FALSE;
	if (lRes == ERROR_SUCCESS)
		_Module.m_bService = TRUE;

	_Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\a_dll\a_dll.h ===
#define DllExport __declspec(dllexport)
#define Thread __declspec(thread)

class base1 {
public:
	virtual void DllExport Func1() = 0;

};

class base2 {
public:
	virtual void DllExport Func2() = 0;

};

DllExport base2* func2();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\a_dll\new\a_dll.cpp ===
#include "a_dll.h"

class Inherited : public base1, public base2
{
public:
	void DllExport Func2(void); // Implementation of above
	void DllExport Func1(void); // Implementation of above

private:
	int m_int; 
	void Helper(int); // Helper function for implementation
};

void DllExport Inherited::Func2 (void)
{
	int i = 22;
	m_int = 3;
	Helper(i);
}

void DllExport Inherited::Func1 (void)
{
	int i = 0;
}

void Inherited::Helper(int par)
{
	par++;
}

Thread static int g_tls;

Inherited inh2;

DllExport base2* func2()
{
	return (base2*)(&inh2);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\b_dll\b_dll.c ===
#if defined( WIN )
#include <windows.h>
#endif //WIN
#include <sys\types.h>
#include "b_dll.h"

double WINAPI dPow(int base, int power)
{
	int i;
	double result;
	/* note: don't handle zero's */
	if (power==0)
		return 1;
	if (base==0)
		return 0;
	for (result=base,i=1;i<power;i++)
		result *= base;
	
	return result;
} 


INT WINAPI DllMain(HANDLE hInst, ULONG ulRbc, LPVOID lpReserved)
{
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\a_dll\new\a_dll.h ===
#define DllExport __declspec(dllexport)
#define Thread __declspec(thread)

class base1
{
public:
	virtual void DllExport Func1() = 0;
};

class base2
{
public:
	virtual void DllExport Func2() = 0;
};

DllExport base2* func2();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\b_dll\new\b_dll.c ===
#if defined( WIN )
#include <windows.h>
#endif //WIN
#include <sys\types.h>
#include "b_dll.h"

double WINAPI dPow(int base, int power)
{
	int i = 0;
	double result;
	/* note: don't handle zero's */
	if (power==0)
		return 1;
	if (base==0)
		return 0;
	for (result=base,i=1;i<power;i++)
		result *= base;
	
	return result;
} 


INT WINAPI DllMain(HANDLE hInst, ULONG ulRbc, LPVOID lpReserved)
{
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\consol\consol.h ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "consol2.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\consol\consol2.h ===
int foo_Include(int number);

int foo_Include(int number)
{
	number*=2;
	if(number == 3)
	{
		return (-1);
	}
	return number;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\b_dll\b_dll.h ===
#if defined( WIN32 )
#include <windows.h> 
#endif

double WINAPI dPow( int base, int power);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\consol\consol.c ===
#include <assert.h>
#include "consol.h"
#define ArrayLength 100
#define StructString65 "String65String65String65String65String65String65String65String65"
#define LocalString65  "__local_String65__local_String65__local_String65__local_String65"
#define Flag 1

int TestG(void);
int func();
int recur_func();
int foo(int);
void nest_func();
int Global;
typedef int My_typedef;

struct Struct 
{
   int IntN;
   char *String65;
} Struct;

void nest_func()
{
 	if (func()) 
   	foo (func());
};

int func()
{ 
	return 33;
};

int foo(int Parameter)
{
   return Parameter;
};

int recur_func() 
{
   static x=1;
   x++;
   if (x<9) recur_func();
   else return x;
};

int main()
{
	int iGo = TestG();
	return 0;
}

int TestG()
{
 	int Local;
 	int Int;
 	long Long;
 	double Double;
 	long double Ldouble;
 	float Real;
 	char *String;
 	void *Void;
 	My_typedef Mine = 99;
 
	struct Struct Struct_local;
 	struct Struct Array_struct[ArrayLength];
 	int  Array1d[3];
 	long Array2d[3][3];
 	char Array3d[3][3][3];

 	if (Flag) 
	{

		for (Int=0; Int < ArrayLength; Int++)
   		{						                      // not executable code line
			Array_struct[Int].IntN = Int;
			Array_struct[Int].String65 = StructString65;
		};	  
 	};

 	for (Int=0; Int<3; Int++) 
	{
		Array1d[Int]=Int;
     	Array2d[Int][Int]=Int;
     	Array3d[Int][Int][Int]=Int;
  	};
	
	Local=17;
 	Array1d[2]=9;
 	Struct.IntN = 1;
 	Struct.String65 = StructString65;
 	Struct_local.IntN = 11;
 	Struct_local.String65 = LocalString65;
 	Int=2;Int=6;Int=9;
 	Real=(float)1.303;
 	Double=1.303;
 	Ldouble=1.303;
 	String="this is a string";
 	Global=77;
 	Long=99;
 	Int=func();

 	if (Local > 0) 
	{
 		while (Local == 1)  
			Real = (float)9.9999;    // dead code
		if (Local > 1)
   	{							// not executable code line
	 		while (Local == 17)
			{                 // not executable code line
	 			Real = (float)8.88888;
				break;
			}
		}
 		else
 		 Real = (float)7.77;		// dead code
	}
 	else						
   {							// dead code
      Real = (float)6.1;	      // dead code
	}							// dead code

 	if (1 < Local) do { Double = 555.555; } while (Local == 0);

 	Int=foo(Local);
	Int = foo_Include(Int);
	Mine = foo_Include(Mine);
 	Int=recur_func();
	Void = (void*)Int;
  	nest_func();
if(func() == 33)goto LabeL;
	Int = 999;
LabeL: 	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\b_dll\new\b_dll.h ===
#include <windows.h> 

double WINAPI dPow( int base, int power);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\consol\new\consol.h ===
//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>

#include "consol2.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\consol\new\consol.c ===
#include <assert.h>
#include "consol.h"
#define ArrayLength 10
#define StructString65 "String65String65String65String65String65String65String65String65"
#define LocalString65  "__local_String65__local_String65__local_String65__local_String65"
#define Flag 1

int TestG(void);
int func();
int recur_func();
int foo(int);
void nest_func();
int Global;

struct Struct 
{
   int IntN;
   char *String65;
} Struct;

void nest_func()
{
 	if (func()) 
   	foo (func());
};

int func()
{ 
	return 33;
};

int foo(int Parameter)
{
   return Parameter + 5;
};

int recur_func() 
{
   static x=1;
   x++;
   if (x<9) recur_func();
   else return x;
};

int main()
{
	int iGo = TestG();
	return 0;
}

int TestG()
{
 	int Local;
 	int Int;
 	long Long;
 	double Double;
 	long double Ldouble;
 	float Real;
 	char *String;
 	void *Void;
 
	struct Struct Struct_local;
 	struct Struct Array_struct[ArrayLength];
 	int  Array1d[3];
 	long Array2d[3][3];
 	char Array3d[3][3][3];

 	if (Flag) 
	{

		for (Int=0; Int < ArrayLength; Int++)
   		{						                      // not executable code line
			Array_struct[Int].IntN = Int;
			Array_struct[Int].String65 = StructString65;
		};	  
 	};

 	for (Int=0; Int<3; Int++) 
	{
		Array1d[Int]=Int;
     	Array2d[Int][Int]=Int;
     	Array3d[Int][Int][Int]=Int;
  	};
	
	Local=17;
 	Array1d[2]=9;
 	Struct.IntN = 1;
 	Struct.String65 = StructString65;
 	Struct_local.IntN = 11;
 	Struct_local.String65 = LocalString65;
 	Int=2;Int=6;Int=9;
 	Real=(float)1.303;
 	Double=1.303;
 	Ldouble=1.303;
 	String="this is a string";
 	Global=77;
 	Long=99;
 	Int=func();

 	if (1 < Local) do { Double = 555.555; } while (Local == 0);

 	Int=foo(Local);
	Int = foo_Include(Int);
	// Mine = foo_Include(Mine);
 	Int=recur_func();
	Void = (void*)Int;
  	nest_func();
if(func() == 33)goto LabeL;
	Int = 999;
LabeL: 	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\customb1\another test.h ===
#if !defined(AFX_ANOTHERTEST_H__1B68E991_BA52_11D1_BAEB_00C04FAC5A7C__INCLUDED_)
#define AFX_ANOTHERTEST_H__1B68E991_BA52_11D1_BAEB_00C04FAC5A7C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_ANOTHERTEST_H__1B68E991_BA52_11D1_BAEB_00C04FAC5A7C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\customb1\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by ANOTHER TEST.RC
//
#define IDR_MAINFRAME					128
#define IDD_ANOTHERTEST_DIALOG		102
#define IDD_ABOUTBOX					103
#define IDS_APP_TITLE					103
#define IDM_ABOUT						104
#define IDM_EXIT						105
#define IDS_HELLO						106
#define IDI_ANOTHERTEST	            107
#define IDI_SMALL						108
#define IDC_ANOTHERTEST	            109
#define IDC_MYICON						2
#define IDC_STATIC	                    -1
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\customb1\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	another test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\consol\new\consol2.h ===
int foo_Include(int number);

int foo_Include(int number)
{
	number *= 4;
	if(number == 3)
	{
		return (-1);
	}
	number += 5;
	return number;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\customb1\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// Local Header Files

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\hello\hello.cpp ===
#include <windows.h>
#include "hello1.h"

int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
{
//        dll_func();
	shared_func();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\hello\hello1.cpp ===
#include <stdio.h>
#include "hello1.h"
void shared_func(void)
{
   printf("Hello World!");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\customb1\another test.cpp ===
// another test.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include "resource.h"

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst;								// current instance
TCHAR szTitle[MAX_LOADSTRING];								// The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];								// The title bar text

// Foward declarations of functions included in this code module:
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
 	// TODO: Place code here.
	MSG msg;
	HACCEL hAccelTable;

	// Initialize global strings
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_ANOTHERTEST, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// Perform application initialization:
	if (!InitInstance (hInstance, nCmdShow)) 
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_ANOTHERTEST);

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return msg.wParam;
}



//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_ANOTHERTEST);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= (LPCSTR)IDC_ANOTHERTEST;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   HWND hWnd;

   hInst = hInstance; // Store instance handle in our global variable

   hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);

   if (!hWnd)
   {
      return FALSE;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND	- process the application menu
//  WM_PAINT	- Paint the main window
//  WM_DESTROY	- post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;
	TCHAR szHello[MAX_LOADSTRING];
	LoadString(hInst, IDS_HELLO, szHello, MAX_LOADSTRING);

	switch (message) 
	{
		case WM_COMMAND:
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 
			// Parse the menu selections:
			switch (wmId)
			{
				case IDM_ABOUT:
				   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
				   break;
				case IDM_EXIT:
				   DestroyWindow(hWnd);
				   break;
				default:
				   return DefWindowProc(hWnd, message, wParam, lParam);
			}
			break;
		case WM_PAINT:
			hdc = BeginPaint(hWnd, &ps);
			// TODO: Add any drawing code here...
			RECT rt;
			GetClientRect(hWnd, &rt);
			DrawText(hdc, szHello, strlen(szHello), &rt, DT_CENTER);
			EndPaint(hWnd, &ps);
			break;
		case WM_DESTROY:
			PostQuitMessage(0);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}

// Mesage handler for about box.
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
				return TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\hello\new\hello.cpp ===
#include <windows.h>
#include <stdio.h>
#include "hello1.h"

int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
{
	shared_func();
    printf("How are you doing!");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\hello\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by hello.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\hello.v4\hello.cpp ===
#include <windows.h>
#include "shared.h"

int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
{
//        dll_func();
	shared_func();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\hello\hello1.h ===
void shared_func(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\hello.v4\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by hello.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\hello.v4\shared.cpp ===
#include <stdio.h>
#include "shared.h"
void shared_func(void)
{
   printf("Hello World!");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\hello.v4\shared.h ===
void shared_func(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\isapiew\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by isapiew.rc
//

#define IDS_SERVER        102

#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_CONTROL_VALUE         103
#define _APS_NEXT_SYMED_VALUE           103
#define _APS_NEXT_COMMAND_VALUE         32768
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\isapiew\StdAfx.h ===
#if !defined(AFX_STDAFX_H__7EFBEC17_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_STDAFX_H__7EFBEC17_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afx.h>
#include <afxwin.h>
#include <afxmt.h>		// for synchronization objects
#include <afxext.h>
#include <afxisapi.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7EFBEC17_CAA8_11D0_84BF_00AA00C00848__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\isapiew\isapiew.cpp ===
// ISAPIEW.CPP - Implementation file for your Internet Server
//    isapiew Extension

#include "stdafx.h"
#include "isapiew.h"

///////////////////////////////////////////////////////////////////////
// The one and only CWinApp object
// NOTE: You may remove this object if you alter your project to no
// longer use MFC in a DLL.

CWinApp theApp;

///////////////////////////////////////////////////////////////////////
// command-parsing map

BEGIN_PARSE_MAP(CIsapiewExtension, CHttpServer)
	// TODO: insert your ON_PARSE_COMMAND() and 
	// ON_PARSE_COMMAND_PARAMS() here to hook up your commands.
	// For example:

	ON_PARSE_COMMAND(Default, CIsapiewExtension, ITS_EMPTY)
	DEFAULT_PARSE_COMMAND(Default, CIsapiewExtension)
END_PARSE_MAP(CIsapiewExtension)


///////////////////////////////////////////////////////////////////////
// The one and only CIsapiewExtension object

CIsapiewExtension theExtension;


///////////////////////////////////////////////////////////////////////
// CIsapiewExtension implementation

CIsapiewExtension::CIsapiewExtension()
{
}

CIsapiewExtension::~CIsapiewExtension()
{
}

BOOL CIsapiewExtension::GetExtensionVersion(HSE_VERSION_INFO* pVer)
{
	// Call default implementation for initialization
	CHttpServer::GetExtensionVersion(pVer);

	// Load description string
	TCHAR sz[HSE_MAX_EXT_DLL_NAME_LEN+1];
	ISAPIVERIFY(::LoadString(AfxGetResourceHandle(),
			IDS_SERVER, sz, HSE_MAX_EXT_DLL_NAME_LEN));
	_tcscpy(pVer->lpszExtensionDesc, sz);
	return TRUE;
}

///////////////////////////////////////////////////////////////////////
// CIsapiewExtension command handlers

void CIsapiewExtension::Default(CHttpServerContext* pCtxt)
{
	StartContent(pCtxt);
	WriteTitle(pCtxt);

	*pCtxt << _T("This default message was produced by the Internet");
	*pCtxt << _T(" Server DLL Wizard. Edit your CIsapiewExtension::Default()");
	*pCtxt << _T(" implementation to change it.\r\n");

	EndContent(pCtxt);
}

// Do not edit the following lines, which are needed by ClassWizard.
#if 0
BEGIN_MESSAGE_MAP(CIsapiewExtension, CHttpServer)
	//{{AFX_MSG_MAP(CIsapiewExtension)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
#endif	// 0



///////////////////////////////////////////////////////////////////////
// If your extension will not use MFC, you'll need this code to make
// sure the extension objects can find the resource handle for the
// module.  If you convert your extension to not be dependent on MFC,
// remove the comments arounn the following AfxGetResourceHandle()
// and DllMain() functions, as well as the g_hInstance global.

/****

static HINSTANCE g_hInstance;

HINSTANCE AFXISAPI AfxGetResourceHandle()
{
	return g_hInstance;
}

BOOL WINAPI DllMain(HINSTANCE hInst, ULONG ulReason,
					LPVOID lpReserved)
{
	if (ulReason == DLL_PROCESS_ATTACH)
	{
		g_hInstance = hInst;
	}

	return TRUE;
}

****/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\isapiew\isapiew.h ===
#if !defined(AFX_ISAPIEW_H__7EFBEC11_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_ISAPIEW_H__7EFBEC11_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

// ISAPIEW.H - Header file for your Internet Server
//    isapiew Extension

#include "resource.h"

class CIsapiewExtension : public CHttpServer
{
public:
	CIsapiewExtension();
	~CIsapiewExtension();

// Overrides
	// ClassWizard generated virtual function overrides
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//{{AFX_VIRTUAL(CIsapiewExtension)
	public:
	virtual BOOL GetExtensionVersion(HSE_VERSION_INFO* pVer);
	//}}AFX_VIRTUAL

	// TODO: Add handlers for your commands here.
	// For example:

	void Default(CHttpServerContext* pCtxt);

	DECLARE_PARSE_MAP()

	//{{AFX_MSG(CIsapiewExtension)
	//}}AFX_MSG
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ISAPIEW_H__7EFBEC11_CAA8_11D0_84BF_00AA00C00848__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\isapiew\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	isapiew.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\isapiew\new\isapiew.h ===
#if !defined(AFX_ISAPIEW_H__7EFBEC11_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_ISAPIEW_H__7EFBEC11_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

// ISAPIEW.H - Header file for your Internet Server
//    isapiew Extension
#define ISAPIEWTEST
#include "resource.h"

class CIsapiewExtension : public CHttpServer
{
public:
	CIsapiewExtension();
	~CIsapiewExtension();

// Overrides
	// ClassWizard generated virtual function overrides
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//{{AFX_VIRTUAL(CIsapiewExtension)
	public:
	virtual BOOL GetExtensionVersion(HSE_VERSION_INFO* pVer);
	//}}AFX_VIRTUAL

	// TODO: Add handlers for your commands here.
	// For example:

	void Default(CHttpServerContext* pCtxt);

	DECLARE_PARSE_MAP()

	//{{AFX_MSG(CIsapiewExtension)
	//}}AFX_MSG
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ISAPIEW_H__7EFBEC11_CAA8_11D0_84BF_00AA00C00848__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\isapiew\new\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by isapiew.rc
//
#define IDS_SERVER                      102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         103
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\isapiew\new\isapiew.cpp ===
// ISAPIEW.CPP - Implementation file for your Internet Server
//    isapiew Extension

#include "stdafx.h"
#include "isapiew.h"

///////////////////////////////////////////////////////////////////////
// The one and only CWinApp object
// NOTE: You may remove this object if you alter your project to no
// longer use MFC in a DLL.

CWinApp theApp;

///////////////////////////////////////////////////////////////////////
// command-parsing map

BEGIN_PARSE_MAP(CIsapiewExtension, CHttpServer)
	// TODO: insert your ON_PARSE_COMMAND() and 
	// ON_PARSE_COMMAND_PARAMS() here to hook up your commands.
	// For example:

	ON_PARSE_COMMAND(Default, CIsapiewExtension, ITS_EMPTY)
	DEFAULT_PARSE_COMMAND(Default, CIsapiewExtension)
END_PARSE_MAP(CIsapiewExtension)


///////////////////////////////////////////////////////////////////////
// The one and only CIsapiewExtension object

CIsapiewExtension theExtension;


///////////////////////////////////////////////////////////////////////
// CIsapiewExtension implementation

CIsapiewExtension::CIsapiewExtension()
{
}

CIsapiewExtension::~CIsapiewExtension()
{
}

BOOL CIsapiewExtension::GetExtensionVersion(HSE_VERSION_INFO* pVer)
{
	// Call default implementation for initialization
	CHttpServer::GetExtensionVersion(pVer);

	// Load description string
	TCHAR sz[HSE_MAX_EXT_DLL_NAME_LEN+1];
	ISAPIVERIFY(::LoadString(AfxGetResourceHandle(),
			IDS_SERVER, sz, HSE_MAX_EXT_DLL_NAME_LEN));
	_tcscpy(pVer->lpszExtensionDesc, sz);
	return TRUE;
}

///////////////////////////////////////////////////////////////////////
// CIsapiewExtension command handlers

void CIsapiewExtension::Default(CHttpServerContext* pCtxt)
{
	StartContent(pCtxt);
	WriteTitle(pCtxt);

	*pCtxt << _T("This default message was produced by the Internet");
	*pCtxt << _T(" Server DLL Wizard. Edit your CIsapiewExtension::Default()");
	*pCtxt << _T(" implementation to change it.\r\n");
	int i = 6;
	EndContent(pCtxt);
}

// Do not edit the following lines, which are needed by ClassWizard.
#if 0
BEGIN_MESSAGE_MAP(CIsapiewExtension, CHttpServer)
	//{{AFX_MSG_MAP(CIsapiewExtension)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
#endif	// 0



///////////////////////////////////////////////////////////////////////
// If your extension will not use MFC, you'll need this code to make
// sure the extension objects can find the resource handle for the
// module.  If you convert your extension to not be dependent on MFC,
// remove the comments arounn the following AfxGetResourceHandle()
// and DllMain() functions, as well as the g_hInstance global.

/****

static HINSTANCE g_hInstance;

HINSTANCE AFXISAPI AfxGetResourceHandle()
{
	return g_hInstance;
}

BOOL WINAPI DllMain(HINSTANCE hInst, ULONG ulReason,
					LPVOID lpReserved)
{
	if (ulReason == DLL_PROCESS_ATTACH)
	{
		g_hInstance = hInst;
	}

	return TRUE;
}

****/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawdll\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by MFCAWDLL.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawdll\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mfcawdll.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawdll\mfcawdll.cpp ===
// mfcawdll.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include "mfcawdll.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CMfcawdllApp

BEGIN_MESSAGE_MAP(CMfcawdllApp, CWinApp)
	//{{AFX_MSG_MAP(CMfcawdllApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawdllApp construction

CMfcawdllApp::CMfcawdllApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMfcawdllApp object

CMfcawdllApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawdll\mfcawdll.h ===
// mfcawdll.h : main header file for the MFCAWDLL DLL
//

#if !defined(AFX_MFCAWDLL_H__7EFBEBEF_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWDLL_H__7EFBEBEF_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CMfcawdllApp
// See mfcawdll.cpp for the implementation of this class
//

class CMfcawdllApp : public CWinApp
{
public:
	CMfcawdllApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawdllApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CMfcawdllApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWDLL_H__7EFBEBEF_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawdll\new\mfcawdll.cpp ===
// mfcawdll.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include "mfcawdll.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CMfcawdllApp

BEGIN_MESSAGE_MAP(CMfcawdllApp, CWinApp)
	//{{AFX_MSG_MAP(CMfcawdllApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawdllApp construction

CMfcawdllApp::CMfcawdllApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
	int i = 9;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMfcawdllApp object

CMfcawdllApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawdll\new\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mfcawdll.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawdll\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7EFBEBF1_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_STDAFX_H__7EFBEBF1_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7EFBEBF1_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\ChildFrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__1DEE14B2_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_CHILDFRM_H__1DEE14B2_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__1DEE14B2_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\ChildFrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "mfcawex2.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\CntrItem.cpp ===
// CntrItem.cpp : implementation of the CMfcawex2CntrItem class
//

#include "stdafx.h"
#include "mfcawex2.h"

#include "mfcawex2Doc.h"
#include "mfcawex2View.h"
#include "CntrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2CntrItem implementation

IMPLEMENT_SERIAL(CMfcawex2CntrItem, COleClientItem, 0)

CMfcawex2CntrItem::CMfcawex2CntrItem(CMfcawex2Doc* pContainer)
	: COleClientItem(pContainer)
{
	// TODO: add one-time construction code here
	
}

CMfcawex2CntrItem::~CMfcawex2CntrItem()
{
	// TODO: add cleanup code here
	
}

void CMfcawex2CntrItem::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	ASSERT_VALID(this);

	COleClientItem::OnChange(nCode, dwParam);

	// When an item is being edited (either in-place or fully open)
	//  it sends OnChange notifications for changes in the state of the
	//  item or visual appearance of its content.

	// TODO: invalidate the item by calling UpdateAllViews
	//  (with hints appropriate to your application)

	GetDocument()->UpdateAllViews(NULL);
		// for now just update ALL views/no hints
}

BOOL CMfcawex2CntrItem::OnChangeItemPosition(const CRect& rectPos)
{
	ASSERT_VALID(this);

	// During in-place activation CMfcawex2CntrItem::OnChangeItemPosition
	//  is called by the server to change the position of the in-place
	//  window.  Usually, this is a result of the data in the server
	//  document changing such that the extent has changed or as a result
	//  of in-place resizing.
	//
	// The default here is to call the base class, which will call
	//  COleClientItem::SetItemRects to move the item
	//  to the new position.

	if (!COleClientItem::OnChangeItemPosition(rectPos))
		return FALSE;

	// TODO: update any cache you may have of the item's rectangle/extent

	return TRUE;
}

void CMfcawex2CntrItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);

	// During in-place activation, CMfcawex2CntrItem::OnGetItemPosition
	//  will be called to determine the location of this item.  The default
	//  implementation created from AppWizard simply returns a hard-coded
	//  rectangle.  Usually, this rectangle would reflect the current
	//  position of the item relative to the view used for activation.
	//  You can obtain the view by calling CMfcawex2CntrItem::GetActiveView.

	// TODO: return correct rectangle (in pixels) in rPosition

	rPosition.SetRect(10, 10, 210, 210);
}

void CMfcawex2CntrItem::OnActivate()
{
    // Allow only one inplace activate item per frame
    CMfcawex2View* pView = GetActiveView();
    ASSERT_VALID(pView);
    COleClientItem* pItem = GetDocument()->GetInPlaceActiveItem(pView);
    if (pItem != NULL && pItem != this)
        pItem->Close();
    
    COleClientItem::OnActivate();
}

void CMfcawex2CntrItem::OnDeactivateUI(BOOL bUndoable)
{
	COleClientItem::OnDeactivateUI(bUndoable);

    // Hide the object if it is not an outside-in object
    DWORD dwMisc = 0;
    m_lpObject->GetMiscStatus(GetDrawAspect(), &dwMisc);
    if (dwMisc & OLEMISC_INSIDEOUT)
        DoVerb(OLEIVERB_HIDE, NULL);
}

void CMfcawex2CntrItem::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	// Call base class first to read in COleClientItem data.
	// Since this sets up the m_pDocument pointer returned from
	//  CMfcawex2CntrItem::GetDocument, it is a good idea to call
	//  the base class Serialize first.
	COleClientItem::Serialize(ar);

	// now store/retrieve data specific to CMfcawex2CntrItem
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

BOOL CMfcawex2CntrItem::CanActivate()
{
	// Editing in-place while the server itself is being edited in-place
	//  does not work and is not supported.  So, disable in-place
	//  activation in this case.
	CMfcawex2Doc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(COleServerDoc)));
	if (pDoc->IsInPlaceActive())
		return FALSE;

	// otherwise, rely on default behavior
	return COleClientItem::CanActivate();
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2CntrItem diagnostics

#ifdef _DEBUG
void CMfcawex2CntrItem::AssertValid() const
{
	COleClientItem::AssertValid();
}

void CMfcawex2CntrItem::Dump(CDumpContext& dc) const
{
	COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawdll\new\mfcawdll.h ===
// mfcawdll.h : main header file for the MFCAWDLL DLL
//

#if !defined(AFX_MFCAWDLL_H__7EFBEBEF_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWDLL_H__7EFBEBEF_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif
#define MFCDLLXXX
#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CMfcawdllApp
// See mfcawdll.cpp for the implementation of this class
//

class CMfcawdllApp : public CWinApp
{
public:
	CMfcawdllApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawdllApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CMfcawdllApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWDLL_H__7EFBEBEF_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\IpFrame.cpp ===
// IpFrame.cpp : implementation of the CInPlaceFrame class
//

#include "stdafx.h"
#include "mfcawex2.h"

#include "IpFrame.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame

IMPLEMENT_DYNCREATE(CInPlaceFrame, COleIPFrameWnd)

BEGIN_MESSAGE_MAP(CInPlaceFrame, COleIPFrameWnd)
	//{{AFX_MSG_MAP(CInPlaceFrame)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, COleIPFrameWnd::OnHelpFinder)
	ON_COMMAND(ID_HELP, COleIPFrameWnd::OnHelp)
	ON_COMMAND(ID_DEFAULT_HELP, COleIPFrameWnd::OnHelpFinder)
	ON_COMMAND(ID_CONTEXT_HELP, COleIPFrameWnd::OnContextHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame construction/destruction

CInPlaceFrame::CInPlaceFrame()
{
}

CInPlaceFrame::~CInPlaceFrame()
{
}

int CInPlaceFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleIPFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// CResizeBar implements in-place resizing.
	if (!m_wndResizeBar.Create(this))
	{
		TRACE0("Failed to create resize bar\n");
		return -1;      // fail to create
	}

	// By default, it is a good idea to register a drop-target that does
	//  nothing with your frame window.  This prevents drops from
	//  "falling through" to a container that supports drag-drop.
	m_dropTarget.Register(this);

	return 0;
}

// OnCreateControlBars is called by the framework to create control bars on the
//  container application's windows.  pWndFrame is the top level frame window of
//  the container and is always non-NULL.  pWndDoc is the doc level frame window
//  and will be NULL when the container is an SDI application.  A server
//  application can place MFC control bars on either window.
BOOL CInPlaceFrame::OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc)
{
	// Remove this if you use pWndDoc
	UNREFERENCED_PARAMETER(pWndDoc);

	// Set owner to this window, so messages are delivered to correct app
	m_wndToolBar.SetOwner(this);

	// Create toolbar on client's frame window
	if (!m_wndToolBar.Create(pWndFrame) ||
		!m_wndToolBar.LoadToolBar(IDR_MFCAWETYPE_SRVR_IP))
	{
		TRACE0("Failed to create toolbar\n");
		return FALSE;
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	pWndFrame->EnableDocking(CBRS_ALIGN_ANY);
	pWndFrame->DockControlBar(&m_wndToolBar);

	return TRUE;
}

BOOL CInPlaceFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return COleIPFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame diagnostics

#ifdef _DEBUG
void CInPlaceFrame::AssertValid() const
{
	COleIPFrameWnd::AssertValid();
}

void CInPlaceFrame::Dump(CDumpContext& dc) const
{
	COleIPFrameWnd::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\CntrItem.h ===
// CntrItem.h : interface of the CMfcawex2CntrItem class
//

#if !defined(AFX_CNTRITEM_H__1DEE14BD_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_CNTRITEM_H__1DEE14BD_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMfcawex2Doc;
class CMfcawex2View;

class CMfcawex2CntrItem : public COleClientItem
{
	DECLARE_SERIAL(CMfcawex2CntrItem)

// Constructors
public:
	CMfcawex2CntrItem(CMfcawex2Doc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CMfcawex2Doc* GetDocument()
		{ return (CMfcawex2Doc*)COleClientItem::GetDocument(); }
	CMfcawex2View* GetActiveView()
		{ return (CMfcawex2View*)COleClientItem::GetActiveView(); }

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawex2CntrItem)
	public:
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual void OnActivate();
	protected:
	virtual void OnGetItemPosition(CRect& rPosition);
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
	virtual BOOL CanActivate();
	//}}AFX_VIRTUAL

// Implementation
public:
	~CMfcawex2CntrItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CNTRITEM_H__1DEE14BD_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\MainFrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "mfcawex2.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, CMDIFrameWnd::OnHelpFinder)
	ON_COMMAND(ID_HELP, CMDIFrameWnd::OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, CMDIFrameWnd::OnContextHelp)
	ON_COMMAND(ID_DEFAULT_HELP, CMDIFrameWnd::OnHelpFinder)
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\IpFrame.h ===
// IpFrame.h : interface of the CInPlaceFrame class
//

#if !defined(AFX_IPFRAME_H__1DEE14BB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_IPFRAME_H__1DEE14BB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CInPlaceFrame : public COleIPFrameWnd
{
	DECLARE_DYNCREATE(CInPlaceFrame)
public:
	CInPlaceFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInPlaceFrame)
	public:
	virtual BOOL OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CInPlaceFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	CToolBar    m_wndToolBar;
	COleDropTarget	m_dropTarget;
	COleResizeBar   m_wndResizeBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CInPlaceFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_IPFRAME_H__1DEE14BB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\MainFrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__1DEE14B0_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MAINFRM_H__1DEE14B0_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__1DEE14B0_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\mfcawex2.cpp ===
// mfcawex2.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "mfcawex2.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "IpFrame.h"
#include "mfcawex2Doc.h"
#include "mfcawex2View.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2App

BEGIN_MESSAGE_MAP(CMfcawex2App, CWinApp)
	//{{AFX_MSG_MAP(CMfcawex2App)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2App construction

CMfcawex2App::CMfcawex2App()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMfcawex2App object

CMfcawex2App theApp;

// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.

// {1DEE14A6-CC4B-11D0-84BF-00AA00C00848}
static const CLSID clsid =
{ 0x1dee14a6, 0xcc4b, 0x11d0, { 0x84, 0xbf, 0x0, 0xaa, 0x0, 0xc0, 0x8, 0x48 } };

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2App initialization

BOOL CMfcawex2App::InitInstance()
{
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_MFCAWETYPE,
		RUNTIME_CLASS(CMfcawex2Doc),
		RUNTIME_CLASS(CChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CMfcawex2View));
	pDocTemplate->SetContainerInfo(IDR_MFCAWETYPE_CNTR_IP);
	pDocTemplate->SetServerInfo(
		IDR_MFCAWETYPE_SRVR_EMB, IDR_MFCAWETYPE_SRVR_IP,
		RUNTIME_CLASS(CInPlaceFrame));
	AddDocTemplate(pDocTemplate);

	// Connect the COleTemplateServer to the document template.
	//  The COleTemplateServer creates new documents on behalf
	//  of requesting OLE containers by using information
	//  specified in the document template.
	m_server.ConnectTemplate(clsid, pDocTemplate, FALSE);

	// Register all OLE server factories as running.  This enables the
	//  OLE libraries to create objects from other applications.
	COleTemplateServer::RegisterAll();
		// Note: MDI applications register all server objects without regard
		//  to the /Embedding or /Automation on the command line.

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Check to see if launched as OLE server
	if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
	{
		// Application was run with /Embedding or /Automation.  Don't show the
		//  main window in this case.
		return TRUE;
	}

	// When a server application is launched stand-alone, it is a good idea
	//  to update the system registry in case it has been damaged.
	m_server.UpdateRegistry(OAT_INPLACE_SERVER);
	COleObjectFactory::UpdateRegistryAll();

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CMfcawex2App::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2App commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\mfcawex2.h ===
// mfcawex2.h : main header file for the MFCAWEX2 application
//

#if !defined(AFX_MFCAWEX2_H__1DEE14AB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWEX2_H__1DEE14AB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2App:
// See mfcawex2.cpp for the implementation of this class
//

class CMfcawex2App : public CWinApp
{
public:
	CMfcawex2App();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawex2App)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
	COleTemplateServer m_server;
		// Server object for document creation

	//{{AFX_MSG(CMfcawex2App)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEX2_H__1DEE14AB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by MFCAWEX2.RC
//
#define IDR_MAINFRAME				128
#define IDR_MFCAWETYPE				129
#define IDR_MFCAWETYPE_SRVR_IP		4
#define IDR_MFCAWETYPE_SRVR_EMB		5
#define IDR_MFCAWETYPE_CNTR_IP		6
#define IDD_ABOUTBOX				100
#define IDP_OLE_INIT_FAILED			100
#define IDP_FAILED_TO_CREATE		102
#define ID_CANCEL_EDIT_CNTR			32768
#define ID_CANCEL_EDIT_SRVR			32769

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS			1
#define _APS_NEXT_RESOURCE_VALUE	130
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\mfcawex2Doc.cpp ===
// mfcawex2Doc.cpp : implementation of the CMfcawex2Doc class
//

#include "stdafx.h"
#include "mfcawex2.h"

#include "mfcawex2Doc.h"
#include "CntrItem.h"
#include "SrvrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2Doc

IMPLEMENT_DYNCREATE(CMfcawex2Doc, COleServerDoc)

BEGIN_MESSAGE_MAP(CMfcawex2Doc, COleServerDoc)
	//{{AFX_MSG_MAP(CMfcawex2Doc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Enable default OLE container implementation
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, COleServerDoc::OnUpdatePasteMenu)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, COleServerDoc::OnUpdatePasteLinkMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, COleServerDoc::OnUpdateObjectVerbMenu)
	ON_COMMAND(ID_OLE_EDIT_CONVERT, COleServerDoc::OnEditConvert)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, COleServerDoc::OnUpdateEditLinksMenu)
	ON_COMMAND(ID_OLE_EDIT_LINKS, COleServerDoc::OnEditLinks)
	ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, COleServerDoc::OnUpdateObjectVerbMenu)
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CMfcawex2Doc, COleServerDoc)
	//{{AFX_DISPATCH_MAP(CMfcawex2Doc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//      DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IMfcawex2 to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {1DEE14A8-CC4B-11D0-84BF-00AA00C00848}
static const IID IID_IMfcawex2 =
{ 0x1dee14a8, 0xcc4b, 0x11d0, { 0x84, 0xbf, 0x0, 0xaa, 0x0, 0xc0, 0x8, 0x48 } };

BEGIN_INTERFACE_MAP(CMfcawex2Doc, COleServerDoc)
	INTERFACE_PART(CMfcawex2Doc, IID_IMfcawex2, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2Doc construction/destruction

CMfcawex2Doc::CMfcawex2Doc()
{
	// Use OLE compound files
	EnableCompoundFile();

	// TODO: add one-time construction code here

	EnableAutomation();

	AfxOleLockApp();
}

CMfcawex2Doc::~CMfcawex2Doc()
{
	AfxOleUnlockApp();
}

BOOL CMfcawex2Doc::OnNewDocument()
{
	if (!COleServerDoc::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2Doc server implementation

COleServerItem* CMfcawex2Doc::OnGetEmbeddedItem()
{
	// OnGetEmbeddedItem is called by the framework to get the COleServerItem
	//  that is associated with the document.  It is only called when necessary.

	CMfcawex2SrvrItem* pItem = new CMfcawex2SrvrItem(this);
	ASSERT_VALID(pItem);
	return pItem;
}



/////////////////////////////////////////////////////////////////////////////
// CMfcawex2Doc serialization

void CMfcawex2Doc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}

	// Calling the base class COleServerDoc enables serialization
	//  of the container document's COleClientItem objects.
	COleServerDoc::Serialize(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2Doc diagnostics

#ifdef _DEBUG
void CMfcawex2Doc::AssertValid() const
{
	COleServerDoc::AssertValid();
}

void CMfcawex2Doc::Dump(CDumpContext& dc) const
{
	COleServerDoc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2Doc commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\mfcawex2View.cpp ===
// mfcawex2View.cpp : implementation of the CMfcawex2View class
//

#include "stdafx.h"
#include "mfcawex2.h"

#include "mfcawex2Doc.h"
#include "CntrItem.h"
#include "mfcawex2View.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2View

IMPLEMENT_DYNCREATE(CMfcawex2View, CView)

BEGIN_MESSAGE_MAP(CMfcawex2View, CView)
	//{{AFX_MSG_MAP(CMfcawex2View)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	ON_WM_DESTROY()
	ON_WM_SETFOCUS()
	ON_WM_SIZE()
	ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
	ON_COMMAND(ID_CANCEL_EDIT_CNTR, OnCancelEditCntr)
	ON_COMMAND(ID_CANCEL_EDIT_SRVR, OnCancelEditSrvr)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2View construction/destruction

CMfcawex2View::CMfcawex2View()
{
	m_pSelection = NULL;
	// TODO: add construction code here

}

CMfcawex2View::~CMfcawex2View()
{
}

BOOL CMfcawex2View::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2View drawing

void CMfcawex2View::OnDraw(CDC* pDC)
{
	CMfcawex2Doc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: add draw code for native data here
	// TODO: also draw all OLE items in the document

	// Draw the selection at an arbitrary position.  This code should be
	//  removed once your real drawing code is implemented.  This position
	//  corresponds exactly to the rectangle returned by CMfcawex2CntrItem,
	//  to give the effect of in-place editing.

	// TODO: remove this code when final draw code is complete.

	if (m_pSelection == NULL)
	{
		POSITION pos = pDoc->GetStartPosition();
		m_pSelection = (CMfcawex2CntrItem*)pDoc->GetNextClientItem(pos);
	}
	if (m_pSelection != NULL)
		m_pSelection->Draw(pDC, CRect(10, 10, 210, 210));
}

void CMfcawex2View::OnInitialUpdate()
{
	CView::OnInitialUpdate();

	// TODO: remove this code when final selection model code is written
	m_pSelection = NULL;    // initialize selection

}

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2View printing

BOOL CMfcawex2View::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CMfcawex2View::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CMfcawex2View::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

void CMfcawex2View::OnDestroy()
{
	// Deactivate the item on destruction; this is important
	// when a splitter view is being used.
   CView::OnDestroy();
   COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
   if (pActiveItem != NULL && pActiveItem->GetActiveView() == this)
   {
      pActiveItem->Deactivate();
      ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
   }
}


/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

BOOL CMfcawex2View::IsSelected(const CObject* pDocItem) const
{
	// The implementation below is adequate if your selection consists of
	//  only CMfcawex2CntrItem objects.  To handle different selection
	//  mechanisms, the implementation here should be replaced.

	// TODO: implement this function that tests for a selected OLE client item

	return pDocItem == m_pSelection;
}

void CMfcawex2View::OnInsertObject()
{
	// Invoke the standard Insert Object dialog box to obtain information
	//  for new CMfcawex2CntrItem object.
	COleInsertDialog dlg;
	if (dlg.DoModal() != IDOK)
		return;

	BeginWaitCursor();

	CMfcawex2CntrItem* pItem = NULL;
	TRY
	{
		// Create new item connected to this document.
		CMfcawex2Doc* pDoc = GetDocument();
		ASSERT_VALID(pDoc);
		pItem = new CMfcawex2CntrItem(pDoc);
		ASSERT_VALID(pItem);

		// Initialize the item from the dialog data.
		if (!dlg.CreateItem(pItem))
			AfxThrowMemoryException();  // any exception will do
		ASSERT_VALID(pItem);

		// If item created from class list (not from file) then launch
		//  the server to edit the item.
		if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
			pItem->DoVerb(OLEIVERB_SHOW, this);

		ASSERT_VALID(pItem);

		// As an arbitrary user interface design, this sets the selection
		//  to the last item inserted.

		// TODO: reimplement selection as appropriate for your application

		m_pSelection = pItem;   // set selection to last inserted item
		pDoc->UpdateAllViews(NULL);
	}
	CATCH(CException, e)
	{
		if (pItem != NULL)
		{
			ASSERT_VALID(pItem);
			pItem->Delete();
		}
		AfxMessageBox(IDP_FAILED_TO_CREATE);
	}
	END_CATCH

	EndWaitCursor();
}

// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.  Here,
//  the container (not the server) causes the deactivation.
void CMfcawex2View::OnCancelEditCntr()
{
	// Close any in-place active item on this view.
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
	{
		pActiveItem->Close();
	}
	ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
}

// Special handling of OnSetFocus and OnSize are required for a container
//  when an object is being edited in-place.
void CMfcawex2View::OnSetFocus(CWnd* pOldWnd)
{
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL &&
		pActiveItem->GetItemState() == COleClientItem::activeUIState)
	{
		// need to set focus to this item if it is in the same view
		CWnd* pWnd = pActiveItem->GetInPlaceWindow();
		if (pWnd != NULL)
		{
			pWnd->SetFocus();   // don't call the base class
			return;
		}
	}

	CView::OnSetFocus(pOldWnd);
}

void CMfcawex2View::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
		pActiveItem->SetItemRects();
}

/////////////////////////////////////////////////////////////////////////////
// OLE Server support

// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.  Here,
//  the server (not the container) causes the deactivation.
void CMfcawex2View::OnCancelEditSrvr()
{
	GetDocument()->OnDeactivateUI(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2View diagnostics

#ifdef _DEBUG
void CMfcawex2View::AssertValid() const
{
	CView::AssertValid();
}

void CMfcawex2View::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CMfcawex2Doc* CMfcawex2View::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMfcawex2Doc)));
	return (CMfcawex2Doc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2View message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\mfcawex2Doc.h ===
// mfcawex2Doc.h : interface of the CMfcawex2Doc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MFCAWEX2DOC_H__1DEE14B4_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWEX2DOC_H__1DEE14B4_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class CMfcawex2SrvrItem;

class CMfcawex2Doc : public COleServerDoc
{
protected: // create from serialization only
	CMfcawex2Doc();
	DECLARE_DYNCREATE(CMfcawex2Doc)

// Attributes
public:
	CMfcawex2SrvrItem* GetEmbeddedItem()
		{ return (CMfcawex2SrvrItem*)COleServerDoc::GetEmbeddedItem(); }

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawex2Doc)
	protected:
	virtual COleServerItem* OnGetEmbeddedItem();
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMfcawex2Doc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CMfcawex2Doc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CMfcawex2Doc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEX2DOC_H__1DEE14B4_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\mfcawex2View.h ===
// mfcawex2View.h : interface of the CMfcawex2View class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MFCAWEX2VIEW_H__1DEE14B6_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWEX2VIEW_H__1DEE14B6_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMfcawex2CntrItem;

class CMfcawex2View : public CView
{
protected: // create from serialization only
	CMfcawex2View();
	DECLARE_DYNCREATE(CMfcawex2View)

// Attributes
public:
	CMfcawex2Doc* GetDocument();
	// m_pSelection holds the selection to the current CMfcawex2CntrItem.
	// For many applications, such a member variable isn't adequate to
	//  represent a selection, such as a multiple selection or a selection
	//  of objects that are not CMfcawex2CntrItem objects.  This selection
	//  mechanism is provided just to help you get started.

	// TODO: replace this selection mechanism with one appropriate to your app.
	CMfcawex2CntrItem* m_pSelection;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawex2View)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual BOOL IsSelected(const CObject* pDocItem) const;// Container support
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMfcawex2View();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CMfcawex2View)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	afx_msg void OnDestroy();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnInsertObject();
	afx_msg void OnCancelEditCntr();
	afx_msg void OnCancelEditSrvr();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in mfcawex2View.cpp
inline CMfcawex2Doc* CMfcawex2View::GetDocument()
   { return (CMfcawex2Doc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEX2VIEW_H__1DEE14B6_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\SrvrItem.h ===
// SrvrItem.h : interface of the CMfcawex2SrvrItem class
//

#if !defined(AFX_SRVRITEM_H__1DEE14B9_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_SRVRITEM_H__1DEE14B9_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMfcawex2SrvrItem : public COleServerItem
{
	DECLARE_DYNAMIC(CMfcawex2SrvrItem)

// Constructors
public:
	CMfcawex2SrvrItem(CMfcawex2Doc* pContainerDoc);

// Attributes
	CMfcawex2Doc* GetDocument() const
		{ return (CMfcawex2Doc*)COleServerItem::GetDocument(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawex2SrvrItem)
	public:
	virtual BOOL OnDraw(CDC* pDC, CSize& rSize);
	virtual BOOL OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize);
	//}}AFX_VIRTUAL

// Implementation
public:
	~CMfcawex2SrvrItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SRVRITEM_H__1DEE14B9_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mfcawex2.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\SrvrItem.cpp ===
// SrvrItem.cpp : implementation of the CMfcawex2SrvrItem class
//

#include "stdafx.h"
#include "mfcawex2.h"

#include "mfcawex2Doc.h"
#include "SrvrItem.h"
#include "CntrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2SrvrItem implementation

IMPLEMENT_DYNAMIC(CMfcawex2SrvrItem, COleServerItem)

CMfcawex2SrvrItem::CMfcawex2SrvrItem(CMfcawex2Doc* pContainerDoc)
	: COleServerItem(pContainerDoc, TRUE)
{
	// TODO: add one-time construction code here
	//  (eg, adding additional clipboard formats to the item's data source)
}

CMfcawex2SrvrItem::~CMfcawex2SrvrItem()
{
	// TODO: add cleanup code here
}

void CMfcawex2SrvrItem::Serialize(CArchive& ar)
{
	// CMfcawex2SrvrItem::Serialize will be called by the framework if
	//  the item is copied to the clipboard.  This can happen automatically
	//  through the OLE callback OnGetClipboardData.  A good default for
	//  the embedded item is simply to delegate to the document's Serialize
	//  function.  If you support links, then you will want to serialize
	//  just a portion of the document.

	if (!IsLinkedItem())
	{
		CMfcawex2Doc* pDoc = GetDocument();
		ASSERT_VALID(pDoc);
		pDoc->Serialize(ar);
	}
}

BOOL CMfcawex2SrvrItem::OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize)
{
	// Most applications, like this one, only handle drawing the content
	//  aspect of the item.  If you wish to support other aspects, such
	//  as DVASPECT_THUMBNAIL (by overriding OnDrawEx), then this
	//  implementation of OnGetExtent should be modified to handle the
	//  additional aspect(s).

	if (dwDrawAspect != DVASPECT_CONTENT)
		return COleServerItem::OnGetExtent(dwDrawAspect, rSize);

	// CMfcawex2SrvrItem::OnGetExtent is called to get the extent in
	//  HIMETRIC units of the entire item.  The default implementation
	//  here simply returns a hard-coded number of units.

	CMfcawex2Doc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: replace this arbitrary size

	rSize = CSize(3000, 3000);   // 3000 x 3000 HIMETRIC units

	return TRUE;
}

BOOL CMfcawex2SrvrItem::OnDraw(CDC* pDC, CSize& rSize)
{
	// Remove this if you use rSize
	UNREFERENCED_PARAMETER(rSize);

	CMfcawex2Doc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: set mapping mode and extent
	//  (The extent is usually the same as the size returned from OnGetExtent)
	pDC->SetMapMode(MM_ANISOTROPIC);
	pDC->SetWindowOrg(0,0);
	pDC->SetWindowExt(3000, 3000);

	// TODO: add drawing code here.  Optionally, fill in the HIMETRIC extent.
	//  All drawing takes place in the metafile device context (pDC).

	// TODO: also draw embedded CMfcawex2CntrItem objects.

	// The following code draws the first item at an arbitrary position.

	// TODO: remove this code when your real drawing code is complete

	POSITION pos = pDoc->GetStartPosition();
	CMfcawex2CntrItem* pItem = (CMfcawex2CntrItem*)pDoc->GetNextClientItem(pos);
	if (pItem != NULL)
		pItem->Draw(pDC, CRect(10, 10, 1010, 1010));
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2SrvrItem diagnostics

#ifdef _DEBUG
void CMfcawex2SrvrItem::AssertValid() const
{
	COleServerItem::AssertValid();
}

void CMfcawex2SrvrItem::Dump(CDumpContext& dc) const
{
	COleServerItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__1DEE14AE_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_STDAFX_H__1DEE14AE_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1DEE14AE_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\new\ChildFrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "mfcawex2.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
int i = 3;
	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\new\CntrItem.cpp ===
// CntrItem.cpp : implementation of the CMfcawex2CntrItem class
//

#include "stdafx.h"
#include "mfcawex2.h"

#include "mfcawex2Doc.h"
#include "mfcawex2View.h"
#include "CntrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2CntrItem implementation

IMPLEMENT_SERIAL(CMfcawex2CntrItem, COleClientItem, 0)

CMfcawex2CntrItem::CMfcawex2CntrItem(CMfcawex2Doc* pContainer)
	: COleClientItem(pContainer)
{
	// TODO: add one-time construction code here
	
}

CMfcawex2CntrItem::~CMfcawex2CntrItem()
{
	// TODO: add cleanup code here
	
}

void CMfcawex2CntrItem::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	ASSERT_VALID(this);

	COleClientItem::OnChange(nCode, dwParam);
int i = 3;

	// When an item is being edited (either in-place or fully open)
	//  it sends OnChange notifications for changes in the state of the
	//  item or visual appearance of its content.

	// TODO: invalidate the item by calling UpdateAllViews
	//  (with hints appropriate to your application)

	GetDocument()->UpdateAllViews(NULL);
		// for now just update ALL views/no hints
}

BOOL CMfcawex2CntrItem::OnChangeItemPosition(const CRect& rectPos)
{
	ASSERT_VALID(this);

	// During in-place activation CMfcawex2CntrItem::OnChangeItemPosition
	//  is called by the server to change the position of the in-place
	//  window.  Usually, this is a result of the data in the server
	//  document changing such that the extent has changed or as a result
	//  of in-place resizing.
	//
	// The default here is to call the base class, which will call
	//  COleClientItem::SetItemRects to move the item
	//  to the new position.

	if (!COleClientItem::OnChangeItemPosition(rectPos))
		return FALSE;

	// TODO: update any cache you may have of the item's rectangle/extent

	return TRUE;
}

void CMfcawex2CntrItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);

	// During in-place activation, CMfcawex2CntrItem::OnGetItemPosition
	//  will be called to determine the location of this item.  The default
	//  implementation created from AppWizard simply returns a hard-coded
	//  rectangle.  Usually, this rectangle would reflect the current
	//  position of the item relative to the view used for activation.
	//  You can obtain the view by calling CMfcawex2CntrItem::GetActiveView.

	// TODO: return correct rectangle (in pixels) in rPosition

	rPosition.SetRect(10, 10, 210, 210);
}

void CMfcawex2CntrItem::OnActivate()
{
    // Allow only one inplace activate item per frame
    CMfcawex2View* pView = GetActiveView();
    ASSERT_VALID(pView);
    COleClientItem* pItem = GetDocument()->GetInPlaceActiveItem(pView);
    if (pItem != NULL && pItem != this)
        pItem->Close();
    
    COleClientItem::OnActivate();
}

void CMfcawex2CntrItem::OnDeactivateUI(BOOL bUndoable)
{
	COleClientItem::OnDeactivateUI(bUndoable);

    // Hide the object if it is not an outside-in object
    DWORD dwMisc = 0;
    m_lpObject->GetMiscStatus(GetDrawAspect(), &dwMisc);
    if (dwMisc & OLEMISC_INSIDEOUT)
        DoVerb(OLEIVERB_HIDE, NULL);
}

void CMfcawex2CntrItem::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	// Call base class first to read in COleClientItem data.
	// Since this sets up the m_pDocument pointer returned from
	//  CMfcawex2CntrItem::GetDocument, it is a good idea to call
	//  the base class Serialize first.
	COleClientItem::Serialize(ar);

	// now store/retrieve data specific to CMfcawex2CntrItem
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

BOOL CMfcawex2CntrItem::CanActivate()
{
	// Editing in-place while the server itself is being edited in-place
	//  does not work and is not supported.  So, disable in-place
	//  activation in this case.
	CMfcawex2Doc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(COleServerDoc)));
	if (pDoc->IsInPlaceActive())
		return FALSE;

	// otherwise, rely on default behavior
	return COleClientItem::CanActivate();
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2CntrItem diagnostics

#ifdef _DEBUG
void CMfcawex2CntrItem::AssertValid() const
{
	COleClientItem::AssertValid();
}

void CMfcawex2CntrItem::Dump(CDumpContext& dc) const
{
	COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\new\CntrItem.h ===
// CntrItem.h : interface of the CMfcawex2CntrItem class
//

#if !defined(AFX_CNTRITEM_H__1DEE14BD_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_CNTRITEM_H__1DEE14BD_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#define TESTTEST
class CMfcawex2Doc;
class CMfcawex2View;

class CMfcawex2CntrItem : public COleClientItem
{
	DECLARE_SERIAL(CMfcawex2CntrItem)

// Constructors
public:
	CMfcawex2CntrItem(CMfcawex2Doc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CMfcawex2Doc* GetDocument()
		{ return (CMfcawex2Doc*)COleClientItem::GetDocument(); }
	CMfcawex2View* GetActiveView()
		{ return (CMfcawex2View*)COleClientItem::GetActiveView(); }

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawex2CntrItem)
	public:
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual void OnActivate();
	protected:
	virtual void OnGetItemPosition(CRect& rPosition);
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
	virtual BOOL CanActivate();
	//}}AFX_VIRTUAL

// Implementation
public:
	~CMfcawex2CntrItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CNTRITEM_H__1DEE14BD_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\new\IpFrame.cpp ===
// IpFrame.cpp : implementation of the CInPlaceFrame class
//

#include "stdafx.h"
#include "mfcawex2.h"

#include "IpFrame.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame

IMPLEMENT_DYNCREATE(CInPlaceFrame, COleIPFrameWnd)

BEGIN_MESSAGE_MAP(CInPlaceFrame, COleIPFrameWnd)
	//{{AFX_MSG_MAP(CInPlaceFrame)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, COleIPFrameWnd::OnHelpFinder)
	ON_COMMAND(ID_HELP, COleIPFrameWnd::OnHelp)
	ON_COMMAND(ID_DEFAULT_HELP, COleIPFrameWnd::OnHelpFinder)
	ON_COMMAND(ID_CONTEXT_HELP, COleIPFrameWnd::OnContextHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame construction/destruction

CInPlaceFrame::CInPlaceFrame()
{
}

CInPlaceFrame::~CInPlaceFrame()
{
}

int CInPlaceFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleIPFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// CResizeBar implements in-place resizing.
	if (!m_wndResizeBar.Create(this))
	{
		TRACE0("Failed to create resize bar\n");
		return -1;      // fail to create
	}

	// By default, it is a good idea to register a drop-target that does
	//  nothing with your frame window.  This prevents drops from
	//  "falling through" to a container that supports drag-drop.
	m_dropTarget.Register(this);
int i = 3;

	return 0;
}

// OnCreateControlBars is called by the framework to create control bars on the
//  container application's windows.  pWndFrame is the top level frame window of
//  the container and is always non-NULL.  pWndDoc is the doc level frame window
//  and will be NULL when the container is an SDI application.  A server
//  application can place MFC control bars on either window.
BOOL CInPlaceFrame::OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc)
{
	// Remove this if you use pWndDoc
	UNREFERENCED_PARAMETER(pWndDoc);

	// Set owner to this window, so messages are delivered to correct app
	m_wndToolBar.SetOwner(this);

	// Create toolbar on client's frame window
	if (!m_wndToolBar.Create(pWndFrame) ||
		!m_wndToolBar.LoadToolBar(IDR_MFCAWETYPE_SRVR_IP))
	{
		TRACE0("Failed to create toolbar\n");
		return FALSE;
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	pWndFrame->EnableDocking(CBRS_ALIGN_ANY);
	pWndFrame->DockControlBar(&m_wndToolBar);

	return TRUE;
}

BOOL CInPlaceFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return COleIPFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame diagnostics

#ifdef _DEBUG
void CInPlaceFrame::AssertValid() const
{
	COleIPFrameWnd::AssertValid();
}

void CInPlaceFrame::Dump(CDumpContext& dc) const
{
	COleIPFrameWnd::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\new\mfcawex2.h ===
// mfcawex2.h : main header file for the MFCAWEX2 application
//

#if !defined(AFX_MFCAWEX2_H__1DEE14AB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWEX2_H__1DEE14AB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif
#define TESTTEST

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2App:
// See mfcawex2.cpp for the implementation of this class
//

class CMfcawex2App : public CWinApp
{
public:
	CMfcawex2App();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawex2App)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
	COleTemplateServer m_server;
		// Server object for document creation

	//{{AFX_MSG(CMfcawex2App)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEX2_H__1DEE14AB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\new\mfcawex2Doc.h ===
// mfcawex2Doc.h : interface of the CMfcawex2Doc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MFCAWEX2DOC_H__1DEE14B4_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWEX2DOC_H__1DEE14B4_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define TESTTEST

class CMfcawex2SrvrItem;

class CMfcawex2Doc : public COleServerDoc
{
protected: // create from serialization only
	CMfcawex2Doc();
	DECLARE_DYNCREATE(CMfcawex2Doc)

// Attributes
public:
	CMfcawex2SrvrItem* GetEmbeddedItem()
		{ return (CMfcawex2SrvrItem*)COleServerDoc::GetEmbeddedItem(); }

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawex2Doc)
	protected:
	virtual COleServerItem* OnGetEmbeddedItem();
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMfcawex2Doc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CMfcawex2Doc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CMfcawex2Doc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEX2DOC_H__1DEE14B4_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\new\IpFrame.h ===
// IpFrame.h : interface of the CInPlaceFrame class
//

#if !defined(AFX_IPFRAME_H__1DEE14BB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_IPFRAME_H__1DEE14BB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_
#define TESTTEST

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CInPlaceFrame : public COleIPFrameWnd
{
	DECLARE_DYNCREATE(CInPlaceFrame)
public:
	CInPlaceFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInPlaceFrame)
	public:
	virtual BOOL OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CInPlaceFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	CToolBar    m_wndToolBar;
	COleDropTarget	m_dropTarget;
	COleResizeBar   m_wndResizeBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CInPlaceFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_IPFRAME_H__1DEE14BB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\new\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mfcawex2.rc
//
#define IDR_MFCAWETYPE_SRVR_IP          4
#define IDR_MFCAWETYPE_SRVR_EMB         5
#define IDR_MFCAWETYPE_CNTR_IP          6
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define IDP_FAILED_TO_CREATE            102
#define IDR_MAINFRAME                   128
#define IDR_MFCAWETYPE                  129
#define ID_CANCEL_EDIT_CNTR             32768
#define ID_CANCEL_EDIT_SRVR             32769

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\new\SrvrItem.cpp ===
// SrvrItem.cpp : implementation of the CMfcawex2SrvrItem class
//

#include "stdafx.h"
#include "mfcawex2.h"

#include "mfcawex2Doc.h"
#include "SrvrItem.h"
#include "CntrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2SrvrItem implementation

IMPLEMENT_DYNAMIC(CMfcawex2SrvrItem, COleServerItem)

CMfcawex2SrvrItem::CMfcawex2SrvrItem(CMfcawex2Doc* pContainerDoc)
	: COleServerItem(pContainerDoc, TRUE)
{
	// TODO: add one-time construction code here
	//  (eg, adding additional clipboard formats to the item's data source)
}

CMfcawex2SrvrItem::~CMfcawex2SrvrItem()
{
	// TODO: add cleanup code here
}

void CMfcawex2SrvrItem::Serialize(CArchive& ar)
{
	// CMfcawex2SrvrItem::Serialize will be called by the framework if
	//  the item is copied to the clipboard.  This can happen automatically
	//  through the OLE callback OnGetClipboardData.  A good default for
	//  the embedded item is simply to delegate to the document's Serialize
	//  function.  If you support links, then you will want to serialize
	//  just a portion of the document.
int i = 3;

	if (!IsLinkedItem())
	{
		CMfcawex2Doc* pDoc = GetDocument();
		ASSERT_VALID(pDoc);
		pDoc->Serialize(ar);
	}
}

BOOL CMfcawex2SrvrItem::OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize)
{
	// Most applications, like this one, only handle drawing the content
	//  aspect of the item.  If you wish to support other aspects, such
	//  as DVASPECT_THUMBNAIL (by overriding OnDrawEx), then this
	//  implementation of OnGetExtent should be modified to handle the
	//  additional aspect(s).

	if (dwDrawAspect != DVASPECT_CONTENT)
		return COleServerItem::OnGetExtent(dwDrawAspect, rSize);

	// CMfcawex2SrvrItem::OnGetExtent is called to get the extent in
	//  HIMETRIC units of the entire item.  The default implementation
	//  here simply returns a hard-coded number of units.

	CMfcawex2Doc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: replace this arbitrary size

	rSize = CSize(3000, 3000);   // 3000 x 3000 HIMETRIC units

	return TRUE;
}

BOOL CMfcawex2SrvrItem::OnDraw(CDC* pDC, CSize& rSize)
{
	// Remove this if you use rSize
	UNREFERENCED_PARAMETER(rSize);

	CMfcawex2Doc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: set mapping mode and extent
	//  (The extent is usually the same as the size returned from OnGetExtent)
	pDC->SetMapMode(MM_ANISOTROPIC);
	pDC->SetWindowOrg(0,0);
	pDC->SetWindowExt(3000, 3000);

	// TODO: add drawing code here.  Optionally, fill in the HIMETRIC extent.
	//  All drawing takes place in the metafile device context (pDC).

	// TODO: also draw embedded CMfcawex2CntrItem objects.

	// The following code draws the first item at an arbitrary position.

	// TODO: remove this code when your real drawing code is complete

	POSITION pos = pDoc->GetStartPosition();
	CMfcawex2CntrItem* pItem = (CMfcawex2CntrItem*)pDoc->GetNextClientItem(pos);
	if (pItem != NULL)
		pItem->Draw(pDC, CRect(10, 10, 1010, 1010));
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawex2SrvrItem diagnostics

#ifdef _DEBUG
void CMfcawex2SrvrItem::AssertValid() const
{
	COleServerItem::AssertValid();
}

void CMfcawex2SrvrItem::Dump(CDumpContext& dc) const
{
	COleServerItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex3\mfcawex3.cpp ===
// mfcawex3.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "mfcawex3.h"
#include "mfcawex3Dlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3App

BEGIN_MESSAGE_MAP(CMfcawex3App, CWinApp)
	//{{AFX_MSG_MAP(CMfcawex3App)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3App construction

CMfcawex3App::CMfcawex3App()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMfcawex3App object

CMfcawex3App theApp;

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3App initialization

BOOL CMfcawex3App::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CMfcawex3Dlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex3\mfcawex3.h ===
// mfcawex3.h : main header file for the MFCAWEX3 application
//

#if !defined(AFX_MFCAWEX3_H__3EDC9525_885B_11D1_87EF_00AA003451E1__INCLUDED_)
#define AFX_MFCAWEX3_H__3EDC9525_885B_11D1_87EF_00AA003451E1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3App:
// See mfcawex3.cpp for the implementation of this class
//

class CMfcawex3App : public CWinApp
{
public:
	CMfcawex3App();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawex3App)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMfcawex3App)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEX3_H__3EDC9525_885B_11D1_87EF_00AA003451E1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex2\new\SrvrItem.h ===
// SrvrItem.h : interface of the CMfcawex2SrvrItem class
//

#if !defined(AFX_SRVRITEM_H__1DEE14B9_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_SRVRITEM_H__1DEE14B9_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#define TESTTEST

class CMfcawex2SrvrItem : public COleServerItem
{
	DECLARE_DYNAMIC(CMfcawex2SrvrItem)

// Constructors
public:
	CMfcawex2SrvrItem(CMfcawex2Doc* pContainerDoc);

// Attributes
	CMfcawex2Doc* GetDocument() const
		{ return (CMfcawex2Doc*)COleServerItem::GetDocument(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawex2SrvrItem)
	public:
	virtual BOOL OnDraw(CDC* pDC, CSize& rSize);
	virtual BOOL OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize);
	//}}AFX_VIRTUAL

// Implementation
public:
	~CMfcawex2SrvrItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SRVRITEM_H__1DEE14B9_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex3\mfcawex3Dlg.cpp ===
// mfcawex3Dlg.cpp : implementation file
//

#include "stdafx.h"
#include "mfcawex3.h"
#include "mfcawex3Dlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3Dlg dialog

CMfcawex3Dlg::CMfcawex3Dlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMfcawex3Dlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMfcawex3Dlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CMfcawex3Dlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMfcawex3Dlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMfcawex3Dlg, CDialog)
	//{{AFX_MSG_MAP(CMfcawex3Dlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3Dlg message handlers

BOOL CMfcawex3Dlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CMfcawex3Dlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CMfcawex3Dlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMfcawex3Dlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex3\mfcawex3Dlg.h ===
// mfcawex3Dlg.h : header file
//

#if !defined(AFX_MFCAWEX3DLG_H__3EDC9527_885B_11D1_87EF_00AA003451E1__INCLUDED_)
#define AFX_MFCAWEX3DLG_H__3EDC9527_885B_11D1_87EF_00AA003451E1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3Dlg dialog

class CMfcawex3Dlg : public CDialog
{
// Construction
public:
	CMfcawex3Dlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CMfcawex3Dlg)
	enum { IDD = IDD_MFCAWEX3_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawex3Dlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CMfcawex3Dlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEX3DLG_H__3EDC9527_885B_11D1_87EF_00AA003451E1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex3\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by MFCAWEX3.RC
//
#define IDR_MAINFRAME					128
#define IDM_ABOUTBOX					0x0010
#define IDD_ABOUTBOX					100
#define IDS_ABOUTBOX					101
#define IDD_MFCAWEX3_DIALOG				102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex3\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mfcawex3.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex3\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__3EDC9529_885B_11D1_87EF_00AA003451E1__INCLUDED_)
#define AFX_STDAFX_H__3EDC9529_885B_11D1_87EF_00AA003451E1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3EDC9529_885B_11D1_87EF_00AA003451E1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex3\new\mfcawex3.h ===
// mfcawex3.h : main header file for the MFCAWEX3 application
//

#if !defined(AFX_MFCAWEX3_H__1DEE14E9_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWEX3_H__1DEE14E9_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif
#define TESTTEST
#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3App:
// See mfcawex3.cpp for the implementation of this class
//

class CMfcawex3App : public CWinApp
{
public:
	CMfcawex3App();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawex3App)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMfcawex3App)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEX3_H__1DEE14E9_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex3\new\mfcawex3Dlg.cpp ===
// mfcawex3Dlg.cpp : implementation file
//

#include "stdafx.h"
#include "mfcawex3.h"
#include "mfcawex3Dlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3Dlg dialog

CMfcawex3Dlg::CMfcawex3Dlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMfcawex3Dlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMfcawex3Dlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CMfcawex3Dlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMfcawex3Dlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMfcawex3Dlg, CDialog)
	//{{AFX_MSG_MAP(CMfcawex3Dlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3Dlg message handlers

BOOL CMfcawex3Dlg::OnInitDialog()
{
	CDialog::OnInitDialog();
int i = 3;

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CMfcawex3Dlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CMfcawex3Dlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMfcawex3Dlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex3\new\mfcawex3Dlg.h ===
// mfcawex3Dlg.h : header file
//

#if !defined(AFX_MFCAWEX3DLG_H__1DEE14EB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWEX3DLG_H__1DEE14EB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#define TESTTEST

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3Dlg dialog

class CMfcawex3Dlg : public CDialog
{
// Construction
public:
	CMfcawex3Dlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CMfcawex3Dlg)
	enum { IDD = IDD_MFCAWEX3_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawex3Dlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CMfcawex3Dlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEX3DLG_H__1DEE14EB_CC4B_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex3\new\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mfcawex3.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_MFCAWEX3_DIALOG             102
#define IDR_MAINFRAME                   128

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawex3\new\mfcawex3.cpp ===
// mfcawex3.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "mfcawex3.h"
#include "mfcawex3Dlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3App

BEGIN_MESSAGE_MAP(CMfcawex3App, CWinApp)
	//{{AFX_MSG_MAP(CMfcawex3App)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3App construction

CMfcawex3App::CMfcawex3App()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMfcawex3App object

CMfcawex3App theApp;

/////////////////////////////////////////////////////////////////////////////
// CMfcawex3App initialization

BOOL CMfcawex3App::InitInstance()
{
	AfxEnableControlContainer();
int i = 3;
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CMfcawex3Dlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\ChildFrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__CAA16AAE_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_CHILDFRM_H__CAA16AAE_CAD7_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__CAA16AAE_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\MainFrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "mfcawexe.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\ChildFrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "mfcawexe.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\mfcawexe.h ===
// mfcawexe.h : main header file for the MFCAWEXE application
//

#if !defined(AFX_MFCAWEXE_H__CAA16AA8_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWEXE_H__CAA16AA8_CAD7_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeApp:
// See mfcawexe.cpp for the implementation of this class
//

class CMfcawexeApp : public CWinApp
{
public:
	CMfcawexeApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawexeApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMfcawexeApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEXE_H__CAA16AA8_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\mfcawexe.cpp ===
// mfcawexe.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "mfcawexe.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "mfcawexeDoc.h"
#include "mfcawexeView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeApp

BEGIN_MESSAGE_MAP(CMfcawexeApp, CWinApp)
	//{{AFX_MSG_MAP(CMfcawexeApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeApp construction

CMfcawexeApp::CMfcawexeApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMfcawexeApp object

CMfcawexeApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeApp initialization

BOOL CMfcawexeApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_MFCAWETYPE,
		RUNTIME_CLASS(CMfcawexeDoc),
		RUNTIME_CLASS(CChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CMfcawexeView));
	AddDocTemplate(pDocTemplate);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CMfcawexeApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeApp commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\mfcawexeDoc.cpp ===
// mfcawexeDoc.cpp : implementation of the CMfcawexeDoc class
//

#include "stdafx.h"
#include "mfcawexe.h"

#include "mfcawexeDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeDoc

IMPLEMENT_DYNCREATE(CMfcawexeDoc, CDocument)

BEGIN_MESSAGE_MAP(CMfcawexeDoc, CDocument)
	//{{AFX_MSG_MAP(CMfcawexeDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeDoc construction/destruction

CMfcawexeDoc::CMfcawexeDoc()
{
	// TODO: add one-time construction code here

}

CMfcawexeDoc::~CMfcawexeDoc()
{
}

BOOL CMfcawexeDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CMfcawexeDoc serialization

void CMfcawexeDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeDoc diagnostics

#ifdef _DEBUG
void CMfcawexeDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CMfcawexeDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\MainFrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__CAA16AAC_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MAINFRM_H__CAA16AAC_CAD7_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__CAA16AAC_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\mfcawexeDoc.h ===
// mfcawexeDoc.h : interface of the CMfcawexeDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MFCAWEXEDOC_H__CAA16AB0_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWEXEDOC_H__CAA16AB0_CAD7_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class CMfcawexeDoc : public CDocument
{
protected: // create from serialization only
	CMfcawexeDoc();
	DECLARE_DYNCREATE(CMfcawexeDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawexeDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMfcawexeDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CMfcawexeDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEXEDOC_H__CAA16AB0_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\mfcawexeView.cpp ===
// mfcawexeView.cpp : implementation of the CMfcawexeView class
//

#include "stdafx.h"
#include "mfcawexe.h"

#include "mfcawexeDoc.h"
#include "mfcawexeView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeView

IMPLEMENT_DYNCREATE(CMfcawexeView, CView)

BEGIN_MESSAGE_MAP(CMfcawexeView, CView)
	//{{AFX_MSG_MAP(CMfcawexeView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeView construction/destruction

CMfcawexeView::CMfcawexeView()
{
	// TODO: add construction code here

}

CMfcawexeView::~CMfcawexeView()
{
}

BOOL CMfcawexeView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeView drawing

void CMfcawexeView::OnDraw(CDC* pDC)
{
	CMfcawexeDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: add draw code for native data here
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeView printing

BOOL CMfcawexeView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CMfcawexeView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CMfcawexeView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeView diagnostics

#ifdef _DEBUG
void CMfcawexeView::AssertValid() const
{
	CView::AssertValid();
}

void CMfcawexeView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CMfcawexeDoc* CMfcawexeView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMfcawexeDoc)));
	return (CMfcawexeDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__CAA16AAA_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_STDAFX_H__CAA16AAA_CAD7_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CAA16AAA_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mfcawexe.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by MFCAWEXE.RC
//
#define IDR_MAINFRAME				128
#define IDR_MFCAWETYPE				129
#define IDD_ABOUTBOX				100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS			1
#define _APS_NEXT_RESOURCE_VALUE	130
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\mfcawexeView.h ===
// mfcawexeView.h : interface of the CMfcawexeView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MFCAWEXEVIEW_H__CAA16AB2_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWEXEVIEW_H__CAA16AB2_CAD7_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMfcawexeView : public CView
{
protected: // create from serialization only
	CMfcawexeView();
	DECLARE_DYNCREATE(CMfcawexeView)

// Attributes
public:
	CMfcawexeDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawexeView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMfcawexeView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CMfcawexeView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in mfcawexeView.cpp
inline CMfcawexeDoc* CMfcawexeView::GetDocument()
   { return (CMfcawexeDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEXEVIEW_H__CAA16AB2_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\new\ChildFrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__CAA16AAE_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_CHILDFRM_H__CAA16AAE_CAD7_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#define XXXXTEST

class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__CAA16AAE_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\new\ChildFrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "mfcawexe.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
	int i = 5;
	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\new\MainFrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "mfcawexe.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	long l = 55555;

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\new\MainFrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__CAA16AAC_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MAINFRM_H__CAA16AAC_CAD7_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#define XXXXTEST

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__CAA16AAC_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\new\mfcawexeDoc.cpp ===
// mfcawexeDoc.cpp : implementation of the CMfcawexeDoc class
//

#include "stdafx.h"
#include "mfcawexe.h"

#include "mfcawexeDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeDoc

IMPLEMENT_DYNCREATE(CMfcawexeDoc, CDocument)

BEGIN_MESSAGE_MAP(CMfcawexeDoc, CDocument)
	//{{AFX_MSG_MAP(CMfcawexeDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeDoc construction/destruction

CMfcawexeDoc::CMfcawexeDoc()
{
	// TODO: add one-time construction code here

}

CMfcawexeDoc::~CMfcawexeDoc()
{
}

BOOL CMfcawexeDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)
	int i = 99;

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CMfcawexeDoc serialization

void CMfcawexeDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeDoc diagnostics

#ifdef _DEBUG
void CMfcawexeDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CMfcawexeDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\new\mfcawexe.h ===
// mfcawexe.h : main header file for the MFCAWEXE application
//

#if !defined(AFX_MFCAWEXE_H__CAA16AA8_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWEXE_H__CAA16AA8_CAD7_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif
#define XXXXTEST

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeApp:
// See mfcawexe.cpp for the implementation of this class
//

class CMfcawexeApp : public CWinApp
{
public:
	CMfcawexeApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawexeApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMfcawexeApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEXE_H__CAA16AA8_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\new\mfcawexe.cpp ===
// mfcawexe.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "mfcawexe.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "mfcawexeDoc.h"
#include "mfcawexeView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeApp

BEGIN_MESSAGE_MAP(CMfcawexeApp, CWinApp)
	//{{AFX_MSG_MAP(CMfcawexeApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeApp construction

CMfcawexeApp::CMfcawexeApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMfcawexeApp object

CMfcawexeApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeApp initialization

BOOL CMfcawexeApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_MFCAWETYPE,
		RUNTIME_CLASS(CMfcawexeDoc),
		RUNTIME_CLASS(CChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CMfcawexeView));
	AddDocTemplate(pDocTemplate);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

#ifndef XXXTEST
#define XXXTEST
#endif

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CMfcawexeApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeApp commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\new\mfcawexeDoc.h ===
// mfcawexeDoc.h : interface of the CMfcawexeDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MFCAWEXEDOC_H__CAA16AB0_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWEXEDOC_H__CAA16AB0_CAD7_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define XXXXTEST

class CMfcawexeDoc : public CDocument
{
protected: // create from serialization only
	CMfcawexeDoc();
	DECLARE_DYNCREATE(CMfcawexeDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawexeDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMfcawexeDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CMfcawexeDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEXEDOC_H__CAA16AB0_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\new\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mfcawexe.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_MFCAWETYPE                  129

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\new\mfcawexeView.cpp ===
// mfcawexeView.cpp : implementation of the CMfcawexeView class
//

#include "stdafx.h"
#include "mfcawexe.h"

#include "mfcawexeDoc.h"
#include "mfcawexeView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeView

IMPLEMENT_DYNCREATE(CMfcawexeView, CView)

BEGIN_MESSAGE_MAP(CMfcawexeView, CView)
	//{{AFX_MSG_MAP(CMfcawexeView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeView construction/destruction

CMfcawexeView::CMfcawexeView()
{
	// TODO: add construction code here

}

CMfcawexeView::~CMfcawexeView()
{
}

BOOL CMfcawexeView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeView drawing

void CMfcawexeView::OnDraw(CDC* pDC)
{
	CMfcawexeDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	for (int i = 9;	i < 99; i++ )
		i += 8;
	// TODO: add draw code for native data here
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeView printing

BOOL CMfcawexeView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CMfcawexeView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CMfcawexeView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeView diagnostics

#ifdef _DEBUG
void CMfcawexeView::AssertValid() const
{
	CView::AssertValid();
}

void CMfcawexeView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CMfcawexeDoc* CMfcawexeView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMfcawexeDoc)));
	return (CMfcawexeDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMfcawexeView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcawexe\new\mfcawexeView.h ===
// mfcawexeView.h : interface of the CMfcawexeView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MFCAWEXEVIEW_H__CAA16AB2_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAWEXEVIEW_H__CAA16AB2_CAD7_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#define XXXXTEST

class CMfcawexeView : public CView
{
protected: // create from serialization only
	CMfcawexeView();
	DECLARE_DYNCREATE(CMfcawexeView)

// Attributes
public:
	CMfcawexeDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcawexeView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMfcawexeView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CMfcawexeView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in mfcawexeView.cpp
inline CMfcawexeDoc* CMfcawexeView::GetDocument()
   { return (CMfcawexeDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAWEXEVIEW_H__CAA16AB2_CAD7_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\mfcaxcw.cpp ===
// mfcaxcw.cpp : Implementation of CMfcaxcwApp and DLL registration.

#include "stdafx.h"
#include "mfcaxcw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CMfcaxcwApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x7efbebf8, 0xcaa8, 0x11d0, { 0x84, 0xbf, 0, 0xaa, 0, 0xc0, 0x8, 0x48 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CMfcaxcwApp::InitInstance - DLL initialization

BOOL CMfcaxcwApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CMfcaxcwApp::ExitInstance - DLL termination

int CMfcaxcwApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\MfcaxcwCtl.cpp ===
// MfcaxcwCtl.cpp : Implementation of the CMfcaxcwCtrl ActiveX Control class.

#include "stdafx.h"
#include "mfcaxcw.h"
#include "MfcaxcwCtl.h"
#include "MfcaxcwPpg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMfcaxcwCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMfcaxcwCtrl, COleControl)
	//{{AFX_MSG_MAP(CMfcaxcwCtrl)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CMfcaxcwCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CMfcaxcwCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CMfcaxcwCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CMfcaxcwCtrl, COleControl)
	//{{AFX_EVENT_MAP(CMfcaxcwCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CMfcaxcwCtrl, 1)
	PROPPAGEID(CMfcaxcwPropPage::guid)
END_PROPPAGEIDS(CMfcaxcwCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMfcaxcwCtrl, "MFCAXCW.MfcaxcwCtrl.1",
	0x7efbebfb, 0xcaa8, 0x11d0, 0x84, 0xbf, 0, 0xaa, 0, 0xc0, 0x8, 0x48)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CMfcaxcwCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DMfcaxcw =
		{ 0x7efbebf9, 0xcaa8, 0x11d0, { 0x84, 0xbf, 0, 0xaa, 0, 0xc0, 0x8, 0x48 } };
const IID BASED_CODE IID_DMfcaxcwEvents =
		{ 0x7efbebfa, 0xcaa8, 0x11d0, { 0x84, 0xbf, 0, 0xaa, 0, 0xc0, 0x8, 0x48 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwMfcaxcwOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CMfcaxcwCtrl, IDS_MFCAXCW, _dwMfcaxcwOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::CMfcaxcwCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CMfcaxcwCtrl

BOOL CMfcaxcwCtrl::CMfcaxcwCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_MFCAXCW,
			IDB_MFCAXCW,
			afxRegApartmentThreading,
			_dwMfcaxcwOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::CMfcaxcwCtrl - Constructor

CMfcaxcwCtrl::CMfcaxcwCtrl()
{
	InitializeIIDs(&IID_DMfcaxcw, &IID_DMfcaxcwEvents);

	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::~CMfcaxcwCtrl - Destructor

CMfcaxcwCtrl::~CMfcaxcwCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::OnDraw - Drawing function

void CMfcaxcwCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	// TODO: Replace the following code with your own drawing code.
	pdc->FillRect(rcBounds, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
	pdc->Ellipse(rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::DoPropExchange - Persistence support

void CMfcaxcwCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::OnResetState - Reset control to default state

void CMfcaxcwCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::AboutBox - Display an "About" box to the user

void CMfcaxcwCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_MFCAXCW);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\mfcaxcw.h ===
#if !defined(AFX_MFCAXCW_H__7EFBEC01_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAXCW_H__7EFBEC01_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// mfcaxcw.h : main header file for MFCAXCW.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwApp : See mfcaxcw.cpp for implementation.

class CMfcaxcwApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAXCW_H__7EFBEC01_CAA8_11D0_84BF_00AA00C00848__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\MfcaxcwPpg.cpp ===
// MfcaxcwPpg.cpp : Implementation of the CMfcaxcwPropPage property page class.

#include "stdafx.h"
#include "mfcaxcw.h"
#include "MfcaxcwPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMfcaxcwPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMfcaxcwPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CMfcaxcwPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMfcaxcwPropPage, "MFCAXCW.MfcaxcwPropPage.1",
	0x7efbebfc, 0xcaa8, 0x11d0, 0x84, 0xbf, 0, 0xaa, 0, 0xc0, 0x8, 0x48)


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwPropPage::CMfcaxcwPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMfcaxcwPropPage

BOOL CMfcaxcwPropPage::CMfcaxcwPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_MFCAXCW_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwPropPage::CMfcaxcwPropPage - Constructor

CMfcaxcwPropPage::CMfcaxcwPropPage() :
	COlePropertyPage(IDD, IDS_MFCAXCW_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CMfcaxcwPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwPropPage::DoDataExchange - Moves data between page and properties

void CMfcaxcwPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CMfcaxcwPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\MfcaxcwCtl.h ===
#if !defined(AFX_MFCAXCWCTL_H__7EFBEC09_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAXCWCTL_H__7EFBEC09_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// MfcaxcwCtl.h : Declaration of the CMfcaxcwCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl : See MfcaxcwCtl.cpp for implementation.

class CMfcaxcwCtrl : public COleControl
{
	DECLARE_DYNCREATE(CMfcaxcwCtrl)

// Constructor
public:
	CMfcaxcwCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcaxcwCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CMfcaxcwCtrl();

	DECLARE_OLECREATE_EX(CMfcaxcwCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CMfcaxcwCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CMfcaxcwCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CMfcaxcwCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CMfcaxcwCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CMfcaxcwCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CMfcaxcwCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CMfcaxcwCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAXCWCTL_H__7EFBEC09_CAA8_11D0_84BF_00AA00C00848__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by mfcaxcw.rc
//

#define IDS_MFCAXCW               1
#define IDS_MFCAXCW_PPG           2

#define IDS_MFCAXCW_PPG_CAPTION   200

#define IDD_PROPPAGE_MFCAXCW      200

#define IDD_ABOUTBOX_MFCAXCW      1

#define IDB_MFCAXCW               1

#define IDI_ABOUTDLL				1

#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#define _APS_NEXT_COMMAND_VALUE         32768
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\MfcaxcwPpg.h ===
#if !defined(AFX_MFCAXCWPPG_H__7EFBEC0B_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAXCWPPG_H__7EFBEC0B_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// MfcaxcwPpg.h : Declaration of the CMfcaxcwPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMfcaxcwPropPage : See MfcaxcwPpg.cpp.cpp for implementation.

class CMfcaxcwPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CMfcaxcwPropPage)
	DECLARE_OLECREATE_EX(CMfcaxcwPropPage)

// Constructor
public:
	CMfcaxcwPropPage();

// Dialog Data
	//{{AFX_DATA(CMfcaxcwPropPage)
	enum { IDD = IDD_PROPPAGE_MFCAXCW };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CMfcaxcwPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAXCWPPG_H__7EFBEC0B_CAA8_11D0_84BF_00AA00C00848__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\StdAfx.h ===
#if !defined(AFX_STDAFX_H__7EFBEBFF_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_STDAFX_H__7EFBEBFF_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7EFBEBFF_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\new\mfcaxcw.h ===
#if !defined(AFX_MFCAXCW_H__7EFBEC01_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAXCW_H__7EFBEC01_CAA8_11D0_84BF_00AA00C00848__INCLUDED_
#define AXCW_______

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// mfcaxcw.h : main header file for MFCAXCW.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwApp : See mfcaxcw.cpp for implementation.

class CMfcaxcwApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAXCW_H__7EFBEC01_CAA8_11D0_84BF_00AA00C00848__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\new\MfcaxcwPpg.cpp ===
// MfcaxcwPpg.cpp : Implementation of the CMfcaxcwPropPage property page class.

#include "stdafx.h"
#include "mfcaxcw.h"
#include "MfcaxcwPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMfcaxcwPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMfcaxcwPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CMfcaxcwPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMfcaxcwPropPage, "MFCAXCW.MfcaxcwPropPage.1",
	0x7efbebfc, 0xcaa8, 0x11d0, 0x84, 0xbf, 0, 0xaa, 0, 0xc0, 0x8, 0x48)


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwPropPage::CMfcaxcwPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMfcaxcwPropPage

BOOL CMfcaxcwPropPage::CMfcaxcwPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_MFCAXCW_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwPropPage::CMfcaxcwPropPage - Constructor

CMfcaxcwPropPage::CMfcaxcwPropPage() :
	COlePropertyPage(IDD, IDS_MFCAXCW_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CMfcaxcwPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwPropPage::DoDataExchange - Moves data between page and properties

void CMfcaxcwPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CMfcaxcwPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
	int i = 5;
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\new\mfcaxcw.cpp ===
// mfcaxcw.cpp : Implementation of CMfcaxcwApp and DLL registration.

#include "stdafx.h"
#include "mfcaxcw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CMfcaxcwApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x7efbebf8, 0xcaa8, 0x11d0, { 0x84, 0xbf, 0, 0xaa, 0, 0xc0, 0x8, 0x48 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CMfcaxcwApp::InitInstance - DLL initialization

BOOL CMfcaxcwApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}
	int i = 3;
	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CMfcaxcwApp::ExitInstance - DLL termination

int CMfcaxcwApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\new\MfcaxcwPpg.h ===
#if !defined(AFX_MFCAXCWPPG_H__7EFBEC0B_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAXCWPPG_H__7EFBEC0B_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#define AXCW______

// MfcaxcwPpg.h : Declaration of the CMfcaxcwPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMfcaxcwPropPage : See MfcaxcwPpg.cpp.cpp for implementation.

class CMfcaxcwPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CMfcaxcwPropPage)
	DECLARE_OLECREATE_EX(CMfcaxcwPropPage)

// Constructor
public:
	CMfcaxcwPropPage();

// Dialog Data
	//{{AFX_DATA(CMfcaxcwPropPage)
	enum { IDD = IDD_PROPPAGE_MFCAXCW };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CMfcaxcwPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAXCWPPG_H__7EFBEC0B_CAA8_11D0_84BF_00AA00C00848__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\new\MfcaxcwCtl.h ===
#if !defined(AFX_MFCAXCWCTL_H__7EFBEC09_CAA8_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MFCAXCWCTL_H__7EFBEC09_CAA8_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#define AXCW______
// MfcaxcwCtl.h : Declaration of the CMfcaxcwCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl : See MfcaxcwCtl.cpp for implementation.

class CMfcaxcwCtrl : public COleControl
{
	DECLARE_DYNCREATE(CMfcaxcwCtrl)

// Constructor
public:
	CMfcaxcwCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcaxcwCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CMfcaxcwCtrl();

	DECLARE_OLECREATE_EX(CMfcaxcwCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CMfcaxcwCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CMfcaxcwCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CMfcaxcwCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CMfcaxcwCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CMfcaxcwCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CMfcaxcwCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CMfcaxcwCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCAXCWCTL_H__7EFBEC09_CAA8_11D0_84BF_00AA00C00848__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\new\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mfcaxcw.rc
//
#define IDS_MFCAXCW                     1
#define IDD_ABOUTBOX_MFCAXCW            1
#define IDB_MFCAXCW                     1
#define IDI_ABOUTDLL                    1
#define IDS_MFCAXCW_PPG                 2
#define IDS_MFCAXCW_PPG_CAPTION         200
#define IDD_PROPPAGE_MFCAXCW            200
#define IDD_DIALOG1                     201
#define IDD_DIALOG2                     202

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\stat_lib\stat_lib.cpp ===
#include "stat_lib.h"

class Inherited : public base1, public base2 
{
public:
	void Func2(void); // Implementation of above
	void Func1(void); // Implementation of above

private:
	int m_int; 
	void Helper(int); // Helper function for implementation
};

void Inherited::Func2 (void)
{
	int i = 2;
	m_int =3;
	Helper(i);
}

void Inherited::Func1 (void)
{
	int i = 0;	 
}

void Inherited::Helper(int par)
{
	par++;
}

Inherited inh2;

base2* func2()
{
	return (base2*)(&inh2);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\mfcaxcw\new\MfcaxcwCtl.cpp ===
// MfcaxcwCtl.cpp : Implementation of the CMfcaxcwCtrl ActiveX Control class.

#include "stdafx.h"
#include "mfcaxcw.h"
#include "MfcaxcwCtl.h"
#include "MfcaxcwPpg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMfcaxcwCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMfcaxcwCtrl, COleControl)
	//{{AFX_MSG_MAP(CMfcaxcwCtrl)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CMfcaxcwCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CMfcaxcwCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CMfcaxcwCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CMfcaxcwCtrl, COleControl)
	//{{AFX_EVENT_MAP(CMfcaxcwCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CMfcaxcwCtrl, 1)
	PROPPAGEID(CMfcaxcwPropPage::guid)
END_PROPPAGEIDS(CMfcaxcwCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMfcaxcwCtrl, "MFCAXCW.MfcaxcwCtrl.1",
	0x7efbebfb, 0xcaa8, 0x11d0, 0x84, 0xbf, 0, 0xaa, 0, 0xc0, 0x8, 0x48)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CMfcaxcwCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DMfcaxcw =
		{ 0x7efbebf9, 0xcaa8, 0x11d0, { 0x84, 0xbf, 0, 0xaa, 0, 0xc0, 0x8, 0x48 } };
const IID BASED_CODE IID_DMfcaxcwEvents =
		{ 0x7efbebfa, 0xcaa8, 0x11d0, { 0x84, 0xbf, 0, 0xaa, 0, 0xc0, 0x8, 0x48 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwMfcaxcwOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CMfcaxcwCtrl, IDS_MFCAXCW, _dwMfcaxcwOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::CMfcaxcwCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CMfcaxcwCtrl

BOOL CMfcaxcwCtrl::CMfcaxcwCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.
	int i = 6;
	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_MFCAXCW,
			IDB_MFCAXCW,
			afxRegApartmentThreading,
			_dwMfcaxcwOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::CMfcaxcwCtrl - Constructor

CMfcaxcwCtrl::CMfcaxcwCtrl()
{
	InitializeIIDs(&IID_DMfcaxcw, &IID_DMfcaxcwEvents);

	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::~CMfcaxcwCtrl - Destructor

CMfcaxcwCtrl::~CMfcaxcwCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::OnDraw - Drawing function

void CMfcaxcwCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	// TODO: Replace the following code with your own drawing code.
	pdc->FillRect(rcBounds, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
	pdc->Ellipse(rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::DoPropExchange - Persistence support

void CMfcaxcwCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::OnResetState - Reset control to default state

void CMfcaxcwCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl::AboutBox - Display an "About" box to the user

void CMfcaxcwCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_MFCAXCW);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CMfcaxcwCtrl message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\stat_lib\stat_lib.h ===
class base1
{
public:
	virtual void Func1() = 0;

};

class base2 
{
public:
	virtual void Func2() = 0;

};

base2* func2();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\Nothing.cpp ===
// Nothing.cpp : Defines the entry point for the dll application.
//

#include "Precomp.h"
#include "Nothing.h"
#include "shared.h"

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch( ul_reason_for_call ) 
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}


// This is an example of an exported variable
NOTHING_API int nNothing=0;

// This is an example of an exported function.
NOTHING_API int fnNothing(void)
{
	return 42;
}

// This is the constructor of a class that has been exported.
// see Nothing.h for the class definition
CNothing::CNothing()
{ 
	return; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\Nothing.h ===
#include "resource.h"


// The following ifdef block is the standard way of creating macros which make exporting 
// from a dll simpler. All files within this DLL are compiled with the NOTHING_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// NOTHING_API functions as being imported from a DLL, wheras this Dll sees symbols 
// defined with this macro as being exported.
#ifdef NOTHING_EXPORTS
#define NOTHING_API __declspec(dllexport)
#else
#define NOTHING_API __declspec(dllimport)
#endif

// This class is exported from the Nothing.dll
class NOTHING_API CNothing {
public:
	CNothing(void);
	// TODO: add your methods here.
};

extern NOTHING_API int nNothing;

NOTHING_API int fnNothing(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\Nothing2.cpp ===
#include "Precomp.h"

void Hi()
	{
	return;
	}

#include "Nothing.h"

void Bye()
	{
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\stat_lib\new\stat_lib.h ===
class base1
{
public:
	virtual void Func1() = 0;
	int Num;
};

class base2 
{
public:
	virtual void Func2() = 0;
	long LongNum;
};

base2* func2();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\This file has a really long name and I like that fact.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\stat_lib\new\stat_lib.cpp ===
#include "stat_lib.h"

class Inherited : public base1, public base2 
{
public:
	void Func2(void); // Implementation of above
	void Func1(void); // Implementation of above

private:
	int m_int; 
	void Helper(int); // Helper function for implementation
};

void Inherited::Func2 (void)
{
	int i = 2;
	m_int =3;
	Helper(i);
	Helper(m_int);
}

void Inherited::Func1 (void)
{
	int i = 0;	 
}

void Inherited::Helper(int par)
{
	par++;
}

Inherited inh2;

base2* func2()
{
	return (base2*)(&inh2);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\Nothing3.cpp ===
#include "Precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\Precomp.h ===
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Nothing.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\Worthless.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resource1.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\Useless.cpp ===
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Useless.cpp

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
#include "useless.h"
#include "shared.h"
#include "nothing.h"

void main()
	{
	// Do some useless stuff
	int i = 2;
	int j = 2;

	i += j;
	j += i;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F71F1092_1029_11D1_99B7_00AA0042FAF4__INCLUDED_)
#define AFX_STDAFX_H__F71F1092_1029_11D1_99B7_00AA0042FAF4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F71F1092_1029_11D1_99B7_00AA0042FAF4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\Useless.h ===
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Useless.h

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// A useless comment

// A useless variable
int k;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\Shared.h ===
// Shared.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\useless.c ===
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Useless.c

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
#include "useless.h"

void main()
	{
	int i = 0;
	int j = 1;

	i += j;
	j += i;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\Worthless.c ===
void DoNothing()
	{
	// This function does nothing
	}

void DoNothingEx()
	{
	// This function does nothing
	}

void DoNothingEx2()
	{
	// This function does nothing
	}

void DoNothingEx3()
	{
	// This function does nothing
	}

void DoNothingEx4()
	{
	// This function does nothing
	}

#include "worthless"

void DoNothingEx5()
	{
	// This function does nothing
	}

void DoNothingEx6()
	{
	// This function does nothing
	}

void DoNothingEx7()
	{
	// This function does nothing
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\Worthless2.h ===
#ifndef __WORTHLESS2_H__
#define __WORTHLESS2_H__

#include "worthless3.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\Worthless4.h ===
#ifndef __WORTHLESS4_H__
#define __WORTHLESS4_H__

#include "This is a header file"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\bin\src\useless\new\Worthless3.h ===
#ifndef __WORTHLESS3_H__
#define __WORTHLESS3_H__

#include "worthless4.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\build\bldatl.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BldATL.CPP
//
//	Created by :			Date :
//		YefimS					5/14/97
//
//	Description :
//		Implementation of the CBuildATLTest class

#include "stdafx.h"
#include "BldATL.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CBuildATLTest, CProjectTestSet, "Building ATL Projects", -1, CBuildSubSuite)

void CBuildATLTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CBuildATLTest

void CBuildATLTest::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( BuildATLCOMAppWizardDll() );
	XSAFETY;
	EXPECT_TRUE( BuildATLCOMAppWizardExe() );
	XSAFETY;
	EXPECT_TRUE( BuildATLCOMAppWizardService() );
	XSAFETY;

}


BOOL CBuildATLTest::BuildATLCOMAppWizardExe( void )
{
	LogTestHeader("BuildATLCOMAppWizardExe");

	m_strProjName = "atlcomex";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	CString szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	CString szBasePathName = m_strProjLoc + m_strProjName;
	CString szNewBasePathName = szNewSRCFileLoc + m_strProjName;

	RemoveTestFiles( m_strProjLoc );

	CreateDirectory(m_strProjLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAgainAndVerify");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Change resources and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".rc", szNewBasePathName + ".rc", GetLocString(IDSS_OUTPUTWIN_RC_COMPILING)));

	LogSubTestHeader("Change source files and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".h", szNewBasePathName + ".h", m_strProjName + ".cpp"));
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".cpp", szNewBasePathName + ".cpp", m_strProjName + ".cpp"));

	LogSubTestHeader("ReBuildProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.RebuildAll(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Build Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Change idl file and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".idl", szNewBasePathName + ".idl", m_strProjName + ".idl"));

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}

BOOL CBuildATLTest::BuildATLCOMAppWizardDll( void )
{
	LogTestHeader("BuildATLCOMAppWizardDll");

	m_strProjName = "atlcomaw";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	CString szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	CString szBasePathName = m_strProjLoc + m_strProjName;
	CString szNewBasePathName = szNewSRCFileLoc + m_strProjName;

	RemoveTestFiles( m_strProjLoc );

	CreateDirectory(m_strProjLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAgainAndVerify");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Change def file and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".def", szNewBasePathName + ".def", GetLocString(IDSS_OUTPUTWIN_LINKING)));
	EXPECT_TRUE( VerifyBuildString( GetLocString(IDSS_OUTPUTWIN_COMPILING), FALSE ) < 0 );

	LogSubTestHeader("Build Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Change resources and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".rc", szNewBasePathName + ".rc", GetLocString(IDSS_OUTPUTWIN_RC_COMPILING)));

	LogSubTestHeader("Change source files and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".h", szNewBasePathName + ".h", m_strProjName + ".cpp"));
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".cpp", szNewBasePathName + ".cpp", m_strProjName + ".cpp"));

	LogSubTestHeader("ReBuildProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.RebuildAll(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Change idl file and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".idl", szNewBasePathName + ".idl", m_strProjName + ".idl"));
	EXPECT_TRUE( VerifyBuildString( "Registering") > 0 );

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}

BOOL CBuildATLTest::BuildATLCOMAppWizardService( void )
{
	LogTestHeader("BuildATLCOMAppWizardService");

	m_strProjName = "atlservi";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	CString szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	CString szBasePathName = m_strProjLoc + m_strProjName;
	CString szNewBasePathName = szNewSRCFileLoc + m_strProjName;

	RemoveTestFiles( m_strProjLoc );

	CreateDirectory(m_strProjLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAgainAndVerify");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Build Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Change resources and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".rc", szNewBasePathName + ".rc", GetLocString(IDSS_OUTPUTWIN_RC_COMPILING)));

	LogSubTestHeader("Change source file and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".cpp", szNewBasePathName + ".cpp", m_strProjName + ".cpp"));

	LogSubTestHeader("ReBuildProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.RebuildAll(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Change idl file and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".idl", szNewBasePathName + ".idl", m_strProjName + ".idl"));

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\build\bldatl.h ===
///////////////////////////////////////////////////////////////////////////////
//	bldatl.H
//
//	Created by :			Date :
//		YefimS					5/12/97
//
//	Description :
//		Declaration of the CBuildATLTest class

#ifndef __bldatl_H__
#define __bldatl_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "buildsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CBuildATLTest class

class CBuildATLTest : public CProjectTestSet
{
	DECLARE_TEST(CBuildATLTest, CBuildSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL BuildATLCOMAppWizardDll();
	BOOL BuildATLCOMAppWizardExe();
	BOOL BuildATLCOMAppWizardService();

// Utilities

};

#endif //__bldatl_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\build\bldmisc.h ===
///////////////////////////////////////////////////////////////////////////////
//	bldwin32.H
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Declaration of the CBuildWin32Test class

#ifndef __bldmisc_H__
#define __bldmisc_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "buildsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CBuildMiscTest class

class CBuildMiscTest : public CProjectTestSet
{
	DECLARE_TEST(CBuildMiscTest, CBuildSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:
//	BOOL RunAsDependent(void);
//	BOOL CloseProject( void );

// Test Cases
protected:
	BOOL CreateAndBuildMakefile();
	BOOL BuildISAPIExtensionWizard();

// Utilities

};

#endif //__bldwin32_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\build\bldmfc.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BldWin32.CPP
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Implementation of the CBuildMFCTest class

#include "stdafx.h"
#include "BldMFC.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CBuildMFCTest, CProjectTestSet, "Building MFC Projects", -1, CBuildSubSuite)

void CBuildMFCTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CBuildMFCTest

void CBuildMFCTest::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( BuildMFCAppWizardExe() );
	XSAFETY;
	EXPECT_TRUE( BuildMFCAppWizardDll() );
	XSAFETY;
	EXPECT_TRUE( BuildMFCActiveXControlWizard() );
	XSAFETY;
	EXPECT_TRUE( BuildMFCAppWizardExeCSHelp());
	XSAFETY;
	EXPECT_TRUE( BuildMFCAppWizardExeStaticMFC());
	XSAFETY;

}


BOOL CBuildMFCTest::BuildMFCAppWizardExe( void )
{
	LogTestHeader("BuildMFCAppWizardExe");

	m_strProjName = "mfcawexe";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szProjResLoc	= m_strProjLoc + "res\\";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	CString szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	CString szResFileLoc	= szSRCFileLoc + "res\\";
	CString szNewResFileLoc	= szNewSRCFileLoc + "res\\";
	CString szBasePathName = m_strProjLoc + m_strProjName;
	CString szNewBasePathName = szNewSRCFileLoc + m_strProjName;
	CString szAppFile = szBasePathName + ".cpp";
	CString szNewFile = szNewBasePathName + ".cpp";

	RemoveTestFiles( szProjResLoc );
	RemoveTestFiles( m_strProjLoc );

	CreateDirectory(m_strProjLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );
	CreateDirectory(szProjResLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szResFileLoc, szProjResLoc ) );

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAgainAndVerify");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Change resources and build the project");
	EXPECT_TRUE( CopyProjectSources( szNewResFileLoc, szProjResLoc ) );
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".rc", szNewBasePathName + ".rc", GetLocString(IDSS_OUTPUTWIN_RC_COMPILING)));

	LogSubTestHeader("Build Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("ReBuildProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.RebuildAll(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Change source files and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szAppFile, szNewFile, m_strProjName + ".cpp"));
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".h", szNewBasePathName + ".h", m_strProjName + ".cpp"));
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + "Doc.cpp", szNewBasePathName + "Doc.cpp", m_strProjName + "Doc.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + "View.cpp", szNewBasePathName + "View.cpp", m_strProjName + "View.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + "Doc.h", szNewBasePathName + "Doc.h", m_strProjName + "Doc.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + "View.h", szNewBasePathName + "View.h", m_strProjName + "View.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(m_strProjLoc + "ChildFrm.h", szNewSRCFileLoc + "ChildFrm.h", "ChildFrm.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(m_strProjLoc + "ChildFrm.cpp", szNewSRCFileLoc + "ChildFrm.cpp", "ChildFrm.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(m_strProjLoc + "MainFrm.h", szNewSRCFileLoc + "MainFrm.h", "MainFrm.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(m_strProjLoc + "MainFrm.cpp", szNewSRCFileLoc + "MainFrm.cpp", "MainFrm.cpp"));

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}

BOOL CBuildMFCTest::BuildMFCAppWizardDll( void )
{
	LogTestHeader("BuildMFCAppWizardDll");

	m_strProjName = "mfcawdll";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szProjResLoc	= m_strProjLoc + "res\\";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	CString szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	CString szResFileLoc	= szSRCFileLoc + "res\\";
	CString szNewResFileLoc	= szNewSRCFileLoc + "res\\";
	CString szBasePathName = m_strProjLoc + m_strProjName;
	CString szNewBasePathName = szNewSRCFileLoc + m_strProjName;
	CString szAppFile = szBasePathName + ".cpp";
	CString szNewFile = szNewBasePathName + ".cpp";

	RemoveTestFiles( szProjResLoc );
	RemoveTestFiles( m_strProjLoc );

	CreateDirectory(m_strProjLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );
	CreateDirectory(szProjResLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szResFileLoc, szProjResLoc ) );

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAgainAndVerify");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Switch to Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Change def file and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".def", szNewBasePathName + ".def", GetLocString(IDSS_OUTPUTWIN_LINKING)));
	EXPECT_TRUE( VerifyBuildString( GetLocString(IDSS_OUTPUTWIN_COMPILING), FALSE ) < 0 );

	LogSubTestHeader("Change resources and build the project");
	EXPECT_TRUE( CopyProjectSources( szNewResFileLoc, szProjResLoc ) );
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".rc", szNewBasePathName + ".rc", GetLocString(IDSS_OUTPUTWIN_RC_COMPILING)));

	LogSubTestHeader("Change source files and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".h", szNewBasePathName + ".h", m_strProjName + ".cpp"));
	EXPECT_TRUE( UpdateBuildVerify(szAppFile, szNewFile, m_strProjName + ".cpp"));

	LogSubTestHeader("ReBuildProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.RebuildAll(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}

BOOL CBuildMFCTest::BuildMFCActiveXControlWizard( void )
{
	LogTestHeader("BuildMFCActiveXControlWizard");
	m_strProjName = "mfcaxcw";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	CString szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	CString szBasePathName = m_strProjLoc + m_strProjName;
	CString szNewBasePathName = szNewSRCFileLoc + m_strProjName;
	CString szAppFile = szBasePathName + ".cpp";
	CString szNewFile = szNewBasePathName + ".cpp";

	RemoveTestFiles( m_strProjLoc );

	CreateDirectory(m_strProjLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );
	EXPECT_TRUE( VerifyBuildString( "Registering") > 0 );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAgainAndVerify");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Change source files and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + "Ctl.h", szNewBasePathName + "Ctl.h", m_strProjName + "Ctl.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + "Ppg.h", szNewBasePathName + "Ppg.h", m_strProjName + "Ppg.cpp"));

	LogSubTestHeader("Change resources and build the project");
	szNewFile = szNewBasePathName + ".ico";
	CString szCurrentFile = szBasePathName + ".ico";
	CopyFile(szNewFile, szCurrentFile, FALSE);
	SetFileAttributes(szCurrentFile, FILE_ATTRIBUTE_NORMAL ); 
	TouchFile( szCurrentFile );
	szNewFile = szNewBasePathName + "Ctl.bmp";
	szCurrentFile = szBasePathName + "Ctl.bmp";
	CopyFile(szNewFile, szCurrentFile, FALSE);
	SetFileAttributes(szCurrentFile, FILE_ATTRIBUTE_NORMAL ); 
	TouchFile( szCurrentFile );
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".rc", szNewBasePathName + ".rc", GetLocString(IDSS_OUTPUTWIN_RC_COMPILING)));
	EXPECT_TRUE( VerifyBuildString( "Registering") > 0 );

	LogSubTestHeader("Change source files and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".h", szNewBasePathName + ".h", m_strProjName + ".cpp"));

	LogSubTestHeader("Change odl file and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".odl", szNewBasePathName + ".odl", m_strProjName + ".odl"));
	EXPECT_TRUE( VerifyBuildString( "Registering") > 0 );

	LogSubTestHeader("Change def file and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".def", szNewBasePathName + ".def", GetLocString(IDSS_OUTPUTWIN_LINKING)));
	EXPECT_TRUE( VerifyBuildString( GetLocString(IDSS_OUTPUTWIN_COMPILING), FALSE ) < 0 );
	EXPECT_TRUE( VerifyBuildString( "Registering") > 0 );

	LogSubTestHeader("Switch to Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("ReBuildProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.RebuildAll(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );
	EXPECT_TRUE( VerifyBuildString( "Registering") > 0 );

	LogSubTestHeader("Change source files and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + "Ctl.cpp", szNewBasePathName + "Ctl.cpp", m_strProjName + "Ctl.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + "Ppg.cpp", szNewBasePathName + "Ppg.cpp", m_strProjName + "Ppg.cpp"));

	szNewFile = szNewBasePathName + ".cpp";
	LogSubTestHeader("Change source files and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szAppFile, szNewFile, m_strProjName + ".cpp"));

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}

BOOL CBuildMFCTest::BuildMFCAppWizardExeCSHelp( void )
{
	LogTestHeader("BuildMFCAppWizardExeCSHelp");

	m_strProjName = "mfcawex2";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szProjResLoc	= m_strProjLoc + "res\\";
	CString szProjHelpLoc	= m_strProjLoc + "hlp\\";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	CString szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	CString szResFileLoc	= szSRCFileLoc + "res\\";
	CString szNewResFileLoc	= szNewSRCFileLoc + "res\\";
	CString szHelpFileLoc	= szSRCFileLoc + "hlp\\";
	CString szNewHelpFileLoc	= szNewSRCFileLoc + "hlp\\";
	CString szBasePathName = m_strProjLoc + m_strProjName;
	CString szNewBasePathName = szNewSRCFileLoc + m_strProjName;
	CString szAppFile = szBasePathName + ".cpp";
	CString szNewFile = szNewBasePathName + ".cpp";

	RemoveTestFiles( szProjResLoc );
	RemoveTestFiles( szProjHelpLoc );
	RemoveTestFiles( m_strProjLoc );

	CreateDirectory(m_strProjLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );
	CreateDirectory(szProjResLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szResFileLoc, szProjResLoc ) );
	CreateDirectory(szProjHelpLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szHelpFileLoc, szProjHelpLoc ) );

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );
	EXPECT_TRUE( VerifyBuildString( "Making help file") > 0 );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAgainAndVerify");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Change resources and build the project");
	EXPECT_TRUE( CopyProjectSources( szNewResFileLoc, szProjResLoc ) );
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".rc", szNewBasePathName + ".rc", GetLocString(IDSS_OUTPUTWIN_RC_COMPILING)));

	LogSubTestHeader("Build Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );
	EXPECT_TRUE( VerifyBuildString( "Making help file") > 0 );

	LogSubTestHeader("ReBuildProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.RebuildAll(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );
	EXPECT_TRUE( VerifyBuildString( "Making help file") > 0 );

	LogSubTestHeader("Change source files and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".h", szNewBasePathName + ".h", m_strProjName + ".cpp"));
	EXPECT_TRUE( UpdateBuildVerify(m_strProjLoc + "CntrItem.cpp", szNewSRCFileLoc + "CntrItem.cpp", "CntrItem.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(m_strProjLoc + "SrvrItem.h", szNewSRCFileLoc + "SrvrItem.h", "SrvrItem.cpp"));

	EXPECT_TRUE( UpdateBuildVerify(m_strProjLoc + "IpFrame.cpp", szNewSRCFileLoc + "IpFrame.cpp", "IpFrame.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(m_strProjLoc + "CntrItem.h", szNewSRCFileLoc + "CntrItem.h", "CntrItem.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + "Doc.h", szNewBasePathName + "Doc.h", m_strProjName + "Doc.cpp"));

	LogSubTestHeader("Change help files and build the project");
	EXPECT_TRUE( CopyProjectSources( szNewHelpFileLoc, szProjHelpLoc ) );
	CString szCurrentFile = szProjHelpLoc + m_strProjName + ".hpj";
	SetFileAttributes(szCurrentFile, FILE_ATTRIBUTE_NORMAL ); 
	TouchFile( szCurrentFile );
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildString( "Making help file") > 0 );

	LogSubTestHeader("Change source files and build the project");
	EXPECT_TRUE( UpdateBuildVerify(m_strProjLoc + "ChildFrm.cpp", szNewSRCFileLoc + "ChildFrm.cpp", "ChildFrm.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(m_strProjLoc + "SrvrItem.cpp", szNewSRCFileLoc + "SrvrItem.cpp", "SrvrItem.cpp"));

	EXPECT_TRUE( UpdateBuildVerify(m_strProjLoc + "IpFrame.h", szNewSRCFileLoc + "IpFrame.h", "IpFrame.cpp"));

	LogSubTestHeader("Change odl file and build the project");
	szNewFile = szNewBasePathName + ".odl";
	szCurrentFile = szBasePathName + ".odl";
	CopyFile(szNewFile, szCurrentFile, FALSE);
	SetFileAttributes(szCurrentFile, FILE_ATTRIBUTE_NORMAL ); 
	TouchFile( szCurrentFile );
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildString( GetLocString(IDSS_OUTPUTWIN_CREATING_LIB)) > 0 );

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}

BOOL CBuildMFCTest::BuildMFCAppWizardExeStaticMFC( void )
{
	LogTestHeader("BuildMFCAppWizardExeStaticMFC");

	m_strProjName = "mfcawex3";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szProjResLoc	= m_strProjLoc + "res\\";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	CString szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	CString szResFileLoc	= szSRCFileLoc + "res\\";
	CString szNewResFileLoc	= szNewSRCFileLoc + "res\\";
	CString szBasePathName = m_strProjLoc + m_strProjName;
	CString szNewBasePathName = szNewSRCFileLoc + m_strProjName;
	CString szAppFile = szBasePathName + ".cpp";
	CString szNewFile = szNewBasePathName + ".cpp";

	RemoveTestFiles( szProjResLoc );
	RemoveTestFiles( m_strProjLoc );

	CreateDirectory(m_strProjLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );
	CreateDirectory(szProjResLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szResFileLoc, szProjResLoc ) );

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAgainAndVerify");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Build Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("ReBuildProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.RebuildAll(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Change source files and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".h", szNewBasePathName + ".h", m_strProjName + ".cpp"));
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + "Dlg.cpp", szNewBasePathName + "Dlg.cpp", m_strProjName + "Dlg.cpp"));

	LogSubTestHeader("Change resources and build the project");
	EXPECT_TRUE( CopyProjectSources( szNewResFileLoc, szProjResLoc ) );
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".rc", szNewBasePathName + ".rc", GetLocString(IDSS_OUTPUTWIN_RC_COMPILING)));

	LogSubTestHeader("Change source files and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + "Dlg.h", szNewBasePathName + "Dlg.h", m_strProjName + "Dlg.cpp"));
	EXPECT_TRUE( UpdateBuildVerify(szAppFile, szNewFile, m_strProjName + ".cpp"));

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\build\bldmisc.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BldWin32.CPP
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Implementation of the CBuildMiscTest class

#include "stdafx.h"
#include "BldMisc.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CBuildMiscTest, CProjectTestSet, "Building Miscellaneous Projects", -1, CBuildSubSuite)

void CBuildMiscTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CBuildMiscTest

void CBuildMiscTest::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( CreateAndBuildMakefile() );
	XSAFETY;
	EXPECT_TRUE( BuildISAPIExtensionWizard() );
	XSAFETY;

}


BOOL CBuildMiscTest::CreateAndBuildMakefile( void )
{
	LogTestHeader("CreateAndBuildMakefile");

	m_strProjName = "mkfile01";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";

	RemoveTestFiles( m_strProjLoc );

	LogSubTestHeader("Creating a Makefile project");
	if (!(VERIFY_TEST_SUCCESS( prj.NewProject( UIAW_PT_MAKEFILE, m_strProjName, m_strProjLoc, PLATFORMS)) 
		  && VERIFY_TEST_SUCCESS( prj.SetBuildCommand("echo Build makefile project") )))
	{
 		m_pLog->RecordFailure("Could not create project");
		return FALSE;
	}

	LogSubTestHeader("BuildProject");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildString( "Build makefile project") > 0 );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)));

	LogSubTestHeader("BuildProjectAgain");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildString( "Build makefile project") > 0 );

	LogSubTestHeader("Change the command line and build the project");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.SetBuildCommand("echo Build makefile project second time") ));
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildString( "Build makefile project second time") > 0 );

	LogSubTestHeader("ReBuildProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.RebuildAll(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildString( "Build makefile project") > 0 );

	LogSubTestHeader("Build Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.SetBuildCommand("echo Build makefile project release") ));
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildString( "Build makefile project release") > 0 );

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}


BOOL CBuildMiscTest::BuildISAPIExtensionWizard( void )
{
	LogTestHeader("BuildISAPIExtensionWizard");

	m_strProjName = "isapiew";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	CString szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	CString szBasePathName = m_strProjLoc + m_strProjName;
	CString szNewBasePathName = szNewSRCFileLoc + m_strProjName;
	CString szNewFile = szNewBasePathName + ".cpp";

	RemoveTestFiles( m_strProjLoc );

	CreateDirectory(m_strProjLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAgainAndVerify");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Change header and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".h", szNewBasePathName + ".h", m_strProjName + ".cpp"));

	LogSubTestHeader("Change resources and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".rc", szNewBasePathName + ".rc", GetLocString(IDSS_OUTPUTWIN_RC_COMPILING)));

	LogSubTestHeader("Change source file and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".cpp", szNewBasePathName + ".cpp", m_strProjName + ".cpp"));

	LogSubTestHeader("Change def file and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szBasePathName + ".def", szNewBasePathName + ".def", GetLocString(IDSS_OUTPUTWIN_LINKING)));
	EXPECT_TRUE( VerifyBuildString( GetLocString(IDSS_OUTPUTWIN_COMPILING), FALSE ) < 0 );

	LogSubTestHeader("ReBuildProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.RebuildAll(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Build Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\build\bldmfc.h ===
///////////////////////////////////////////////////////////////////////////////
//	bldmfc.H
//
//	Created by :			Date :
//		YefimS					5/12/97
//
//	Description :
//		Declaration of the CBuildMFCTest class

#ifndef __bldmfc_H__
#define __bldmfc_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "buildsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CBuildMFCTest class

class CBuildMFCTest : public CProjectTestSet
{
	DECLARE_TEST(CBuildMFCTest, CBuildSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL BuildMFCAppWizardExe();
	BOOL BuildMFCAppWizardDll();
	BOOL BuildMFCActiveXControlWizard();
	BOOL BuildMFCAppWizardExeCSHelp();
	BOOL BuildMFCAppWizardExeStaticMFC();

// Utilities

};

#endif //__bldmfc_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\build\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\build\bldwin32.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BldWin32.CPP
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Implementation of the CBuildWin32Test class

#include "stdafx.h"
#include "BldWin32.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CBuildWin32Test, CProjectTestSet, "Building Win32 Projects", -1, CBuildSubSuite)

// Global variables
static CString cstrRelease  =  GetLocString(IDSS_BUILD_RELEASE);
static CString cstrDebug  =  GetLocString(IDSS_BUILD_DEBUG);
CString RELEASETARGET = " - Win32 " + cstrRelease;
CString DEBUGTARGET = " - Win32 " + cstrDebug;
/*
BOOL CBuildWin32Test::RunAsDependent(void)
{
	// name of the project file
	CString strProjFile = m_strCWD + PROJNAME + "\\" + PROJMAKFILE;

	// if the project file exists, there's no need to run this test as a dependency
	if (_access(strProjFile, 0) != -1) {
		return FALSE;
	}
	else {
		return TRUE;
	}
}
*/
void CBuildWin32Test::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CBuildWin32Test

void CBuildWin32Test::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( CreateAndBuildWin32App() );
	XSAFETY;
	EXPECT_TRUE( CreateAndBuildConsoleApp() );
	XSAFETY;
	EXPECT_TRUE( CreateAndBuildWin32Dll() );
	XSAFETY;
	EXPECT_TRUE( CreateAndBuildWin32StaticLib() );
	XSAFETY;

}

BOOL CBuildWin32Test::CreateAndBuildWin32App( void )
{
	LogTestHeader("CreateAndBuildWin32App");

	m_strProjName = "Hello";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szCPPFiles	= m_strProjLoc + "*.cpp";
	CString szRCFiles	= m_strProjLoc + "*.rc";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	CString szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	CString szAppFile = m_strProjLoc + m_strProjName + ".cpp";
	CString szNewFile = szNewSRCFileLoc + m_strProjName + ".cpp";

	RemoveTestFiles( m_strProjLoc );

	LogSubTestHeader("Creating a Win32 Application project");
	if (!VERIFY_TEST_SUCCESS( prj.NewProject( EXE, m_strProjName, m_strProjLoc, PLATFORMS)))
	{
 		m_pLog->RecordFailure("Could not create an Application project");
		return FALSE;
	}

	LogSubTestHeader("Insert files into the project");
	
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );
	// Add source files files
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.AddFiles( szCPPFiles, m_strProjName )));
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.AddFiles( szRCFiles, m_strProjName )));

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAgainAndVerify");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("ChangeProjectFiles");
	EXPECT_TRUE( UpdateBuildVerify(szAppFile, szNewFile, m_strProjName + ".cpp"));

	LogSubTestHeader("Switch to Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}

BOOL CBuildWin32Test::CreateAndBuildConsoleApp( void )
{
	LogTestHeader("CreateAndBuildConsoleApp using .c files and nested headers");

	m_strProjName = "consol";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szCFiles	= m_strProjLoc + "*.c";
	CString szHeaderFiles	= m_strProjLoc + "*.h";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	CString szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	CString szAppFile = m_strProjLoc + m_strProjName + ".c";
	CString szNewFile = szNewSRCFileLoc + m_strProjName + ".c";
	CString szHeader = m_strProjLoc + m_strProjName + ".h";
	CString szNewHeader = szNewSRCFileLoc + m_strProjName + ".h";
	CString szHeader2 = m_strProjLoc + m_strProjName + "2.h";
	CString szNewHeader2 = szNewSRCFileLoc + m_strProjName + "2.h";

	RemoveTestFiles( m_strProjLoc );

	LogSubTestHeader("Creating a Win32 Console Application project");
	if (!VERIFY_TEST_SUCCESS( prj.NewProject( CONSOLE_APP, m_strProjName, m_strProjLoc, PLATFORMS)))
	{
 		m_pLog->RecordFailure("Could not create an Application project");
		return FALSE;
	}

	LogSubTestHeader("Insert files into the project");
	
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );

	// Add source files	and headers
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.AddFiles( szCFiles, m_strProjName )));
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.AddFiles( szHeaderFiles, m_strProjName )));

	LogSubTestHeader("BuildProjectAndVerify");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Switch to Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	if (!VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)))
	{
		m_pLog->RecordFailure("Could not open the project");
		return FALSE;
	}

	LogSubTestHeader("BuildProjectAgainAndVerify");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Switch to Debug target");
	prj.SetTarget(m_strProjName + DEBUGTARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Change header and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szHeader, szNewHeader, m_strProjName + ".c"));

	LogSubTestHeader("Change source: .c and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szAppFile, szNewFile, m_strProjName + ".c"));

	LogSubTestHeader("Change nested header and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szHeader2, szNewHeader2, m_strProjName + ".c"));

	LogSubTestHeader("Switch to Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}


BOOL CBuildWin32Test::CreateAndBuildWin32Dll( void )
{
	LogTestHeader("CreateAndBuildWin32Dll");

	m_strProjName = "a_dll";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szCPPFiles	= m_strProjLoc + "*.cpp";
	CString szHeaderFiles	= m_strProjLoc + "*.h";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	CString szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	CString szAppFile = m_strProjLoc + m_strProjName + ".cpp";
	CString szNewFile = szNewSRCFileLoc + m_strProjName + ".cpp";
	CString szHeader = m_strProjLoc + m_strProjName + ".h";
	CString szNewHeader = szNewSRCFileLoc + m_strProjName + ".h";

	RemoveTestFiles( m_strProjLoc );

	LogSubTestHeader("Creating a Win32 Dll project");
	if (!VERIFY_TEST_SUCCESS( prj.NewProject( DLL, m_strProjName, m_strProjLoc, PLATFORMS)))
	{
 		m_pLog->RecordFailure("Could not create an Application project");
		return FALSE;
	}

	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );

	LogSubTestHeader("Insert files into the project");
	// Add source files and headers
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.AddFiles( szCPPFiles, m_strProjName )));
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.AddFiles( szHeaderFiles, m_strProjName )));

	LogSubTestHeader("BuildProject");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)));

	LogSubTestHeader("BuildProjectAgain");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Change source: .cpp and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szAppFile, szNewFile, m_strProjName + ".cpp"));

	LogSubTestHeader("Switch to Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Change header and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szHeader, szNewHeader, m_strProjName + ".cpp"));

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));


	// Dll with def file and DllMain
	m_strProjName = "b_dll";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szCFiles	= m_strProjLoc + "*.c";
	szHeaderFiles	= m_strProjLoc + "*.h";
	CString szDefFiles	= m_strProjLoc + "*.def";
	szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	szAppFile = m_strProjLoc + m_strProjName + ".c";
	szNewFile = szNewSRCFileLoc + m_strProjName + ".c";
	szHeader = m_strProjLoc + m_strProjName + ".h";
	szNewHeader = szNewSRCFileLoc + m_strProjName + ".h";
	CString szDefFile = m_strProjLoc + m_strProjName + ".def";
	CString szNewDefFile = szNewSRCFileLoc + m_strProjName + ".def";

	RemoveTestFiles( m_strProjLoc );

	LogSubTestHeader("Creating a Win32 Dll project with def file");
	if (!VERIFY_TEST_SUCCESS( prj.NewProject( DLL, m_strProjName, m_strProjLoc, PLATFORMS)))
	{
 		m_pLog->RecordFailure("Could not create an Application project");
		return FALSE;
	}

	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );

	LogSubTestHeader("Insert files into the project");
	// Add source files, def files and headers
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.AddFiles( szCFiles, m_strProjName )));
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.AddFiles( szHeaderFiles, m_strProjName )));
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.AddFiles( szDefFiles, m_strProjName )));

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("BuildProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)));

	LogSubTestHeader("BuildProjectAgain");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Switch to Release target");
	prj.SetTarget(m_strProjName + RELEASETARGET);
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );

	LogSubTestHeader("Change source: .c and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szAppFile, szNewFile, m_strProjName + ".c"));

	LogSubTestHeader("Change header and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szHeader, szNewHeader, m_strProjName + ".c"));

	LogSubTestHeader("Change def file and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szDefFile, szNewDefFile, GetLocString(IDSS_OUTPUTWIN_LINKING)));
	EXPECT_TRUE( VerifyBuildString( GetLocString(IDSS_OUTPUTWIN_COMPILING), FALSE ) < 0 );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}

BOOL CBuildWin32Test::CreateAndBuildWin32StaticLib( void )
{
	LogTestHeader("CreateAndBuildWin32StaticLib");

	m_strProjName = "stat_lib";	//ToDo: We should get the name from file with all languages strings
	m_strProjLoc  = m_strCWD + "apps\\" + m_strProjName + "\\";
	CString szCPPFiles	= m_strProjLoc + "*.cpp";
	CString szHeaderFiles	= m_strProjLoc + "*.h";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strProjName + "\\";
	CString szNewSRCFileLoc	= szSRCFileLoc + "new\\";
	CString szAppFile = m_strProjLoc + m_strProjName + ".cpp";
	CString szNewFile = szNewSRCFileLoc + m_strProjName + ".cpp";
	CString szHeader = m_strProjLoc + m_strProjName + ".h";
	CString szNewHeader = szNewSRCFileLoc + m_strProjName + ".h";

	RemoveTestFiles( m_strProjLoc );

	LogSubTestHeader("Creating a Win32 Static Library project");
	if (!VERIFY_TEST_SUCCESS( prj.NewProject( STATIC_LIBRARY, m_strProjName, m_strProjLoc, PLATFORMS)))
	{
 		m_pLog->RecordFailure("Could not create project");
		return FALSE;
	}

	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjLoc ) );

	LogSubTestHeader("Insert files into the project");
	// Add source files and headers
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.AddFiles( szCPPFiles, m_strProjName )));
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.AddFiles( szHeaderFiles, m_strProjName )));

	LogSubTestHeader("BuildProject");
	int iWaitForBuild = 3;	// Minutes to wait for the build to complete
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );
	EXPECT_TRUE( VerifyBuildString( GetLocString(IDSS_OUTPUTWIN_LINKING), FALSE ) < 0 );

 	LogSubTestHeader("SaveProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Save()));

	LogSubTestHeader("Close Project");
	BOOL bSaveProjBeforeClose = FALSE; 
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	LogSubTestHeader("Open Project");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Open(m_strProjLoc + m_strProjName)));

	LogSubTestHeader("BuildProjectAgain");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( FALSE ) );

	LogSubTestHeader("Change header and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szHeader, szNewHeader, m_strProjName + ".cpp"));
	EXPECT_TRUE( VerifyBuildString( GetLocString(IDSS_OUTPUTWIN_LINKING), FALSE ) < 0 );

	LogSubTestHeader("Change source: .cpp and build the project");
	EXPECT_TRUE( UpdateBuildVerify(szAppFile, szNewFile, m_strProjName + ".cpp"));
	EXPECT_TRUE( VerifyBuildString( GetLocString(IDSS_OUTPUTWIN_LINKING), FALSE ) < 0 );

	LogSubTestHeader("ReBuildProject");
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.RebuildAll(iWaitForBuild)));
	EXPECT_TRUE( VerifyBuildOccured( TRUE ) );
	EXPECT_TRUE( VerifyBuildString( GetLocString(IDSS_OUTPUTWIN_LINKING), FALSE ) < 0 );

	LogSubTestHeader("Close And Save");
	bSaveProjBeforeClose = TRUE; 
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose)));

	RemoveTestFiles( m_strProjLoc );
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\build\buildsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	buildsub.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CBuildSubSuite class
//

#include "stdafx.h"
#include "buildsub.h"
#include "afxdllx.h"
//#include "..\cleanup.h"

#include "bldwin32.h"
#include "bldmfc.h"
#include "bldatl.h"
#include "bldmisc.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CBuildSubSuite

IMPLEMENT_SUBSUITE(CBuildSubSuite, CIDESubSuite, "Build", "VCQA ProjBuild")

BEGIN_TESTLIST(CBuildSubSuite)
	TEST(CBuildWin32Test, RUN)
	TEST(CBuildMFCTest, RUN)
	TEST(CBuildATLTest, RUN)
	TEST(CBuildMiscTest, RUN)
END_TESTLIST()
/*
void CProj1SubSuite::CleanUp(void)
	{
//	::CleanUp();
	}
*/
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\build\bldwin32.h ===
///////////////////////////////////////////////////////////////////////////////
//	bldwin32.H
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Declaration of the CBuildWin32Test class

#ifndef __bldwin32_H__
#define __bldwin32_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "buildsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CBuildWin32Test class

class CBuildWin32Test : public CProjectTestSet
{
	DECLARE_TEST(CBuildWin32Test, CBuildSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:
//	BOOL RunAsDependent(void);
//	BOOL CloseProject( void );

// Test Cases
protected:
	BOOL CreateAndBuildWin32App();
	BOOL CreateAndBuildConsoleApp();
	BOOL CreateAndBuildWin32Dll();
	BOOL CreateAndBuildWin32StaticLib();

// Utilities
//	BOOL UpdateBuildVerify( LPCSTR szCurrentFile, LPCSTR szNewFile, LPCSTR szFileString );
/*	BOOL CreateNewProject( void );
	BOOL AddFilesToEXEProject( void );
	BOOL SaveProject( void );
*/
};

#endif //__bldwin32_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\convers\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\build\buildsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	buildsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CBuildSubSuite class
//

#ifndef __buildsub_H__
#define __buildsub_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CBuildSubSuite class

class CBuildSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CBuildSubSuite)

	DECLARE_TESTLIST()
protected:
//	void CleanUp(void);
};

#endif //__buildsub_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\convers\convsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	convsub.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CConversionSubSuite class
//

#include "stdafx.h"
#include "convsub.h"
#include "afxdllx.h"

#include "conv1.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CConversionSubSuite

IMPLEMENT_SUBSUITE(CConversionSubSuite, CIDESubSuite, "Project Conversion", "VCQA ProjBuild")

BEGIN_TESTLIST(CConversionSubSuite)
	TEST(CConversionTest1, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\build\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\convers\conv1.h ===
///////////////////////////////////////////////////////////////////////////////
//	conv1.H
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Declaration of the CConversionTest1 class

#ifndef __conv1_H__
#define __conv1_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "convsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CConversionTest1 class

class CConversionTest1 : public CProjectTestSet
{
	DECLARE_TEST(CConversionTest1, CConversionSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL Test1();

// Utilities

};

#endif //__conv1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\convers\conv1.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	conv1.CPP
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Implementation of the CConversionTest1 class

#include "stdafx.h"
#include "conv1.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CConversionTest1, CProjectTestSet, "Doing....", -1, CConversionSubSuite)

void CConversionTest1::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CSuite1Test

void CConversionTest1::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( Test1() );
	XSAFETY;

}


BOOL CConversionTest1::Test1( void )
{
	LogTestHeader("Test1");

// Write the test

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\convers\convsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	convsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CConversionSubSuite class
//

#ifndef __convsub_H__
#define __convsub_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CConversionSubSuite class

class CConversionSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CConversionSubSuite)

	DECLARE_TESTLIST()
protected:
};

#endif //__convsub_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\customb\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\customb\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\convers\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\customb\cust1.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	cust1.CPP
//
//	Created by :			Date :
//		Brickb 				3/12/98
//
//	Description :
//		Implementation of the CCustomBuildTest1 class

#include "stdafx.h"
#include "cust1.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
int iWaitForBuild = 3;	// Minutes to wait for the build to complete

IMPLEMENT_TEST(CCustomBuildTest1, CProjectTestSet, "Custom Build Basics", -1, CCustomBuildSubSuite)

void CCustomBuildTest1::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CCustomBuildTest1

void CCustomBuildTest1::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( BasicTest() );
	XSAFETY;

}


BOOL CCustomBuildTest1::BasicTest( void )
{
	LogTestHeader("Basic Custom Build Rules");
	// slap together a basic project for this test
	EXPECT_TRUE(GetProjReady());

	//lets put a very simple custom build things in the Prj Settings Dialog
	EXPECT_TRUE(SetCustomBuild());
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	// should not see a build for the above changes
	EXPECT_TRUE(VerifyBuildOccured(FALSE));
	// Check to see of the text made it into the Output window
	EXPECT_TRUE(VerifyBuildString(GetLocString(IDSS_PB_CUSTBLD_DESC_1)));

	// Now lets try all the Macro's at once to see what they get us
	EXPECT_TRUE(SetAllMacros());
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	// should not see a build for the above changes
	EXPECT_TRUE(VerifyBuildOccured(FALSE));

	// close the workspace 
	prj.Close(TRUE);

	return TRUE;
}

BOOL CCustomBuildTest1::SetCustomBuild( void )
{
	CString desc = GetLocString(IDSS_PB_CUSTBLD_DESC_1) + GetLocString(IDSS_PB_CUSTBLD_DESC_2); 
	CStringArray bld_cmds;
	bld_cmds.Add("echo \"ProjDir=$(ProjDir)\" > .\\$(OutDir)\\echo1.out");
	bld_cmds.Add("echo \"TargetName=$(TargetName)\" > .\\$(OutDir)\\echo2.out");
	CStringArray output_files;
	output_files.Add("$(OutDir)\\echo1.out");
	output_files.Add("$(OutDir)\\echo2.out");
	ConfigStrArray configs;
	configs.Add(m_strProjName, PLATFORM_WIN32_X86, BUILD_RELEASE );

	if ( !VERIFY_TEST_SUCCESS(prj.SetCustomBuildOptions(desc, bld_cmds, output_files, configs )))
	{
		m_pLog->RecordFailure("Change custom build options.");
		return FALSE;
	}
	return TRUE;
}

BOOL CCustomBuildTest1::SetAllMacros( void )
{
	CString desc = GetLocString(IDSS_PB_CUSTBLD_DESC_1) + GetLocString(IDSS_PB_CUSTBLD_DESC_2); 
	CStringArray bld_cmds;
	bld_cmds.Add("echo ProjDir=$(ProjDir) >$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo TargetName=$(TargetName) >>$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo IntermediateDir=$(IntDir) >>$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo OutputDir=$(OutDir) >>$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo TargetDir=$(TargetDir) >>$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo ProjectDir=$(ProjDir) >>$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo WorkspaceDir=$(WkspDir) >>$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo MSDEVDir=$(MSDEVDIR) >>$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo RemoteDir=$(RemoteDir) >>$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo TargetPath=$(TargetPath) >>$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo TargetName=$(TargetName) >>$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo InputPath=$(InputPath) >>$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo InputName=$(InputName) >>$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo WorkspaceName=$(WkspName) >>$(ProjDir)\\echo3.out");
	bld_cmds.Add("echo RemoteTarget=$(REMOTETARGETPATH) >>$(ProjDir)\\echo3.out");

	CStringArray output_files;
	output_files.Add("$(ProjDir)\\echo3.out");

	ConfigStrArray configs;
	configs.Add(m_strProjName, PLATFORM_WIN32_X86, BUILD_RELEASE );

	if ( !VERIFY_TEST_SUCCESS(prj.SetCustomBuildOptions(desc, bld_cmds, output_files, configs )))
	{
		m_pLog->RecordFailure("Change custom build options.");
		return FALSE;
	}
	return TRUE;
}


BOOL CCustomBuildTest1::GetProjReady( void )
{

		// Create a new Project
	m_strProjName = GetLocString(IDSS_FUNNY_PROJ_NAME);
	m_strProjLoc  = m_strCWD + _T("apps\\") + m_strProjName + _T("\\");
	CString szSRCFileLoc	= m_strCWD + _T("src\\") + _T("customb1") + _T("\\");
	CString szHFiles		= szSRCFileLoc + _T("*.h");
	CString szCPPFiles		= szSRCFileLoc + _T("*.cpp");
	CString szRCFiles		= szSRCFileLoc + _T("*.rc");
	CString szICOFiles		= szSRCFileLoc + _T("*.ico");

	// Create a clean copy of the test workspace tree
	KillAllFiles(m_strProjLoc + _T("Debug\\"), TRUE);
	KillAllFiles(m_strProjLoc + _T("Release\\"), TRUE);
	KillAllFiles(m_strProjLoc, TRUE);

	if (!VERIFY_TEST_SUCCESS( prj.NewProject( UIAW_PT_APP, m_strProjName, m_strProjLoc, PLATFORMS)))
	{
 		m_pLog->RecordFailure("Could not create an Application project");
		return FALSE;
	}

	// Suck in all the project files we have created for this test.
	EXPECT_TRUE(CopyProjectSources(szSRCFileLoc, m_strProjLoc));
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.AddFiles( szCPPFiles, m_strProjName )));
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.AddFiles( szRCFiles, m_strProjName )));
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.AddFiles( szHFiles, m_strProjName )));
	EXPECT_TRUE(VERIFY_TEST_SUCCESS( prj.AddFiles( szICOFiles, m_strProjName )));

	LogSubTestHeader("BuildProjectCustomb1");
	EXPECT_TRUE( VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)));
	return VerifyBuildOccured( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\customb\custsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	custsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CCustomBuildSubSuite class
//

#ifndef __custsub_H__
#define __custsub_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CCustomBuildSubSuite class

class CCustomBuildSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CCustomBuildSubSuite)

	DECLARE_TESTLIST()
protected:
};

#endif //__custsub_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\defaultp\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\defaultp\defau1.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	defau1.CPP
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Implementation of the CDefaultProjectTest1 class

#include "stdafx.h"
#include "defau1.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CDefaultProjectTest1, CProjectTestSet, "Doing....", -1, CDefaultPrjSubSuite)

void CDefaultProjectTest1::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CSuite1Test

void CDefaultProjectTest1::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( Test1() );
	XSAFETY;

}


BOOL CDefaultProjectTest1::Test1( void )
{
	LogTestHeader("Test1");

// Write the test

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\defaultp\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\customb\cust1.h ===
///////////////////////////////////////////////////////////////////////////////
//	cust1.H
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Declaration of the Ccust1Test class

#ifndef __cust1_H__
#define __cust1_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "custsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CCustomBuildTest1 class

class CCustomBuildTest1 : public CProjectTestSet
{
	DECLARE_TEST(CCustomBuildTest1, CCustomBuildSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL BasicTest(void);
	BOOL SetCustomBuild(void);
	BOOL SetAllMacros(void);
	BOOL GetProjReady(void);

// Utilities

};

#endif //__cust1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\customb\custsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	custsub.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CCustomBuildSubSuite class
//

#include "stdafx.h"
#include "custsub.h"
#include "afxdllx.h"

#include "cust1.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CCustomBuildSubSuite

IMPLEMENT_SUBSUITE(CCustomBuildSubSuite, CIDESubSuite, "Custom Build", "VCQA ProjBuild")

BEGIN_TESTLIST(CCustomBuildSubSuite)
	TEST(CCustomBuildTest1, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\defaultp\defausub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	defausub.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CDefaultPrjSubSuite class
//

#include "stdafx.h"
#include "defausub.h"
#include "afxdllx.h"

#include "defau1.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CDefaultPrjSubSuite

IMPLEMENT_SUBSUITE(CDefaultPrjSubSuite, CIDESubSuite, "Default Project", "VCQA ProjBuild")

BEGIN_TESTLIST(CDefaultPrjSubSuite)
	TEST(CDefaultProjectTest1, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\defaultp\defausub.h ===
///////////////////////////////////////////////////////////////////////////////
//	defausub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CDefaultPrjSubSuite class
//

#ifndef __defausub_H__
#define __defausub_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CDefaultPrjSubSuite class

class CDefaultPrjSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CDefaultPrjSubSuite)

	DECLARE_TESTLIST()
protected:
};

#endif //__defausub_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\defaultp\defau1.h ===
///////////////////////////////////////////////////////////////////////////////
//	defau1.H
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Declaration of the Cdefau1Test class

#ifndef __defau1_H__
#define __defau1_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "defausub.h"

///////////////////////////////////////////////////////////////////////////////
//	CDefaultProjectTest1 class

class CDefaultProjectTest1 : public CProjectTestSet
{
	DECLARE_TEST(CDefaultProjectTest1, CDefaultPrjSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL Test1();

// Utilities

};

#endif //__defau1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\depend\dep1.h ===
///////////////////////////////////////////////////////////////////////////////
//	dep1.H
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Declaration of the Cdep1Test class

#ifndef __dep1_H__
#define __dep1_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "depsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CDependenciesTest1 class

class CDependenciesTest1 : public CProjectTestSet
{
	DECLARE_TEST(CDependenciesTest1, CDependenciesSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL BasicDependencyTest();
	BOOL ProjectDependencies();
	BOOL GenericProjectDependencies();

// Utilities
	void TouchAndBuild(
		CString szFileToTouch,
		BOOL	bExpectRebuild = TRUE
		);
	BOOL VerifyTextInBuildLog(
		CString szTextToFind
		);

};

#endif //__dep1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\depend\depsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	depsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CDependenciesSubSuite class
//

#ifndef __depsub_H__
#define __depsub_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CDependenciesSubSuite class

class CDependenciesSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CDependenciesSubSuite)

	DECLARE_TESTLIST()
protected:
};

#endif //__depsub_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\depend\gprojdep.h ===
///////////////////////////////////////////////////////////////////////////////
//	Gprojdep.h
//
//	Created by :			Date :
//		t-seanc					8/12/97
//
//	Description :
//		Declaration of the CGenProjectDependencies class.

#ifndef __GENPROJDEP_H__
#define __GENPROJDEP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "depsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CGenProjectDependencies class

class CGenProjectDependencies : public CProjectTestSet
{
	DECLARE_TEST(CGenProjectDependencies, CDependenciesSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL GenProjectsDependantOnProjects(); 
	BOOL GenProjectsDependantOnGenProjects();

// Utilities
};

#endif // __PROJDEP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\depend\filedep.h ===
///////////////////////////////////////////////////////////////////////////////
//	Filedep.h
//
//	Created by :			Date :
//		t-seanc					8/12/97
//
//	Description :
//		Declaration of the CFileDependencies class.

#ifndef __FILEDEP_H__
#define __FILEDEP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "depsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CFileDependencies class

class CFileDependencies : public CProjectTestSet
{
	DECLARE_TEST(CFileDependencies, CDependenciesSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL FilesDependantOnHeaderFiles();

// Utilities
};

#endif // __FILEDEP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\depend\depsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	depsub.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CDependenciesSubSuite class
//

#include "stdafx.h"
#include "depsub.h"
#include "afxdllx.h"

#include "filedep.h"
#include "projdep.h"
#include "gprojdep.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CDependenciesSubSuite

IMPLEMENT_SUBSUITE(CDependenciesSubSuite, CIDESubSuite, "Project Dependencies", "VCQA ProjBuild")

BEGIN_TESTLIST(CDependenciesSubSuite)
	TEST(CFileDependencies, RUN)
	TEST(CProjectDependencies, RUN)
	TEST(CGenProjectDependencies, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\depend\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\depend\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\depend\dep1.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	dep1.CPP
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Implementation of the CDependenciesTest1 class

#include "stdafx.h"
#include "dep1.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CDependenciesTest1, CProjectTestSet, "Basic Dependency Test", -1, CDependenciesSubSuite)

void CDependenciesTest1::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CDependenciesTest1

void CDependenciesTest1::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( BasicDependencyTest() );
	XSAFETY;

}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	BasicDependencyTest

	Makes sure all simple dependency relationships (File, Project, Generic
	Project) work.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
BOOL CDependenciesTest1::BasicDependencyTest( void )
	{
	// Write out the test header
	LogTestHeader("Basic Dependency Test");

	// Copy the files from the clean directory
	CString szProjPath = m_strCWD + _T("src\\") + _T("Useless\\");
	CString szCleanProjPath = szProjPath + _T("new\\");
	m_pLog->RecordInfo(szProjPath);
	m_pLog->RecordInfo(szCleanProjPath);
	KillFile(szProjPath, _T("*.*"));
	KillAllFiles(szProjPath + _T("Release\\"), TRUE);
	EXPECT_TRUE(CopyProjectSources(szCleanProjPath, szProjPath));

	// Open the Useless workspace
	EXPECT_SUCCESS(prj.Open(szProjPath + "Useless.dsw", 0));

	// Set the active project to Useless and build
	MST.DoKeys("%(BO)");
	MST.DoKeys("U");
	MST.DoKeys("{ENTER}");
	EXPECT_SUCCESS(prj.Build(5));
	EXPECT_TRUE(VerifyBuildOccured(TRUE));	

	// Check to make sure dependencies are correctly understood
	TouchAndBuild(szProjPath + _T("Useless.h"));
	VerifyTextInBuildLog(_T("Useless"));
	TouchAndBuild(szProjPath + _T("Nothing.h"));

	// Close the project
	EXPECT_SUCCESS(prj.Close(0));

	return TRUE;
	}

BOOL CDependenciesTest1::ProjectDependencies()
	{
	// Touch some other projects and make sure the results are correct
	TouchAndBuild(szProjPath + _T("Nothing.cpp"));
	TouchAndBuild(szProjPath + _T("Resource1.rc"));
	TouchAndBuild(szProjPath + _T("Worthless.h"), FALSE);

	return TRUE;
	}

BOOL CDependenciesTest1::GenericProjectDependencies()
	{
	// Set the active project to Generic and build
	MST.DoKeys("%(BO)");
	MST.DoKeys("G");
	MST.DoKeys("{ENTER}");
	EXPECT_SUCCESS(prj.Build(5));

	// Check to make sure dependants are recorded
	TouchAndBuild(szProjPath + _T("Useless.h"));
	TouchAndBuild(szProjPath + _T("Nothing.h"));
	TouchAndBuild(szProjPath + _T("Worthless.h"));

	return TRUE;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	TouchAndBuild

	Description:
	
	Touches the specified file and the rebuilds the current active project.
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void CDependenciesTest1::TouchAndBuild
	(
	CString szFileToTouch,
	BOOL	bExpectRebuild /* = true */
	)	

	{
	// Set the modification time of the file to the current time
	_utime(szFileToTouch, NULL);

	// Build the active project
	EXPECT_SUCCESS(prj.Build(5));
	EXPECT_TRUE(VerifyBuildOccured(bExpectRebuild));
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	VerifyTextInBuildLog

	Description:
	
	Checks to see if the specified text is found in the build log.  If it
	is not, a failure is recorded.
  
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
BOOL CDependenciesTest1::VerifyTextInBuildLog
	(
	CString szTextToFind
	)

	{
	// Get the build log
	CString BuildLog = GetBldLog();

	// Search for the text
	szTextToFind.MakeLower();
	if(BuildLog.Find(szTextToFind) == -1)
		{
		m_pLog->RecordFailure(_T("Could not find ") + szTextToFind + _T(" in build log."));
		return FALSE;
		}
	else 
		return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\depend\filedep.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Filedep.cpp
//
//	Created by :			Date :
//		t-seanc					8/12/97
//
//	Description :
//		Implementation of the CFileDependencies class

#include "stdafx.h"
#include "filedep.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CFileDependencies, CProjectTestSet, "Dependencies of Files", -1, CDependenciesSubSuite)

void CFileDependencies::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}

////////////////////////////////////////////////////////////////////
//	CDependenciesTest1

void CFileDependencies::Run(void)
	{	 
	XSAFETY;
	EXPECT_TRUE(FilesDependantOnHeaderFiles());
	XSAFETY;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Function: FilesDependantOnHeaderFiles

	This test makes sure that header file dependencies are correctly 
	recognized by the dependency scanner.  It opens the workspace Useless 
	and changes the active project to Worthless which contains a source 
	file that has several levels of nested include files, each of the 
	include files having many strange constructs within them.  It touches 
	each of those include files and rebuilds making sure that the build 
	occurs each time.

	After that, it removes dependencies from the project by removing
	#include directives, builds the project, touches the header files
	that were removed and makes sure a second rebuild does not occur.

	Return Value: BOOL

	This function returns TRUE if the test succeeds and FALSE if the 
	test fails.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
BOOL CFileDependencies::FilesDependantOnHeaderFiles()
	{
	LogTestHeader(_T("Files dependant on header files"));
	
	UIWorkspaceWindow uiws;

	// Create string containing the path to the Useless tree
	CString szProjectPath = m_strCWD + _T("src\\") + _T("useless\\");

	// Create a clean copy of the test workspace tree
	KillFile(szProjectPath, _T("*.*"));
	KillAllFiles(szProjectPath + _T("Debug\\"), TRUE);
	KillAllFiles(szProjectPath + _T("Release\\"), TRUE);
	CopyProjectSources(szProjectPath + _T("new\\"), szProjectPath);

	// Open the workspace
	prj.Open(szProjectPath + _T("Useless.dsw"));

	// Change the active project to Worthless
	uiws.SetActiveProject(_T("Worthless"));

	// Build the project
	EXPECT_SUCCESS(prj.Build(5));
	EXPECT_TRUE(VerifyBuildOccured(TRUE));	

	// Touch every header and rebuild
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless2.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless3.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless4.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));
	EXPECT_TRUE(TouchAndVerifyRebuild(
		szProjectPath + 
		_T("This is another header file.Do you like it.I think it is neat")
		));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));

	// Remove the dependency on "This is a header file", touch, and rebuild
	src.Open(szProjectPath + _T("Worthless4.h"));
	src.Replace(
		_T("#include.\\:q"), // search for the quoted string
		_T(" "), 
		TRUE, 
		TRUE, 
		TRUE, 
		COSource::RS_WHOLEFILE,
		TRUE
		);
	src.Close(TRUE);
	prj.Build(5);
	TouchAndVerifyRebuild(szProjectPath + _T("This is a header file"), FALSE);

	// *******
	// If you get a failuer here, take a look at BUG VS29120
	// *******

	// Remove the dependency on "Worthless4.h", touch, and rebuild
	src.Open(szProjectPath + _T("Worthless3.h"));
	src.Replace(
		_T("#include.\\:q"), 
		_T(" "), 
		TRUE,
		TRUE, 
		TRUE, 
		COSource::RS_WHOLEFILE,
		TRUE
		);
	src.Close(TRUE);
	prj.Build(5);
	TouchAndVerifyRebuild(szProjectPath + _T("Worthless4.h"), FALSE);
	
	// Remove the dependency on "Worthless3.h", touch, and rebuild
	src.Open(szProjectPath + _T("Worthless2.h"));
	src.Replace(
		_T("#include.\\:q"), 
		_T(" "), 
		TRUE, 
		TRUE, 
		TRUE, 
		COSource::RS_WHOLEFILE,
		TRUE
		);
	src.Close(TRUE);
	prj.Build(5);
	TouchAndVerifyRebuild(szProjectPath + _T("Worthless3.h"), FALSE);

	// Remove the dependency on "Worthless2.h", touch, and rebuild
	src.Open(szProjectPath + _T("Worthless"));
	src.Replace(
		_T("#include.\\:q"), 
		_T(" "), 
		TRUE, 
		TRUE, 
		TRUE, 
		COSource::RS_WHOLEFILE,
		TRUE
		);
	src.Close(TRUE);
	prj.Build(5);
	TouchAndVerifyRebuild(szProjectPath + _T("Worthless2.h"), FALSE);

	// Close the workspace
	prj.Close(0);
	
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\depend\gprojdep.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Filedep.cpp
//
//	Created by :			Date :
//		t-seanc					8/12/97
//
//	Description :
//		Implementation of the CGenProjectDependencies class

#include "stdafx.h"
#include "gprojdep.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(
	CGenProjectDependencies, 
	CProjectTestSet, 
	"Dependencies of Generic Projects", 
	-1, 
	CDependenciesSubSuite
	)

void CGenProjectDependencies::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}

////////////////////////////////////////////////////////////////////
//	CDependenciesTest1

void CGenProjectDependencies::Run(void)
	{	 
	XSAFETY;
	EXPECT_TRUE(GenProjectsDependantOnProjects());
	EXPECT_TRUE(GenProjectsDependantOnGenProjects());
	XSAFETY;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Function: GenProjectsDependantOnProjects

	This test opens the workspace Useless and sets the active project to a 
	generic project named Generic.  Generic is dependant on several other 
	projects in the workspace.	This test touches many of the files that 
	Generic is dependant on	and then rebuilds, making sure that the build 
	occurs in every case.

	Return Value: BOOL

	This function returns TRUE if the test succeeds and FALSE if the 
	test fails.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
BOOL CGenProjectDependencies::GenProjectsDependantOnProjects()
	{
	LogTestHeader(_T("Generic projects dependant on projects"));
	
	UIWorkspaceWindow uiws;

	// Create string containing the path to the Useless tree
	CString szProjectPath = m_strCWD + _T("src\\") + _T("useless\\");

	// Create a clean copy of the test workspace tree
	KillFile(szProjectPath, _T("*.*"));
	KillAllFiles(szProjectPath + _T("Debug\\"), TRUE);
	KillAllFiles(szProjectPath + _T("Release\\"), TRUE);
	CopyProjectSources(szProjectPath + _T("new\\"), szProjectPath);

	// Open the workspace
	prj.Open(szProjectPath + _T("Useless.dsw"));

	// Change the active project to Generic
	uiws.SetActiveProject(_T("Generic"));

	// Build the project
	EXPECT_SUCCESS(prj.Build(5));

	// Touch everything the in the project Nothing
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Nothing.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Nothing.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing2.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing3.cpp"), FALSE));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Precomp.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing2.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing3.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Nothing2.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing2.cpp")));

	// Touch everything the in the project Worthless
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless2.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless3.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless4.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));

	// Touch everything in the project Useless
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Useless.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Useless.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Useless.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Useless.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Resource1.rc")));
	EXPECT_TRUE(VerifyBuildString(GetLocString(IDSS_OUTPUTWIN_RC_COMPILING)));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("This file has a really long name and I like that fact.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("This file has a really long name and I like that fact.cpp")));

	// Close the workspace
	prj.Close(0);

	return TRUE;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Function: GenProjectsDependantOnGenProjects

	This test opens a workspace Useless and sets the active project to a 
	generic project named Another Generic Project.  Another Generic Project 
	includes the generic project Generic.  This test then touches many of 
	the files that Another Generic Project is dependant on and rebuilds the 
	project, making sure the build occurs each time.

	Return Value: BOOL

	This function returns TRUE if the test succeeds and FALSE if the 
	test fails.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
BOOL CGenProjectDependencies::GenProjectsDependantOnGenProjects()
	{	
	LogTestHeader(_T("Generic projects dependant on generic projects"));

	UIWorkspaceWindow uiws;

	// Create string containing the path to the Useless tree
	CString szProjectPath = m_strCWD + _T("src\\") + _T("useless\\");

	// Open the workspace
	prj.Open(szProjectPath + _T("Useless.dsw"));

	// Change the active project to Another Generic Project
	uiws.SetActiveProject(_T("Another Generic Project"));

	// Build the project
	EXPECT_SUCCESS(prj.Build(5));

	// Touch everything the in the project Nothing
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Nothing.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Nothing.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing2.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing3.cpp"), FALSE));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Precomp.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing2.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing3.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Nothing2.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing2.cpp")));

	// Touch everything the in the project Worthless
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless2.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless3.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless4.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));

	// Touch everything in the project Useless
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Useless.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Useless.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Useless.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Useless.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Resource1.rc")));
	EXPECT_TRUE(VerifyBuildString(GetLocString(IDSS_OUTPUTWIN_RC_COMPILING)));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("This file has a really long name and I like that fact.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("This file has a really long name and I like that fact.cpp")));

	// Close the workspace
	prj.Close(0);

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\exportmf\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\exportmf\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\depend\projdep.h ===
///////////////////////////////////////////////////////////////////////////////
//	Gprojdep.h
//
//	Created by :			Date :
//		t-seanc					8/12/97
//
//	Description :
//		Declaration of the CProjectDependencies class.

#ifndef __PROJDEP_H__
#define __PROJDEP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "depsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CProjectDependencies class

class CProjectDependencies : public CProjectTestSet
{
	DECLARE_TEST(CProjectDependencies, CDependenciesSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL ProjectsDependantOnFiles();
	BOOL ProjectsDependantOnProjects();
	BOOL ProjectsDependantOnGenProjects();

// Utilities
};

#endif // __PROJDEP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\exportmf\expor1.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	expor1.CPP
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Implementation of the CExportMakefileTest1 class

#include "stdafx.h"
#include "expor1.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CExportMakefileTest1, CProjectTestSet, "Doing....", -1, CExportMakefileSubSuite)

void CExportMakefileTest1::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CExportMakefileTest1

void CExportMakefileTest1::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( Test1() );
	XSAFETY;

}


BOOL CExportMakefileTest1::Test1( void )
{
	LogTestHeader("Test1");

// Write the test

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\exportmf\exporsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	exporsub.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CExportMakefileSubSuite class
//

#include "stdafx.h"
#include "exporsub.h"
#include "afxdllx.h"

#include "expor1.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CExportMakefileSubSuite

IMPLEMENT_SUBSUITE(CExportMakefileSubSuite, CIDESubSuite, "Export Makefile", "VCQA ProjBuild")

BEGIN_TESTLIST(CExportMakefileSubSuite)
	TEST(CExportMakefileTest1, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\depend\projdep.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Filedep.cpp
//
//	Created by :			Date :
//		t-seanc					8/12/97
//
//	Description :
//		Implementation of the CProjectDependencies class

#include "stdafx.h"
#include "projdep.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CProjectDependencies, CProjectTestSet, "Dependencies of Projects", -1, CDependenciesSubSuite)

void CProjectDependencies::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}

////////////////////////////////////////////////////////////////////
//	CDependenciesTest1

void CProjectDependencies::Run(void)
	{	 
	XSAFETY;
	EXPECT_TRUE(ProjectsDependantOnFiles());
	EXPECT_TRUE(ProjectsDependantOnProjects());
	EXPECT_TRUE(ProjectsDependantOnGenProjects());
	XSAFETY;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Function: ProjectsDependantOnFiles

	This test opens the workspace Useless, and sets the active project
	to Useless which contains several source files.  The test touches 
	each of these source files and rebuilds, checking to make sure the 
	build occurs in every case.

	Return Value: BOOL

	This function returns TRUE if the test succeeds and FALSE if the 
	test fails.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
BOOL CProjectDependencies::ProjectsDependantOnFiles()
	{	
	LogTestHeader(_T("Projects dependant on files"));

	UIWorkspaceWindow uiws;

	// Create string containing the path to the Useless tree
	CString szProjectPath = m_strCWD + _T("src\\") + _T("useless\\");

	// Create a clean copy of the test workspace tree
	KillFile(szProjectPath, _T("*.*"));
	KillAllFiles(szProjectPath + _T("Debug\\"), TRUE);
	KillAllFiles(szProjectPath + _T("Release\\"), TRUE);
	CopyProjectSources(szProjectPath + _T("new\\"), szProjectPath);

	// Open the workspace
	prj.Open(szProjectPath + _T("Useless.dsw"));

	// Change the active project to Useless
	uiws.SetActiveProject(_T("Useless"));

	// Touch everything in the project Useless
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Useless.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Useless.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Useless.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Useless.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Resource1.rc")));
	EXPECT_TRUE(VerifyBuildString(GetLocString(IDSS_OUTPUTWIN_RC_COMPILING)));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("This file has a really long name and I like that fact.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("This file has a really long name and I like that fact.cpp")));
	
	// Close the project
	prj.Close(0);
	
	return TRUE;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Function: ProjectsDependantOnProjects

	This test opens the workspace Useless and sets the active project to
	Useless which is dependant on the project Nothing.  It then touches 
	every file in Nothing and rebuilds, making sure the build occurs in 
	every case.

	Return Value: BOOL

	This function returns TRUE if the test succeeds and FALSE if the 
	test fails.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
BOOL CProjectDependencies::ProjectsDependantOnProjects()
	{
	LogTestHeader(_T("Projects dependant on projects"));
	
	UIWorkspaceWindow uiws;
	
	// Create string containing the path to the Useless tree
	CString szProjectPath = m_strCWD + _T("src\\") + _T("useless\\");

	// Open the workspace
	prj.Open(szProjectPath + _T("Useless.dsw"));

	// Change the active project to Useless
	uiws.SetActiveProject(_T("Useless"));

	// Touch everything the in the project Nothing
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Nothing.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Nothing.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing2.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing3.cpp"), FALSE));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Precomp.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing2.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing3.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Nothing2.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing2.cpp")));

	// Close the workspace
	prj.Close(0);
	
	return TRUE;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Function: ProjectsDependantOnGenProjects

	This test opens the workspace Useless and set the active project to 
	Pointless which is dependant on the generic project Another Generic 
	Project.  It then touches several of the files that Another Generic 
	Project is dependant on and rebuilds making sure the build occurs in 
	every case.

	Return Value: BOOL

	This function returns TRUE if the test succeeds and FALSE if the 
	test fails.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
BOOL CProjectDependencies::ProjectsDependantOnGenProjects()
	{
	LogTestHeader(_T("Projects dependant on generic projects"));

	UIWorkspaceWindow uiws;

	// Create string containing the path to the Useless tree
	CString szProjectPath = m_strCWD + _T("src\\") + _T("useless\\");

	// Open the workspace
	prj.Open(szProjectPath + _T("Useless.dsw"));

	// Change the active project to Pointless
	uiws.SetActiveProject(_T("Pointless"));

	// Touch everything the in the project Nothing
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Nothing.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Nothing.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing2.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing3.cpp"), FALSE));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Precomp.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing2.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing3.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Nothing2.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Nothing2.cpp")));

	// Touch everything the in the project Worthless
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless2.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless3.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Worthless4.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Worthless.c")));

	// Touch everything in the project Useless
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Useless.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("Useless.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Useless.h")));
	EXPECT_TRUE(VerifyBuildString(_T("Useless.cpp")));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("Resource1.rc")));
	EXPECT_TRUE(VerifyBuildString(GetLocString(IDSS_OUTPUTWIN_RC_COMPILING)));
	EXPECT_TRUE(TouchAndVerifyRebuild(szProjectPath + _T("This file has a really long name and I like that fact.cpp")));
	EXPECT_TRUE(VerifyBuildString(_T("This file has a really long name and I like that fact.cpp")));

	// Close the workspace
	prj.Close(0);

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\exportmf\expor1.h ===
///////////////////////////////////////////////////////////////////////////////
//	expor1.H
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Declaration of the Cexpor1Test class

#ifndef __expor1_H__
#define __expor1_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "exporsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CExportMakefileTest1 class

class CExportMakefileTest1 : public CProjectTestSet
{
	DECLARE_TEST(CExportMakefileTest1, CExportMakefileSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL Test1();

// Utilities

};

#endif //__expor1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\external\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\external\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\exportmf\exporsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	exporsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CExportMakefileSubSuite class
//

#ifndef __exporsub_H__
#define __exporsub_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CExportMakefileSubSuite class

class CExportMakefileSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CExportMakefileSubSuite)

	DECLARE_TESTLIST()
protected:
};

#endif //__exporsub_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\external\extern1.h ===
///////////////////////////////////////////////////////////////////////////////
//	extern1.H
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Declaration of the Cextern1Test class

#ifndef __extern1_H__
#define __extern1_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "extersub.h"

///////////////////////////////////////////////////////////////////////////////
//	CExternalMakefileTest1 class

class CExternalMakefileTest1 : public CProjectTestSet
{
	DECLARE_TEST(CExternalMakefileTest1, CExternalMakefileSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL Test1();

// Utilities

};

#endif //__extern1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\external\extern1.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	extern1.CPP
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Implementation of the CExternalMakefileTest1 class

#include "stdafx.h"
#include "extern1.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CExternalMakefileTest1, CProjectTestSet, "Doing....", -1, CExternalMakefileSubSuite)

void CExternalMakefileTest1::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CExternalMakefileTest1

void CExternalMakefileTest1::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( Test1() );
	XSAFETY;

}


BOOL CExternalMakefileTest1::Test1( void )
{
	LogTestHeader("Test1");

// Write the test

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\external\extersub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	extersub.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CextersubSuite class
//

#include "stdafx.h"
#include "extersub.h"
#include "afxdllx.h"

#include "extern1.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CExternalMakefileSubSuite

IMPLEMENT_SUBSUITE(CExternalMakefileSubSuite, CIDESubSuite, "External Makefiles", "VCQA ProjBuild")

BEGIN_TESTLIST(CExternalMakefileSubSuite)
	TEST(CExternalMakefileTest1, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\external\extersub.h ===
///////////////////////////////////////////////////////////////////////////////
//	extersub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CextersubSuite class
//

#ifndef __extersub_H__
#define __extersub_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CExternalMakefileSubSuite class

class CExternalMakefileSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CExternalMakefileSubSuite)

	DECLARE_TESTLIST()
protected:
};

#endif //__extersub_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\options\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\options\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\options\optsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	optsub.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CBuildOptionsSubSuite class
//

#include "stdafx.h"
#include "optsub.h"
#include "afxdllx.h"

#include "opt1.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CBuildOptionsSubSuite

IMPLEMENT_SUBSUITE(CBuildOptionsSubSuite, CIDESubSuite, "Build Options", "VCQA ProjBuild")

BEGIN_TESTLIST(CBuildOptionsSubSuite)
	TEST(CBuildOptionsTest1, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\options\opt1.h ===
///////////////////////////////////////////////////////////////////////////////
//	opt1.H
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Declaration of the Copt1Test class

#ifndef __opt1_H__
#define __opt1_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "optsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CBuildOptionsTest1 class

class CBuildOptionsTest1 : public CProjectTestSet
{
	DECLARE_TEST(CBuildOptionsTest1, CBuildOptionsSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL Test1();

// Utilities

};

#endif //__opt1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\proj1\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\options\opt1.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	opt1.CPP
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Implementation of the CBuildOptionsTest1 class

#include "stdafx.h"
#include "opt1.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CBuildOptionsTest1, CProjectTestSet, "Doing....", -1, CBuildOptionsSubSuite)

void CBuildOptionsTest1::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//	CBuildOptionsTest1

void CBuildOptionsTest1::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( Test1() );
	XSAFETY;

}


BOOL CBuildOptionsTest1::Test1( void )
{
	LogTestHeader("Test1");

// Write the test

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\options\optsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	optsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CBuildOptionsSubSuite class
//

#ifndef __optsub_H__
#define __optsub_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CBuildOptionsSubSuite class

class CBuildOptionsSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CBuildOptionsSubSuite)

	DECLARE_TESTLIST()
protected:
};

#endif //__optsub_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\proj1\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\subprjs\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\proj1\prj1sub.h ===
///////////////////////////////////////////////////////////////////////////////
//	prj1sub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CProj1SubSuite class
//

#ifndef __prj1sub_H__
#define __prj1sub_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CDisAsmSubSuite class

class CProj1SubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CProj1SubSuite)
//	CDisAsmSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
//	void CleanUp(void);
};

#endif //__prj1sub_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\subprjs\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\proj1\prj1sub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CDisAsmSubSuite class
//

#include "stdafx.h"
#include "prj1sub.h"
#include "afxdllx.h"
//#include "..\cleanup.h"

#include "prjcases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CProj1SubSuite

IMPLEMENT_SUBSUITE(CProj1SubSuite, CIDESubSuite, "Proj1", "VCQA ProjBuild")

BEGIN_TESTLIST(CProj1SubSuite)
	TEST(CPrjAppTest, RUN)
END_TESTLIST()
/*
void CProj1SubSuite::CleanUp(void)
	{
//	::CleanUp();
	}
*/
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\proj1\prjcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	PRJCASES.CPP
//
//	Created by :			Date :
//		TomWh					10/18/93
//
//	Description :
//		Implementation of the CPrjAppTest class
//		PaulLu - Took over ownership and converted to use new utility layer
//		DorianG - Seized control and made fixes for V3 UI changes - 10/1/94
//		ThuyT - Splitted test cases into trival subsuites.  2/06/96.

#include "stdafx.h"
#include "prjcases.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

//#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CPrjAppTest, CProjectTestSet, "Creating Application Project", -1, CProj1SubSuite)

// Global variables
#define PROJNAME		"Hello"
#define PROJMAKFILE		"Hello.DSP"
CString cstrRelease  =  GetLocString(IDSS_BUILD_RELEASE);
CString EXERELEASETARGET = "Hello - Win32 " + cstrRelease;
CString DLLRELEASETARGET = "DLL - Win32 " + cstrRelease;

BOOL CPrjAppTest::RunAsDependent(void)
{
	// name of the project file
	CString strProjFile = m_strCWD + PROJNAME + "\\" + PROJMAKFILE;

	// if the project file exists, there's no need to run this test as a dependency
	if (_access(strProjFile, 0) != -1) {
		return FALSE;
	}
	else {
		return TRUE;
	}
}

void CPrjAppTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
	m_szProjEXELoc		 = m_strCWD + PROJNAME + "\\";

}

////////////////////////////////////////////////////////////////////
//	CPrjAppTest

void CPrjAppTest::Run(void)
{	 
	XSAFETY;

// 	m_pLog->RecordInfo("Creating an Application project...");
	RemoveTestFiles( m_szProjEXELoc );
	EXPECT( CreateNewProject() );
//	m_pLog->RecordInfo("Insert files to the project.");
	EXPECT( AddFilesToEXEProject() );
//	m_pLog->RecordInfo("Save the project.");
	EXPECT( SaveProject() );
	EXPECT( CloseProject() );
	m_pLog->RecordInfo("Successfully creating an Application project.");
}

BOOL CPrjAppTest::CreateNewProject( void )
{
	LogTestHeader("Creating an Application project...");
	if (!VERIFY_TEST_SUCCESS( prj.NewProject( EXE, PROJNAME, m_szProjEXELoc, PLATFORMS))) {
 		m_pLog->RecordFailure("Create an Application project");
		return FALSE;
	}
	return TRUE;
}

BOOL CPrjAppTest::AddFilesToEXEProject( void )
{
	LogTestHeader("Insert files to the project.");

	CString szEXECPPFiles	= m_szProjEXELoc + "Hello*.cpp";
	CString szEXERCFiles	= m_szProjEXELoc + "*.rc";
	CString szSRCFileLoc	= m_strCWD + "src\\";
	CString szPattern		= szSRCFileLoc + "*.*";
	
	// Copy Hello.cpp Hello1.cpp and Hello.rc files to "Hello" directory
	WIN32_FIND_DATA ffdImgFile;
    HANDLE hFile = FindFirstFile(szPattern, &ffdImgFile);
    if( hFile != INVALID_HANDLE_VALUE )
    {
        do
        {
			CopyFile( szSRCFileLoc + ffdImgFile.cFileName, m_szProjEXELoc + ffdImgFile.cFileName, FALSE );
			SetFileAttributes(m_szProjEXELoc + ffdImgFile.cFileName, FILE_ATTRIBUTE_NORMAL ); 
		}
        while( FindNextFile(hFile, &ffdImgFile) );
        EXPECT( GetLastError() == ERROR_NO_MORE_FILES );
    }

	// Add Hello.cpp Hello1.cpp and Hello.rc files
	if (!VERIFY_TEST_SUCCESS( prj.AddFiles( szEXECPPFiles, PROJNAME ))) {
		m_pLog->RecordFailure("Couldn't add CPP files to EXE project");
		return FALSE;
	}
	
	if (!VERIFY_TEST_SUCCESS( prj.AddFiles( szEXERCFiles, PROJNAME ))) {
		m_pLog->RecordFailure("Couldn't add RC files to EXE project");
		return FALSE;
	}
	return TRUE;
}	

BOOL CPrjAppTest::SaveProject( void )
{
	LogTestHeader("SaveProject");

	if (!VERIFY_TEST_SUCCESS( prj.Save())) {
		m_pLog->RecordFailure("Save the project");
		return FALSE;
	}
	return TRUE;
}	

BOOL CPrjAppTest::CloseProject( void )
{
	LogTestHeader("Close Project");

	BOOL bSaveProjBeforeClose = FALSE; 
	
	if (!VERIFY_TEST_SUCCESS( prj.Close(bSaveProjBeforeClose))) {
		m_pLog->RecordFailure("Close the project");
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\subprjs\sprjsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	sprjsub.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CSubprojectsSubSuite class
//

#include "stdafx.h"
#include "sprjsub.h"
#include "afxdllx.h"

#include "subprj1.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CSubprojectsSubSuite

IMPLEMENT_SUBSUITE(CSubprojectsSubSuite, CIDESubSuite, "Subprojects", "VCQA ProjBuild")

BEGIN_TESTLIST(CSubprojectsSubSuite)
	TEST(CSubprojectsTest1, RUN)
END_TESTLIST()
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\proj1\prjcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	PRJCASES.H
//
//	Created by :			Date :
//		TomWh					10/18/93
//
//	Description :
//		Declaration of the CPrjAppTest class
//		PaulLu - Took over ownership and converted to use new utility layer
//

#ifndef __PRJCASES_H__
#define __PRJCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "prj1sub.h"
/*
// Global variables
extern CString cstrRelease ;// =  GetLocString(IDSS_BUILD_RELEASE);
extern CString EXERELEASETARGET; //= "Hello - Win32 " + cstrRelease;
extern CString DLLRELEASETARGET; //= "DLL - Win32 " + cstrRelease;
*/

///////////////////////////////////////////////////////////////////////////////
//	CPrjAppTest class

class CPrjAppTest : public CProjectTestSet
{
	DECLARE_TEST(CPrjAppTest, CProj1SubSuite)

// Operations
public:
//	virtual BOOL RunAsDependent(void);
	virtual void PreRun(void);
	virtual void Run(void);

public:
/*	CString m_strCurDir;
	CString szBuildToolsLoc;
	CString szProjEXELoc;	
*/ 		
	BOOL RunAsDependent(void);
	BOOL CloseProject( void );
// Test Cases
protected:
	BOOL CreateNewProject( void );
	BOOL AddFilesToEXEProject( void );
	BOOL SaveProject( void );

};

#endif //__PRJCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\subprjs\sprjsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	sprjsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CSubprojectsSubSuite class
//

#ifndef __sprjsub_H__
#define __sprjsub_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSubprojectsSubSuite class

class CSubprojectsSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CSubprojectsSubSuite)

	DECLARE_TESTLIST()
protected:
};

#endif //__sprjsub_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\appwiz.v2\appmodul.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// export WinMain to force linkage to this module

extern int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpCmdLine, int nCmdShow);

#ifdef _MAC
extern "C" int PASCAL
#else
extern "C" int WINAPI
#endif
_tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpCmdLine, int nCmdShow)
{
	return AfxWinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow);
}

/////////////////////////////////////////////////////////////////////////////
// initialize app state such that it points to this module's core state

class _AFX_TERM_APP_STATE
{
public:
	~_AFX_TERM_APP_STATE();
};

_AFX_TERM_APP_STATE::~_AFX_TERM_APP_STATE()
{
	AfxTermLocalData(NULL);
}

// force initialization early
#pragma warning(disable: 4074)
#pragma init_seg(lib)

_AFX_TERM_APP_STATE _afxTermAppState;

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\subprjs\subprj1.h ===
///////////////////////////////////////////////////////////////////////////////
//	subprj1.H
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Declaration of the Csubprj1Test class

#ifndef __subprj1_H__
#define __subprj1_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\prjset.h"
#include "sprjsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CSubprojectsTest1 class

class CSubprojectsTest1 : public CProjectTestSet
{
	DECLARE_TEST(CSubprojectsTest1, CSubprojectsSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

public:

// Test Cases
protected:
	BOOL Test1();

// Utilities

};

#endif //__subprj1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\core\subprjs\subprj1.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	subprj1.CPP
//
//	Created by :			Date :
//		YefimS					5/2/97
//
//	Description :
//		Implementation of the CSubprojectsTest1 class

#include "stdafx.h"
#include "subprj1.h"

#include <io.h>
#include <sys/utime.h>
#include <sys/stat.h> 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CSubprojectsTest1, CProjectTestSet, "Doing....", -1, CSubprojectsSubSuite)

void CSubprojectsTest1::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

////////////////////////////////////////////////////////////////////
//CSubprojectsTest1

void CSubprojectsTest1::Run(void)
{	 
	XSAFETY;
	EXPECT_TRUE( Test1() );
	XSAFETY;

}


BOOL CSubprojectsTest1::Test1( void )
{
	LogTestHeader("Test1");

// Write the test

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\appwiz.v2\defdoc.h ===
// defdoc.h : interface of the CDefDoc class
//
/////////////////////////////////////////////////////////////////////////////

class CDefDoc : public CDocument
{
protected: // create from serialization only
	CDefDoc();
	DECLARE_DYNCREATE(CDefDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDefDoc)
	public:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CDefDoc();
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CDefDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\appwiz.v2\defview.cpp ===
// defview.cpp : implementation of the CDefView class
//

#include "stdafx.h"
#include "def.h"

#include "defdoc.h"
#include "defview.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDefView

IMPLEMENT_DYNCREATE(CDefView, CView)

BEGIN_MESSAGE_MAP(CDefView, CView)
	//{{AFX_MSG_MAP(CDefView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDefView construction/destruction

CDefView::CDefView()
{
	// TODO: add construction code here

}

CDefView::~CDefView()
{
}

/////////////////////////////////////////////////////////////////////////////
// CDefView drawing

void CDefView::OnDraw(CDC* pDC)
{
	CDefDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: add draw code for native data here
}

/////////////////////////////////////////////////////////////////////////////
// CDefView printing

BOOL CDefView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CDefView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CDefView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CDefView diagnostics

#ifdef _DEBUG
void CDefView::AssertValid() const
{
	CView::AssertValid();
}

void CDefView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CDefDoc* CDefView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CDefDoc)));
	return (CDefDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDefView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\appwiz.v2\defdoc.cpp ===
// defdoc.cpp : implementation of the CDefDoc class
//

#include "stdafx.h"
#include "def.h"

#include "defdoc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDefDoc

IMPLEMENT_DYNCREATE(CDefDoc, CDocument)

BEGIN_MESSAGE_MAP(CDefDoc, CDocument)
	//{{AFX_MSG_MAP(CDefDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDefDoc construction/destruction

CDefDoc::CDefDoc()
{
	// TODO: add one-time construction code here

}

CDefDoc::~CDefDoc()
{
}

BOOL CDefDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDefDoc serialization

void CDefDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CDefDoc diagnostics

#ifdef _DEBUG
void CDefDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CDefDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDefDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\appwiz.v2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by DEF.RC
//
#define IDR_MAINFRAME				128
#define IDR_DEFTYPE				129
#define IDD_ABOUTBOX				100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS			1
#define _APS_NEXT_RESOURCE_VALUE	130
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\appwiz.v2\mainfrm.h ===
// mainfrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\appwiz.v2\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	def.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\appwiz.v2\mainfrm.cpp ===
// mainfrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "def.h"

#include "mainfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars
	
// toolbar buttons - IDs are command buttons
static UINT BASED_CODE buttons[] =
{
	// same order as in the bitmap 'toolbar.bmp'
	ID_FILE_NEW,
	ID_FILE_OPEN,
	ID_FILE_SAVE,
		ID_SEPARATOR,
	ID_EDIT_CUT,
	ID_EDIT_COPY,
	ID_EDIT_PASTE,
		ID_SEPARATOR,
	ID_FILE_PRINT,
	ID_APP_ABOUT,
};

static UINT BASED_CODE indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadBitmap(IDR_MAINFRAME) ||
		!m_wndToolBar.SetButtons(buttons,
		  sizeof(buttons)/sizeof(UINT)))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	// TODO: Remove this if you don't want tool tips
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);

	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\appwiz.v2\defview.h ===
// defview.h : interface of the CDefView class
//
/////////////////////////////////////////////////////////////////////////////

class CDefView : public CView
{
protected: // create from serialization only
	CDefView();
	DECLARE_DYNCREATE(CDefView)

// Attributes
public:
	CDefDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDefView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CDefView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CDefView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in defview.cpp
inline CDefDoc* CDefView::GetDocument()
   { return (CDefDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\appwiz.v2\winmain.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef AFX_CORE1_SEG
#pragma code_seg(AFX_CORE1_SEG)
#endif

/////////////////////////////////////////////////////////////////////////////
// Standard WinMain implementation
//  Can be replaced as long as 'AfxWinInit' is called first

#ifndef _USRDLL
#ifdef _MAC
extern "C" int PASCAL
#else
extern "C" int WINAPI
#endif
_tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpCmdLine, int nCmdShow)
{
	ASSERT(hPrevInstance == NULL);

	int nReturnCode = -1;
	CWinApp* pApp = AfxGetApp();

	// AFX internal initialization
	if (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow))
		goto InitFailure;

	// App global initializations (rare)
	ASSERT_VALID(pApp);
	if (!pApp->InitApplication())
		goto InitFailure;
	ASSERT_VALID(pApp);

	// Perform specific initializations
	if (!pApp->InitInstance())
	{
		if (pApp->m_pMainWnd != NULL)
		{
			TRACE0("Warning: Destroying non-NULL m_pMainWnd\n");
			pApp->m_pMainWnd->DestroyWindow();
		}
		nReturnCode = pApp->ExitInstance();
		goto InitFailure;
	}
	ASSERT_VALID(pApp);

	nReturnCode = pApp->Run();
	ASSERT_VALID(pApp);

InitFailure:
	AfxWinTerm();
	return nReturnCode;
}

#else
// _USRDLL library initialization

extern "C" BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
	CWinApp* pApp = AfxGetApp();
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// initialize MFC exception handling
#ifndef _AFX_OLD_EXCEPTIONS
		set_terminate(&AfxStandardTerminate);
#endif
		_set_new_handler(&AfxNewHandler);

		// initialize DLL's instance(/module) not the app's
		if (!AfxWinInit(hInstance, NULL, &afxChNil, 0))
		{
			AfxWinTerm();
			return FALSE;   // Init Failed
		}

		// initialize the single instance DLL
		if (pApp != NULL && !pApp->InitInstance())
		{
			pApp->ExitInstance();
			AfxWinTerm();
			return FALSE;   // Init Failed
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		if (pApp != NULL)
			pApp->ExitInstance();

#ifdef _DEBUG
		// check for missing AfxLockTempMap calls
		if (AfxGetThreadState()->m_nTempMapLock != 0)
			TRACE1("Warning: Temp map lock count non-zero (%ld).\n",
				AfxGetThreadState()->m_nTempMapLock);
#endif
		// terminate the library before destructors are called
		AfxWinTerm();

		// free safety pool buffer
		AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
		if (pThreadState->m_pSafetyPoolBuffer != NULL)
		{
			free(pThreadState->m_pSafetyPoolBuffer);
			pThreadState->m_pSafetyPoolBuffer = NULL;
		}
		// clean up map objects before it is too late
		pThreadState->m_mapHWND.CHandleMap::~CHandleMap();
		pThreadState->m_mapHMENU.CHandleMap::~CHandleMap();
		pThreadState->m_mapHDC.CHandleMap::~CHandleMap();
		pThreadState->m_mapHGDIOBJ.CHandleMap::~CHandleMap();

#ifdef _DEBUG
		// trace any memory leaks that may have occurred
		AfxDumpMemoryLeaks();
#endif
	}
	return TRUE;    // ok
}

// Note: need to initialize _pRawDllMain to RawDllMain so it gets called
extern "C" BOOL WINAPI RawDllMain(HINSTANCE, DWORD dwReason, LPVOID);
extern "C" BOOL (WINAPI* _pRawDllMain)(HINSTANCE, DWORD, LPVOID) = &RawDllMain;
#endif //!_USRDLL

/////////////////////////////////////////////////////////////////////////////
// Common DLL initialization

#ifdef _WINDLL
extern BOOL _afxSharedData; // set to TRUE if running Win32s
extern DWORD _afxAppTlsIndex;

extern "C" BOOL WINAPI RawDllMain(HINSTANCE, DWORD dwReason, LPVOID)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// make sure we have enough memory to attempt to start (8kb)
		void* pMinHeap = LocalAlloc(NONZEROLPTR, 0x2000);
		if (pMinHeap == NULL)
			return FALSE;   // fail if memory alloc fails
		LocalFree(pMinHeap);

		// cache Win32s version info
		if (_afxSharedData == (BOOL)-1)
		{
			DWORD dwVersion = ::GetVersion();
			_afxSharedData = (dwVersion & 0x80000000) && (BYTE)dwVersion <= 3;
		}

		// allocate initial thread local storage index
		if (_afxThreadTlsIndex == NULL_TLS)
		{
			_afxThreadTlsIndex = TlsAlloc();
			if (_afxThreadTlsIndex == NULL_TLS)
				return FALSE;   // failure
		}

		// initialize thread state for before constructors run
		AFX_THREAD_STATE* pThreadState = new AFX_THREAD_STATE;
		if (pThreadState == NULL)
			return FALSE;

		// initialize process state before constructors run
		AFX_APP_STATE* pAppState;
		if (_afxSharedData)
		{
			// Win32s: allocate thread local storage index if necessary
			if (_afxAppTlsIndex == NULL_TLS)
			{
				_afxAppTlsIndex = TlsAlloc();
				if (_afxAppTlsIndex == NULL_TLS)
					return FALSE;   // failure
			}

			// allocate AFX_APP_STATE structure for this process
			ASSERT(TlsGetValue(_afxAppTlsIndex) == NULL);
			pAppState = new AFX_APP_STATE;
			ASSERT(TlsGetValue(_afxAppTlsIndex) == pAppState);
			if (pAppState == NULL)
				return FALSE;   // failure
		}
		else
		{
			// Win32: use global buffer for app state instead
			pAppState = new AFX_APP_STATE;
			ASSERT(pAppState != NULL);
		}

		// make sure everything worked
		ASSERT(AfxGetAppState() == pAppState);
		ASSERT(AfxGetThreadState() == pThreadState);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// free the thread state (for primary thread)
		AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
		delete pThreadState;

		// free the process state
		AFX_APP_STATE* pAppState = AfxGetAppState();
		delete pAppState;
	}
	return TRUE;    // ok
}
#endif //_WINDLL

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\appwiz.v2\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\multipad.v2\mpinit.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/


/***************************************************************************
 *                                                                         *
 *  MODULE      : MpInit.c                                                 *
 *                                                                         *
 *  PURPOSE     : Contains initialization code for MultiPad.               *
 *                                                                         *
 *  FUNCTIONS   : InitializeApplication() - Sets up Class data structure   *
 *                                          and registers window class.    *
 *                                                                         *
 *                InitializeInstance ()   - Does a per-instance initial-   *
 *                                          ization of MultiPad. Creates   *
 *                                          the "frame" and MDI client.    *
 *                                                                         *
 ***************************************************************************/
#include "multipad.h"

CHAR szFrame[] = "mpframe";   /* Class name for "frame" window */
CHAR szChild[] = "mpchild";   /* Class name for MDI window     */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : InitializeApplication ()                                   *
 *                                                                          *
 *  PURPOSE    : Sets up the class data structures and does a one-time      *
 *               initialization of the app by registering the window classes*
 *                                                                          *
 *  RETURNS    : TRUE  - If RegisterClass() was successful for both classes.*
 *               FALSE - otherwise.                                         *
 *                                                                          *
 ****************************************************************************/

BOOL APIENTRY InitializeApplication()
{
    WNDCLASS    wc;

    /* Register the frame class */
    wc.style         = 0;
    wc.lpfnWndProc   = (WNDPROC) MPFrameWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance    = hInst;
    wc.hIcon         = LoadIcon(hInst,IDMULTIPAD);
    wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_APPWORKSPACE+1);
    wc.lpszMenuName  = IDMULTIPAD;
    wc.lpszClassName = szFrame;

    if (!RegisterClass (&wc) )
        return FALSE;

    /* Register the MDI child class */
    wc.lpfnWndProc   = (WNDPROC) MPMDIChildWndProc;
    wc.hIcon         = LoadIcon(hInst,IDNOTE);
    wc.lpszMenuName  = NULL;
    wc.cbWndExtra    = CBWNDEXTRA;
    wc.lpszClassName = szChild;

    if (!RegisterClass(&wc))
        return FALSE;

    return TRUE;

}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : InitializeInstance ()                                      *
 *                                                                          *
 *  PURPOSE    : Performs a per-instance initialization of MultiPad. It     *
 *               also creates the frame and an MDI window.                  *
 *                                                                          *
 *  RETURNS    : TRUE  - If initialization was successful.                  *
 *               FALSE - otherwise.                                         *
 *                                                                          *
 ****************************************************************************/
BOOL APIENTRY InitializeInstance(LPSTR lpCmdLine, INT nCmdShow)
{
    extern HWND  hwndMDIClient;
    CHAR         sz[80], *pCmdLine;
    HDC          hdc;
    HMENU        hmenu;

    /* Get the base window title */
    LoadString (hInst, IDS_APPNAME, sz, sizeof(sz));

    /* Create the frame */
    hwndFrame = CreateWindow (szFrame,
                              sz,
                              WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                              CW_USEDEFAULT,
                              0,
                              CW_USEDEFAULT,
                              0,
                              NULL,
                              NULL,
                              hInst,
                              NULL);

    if ((!hwndFrame) || (!hwndMDIClient))
        return FALSE;

    /* Load main menu accelerators */
    if (!(hAccel = LoadAccelerators (hInst, IDMULTIPAD)))
        return FALSE;

    /* Display the frame window */
    ShowWindow (hwndFrame, nCmdShow);
    UpdateWindow (hwndFrame);

    /* If the command line string is empty, nullify the pointer to it 
    ** else copy command line into our data segment 
    */
    if ( lpCmdLine && !(*lpCmdLine))
             pCmdLine = NULL;
    else {
        pCmdLine = (CHAR *) LocalAlloc(LPTR, lstrlen(lpCmdLine) + 1);
        if (pCmdLine)
           lstrcpy(pCmdLine, lpCmdLine);
    }

    /* Add the first MDI window */
    AddFile (pCmdLine);

    /* if we allocated a buffer then free it */
    if (pCmdLine)
        LocalFree((LOCALHANDLE) pCmdLine);

    /* Default to minimized windows after the first. */
    styleDefault = 0L;

    return TRUE;
        UNREFERENCED_PARAMETER(hmenu);
        UNREFERENCED_PARAMETER(hdc);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\multipad.v2\mpprint.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/***************************************************************************
 *                                                                         *
 *  MODULE      : MpPrint()                                                *
 *                                                                         *
 *  PURPOSE     : Printing code for MultiPad.                              *
 *                                                                         *
 *  FUNCTIONS   : GetPrinterDC ()          -  Creates a printer DC for the *
 *                                            default device.              *
 *                                                                         *
 *                AbortProc ()             -  Export proc. for GDI to check*
 *                                            print abort.                 *
 *                                                                         *
 *                PrintDlgProc ()          -  Dialog function for the print*
 *                                            cancel dialog.               *
 *                                                                         *
 *                PrintFile ()             -  Prints the contents of the   *
 *                                            edit control.                *
 *                                                                         *
 *                GetInitializationData () -  Gets DC initialisation data  *
 *                                            from a DC supporting         *
 *                                            ExtDeviceMode().                   *
 *                                                                         *
 ***************************************************************************/
#include "multipad.h"

BOOL fAbort;            /* TRUE if the user has aborted the print job    */
HWND hwndPDlg;          /* Handle to the cancel print dialog             */
CHAR szDevice[160];     /* Contains the device, the driver, and the port */
PSTR szDriver;          /* Pointer to the driver name                    */
PSTR szPort;            /* Port, ie, LPT1                                */
PSTR szTitle;           /* Global pointer to job title                   */
INT iPrinter = 0;       /* level of available printer support.           */
                        /* 0 - no printer available                      */
                        /* 1 - printer available                         */
                        /* 2 - driver supports 3.0 device initialization */
HANDLE hInitData=NULL;  /* handle to initialization data                 */

CHAR szExtDeviceMode[] = "EXTDEVICEMODE";

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetPrinterDC ()                                            *
 *                                                                          *
 *  PURPOSE    : Creates a printer display context for the default device.  *
 *               As a side effect, it sets the szDevice and szPort variables*
 *               It also sets iPrinter to the supported level of printing.  *
 *                                                                          *
 *  RETURNS    : HDC   - A handle to printer DC.                            *
 *                                                                          *
 ****************************************************************************/
HDC APIENTRY GetPrinterDC(BOOL bInformation)
{
    HDC      hdc;
    LPDEVMODE  lpdevmode = NULL;

    iPrinter = 0;

    /* Get the printer information from win.ini into a buffer and
     * null terminate it.
     */
    GetProfileString ( "windows", "device", "" ,szDevice, sizeof(szDevice));
    for (szDriver = szDevice; *szDriver && *szDriver != ','; szDriver++)
        ;
    if (*szDriver)
        *szDriver++ = 0;

    /* From the current position in the buffer, null teminate the
     * list of ports
     */
    for (szPort = szDriver; *szPort && *szPort != ','; szPort++)
        ;
    if (*szPort)
        *szPort++ = 0;

    /* if the device, driver and port buffers all contain meaningful data,
     * proceed.
     */
    if (!*szDevice || !*szDriver || !*szPort){
        *szDevice = 0;
        return NULL;
    }

    /* Create the printer display context */
    if (hInitData){
        /* Get a pointer to the initialization data */
        lpdevmode = (LPDEVMODE) LocalLock (hInitData);

        if (lstrcmp (szDevice, (LPSTR)lpdevmode)){
            /* User has changed the device... cancel this setup, as it is
             * invalid (although if we worked harder we could retain some
             * of it).
             */
            lpdevmode = NULL;
            LocalUnlock (hInitData);
            LocalFree (hInitData);
            hInitData = NULL;
        }
    }

    if (bInformation)
      hdc = CreateIC (szDriver, szDevice, szPort, lpdevmode);
   else
      hdc = CreateDC (szDriver, szDevice, szPort, lpdevmode);

    /* Unlock initialization data */
    if (hInitData)
        LocalUnlock (hInitData);

    if (!hdc)
        return NULL;


    iPrinter = 1;

    /* Find out if ExtDeviceMode() is supported and set flag appropriately */
    if (GetProcAddress (LoadLibrary(szDriver), szExtDeviceMode))
        iPrinter = 2;

    return hdc;

}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : AbortProc()                                                *
 *                                                                          *
 *  PURPOSE    : To be called by GDI print code to check for user abort.    *
 *                                                                          *
 ****************************************************************************/
INT APIENTRY AbortProc (
        HDC hdc,
        WORD reserved)
{
    MSG msg;

    /* Allow other apps to run, or get abort messages */
    while (!fAbort && PeekMessage (&msg, NULL, 0, 0, TRUE))
        if (!hwndPDlg || !IsDialogMessage (hwndPDlg, &msg)){
            TranslateMessage (&msg);
            DispatchMessage  (&msg);
        }
    return !fAbort;

        UNREFERENCED_PARAMETER(hdc);
        UNREFERENCED_PARAMETER(reserved);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PrintDlgProc ()                                            *
 *                                                                          *
 *  PURPOSE    : Dialog function for the print cancel dialog box.           *
 *                                                                          *
 *  RETURNS    : TRUE  - OK to abort/ not OK to abort                       *
 *               FALSE - otherwise.                                         *
 *                                                                          *
 ****************************************************************************/
BOOL APIENTRY PrintDlgProc(HWND hwnd, UINT msg, WORD wParam, LONG lParam)
{
    switch (msg){
        case WM_INITDIALOG:
            /* Set up information in dialog box */
            SetDlgItemText (hwnd, IDD_PRINTDEVICE, (LPSTR)szDevice);
            SetDlgItemText (hwnd, IDD_PRINTPORT, (LPSTR)szPort);
            SetDlgItemText (hwnd, IDD_PRINTTITLE, (LPSTR)szTitle);
            break;

        case WM_COMMAND:
            /* abort printing if the only button gets hit */
            fAbort = TRUE;
            break;

        default:
            return FALSE;
    }
    return TRUE;
        UNREFERENCED_PARAMETER(wParam);
        UNREFERENCED_PARAMETER(lParam);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PrintFile ()                                               *
 *                                                                          *
 *  PURPOSE    : Prints the contents of the edit control.                   *
 *                                                                          *
 ****************************************************************************/

VOID APIENTRY PrintFile(HWND hwnd)
{
    HDC     hdc;
    INT     yExtPage;
    CHAR    sz[32];
    int     cch;
    WORD    ich;
    PSTR    pch;
    WORD    iLine;
    WORD    nLinesEc;
    WORD    i;
    HANDLE  hT;
    HWND    hwndPDlg;
    DWORD   dy;
    INT     yExtSoFar;
    WORD    fError = TRUE;
    HWND    hwndEdit;

    hwndEdit = (HWND)GetWindowLong(hwnd,GWL_HWNDEDIT);

    /* Create the job title by loading the title string from STRINGTABLE */
    cch = LoadString (hInst, IDS_PRINTJOB, sz, sizeof(sz));
    szTitle = sz + cch;
    cch += GetWindowText (hwnd, sz + cch, 32 - cch);
    sz[31] = 0;

    /* Initialize the printer */
    hdc = GetPrinterDC(FALSE);
    if (!hdc)
        goto getout5;

    /* Disable the main application window and create the Cancel dialog */
    EnableWindow (hwndFrame, FALSE);

    hwndPDlg = CreateDialog (hInst, IDD_PRINT, hwnd, (DLGPROC) PrintDlgProc);

    if (!hwndPDlg)
        goto getout3;
    ShowWindow (hwndPDlg, SW_SHOW);
    UpdateWindow (hwndPDlg);

    /* Allow the app. to inform GDI of the escape function to call */
    if (Escape(hdc, SETABORTPROC, 0, (LPSTR)AbortProc, NULL) < 0)
        goto getout1;

    /* Initialize the document */
    if (Escape(hdc, STARTDOC, cch, (LPSTR)sz, NULL) < 0)
        goto getout1;

    /* Get the height of one line and the height of a page */
    {
    SIZE tmp;
    GetTextExtentPoint(hdc, "CC", 2, &tmp );
    dy = tmp.cy;
    }

    yExtPage = GetDeviceCaps(hdc, VERTRES);

    /* Get the lines in document and and a handle to the text buffer */
    iLine     = 0;
    yExtSoFar = 0;
    nLinesEc  = (WORD)SendMessage (hwndEdit, EM_GETLINECOUNT, 0, 0L);
    hT        = (HANDLE)SendMessage (hwndEdit, EM_GETHANDLE, 0, 0L);

    /* While more lines print out the text */
    while (iLine < nLinesEc){
        if (yExtSoFar + (int) dy > yExtPage){
            /* Reached the end of a page. Tell the device driver to eject a
             * page
             */
            if (Escape(hdc, NEWFRAME, 0, NULL, NULL) < 0 || fAbort)
                goto getout2;
            yExtSoFar = 0;
        }

        /* Get the length and position of the line in the buffer
         * and lock from that offset into the buffer */
        ich = (WORD)SendMessage (hwndEdit, EM_LINEINDEX, iLine, 0L);
        cch = (WORD)SendMessage (hwndEdit, EM_LINELENGTH, ich, 0L);
        pch = (PSTR)LocalLock(hT) + ich;

        /* Print the line and unlock the text handle */
        TextOut (hdc, 0, yExtSoFar, (LPSTR)pch, cch);
        LocalUnlock (hT);

        /* Test and see if the Abort flag has been set. If yes, exit. */
        if (fAbort)
            goto getout2;

        /* Move down the page */
        yExtSoFar += dy;
        iLine++;
    }

    /* Eject the last page. */
    if (Escape(hdc, NEWFRAME, 0, NULL, NULL) < 0)
        goto getout2;

    /* Complete the document. */
    if (Escape(hdc, ENDDOC, 0, NULL, NULL) < 0){
getout2:
        /* Ran into a problem before NEWFRAME? Abort the document */
        Escape( hdc, ABORTDOC, 0, NULL, NULL);
    }
    else
        fError=FALSE;

getout3:
    /* Close the cancel dialog and re-enable main app. window */
    EnableWindow (hwndFrame, TRUE);
    DestroyWindow (hwndPDlg);

getout1:
    DeleteDC(hdc);

getout5:
#ifdef WIN16
    /* Get rid of dialog procedure instances */
    FreeProcInstance (lpfnPDlg);
#endif

#ifdef WIN16
getout4:
    FreeProcInstance (lpfnAbort);
getout:
#endif

    /* Error? make sure the user knows... */
    if (fError)
        MPError (hwnd, MB_OK | MB_ICONEXCLAMATION, IDS_PRINTERROR, (LPSTR)szTitle);

    return;
        UNREFERENCED_PARAMETER(i);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetInitializationData()                                    *
 *                                                                          *
 *  PURPOSE    : Gets DC initialization data from a printer driver          *
 *               supporting ExtDeviceMode(). Called in response to the      *
 *               File/Printer setup menu selection.                         *
 *                                                                          *
 *               This function allows the user to change the printer        *
 *               settings FOR MULTIPAD ONLY.  This allows Multipad to print *
 *               in a variety of settings without messing up any other      *
 *               applications. In a more sophisticated application, this    *
 *               setup could even be saved on a document-by-document basis. *
 *                                                                          *
 ****************************************************************************/
BOOL APIENTRY GetInitializationData( HWND hwnd )
{
    LPSTR     lpOld;
    LPSTR     lpNew;
    FARPROC   lpfn;
    HANDLE    hT,hDrv;
    CHAR      sz[32];
    int           cb;
    INT       flag;

    /* Pop up dialog for user and retain data in app buffer */
    flag = DM_PROMPT | DM_COPY;

    /* Load the device driver and find the ExtDeviceMode() function */
    wsprintf (sz, "%s.drv", (LPSTR)szDriver);
    if ((int)(hDrv = LoadLibrary (sz)) < 32)
        return FALSE;
    if (!(lpfn = GetProcAddress (hDrv, szExtDeviceMode)))
        return FALSE;

    if (hInitData){
        /* We have some old data... we want to modify the previously specified
         * setup rather than starting with the default setup.
         */
        lpOld = (LPSTR)LocalLock(hInitData);
        flag |= DM_MODIFY;
    }
    else
        lpOld = NULL;

    /* Get the number of bytes needed for the init data */
    cb = (*lpfn) (hwnd,
                  hDrv,
                  (LPDEVMODE)NULL,
                  (LPSTR)szDevice,
                  (LPSTR)szPort,
                  (LPDEVMODE)NULL,
                  (LPSTR)NULL,
                  0);

    /* Grab some memory for the new data and lock it. */
    hT    = LocalAlloc (LHND,cb);
    if(!hT){
        MessageBox(hwnd, "<GetInitializationData> Not enough memory.", NULL, MB_OK | MB_ICONHAND);
            LocalUnlock(hInitData);
            LocalFree(hInitData);
        FreeLibrary(hDrv);
        return(FALSE);
    }

    lpNew = (LPSTR)LocalLock (hT);

    /* Post the device mode dialog. 0 flag iff user hits OK button */
    if ((*lpfn) (hwnd,
                 hDrv,
                 (LPDEVMODE)lpNew,
                 (LPSTR)szDevice,
                 (LPSTR)szPort,
                 (LPDEVMODE)lpOld,
                 (LPSTR)NULL,
                 flag)==IDOK)
        flag = 0;

    /* Unlock the input structures */
    LocalUnlock (hT);

    if (hInitData)
        LocalUnlock (hInitData);

    /* If the user hit OK and everything worked, free the original init.
     * data and retain the new one.  Otherwise, toss the new buffer.
     */
    if (flag)
        LocalFree (hT);
    else{
        if (hInitData)
            LocalFree (hInitData);
        hInitData = hT;
    }

    FreeLibrary(hDrv);
    return (!flag);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\multipad.v2\mpfile.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/***************************************************************************
 *                                                                         *
 *  MODULE    : MpFile.c                                                   *
 *                                                                         *
 *  PURPOSE   : Contains the code for File I/O for Multipad.               *
 *                                                                         *
 *  FUNCTIONS : AlreadyOpen   - Determines if a file is already open.      *
 *                                                                         *
 *              AddFile       - Creates a new MDI window and, if specified,*
 *                              loads a file into it.                      *
 *                                                                         *
 *              LoadFile      - Loads a file into a MDI window.            *
 *                                                                         *
 *              MyReadFile    - Calls File/Open dialog and appropriately   *
 *                              responds to the user's input.              *
 *                                                                         *
 *              SaveFile      - Saves the contents of a MDI window's edit  *
 *                              control to a file.                         *
 *                                                                         *
 *              SetSaveFrom   - Formats the "Save 'file' to" string.       *
 *                                                                         *
 *              SaveAsDlgProc - Dialog function for the File/SaveAs dialog.*
 *                                                                         *
 *              ChangeFile    - Calls File/SaveAs dialog.                  *
 *                                                                         *
 ***************************************************************************/
#include "multipad.h"
#include <fcntl.h>
#include <SYS\types.h>
#include <SYS\stat.h>
#include <io.h>
#include <string.h>

VOID APIENTRY GetFileName(PSTR);
//INT APIENTRY DialogBoxParam(HANDLE,LPSTR,HWND,FARPROC,LONG);
//LPSTR WINAPI AnsiUpper(LPSTR);

OFSTRUCT        of;
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : AlreadyOpen(szFile)                                        *
 *                                                                          *
 *  PURPOSE    : Checks to see if the file described by the string pointed  *
 *               to by 'szFile' is already open.                            *
 *                                                                          *
 *  RETURNS    : a handle to the described file's window if that file is    *
 *               already open;  NULL otherwise.                             *
 *                                                                          *
 ****************************************************************************/

HWND AlreadyOpen(CHAR *szFile)
{
    INT     iDiff;
    HWND    hwndCheck;
    CHAR    szChild[64];
    LPSTR   lpChild, lpFile;
    HFILE     wFileTemp;

    /* Open the file with the OF_PARSE flag to obtain the fully qualified
     * pathname in the OFSTRUCT structure.
     */
    wFileTemp = OpenFile((LPSTR)szFile, (LPOFSTRUCT)&of, OF_PARSE);
    if (! wFileTemp)
        return(NULL);
    _lclose(wFileTemp);

    /* Check each MDI child window in Multipad */
    for (   hwndCheck = GetWindow(hwndMDIClient, GW_CHILD);
            hwndCheck;
            hwndCheck = GetWindow(hwndCheck, GW_HWNDNEXT)   ) {
        /* Initialization  for comparison */
        lpChild = szChild;
        lpFile = (LPSTR)AnsiUpper((LPSTR) of.szPathName);
        iDiff = 0;

        /* Skip icon title windows */
        if (GetWindow(hwndCheck, GW_OWNER))
            continue;

        /* Get current child window's name */
        GetWindowText(hwndCheck, lpChild, 64);

        /* Compare window name with given name */
        while ((*lpChild) && (*lpFile) && (!iDiff)){
            if (*lpChild++ != *lpFile++)
                iDiff = 1;
        }

        /* If the two names matched, the file is already   */
        /* open -- return handle to matching child window. */
        if (!iDiff)
            return(hwndCheck);
    }
    /* No match found -- file is not open -- return NULL handle */
    return(NULL);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : AddFile (lpName)                                           *
 *                                                                          *
 *  PURPOSE    : Creates a new MDI window. If the lpName parameter is not   *
 *               NULL, it loads a file into the window.                     *
 *                                                                          *
 *  RETURNS    : HWND  - A handle to the new window.                        *
 *                                                                          *
 ****************************************************************************/

HWND APIENTRY AddFile(CHAR * pName)
{
    HWND hwnd;

    CHAR            sz[160];
    MDICREATESTRUCT mcs;

    if (!pName) {
        /* The pName parameter is NULL -- load the "Untitled" string from */
        /* STRINGTABLE and set the title field of the MDI CreateStruct.    */
        LoadString (hInst, IDS_UNTITLED, sz, sizeof(sz));
        mcs.szTitle = (LPSTR)sz;
    }
    else
        /* Title the window with the fully qualified pathname obtained by
         * calling OpenFile() with the OF_PARSE flag (in function
         * AlreadyOpen(), which is called before AddFile().
         */
        mcs.szTitle = of.szPathName;

    mcs.szClass = szChild;
    mcs.hOwner  = hInst;

    /* Use the default size for the window */
    mcs.x = mcs.cx = CW_USEDEFAULT;
    mcs.y = mcs.cy = CW_USEDEFAULT;

    /* Set the style DWORD of the window to default */
    mcs.style = styleDefault;

    /* tell the MDI Client to create the child */
    hwnd = (HWND)SendMessage (hwndMDIClient,
                              WM_MDICREATE,
                              0,
                              (LONG)(LPMDICREATESTRUCT)&mcs);

    /* Did we get a file? Read it into the window */
    if (pName){
        if (!LoadFile(hwnd, pName)){
            /* File couldn't be loaded -- close window */
            SendMessage(hwndMDIClient, WM_MDIDESTROY, (DWORD) hwnd, 0L);
        }
    }

    return hwnd;
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : LoadFile (lpName)                                          *
 *                                                                          *
 *  PURPOSE    : Given the handle to a MDI window and a filename, reads the *
 *               file into the window's edit control child.                 *
 *                                                                          *
 *  RETURNS    : TRUE  - If file is sucessfully loaded.                     *
 *               FALSE - Otherwise.                                         *
 *                                                                          *
 ****************************************************************************/

INT APIENTRY LoadFile (
        HWND hwnd,
        CHAR * pName)
{
    LONG   wLength;
    HANDLE hT;
    LPSTR  lpB;
    HWND   hwndEdit;
    HFILE  fh;
        OFSTRUCT  of;
    hwndEdit = (HWND)GetWindowLong (hwnd, GWL_HWNDEDIT);

    /* The file has a title, so reset the UNTITLED flag. */
    SetWindowWord(hwnd, GWW_UNTITLED, FALSE);

    fh = OpenFile(pName, &of, OF_READ);  /* JAP was 0, which is OF_READ)*/

    /* Make sure file has been opened correctly */
    if ( fh < 0 )
        goto error;

    /* Find the length of the file */
    wLength = (DWORD)_llseek(fh, 0L, 2);
    _llseek(fh, 0L, 0);

    /* Attempt to reallocate the edit control's buffer to the file size */
    hT = (HANDLE)SendMessage (hwndEdit, EM_GETHANDLE, 0, 0L);
    if (LocalReAlloc(hT, wLength+1, LHND) == NULL) {
        /* Couldn't reallocate to new size -- error */
        _lclose(fh);
        goto error;
    }

    /* read the file into the buffer */
    if (wLength != (LONG)_lread(fh, (lpB = (LPSTR)LocalLock (hT)), (UINT)wLength))
        MPError (hwnd, MB_OK|MB_ICONHAND, IDS_CANTREAD, (LPSTR)pName);

    /* Zero terminate the edit buffer */
    lpB[wLength] = 0;
    LocalUnlock (hT);

    SendMessage (hwndEdit, EM_SETHANDLE, (UINT)hT, 0L);
    _lclose(fh);

    return TRUE;

error:
    /* Report the error and quit */
    MPError(hwnd, MB_OK | MB_ICONHAND, IDS_CANTOPEN, (LPSTR)pName);
    return FALSE;
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MyReadFile(hwnd)                                           *
 *                                                                          *
 *  PURPOSE    : Called in response to a File/Open menu selection. It asks  *
 *               the user for a file name and responds appropriately.       *
 *                                                                          *
 ****************************************************************************/

VOID APIENTRY MyReadFile(HWND hwnd)
{
    CHAR    szFile[128];
    HWND    hwndFile;

    GetFileName (szFile);

    /* If the result is not the empty string -- take appropriate action */
    if (*szFile) {
            /* Is file already open?? */
            if (hwndFile = AlreadyOpen(szFile)) {
                /* Yes -- bring the file's window to the top */
                BringWindowToTop(hwndFile);
            }
            else {
                /* No -- make a new window and load file into it */
                AddFile(szFile);
            }
    }
        UNREFERENCED_PARAMETER(hwnd);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SaveFile (hwnd)                                            *
 *                                                                          *
 *  PURPOSE    : Saves contents of current edit control to disk.            *
 *                                                                          *
 ****************************************************************************/

VOID APIENTRY SaveFile(HWND hwnd)
{
    HANDLE   hT;
    LPSTR    lpT;
    CHAR     szFile[128];
    INT      cch;
    INT      fh;
//    OFSTRUCT of;
    HWND     hwndEdit;

    PSTR     pch;

    hwndEdit = (HWND)GetWindowLong ( hwnd, GWL_HWNDEDIT);
    GetWindowText (hwnd, szFile, sizeof(szFile));

    /* If there is no extension (control is 'Untitled') add .TXT as extension */
    for (cch = FALSE, lpT = szFile; *lpT; lpT++)
        switch (*lpT){
            case '.':
                 cch = TRUE;
                 break;

            case '\\':
            case ':' :
                 cch = FALSE;
                 break;
        }
    if (!cch)
        LoadString (hInst, IDS_ADDEXT, lpT, lpT - (LPSTR)szFile);

    fh = open(szFile, O_BINARY | O_WRONLY | O_CREAT, S_IWRITE);

    /* If file could not be opened, quit */
    if (fh < 0){
        MPError (hwnd, MB_OK | MB_ICONHAND, IDS_CANTCREATE, (LPSTR)szFile);
        return;
    }

    /* Find out the length of the text in the edit control */
    cch = GetWindowTextLength (hwndEdit);

    /* Obtain a handle to the text buffer */
    hT  = (HANDLE)SendMessage (hwndEdit, EM_GETHANDLE, 0, 0L);
    lpT = (LPSTR)LocalLock (hT);

    /* Write out the contents of the buffer to the file. */
    if (cch != write(fh, lpT, cch))
        MPError (hwnd, MB_OK | MB_ICONHAND, IDS_CANTWRITE, (LPSTR)szFile);

    /* Clean up */
    LocalUnlock (hT);
    SendMessage (hwndEdit, EM_SETHANDLE, (UINT)hT, 0L);

    close(fh);

    return;
        UNREFERENCED_PARAMETER(pch);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SetSaveFrom ()                                             *
 *                                                                          *
 *  PURPOSE    : Formats the "Save 'file' to .." string.                    *
 *                                                                          *
 ****************************************************************************/

VOID NEAR PASCAL SetSaveFrom (
        HWND hwnd,
        PSTR psz)
{
    CHAR szFmt[32];
    CHAR szText[160];

    /* The text string in the .RC file contains the format string... */
    GetDlgItemText( hwnd, IDD_SAVEFROM, szFmt, sizeof(szFmt));

    /* NOTE: this (LPSTR) cast MUST be here... wsprintf() is a cdecl
     * (C calling conventions) function with varying args... there is
     * no way for the compiler to know that all strings must be LPSTR's
     * and do the conversion, so we have to be careful about wsprintf()'s.
     */
    wsprintf ( szText, szFmt, (LPSTR)psz);

    /* set the text in the static control */
    SetDlgItemText (hwnd, IDD_SAVEFROM, szText);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SaveAsDlgProc(hwnd, message, wParam, lParam)               *
 *                                                                          *
 *  PURPOSE    : Dialog function File/SaveAs. It waits for a filename, and  *
 *               then calls SaveFile or cancels the operation.              *
 *                                                                          *
 ****************************************************************************/

BOOL APIENTRY SaveAsDlgProc(
        HWND hwnd,
        UINT message,
        UINT wParam,
        LONG lParam)
{
    CHAR   sz[64];
    CHAR   *pch;
    BOOL   fExt;
    HWND   hwndSave;

    switch (message){

        case WM_INITDIALOG:

            /* Identify the window whose contents we're saving */
#ifdef ORGCODE
            hwndSave = LOWORD (lParam);
#else
                hwndSave = (HWND)lParam;                /*passed in from another procedure*/
#endif
            /* Set it's name in the property list */
            SetProp (hwnd, PROP_FILENAME, hwndSave);

            GetWindowText (hwndSave, sz, sizeof(sz));

            /* Set the save from string... */
            SetSaveFrom (hwnd,sz);

            /* Generate a filename complete with extension */
            AnsiUpper (sz);
            for (fExt = FALSE, pch = sz; *pch; pch++)
                if (*pch == '.')
                    fExt = TRUE;
                else if (*pch == '\\')
                    fExt = FALSE;
            if (!fExt)
                LoadString (hInst, IDS_ADDEXT, (LPSTR)pch, pch - sz);

            /* Display the filename in the edit control */
            SetDlgItemText (hwnd, IDD_SAVETO, sz);

            /* Select the entire range of text */
            SendMessage(GetDlgItem(hwnd, IDD_SAVETO), EM_SETSEL, GET_EM_SETSEL_MPS(0, 100));

            DlgDirList (hwnd, "*.*", (INT)IDD_DIRS, (INT)IDD_PATH, (WORD)ATTR_DIRS);

            /* enable OK butto iff edit control is nonempty */
            if (!*sz)
                EnableWindow (GetDlgItem (hwnd, IDOK), FALSE);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case IDCANCEL:
                    /* Abort operation */
                    EndDialog(hwnd,1);
                    break;

                case IDOK:
                   /*  Just change the title of the MDI child. The calling
                    *  function of ChangeFile(), which uses the title text
                    *  for the filename, will do the actual save.
                    */
                    hwndSave = GetProp (hwnd, PROP_FILENAME);
                    GetDlgItemText (hwnd, IDD_SAVETO, sz, sizeof(sz));
                    AnsiUpper ((LPSTR)sz);
                    SetWindowText (hwndSave, sz);
                    EndDialog (hwnd, 0);
                    break;

                case IDD_SAVETO:
                   /* If the edit control changes, check to see if its empty.
                    * enable OK if it contains something
                    */
                    if (HIWORD (lParam) != EN_CHANGE)
                        return FALSE;
                    EnableWindow (GetDlgItem (hwnd, IDOK),
                                SendDlgItemMessage (hwnd,
                                                   IDD_SAVETO,
                                                   WM_GETTEXTLENGTH,
                                                   0,
                                                   0L));
                    break;

                case IDD_DIRS:
                    if (HIWORD(lParam)==LBN_DBLCLK){
                        CHAR szT[64];

                        DlgDirSelectEx(hwnd, szT, 64, IDD_DIRS);
                        lstrcat ( szT, "*.*");
                        DlgDirList (hwnd, szT, (INT)IDD_DIRS, (INT)IDD_PATH, (WORD)ATTR_DIRS);
                        break;
                    }
                    return FALSE;

                default:
                    return FALSE;
            }

        default:
            return FALSE;
    }
    return TRUE;
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : ChangeFile (hwnd)                                          *
 *                                                                          *
 *  PURPOSE    : Invokes the File/SaveAs dialog.                            *
 *                                                                          *
 *  RETURNS    : TRUE  - if user selected OK or NO.                         *
 *               FALSE - otherwise.                                         *
 *                                                                          *
 ****************************************************************************/

BOOL APIENTRY ChangeFile (HWND hwnd)
{
    INT     i;

#ifdef NOTCOMMONDIALOGS
    i = DialogBoxParam (hInst, IDD_SAVEAS, hwnd, SaveAsDlgProc, (LONG)hwnd);
    if (!i)
            SetWindowWord (hwnd, GWW_UNTITLED, 0);
    return !i;
#else
    OPENFILENAME ofn;
    CHAR szFilterSpec [128] =                       /* file type filters */
             "TEXT FILES(*.TXT)\0*.txt\0";

    #define MAXFILENAME 256
    CHAR szFileName[MAXFILENAME];
    CHAR szFileTitle[MAXFILENAME];

    strcpy(szFileName, "");   /* these need be NULL*/
    strcpy(szFileTitle, "");

    /* fill in non-variant fields of OPENFILENAME struct. */
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hwnd;
    ofn.lpstrFilter       = szFilterSpec;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = szFileName;
    ofn.nMaxFile          = MAXFILENAME;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrFileTitle    = szFileTitle;
    ofn.nMaxFileTitle     = MAXFILENAME;
    ofn.lpstrTitle        = "Save TextFiles";
    ofn.lpstrDefExt       = "TXT";
    ofn.Flags             = 0;
    /* Use standard open dialog */
    i = GetSaveFileName ((LPOPENFILENAME)&ofn);
    if (i)
	{
        AnsiUpper ((LPSTR)ofn.lpstrFile);
        SetWindowText (hwnd, ofn.lpstrFile);
        SetWindowWord (hwnd, GWW_UNTITLED, 0);
	}
    return i;
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\multipad.v2\mpopen.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/***************************************************************************
 *                                                                         *
 *  MODULE      : MpOpen.c                                                 *
 *                                                                         *
 *  PURPOSE     : Contains the file open dialog function and it's helper   *
 *                functions.                                               *
 *                                                                         *
 *  FUNCTIONS   : IsWild ()           - Ascertains that the input string   *
 *                                      contains a DOS wildcard character. *
 *                                                                         *
 *                SelectFile()        - If filename supplied contains a    *
 *                                      wildcard, this function fills the  *
 *                                      listboxes in File/Open dialog, else*
 *                                      the dialog is closed.              *
 *                                                                         *
 *                FileOpenDlgProc()   - Dialog funcion for the File/Open   *
 *                                      dialog.                            *
 *                                                                         *
 *                GetFileName ()      - Gets a file name from the user.    *
 *                                                                         *
 ***************************************************************************/
#include "multipad.h"
#include <fcntl.h>
#include <io.h>
#include <string.h>
CHAR szPropertyName [] = "FILENAME";/* Name of the File name property list item */



/****************************************************************************
 *                                                                          *
 *  FUNCTION   : IsWild ( psz )                                             *
 *                                                                          *
 *  PURPOSE    : Checks if the string (referenced by a NEAR pointer)        *
 *               contains a DOS wildcard character ("*" or "?").            *
 *                                                                          *
 *  RETURNS    : TRUE  - iff the string contains a wildcard character.      *
 *               FALSE - otherwise.                                  .      *
 *                                                                          *
 ****************************************************************************/
BOOL NEAR PASCAL IsWild(register PSTR psz)
{
    for(;;)
        switch (*psz++){
            case '*':
            case '?':
                /* Found wildcard */
                return TRUE;

            case 0:
                /* Reached end of string */
                return FALSE;

            default:
                continue;
        }
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : FileExists(pch)                                            *
 *                                                                          *
 *  PURPOSE    : Checks to see if a file exists with the path/filename      *
 *               described by the string pointed to by 'pch'.               *
 *                                                                          *
 *  RETURNS    : TRUE  - if the described file does exist.                  *
 *               FALSE - otherwise.                                         *
 *                                                                          *
 ****************************************************************************/


BOOL FileExists(PSTR pch)
{
        int fh;

        if ((fh = open(pch, O_RDONLY)) < 0)
             return(FALSE);

        _lclose(fh);
        return(TRUE);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SelectFile ( hwnd )                                        *
 *                                                                          *
 *  PURPOSE    : Reads the string in the edit control of the File/Open      *
 *               dialog. If it contains a wildcard, then it attempts to     *
 *               fill the listboxes in the File/Open dialog. Othewise it    *
 *               ends the dialog. Modifies the FILENAME item in the property*
 *               list of the window.                                        *
 *                                                                          *
 ****************************************************************************/

VOID NEAR PASCAL SelectFile(register HWND hwnd)
{
    register PSTR pch;
    PSTR          pch2;

    /* Get handle (near address) to filename data in window's property list */
    pch = (PSTR)GetProp (hwnd, PROP_FILENAME);

    /* Get the text from the dialog's edit control into this address */
    GetDlgItemText (hwnd, IDD_FILENAME, pch, 64);

    if ( IsWild (pch)){
        /* Select the directory and make a listing of the directories */
        DlgDirList(hwnd, (LPSTR)pch, (int)IDD_DIRS, (int)IDD_PATH, (WORD)ATTR_DIRS);

        /* Obtain the filename-only part of the path in the edit control */
        for (pch2 = pch; *pch; pch++)
            if (*pch == '\\' || *pch == ':')
                pch2 = pch + 1;

        /* List the files in this directory based on the wildcard. */
        DlgDirList(hwnd, (LPSTR)pch2, IDD_FILES, IDD_PATH, ATTR_FILES);

        /* Set the dialog's edit control to the filename part of path
         * string.
         */
        SetDlgItemText (hwnd, IDD_FILENAME, pch2);
    }
    else
    {
        /* The filename in the property list is not a wildcard */
        if (FileExists (pch)){

            RemoveProp (hwnd, PROP_FILENAME);
            EndDialog (hwnd, 0);
        }
        else{
            MPError ( hwnd, MB_OK | MB_SYSTEMMODAL, IDS_CANTOPEN, (LPSTR) pch);
            SetActiveWindow (hwnd);
        }
    }
}



/****************************************************************************
 *                                                                          *
 *  FUNCTION   : FileOpenDlgProc()                                          *
 *                                                                          *
 *  PURPOSE    : Dialog function for the File/Open dialog. Takes care of    *
 *               calling the appropriate functions for extracting the       *
 *               filename and wildcard, filling the listboxes and changing  *
 *               the FILENAME item in the property list for the window.     *
 *                                                                          *
 ****************************************************************************/

BOOL APIENTRY FileOpenDlgProc (
        register HWND hwnd,
        WORD          message,
        register UINT wParam,
        LONG          lParam)
{
    PSTR pch;

    switch (message){

        case WM_INITDIALOG:
            /* Set the default file extension on edit window, and try to
             * get a listing of the files and directories.
             */
            SetDlgItemText ( hwnd, IDD_FILENAME, DEFFILESEARCH);
            SetProp (hwnd, PROP_FILENAME, (HANDLE) lParam);
            SendDlgItemMessage (hwnd, IDD_FILENAME, EM_LIMITTEXT, 64, 0L);
            SelectFile (hwnd);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    SelectFile(hwnd);
                    break;

                case IDCANCEL:
                    /* Set the filename in the prop. list to NULL and quit */
                    pch  = (PSTR) GetProp (hwnd, PROP_FILENAME);
                    *pch = 0;
                    EndDialog (hwnd, 0);
                    break;

                case IDD_FILENAME:
                    /* Enable the OK button if the edit control has text. */
                    EnableWindow ( GetDlgItem (hwnd, IDOK),
                                   GetWindowTextLength (GET_WM_COMMAND_HWND(wParam, lParam)));
                    break;

                case IDD_FILES:

                    /* The files listbox. If file selection has changed, fill
                     * the new filename into the property list buffer and set
                     * text in edit control.
                     */
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE){
                            pch = (PSTR) GetProp (hwnd, PROP_FILENAME);
                            DlgDirSelectEx(hwnd, (LPSTR)pch, 128, IDD_FILES);
                            SetDlgItemText (hwnd, IDD_FILENAME, (LPSTR)pch);
                    }
                    else if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)
                            /* if the item was double-clicked, try to open it */
                            SelectFile(hwnd);
                    break;

                case IDD_DIRS:

                    /* The directories listbox. Append current filename in edit
                     * control (stripped of the path prefix) to the name from
                     * the property list and set the new string in the edit
                     * control.
                     */
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE) {

                            PSTR pch2, pchT, pchS;

                            pch = (PSTR) GetProp (hwnd, PROP_FILENAME);

                            /* Get the new drive/dir */
                            DlgDirSelectEx(hwnd, pch, 128, IDD_DIRS);
                            pch2 = pch + lstrlen(pch);

                            /* Fetch current contents of dialog's edit control and append
                             * it to name from property list... */
                            GetDlgItemText(hwnd,IDD_FILENAME,(LPSTR)pch2,64);
                            if (*pch2 == 0){
                                SetDlgItemText(hwnd, IDD_FILENAME, DEFFILESEARCH);
                                GetDlgItemText(hwnd,IDD_FILENAME,(LPSTR)pch2,64);
                            }
                            else {
                                pchS = pch;
                                for (pchT = pch = pch2; *pch; pch++) {
                                        if (*pch == '\\' || *pch == ':')
                                            pchT = pch2;
                                        else
                                            *pchT++ = *pch;
                                }
                                *pchT = 0;
                                pch = pchS;
                            }

                            /* Set the edit control with new string */
                            SetDlgItemText (hwnd, IDD_FILENAME, (LPSTR)pch);
                    }
                    else if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)
                            SelectFile (hwnd);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetFilename ( pstr )                                       *
 *                                                                          *
 *  PURPOSE    : Gets a filename from the user by calling the File/Open     *
 *               dialog.                                                    *
 *                                                                          *
 ****************************************************************************/
VOID APIENTRY GetFileName(PSTR pstr)
{
#ifdef NOTCOMMONDIALOGS
    DialogBoxParam (hInst, IDD_FILEOPEN, hwndFrame, FileOpenDlgProc, (LONG)pstr);
#else
    OPENFILENAME ofn;
    CHAR szFilterSpec [128] =                       /* file type filters */
             "TEXT FILES(*.TXT)\0*.TXT\0";

    #define MAXFILENAME 256
    CHAR szFileName[MAXFILENAME];
    CHAR szFileTitle[MAXFILENAME];

    strcpy(szFileName, "");   /* these need be NULL*/
    strcpy(szFileTitle, "");

    /* fill in non-variant fields of OPENFILENAME struct. */
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = NULL;
    ofn.lpstrFilter       = szFilterSpec;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = szFileName;
    ofn.nMaxFile          = MAXFILENAME;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrFileTitle    = szFileTitle;
    ofn.nMaxFileTitle     = MAXFILENAME;
    ofn.lpstrTitle        = "Open TextFiles";
    ofn.lpstrDefExt       = "TXT";
    ofn.Flags             = OFN_FILEMUSTEXIST;
    /* Use standard open dialog */
    if (!GetOpenFileName ((LPOPENFILENAME)&ofn)){
        *pstr = 0;
        MessageBox(hwndFrame, " FileOpen FAILed!", "Multipad", MB_OK | IDOK);
    }
    else{
        strcpy(pstr, ofn.lpstrFile);
    }
 
#endif
   return;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\appmodul.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// export WinMain to force linkage to this module

extern int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpCmdLine, int nCmdShow);

#ifdef _MAC
extern "C" int PASCAL
#else
extern "C" int WINAPI
#endif
_tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpCmdLine, int nCmdShow)
{
	return AfxWinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow);
}

/////////////////////////////////////////////////////////////////////////////
// initialize app state such that it points to this module's core state

class _AFX_TERM_APP_STATE
{
public:
	~_AFX_TERM_APP_STATE();
};

_AFX_TERM_APP_STATE::~_AFX_TERM_APP_STATE()
{
	AfxTermLocalData(NULL);
}

// force initialization early
#pragma warning(disable: 4074)
#pragma init_seg(lib)

_AFX_TERM_APP_STATE _afxTermAppState;

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\multipad.v2\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by MULTIPAD.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\aboutdlg.cpp ===
// aboutdlg.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "aboutdlg.h"
#include "version.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog

// About Box : Product information
// NOTE: Do not change PRODINFO structure without consulting w/Setup owner;
// Setup directly modifies 'licenceName' and 'licenceCompany' and expects them
// to be of fixed length (Cuda 2414: a-jonj, 2-26-93)
struct PRODINFO
{
	CHAR licenseName[30];
	CHAR licenseCompany[30];
	CHAR serialNumber[20];
};

//
// About Box : Product information
// Setup searches for this information in the exe and overwrites
// it with the real user's name and company.
//
struct PRODINFO productInfo =
{
#ifdef _DEBUG
	/* szVerUser,*/
	"Microsoft Team C++",
#else
	"This is an unauthorized copy",	// Registered user name
	"of Microsoft Spy++",			// Company name
#endif
	"33148253781"					// Serial # (not displayed)
};


CAboutDlg::CAboutDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAboutDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAboutDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
	ON_WM_DRAWITEM()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg message handlers

BOOL CAboutDlg::OnInitDialog()
{
	CHAR szTmp[80];

	CDialog::OnInitDialog();

	//
	// Display the version string
	//
#ifndef SHIP
	wsprintf(szTmp, "%d.%2.2d.%4.4d", rmj, rmm, rup);
#else	// SHIP
	wsprintf(szTmp, "%d.%2.2d", rmj, rmm);
#endif	// SHIP
	SetDlgItemText(IDC_ABOUT_VERSION, szTmp);

	//Display license information
	SetDlgItemText(IDC_ABOUT_LICENSENAME, productInfo.licenseName);
	SetDlgItemText(IDC_ABOUT_LICENSECOMPANY, productInfo.licenseCompany);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CAboutDlg::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	// We should only be getting WM_DRAWITEM messages from the
	// icon control (an ownerdrawn button)!
	ASSERT(nIDCtl == IDC_ABOUT_ICON);

	CBitmap bmLarge;
	bmLarge.LoadBitmap(IDB_LARGEABOUT);

	// dolphin 14787 [patbr]
	// on Daytona-J bitmap does not cover control area, so paint control background first...
	HBRUSH hbrGray = CreateSolidBrush(RGB(192, 192, 192));
	::FillRect(lpDrawItemStruct->hDC, &(lpDrawItemStruct->rcItem), hbrGray);
	DeleteObject(hbrGray);

	// Draw the bitmap...
	BITMAP bitmap;
	bmLarge.GetObject(sizeof (BITMAP), &bitmap);
	{
		CDC memDC;
		memDC.CreateCompatibleDC((CDC *)CDC::FromHandle(lpDrawItemStruct->hDC));
		CBitmap* pOldBitmap = memDC.SelectObject(&bmLarge);
		((CDC *)CDC::FromHandle(lpDrawItemStruct->hDC))->BitBlt(0, 0, bitmap.bmWidth, bitmap.bmHeight, &memDC, 0, 0, SRCCOPY);
		memDC.SelectObject(pOldBitmap);
	}
}

void CAboutDlg::OnOK()
{
	if ((GetKeyState(VK_CONTROL) >= 0) && (GetKeyState(VK_SHIFT) >= 0))
		CDialog::OnOK();
	else
	{
		if (GetDlgItem(IDC_ABOUT_MSDEV)->IsWindowVisible())
			GetDlgItem(IDC_ABOUT_MSDEV)->ShowWindow(FALSE);
		else
			GetDlgItem(IDC_ABOUT_MSDEV)->ShowWindow(TRUE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\multipad.v2\mpfind.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/***************************************************************************
 *                                                                         *
 *  MODULE      : MpFind.c                                                 *
 *                                                                         *
 *  PURPOSE     : Code to do text searches in MultiPad.                    *
 *                                                                         *
 *  FUNCTIONS   : RealSlowCompare () - Compares subject string with target *
 *                                     string.                             *
 *                                                                         *
 *                Local_FindText ()          - Looks for the search string in the  *
 *                                     active window.                      *
 *                                                                         *
 *                FindPrev ()        - Find previous occurence of search   *
 *                                     string.                             *
 *                                                                         *
 *                FindNext ()        - Find next occurence of search string*
 *                                                                         *
 *                FindDlgProc ()     - Dialog function for Search/Find.    *
 *                                                                         *
 *                Find ()            - Invokes FindDlgProc ()              *
 *                                                                         *
 ***************************************************************************/
#include "multipad.h"

#undef HIWORD
#undef LOWORD

#define HIWORD(l) (((WORD*)&(l))[1])
#define LOWORD(l) (((WORD*)&(l))[0])

BOOL fCase         = FALSE;    /* Turn case sensitivity off */
CHAR szSearch[160] = "";       /* Initialize search string  */

//LPSTR WINAPI AnsiLower (LPSTR);

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : RealSlowCompare ()                                         *
 *                                                                          *
 *  PURPOSE    : Compares subject string with the target string. This fn/   *
 *               is called repeatedly so that all substrings are compared,  *
 *               which makes it O(n ** 2), hence it's name.                 *
 *                                                                          *
 *  RETURNS    : TRUE  - If pSubject is identical to pTarget.               *
 *               FALSE - otherwise.                                         *
 *                                                                          *
 ****************************************************************************/

BOOL NEAR PASCAL RealSlowCompare (
        register PSTR pSubject,
        register PSTR pTarget)
{
    if (fCase){
        while (*pTarget)
            if (*pTarget++ != *pSubject++)
                return FALSE;
    }
    else{
        /* If case-insensitive, convert both subject and target to lowercase
         * before comparing.
         */
        AnsiLower ((LPSTR)pTarget);
        while (*pTarget)
            if (*pTarget++ != (CHAR)(DWORD)AnsiLower ((LPSTR)(DWORD)(BYTE)*pSubject++))
                return FALSE;
    }
    return TRUE;
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : Local_FindText ()                                                  *
 *                                                                          *
 *  PURPOSE    : Finds the search string in the active window according to  *
 *               search direction (dch) specified ( -1 for reverse and 1 for*
 *               forward searches).                                         *
 *                                                                          *
 ****************************************************************************/
VOID NEAR PASCAL Local_FindText(register INT dch)
{
    register PSTR pText;
    HANDLE        hT;
    LONG          l;
    WORD          cch;
    INT           i;

    if (!*szSearch)
        return;

    /* Find the current selection range */
    l = (LONG)SendMessage(hwndActiveEdit, EM_GETSEL, 0, 0);

    /* Get the handle to the text buffer and lock it */
    hT    = (HANDLE)SendMessage (hwndActiveEdit, EM_GETHANDLE, 0, 0L);
    pText = LocalLock(hT);

    /* Get the length of the text */
    cch = (WORD)SendMessage (hwndActiveEdit, WM_GETTEXTLENGTH, 0, 0L);

    /* Start with the next char. in selected range ... */
    pText += LOWORD (l) + dch;

    /* Compute how many characters are before/after the current selection*/
    if (dch < 0)
        i = LOWORD (l);
    else
        i = cch - LOWORD (l) + 1 - lstrlen (szSearch);

    /* While there are uncompared substrings... */
    while ( i > 0){
        LOWORD(l)+=dch;

        /* Does this substring match? */
        if (RealSlowCompare(pText,szSearch)){

            /* Yes, unlock the buffer.*/
            LocalUnlock(hT);

            /* Select the located string */
            HIWORD(l) = LOWORD(l) + (WORD)lstrlen (szSearch);
            SendMessage(hwndActiveEdit, EM_SETSEL, GET_EM_SETSEL_MPS(LOWORD(l), HIWORD(l)));
            return;
        }
        i--;

        /* increment/decrement start position by 1 */
        pText += dch;
    }

    /* Not found... unlock buffer. */
    LocalUnlock (hT);

    /* Give a message */
    MPError (hwndFrame, MB_OK | MB_ICONEXCLAMATION, IDS_CANTFIND, (LPSTR)szSearch);

    return;
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : FindPrev ()                                                *
 *                                                                          *
 *  PURPOSE    : Finds the previous occurence of the search string. Calls   *
 *               Local_FindText () with a negative search direction.                *
 *                                                                          *
 ****************************************************************************/
VOID APIENTRY FindPrev()
{
    Local_FindText(-1);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : FindNext ()                                                *
 *                                                                          *
 *  PURPOSE    : Finds the next occurence of search string. Calls           *
 *               Local_FindText () with a positive search direction.                *
 *                                                                          *
 ****************************************************************************/
VOID APIENTRY FindNext()
{
    Local_FindText(1);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : FindDlgProc(hwnd, message, wParam, lParam)                 *
 *                                                                          *
 *  PURPOSE    : Dialog function for the Search/Find command. Prompts user  *
 *               for target string, case flag and search direction.         *
 *                                                                          *
 ****************************************************************************/
BOOL APIENTRY FindDlgProc(
        HWND hwnd,
        UINT msg,
        UINT wParam,
        LONG lParam)
{
    switch (msg){
        case WM_INITDIALOG:{

            /* Check/uncheck case button */
            CheckDlgButton (hwnd, (int)IDD_CASE, (WORD)fCase);

            /* Set default search string to most recently searched string */
            SetDlgItemText (hwnd, IDD_SEARCH, szSearch);

            /* Allow search only if target is nonempty */
            if (!lstrlen (szSearch)){
                EnableWindow (GetDlgItem (hwnd, IDOK), FALSE);
                EnableWindow (GetDlgItem (hwnd, IDD_PREV), FALSE);
            }
            break;
        }

        case WM_COMMAND:
        {

            /* Search forward by default (see IDOK below) */
            INT i = 1;

            switch (LOWORD(wParam)){
                /* if the search target becomes non-empty, enable searching */
                case IDD_SEARCH:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE){
                        if (!(WORD) SendDlgItemMessage (hwnd,
                                                        IDD_SEARCH,
                                                        WM_GETTEXTLENGTH,
                                                        0,
                                                        0L))
                            i = FALSE;
                        else
                            i = TRUE;
                        EnableWindow (GetDlgItem (hwnd, IDOK), i);
                        EnableWindow (GetDlgItem (hwnd, IDD_PREV), i);
                    }
                    break;

                case IDD_CASE:
                    /* Toggle state of case button */
                    CheckDlgButton (hwnd,
                                    (int)IDD_CASE,
                                    (WORD)!IsDlgButtonChecked (hwnd, (int)IDD_CASE));
                    break;

                case IDD_PREV:
                    /* Set direction to backwards */
                    i=-1;
                    /*** FALL THRU ***/

                case IDOK:
                    /* Save case selection */
                    fCase = IsDlgButtonChecked( hwnd, IDD_CASE);

                    /* Get search string */
                    GetDlgItemText (hwnd, IDD_SEARCH, szSearch, sizeof (szSearch));

                    /* Find the text */
                    Local_FindText (i);
                    /*** FALL THRU ***/

                /* End the dialog */
                case IDCANCEL:
                    EndDialog (hwnd, 0);
                    break;

                default:
                    return FALSE;
            }
            break;
        }
        default:
            return FALSE;
    }
    return TRUE;
        UNREFERENCED_PARAMETER(lParam);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : Find()                                                     *
 *                                                                          *
 *  PURPOSE    : Invokes the Search/Find dialog.                            *
 *                                                                          *
 ****************************************************************************/

VOID APIENTRY Find()
{
    DialogBox (hInst, IDD_FIND, hwndFrame, FindDlgProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\blmsgs.cpp ===
//-----------------------------------------------------------------------------
//  BLMsgs.cpp
//
//  Button-list (Chicago control) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifndef DISABLE_WIN95_MESSAGES
#endif	// DISABLE_WIN95_MESSAGES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\animsgs.cpp ===
//-----------------------------------------------------------------------------
//  AniMsgs.cpp
//
//  Animate (Chicago control) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifndef DISABLE_WIN95_MESSAGES
//////////////////////////////////////////////////////////////////////////////

DECODE(ACM_OPEN)
{
	PARM(lpszName, LPSTR, LP);

	POUTC(lpszName, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

DECODERET(ACM_OPEN)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(ACM_OPEN)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(pstr, LPSTR, ED2);
		INDENT();
		P2OUTS(pstr);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(ACM_PLAY)
{
	PARM(cRepeat, UINT, WP);
	PARM(wFrom, UINT, LOLP);
	PARM(wTo, UINT, HILP);

	POUTC(cRepeat, INT);
	POUTC(wFrom, INT);
	POUTC(wTo, INT);

	return TRUE;
}

DECODERET(ACM_PLAY)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(ACM_PLAY);

//////////////////////////////////////////////////////////////////////////////

NODECODE(ACM_STOP);

NODECODERET(ACM_STOP);

NODECODEPARM(ACM_STOP);

//////////////////////////////////////////////////////////////////////////////

NODECODE(ACM_OPENW);

NODECODERET(ACM_OPENW);

NODECODEPARM(ACM_OPENW);

//////////////////////////////////////////////////////////////////////////////
#endif	// DISABLE_WIN95_MESSAGES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\btnmsgs.cpp ===
//-----------------------------------------------------------------------------
//  BtnMsgs.cpp
//
//  Button (BM_*) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

static VALUETABLE tblBtnStyles[] =
{
	TABLEENTRY(BS_3STATE),
	TABLEENTRY(BS_AUTO3STATE),
	TABLEENTRY(BS_AUTOCHECKBOX),
	TABLEENTRY(BS_AUTORADIOBUTTON),
	TABLEENTRY(BS_CHECKBOX),
	TABLEENTRY(BS_DEFPUSHBUTTON),
	TABLEENTRY(BS_GROUPBOX),
	TABLEENTRY(BS_OWNERDRAW),
	TABLEENTRY(BS_PUSHBUTTON),
	TABLEENTRY(BS_RADIOBUTTON),
	TABLEENTRY(BS_USERBUTTON),
	TABLEEND
};

//////////////////////////////////////////////////////////////////////////////
/*
// TODO: 
NODECODE(BM_CLICK);

NODECODERET(BM_CLICK);

NODECODEPARM(BM_CLICK);
*/
//////////////////////////////////////////////////////////////////////////////

NODECODE(BM_GETCHECK);

DECODERET(BM_GETCHECK)
{
	PARM(fCheck, UINT, RET);

	POUTC(fCheck, INT);
	switch (fCheck)
	{
		case 0:
			MOUT << ids(IDS_UNCHECKED);
			break;

		case 1:
			MOUT << ids(IDS_CHECKED);
			break;

		case 2:
			MOUT << ids(IDS_INDETERMINATE);
			break;
	}

	return TRUE;
}

NODECODEPARM(BM_GETCHECK);

//////////////////////////////////////////////////////////////////////////////

NODECODE(BM_GETSTATE);

DECODERET(BM_GETSTATE)
{
	PARM(lResult, UINT, RET);
	UINT fChecked = lResult & 0x0003;
	BOOL fHilight = (lResult & 0x0004) != 0;
	BOOL fFocus = (lResult & 0x0008) != 0;

	POUTC(fChecked, INT);
	switch (fChecked)
	{
		case 0:
			MOUT << ids(IDS_UNCHECKED);
			break;

		case 1:
			MOUT << ids(IDS_CHECKED);
			break;

		case 2:
			MOUT << ids(IDS_INDETERMINATE);
			break;
	}

	POUTB(fHilight);
	POUTB(fFocus);

	return TRUE;
}

NODECODEPARM(BM_GETSTATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(BM_SETCHECK)
{
	PARM(fCheck, UINT, WP);

	POUTC(fCheck, INT);
	switch (fCheck)
	{
		case 0:
			MOUT << ids(IDS_UNCHECKED);
			break;

		case 1:
			MOUT << ids(IDS_CHECKED);
			break;

		case 2:
			MOUT << ids(IDS_INDETERMINATE);
			break;
	}

	return TRUE;
}

NODECODERET(BM_SETCHECK);

NODECODEPARM(BM_SETCHECK);

//////////////////////////////////////////////////////////////////////////////

DECODE(BM_SETSTATE)
{
	PARM(fState, BOOL, WP);

	POUTB(fState);

	return TRUE;
}

NODECODERET(BM_SETSTATE);

NODECODEPARM(BM_SETSTATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(BM_SETSTYLE)
{
	PARM(dwStyle, DWORD, WP);
	PARM(fRedraw, BOOL, LOLP);

	PLABEL(dwStyle);
	TableOrValue(tblBtnStyles, (UINT)(dwStyle & ~BS_LEFTTEXT));

	if (dwStyle & BS_LEFTTEXT)
	{
		MOUT << " | BS_LEFTTEXT";
	}

	POUTB(fRedraw);

	return TRUE;
}

NODECODERET(BM_SETSTYLE);

NODECODEPARM(BM_SETSTYLE);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\ddemsgs.cpp ===
//-----------------------------------------------------------------------------
//  DDEMsgs.cpp
//
//  DDE message crackers.

#include "stdafx.h"
#pragma hdrstop

#include <dde.h>		// for UnpackDDElParam

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DDE_ACK)
{
	if (pmsd->fPostType != POSTTYPE_POSTED)
	{
		DECODELIKE(WM_DDE_INITIATE);
	}
	else
	{
		PARM(hwnd, HWND, WP);
		PARM(lPackedVal, DWORD, LP);

		UINT wStatus, aItem;

		POUT(hwnd);
		POUT(lPackedVal);

		if (UnpackDDElParam(WM_DDE_ACK, lPackedVal, &wStatus, &aItem) ||
			UnpackDDElParam(WM_DDE_ADVISE, lPackedVal, &wStatus, &aItem) ||
			UnpackDDElParam(WM_DDE_DATA, lPackedVal, &wStatus, &aItem) ||
			UnpackDDElParam(WM_DDE_EXECUTE, lPackedVal, &wStatus, &aItem) ||
			UnpackDDElParam(WM_DDE_POKE, lPackedVal, &wStatus, &aItem) ||
			UnpackDDElParam(WM_DDE_REQUEST, lPackedVal, &wStatus, &aItem) ||
			UnpackDDElParam(WM_DDE_TERMINATE, lPackedVal, &wStatus, &aItem) ||
			UnpackDDElParam(WM_DDE_UNADVISE, lPackedVal, &wStatus, &aItem))
		{
			CHAR szAtom[256];

			POUTC(wStatus, WORD);

			if (GlobalGetAtomName((ATOM)aItem, szAtom, sizeof(szAtom)))
			{
				POUTC(aItem, WORD);
				POUTS(szAtom);
			}
			else
			{
				UINT hCommands;

				if (UnpackDDElParam(WM_DDE_ACK, lPackedVal, &wStatus, &hCommands) ||
					UnpackDDElParam(WM_DDE_ADVISE, lPackedVal, &wStatus, &hCommands) ||
					UnpackDDElParam(WM_DDE_DATA, lPackedVal, &wStatus, &hCommands) ||
					UnpackDDElParam(WM_DDE_EXECUTE, lPackedVal, &wStatus, &hCommands) ||
					UnpackDDElParam(WM_DDE_POKE, lPackedVal, &wStatus, &hCommands) ||
					UnpackDDElParam(WM_DDE_REQUEST, lPackedVal, &wStatus, &hCommands) ||
					UnpackDDElParam(WM_DDE_TERMINATE, lPackedVal, &wStatus, &hCommands) ||
					UnpackDDElParam(WM_DDE_UNADVISE, lPackedVal, &wStatus, &hCommands))
				{
					POUTC(hCommands, DWORD);

					LPSTR lpszCommands;
	
					if ((lpszCommands = (LPSTR)GlobalLock((HGLOBAL)hCommands)) != NULL)
					{
						POUTS(lpszCommands);
						GlobalUnlock((HGLOBAL)hCommands);
					}
				}
			}
		}
	}

	return TRUE;
}

NODECODERET(WM_DDE_ACK);

NODECODEPARM(WM_DDE_ACK);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DDE_ADVISE)
{
	PARM(hwnd, HWND, WP);
	PARM(lPackedVal, DWORD, LP);

	UINT hOptions, aItem;

	POUT(hwnd);
	POUT(lPackedVal);

	if (UnpackDDElParam(WM_DDE_ACK, lPackedVal, &hOptions, &aItem) ||
		UnpackDDElParam(WM_DDE_ADVISE, lPackedVal, &hOptions, &aItem) ||
		UnpackDDElParam(WM_DDE_DATA, lPackedVal, &hOptions, &aItem) ||
		UnpackDDElParam(WM_DDE_EXECUTE, lPackedVal, &hOptions, &aItem) ||
		UnpackDDElParam(WM_DDE_INITIATE, lPackedVal, &hOptions, &aItem) ||
		UnpackDDElParam(WM_DDE_POKE, lPackedVal, &hOptions, &aItem) ||
		UnpackDDElParam(WM_DDE_REQUEST, lPackedVal, &hOptions, &aItem) ||
		UnpackDDElParam(WM_DDE_TERMINATE, lPackedVal, &hOptions, &aItem) ||
		UnpackDDElParam(WM_DDE_UNADVISE, lPackedVal, &hOptions, &aItem))
	{
		CHAR szAtom[256];

		POUTC(hOptions, WORD);
		POUTC(aItem, WORD);

		if (GlobalGetAtomName((ATOM)aItem, szAtom, sizeof(szAtom)))
		{
			POUTS(szAtom);
		}						 
	}

	return TRUE;
}

NODECODERET(WM_DDE_ADVISE);

NODECODEPARM(WM_DDE_ADVISE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DDE_DATA)
{
	DECODELIKE(WM_DDE_ADVISE);
}

NODECODERET(WM_DDE_DATA);

NODECODEPARM(WM_DDE_DATA);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DDE_EXECUTE)
{
	PARM(hwnd, HWND, WP);
	PARM(lPackedVal, DWORD, LP);

	UINT hOptions, hCommands;

	POUT(hwnd);
	POUT(lPackedVal);

	if (UnpackDDElParam(WM_DDE_ACK, lPackedVal, &hOptions, &hCommands) ||
		UnpackDDElParam(WM_DDE_ADVISE, lPackedVal, &hOptions, &hCommands) ||
		UnpackDDElParam(WM_DDE_DATA, lPackedVal, &hOptions, &hCommands) ||
		UnpackDDElParam(WM_DDE_EXECUTE, lPackedVal, &hOptions, &hCommands) ||
		UnpackDDElParam(WM_DDE_INITIATE, lPackedVal, &hOptions, &hCommands) ||
		UnpackDDElParam(WM_DDE_POKE, lPackedVal, &hOptions, &hCommands) ||
		UnpackDDElParam(WM_DDE_REQUEST, lPackedVal, &hOptions, &hCommands) ||
		UnpackDDElParam(WM_DDE_TERMINATE, lPackedVal, &hOptions, &hCommands) ||
		UnpackDDElParam(WM_DDE_UNADVISE, lPackedVal, &hOptions, &hCommands))
	{
		LPSTR lpszCommands;

		POUTC(hCommands, DWORD);

		if ((lpszCommands = (LPSTR)GlobalLock((HGLOBAL)hCommands)) != NULL)
		{
			POUTS(lpszCommands);
			GlobalUnlock((HGLOBAL)hCommands);
		}						 
	}

	return TRUE;
}

NODECODERET(WM_DDE_EXECUTE);

NODECODEPARM(WM_DDE_EXECUTE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DDE_INITIATE)
{
	PARM(hwnd, HWND, WP);
	PARM(aApp, WORD, LOLP);
	PARM(aTopic, WORD, HILP);

	CHAR szAtom[256];

	POUT(hwnd);

	POUT(aApp);
	if (GlobalGetAtomName(aApp, szAtom, sizeof(szAtom)))
	{
		POUTS(szAtom);
	}

	POUT(aTopic);
	if (GlobalGetAtomName(aTopic, szAtom, sizeof(szAtom)))
	{
		POUTS(szAtom);
	}

	return TRUE;
}

NODECODERET(WM_DDE_INITIATE);

NODECODEPARM(WM_DDE_INITIATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DDE_POKE)
{
	DECODELIKE(WM_DDE_ADVISE);
}

NODECODERET(WM_DDE_POKE);

NODECODEPARM(WM_DDE_POKE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DDE_REQUEST)
{
	PARM(hwnd, HWND, WP);
	PARM(cfFormat, UINT, LOLP);
	PARM(aItem, WORD, HILP);

	CHAR szAtom[256];

	POUT(hwnd);
	TABLEORVALUE(tblCBFormat, cfFormat);

	POUT(aItem);
	if (GlobalGetAtomName(aItem, szAtom, sizeof(szAtom)))
	{
		POUTS(szAtom);
	}

	return TRUE;
}

NODECODERET(WM_DDE_REQUEST);

NODECODEPARM(WM_DDE_REQUEST);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DDE_TERMINATE)
{
	PARM(hwnd, HWND, WP);

	POUT(hwnd);

	return TRUE;
}

NODECODERET(WM_DDE_TERMINATE);

NODECODEPARM(WM_DDE_TERMINATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DDE_UNADVISE)
{
	DECODELIKE(WM_DDE_REQUEST);
}

NODECODERET(WM_DDE_UNADVISE);

NODECODEPARM(WM_DDE_UNADVISE);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\clipmsgs.cpp ===
//-----------------------------------------------------------------------------
//  ClipMsgs.cpp
//
//  Clipboard message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

VALUETABLE tblCBFormat[] =
{
	TABLEENTRY(CF_BITMAP),
	TABLEENTRY(CF_DIB),
	TABLEENTRY(CF_DIF),
	TABLEENTRY(CF_DSPBITMAP),
	TABLEENTRY(CF_DSPENHMETAFILE),
	TABLEENTRY(CF_DSPMETAFILEPICT),
	TABLEENTRY(CF_DSPTEXT),
	TABLEENTRY(CF_ENHMETAFILE),
	TABLEENTRY(CF_METAFILEPICT),
	TABLEENTRY(CF_OEMTEXT),
	TABLEENTRY(CF_OWNERDISPLAY),
	TABLEENTRY(CF_PALETTE),
	TABLEENTRY(CF_PENDATA),
	TABLEENTRY(CF_RIFF),
	TABLEENTRY(CF_SYLK),
	TABLEENTRY(CF_TEXT),
	TABLEENTRY(CF_TIFF),
	TABLEENTRY(CF_UNICODETEXT),
	TABLEENTRY(CF_WAVE),
	TABLEEND
};

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_ASKCBFORMATNAME)
{
	PARM(cchName, INT, WP);
	PARM(lpszFormatName, LPTSTR, LP);

	POUT(cchName);
	POUTC(lpszFormatName, DWORD);

	return TRUE;
}

DECODERET(WM_ASKCBFORMATNAME)
{
	PARM(lpszFormatName, LPTSTR, LP);

	POUTC(lpszFormatName, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

DECODEPARM(WM_ASKCBFORMATNAME)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(pstr, LPSTR, ED2);
		INDENT();
		P2OUTS(pstr);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CHANGECBCHAIN)
{
	PARM(hwndRemove, HWND, WP);
	PARM(hwndNext, HWND, LP);

	POUT(hwndRemove);
	POUT(hwndNext);

	return TRUE;
}

NODECODERET(WM_CHANGECBCHAIN);

NODECODEPARM(WM_CHANGECBCHAIN);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_CLEAR);

NODECODERET(WM_CLEAR);

NODECODEPARM(WM_CLEAR);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_COPY);

NODECODERET(WM_COPY);

NODECODEPARM(WM_COPY);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_CUT);

NODECODERET(WM_CUT);

NODECODEPARM(WM_CUT);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_DESTROYCLIPBOARD);

NODECODERET(WM_DESTROYCLIPBOARD);

NODECODEPARM(WM_DESTROYCLIPBOARD);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_DRAWCLIPBOARD);

NODECODERET(WM_DRAWCLIPBOARD);

NODECODEPARM(WM_DRAWCLIPBOARD);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_HSCROLLCLIPBOARD)
{
	PARM(hwndViewer, HWND, WP);
	PARM(fuScrollCode, UINT, LOLP);
	PARM(nPos, INT, HILP);

	POUT(hwndViewer);
	TABLEORVALUE(tblHScroll, fuScrollCode);

	switch (fuScrollCode)
	{
		case SB_THUMBPOSITION:
		case SB_THUMBTRACK:
			POUT(nPos);
			break;
	}

	return TRUE;
}

NODECODERET(WM_HSCROLLCLIPBOARD);

NODECODEPARM(WM_HSCROLLCLIPBOARD);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_PAINTCLIPBOARD)
{
	PARM(hwndViewer, HWND, WP);
	PARM(hglbPs, HGLOBAL, LP);

	POUT(hwndViewer);
	POUTC(hglbPs, DWORD);

	return TRUE;
}

NODECODERET(WM_PAINTCLIPBOARD);

DECODEPARM(WM_PAINTCLIPBOARD)
{
	P2WPOUT();

	P2LPOUTPTR(PAINTSTRUCT);
	P2IFSIZEOF(PAINTSTRUCT)
	{
		PARM(pps, LPPAINTSTRUCT, ED2);
		INDENT();
		P2OUTC(pps, hdc, DWORD);
		P2OUTB(pps, fErase);
		P2OUTRECT(pps, rcPaint);
		P2OUTB(pps, fRestore);
		P2OUTB(pps, fIncUpdate);

		P2LABEL(rgbReserved[32]);
		for (int i = 0; i < 32; i++)
		{
			CHAR sz[8];
			sprintf(sz, "%02X ", pps->rgbReserved[i]);
			M2OUT << sz;
		}
		P2ENDLINE();
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_PASTE);

NODECODERET(WM_PASTE);

NODECODEPARM(WM_PASTE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_RENDERALLFORMATS);

NODECODERET(WM_RENDERALLFORMATS);

NODECODEPARM(WM_RENDERALLFORMATS);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_RENDERFORMAT)
{
	PARM(uFormat, UINT, WP);

	TABLEORVALUE(tblCBFormat, uFormat);

	return TRUE;
}

NODECODERET(WM_RENDERFORMAT);

NODECODEPARM(WM_RENDERFORMAT);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SIZECLIPBOARD)
{
	PARM(hwndViewer, HWND, WP);
	PARM(hglbPs, HGLOBAL, LP);

	POUT(hwndViewer);
	POUTC(hglbPs, DWORD);

	return TRUE;
}

NODECODERET(WM_SIZECLIPBOARD);

DECODEPARM(WM_SIZECLIPBOARD)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(prc, LPRECT, ED2);
		INDENT();
		P2OUT(prc, left);
		P2OUT(prc, top);
		P2OUT(prc, right);
		P2OUT(prc, bottom);
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_UNDO);

DECODERET(WM_UNDO)
{
	PARM(fSuccess, BOOL, RET);

	POUT(fSuccess);

	return TRUE;
}

NODECODEPARM(WM_UNDO);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_VSCROLLCLIPBOARD)
{
	PARM(hwndViewer, HWND, WP);
	PARM(fuScrollCode, UINT, LOLP);
	PARM(nPos, INT, HILP);

	POUT(hwndViewer);
	TABLEORVALUE(tblVScroll, fuScrollCode);

	switch (fuScrollCode)
	{
		case SB_THUMBPOSITION:
		case SB_THUMBTRACK:
			POUT(nPos);
			break;
	}

	return TRUE;
}

NODECODERET(WM_VSCROLLCLIPBOARD);

NODECODEPARM(WM_VSCROLLCLIPBOARD);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\aboutdlg.h ===
// aboutdlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog

class CAboutDlg : public CDialog
{
// Construction
public:
	CAboutDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUT };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	// Generated message map functions
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\dlgmsgs.cpp ===
//-----------------------------------------------------------------------------
//  DlgMsgs.cpp
//
//  Dialog message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

NODECODE(DM_GETDEFID);

DECODERET(DM_GETDEFID)
{
	PARM(wHasDef, WORD, HIRET);
	PARM(wDefID, WORD, LORET);

	if (wHasDef == DC_HASDEFID)
	{
		PLABEL(wHasDef);
		MOUT << "DC_HASDEFID";
		POUTC(wDefID, WORD);
		return(TRUE);
	}

	return(FALSE);
}

NODECODEPARM(DM_GETDEFID);

//////////////////////////////////////////////////////////////////////////////

DECODE(DM_SETDEFID)
{
	PARM(wDefID, WORD, LOWP);

	POUTC(wDefID, WORD);

	return(TRUE);
}

DECODERET(DM_SETDEFID)
{
	PARM(fSetDefID, DWORD, RET);
	TABLEORINT(tblTrueFalse, fSetDefID);
	return(TRUE);
}

NODECODEPARM(DM_SETDEFID);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\cbmsgs.cpp ===
//-----------------------------------------------------------------------------
//  CBMsgs.cpp
//
//  Combobox message (CB_*) crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

VALUETABLE tblCBRet[] =
{
	TABLEENTRY(CB_ERR),
	TABLEENTRY(CB_ERRSPACE),
	TABLEEND
};

static VALUETABLE tblCBRetOK[] =
{
	TABLEENTRY(CB_OKAY),
	TABLEENTRY(CB_ERR),
	TABLEENTRY(CB_ERRSPACE),
	TABLEEND
};

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_ADDSTRING)
{
	PARM(lpsz, LPCTSTR, LP);

	POUTC(lpsz, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

DECODERET(CB_ADDSTRING)
{
	PARM(index, INT, RET);

	TABLEORINT(tblCBRet, index);

	return TRUE;
}

DECODEPARM(CB_ADDSTRING)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(pstr, LPSTR, ED2);
		INDENT();
		P2OUTS(pstr);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_DELETESTRING)
{
	PARM(index, INT, WP);

	POUT(index);

	return TRUE;
}

DECODERET(CB_DELETESTRING)
{
	PARM(cItemsRemaining, INT, RET);

	TABLEORINT(tblCBRet, cItemsRemaining);

	return TRUE;
}

NODECODEPARM(CB_DELETESTRING);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_DIR)
{
	PARM(uAttrs, UINT, WP);
	PARM(lpszFileSpec, LPCTSTR, LP);

	TABLEFLAGS(tblFileAttrs, uAttrs);
	POUTC(lpszFileSpec, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

DECODERET(CB_DIR)
{
	DECODERETLIKE(CB_ADDSTRING);
}

DECODEPARM(CB_DIR)
{
	DECODEPARMLIKE(CB_ADDSTRING);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_FINDSTRING)
{
	PARM(indexStart, INT, WP);
	PARM(lpszFind, LPCTSTR, LP);

	POUT(indexStart);
	if (indexStart == -1)
	{
		MOUT << ids(IDS_FROM_THE_BEGINNING);
	}

	POUTC(lpszFind, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

DECODERET(CB_FINDSTRING)
{
	DECODERETLIKE(CB_ADDSTRING);
}

DECODEPARM(CB_FINDSTRING)
{
	DECODEPARMLIKE(CB_ADDSTRING);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_FINDSTRINGEXACT)
{
	DECODELIKE(CB_FINDSTRING);
}

DECODERET(CB_FINDSTRINGEXACT)
{
	DECODERETLIKE(CB_FINDSTRING);
}

DECODEPARM(CB_FINDSTRINGEXACT)
{
	DECODEPARMLIKE(CB_FINDSTRING);
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(CB_GETCOUNT);

DECODERET(CB_GETCOUNT)
{
	PARM(cItems, INT, RET);

	TABLEORINT(tblCBRet, cItems);

	return TRUE;
}

NODECODEPARM(CB_GETCOUNT);

//////////////////////////////////////////////////////////////////////////////

NODECODE(CB_GETCURSEL);

DECODERET(CB_GETCURSEL)
{
	DECODERETLIKE(CB_ADDSTRING);
}

NODECODEPARM(CB_GETCURSEL);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_GETDROPPEDCONTROLRECT)
{
	PARM(lprc, LPRECT, LP);

	POUTC(lprc, DWORD);

	return TRUE;
}

DECODERET(CB_GETDROPPEDCONTROLRECT)
{
	PARM(lResult, UINT, RET);
	PARM(lprc, LPRECT, LP);

	TABLEORVALUE(tblCBRetOK, lResult);

	if (lResult != CB_ERR)
	{
		POUTC(lprc, DWORD);
		PIFSIZEOF(RECT)
		{
			PARM(prc, LPRECT, ED);
			POUTRECT(prc);
		}
	}

	return TRUE;
}

DECODEPARM(CB_GETDROPPEDCONTROLRECT)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(prc, LPRECT, ED2);
		INDENT();
		P2OUT(prc, left);
		P2OUT(prc, top);
		P2OUT(prc, right);
		P2OUT(prc, bottom);
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(CB_GETDROPPEDSTATE);

DECODERET(CB_GETDROPPEDSTATE)
{
	PARM(fDropped, BOOL, RET);

	POUTB(fDropped);

	return TRUE;
}

NODECODEPARM(CB_GETDROPPEDSTATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_GETEDITSEL)
{
	PARM(lpdwStart, DWORD, WP);
	PARM(lpdwEnd, DWORD, LP);

	POUT(lpdwStart);
	POUT(lpdwEnd);

	return TRUE;
}

DECODERET(CB_GETEDITSEL)
{
	PARM(wStart, UINT, LORET);
	PARM(wEnd, UINT, HIRET);
	PARM(lpdwStart, DWORD, WP);
	PARM(lpdwEnd, DWORD, LP);

	POUT(wStart);
	POUT(wEnd);

	PIFSIZEOF(PACK_WPLPDWORDS)
	{
		PARM(ppwld, PPACK_WPLPDWORDS, ED);

		POUTC(lpdwStart, DWORD);
		if (ppwld->fValidWP)
		{
			MOUT << " (" << (INT)ppwld->nWP << ')';
		}

		POUTC(lpdwEnd, DWORD);
		if (ppwld->fValidLP)
		{
			MOUT << " (" << (INT)ppwld->nLP << ')';
		}
	}
	else
	{
		POUTC(lpdwStart, DWORD);
		POUTC(lpdwEnd, DWORD);
	}

	return TRUE;
}

DECODEPARM(CB_GETEDITSEL)
{
	P2IFSIZEOF(PACK_WPLPDWORDS)
	{
		PARM(ppwld, PPACK_WPLPDWORDS, ED2);

		if (ppwld->fValidWP)
		{
			P2WPOUTPTR(DWORD);
			INDENT();
			M2OUT << (INT)ppwld->nWP;
			P2ENDLINE();
			OUTDENT();
		}
		else
		{
			P2WPOUT();
		}

		if (ppwld->fValidLP)
		{
			P2LPOUTPTR(DWORD);
			INDENT();
			M2OUT << (INT)ppwld->nLP;
			P2ENDLINE();
			OUTDENT();
		}
		else
		{
			P2WPOUT();
		}
	}
	else
	{
		P2WPOUT();
		P2LPOUT();
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(CB_GETEXTENDEDUI);

DECODERET(CB_GETEXTENDEDUI)
{
	PARM(fExtended, BOOL, RET);

	POUTB(fExtended);

	return FALSE;
}

NODECODEPARM(CB_GETEXTENDEDUI);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_GETITEMDATA)
{
	PARM(index, INT, WP);

	POUT(index);

	return TRUE;
}

DECODERET(CB_GETITEMDATA)
{
	PARM(dwData, DWORD, RET);

	TABLEORDWORD(tblCBRet, dwData);

	return TRUE;
}

NODECODEPARM(CB_GETITEMDATA);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_GETITEMHEIGHT)
{
	PARM(index, INT, WP);

	POUT(index);
	if (index == -1)
	{
		MOUT << ids(IDS_THE_SELECTION_FIELD);
	}

	return TRUE;
}

DECODERET(CB_GETITEMHEIGHT)
{
	PARM(cyItem, INT, RET);

	TABLEORINT(tblCBRet, cyItem);

	return TRUE;
}

NODECODEPARM(CB_GETITEMHEIGHT);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_GETLBTEXT)
{
	PARM(index, INT, WP);
	PARM(lpszBuffer, LPCTSTR, LP);

	POUT(index);
	POUTC(lpszBuffer, DWORD);

	return TRUE;
}

DECODERET(CB_GETLBTEXT)
{
	PARM(cchText, INT, RET);
	PARM(lpszBuffer, LPCTSTR, LP);

	TABLEORINT(tblCBRet, cchText);
	POUTC(lpszBuffer, DWORD);
	PIFDATA()
	{
		PARM(pso, PPACK_STRINGORD, ED);

		PIFISORD(pso)
		{
			POUTORD(pso);
		}
		else
		{
			PARM(pstr, LPSTR, ED);
			POUTS(pstr);
		}
	}

	return TRUE;
}

DECODEPARM(CB_GETLBTEXT)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(pso, PPACK_STRINGORD, ED2);

		INDENT();

		P2IFISORD(pso)
		{
			P2OUTORD(pso);
		}
		else
		{
			PARM(pstr, LPSTR, ED2);
			P2OUTS(pstr);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_GETLBTEXTLEN)
{
	DECODELIKE(CB_GETITEMDATA);
}

DECODERET(CB_GETLBTEXTLEN)
{
	PARM(cchText, INT, RET);

	TABLEORINT(tblCBRet, cchText);

	return TRUE;
}

NODECODEPARM(CB_GETLBTEXTLEN);

//////////////////////////////////////////////////////////////////////////////

NODECODE(CB_GETLOCALE);

DECODERET(CB_GETLOCALE)
{
	PARM(dwLocaleID, DWORD, RET);

	POUT(dwLocaleID);

	return TRUE;
}

NODECODEPARM(CB_GETLOCALE);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_INSERTSTRING)
{
	PARM(index, INT, WP);
	PARM(lpsz, LPCTSTR, LP);

	POUT(index);
	if (index == -1)
	{
		MOUT << ids(IDS_END_OF_THE_LIST);
	}

	POUTC(lpsz, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

DECODERET(CB_INSERTSTRING)
{
	DECODERETLIKE(CB_GETITEMDATA);
}

DECODEPARM(CB_INSERTSTRING)
{
	DECODEPARMLIKE(CB_ADDSTRING);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_LIMITTEXT)
{
	PARM(cchLimit, UINT, WP);

	POUT(cchLimit);

	return TRUE;
}

NODECODERET(CB_LIMITTEXT);

NODECODEPARM(CB_LIMITTEXT);

//////////////////////////////////////////////////////////////////////////////

NODECODE(CB_RESETCONTENT);

NODECODERET(CB_RESETCONTENT);

NODECODEPARM(CB_RESETCONTENT);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_SELECTSTRING)
{
	DECODELIKE(CB_FINDSTRING);
}

DECODERET(CB_SELECTSTRING)
{
	DECODERETLIKE(CB_GETITEMDATA);
}

DECODEPARM(CB_SELECTSTRING)
{
	DECODEPARMLIKE(CB_ADDSTRING);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_SETCURSEL)
{
	PARM(index, INT, WP);

	POUT(index);
	if (index == -1)
	{
		MOUT << ids(IDS_NO_SELECTION);
	}

	return TRUE;
}

DECODERET(CB_SETCURSEL)
{
	PARM(index, INT, WP);
	PARM(lResult, UINT, RET);

	PLABEL(lResult);
	if (index == -1 && lResult == (UINT)CB_ERR)
	{
		MOUT << "-1" << ids(IDS_SUCCESSFULLY_REMOVED_SELECT);
	}
	else
	{
		TableOrValue(tblCBRetOK, lResult);
	}

	return TRUE;
}

NODECODEPARM(CB_SETCURSEL);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_SETEDITSEL)
{
	PARM(ichStart, INT, LOLP);
	PARM(ichEnd, INT, HILP);

	POUT(ichStart);
	if (ichStart == -1)
	{
		MOUT << ids(IDS_REMOVE_THE_SELECTION);
	}

	POUT(ichEnd);
	if (ichEnd == -1)
	{
		MOUT << ids(IDS_THE_LAST_CHARACTER);
	}

	return TRUE;
}

DECODERET(CB_SETEDITSEL)
{
	PARM(lResult, UINT, RET);

	TABLEORVALUE(tblCBRetOK, lResult);
	if (lResult == TRUE)
	{
		MOUT << ids(IDS_SUCCESS);
	}

	return TRUE;
}

NODECODEPARM(CB_SETEDITSEL);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_SETEXTENDEDUI)
{
	PARM(fExtended, BOOL, WP);

	POUTB(fExtended);

	return FALSE;
}

DECODERET(CB_SETEXTENDEDUI)
{
	PARM(lResult, UINT, RET);

	TABLEORVALUE(tblCBRetOK, lResult);

	return TRUE;
}

NODECODEPARM(CB_SETEXTENDEDUI);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_SETITEMDATA)
{
	PARM(index, INT, WP);
	PARM(dwData, DWORD, LP);

	POUT(index);
	POUT(dwData);
	MOUT << " (" << (INT)dwData << ')';

	return TRUE;
}

DECODERET(CB_SETITEMDATA)
{
	DECODERETLIKE(CB_SETEXTENDEDUI);
}

NODECODEPARM(CB_SETITEMDATA);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_SETITEMHEIGHT)
{
	PARM(index, INT, WP);
	PARM(cyItem, INT, LP);

	POUT(index);
	if (index == -1)
	{
		MOUT << ids(IDS_THE_SELECTION_FIELD);
	}

	POUT(cyItem);

	return TRUE;
}

DECODERET(CB_SETITEMHEIGHT)
{
	DECODERETLIKE(CB_SETEXTENDEDUI);
}

NODECODEPARM(CB_SETITEMHEIGHT);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_SETLOCALE)
{
	PARM(dwLocaleID, DWORD, WP);

	POUT(dwLocaleID);

	return TRUE;
}

DECODERET(CB_SETLOCALE)
{
	PARM(dwPrevLocaleID, DWORD, RET);

	TABLEORDWORD(tblCBRet, dwPrevLocaleID);

	return TRUE;
}

NODECODEPARM(CB_SETLOCALE);

//////////////////////////////////////////////////////////////////////////////

DECODE(CB_SHOWDROPDOWN)
{
	PARM(fShow, BOOL, WP);

	POUTB(fShow);

	return TRUE;
}

NODECODERET(CB_SHOWDROPDOWN);

NODECODEPARM(CB_SHOWDROPDOWN);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\editmsgs.cpp ===
//-----------------------------------------------------------------------------
//  EditMsgs.cpp
//
//  Edit message (EM_*) crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

static VALUETABLE tblVScrollCode[] =
{
	TABLEENTRY(SB_LINEUP),
	TABLEENTRY(SB_LINEDOWN),
	TABLEENTRY(SB_PAGEUP),
	TABLEENTRY(SB_PAGEDOWN),
	TABLEEND
};

//////////////////////////////////////////////////////////////////////////////

NODECODE(EM_CANUNDO);

DECODERET(EM_CANUNDO)
{
	PARM(fCanUndo, BOOL, RET);

	POUTB(fCanUndo);

	return TRUE;
}

NODECODEPARM(EM_CANUNDO);

//////////////////////////////////////////////////////////////////////////////

NODECODE(EM_EMPTYUNDOBUFFER);

NODECODERET(EM_EMPTYUNDOBUFFER);

NODECODEPARM(EM_EMPTYUNDOBUFFER);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_FMTLINES)
{
	PARM(fAddEOL, BOOL, WP);

	POUTB(fAddEOL);

	return TRUE;
}

NODECODERET(EM_FMTLINES);

NODECODEPARM(EM_FMTLINES);

//////////////////////////////////////////////////////////////////////////////

NODECODE(EM_GETFIRSTVISIBLELINE);

DECODERET(EM_GETFIRSTVISIBLELINE)
{
	PARM(iFirstVisibleLine, INT, RET);

	POUT(iFirstVisibleLine);

	return TRUE;
}

NODECODEPARM(EM_GETFIRSTVISIBLELINE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(EM_GETHANDLE);

DECODERET(EM_GETHANDLE)
{
	PARM(hloc, HLOCAL, RET);

	POUTC(hloc, DWORD);

	return TRUE;
}

NODECODEPARM(EM_GETHANDLE);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_GETLINE)
{
	PARM(line, INT, WP);
	PARM(lpch, LPCSTR, LP);

	POUT(line);
	POUTC(lpch, DWORD);
	PIFDATA()
	{
		//
		// There will be one word in the extra data that is
		// the maximum characters to copy.  Note that the
		// format of the extra data changes for the ret cracker
		// of this message below, however!
		//
		PARM(pw, LPWORD, ED);
		PLABEL(cchMax);
		MOUT << (INT)(UINT)*pw;
	}

	return TRUE;
}

DECODERET(EM_GETLINE)
{
	PARM(cchCopied, INT, RET);

	POUT(cchCopied);

	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

DECODEPARM(EM_GETLINE)
{
	P2WPOUT();

	P2LPOUTPTRSTR;

	//
	// Only look for the string on a return.  The extra data that
	// will be there on a send/post is the cchMax of the buffer in
	// a single WORD.  We don't bother to show this in the parm
	// cracker here, however.
	//
	P2IFRETURN()
	{
		P2IFDATA()
		{
			PARM(pstr, LPSTR, ED2);
			INDENT();
			P2OUTS(pstr);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(EM_GETLINECOUNT);

DECODERET(EM_GETLINECOUNT)
{
	PARM(cLines, INT, RET);

	POUT(cLines);

	return TRUE;
}

NODECODEPARM(EM_GETLINECOUNT);

//////////////////////////////////////////////////////////////////////////////

NODECODE(EM_GETMODIFY);

DECODERET(EM_GETMODIFY)
{
	PARM(fModified, BOOL, RET);

	POUTB(fModified);

	return TRUE;
}

NODECODEPARM(EM_GETMODIFY);

//////////////////////////////////////////////////////////////////////////////

NODECODE(EM_GETPASSWORDCHAR);

DECODERET(EM_GETPASSWORDCHAR)
{
	PARM(ch, CHAR, RET);

	PLABEL(ch);
	if (ch)
	{
		MOUT << '\'' << ch << "' (" << (INT)(UCHAR)ch << ')';
	}
	else
	{
		MOUT << '0' << ids(IDS_NO_PASSWORD_CHARACTER);
	}

	return TRUE;
}

NODECODEPARM(EM_GETPASSWORDCHAR);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_GETRECT)
{
	PARM(lprc, LPRECT, LP);

	POUTC(lprc, DWORD);

	return TRUE;
}

DECODERET(EM_GETRECT)
{
	PARM(lprc, LPRECT, LP);

	POUTC(lprc, DWORD);
	PIFSIZEOF(RECT)
	{
		PARM(prc, LPRECT, ED);
		POUTRECT(prc);
	}

	return TRUE;
}

DECODEPARM(EM_GETRECT)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(prc, LPRECT, ED2);
		INDENT();
		P2OUT(prc, left);
		P2OUT(prc, top);
		P2OUT(prc, right);
		P2OUT(prc, bottom);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_GETSEL)
{
	PARM(lpdwStart, LPDWORD, WP);
	PARM(lpdwEnd, LPDWORD, LP);

	POUTC(lpdwStart, DWORD);
	POUTC(lpdwEnd, DWORD);

	return TRUE;
}

DECODERET(EM_GETSEL)
{
	PARM(wStart, UINT, LORET);
	PARM(wEnd, UINT, HIRET);
	PARM(lpdwStart, DWORD, WP);
	PARM(lpdwEnd, DWORD, LP);

	POUT(wStart);
	POUT(wEnd);

	PIFSIZEOF(PACK_WPLPDWORDS)
	{
		PARM(ppwld, PPACK_WPLPDWORDS, ED);

		POUTC(lpdwStart, DWORD);
		if (ppwld->fValidWP)
		{
			MOUT << " (" << (INT)ppwld->nWP << ')';
		}

		POUTC(lpdwEnd, DWORD);
		if (ppwld->fValidLP)
		{
			MOUT << " (" << (INT)ppwld->nLP << ')';
		}
	}
	else
	{
		POUTC(lpdwStart, DWORD);
		POUTC(lpdwEnd, DWORD);
	}

	return TRUE;
}

DECODEPARM(EM_GETSEL)
{
	P2IFSIZEOF(PACK_WPLPDWORDS)
	{
		PARM(ppwld, PPACK_WPLPDWORDS, ED2);

		if (ppwld->fValidWP)
		{
			P2WPOUTPTR(DWORD);
			INDENT();
			M2OUT << (INT)ppwld->nWP;
			P2ENDLINE();
			OUTDENT();
		}
		else
		{
			P2WPOUT();
		}

		if (ppwld->fValidLP)
		{
			P2LPOUTPTR(DWORD);
			INDENT();
			M2OUT << (INT)ppwld->nLP;
			P2ENDLINE();
			OUTDENT();
		}
		else
		{
			P2WPOUT();
		}
	}
	else
	{
		P2WPOUT();
		P2LPOUT();
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(EM_GETTHUMB);

NODECODERET(EM_GETTHUMB);

NODECODEPARM(EM_GETTHUMB);

//////////////////////////////////////////////////////////////////////////////

NODECODE(EM_GETWORDBREAKPROC);

DECODERET(EM_GETWORDBREAKPROC)
{
	PARM(ewbprc, EDITWORDBREAKPROC, RET);

	POUTC(ewbprc, DWORD);

	return TRUE;
}

NODECODEPARM(EM_GETWORDBREAKPROC);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_LIMITTEXT)
{
	PARM(cchMax, UINT, WP);

	POUT(cchMax);

	return TRUE;
}

NODECODERET(EM_LIMITTEXT);

NODECODEPARM(EM_LIMITTEXT);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_LINEFROMCHAR)
{
	PARM(ich, INT, WP);

	POUT(ich);

	if (ich == -1)
	{
		MOUT << ids(IDS_CURRENT_LINE);
	}

	return TRUE;
}

DECODERET(EM_LINEFROMCHAR)
{
	PARM(iLine, INT, RET);

	POUT(iLine);

	return TRUE;
}

NODECODEPARM(EM_LINEFROMCHAR);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_LINEINDEX)
{
	PARM(line, INT, WP);

	POUT(line);

	if (line == -1)
	{
		MOUT << ids(IDS_CURRENT_LINE);
	}

	return TRUE;
}

DECODERET(EM_LINEINDEX)
{
	PARM(ich, INT, RET);

	POUT(ich);

	if (ich == -1)
	{
		MOUT << ids(IDS_LINE_IS_OUT_OF_RANGE);
	}

	return TRUE;
}

NODECODEPARM(EM_LINEINDEX);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_LINELENGTH)
{
	PARM(ich, INT, WP);

	POUT(ich);

	return TRUE;
}

DECODERET(EM_LINELENGTH)
{
	PARM(cchLine, INT, RET);

	POUT(cchLine);

	return TRUE;
}

NODECODEPARM(EM_LINELENGTH);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_LINESCROLL)
{
	PARM(cxScroll, INT, WP);
	PARM(cyScroll, INT, LP);

	POUT(cxScroll);
	POUT(cyScroll);

	return TRUE;
}

DECODERET(EM_LINESCROLL)
{
	PARM(fMultiLineEditCtrl, BOOL, RET);

	POUTB(fMultiLineEditCtrl);

	return TRUE;
}

NODECODEPARM(EM_LINESCROLL);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_REPLACESEL)
{
	PARM(lpszReplace, LPCTSTR, LP);

	POUTC(lpszReplace, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

NODECODERET(EM_REPLACESEL);

DECODEPARM(EM_REPLACESEL)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(pstr, LPSTR, ED2);
		INDENT();
		P2OUTS(pstr);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_SCROLL)
{
	PARM(nScroll, INT, WP);

	TABLEORVALUE(tblVScrollCode, nScroll);

	return TRUE;
}

DECODERET(EM_SCROLL)
{
	PARM(fSuccess, BOOL, HIRET);
	PARM(nScrolled, UINT, LORET);

	POUTB(fSuccess);
	if (fSuccess)
	{
		POUTC(nScrolled, INT);
	}

	return TRUE;
}

NODECODEPARM(EM_SCROLL);

//////////////////////////////////////////////////////////////////////////////

NODECODE(EM_SCROLLCARET);

DECODERET(EM_SCROLLCARET)
{
	PARM(fSentToEditCtrl, BOOL, RET);

	POUTB(fSentToEditCtrl);

	return TRUE;
}

NODECODEPARM(EM_SCROLLCARET);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_SETHANDLE)
{
	PARM(hloc, HLOCAL, WP);

	POUTC(hloc, DWORD);

	return TRUE;
}

NODECODERET(EM_SETHANDLE);

NODECODEPARM(EM_SETHANDLE);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_SETMODIFY)
{
	PARM(fModified, BOOL, WP);

	POUTB(fModified);

	return TRUE;
}

NODECODERET(EM_SETMODIFY);

NODECODEPARM(EM_SETMODIFY);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_SETPASSWORDCHAR)
{
	PARM(ch, CHAR, WP);

	PLABEL(ch);
	if (ch == 0)
	{
		MOUT << '0' << ids(IDS_NONE);
	}
	else
	{
		MOUT << '\'' << ch << "' (" << (INT)(UCHAR)ch << ')';
	}

	return TRUE;
}

NODECODERET(EM_SETPASSWORDCHAR);

NODECODEPARM(EM_SETPASSWORDCHAR);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_SETREADONLY)
{
	PARM(fReadOnly, BOOL, WP);

	POUTB(fReadOnly);

	return TRUE;
}

DECODERET(EM_SETREADONLY)
{
	PARM(fSuccess, BOOL, RET);

	POUTB(fSuccess);

	return TRUE;
}

NODECODEPARM(EM_SETREADONLY);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_SETRECT)
{
	PARM(lprc, LPRECT, LP);

	POUTC(lprc, DWORD);
	PIFSIZEOF(RECT)
	{
		PARM(prc, LPRECT, ED);
		POUTRECT(prc);
	}

	return TRUE;
}

NODECODERET(EM_SETRECT);

DECODEPARM(EM_SETRECT)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(prc, LPRECT, ED2);
		INDENT();
		P2OUT(prc, left);
		P2OUT(prc, top);
		P2OUT(prc, right);
		P2OUT(prc, bottom);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_SETRECTNP)
{
	DECODELIKE(EM_SETRECT);
}

NODECODERET(EM_SETRECTNP);

DECODEPARM(EM_SETRECTNP)
{
	DECODEPARMLIKE(EM_SETRECT);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_SETSEL)
{
	PARM(nStart, INT, WP);
	PARM(nEnd, INT, LP);

	POUT(nStart);
	POUT(nEnd);

	if (nStart == 0 && nEnd == -1)
	{
		MOUT << ids(IDS_SELECT_ALL_TEXT);
	}

	return TRUE;
}

NODECODERET(EM_SETSEL);

NODECODEPARM(EM_SETSEL);

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_SETTABSTOPS)
{
	PARM(cTabs, INT, WP);
	PARM(lpnTabs, PUINT, LP);

	POUT(cTabs);

	if (cTabs)
	{
		POUTC(lpnTabs, DWORD);
		PIFDATA()
		{
			PARM(pTabs, PINT, ED);

			PrintIntArray(pTabs, PSIZEOFED() / sizeof(INT), cTabs);
		}
	}
	else
	{
		MOUT << ids(IDS_SET_TABS_TO_DEFAULT);
	}

	return TRUE;
}

DECODERET(EM_SETTABSTOPS)
{
	PARM(fSuccess, BOOL, RET);

	POUTB(fSuccess);

	return TRUE;
}

DECODEPARM(EM_SETTABSTOPS)
{
	P2WPOUT();

	P2LPOUTPTR(INT array);
	P2IFDATA()
	{
		PARM(pTabs, PINT, ED2);
		PARM(cTabs, INT, WP2);
		INDENT();
		PrintIntArray2(pmps, pTabs, P2SIZEOFED() / sizeof(INT), cTabs);
		P2ENDLINE();
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(EM_SETWORDBREAKPROC)
{
	PARM(ewbprc, EDITWORDBREAKPROC, LP);

	POUTC(ewbprc, DWORD);

	return TRUE;
}

NODECODERET(EM_SETWORDBREAKPROC);

NODECODEPARM(EM_SETWORDBREAKPROC);

//////////////////////////////////////////////////////////////////////////////

NODECODE(EM_UNDO);

DECODERET(EM_UNDO)
{
	PARM(fSuccess, BOOL, RET);

	POUTB(fSuccess);

	return TRUE;
}

NODECODEPARM(EM_UNDO);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\filtrdlg.cpp ===
// filtrdlg.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"
#include "findtool.h"
#include "filtrdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFiltersTabbedDialog

CFiltersTabbedDialog::~CFiltersTabbedDialog()
{
	CMsgDoc::m_iInitialTab = m_nTabCur;
}


BEGIN_MESSAGE_MAP(CFiltersTabbedDialog, CTabbedDialog)
	//{{AFX_MSG_MAP(CFiltersTabbedDialog)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CFiltersTabbedDialog message handlers

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\findtool.h ===
// findtool.h : header file
//


class CFiltersWindowDlgTab;
class CFindWindowDlg;
class CSearchWindowDlg;
class CSearchMessageDlg;
class CSearchWindowDlgTab;
class CSearchMessageDlgTab;

/////////////////////////////////////////////////////////////////////////////
// CFindToolIcon

class CFindToolIcon : public CStatic
{
// Construction
public:
	CFindToolIcon() {}

// Attributes
public:

// Operations
public:
	void Initialize(CFiltersWindowDlgTab* pFiltersWindowDlgTab);
	void Initialize(CFindWindowDlg* pFindWindowDlg);
	void Initialize(CSearchWindowDlg* pSearchWindowDlg);
	void Initialize(CSearchMessageDlg* pSearchMessageDlg);

// Implementation
public:
	virtual ~CFindToolIcon() {}

protected:
	void DrawWindowFrame(HWND hwnd);
	void StartFlash(HWND hwnd);
	void StopFlash();

	CFiltersWindowDlgTab* m_pFiltersWindowDlgTab;
	CFindWindowDlg* m_pFindWindowDlg;
	CSearchWindowDlg* m_pSearchWindowDlg;
	CSearchMessageDlg* m_pSearchMessageDlg;
	HWND m_hwndFlash;
	HWND m_hwndSubjectLast;
	BOOL m_fHilite;

	// Generated message map functions
protected:
	//{{AFX_MSG(CFindToolIcon)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg UINT OnNcHitTest(CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\findwdlg.cpp ===
// findwdlg.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "findtool.h"
#include "findwdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFindWindowDlg dialog

CFindWindowDlg::CFindWindowDlg(CWnd *pParentWnd) : CDialog(CFindWindowDlg::IDD, pParentWnd)
{
	//{{AFX_DATA_INIT(CFindWindowDlg)
	m_ShowProperties = TRUE;
	m_ShowMessages = FALSE;
	//}}AFX_DATA_INIT
}

CFindWindowDlg::~CFindWindowDlg()
{
}

void CFindWindowDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFindWindowDlg)
	DDX_Check(pDX, IDC_FW_SHOWPROPERTIES, m_ShowProperties);
	DDX_Check(pDX, IDC_FW_SHOWMESSAGES, m_ShowMessages);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFindWindowDlg, CDialog)
	//{{AFX_MSG_MAP(CFindWindowDlg)
	ON_BN_CLICKED(IDC_FW_HIDESPY, OnClickedHide)
	ON_EN_KILLFOCUS(IDC_FW_ENTERHWND, VerifyEnteredHwnd)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CFindWindowDlg message handlers

BOOL CFindWindowDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	CFont* pFont = GetStdFont(font_Normal);
	ASSERT(pFont);
	HFONT hfont = (HFONT)pFont->m_hObject;

	SendDlgItemMessage(IDC_FW_ENTERHWND, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_FW_CAPTION, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_FW_CLASS, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_FW_STYLE, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_FW_RECT, WM_SETFONT, (WPARAM)hfont, FALSE);

// begin special font mucking-around
	if (_getmbcp() != 0)
	{
		pFont = GetStdFont(font_Fixed);
		ASSERT(pFont);
		hfont = (HFONT)pFont->m_hObject;

		SendDlgItemMessage(IDC_FW_CAPTION, WM_SETFONT, (WPARAM)hfont, FALSE);
		SendDlgItemMessage(IDC_FW_CLASS, WM_SETFONT, (WPARAM)hfont, FALSE);
	}
// end special font mucking-around

	m_FindToolIcon.SubclassDlgItem(IDC_FW_FINDTOOL, this);
	m_FindToolIcon.Initialize(this);

	m_hwndSelected = (HWND)NULL;

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CFindWindowDlg::OnOK()
{
	HWND hwndSelected;
	CHAR szHwnd[9];

	GetDlgItemText(IDC_FW_ENTERHWND, szHwnd, sizeof(szHwnd));

	hwndSelected = (HWND)_tcstoul(szHwnd, NULL, 16);

	if (::IsWindow(hwndSelected))
	{
		if (!IsSpyableWindow(hwndSelected))
		{
			SpyMessageBox(IDS_WND_NOT_SPYABLE);
			GotoDlgCtrl(GetDlgItem(IDC_FW_ENTERHWND));
			return;
		}

		m_hwndSelected = hwndSelected;

		// Restore the Spy app if necessary.
		if (IsDlgButtonChecked(IDC_FW_HIDESPY))
		{
			theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
			CheckDlgButton(IDC_FW_HIDESPY, 0);
		}
		CDialog::OnOK();
	}
	else
	{
		SpyMessageBox(IDS_FW_INVALIDHWND);
		GotoDlgCtrl(GetDlgItem(IDC_FW_ENTERHWND));
	}
}

void CFindWindowDlg::OnCancel()
{
	// Restore the Spy app if necessary.
	if (IsDlgButtonChecked(IDC_FW_HIDESPY))
	{
		theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
		CheckDlgButton(IDC_FW_HIDESPY, 0);
	}
	CDialog::OnCancel();
}

void CFindWindowDlg::SetSelectedWindow(HWND hwndSelected)
{
	CHAR sz[256];
	LPSTR lpszClass;
	int cch;
	RECT rc;

	if (::IsWindow(hwndSelected))
	{
		wsprintf(sz, "%08X", hwndSelected);
		SetDlgItemText(IDC_FW_ENTERHWND, sz);

		sz[0] = '"';
		cch = ::GetWindowText(hwndSelected, &sz[1], 256 - 2);
		sz[cch + 1] = '"';
		sz[cch + 2] = 0;
		SetDlgItemText(IDC_FW_CAPTION, sz);

		::GetClassName(hwndSelected, sz, 256);
		if ((lpszClass = GetExpandedClassName(sz)) != NULL)
			_tcscat(sz, lpszClass);
		SetDlgItemText(IDC_FW_CLASS, sz);

		wsprintf(sz, "%08X", ::GetWindowLong(hwndSelected, GWL_STYLE));
		SetDlgItemText(IDC_FW_STYLE, sz);

		::GetWindowRect(hwndSelected, &rc);
		wsprintf(sz, "(%d, %d)-(%d, %d) %dx%d", rc.left, rc.top, rc.right, rc.bottom, rc.right - rc.left, rc.bottom - rc.top);
		SetDlgItemText(IDC_FW_RECT, sz);
	}
	else
	{
		SetDlgItemText(IDC_FW_ENTERHWND, "");
		SetDlgItemText(IDC_FW_CAPTION, "");
		SetDlgItemText(IDC_FW_CLASS, "");
		SetDlgItemText(IDC_FW_STYLE, "");
		SetDlgItemText(IDC_FW_RECT, "");
	}
}

void CFindWindowDlg::VerifyEnteredHwnd()
{
	HWND hwndSelected;
	CHAR szHwnd[9];
	CHAR sz[256];
	LPSTR lpszClass;
	int cch;
	RECT rc;

	GetDlgItemText(IDC_FW_ENTERHWND, szHwnd, sizeof(szHwnd));

	hwndSelected = (HWND)_tcstoul(szHwnd, NULL, 16);	// assume user entered HWND in hex

	if (::IsWindow(hwndSelected))
	{
		sz[0] = '"';
		cch = ::GetWindowText(hwndSelected, &sz[1], 256 - 2);
		sz[cch + 1] = '"';
		sz[cch + 2] = 0;
		SetDlgItemText(IDC_FW_CAPTION, sz);

		::GetClassName(hwndSelected, sz, 256);
		if ((lpszClass = GetExpandedClassName(sz)) != NULL)
			_tcscat(sz, lpszClass);
		SetDlgItemText(IDC_FW_CLASS, sz);

		wsprintf(sz, "%08X", ::GetWindowLong(hwndSelected, GWL_STYLE));
		SetDlgItemText(IDC_FW_STYLE, sz);

		::GetWindowRect(hwndSelected, &rc);
		wsprintf(sz, "(%d, %d)-(%d, %d) %dx%d", rc.left, rc.top, rc.right, rc.bottom, rc.right - rc.left, rc.bottom - rc.top);
		SetDlgItemText(IDC_FW_RECT, sz);
	}
	else
	{
		SetDlgItemText(IDC_FW_CAPTION, "");
		SetDlgItemText(IDC_FW_CLASS, "");
		SetDlgItemText(IDC_FW_STYLE, "");
		SetDlgItemText(IDC_FW_RECT, "");
	}
}

void CFindWindowDlg::BeginFindWindowTracking()
{
	SetSelectedWindow((HWND)NULL);
	m_hwndFound = NULL;
}

void CFindWindowDlg::UpdateFindWindowTracking(HWND hwndFound)
{
	SetSelectedWindow(hwndFound);
	m_hwndFound = hwndFound;
}

void CFindWindowDlg::EndFindWindowTracking()
{
	if (m_hwndFound)
		m_hwndSelected = m_hwndFound;
}

void CFindWindowDlg::OnClickedHide()
{
	if (IsDlgButtonChecked(IDC_FW_HIDESPY))
	{
		theApp.m_pMainWnd->ShowWindow(SW_HIDE);
	}
	else
	{
		theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
	}
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\findtool.cpp ===
// findtool.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "findtool.h"
#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"
#include "filtrdlg.h"
#include "findwdlg.h"
#include "srchdlgs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BOOL IsPointInWindow(HWND hwnd, CPoint point)
{
	RECT rc;

	GetWindowRect(hwnd, &rc);

	return(PtInRect(&rc, point));

	if (point.x >= rc.left && point.x <= rc.right &&
		point.y >= rc.top && point.y <= rc.bottom)
	{
		return TRUE;
	}
	else
		return FALSE;
}

HWND TopChildWindowFromPoint(HWND hwnd, CPoint point)
{
	if (hwnd == NULL)
		return(NULL);

	HWND hwndFirstChild = ::GetWindow(hwnd, GW_CHILD);
	if (hwndFirstChild == NULL)
		return(NULL);

	HWND hwndLastChild = ::GetWindow(hwndFirstChild, GW_HWNDLAST);
	if (IsPointInWindow(hwndLastChild, point))
	{
		return(hwndLastChild);
	}
	else
	{
		HWND hwndPrev = hwndLastChild;
		while ((hwndPrev = ::GetWindow(hwndPrev, GW_HWNDPREV)) != NULL)
		{
			if (IsPointInWindow(hwndPrev, point))
				return(hwndPrev);
		}
	}
	return(NULL);
}

HWND TopSiblingWindowFromPoint(HWND hwnd, CPoint point)
{
	if (hwnd == NULL)
		return(NULL);

	HWND hwndLastSibling = ::GetWindow(hwnd, GW_HWNDLAST);
	if (IsPointInWindow(hwndLastSibling, point))
	{
		return(hwndLastSibling);
	}
	else
	{
		HWND hwndPrev = hwndLastSibling;
		while ((hwndPrev = ::GetWindow(hwndPrev, GW_HWNDPREV)) != NULL)
		{
			if (IsPointInWindow(hwndPrev, point))
				return(hwndPrev);
		}
	}
	// shouldn't ever get here...
	ASSERT(FALSE);
	return(NULL);
}

BOOL IsWindowRectInWindowRect(HWND hwndContainee, HWND hwndContainer)
{
	RECT rcContainee;
	RECT rcContainer;

	GetWindowRect(hwndContainee, &rcContainee);
	GetWindowRect(hwndContainer, &rcContainer);

	if (rcContainee.top >= rcContainer.top && rcContainee.bottom <= rcContainer.bottom &&
		rcContainee.left >= rcContainer.left && rcContainee.right <= rcContainer.right)
	{
		return TRUE;
	}
	else
		return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CFindToolIcon

void CFindToolIcon::Initialize(CFiltersWindowDlgTab* pFiltersWindowDlgTab)
{
	m_pFiltersWindowDlgTab = pFiltersWindowDlgTab;
	m_pFindWindowDlg = NULL;
	m_pSearchWindowDlg = NULL;
	m_pSearchMessageDlg = NULL;
	m_hwndFlash = NULL;
	m_fHilite = FALSE;
	m_hwndSubjectLast = (HWND)-1;
}

void CFindToolIcon::Initialize(CFindWindowDlg* pFindWindowDlg)
{
	m_pFindWindowDlg = pFindWindowDlg;
	m_pFiltersWindowDlgTab = NULL;
	m_pSearchWindowDlg = NULL;
	m_pSearchMessageDlg = NULL;
	m_hwndFlash = NULL;
	m_fHilite = FALSE;
	m_hwndSubjectLast = (HWND)-1;
}

void CFindToolIcon::Initialize(CSearchWindowDlg* pSearchWindowDlg)
{
	m_pSearchWindowDlg = pSearchWindowDlg;
	m_pFiltersWindowDlgTab = NULL;
	m_pFindWindowDlg = NULL;
	m_pSearchMessageDlg = NULL;
	m_hwndFlash = NULL;
	m_fHilite = FALSE;
	m_hwndSubjectLast = (HWND)-1;
}

void CFindToolIcon::Initialize(CSearchMessageDlg* pSearchMessageDlg)
{
	m_pSearchMessageDlg = pSearchMessageDlg;
	m_pSearchWindowDlg = NULL;
	m_pFiltersWindowDlgTab = NULL;
	m_pFindWindowDlg = NULL;
	m_hwndFlash = NULL;
	m_fHilite = FALSE;
	m_hwndSubjectLast = (HWND)-1;
}

BEGIN_MESSAGE_MAP(CFindToolIcon, CWnd)
	//{{AFX_MSG_MAP(CFindToolIcon)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_NCHITTEST()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CFindToolIcon message handlers

void CFindToolIcon::OnLButtonDown(UINT nFlags, CPoint point)
{
	SetCapture();
	::SetCursor(theApp.m_hcurFindTool);
	SendMessage(STM_SETICON, (WPARAM)theApp.m_hiconFindTool2);
	UpdateWindow();
	if (m_pFiltersWindowDlgTab)
		m_pFiltersWindowDlgTab->BeginFindWindowTracking();
	else if (m_pFindWindowDlg)
		m_pFindWindowDlg->BeginFindWindowTracking();
	else if (m_pSearchMessageDlg)
		m_pSearchMessageDlg->BeginFindWindowTracking();
	else
		m_pSearchWindowDlg->BeginFindWindowTracking();

	CWnd::OnLButtonDown(nFlags, point);
}

void CFindToolIcon::OnMouseMove(UINT nFlags, CPoint point)
{
	if (GetCapture())
	{
		HWND  hwndSubject;
		DWORD pidSpyxx;
		DWORD pidHwndFound;

		ClientToScreen(&point);

		hwndSubject = ::WindowFromPoint(point);

		//
		// Don't find windows of the Spy++ app itself.
		//
		if (hwndSubject)
		{
			GetWindowThreadProcessId(theApp.m_pMainWnd->m_hWnd, &pidSpyxx);
			GetWindowThreadProcessId(hwndSubject, &pidHwndFound);
			if (pidHwndFound == pidSpyxx)
			{
				hwndSubject = NULL;
			}
		}

		HWND hwndChild = TopChildWindowFromPoint(hwndSubject, point);
		while (hwndChild != NULL && hwndChild != hwndSubject)
		{
			hwndSubject = TopSiblingWindowFromPoint(hwndChild, point);
			hwndChild = TopChildWindowFromPoint(hwndSubject, point);
		}

		DWORD dwStyles = GetWindowLong(hwndSubject, GWL_STYLE);
		if (dwStyles & WS_CHILD)
			hwndSubject = TopSiblingWindowFromPoint(hwndSubject, point);

		//
		// Only update if something changed.
		//
		if (hwndSubject != m_hwndSubjectLast)
		{
			StopFlash();
			if (m_pFiltersWindowDlgTab)
				m_pFiltersWindowDlgTab->UpdateFindWindowTracking(hwndSubject);
			else if (m_pFindWindowDlg)
				m_pFindWindowDlg->UpdateFindWindowTracking(hwndSubject);
			else if (m_pSearchMessageDlg)
				m_pSearchMessageDlg->UpdateFindWindowTracking(hwndSubject);
			else
				m_pSearchWindowDlg->UpdateFindWindowTracking(hwndSubject);
			m_hwndSubjectLast = hwndSubject;
			StartFlash(hwndSubject);
		}
	}

	CWnd::OnMouseMove(nFlags, point);
}

void CFindToolIcon::OnLButtonUp(UINT nFlags, CPoint point)
{
	ReleaseCapture();
	StopFlash();
	SendMessage(STM_SETICON, (WPARAM)theApp.m_hiconFindTool);
	if (m_pFiltersWindowDlgTab)
		m_pFiltersWindowDlgTab->EndFindWindowTracking();
	else if (m_pFindWindowDlg)
		m_pFindWindowDlg->EndFindWindowTracking();
	else if (m_pSearchMessageDlg)
		m_pSearchMessageDlg->EndFindWindowTracking();
	else
		m_pSearchWindowDlg->EndFindWindowTracking();

	CWnd::OnLButtonUp(nFlags, point);
}

UINT CFindToolIcon::OnNcHitTest(CPoint)
{
	return HTCLIENT;
}

void CFindToolIcon::DrawWindowFrame(HWND hwnd)
{
	HDC hdc;
	RECT rc;
	HPEN hpen;
	HPEN hpenOld;
	HBRUSH hbrOld;
	int cxBorder = ::GetSystemMetrics(SM_CXBORDER);
	int cyBorder = ::GetSystemMetrics(SM_CYBORDER);
	int cxFrame  = ::GetSystemMetrics(SM_CXFRAME);
	int cyFrame  = ::GetSystemMetrics(SM_CYFRAME);
	int cxScreen = ::GetSystemMetrics(SM_CXSCREEN);
	int cyScreen = ::GetSystemMetrics(SM_CYSCREEN);

	::GetWindowRect(hwnd, &rc);
	hdc = ::GetWindowDC(hwnd);
	::SetROP2(hdc, R2_NOT);
	hpen = ::CreatePen(PS_INSIDEFRAME, 3 * cxBorder, RGB(0, 0, 0));

	hpenOld = (HPEN)::SelectObject(hdc, hpen);
	hbrOld = (HBRUSH)::SelectObject(hdc, ::GetStockObject(NULL_BRUSH));
	if (::IsZoomed(hwnd))
		::Rectangle(hdc, cxFrame, cyFrame, cxScreen + cxFrame, cyScreen + cyFrame);
	else
		::Rectangle(hdc, 0, 0, rc.right - rc.left, rc.bottom - rc.top);
	::SelectObject(hdc, hbrOld);
	::SelectObject(hdc, hpenOld);

	::ReleaseDC(hwnd, hdc);
	::DeleteObject(hpen);
}

void CFindToolIcon::StartFlash(HWND hwnd)
{
	if (hwnd)
	{
		DrawWindowFrame(hwnd);
		m_hwndFlash = hwnd;
		m_fHilite = TRUE;
	}
}

void CFindToolIcon::StopFlash()
{
	if (m_fHilite)
		DrawWindowFrame(m_hwndFlash);

	m_fHilite = FALSE;
	m_hwndFlash = NULL;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\findwdlg.h ===
// findwdlg.h : header file
//

class CFindWindowDlg;
class CSearchWindowDlg;
class CSearchProcessDlg;
class CSearchThreadDlg;
class CSearchMessageDlg;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CFindWindowDlg window

class CFindWindowDlg : public CDialog
{
// Construction
public:
	CFindWindowDlg(CWnd *pParentWnd = NULL);

// Dialog Data
	//{{AFX_DATA(CFindWindowDlg)
	enum { IDD = IDD_FINDWINDOW };
	BOOL	m_ShowProperties;
	BOOL	m_ShowMessages;
	//}}AFX_DATA

// Implementation
public:
	virtual ~CFindWindowDlg();
	HWND GetSelectedHwnd()
	{
		return(m_hwndSelected);
	}

protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	void BeginFindWindowTracking();
	void UpdateFindWindowTracking(HWND hwndFound);
	void EndFindWindowTracking();

	void SetSelectedWindow(HWND hwndSelected);

	HWND m_hwndSelected;
	HWND m_hwndFound;
	CFindToolIcon m_FindToolIcon;

	// Generated message map functions
protected:
	//{{AFX_MSG(CFindWindowDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnClickedHide();
	afx_msg void VerifyEnteredHwnd();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	friend class CFindToolIcon;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\fontdlg.cpp ===
// fontdlg.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "fontdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFontDlg dialog

void CFontDlg::DoDataExchange(CDataExchange* pDX)
{
	CFontDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontDlg)
	DDX_Check(pDX, IDC_FONT_SAVE, m_fSave);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFontDlg, CFontDialog)
	//{{AFX_MSG_MAP(CFontDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CFontDlg dialog message handlers

void CFontDlg::OnOK()
{
	UpdateData();
	CFontDialog::OnOK();
}

/////////////////////////////////////////////////////////////////////////////

HFONT SpyFontDialog(HFONT hfontInitial)
{
	ASSERT(hfontInitial);

	LOGFONT lf;
	::GetObject(hfontInitial, sizeof(LOGFONT), &lf);
	CFontDlg dlg(&lf, CF_FORCEFONTEXIST | CF_SCREENFONTS | CF_ENABLETEMPLATE);

	dlg.m_cf.lpTemplateName = MAKEINTRESOURCE(CFontDlg::IDD);

	if (dlg.DoModal() == IDOK)
	{
		HFONT hfont = ::CreateFontIndirect(&lf);
		ASSERT(hfont);

		if (dlg.m_fSave)
		{
			::GetObject(hfont, sizeof(LOGFONT), &theApp.m_DefLogFont);
		}

		return hfont;
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\filtrdlg.h ===
// filtrdlg.h : header file
//


class CFiltersTabbedDialog;
class CFiltersWindowDlgTab;
class CFiltersMessageDlgTab;
class CFiltersOutputDlgTab;

/////////////////////////////////////////////////////////////////////////////
// CFiltersTabbedDialog window

class CFiltersTabbedDialog : public CTabbedDialog
{
// Construction
public:
	CFiltersTabbedDialog(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectTab = -1)
		: CTabbedDialog(nIDCaption, pParentWnd, iSelectTab) {}

// Implementation
public:
	virtual ~CFiltersTabbedDialog();
	void SetDocPointer(CMsgDoc *pDoc)
	{
		m_pDoc = pDoc;
	}

protected:
	CMsgDoc *m_pDoc;

	// Generated message map functions
protected:
	//{{AFX_MSG(CFiltersTabbedDialog)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CFiltersWindowDlgTab;
	friend class CFiltersMessageDlgTab;
	friend class CFiltersOutputDlgTab;
};



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CFiltersWindowDlgTab window

class CFiltersWindowDlgTab : public CDlgTab
{
// Construction
public:
	CFiltersWindowDlgTab(UINT nIDTemplate, UINT nIDCaption)
		: CDlgTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CFiltersWindowDlgTab)
	enum { IDD = IDD_FILTERSWINDOWTAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CFiltersWindowDlgTab();

protected:
	virtual BOOL ValidateTab();
	virtual void CommitTab();
	virtual void CancelTab();

	void BeginFindWindowTracking();
	void UpdateFindWindowTracking(HWND hwndFound);
	void EndFindWindowTracking();

	void UpdateSOBFields();
	void ShowSOBLabels(int nObjectType);
	void SetSelectedWindow(HWND hwndSelected);
	void SetSelectedThread(DWORD tid);
	void SetSelectedProcess(DWORD pid);
	void EnableCheckboxes(BOOL fEnable);
	void GraySOB(BOOL fGray);

	CMsgDoc *m_pDoc;
	HWND m_hwndSelected;
	HWND m_hwndFound;
	int m_nObjectType;
	CFindToolIcon m_FindToolIcon;

	// Generated message map functions
protected:
	//{{AFX_MSG(CFiltersWindowDlgTab)
	afx_msg void OnClickedWinFiltersAllWindows();
	afx_msg void OnClickedHide();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CFindToolIcon;
	friend class CFiltersTabbedDialog;
};



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CFiltersMessageDlgTab window

class CFiltersMessageDlgTab : public CDlgTab
{
// Construction
public:
	CFiltersMessageDlgTab(UINT nIDTemplate, UINT nIDCaption)
		: CDlgTab(nIDTemplate, nIDCaption)
	{
		m_paiSelected = NULL;
		m_paiSelected2 = NULL;
	}

// Dialog Data
	//{{AFX_DATA(CFiltersMessageDlgTab)
	enum { IDD = IDD_FILTERSMESSAGETAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CFiltersMessageDlgTab();

protected:
	virtual void CommitTab();

	void UpdateCheckBoxes();

	CMsgDoc * m_pDoc;
	int * m_paiSelected;
	int * m_paiSelected2;
	int m_cItemsSave;

private:
	static BOOL m_fInitializedStatic;		   // TRUE if static data init'd
	static MSGGROUP m_aMsgGroup[];
	static INT m_cMsgGroups;

	static void InitStaticData();

	void OnClickedGroup(int iGroup);

	// Generated message map functions
	//{{AFX_MSG(CFiltersMessageDlgTab)
	afx_msg void OnClickedMsgFiltersAll();
	afx_msg void OnClickedMsgFiltersNone();
	afx_msg void OnClickedMsgFiltersBM();
	afx_msg void OnClickedMsgFiltersCB();
	afx_msg void OnClickedMsgFiltersClip();
	afx_msg void OnClickedMsgFiltersDDE();
	afx_msg void OnClickedMsgFiltersEM();
	afx_msg void OnClickedMsgFiltersKeybd();
	afx_msg void OnClickedMsgFiltersLB();
	afx_msg void OnClickedMsgFiltersMouse();
	afx_msg void OnClickedMsgFiltersNC();
	afx_msg void OnClickedMsgFiltersSTM();
	afx_msg void OnClickedMsgFiltersMDI();
	afx_msg void OnClickedMsgFiltersSBM();
	afx_msg void OnClickedMsgFiltersIME();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeMsgFiltersList();
	afx_msg void OnClickedMsgFiltersDlg();
	afx_msg void OnClickedMsgFiltersAni();
	afx_msg void OnClickedMsgFiltersHdr();
	afx_msg void OnClickedMsgFiltersHK();
	afx_msg void OnClickedMsgFiltersLV();
	afx_msg void OnClickedMsgFiltersProg();
	afx_msg void OnClickedMsgFiltersStat();
	afx_msg void OnClickedMsgFiltersTab();
	afx_msg void OnClickedMsgFiltersTB();
	afx_msg void OnClickedMsgFiltersTrk();
	afx_msg void OnClickedMsgFiltersTT();
	afx_msg void OnClickedMsgFiltersTV();
	afx_msg void OnClickedMsgFiltersUD();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CFiltersTabbedDialog;
};



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CFiltersOutputDlgTab window

class CFiltersOutputDlgTab : public CDlgTab
{
// Construction
public:
	CFiltersOutputDlgTab(UINT nIDTemplate, UINT nIDCaption)
		: CDlgTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CFiltersOutputDlgTab)
	enum { IDD = IDD_FILTERSOUTPUTTAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CFiltersOutputDlgTab();

protected:
	virtual BOOL ValidateTab();
	virtual void CommitTab();

	CMsgDoc *m_pDoc;

	// Generated message map functions
protected:
	//{{AFX_MSG(CFiltersOutputDlgTab)
	virtual BOOL OnInitDialog();
	afx_msg void OnClickedLogToFile();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CFiltersTabbedDialog;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\fontdlg.h ===
// fontdlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFontDlg dialog

class CFontDlg : public CFontDialog
{
// Construction
public:
	CFontDlg(LPLOGFONT lplfInitial = NULL, DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS, CDC* pdcPrinter = NULL, CWnd* pParentWnd = NULL)
		: CFontDialog(lplfInitial, dwFlags, pdcPrinter, pParentWnd)
	{
		m_fSave = FALSE;
		m_nIDHelp = CFontDlg::IDD;
	}

// Dialog Data
	//{{AFX_DATA(CFontDlg)
	enum {IDD = IDD_FONT};
	BOOL	m_fSave;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	// Generated message map functions
	//{{AFX_MSG(CFontDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


HFONT SpyFontDialog(HFONT hfontInitial);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\hdrmsgs.cpp ===
//-----------------------------------------------------------------------------
//  HdrMsgs.cpp
//
//  System header (Chicago control) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifndef DISABLE_WIN95_MESSAGES
//////////////////////////////////////////////////////////////////////////////

NODECODE(HDM_GETITEMCOUNT);

DECODERET(HDM_GETITEMCOUNT)
{
	PARM(nCount, INT, RET);
	POUTC(nCount, INT);

	return TRUE;
}

NODECODEPARM(HDM_GETITEMCOUNT);

//////////////////////////////////////////////////////////////////////////////

DECODE(HDM_INSERTITEM)
{
	PARM(index, UINT, WP);
	PARM(phdi, HD_ITEM FAR *, LP);

	POUTC(index, INT);
	POUTC(phdi, DWORD);

	return TRUE;
}

DECODERET(HDM_INSERTITEM)
{
	PARM(nIndex, INT, RET);
	POUTC(nIndex, INT);

	return TRUE;
}

DECODEPARM(HDM_INSERTITEM)
{
	P2WPOUT();

	P2LPOUTPTR(HD_ITEM);
	P2IFSIZEOF(HD_ITEM)
	{
		PARM(phdi, HD_ITEM FAR *, ED2);
//		PARM(pszItem, LPSTR, phdi->pszText);
		INDENT();
		P2OUTC(phdi, mask, UINT);
		P2OUTC(phdi, cxy, INT);
		P2OUTPTRSTR(phdi, pszText);
//		INDENT();
//		P2OUTS(pszItem);
//		OUTDENT();
		P2OUTC(phdi, hbm, DWORD);
		P2OUTC(phdi, cchTextMax, INT);
		P2OUTC(phdi, fmt, INT);
		P2OUTC(phdi, lParam, DWORD);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(HDM_DELETEITEM)
{
	PARM(index, UINT, WP);
	PARM(phdi, HD_ITEM FAR *, LP);

	POUTC(index, INT);
	POUTC(phdi, DWORD);

	return TRUE;
}

DECODERET(HDM_DELETEITEM)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(HDM_DELETEITEM)
{
	P2WPOUT();

	P2LPOUTPTR(HD_ITEM);
	P2IFSIZEOF(HD_ITEM)
	{
		PARM(phdi, HD_ITEM FAR *, ED2);
//		PARM(pszItem, LPSTR, phdi->pszText);
		INDENT();
		P2OUTC(phdi, mask, UINT);
		P2OUTC(phdi, cxy, INT);
		P2OUTPTRSTR(phdi, pszText);
//		INDENT();
//		P2OUTS(pszItem);
//		OUTDENT();
		P2OUTC(phdi, hbm, DWORD);
		P2OUTC(phdi, cchTextMax, INT);
		P2OUTC(phdi, fmt, INT);
		P2OUTC(phdi, lParam, DWORD);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(HDM_GETITEM)
{
	DECODELIKE(HDM_SETITEM);
}

DECODERET(HDM_GETITEM)
{
	DECODERETLIKE(HDM_SETITEM);
}

DECODEPARM(HDM_GETITEM)
{
	DECODEPARMLIKE(HDM_SETITEM);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(HDM_SETITEM)
{
	PARM(index, UINT, WP);
	PARM(phdi, HD_ITEM FAR *, LP);

	POUTC(index, INT);
	POUTC(phdi, DWORD);

	return TRUE;
}

DECODERET(HDM_SETITEM)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(HDM_SETITEM)
{
	P2WPOUT();

	P2LPOUTPTR(HD_ITEM);
	P2IFSIZEOF(HD_ITEM)
	{
		PARM(phdi, HD_ITEM FAR *, ED2);
//		PARM(pszItem, LPSTR, phdi->pszText);
		INDENT();
		P2OUTC(phdi, mask, UINT);
		P2OUTC(phdi, cxy, INT);
		P2OUTPTRSTR(phdi, pszText);
//		INDENT();
//		P2OUTS(pszItem);
//		OUTDENT();
		P2OUTC(phdi, hbm, DWORD);
		P2OUTC(phdi, cchTextMax, INT);
		P2OUTC(phdi, fmt, INT);
		P2OUTC(phdi, lParam, DWORD);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(HDM_LAYOUT)
{
	PARM(playout, HD_LAYOUT FAR *, LP);

	POUTC(playout, DWORD);

	return TRUE;
}

DECODERET(HDM_LAYOUT)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(HDM_LAYOUT)
{
	P2WPOUT();

	P2LPOUTPTR(HD_LAYOUT);
	P2IFSIZEOF(HD_LAYOUT)
	{
		PARM(playout, HD_LAYOUT FAR *, ED2);
		INDENT();
		P2OUTPTR(playout, prc, RECT);
		P2OUTPTR(playout, pwpos, WINDOWPOS);
//		M2OUT << '(' << playout->prc->left << ',' << playout->prc->top << ") - ("
//				<< playout->prc->right << ',' << playout->prc->bottom << ')';							
//		// REVIEW: crack WINDOWPOS structure here
//		P2OUTC(playout, pwpos, DWORD);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(HDM_HITTEST)
{
	PARM(phdhti, HD_HITTESTINFO FAR *, LP);

	POUTC(phdhti, DWORD);

	return TRUE;
}

DECODERET(HDM_HITTEST)
{
	PARM(nIndex, INT, RET);
	POUTC(nIndex, INT);

	return TRUE;
}

DECODEPARM(HDM_HITTEST)
{
	P2WPOUT();

	P2LPOUTPTR(HD_HITTESTINFO);
	P2IFSIZEOF(HD_HITTESTINFO)
	{
		PARM(phdhti, HD_HITTESTINFO FAR *, ED2);
		INDENT();
		P2OUTPT(phdhti, pt);
		P2OUTC(phdhti, flags, UINT);
		P2OUTC(phdhti, iItem, INT);
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(HDM_INSERTITEMW);

NODECODERET(HDM_INSERTITEMW);

NODECODEPARM(HDM_INSERTITEMW);

//////////////////////////////////////////////////////////////////////////////

NODECODE(HDM_GETITEMW);

NODECODERET(HDM_GETITEMW);

NODECODEPARM(HDM_GETITEMW);

//////////////////////////////////////////////////////////////////////////////

NODECODE(HDM_SETITEMW);

NODECODERET(HDM_SETITEMW);

NODECODEPARM(HDM_SETITEMW);

//////////////////////////////////////////////////////////////////////////////
#endif	// DISABLE_WIN95_MESSAGES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\ime32.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1985-92, Microsoft Corporation

Module Name:

    ime.h

Abstract:

    Procedure declarations, constant definitions and macros for the IME
    component.

--*/

#ifndef _IME_
#define _IME_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


#ifdef KOREA     // BeomOh - 10/05/92
#define CP_HWND                 0
#define CP_OPEN                 1
#define CP_DIRECT               2
#define CP_LEVEL                3

#define lpSource(lpks) (LPSTR)((LPSTR)lpks+lpks->dchSource)
#define lpDest(lpks)   (LPSTR)((LPSTR)lpks+lpks->dchDest)
#endif // KOREA

//
//      Virtual Keys
//
#ifdef KOREA    // BeomOh - 9/29/92
#define VK_FINAL        0x18    /* dummy VK to make final on mouse down */
#define VK_CONVERT      0x1C
#define VK_NONCONVERT   0x1D
#define VK_ACCEPT       0x1E
#define VK_MODECHANGE   0x1F
#else // KOREA
#define VK_DBE_ALPHANUMERIC              0x0f0
#define VK_DBE_KATAKANA                  0x0f1
#define VK_DBE_HIRAGANA                  0x0f2
#define VK_DBE_SBCSCHAR                  0x0f3
#define VK_DBE_DBCSCHAR                  0x0f4
#define VK_DBE_ROMAN                     0x0f5
#define VK_DBE_NOROMAN                   0x0f6
#define VK_DBE_ENTERWORDREGISTERMODE     0x0f7
#define VK_DBE_ENTERIMECONFIGMODE        0x0f8
#define VK_DBE_FLUSHSTRING               0x0f9
#define VK_DBE_CODEINPUT                 0x0fa
#define VK_DBE_NOCODEINPUT               0x0fb
#define VK_DBE_DETERMINESTRING           0x0fc
#endif // KOREA


//
//     switch for wParam of IME_SETCONVERSIONWINDOW
//
#define	MCW_DEFAULT             0x00
#define	MCW_RECT                0x01
#define MCW_WINDOW              0x02
#define MCW_SCREEN              0x04
#define	MCW_VERTICAL            0x08
#define MCW_HIDDEN              0x10

//
//    switch for wParam of IME_SETCONVERSIONMODE
//       and IME_GETCONVERSIONMODE
//
#define IME_MODE_ALPHANUMERIC	0x0001
#ifdef KOREA    // BeomOh - 9/29/92
#define IME_MODE_SBCSCHAR       0x0002
#define IME_MODE_HANJACONVERT   0x0004
#else
#define IME_MODE_KATAKANA	0x0002
#define IME_MODE_HIRAGANA	0x0004
#define IME_MODE_SBCSCHAR	0x0008
#define IME_MODE_DBCSCHAR	0x0010
#define IME_MODE_ROMAN		0x0020
#define IME_MODE_NOROMAN	0x0040
#define IME_MODE_CODEINPUT	0x0080
#define IME_MODE_NOCODEINPUT	0x0100
//
// 0x1, 0x2, 0x4, 0x20, 0x40, 0x80, 0x100 is not for CWIN  ;Internal
// 0x8, 0x10, and below IME_MODE_??? will be use by CWIN   ;Internal
//
#endif

//
//     IME APIs
//
#define IME_GETIMECAPS            0x03
#define IME_SETOPEN               0x04
#define	IME_GETOPEN               0x05
#define IME_GETVERSION            0x07
#define IME_SETCONVERSIONWINDOW   0x08
#ifdef  KOREA
#define IME_MOVEIMEWINDOW         IME_SETCONVERSIONWINDOW
#else
#endif
#define IME_SETCONVERSIONMODE     0x10
#ifdef KOREA    // BeomOh - 10/23/92
#define IME_SET_MODE              0x12
#else
#endif
#define IME_GETCONVERSIONMODE     0x11
#define IME_SENDVKEY              0x13
#define IME_ENTERWORDREGISTERMODE 0x18
#define IME_SETCONVERSIONFONTEX   0x19
#ifdef  KOREA   // 01/12/93 KDLee MSCH
#define IME_GETMNTABLE            0x42  // reserved for HWIN ;Internal
#endif

//#ifdef PEN                                    ;Internal
//#endif                                        ;Internal

#ifdef KOREA    // BeomOh - 9/29/92
//
// IME_CODECONVERT subfunctions
//
#define IME_BANJAtoJUNJA        0x13
#define IME_JUNJAtoBANJA        0x14
#define IME_JOHABtoKS           0x15
#define IME_KStoJOHAB           0x16

//
// IME_AUTOMATA subfunctions
//
#define IMEA_INIT               0x01
#define IMEA_NEXT               0x02
#define IMEA_PREV               0x03

//
// IME_HANJAMODE subfunctions
//
#define IME_REQUEST_CONVERT     0x01
#define IME_ENABLE_CONVERT      0x02

//
// IME_MOVEIMEWINDOW subfunctions
//
#define INTERIM_WINDOW          0x00
#define MODE_WINDOW             0x01
#define HANJA_WINDOW            0x02
#endif // KOREA

//
//







// CTRL_MODIFY is "or" all modify bits, but now only one

//
//    error code
//
#define IME_RS_ERROR            0x01    // genetal error
#define IME_RS_NOIME            0x02    // IME is not installed
#define IME_RS_TOOLONG          0x05    // given string is too long
#define IME_RS_ILLEGAL          0x06    // illegal charactor(s) is string
#define IME_RS_NOTFOUND         0x07    // no (more) candidate
#define IME_RS_NOROOM           0x0a    // no disk/memory space
#define IME_RS_DISKERROR        0x0e    // disk I/O error
#define IME_RS_INVALID          0x11    // Win3.1/NT
#define IME_RS_NEST             0x12    // called nested
#define IME_RS_SYSTEMMODAL      0x13    // called when system mode

//
//   report messge from IME to WinApps
//
#define WM_IME_REPORT		0x0280

//
//   report message parameter for WM_IME_REPORT
//
#define IR_STRINGSTART		0x100
#define IR_STRINGEND		0x101
#define IR_OPENCONVERT		0x120
#define IR_CHANGECONVERT	0x121
#define IR_CLOSECONVERT		0x122
#define IR_FULLCONVERT		0x123
#define IR_IMESELECT		0x130
#define IR_STRING		0x140
#define IR_DBCSCHAR             0x160
#define IR_UNDETERMINE          0x170
#define IR_STRINGEX             0x180   // New for 3.1

#define WM_IMEKEYDOWN           0x290
#define WM_IMEKEYUP             0x291


LRESULT WINAPI SendIMEMessageExA(HWND, LPARAM);
LRESULT WINAPI SendIMEMessageExW(HWND, LPARAM);
#ifdef UNICODE
#define SendIMEMessageEx  SendIMEMessageExW
#else
#define SendIMEMessageEx  SendIMEMessageExA
#endif // !UNICODE

#ifndef _WINDEF_
typedef unsigned int UINT;
#endif // _WINDEF_

//
// IMESTRUCT structure for SendIMEMessageEx
//
typedef struct tagIMESTRUCT {
    UINT     fnc;        // function code
    WPARAM   wParam;     // word parameter
    UINT     wCount;     // word counter
    UINT     dchSource;  // offset to Source from top of memory object
    UINT     dchDest;    // offset to Desrination from top of memory object
    LPARAM   lParam1;
    LPARAM   lParam2;
    LPARAM   lParam3;
} IMESTRUCT,*PIMESTRUCT,NEAR *NPIMESTRUCT,FAR *LPIMESTRUCT;




//
// UNDETERMINESTRING structure for IR_UNDETERMINE
//
typedef struct tagUNDETERMINESTRUCT {
    DWORD    dwSize;
    UINT     uDefIMESize;
    UINT     uDefIMEPos;
    UINT     uUndetTextLen;
    UINT     uUndetTextPos;
    UINT     uUndetAttrPos;
    UINT     uCursorPos;
    UINT     uDeltaStart;
    UINT     uDetermineTextLen;
    UINT     uDetermineTextPos;
    UINT     uDetermineDelimPos;
    UINT     uYomiTextLen;
    UINT     uYomiTextPos;
    UINT     uYomiDelimPos;
} UNDETERMINESTRUCT,*PUNDETERMINESTRUCT,NEAR *NPUNDETERMINESTRUCT,FAR *LPUNDETERMINESTRUCT;


typedef struct tagSTRINGEXSTRUCT {
    DWORD    dwSize;
    UINT     uDeterminePos;
    UINT     uDetermineDelimPos;
    UINT     uYomiPos;
    UINT     uYomiDelimPos;
} STRINGEXSTRUCT,NEAR *NPSTRINGEXSTRUCT,FAR *LPSTRINGEXSTRUCT;


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _IME_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\hkmsgs.cpp ===
//-----------------------------------------------------------------------------
//  HKMsgs.cpp
//
//  Hotkey (Chicago control) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifndef DISABLE_WIN95_MESSAGES

static VALUETABLE tblCombInv[] =
{
	TABLEENTRY(HKCOMB_SCA),
	TABLEENTRY(HKCOMB_SC),
	TABLEENTRY(HKCOMB_SA),
	TABLEENTRY(HKCOMB_CA),
	TABLEENTRY(HKCOMB_S),
	TABLEENTRY(HKCOMB_C),
	TABLEENTRY(HKCOMB_A),
	TABLEENTRY(HKCOMB_NONE),
	TABLEEND
};

static VALUETABLE tblModInv[] =
{
	TABLEENTRY(HOTKEYF_ALT),
	TABLEENTRY(HOTKEYF_CONTROL),
	TABLEENTRY(HOTKEYF_SHIFT),
	TABLEENTRY(HOTKEYF_EXT),
	TABLEEND
};


//////////////////////////////////////////////////////////////////////////////

DECODE(HKM_SETHOTKEY)
{
	PARM(bVKHotKey, BYTE, LOWP);
	PARM(bfMods, BYTE, HIWP);

	// REVIEW: PrintVirtualKey()?
	POUTC(bVKHotKey, BYTE);
	PLABEL(bfMods);
	TABLEORVALUE(tblModInv, bfMods);

	return TRUE;
}

NODECODERET(HKM_SETHOTKEY);

NODECODEPARM(HKM_SETHOTKEY);

//////////////////////////////////////////////////////////////////////////////

NODECODE(HKM_GETHOTKEY);

DECODERET(HKM_GETHOTKEY)
{
	PARM(bVKHotKey, BYTE, LOBYTE(LORET));
	PARM(bfMods, BYTE, HIBYTE(LORET));

	// REVIEW: PrintVirtualKey()?
	POUTC(bVKHotKey, BYTE);
	PLABEL(bfMods);
	TABLEORVALUE(tblModInv, bfMods);

	return TRUE;
}

NODECODEPARM(HKM_GETHOTKEY);

//////////////////////////////////////////////////////////////////////////////

DECODE(HKM_SETRULES)
{
	PARM(fwCombInv, WORD, WP);
	PARM(fwModInv, WORD, LOLP);

	PLABEL(fwCombInv);
	TABLEORVALUE(tblCombInv, fwCombInv);
	PLABEL(fwModInv);
	TABLEORVALUE(tblModInv, fwModInv);

	return TRUE;
}

NODECODERET(HKM_SETRULES);

NODECODEPARM(HKM_SETRULES);

//////////////////////////////////////////////////////////////////////////////
#endif	// DISABLE_WIN95_MESSAGES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\hotlinkc.cpp ===
// hotlinkc.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "hotlinkc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHotLinkCtrl

CHotLinkCtrl::CHotLinkCtrl()
{
	m_fJumpable = FALSE;
}

CHotLinkCtrl::~CHotLinkCtrl()
{
}

BEGIN_MESSAGE_MAP(CHotLinkCtrl, CWnd)
	//{{AFX_MSG_MAP(CHotLinkCtrl)
	ON_WM_LBUTTONDOWN()
	ON_WM_SETCURSOR()
	ON_WM_NCHITTEST()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CHotLinkCtrl::InitStaticData()
{
	m_hcurHand = ::LoadCursor(AfxGetInstanceHandle(),
		MAKEINTRESOURCE(IDC_JUMPHAND));

	//
	// Get the jump color from the registry.  We use the WinHelp color.
	//
	CHAR szJumpColorSpec[64];
	GetProfileString("Windows Help", "JumpColor", "000 128 000", szJumpColorSpec, sizeof(szJumpColorSpec) / sizeof(CHAR));
	CHAR* pszJumpSpec = szJumpColorSpec;
	ULONG ulRed = _tcstoul(pszJumpSpec, &pszJumpSpec, 10);
	ULONG ulGreen = _tcstoul(pszJumpSpec, &pszJumpSpec, 10);
	ULONG ulBlue = _tcstoul(pszJumpSpec, &pszJumpSpec, 10);
	m_clrJump = RGB(ulRed, ulGreen, ulBlue);

	CFont* pFont = GetStdFont(font_NormalUnderline);
	ASSERT(pFont);
}

HCURSOR CHotLinkCtrl::m_hcurHand;
CFont CHotLinkCtrl::m_FontJump;
COLORREF CHotLinkCtrl::m_clrJump;

/////////////////////////////////////////////////////////////////////////////
// CHotLinkCtrl message handlers

void CHotLinkCtrl::SetJumpObject(DWORD dwObject)
{
	m_dwJumpObject = dwObject;
	m_strCaption = FormatHex(dwObject);
	m_fJumpable = TRUE;

	if (GetSafeHwnd())
	{
		Invalidate();
	}
}

void CHotLinkCtrl::MarkInvalid()
{
	m_strCaption = ids(IDS_UNAVAILABLE);
	m_fJumpable = FALSE;

	if (GetSafeHwnd())
	{
		Invalidate();
	}
}

void CHotLinkCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	CWnd::OnLButtonDown(nFlags, point);

	if (IsJumpable())
	{
		GetParent()->SendMessage(WM_HOTLINK,
			(WPARAM)m_dwJumpObject, (LPARAM)GetObjectType());
	}
}

BOOL CHotLinkCtrl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	if (IsJumpable())
	{
		SetCursor(m_hcurHand);
		return TRUE;
	}
	else
	{
		return CWnd::OnSetCursor(pWnd, nHitTest, message);
	}
}

UINT CHotLinkCtrl::OnNcHitTest(CPoint)
{
	return HTCLIENT;
}

void CHotLinkCtrl::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	//
	// Allow the colors (especially the background color)
	// to be set as normal.
	//
	GetParent()->SendMessage(WM_CTLCOLORSTATIC, (WPARAM)dc.m_hDC, (LPARAM)this->m_hWnd);

	if (IsJumpable())
	{
		//
		// Set the jump text color and underlined font.
		//
		dc.SetTextColor(m_clrJump);
		dc.SelectObject(GetStdFont(font_NormalUnderline));
	}
	else
	{
		//
		// Set the default font.  Use the normal static control text
		// color obtained above.
		//
		dc.SelectObject(GetStdFont(font_Normal));
	}

	//
	// Draw the text.  Specify a rectangle that is the size of the
	// whole control so that all of it gets repainted, not just
	// where the new text goes.  Static controls don't have a
	// background brush, so the erase background processing doesn't
	// fill in the background, and we must draw the text opaque.
	//
	RECT rc;
	GetClientRect(&rc);
	dc.ExtTextOut(0, 0, ETO_OPAQUE, &rc, m_strCaption, m_strCaption.GetLength(), NULL);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CHotLinkCtrlWnd

CHotLinkCtrlWnd::CHotLinkCtrlWnd()
{
}

CHotLinkCtrlWnd::~CHotLinkCtrlWnd()
{
}

void CHotLinkCtrlWnd::SetJumpObject(DWORD dwObject)
{
	m_dwJumpObject = dwObject;

	//
	// Format an hwnd using FormatHandle(), not FormatHex().
	// This will return "(None)" if it is null.
	//
	m_strCaption = FormatHandle((HANDLE)dwObject);

	//
	// Null hwnds are not jumpable.
	//
	if (dwObject)
	{
		m_fJumpable = TRUE;
	}
	else
	{
		m_fJumpable = FALSE;
	}

	if (GetSafeHwnd())
	{
		Invalidate();
	}
}

BEGIN_MESSAGE_MAP(CHotLinkCtrlWnd, CHotLinkCtrl)
	//{{AFX_MSG_MAP(CHotLinkCtrlWnd)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CHotLinkCtrlPrc

CHotLinkCtrlPrc::CHotLinkCtrlPrc()
{
}

CHotLinkCtrlPrc::~CHotLinkCtrlPrc()
{
}

BEGIN_MESSAGE_MAP(CHotLinkCtrlPrc, CHotLinkCtrl)
	//{{AFX_MSG_MAP(CHotLinkCtrlPrc)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CHotLinkCtrlThd

CHotLinkCtrlThd::CHotLinkCtrlThd()
{
}

CHotLinkCtrlThd::~CHotLinkCtrlThd()
{
}

BEGIN_MESSAGE_MAP(CHotLinkCtrlThd, CHotLinkCtrl)
	//{{AFX_MSG_MAP(CHotLinkCtrlThd)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\help.cpp ===
// help.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "helpdirs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


static const char chKeySep = '\\';
static char szDefaultKeyName[] = "Software\\Microsoft\\Visual C++ 3.0";
static char szHelpFileName[] = "SPYXX.HLP";
static char szMsgHelpFileName[] = "API32.HLP";



#define MAX_REG_STR 4096
CString GetRegString(LPCSTR szSection, LPCSTR szKey, LPCSTR szDefault)
{
	CString strKey = szDefaultKeyName;
	if (szSection != NULL)
		strKey = strKey + chKeySep + szSection;

	HKEY hSectionKey;
	RegOpenKeyEx(HKEY_CURRENT_USER, strKey, 0, KEY_READ, &hSectionKey);

	char szT[MAX_REG_STR];
	DWORD nSize = MAX_REG_STR;
	DWORD nType = REG_NONE;
	if (hSectionKey == NULL || RegQueryValueEx(hSectionKey, (char*) szKey, NULL, &nType, (LPBYTE) szT, &nSize) != ERROR_SUCCESS)
	{
		// copy the default value
		if (szDefault != NULL)
			_tcsncpy(szT, szDefault, MAX_REG_STR);
		else
			szT[0] = '\0';
	}
	else
		ASSERT(nType == REG_EXPAND_SZ);

	if (hSectionKey != NULL)
		RegCloseKey(hSectionKey);

	return szT;
}


BOOL WriteRegString(LPCSTR szSection, LPCSTR szKey, LPCSTR szVal)
{
	CString strKey = szDefaultKeyName;
	if (szSection != NULL)
		strKey = strKey + chKeySep + szSection;

	DWORD dwDisp;
	HKEY hSectionKey;
	RegCreateKeyEx(HKEY_CURRENT_USER, strKey, 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hSectionKey, &dwDisp);

	long lResult = RegSetValueEx(hSectionKey, (char*) szKey, NULL, REG_SZ, (LPBYTE) szVal, _tcslen(szVal) + 1);

	RegCloseKey(hSectionKey);

	return (lResult == ERROR_SUCCESS);
}



void CSpyApp::WinHelp(DWORD dwData, UINT nCmd)
{
	if (dwData == IDD_ABOUT + HID_BASE_RESOURCE)
	{
		MessageBeep((UINT)-1);
		return;
	}

	switch (nCmd)
	{
		case HELP_CONTEXT:
			// invoke different help context for process general properties tab on NT
			if ((dwData == IDD_PROCESSGENERALTAB + HID_BASE_RESOURCE) && (!IsChicago()))
				dwData = IDD_PROCESSGENERALTAB_NT + HID_BASE_RESOURCE;

			// invoke different help context for thread general properties tab on NT
			if ((dwData == IDD_THREADGENERALTAB + HID_BASE_RESOURCE) && (!IsChicago()))
				dwData = IDD_THREADGENERALTAB_NT + HID_BASE_RESOURCE;

			InvokeWinHelp(dwData, HELPTYPE_CONTEXT);
			break;

		case HELP_HELPONHELP:
			InvokeWinHelp(dwData, HELPTYPE_HELPONHELP);
			break;

		case HELP_INDEX:
			InvokeWinHelp(dwData, HELPTYPE_INDEX);
			break;
	}
}

void CSpyApp::InvokeWinHelp(DWORD dwData, int helpType)
{
	CString strFile;
	CString strFName;
	BOOL fSuccess;

	if (helpType == HELPTYPE_MSGHELP)
	{
		strFName = szMsgHelpFileName;
	}
	else
	{
		strFName = szHelpFileName;
	}

	if (!LocateHelpFile(strFName, strFile, TRUE))
	{
		return;
	}

	BeginWaitCursor();

	switch (helpType)
	{
		case HELPTYPE_INDEX:
			fSuccess = ::WinHelp(m_pMainWnd->m_hWnd, strFile, HELP_INDEX, dwData);
			break;

		case HELPTYPE_HELPONHELP:
			fSuccess = ::WinHelp(m_pMainWnd->m_hWnd, strFile, HELP_HELPONHELP, dwData);
			break;

		case HELPTYPE_CONTEXT:
			fSuccess = ::WinHelp(m_pMainWnd->m_hWnd, strFile, HELP_CONTEXT, dwData);
			break;

		case HELPTYPE_MSGHELP:
			fSuccess = ::WinHelp(m_pMainWnd->m_hWnd, strFile, HELP_KEY, dwData);
			break;

		default:
			//
			// Unknown help type.
			//
			ASSERT(FALSE);
			fSuccess = FALSE;
			break;
	}

	EndWaitCursor();

	if (!fSuccess)
	{
		AfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH_HELP);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\helpdirs.cpp ===
// helpdirs.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "helpdirs.h"

#include <io.h>		 // For _access

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// To compile this file, you must provide implementations of these two
// functions:
//
//  (1) CString GetRegString(const char* szKey, const char* szValue)
//
//      which is a function that does a registry lookup.  Given the
//      key and the value, it returns the requested registry information.
//      If the information cannot be found for any reason, it returns an
//      empty string.
//
//  (2) void WriteRegString(const char* szKey, const char* szValue, const char* sz)
//
//      which is a function that writes the specified sz string into the
//      registry.
//
// In addition, your .RC file (and associated resource.h file) must contain
// the following three items:
//
//  (1) the IDD_NOHELPFILE dialog template, copied from SUSHI.RC
//
//  (2) the IDS_ERROR_HELP_NOFILE string, which reads "Cannot access help
//      file '%s'.  Please correct the help directory locations shown below."
//
//  (3) the IDS_HELP_DEFAULTDIR string, which reads "\HELP"


/////////////////////////////////////////////////////////////////////////////
// Registry key strings for Help information
//
static TCHAR BASED_CODE szHelpKey[] = _T("Help");
static TCHAR BASED_CODE szLocalHelp[] = _T("LocalHelp");
static TCHAR BASED_CODE szRemoteHelp[] = _T("RemoteHelp");
static TCHAR BASED_CODE szNotFound[] = _T("Not found");


/////////////////////////////////////////////////////////////////////////////
// LocateHelpFile
//
// This function is great.  You tell it what file you are looking for.  It
// finds it, and gives you the fully qualified path.  If it can't find the
// file, the user will be prompted with a nifty dialog -- but that's all
// invisible to the caller.
//
// If bQueryUser is TRUE, there are only two possible resolutions when you
// call this function: we either found the file, OR the user cancelled out
// of the dialog which asked them to locate the file.  So if this function
// returns FALSE, you don't need to raise an error message.
//
// If bQueryUser is FALSE, this function will return FALSE if the file cannot
// be found without asking the user for a location.  So, bQueryUser should
// only be FALSE if you do not want to bother the user, and a failure to find
// the file is OK.
//
// strFName:    the name of the help file you need.
// strFullPath: if the function returns TRUE, this string will contain the
//              full path of the file you requested.
// bQueryUser:  TRUE->Query use for help directories if needed.
//				FALSE->Fail rather than ask user.
//
// return value: TRUE if the file is found, FALSE if the user cancels.
//
BOOL LocateHelpFile(const CString& strFName, CString& strFullPath, BOOL bQueryUser)
{
	int iKey = 1;
	int nDirsFound = 0;
	const char* szHelpPrefix = szLocalHelp;

	// Look for the file in all local and remote help directories.
	while (1)
	{
		CString strDir = GetRegString(szHelpKey, AppendIntegerToString(iKey++, szHelpPrefix), szNotFound);
		if (0 == strDir.Compare(szNotFound))
		{
			// Have we run out of places to look?
			if (szHelpPrefix == szRemoteHelp)
				break;

			// no more local values in the registry, try the remote values
			szHelpPrefix = szRemoteHelp;
			iKey = 1;
			continue;
		}

		nDirsFound++;

		if (IsFileThere(strDir, strFName, strFullPath))
			return TRUE;
	}

	// If there were no legal entries, the registry was probably nuked.
	// Try to regenerate some reasonable defaults, and try again.
	if (nDirsFound == 0)
	{
		GenerateDefaultHelpDirectories();
		return LocateHelpFile(strFName, strFullPath, bQueryUser);
	}

	// If we had some places to look, but still couldn't find the file,
	// we need the user's help.  Bring up the Help Directories dialog.
	if (bQueryUser && HelpDirectoriesDialog(strFName))
		return LocateHelpFile(strFName, strFullPath, TRUE);

	// We only get here if the user cancels out of the Help Dirs dialog.
	return FALSE;
}

// Utility functions
//
BOOL IsFileThere(const CString& strDir, const CString& strFName, CString& strFullPath)
{
	ASSERT(!strFName.IsEmpty());

	const TCHAR *pch = strFName;
	if ((strFName[0] != _T('\\')) &&
	    ((strFName.GetLength() < 2) || (*_tcsinc(pch) != _T(':'))))
	{
		if (strDir.IsEmpty())
			return FALSE;

		strFullPath = strDir;

		// Add a backslash between path and fname if needed
		if (strFullPath.Right(1).Compare("\\"))
			strFullPath += "\\";
	}

	strFullPath += strFName;

	if (_access(strFullPath, 04) == 0)	// check for read privs
		return TRUE;

	return FALSE;
}

CString AppendIntegerToString(int i, const TCHAR* szInput)
{
	ASSERT(i > 0);
	ASSERT(i < 100);	// if more than two digits, increase buffer size

	CString str;
	TCHAR* sz = str.GetBufferSetLength(strlen(szInput) + 6);

	wsprintf(sz, "%s%d", szInput, i);

	str.ReleaseBuffer();
	return str;
}

BOOL HelpDirectoriesDialog(const CString& strFile)
{
	CHelpDirDlg dlg;

	// Read the local and remote paths from the registry
	dlg.m_strPath1 = GetRegString(szHelpKey, AppendIntegerToString(1, szLocalHelp));
	dlg.m_strPath2 = GetRegString(szHelpKey, AppendIntegerToString(1, szRemoteHelp));

	// Generate the dialog's error message
	CString strError;
	strError.LoadString(IDS_ERROR_HELP_NOFILE);
	wsprintf(dlg.m_strMessage.GetBufferSetLength(strError.GetLength() + strFile.GetLength() + 2), strError, strFile);
	dlg.m_strMessage.ReleaseBuffer();

	if (dlg.DoModal() != IDOK)
		return FALSE;	// return FALSE if user cancels dialog

	// Unless the user cancelled the dialog, write the new information
	// into the registry.
	WriteRegString(szHelpKey, AppendIntegerToString(1, szLocalHelp), dlg.m_strPath1);
	WriteRegString(szHelpKey, AppendIntegerToString(1, szRemoteHelp), dlg.m_strPath2);

	return TRUE;
}

void GenerateDefaultHelpDirectories()
{
	// Our best-guess default is a "help" directory which is at the same
	// level in the directory hierarchy as the current executable.
	CString strLocal;
	::GetModuleFileName(NULL, strLocal.GetBufferSetLength(_MAX_PATH), _MAX_PATH);
	strLocal.ReleaseBuffer();

	// Convert C:\FOO\BIN\MSVC.EXE to C:\FOO\HELP.
	int i = strLocal.ReverseFind('\\');
	ASSERT(i != -1);
	strLocal.GetBufferSetLength(i);
	strLocal.ReleaseBuffer();

	// Now we have C:\FOO\BIN
	i = strLocal.ReverseFind('\\');
	if (i != -1)
	{
		strLocal.GetBufferSetLength(i);
		strLocal.ReleaseBuffer();
	}

	// Now we have C:\FOO (or just "C:", if the exe was in the root).
	CString strHelp;
	strHelp.LoadString(IDS_HELP_DEFAULTDIR);	// This string is "\HELP"
	strLocal += strHelp;

	// It's essential that one of these strings be non-empty,
	// to avoid infinite recursion in LocateHelpFile.
	ASSERT(!strLocal.IsEmpty());

	WriteRegString(szHelpKey, AppendIntegerToString(1, szLocalHelp), strLocal);
	WriteRegString(szHelpKey, AppendIntegerToString(1, szRemoteHelp), "");

//REVIEW ALANE - temporary code

	// As a favor to all the dogfooders out there, this should preserve
	// their remote directory settings as we switch to the new registry
	// keys.  Coded added 4/6/94, and intended for removal in a week or two.

	CString strRemote = GetRegString("Directories", "Remote Help");
	if (!strRemote.IsEmpty())
		WriteRegString(szHelpKey, AppendIntegerToString(1, szRemoteHelp), strRemote);

//REVIEW - end of temporary code
}

/////////////////////////////////////////////////////////////////////////////
// CHelpDirDlg dialog

CHelpDirDlg::CHelpDirDlg(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CHelpDirDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CHelpDirDlg)
	m_strPath1 = "";
	m_strPath2 = "";
	m_strMessage = "";
	//}}AFX_DATA_INIT
}

void CHelpDirDlg::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHelpDirDlg)
	DDX_Control(pDX, IDC_INFO_ICON, m_icon);
	DDX_Text(pDX, IDC_HELPPATH1, m_strPath1);
	DDX_Text(pDX, IDC_HELPPATH2, m_strPath2);
	DDX_Text(pDX, IDC_ERRORTEXT, m_strMessage);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CHelpDirDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CHelpDirDlg)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelpDirDlg message handlers

LRESULT CHelpDirDlg::OnCommandHelp(WPARAM, LPARAM)
{
	// Obviously, we cannot invoke help from this dialog!
	return TRUE;
}

BOOL CHelpDirDlg::OnInitDialog()
{
	CBaseDialog::OnInitDialog();

	// Place the exclamation-point icon into dialog.
	HICON hicon = theApp.LoadStandardIcon(IDI_EXCLAMATION);
	m_icon.SetIcon(hicon);

	return TRUE; // return TRUE  unless you set the focus to a control
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\hotlinkc.h ===
// hotlinkc.h : header file
//


//
// Sent to the parent of a hot link control window.  The
// lParam is the link type (OT_* define) and the wParam
// is the handle of the object that should be linked to,
// such as the hwnd or the process id.
//
#define WM_HOTLINK	(WM_USER+150)



/////////////////////////////////////////////////////////////////////////////
// CHotLinkCtrl window

class CHotLinkCtrl : public CWnd
{
// Construction
public:
	CHotLinkCtrl();

// Attributes
public:

// Operations
public:
	BOOL IsJumpable()
	{
		return m_fJumpable;
	}

// Implementation
public:
	virtual ~CHotLinkCtrl();
	virtual int GetObjectType() = 0;
	virtual void SetJumpObject(DWORD dwObject);
	virtual void MarkInvalid();

protected:
	DWORD m_dwJumpObject;
	CString m_strCaption;
	BOOL m_fJumpable;

public:
	static void InitStaticData();

protected:
	static HCURSOR m_hcurHand;
	static CFont m_FontJump;
	static COLORREF m_clrJump;

	// Generated message map functions
protected:
	//{{AFX_MSG(CHotLinkCtrl)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg UINT OnNcHitTest(CPoint point);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CHotLinkCtrlWnd window

class CHotLinkCtrlWnd : public CHotLinkCtrl
{
// Construction
public:
	CHotLinkCtrlWnd();

// Implementation
public:
	virtual ~CHotLinkCtrlWnd();
	virtual int GetObjectType()
	{
		return OT_WINDOW;
	}
	virtual void SetJumpObject(DWORD dwObject);

	// Generated message map functions
protected:
	//{{AFX_MSG(CHotLinkCtrlWnd)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CHotLinkCtrlPrc window

class CHotLinkCtrlPrc : public CHotLinkCtrl
{
// Construction
public:
	CHotLinkCtrlPrc();

// Implementation
public:
	virtual ~CHotLinkCtrlPrc();
	virtual int GetObjectType()
	{
		return OT_PROCESS;
	}

	// Generated message map functions
protected:
	//{{AFX_MSG(CHotLinkCtrlPrc)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CHotLinkCtrlThd window

class CHotLinkCtrlThd : public CHotLinkCtrl
{
// Construction
public:
	CHotLinkCtrlThd();

// Implementation
public:
	virtual ~CHotLinkCtrlThd();
	virtual int GetObjectType()
	{
		return OT_THREAD;
	}

	// Generated message map functions
protected:
	//{{AFX_MSG(CHotLinkCtrlThd)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\imemsgs.cpp ===
//-----------------------------------------------------------------------------
//  IMEMsgs.cpp
//
//  IME message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

static VALUETABLE tblIMEReportType[] =
{
	TABLEENTRY(IR_STRINGSTART),
	TABLEENTRY(IR_STRINGEND),
	TABLEENTRY(IR_OPENCONVERT),
	TABLEENTRY(IR_CHANGECONVERT),
	TABLEENTRY(IR_CLOSECONVERT),
	TABLEENTRY(IR_FULLCONVERT),
	TABLEENTRY(IR_IMESELECT),
	TABLEENTRY(IR_STRING),
	TABLEENTRY(IR_DBCSCHAR),
	TABLEENTRY(IR_UNDETERMINE),
	TABLEENTRY(IR_STRINGEX),
	TABLEEND
};

#ifndef DISABLE_WIN95_MESSAGES

static VALUETABLE tblIMECompFlags[] =
{
	TABLEENTRY(GCS_COMPREADSTR),
	TABLEENTRY(GCS_COMPREADATTR),
	TABLEENTRY(GCS_COMPREADCLAUSE),
	TABLEENTRY(GCS_COMPSTR),
	TABLEENTRY(GCS_COMPATTR),
	TABLEENTRY(GCS_COMPCLAUSE),
	TABLEENTRY(GCS_CURSORPOS),
	TABLEENTRY(GCS_DELTASTART),
	TABLEENTRY(GCS_RESULTREADSTR),
	TABLEENTRY(GCS_RESULTREADCLAUSE),
	TABLEENTRY(GCS_RESULTSTR),
	TABLEENTRY(GCS_RESULTCLAUSE),
	TABLEENTRY(CS_INSERTCHAR),
	TABLEENTRY(CS_NOMOVECARET),
	TABLEEND
};

static VALUETABLE tblIMENotifyCmds[] =
{
	TABLEENTRY(IMN_PRIVATE),
	TABLEENTRY(IMN_GUIDELINE),
	TABLEENTRY(IMN_SETSTATUSWINDOWPOS),
	TABLEENTRY(IMN_SETCOMPOSITIONWINDOW),
	TABLEENTRY(IMN_SETCOMPOSITIONFONT),
	TABLEENTRY(IMN_SETCANDIDATEPOS),
	TABLEENTRY(IMN_SETOPENSTATUS),
	TABLEENTRY(IMN_SETSENTENCEMODE),
	TABLEENTRY(IMN_SETCONVERSIONMODE),
	TABLEENTRY(IMN_OPENCANDIDATE),
	TABLEENTRY(IMN_CLOSECANDIDATE),
	TABLEENTRY(IMN_CHANGECANDIDATE),
	TABLEENTRY(IMN_OPENSTATUSWINDOW),
	TABLEENTRY(IMN_CLOSESTATUSWINDOW),
	TABLEEND
};

static VALUETABLE tblIMEControls[] =
{
	TABLEENTRY(IMC_SETSTATUSWINDOWPOS),
	TABLEENTRY(IMC_GETSTATUSWINDOWPOS),
	TABLEENTRY(IMC_SETCOMPOSITIONWINDOW),
	TABLEENTRY(IMC_GETCOMPOSITIONWINDOW),
	TABLEENTRY(IMC_SETCOMPOSITIONFONT),
	TABLEENTRY(IMC_GETCOMPOSITIONFONT),
	TABLEENTRY(IMC_SETCANDIDATEPOS),
	TABLEENTRY(IMC_GETCANDIDATEPOS),
	TABLEEND
};

#endif
//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CONVERTREQUESTEX)
{
	PARM(hwnd, HWND, WP);
	PARM(hglbIMEStruct, HGLOBAL, LP);

	POUT(hwnd);
	POUTC(hglbIMEStruct, DWORD);

	return TRUE;
}

DECODERET(WM_CONVERTREQUESTEX)
{
	PARM(lResult, LRESULT, RET);

	POUTC(lResult, DWORD);

	return TRUE;
}

NODECODEPARM(WM_CONVERTREQUESTEX);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_IMEKEYDOWN)
{
	DECODELIKE(WM_KEYDOWN);
}

DECODERET(WM_IMEKEYDOWN)
{
	DECODERETLIKE(WM_KEYDOWN);
}

DECODEPARM(WM_IMEKEYDOWN)
{
	DECODEPARMLIKE(WM_KEYDOWN);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_IMEKEYUP)
{
	DECODELIKE(WM_KEYUP);
}

DECODERET(WM_IMEKEYUP)
{
	DECODERETLIKE(WM_KEYUP);
}

DECODEPARM(WM_IMEKEYUP)
{
	DECODEPARMLIKE(WM_KEYUP);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_IME_REPORT)
{
	PARM(nReportType, UINT, WP);
	PARM(lParam, LPARAM, LP);

	TABLEORVALUE(tblIMEReportType, nReportType);
	POUTC(lParam, DWORD);

	return TRUE;
}

DECODERET(WM_IME_REPORT)
{
	PARM(lResult, LRESULT, RET);

	POUTC(lResult, DWORD);

	return TRUE;
}

NODECODEPARM(WM_IME_REPORT);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_IME_STARTCOMPOSITION);

NODECODERET(WM_IME_STARTCOMPOSITION);

NODECODEPARM(WM_IME_STARTCOMPOSITION);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_IME_ENDCOMPOSITION);

NODECODERET(WM_IME_ENDCOMPOSITION);

NODECODEPARM(WM_IME_ENDCOMPOSITION);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_IME_COMPOSITION)
{
	PARM(chDBCS, WORD, WP);
	PARM(fFlags, LPARAM, LP);

	POUTC(chDBCS, WORD);
#ifndef DISABLE_WIN95_MESSAGES
	TABLEORVALUE(tblIMECompFlags, fFlags);
#endif
	return TRUE;
}

NODECODERET(WM_IME_COMPOSITION);

NODECODEPARM(WM_IME_COMPOSITION);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_IME_SETCONTEXT)
{
	PARM(fSet, BOOL, WP);
	PARM(hContext, HANDLE, LP);

	POUTC(fSet, BOOL);
	POUTC(hContext, DWORD);

	return TRUE;
}

NODECODERET(WM_IME_SETCONTEXT);

NODECODEPARM(WM_IME_SETCONTEXT);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_IME_NOTIFY)
{
	PARM(dwCommand, LPARAM, WP);
	PARM(dwData, DWORD, LP);

#ifndef DISABLE_WIN95_MESSAGES
	TABLEORVALUE(tblIMENotifyCmds, dwCommand);
#endif
	POUTC(dwData, DWORD);

	return TRUE;
}

NODECODERET(WM_IME_NOTIFY);

NODECODEPARM(WM_IME_NOTIFY);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_IME_CONTROL)
{
	PARM(dwCommand, LPARAM, WP);
	PARM(dwData, DWORD, LP);

#ifndef DISABLE_WIN95_MESSAGES
	TABLEORVALUE(tblIMEControls, dwCommand);
#endif
	POUTC(dwData, DWORD);

	return TRUE;
}

NODECODERET(WM_IME_CONTROL);

NODECODEPARM(WM_IME_CONTROL);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_IME_COMPOSITIONFULL);

NODECODERET(WM_IME_COMPOSITIONFULL);

NODECODEPARM(WM_IME_COMPOSITIONFULL);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_IME_SELECT)
{
	PARM(fSelect, BOOL, WP);
	PARM(hKL, HANDLE, LP);

	POUTC(fSelect, BOOL);
	POUTC(hKL, DWORD);

	return TRUE;
}

NODECODERET(WM_IME_SELECT);

NODECODEPARM(WM_IME_SELECT);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_IME_CHAR)
{
	PARM(chCharCode1, TCHAR, WP);
	PARM(chCharCode2, TCHAR, WP>>8);
	PARM(lKeyData, UINT, LP);
	INT cRepeat = (INT)(unsigned short)LOWORD(lKeyData);
	CHAR szScanCode[8];
	WORD wScanCode = HIWORD(lKeyData) & 0xFF;
	static TCHAR achBuffer[2+1];	// WinslowF - For V2 compatibility [MB_LEN_MAX + 1] VC2.0 does not have this defined. (MB_LEN_MAX = 2)

	achBuffer[0] = chCharCode1;
	if (_istlead(chCharCode1))
		achBuffer[1] = chCharCode2;
	else
		achBuffer[1] = (TCHAR)0;

	MOUT << " chCharCode:'" << achBuffer << "' (" << (INT)(UCHAR)WP << ')';

	POUT(cRepeat);
	wsprintf(szScanCode, "%2.2X", wScanCode);
	PLABEL(ScanCode);
	MOUT << szScanCode;

	return TRUE;
}

NODECODERET(WM_IME_CHAR);

NODECODEPARM(WM_IME_CHAR);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_IME_KEYDOWN)
{
	DECODELIKE(WM_KEYDOWN);
}

DECODERET(WM_IME_KEYDOWN)
{
	DECODERETLIKE(WM_KEYDOWN);
}

DECODEPARM(WM_IME_KEYDOWN)
{
	DECODEPARMLIKE(WM_KEYDOWN);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_IME_KEYUP)
{
	DECODELIKE(WM_KEYUP);
}

DECODERET(WM_IME_KEYUP)
{
	DECODERETLIKE(WM_KEYUP);
}

DECODEPARM(WM_IME_KEYUP)
{
	DECODEPARMLIKE(WM_KEYUP);
}

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\imgwell.cpp ===
// imgwell.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "imgwell.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define DSx	 0x00660046L
#define DSna	0x00220326L

CImageWell::CImageWell()
	: m_bitmap(), m_dc(), m_mask(), m_maskDC(), m_imageSize(0, 0)
{
	m_nBitmapID = 0;
	m_pbitmap = NULL;
}


CImageWell::CImageWell(UINT nBitmapID, CSize imageSize)
	: m_bitmap(), m_dc(), m_mask(), m_maskDC(), m_imageSize(imageSize)
{
	m_nBitmapID = nBitmapID;
	m_pbitmap = NULL;
}


CImageWell::~CImageWell()
{
	// Destructor needed to ensure the DC is deleted before the bitmap
	m_dc.DeleteDC();
	m_bitmap.DeleteObject();
	m_maskDC.DeleteDC();
	m_mask.DeleteObject();
}

void CImageWell::SetBitmap(CBitmap *pBitmap, CSize imageSize)
{
	m_imageSize =imageSize;
	m_pbitmap = pBitmap;
}


BOOL CImageWell::Load(UINT nBitmapID, CSize imageSize)
{
	ASSERT(m_bitmap.m_hObject == NULL);

	//HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(nBitmapID), RT_BITMAP);
	//HINSTANCE hOldInst = AfxGetResourceHandle();

	//AfxSetResourceHandle(hInst);
	if (!m_bitmap.LoadBitmap(nBitmapID))
	{
		TRACE1("Could not load image well %d\n", nBitmapID);
		return FALSE;
	}
	//AfxSetResourceHandle(hOldInst);

	m_nBitmapID = nBitmapID;
	m_imageSize = imageSize;

	m_pbitmap = &m_bitmap;
	return TRUE;
}


void CImageWell::Unload()
{
	ASSERT(m_dc.m_hDC == NULL); // can't unload if it's open!
	ASSERT(m_maskDC.m_hDC == NULL);
	ASSERT(m_bitmap.m_hObject != NULL);

	m_bitmap.DeleteObject();
	m_mask.DeleteObject();
}


BOOL CImageWell::CalculateMask()
{
	ASSERT(m_maskDC.m_hDC == NULL);
	ASSERT(m_dc.m_hDC != NULL);
	ASSERT(m_pbitmap->m_hObject != NULL);

	if (!m_maskDC.CreateCompatibleDC(NULL))
		return FALSE;

	if (m_mask.m_hObject != NULL)
	{
		VERIFY(m_maskDC.SelectObject(&m_mask) != NULL);
		return TRUE;
	}

	BITMAP bmp;
	m_pbitmap->GetObject(sizeof (BITMAP), &bmp);

	if (!m_mask.CreateBitmap(bmp.bmWidth, bmp.bmHeight, 1, 1, NULL))
	{
		m_maskDC.DeleteDC();
		return FALSE;
	}

	VERIFY( m_maskDC.SelectObject(&m_mask) != NULL);

	COLORREF oldBkColor = m_dc.SetBkColor(m_dc.GetPixel(0, 0));
	m_maskDC.BitBlt(0, 0, bmp.bmWidth, bmp.bmHeight, &m_dc, 0, 0, NOTSRCCOPY);
	m_dc.SetBkColor(oldBkColor);
	return TRUE;
}


BOOL CImageWell::Open()
{
	ASSERT(m_dc.m_hDC == NULL); // make sure this is not already open
	ASSERT(m_nBitmapID != 0 || m_pbitmap != NULL);

	if (m_pbitmap == NULL && !Load(m_nBitmapID, m_imageSize))
		return FALSE;

	if (!m_dc.CreateCompatibleDC(NULL))
		return FALSE;

	VERIFY(m_dc.SelectObject(m_pbitmap));

	return TRUE;
}


void CImageWell::Close()
{
	ASSERT(m_dc.m_hDC != NULL);

	m_dc.DeleteDC();
	m_maskDC.DeleteDC();
}

BOOL CImageWell::DrawImage(CDC* pDestDC, CPoint destPoint, UINT nImage, DWORD rop)
{
	BOOL bClose = FALSE;
	if (m_dc.m_hDC == NULL)
	{
		ASSERT(rop != NULL); // must open first and calc mask for rop==0!

		if (!Open())
		{
			TRACE("Could not open image well!\n");
			return FALSE;
		}

		bClose = TRUE;
	}

	if (rop == 0)
	{
		if (m_maskDC.m_hDC == NULL && !CalculateMask())
			return FALSE;

		COLORREF oldBkColor = pDestDC->SetBkColor(RGB(255, 255, 255));
		COLORREF oldTextColor = pDestDC->SetTextColor(RGB(0, 0, 0));

		pDestDC->BitBlt(destPoint.x, destPoint.y, m_imageSize.cx, m_imageSize.cy, &m_dc, m_imageSize.cx * nImage, 0, DSx);
		pDestDC->BitBlt(destPoint.x, destPoint.y, m_imageSize.cx, m_imageSize.cy, &m_maskDC, m_imageSize.cx * nImage, 0, DSna);
		pDestDC->BitBlt(destPoint.x, destPoint.y, m_imageSize.cx, m_imageSize.cy, &m_dc, m_imageSize.cx * nImage, 0, DSx);

		pDestDC->SetBkColor(oldBkColor);
		pDestDC->SetTextColor(oldTextColor);
	}
	else
	{
		pDestDC->BitBlt(destPoint.x, destPoint.y, m_imageSize.cx, m_imageSize.cy, &m_dc, m_imageSize.cx * nImage, 0, rop);
	}

	if (bClose)
		Close();

	return TRUE;
}

BOOL CImageWell::DrawMask(CDC* pDestDC, CPoint destPoint, UINT nImage, DWORD rop)
{
	ASSERT(m_maskDC.m_hDC != NULL); // must open first and calc mask

	pDestDC->BitBlt(destPoint.x, destPoint.y, m_imageSize.cx, m_imageSize.cy, &m_maskDC, m_imageSize.cx * nImage, 0, rop);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\helpdirs.h ===
// helpdirs.h


/////////////////////////////////////////////////////////////////////////////
// In Sushi, C3dDialog is the base class for all dialogs.  But other
// projects which share this file (books online & wizards) will probably
// want to use the standard MFC CDialog class.
#ifdef _SUSHI
#define CBaseDialog C3dDialog
#else
#define CBaseDialog CDialog
#endif


/////////////////////////////////////////////////////////////////////////////
// Functions
//
BOOL LocateHelpFile(const CString& strFName, CString& strHelpFile, BOOL bQueryUser);
BOOL IsFileThere(const CString& strDir, const CString& strFName, CString& strHelpFile);
BOOL HelpDirectoriesDialog(const CString& strFile);
void GenerateDefaultHelpDirectories();
CString AppendIntegerToString(int i, const TCHAR* sz);


/////////////////////////////////////////////////////////////////////////////
// CHelpDirDlg dialog
//
class CHelpDirDlg : public CBaseDialog
{
// Construction
public:
	CHelpDirDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CHelpDirDlg)
	enum { IDD = IDD_NOHELPFILE };
	CString	m_strPath1;
	CString	m_strPath2;
	CString	m_strMessage;
	CStatic m_icon;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	// Generated message map functions
	//{{AFX_MSG(CHelpDirDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	afx_msg LRESULT OnCommandHelp(WPARAM, LPARAM);

	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\imgwell.h ===
#ifndef __IMGWELL_H__
#define __IMGWELL_H__

// The CImageWell class provides a convenient way to handle "tiled"
// bitmaps.

class CImageWell
{
public:
	CImageWell();
	CImageWell(UINT nBitmapID, CSize imageSize);
	~CImageWell();
	void SetBitmap (CBitmap *pBitmap, CSize imageSize);
	
	BOOL Open();
	BOOL IsOpen() { return m_dc.m_hDC != NULL; }
	void Close();
	BOOL Load(UINT nBitmapID, CSize imageSize);
	void Unload();
	
	BOOL CalculateMask();
	
	BOOL DrawImage(CDC* pDestDC, CPoint destPoint, UINT nImage,
		DWORD rop = 0); // rop==0 means image is drawn through a mask

	BOOL DrawMask(CDC* pDestDC, CPoint destPoint, UINT nImage, DWORD rop = NOTSRCCOPY);
	
protected:
		
	CSize m_imageSize;
	
	// We use either this pointer or our member bitmap:
	CBitmap *m_pbitmap;

	UINT m_nBitmapID;
	CBitmap m_bitmap;
	
	CDC m_dc;
	CBitmap m_mask;
	CDC m_maskDC;
};

#endif // __IMGWELL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\lvmsgs.cpp ===
//-----------------------------------------------------------------------------
//  LVMsgs.cpp
//
//  ListView (Chicago control) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static VALUETABLE tblLVRetOK[] =
{
	TABLEENTRY(LB_OKAY),
	TABLEENTRY(LB_ERR),
	TABLEENTRY(LB_ERRSPACE),
	TABLEEND
};
#ifndef DISABLE_WIN95_MESSAGES
static VALUETABLE tblLVArrange[] =
{
	TABLEENTRY(LVA_ALIGNBOTTOM),
	TABLEENTRY(LVA_ALIGNLEFT),
	TABLEENTRY(LVA_ALIGNRIGHT),
	TABLEENTRY(LVA_ALIGNTOP),
	TABLEENTRY(LVA_DEFAULT),
	TABLEENTRY(LVA_SNAPTOGRID),
	TABLEENTRY(LVA_SORTASCENDING | LVA_ALIGNBOTTOM),
	TABLEENTRY(LVA_SORTASCENDING | LVA_ALIGNLEFT),
	TABLEENTRY(LVA_SORTASCENDING | LVA_ALIGNRIGHT),
	TABLEENTRY(LVA_SORTASCENDING | LVA_ALIGNTOP),
	TABLEENTRY(LVA_SORTASCENDING | LVA_DEFAULT),
	TABLEENTRY(LVA_SORTASCENDING | LVA_SNAPTOGRID),
	TABLEENTRY(LVA_SORTDESCENDING | LVA_ALIGNBOTTOM),
	TABLEENTRY(LVA_SORTDESCENDING | LVA_ALIGNLEFT),
	TABLEENTRY(LVA_SORTDESCENDING | LVA_ALIGNRIGHT),
	TABLEENTRY(LVA_SORTDESCENDING | LVA_ALIGNTOP),
	TABLEENTRY(LVA_SORTDESCENDING | LVA_DEFAULT),
	TABLEENTRY(LVA_SORTDESCENDING | LVA_SNAPTOGRID),
	TABLEEND
};

static VALUETABLE tblLVImageList[] =
{
	TABLEENTRY(LVSIL_NORMAL),
	TABLEENTRY(LVSIL_SMALL),
	TABLEENTRY(LVSIL_STATE),
	TABLEEND
};

static VALUETABLE tblLVItemRect[] =
{
	TABLEENTRY(LVIR_BOUNDS),
	TABLEENTRY(LVIR_ICON),
	TABLEENTRY(LVIR_LABEL),
	TABLEENTRY(LVIR_SELECTBOUNDS),
	TABLEEND
};

static VALUETABLE tblLVGetNext[] =
{
	TABLEENTRY(LVNI_ABOVE),
	TABLEENTRY(LVNI_ALL),
	TABLEENTRY(LVNI_BELOW),
	TABLEENTRY(LVNI_PREVIOUS),
	TABLEENTRY(LVNI_TOLEFT),
	TABLEENTRY(LVNI_TORIGHT),
	TABLEENTRY(LVNI_ABOVE | LVNI_CUT),
	TABLEENTRY(LVNI_ALL | LVNI_CUT),
	TABLEENTRY(LVNI_BELOW | LVNI_CUT),
	TABLEENTRY(LVNI_PREVIOUS | LVNI_CUT),
	TABLEENTRY(LVNI_TOLEFT | LVNI_CUT),
	TABLEENTRY(LVNI_TORIGHT | LVNI_CUT),
	TABLEENTRY(LVNI_ABOVE | LVNI_DROPHILITED),
	TABLEENTRY(LVNI_ALL | LVNI_DROPHILITED),
	TABLEENTRY(LVNI_BELOW | LVNI_DROPHILITED),
	TABLEENTRY(LVNI_PREVIOUS | LVNI_DROPHILITED),
	TABLEENTRY(LVNI_TOLEFT | LVNI_DROPHILITED),
	TABLEENTRY(LVNI_TORIGHT | LVNI_DROPHILITED),
	TABLEENTRY(LVNI_ABOVE | LVNI_FOCUSED),
	TABLEENTRY(LVNI_ALL | LVNI_FOCUSED),
	TABLEENTRY(LVNI_BELOW | LVNI_FOCUSED),
	TABLEENTRY(LVNI_PREVIOUS | LVNI_FOCUSED),
	TABLEENTRY(LVNI_TOLEFT | LVNI_FOCUSED),
	TABLEENTRY(LVNI_TORIGHT | LVNI_FOCUSED),
	TABLEENTRY(LVNI_ABOVE | LVNI_SELECTED),
	TABLEENTRY(LVNI_ALL | LVNI_SELECTED),
	TABLEENTRY(LVNI_BELOW | LVNI_SELECTED),
	TABLEENTRY(LVNI_PREVIOUS | LVNI_SELECTED),
	TABLEENTRY(LVNI_TOLEFT | LVNI_SELECTED),
	TABLEENTRY(LVNI_TORIGHT | LVNI_SELECTED),
	TABLEEND
};

static VALUETABLE tblLVColumnWidth[] =
{
	TABLEENTRY(LVSCW_AUTOSIZE),
	TABLEENTRY(LVSCW_AUTOSIZE_USEHEADER),
	TABLEEND
};

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETBKCOLOR);

DECODERET(LVM_GETBKCOLOR)
{
	PARM(clrBk, COLORREF, RET);
	POUTC(clrBk, DWORD);

	return TRUE;
}

NODECODEPARM(LVM_GETBKCOLOR);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SETBKCOLOR)
{
	PARM(clrBk, COLORREF, LP);
	POUTC(clrBk, DWORD);

	return TRUE;
}

DECODERET(LVM_SETBKCOLOR)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_SETBKCOLOR);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_GETIMAGELIST)
{
	PARM(iImageList, INT, WP);
	TABLEORVALUE(tblLVImageList, iImageList);

	return TRUE;
}

DECODERET(LVM_GETIMAGELIST)
{
	PARM(hImageList, HIMAGELIST, RET);
	POUTC(hImageList, DWORD);

	return TRUE;
}

NODECODEPARM(LVM_GETIMAGELIST);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SETIMAGELIST)
{
	PARM(iImageList, INT, WP);
	PARM(himl, HIMAGELIST, LP);

	TABLEORVALUE(tblLVImageList, iImageList);
	POUTC(himl, DWORD);

	return TRUE;
}

NODECODERET(LVM_SETIMAGELIST);

NODECODEPARM(LVM_SETIMAGELIST);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETITEMCOUNT);

DECODERET(LVM_GETITEMCOUNT)
{
	PARM(iCount, INT, RET);
	POUT(iCount);

	return TRUE;
}

NODECODEPARM(LVM_GETITEMCOUNT);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_GETITEM)
{
	PARM(pitem, LV_ITEM FAR *, LP);
	POUTC(pitem, DWORD);

	return TRUE;
}

DECODERET(LVM_GETITEM)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(LVM_GETITEM)
{
	P2WPOUT();

	P2LPOUTPTR(LV_ITEM);
	P2IFSIZEOF(LV_ITEM)
	{
		PARM(pitem, LV_ITEM FAR *, ED2);
//		PARM(pszName, LPSTR, pitem->pszText);
		INDENT();
		P2OUTC(pitem, mask, UINT);
		P2OUT(pitem, iItem);
		P2OUT(pitem, iSubItem);
		P2OUTC(pitem, state, UINT);
		P2OUTC(pitem, stateMask, UINT);
		P2OUTPTRSTR(pitem, pszText);
//		INDENT();
//		P2OUTS(pszName);
//		OUTDENT();
		P2OUT(pitem, cchTextMax);
		P2OUT(pitem, iImage);
		P2OUTC(pitem, lParam, DWORD);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SETITEM)
{
	DECODELIKE(LVM_GETITEM);
}

DECODERET(LVM_SETITEM)
{
	DECODERETLIKE(LVM_GETITEM);
}

DECODEPARM(LVM_SETITEM)
{
	DECODEPARMLIKE(LVM_GETITEM);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_INSERTITEM)
{
	DECODELIKE(LVM_GETITEM);
}

DECODERET(LVM_INSERTITEM)
{
	PARM(nIndex, INT, RET);
	POUT(nIndex);

	return TRUE;
}

DECODEPARM(LVM_INSERTITEM)
{
	DECODEPARMLIKE(LVM_GETITEM);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_DELETEITEM)
{
	PARM(iItem, INT, WP);
	POUT(iItem);

	return TRUE;
}

DECODERET(LVM_DELETEITEM)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_DELETEITEM);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_DELETEALLITEMS);

DECODERET(LVM_DELETEALLITEMS)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_DELETEALLITEMS);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETCALLBACKMASK);

DECODERET(LVM_GETCALLBACKMASK)
{
	PARM(mask, UINT, RET);
	POUTC(mask, UINT);

	return TRUE;
}

NODECODEPARM(LVM_GETCALLBACKMASK);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SETCALLBACKMASK)
{
	PARM(mask, UINT, WP);
	POUTC(mask, UINT);

	return TRUE;
}

DECODERET(LVM_SETCALLBACKMASK)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_SETCALLBACKMASK);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_GETNEXTITEM)
{
	PARM(iStart, INT, WP);
	PARM(flags, UINT, LP);

	POUT(iStart);
	TABLEORVALUE(tblLVGetNext, flags);

	return TRUE;
}

DECODERET(LVM_GETNEXTITEM)
{
	PARM(iIndex, INT, RET);
	POUT(iIndex);

	return TRUE;
}

NODECODEPARM(LVM_GETNEXTITEM);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_FINDITEM)
{
	PARM(iStart, INT, WP);
	PARM(plvfi, LV_FINDINFO FAR *, LP);

	POUT(iStart);
	POUTC(plvfi, DWORD);

	return TRUE;
}

DECODERET(LVM_FINDITEM)
{
	PARM(iIndex, INT, RET);
	POUT(iIndex);

	return TRUE;
}

DECODEPARM(LVM_FINDITEM)
{
	P2WPOUT();

	P2LPOUTPTR(LV_FINDINFO);
	P2IFSIZEOF(LV_FINDINFO)
	{
		PARM(plvfi, LV_FINDINFO FAR *, ED2);
//		PARM(pszName, LPSTR, plvfi->psz);
		INDENT();
		P2OUTC(plvfi, flags, UINT);
		P2OUTPTRSTR(plvfi, psz);
//		INDENT();
//		P2OUTS(pszName);
//		OUTDENT();
		P2OUTC(plvfi, lParam, DWORD);
		P2OUTPT(plvfi, pt);
		P2OUTC(plvfi, vkDirection, UINT);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_GETITEMRECT)
{
	PARM(i, INT, WP);
	PARM(prc, LPRECT, LP);

	POUT(i);
	POUTC(prc, DWORD);

	return TRUE;
}

DECODERET(LVM_GETITEMRECT)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(LVM_GETITEMRECT)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		if (pmsd2->fPostType == POSTTYPE_SENT)
		{
			PARM(prc, LPRECT, ED2);
			PARM(code, INT, prc->left);
			INDENT();
			P2LABEL(code);
			TableOrInt2(pmps, tblLVItemRect, code);
		}
		else
		{
			PARM(prc, LPRECT, ED2);
			INDENT();
			P2OUT(prc, left);
			P2OUT(prc, top);
			P2OUT(prc, right);
			P2OUT(prc, bottom);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SETITEMPOSITION)
{
	PARM(i, INT, WP);
	PARM(x, INT, LOLP);
	PARM(y, INT, HILP);

	POUT(i);
	POUT(x);
	POUT(y);

	return TRUE;
}

DECODERET(LVM_SETITEMPOSITION)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_SETITEMPOSITION);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETITEMPOSITION);

DECODERET(LVM_GETITEMPOSITION)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(LVM_GETITEMPOSITION)
{
	P2WPOUT();

	P2LPOUTPTR(POINT);
	P2IFSIZEOF(POINT)
	{
		PARM(pt, LPPOINT, ED2);
		INDENT();
		P2OUT(pt, x);
		P2OUT(pt, y);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_GETSTRINGWIDTH)
{
	PARM(psz, LPSTR, LP);
	POUTC(psz, DWORD);

	return TRUE;
}

DECODERET(LVM_GETSTRINGWIDTH)
{
	PARM(nWidth, INT, RET);
	POUT(nWidth);

	return TRUE;
}

DECODEPARM(LVM_GETSTRINGWIDTH)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(psz, LPSTR, ED2);
		INDENT();
		P2OUTS(psz);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_HITTEST)
{
	PARM(pinfo, LV_HITTESTINFO FAR *, LP);
	POUTC(pinfo, DWORD);

	return TRUE;
}

DECODERET(LVM_HITTEST)
{
	PARM(nIndex, INT, RET);
	POUT(nIndex);

	return TRUE;
}

DECODEPARM(LVM_HITTEST)
{
	P2WPOUT();

	P2LPOUTPTR(LV_HITTESTINFO);
	P2IFSIZEOF(LV_HITTESTINFO)
	{
		PARM(pinfo, LV_HITTESTINFO FAR *, ED2);
		INDENT();
		P2OUTPT(pinfo, pt);
		P2OUTC(pinfo, flags, UINT);
		P2OUT(pinfo, iItem);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_ENSUREVISIBLE)
{
	PARM(iItem, INT, WP);
	PARM(fPartialOK, BOOL, LP);

	POUT(iItem);
	POUTB(fPartialOK);

	return TRUE;
}

DECODERET(LVM_ENSUREVISIBLE)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_ENSUREVISIBLE);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SCROLL)
{
	PARM(dx, INT, LOLP);
	PARM(dy, INT, HILP);

	POUT(dx);
	POUT(dy);

	return TRUE;
}

DECODERET(LVM_SCROLL)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_SCROLL);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_REDRAWITEMS)
{
	PARM(iFirst, INT, LOLP);
	PARM(iLast, INT, HILP);

	POUT(iFirst);
	POUT(iLast);

	return TRUE;
}

DECODERET(LVM_REDRAWITEMS)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_REDRAWITEMS);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_ARRANGE)
{
	PARM(code, UINT, WP);
	TABLEORVALUE(tblLVArrange, code);

	return TRUE;
}

DECODERET(LVM_ARRANGE)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_ARRANGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_EDITLABEL)
{
	PARM(iItem, INT, WP);
	POUT(iItem);

	return TRUE;
}

DECODERET(LVM_EDITLABEL)
{
	PARM(hwndEdit, HWND, RET);
	POUTC(hwndEdit, DWORD);

	return TRUE;
}

NODECODEPARM(LVM_EDITLABEL);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETEDITCONTROL);

DECODERET(LVM_GETEDITCONTROL)
{
	PARM(hwndEdit, HWND, RET);
	POUTC(hwndEdit, DWORD);

	return TRUE;
}

NODECODEPARM(LVM_GETEDITCONTROL);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_GETCOLUMN)
{
	PARM(iCol, INT, WP);
	PARM(pcol, LV_COLUMN FAR *, LP);

	POUT(iCol);
	POUTC(pcol, DWORD);

	return TRUE;
}

DECODERET(LVM_GETCOLUMN)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(LVM_GETCOLUMN)
{
	P2WPOUT();

	P2LPOUTPTR(LV_COLUMN);
	P2IFSIZEOF(LV_COLUMN)
	{
		PARM(pcol, LV_COLUMN FAR *, ED2);
//		PARM(pszName, LPSTR, pcol->pszText);
		INDENT();
		P2OUTC(pcol, mask, UINT);
		P2OUT(pcol, fmt);
		P2OUT(pcol, cx);
		P2OUTPTRSTR(pcol, pszText);
//		INDENT();
//		P2OUTS(pszName);
//		OUTDENT();
		P2OUT(pcol, cchTextMax);
		P2OUT(pcol, iSubItem);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SETCOLUMN)
{
	DECODELIKE(LVM_GETCOLUMN);
}

DECODERET(LVM_SETCOLUMN)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(LVM_SETCOLUMN)
{
	DECODEPARMLIKE(LVM_GETCOLUMN);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_INSERTCOLUMN)
{
	DECODELIKE(LVM_GETCOLUMN);
}

DECODERET(LVM_INSERTCOLUMN)
{
	PARM(nIndex, INT, RET);
	POUT(nIndex);

	return TRUE;
}

DECODEPARM(LVM_INSERTCOLUMN)
{
	DECODEPARMLIKE(LVM_GETCOLUMN);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_DELETECOLUMN)
{
	PARM(iCol, INT, WP);
	POUT(iCol);

	return TRUE;
}

DECODERET(LVM_DELETECOLUMN)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_DELETECOLUMN);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_GETCOLUMNWIDTH)
{
	PARM(iCol, INT, WP);
	POUT(iCol);

	return TRUE;
}

DECODERET(LVM_GETCOLUMNWIDTH)
{
	PARM(iWidth, INT, RET);
	POUT(iWidth);

	return TRUE;
}

NODECODEPARM(LVM_GETCOLUMNWIDTH);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SETCOLUMNWIDTH)
{
	PARM(iCol, INT, WP);
	PARM(cx, INT, LOLP);

	POUT(iCol);
	TABLEORVALUE(tblLVColumnWidth, cx);

	return TRUE;
}

DECODERET(LVM_SETCOLUMNWIDTH)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_SETCOLUMNWIDTH);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_CREATEDRAGIMAGE)
{
	PARM(iItem, INT, WP);
	PARM(lpptUpLeft, LPPOINT, LP);

	POUT(iItem);
	POUTC(lpptUpLeft, DWORD);

	return TRUE;
}

DECODERET(LVM_CREATEDRAGIMAGE)
{
	PARM(hImage, HANDLE, RET);
	POUTC(hImage, DWORD);

	return TRUE;
}

DECODEPARM(LVM_CREATEDRAGIMAGE)
{
	P2WPOUT();

	P2LPOUTPTR(POINT);
	P2IFSIZEOF(POINT)
	{
		PARM(pt, LPPOINT, ED2);
		INDENT();
		P2OUT(pt, x);
		P2OUT(pt, y);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_GETVIEWRECT)
{
	PARM(prc, LPRECT, LP);
	POUTC(prc, DWORD);

	return TRUE;
}

DECODERET(LVM_GETVIEWRECT)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(LVM_GETVIEWRECT)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(prc, LPRECT, ED2);
		INDENT();
		P2OUT(prc, left);
		P2OUT(prc, top);
		P2OUT(prc, right);
		P2OUT(prc, bottom);
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETTEXTCOLOR);

DECODERET(LVM_GETTEXTCOLOR)
{
	PARM(clrText, COLORREF, RET);
	POUTC(clrText, DWORD);

	return TRUE;
}

NODECODEPARM(LVM_GETTEXTCOLOR);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SETTEXTCOLOR)
{
	DECODELIKE(LVM_SETTEXTBKCOLOR);
}

DECODERET(LVM_SETTEXTCOLOR)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_SETTEXTCOLOR);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETTEXTBKCOLOR);

DECODERET(LVM_GETTEXTBKCOLOR)
{
	PARM(clrText, COLORREF, RET);
	POUTC(clrText, DWORD);

	return TRUE;
}

NODECODEPARM(LVM_GETTEXTBKCOLOR);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SETTEXTBKCOLOR)
{
	PARM(clrText, COLORREF, LP);
	POUTC(clrText, DWORD);

	return TRUE;
}

DECODERET(LVM_SETTEXTBKCOLOR)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_SETTEXTBKCOLOR);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETTOPINDEX);

DECODERET(LVM_GETTOPINDEX)
{
	PARM(nTopIndex, INT, RET);
	POUT(nTopIndex);

	return TRUE;
}

NODECODEPARM(LVM_GETTOPINDEX);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETCOUNTPERPAGE);

DECODERET(LVM_GETCOUNTPERPAGE)
{
	PARM(iCount, INT, RET);
	POUT(iCount);

	return TRUE;
}

NODECODEPARM(LVM_GETCOUNTPERPAGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_GETORIGIN)
{
	PARM(lpptOrg, LPPOINT, LP);
	POUTC(lpptOrg, DWORD);

	return TRUE;
}

DECODERET(LVM_GETORIGIN)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(LVM_GETORIGIN)
{
	DECODEPARMLIKE(LVM_GETITEMPOSITION);
}
//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_UPDATE)
{
	PARM(iItem, INT, WP);
	POUT(iItem);

	return TRUE;
}

DECODERET(LVM_UPDATE)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_UPDATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SETITEMSTATE)
{
	PARM(i, INT, WP);
	PARM(pitem, LV_ITEM FAR *, LP);

	POUT(i);
	POUTC(pitem, DWORD);

	return TRUE;
}

DECODERET(LVM_SETITEMSTATE)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(LVM_SETITEMSTATE)
{
	DECODEPARMLIKE(LVM_GETITEM);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_GETITEMSTATE)
{
	PARM(i, INT, WP);
	PARM(mask, UINT, LP);

	POUT(i);
	POUTC(mask, UINT);

	return TRUE;
}

DECODERET(LVM_GETITEMSTATE)
{
	PARM(flags, UINT, RET);
	POUTC(flags, UINT);

	return TRUE;
}

NODECODEPARM(LVM_GETITEMSTATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_GETITEMTEXT)
{
	PARM(iItem, INT, WP);
	PARM(pitem, LV_ITEM FAR *, LP);

	POUT(iItem);
	POUTC(pitem, DWORD);

	return TRUE;
}

DECODERET(LVM_GETITEMTEXT)
{
	PARM(cchChar, INT, RET);
	POUT(cchChar);

	return TRUE;
}

DECODEPARM(LVM_GETITEMTEXT)
{
	DECODEPARMLIKE(LVM_GETITEM);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SETITEMTEXT)
{
	DECODELIKE(LVM_SETITEMSTATE);
}

DECODERET(LVM_SETITEMTEXT)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(LVM_SETITEMTEXT)
{
	DECODEPARMLIKE(LVM_SETITEMSTATE);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SETITEMCOUNT)
{
	PARM(cItems, INT, WP);
	POUT(cItems);

	return TRUE;
}

NODECODERET(LVM_SETITEMCOUNT);

NODECODEPARM(LVM_SETITEMCOUNT);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SORTITEMS)
{
	PARM(lParamSort, LPARAM, WP);
	PARM(pfnCompare, PFNLVCOMPARE, LP);

	POUTC(lParamSort, DWORD);
	POUTC(pfnCompare, DWORD);

	return TRUE;
}

DECODERET(LVM_SORTITEMS)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(LVM_SORTITEMS);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_SETITEMPOSITION32)
{
	PARM(iItem, INT, WP);
	PARM(lpptNewPos, LPPOINT, LP);

	POUT(iItem);
	POUTC(lpptNewPos, DWORD);

	return TRUE;
}

NODECODERET(LVM_SETITEMPOSITION32);

DECODEPARM(LVM_SETITEMPOSITION32)
{
	DECODEPARMLIKE(LVM_GETITEMPOSITION);
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETSELECTEDCOUNT);

DECODERET(LVM_GETSELECTEDCOUNT)
{
	PARM(nSelected, INT, RET);
	POUT(nSelected);

	return TRUE;
}

NODECODEPARM(LVM_GETSELECTEDCOUNT);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_GETITEMSPACING)
{
	PARM(fSmall, BOOL, WP);
	POUTB(fSmall);

	return TRUE;
}

DECODERET(LVM_GETITEMSPACING)
{
	PARM(iSpacing, INT, RET);
	POUT(iSpacing);

	return TRUE;
}

NODECODEPARM(LVM_GETITEMSPACING);

//////////////////////////////////////////////////////////////////////////////

DECODE(LVM_GETISEARCHSTRING)
{
	PARM(lpsz, LPSTR, LP);
	POUTC(lpsz, DWORD);

	return TRUE;
}

DECODERET(LVM_GETISEARCHSTRING)
{
	PARM(cchChar, INT, RET);
	POUT(cchChar);

	return TRUE;
}

DECODEPARM(LVM_GETISEARCHSTRING)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(pstr, LPSTR, ED2);
		INDENT();
		P2OUTS(pstr);
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETITEMW);

NODECODERET(LVM_GETITEMW);

NODECODEPARM(LVM_GETITEMW);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_SETITEMW);

NODECODERET(LVM_SETITEMW);

NODECODEPARM(LVM_SETITEMW);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_INSERTITEMW);

NODECODERET(LVM_INSERTITEMW);

NODECODEPARM(LVM_INSERTITEMW);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_FINDITEMW);

NODECODERET(LVM_FINDITEMW);

NODECODEPARM(LVM_FINDITEMW);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETSTRINGWIDTHW);

DECODERET(LVM_GETSTRINGWIDTHW)
{
	PARM(nWidth, INT, RET);
	POUT(nWidth);

	return TRUE;
}

NODECODEPARM(LVM_GETSTRINGWIDTHW);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETCOLUMNW);

NODECODERET(LVM_GETCOLUMNW);

NODECODEPARM(LVM_GETCOLUMNW);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_SETCOLUMNW);

NODECODERET(LVM_SETCOLUMNW);

NODECODEPARM(LVM_SETCOLUMNW);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_INSERTCOLUMNW);

NODECODERET(LVM_INSERTCOLUMNW);

NODECODEPARM(LVM_INSERTCOLUMNW);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETITEMTEXTW);

NODECODERET(LVM_GETITEMTEXTW);

NODECODEPARM(LVM_GETITEMTEXTW);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_SETITEMTEXTW);

NODECODERET(LVM_SETITEMTEXTW);

NODECODEPARM(LVM_SETITEMTEXTW);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LVM_GETISEARCHSTRINGW);

NODECODERET(LVM_GETISEARCHSTRINGW);

NODECODEPARM(LVM_GETISEARCHSTRINGW);

//////////////////////////////////////////////////////////////////////////////
#endif	// DISABLE_WIN95_MESSAGES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\mainfrm.cpp ===
// mainfrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#pragma hdrstop

#include "mainfrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_CLOSE()
	ON_WM_SYSCOLORCHANGE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars

// toolbar buttons - IDs are command buttons
static UINT BASED_CODE buttons[] =
{
	//
	// CAUTION!  If you add/remove buttons, you MUST update
	// the INDEX_START_IMAGE and INDEX_STOP_IMAGE defines
	// in SPYXX.H!
	//

#ifdef OLD_TOOLBAR
	// same order as in the bitmap 'toolbarx.bmp'
	ID_SPY_MESSAGES,
	ID_SPY_WINDOWS,
	ID_SPY_PROCESSES,
	ID_SPY_THREADS,
		ID_SEPARATOR,
	ID_MESSAGES_STARTSTOP,
	ID_MESSAGES_OPTIONS,
	ID_MESSAGES_CLEAR,
		ID_SEPARATOR,
	ID_SPY_FINDWINDOW,
		ID_SEPARATOR,
	ID_SEARCH_FIND,
	ID_SEARCH_FINDNEXT,
	ID_SEARCH_FINDPREV,
		ID_SEPARATOR,
	ID_TREE_EXPAND_ONE_LEVEL,
	ID_TREE_EXPAND_BRANCH,
	ID_TREE_EXPAND_ALL,
	ID_TREE_COLLAPSE,
		ID_SEPARATOR,
	ID_WINDOW_CASCADE,
	ID_WINDOW_TILE_HORZ,
	ID_WINDOW_TILE_VERT
#else	// OLD_TOOLBAR
	// same order as in the bitmap 'toolbar.bmp'
	ID_SPY_WINDOWS,
	ID_SPY_PROCESSES,
	ID_SPY_THREADS,
		ID_SEPARATOR,
	ID_SPY_MESSAGES,
		ID_SEPARATOR,
	ID_MESSAGES_STARTSTOP,
	ID_MESSAGES_OPTIONS,
	ID_MESSAGES_CLEAR,
		ID_SEPARATOR,
	ID_SPY_FINDWINDOW,
		ID_SEPARATOR,
	ID_TREE_EXPAND_ONE_LEVEL,
	ID_TREE_EXPAND_BRANCH,
	ID_TREE_EXPAND_ALL,
	ID_TREE_COLLAPSE,
		ID_SEPARATOR,
	ID_SEARCH_FIND,
	ID_SEARCH_FINDNEXT,
	ID_SEARCH_FINDPREV,
		ID_SEPARATOR,
	ID_WINDOW_CASCADE,
	ID_WINDOW_TILE_HORZ,
	ID_WINDOW_TILE_VERT
#endif	// OLD_TOOLBAR
};

static UINT BASED_CODE indicators[] =
{
	ID_SEPARATOR,			// status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	SetWindowLong(m_hWnd, GWL_USERDATA, SPYXX_WINDOW_SIGNATURE);

	if (!m_wndToolBar.Create(this, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_TOOLTIPS | CBRS_FLYBY) ||
		!m_wndToolBar.LoadBitmap(IDR_MAINFRAME) || !m_wndToolBar.SetButtons(buttons, sizeof(buttons)/sizeof(UINT)))
	{
		TRACE("Failed to create toolbar\n");
		return -1;	  // fail to create
	}

	if (!m_wndStatusBar.Create(this) || !m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT)))
	{
		TRACE("Failed to create status bar\n");
		return -1;	  // fail to create
	}

	return 0;
}



void CMainFrame::OnClose()
{
	theApp.m_wndplMain.length = sizeof(WINDOWPLACEMENT);
	theApp.m_fMainWndplValid = GetWindowPlacement(&theApp.m_wndplMain);

	CMDIFrameWnd::OnClose();
}



/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers


void CMainFrame::OnSysColorChange()
{
	CMDIFrameWnd::OnSysColorChange();

	//
	// Recreate the Window color brush with the new system colors.
	//
	theApp.m_BrushWindow.DeleteObject();
	theApp.m_BrushWindow.CreateSolidBrush(GetSysColor(COLOR_WINDOW));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\mainfrm.h ===
// mainfrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:
	CToolBar	m_wndToolBar;
	CStatusBar  m_wndStatusBar;

// Operations
public:

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnClose();
	afx_msg void OnSysColorChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\kbdmsgs.cpp ===
//-----------------------------------------------------------------------------
//  KbdMsgs.cpp
//
//  Keyboard message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

static VALUETABLE tblHotKey[] =
{
	TABLEENTRY(IDHOT_SNAPDESKTOP),
	TABLEENTRY(IDHOT_SNAPWINDOW),
	TABLEEND
};

static VALUETABLE tblVirtKey[] =
{
	TABLEENTRY(VK_LBUTTON),
	TABLEENTRY(VK_RBUTTON),
	TABLEENTRY(VK_CANCEL),
	TABLEENTRY(VK_MBUTTON),
	TABLEENTRY(VK_BACK),
	TABLEENTRY(VK_TAB),
	TABLEENTRY(VK_CLEAR),
	TABLEENTRY(VK_RETURN),
	TABLEENTRY(VK_SHIFT),
	TABLEENTRY(VK_CONTROL),
	TABLEENTRY(VK_MENU),
	TABLEENTRY(VK_PAUSE),
	TABLEENTRY(VK_CAPITAL),
	TABLEENTRY(VK_ESCAPE),
	TABLEENTRY(VK_SPACE),
	TABLEENTRY(VK_PRIOR),
	TABLEENTRY(VK_NEXT),
	TABLEENTRY(VK_END),
	TABLEENTRY(VK_HOME),
	TABLEENTRY(VK_LEFT),
	TABLEENTRY(VK_UP),
	TABLEENTRY(VK_RIGHT),
	TABLEENTRY(VK_DOWN),
	TABLEENTRY(VK_SELECT),
	TABLEENTRY(VK_PRINT),
	TABLEENTRY(VK_EXECUTE),
	TABLEENTRY(VK_SNAPSHOT),
	TABLEENTRY(VK_INSERT),
	TABLEENTRY(VK_DELETE),
	TABLEENTRY(VK_HELP),
	TABLEENTRY(VK_NUMPAD0),
	TABLEENTRY(VK_NUMPAD1),
	TABLEENTRY(VK_NUMPAD2),
	TABLEENTRY(VK_NUMPAD3),
	TABLEENTRY(VK_NUMPAD4),
	TABLEENTRY(VK_NUMPAD5),
	TABLEENTRY(VK_NUMPAD6),
	TABLEENTRY(VK_NUMPAD7),
	TABLEENTRY(VK_NUMPAD8),
	TABLEENTRY(VK_NUMPAD9),
	TABLEENTRY(VK_MULTIPLY),
	TABLEENTRY(VK_ADD),
	TABLEENTRY(VK_SEPARATOR),
	TABLEENTRY(VK_SUBTRACT),
	TABLEENTRY(VK_DECIMAL),
	TABLEENTRY(VK_DIVIDE),
	TABLEENTRY(VK_F1),
	TABLEENTRY(VK_F2),
	TABLEENTRY(VK_F3),
	TABLEENTRY(VK_F4),
	TABLEENTRY(VK_F5),
	TABLEENTRY(VK_F6),
	TABLEENTRY(VK_F7),
	TABLEENTRY(VK_F8),
	TABLEENTRY(VK_F9),
	TABLEENTRY(VK_F10),
	TABLEENTRY(VK_F11),
	TABLEENTRY(VK_F12),
	TABLEENTRY(VK_F13),
	TABLEENTRY(VK_F14),
	TABLEENTRY(VK_F15),
	TABLEENTRY(VK_F16),
	TABLEENTRY(VK_F17),
	TABLEENTRY(VK_F18),
	TABLEENTRY(VK_F19),
	TABLEENTRY(VK_F20),
	TABLEENTRY(VK_F21),
	TABLEENTRY(VK_F22),
	TABLEENTRY(VK_F23),
	TABLEENTRY(VK_F24),
	TABLEENTRY(VK_NUMLOCK),
	TABLEENTRY(VK_SCROLL),
	TABLEEND
};

static VALUETABLE tblVirtKey2[] =
{
	TABLEENTRY('0'),
	TABLEENTRY('1'),
	TABLEENTRY('2'),
	TABLEENTRY('3'),
	TABLEENTRY('4'),
	TABLEENTRY('5'),
	TABLEENTRY('6'),
	TABLEENTRY('7'),
	TABLEENTRY('8'),
	TABLEENTRY('9'),
	TABLEENTRY('A'),
	TABLEENTRY('B'),
	TABLEENTRY('C'),
	TABLEENTRY('D'),
	TABLEENTRY('E'),
	TABLEENTRY('F'),
	TABLEENTRY('G'),
	TABLEENTRY('H'),
	TABLEENTRY('I'),
	TABLEENTRY('J'),
	TABLEENTRY('K'),
	TABLEENTRY('L'),
	TABLEENTRY('M'),
	TABLEENTRY('N'),
	TABLEENTRY('O'),
	TABLEENTRY('P'),
	TABLEENTRY('Q'),
	TABLEENTRY('R'),
	TABLEENTRY('S'),
	TABLEENTRY('T'),
	TABLEENTRY('U'),
	TABLEENTRY('V'),
	TABLEENTRY('W'),
	TABLEENTRY('X'),
	TABLEENTRY('Y'),
	TABLEENTRY('Z'),
	TABLEEND
};

//////////////////////////////////////////////////////////////////////////////

static VOID PrintVirtualKey(UINT vkey)
{
	if (!TableOrNothing(tblVirtKey, vkey))
	{
		TableOrValueNotHot(tblVirtKey2, vkey);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CHAR)
{
	static TCHAR tchLead = 0;

	PARM(chCharCode, TCHAR, WP);
	PARM(lKeyData, UINT, LP);
	INT cRepeat = (INT)(unsigned short)LOWORD(lKeyData);
	CHAR szScanCode[8];
	WORD wScanCode = HIWORD(lKeyData) & 0xFF;
	BOOL fExtended = (HIWORD(lKeyData) & KF_EXTENDED) ? 1 : 0;
	BOOL fAltDown = (HIWORD(lKeyData) & KF_ALTDOWN) ? 1 : 0;
	BOOL fRepeat = (HIWORD(lKeyData) & KF_REPEAT) ? 1 : 0;
	BOOL fUp = (HIWORD(lKeyData) & KF_UP) ? 1 : 0;

	if (IsDBCSLeadByte((char)chCharCode))
	{
		MOUT << " chCharCode:'.' (" << (INT)(UCHAR)chCharCode << ") (lead)";
		tchLead = chCharCode;
	}
	else if (tchLead)
	{
		MOUT << " chCharCode:'" << tchLead << chCharCode << "' (" << (INT)(UCHAR)chCharCode << ") (trail)";
		tchLead = 0;
	}
	else
	{
		MOUT << " chCharCode:'" << chCharCode << "' (" << (INT)(UCHAR)chCharCode << ')';
	}

	POUT(cRepeat);
	wsprintf(szScanCode, "%2.2X", wScanCode);
	PLABEL(ScanCode);
	MOUT << szScanCode;

	//
	// These are printed out as 1/0, not True/False to save space.
	//
	POUT(fExtended);
	POUT(fAltDown);
	POUT(fRepeat);
	POUT(fUp);

	return TRUE;
}

NODECODERET(WM_CHAR);

NODECODEPARM(WM_CHAR);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_CHARTOITEM)
{
	PARM(nKey, CHAR, LOWP);
	PARM(nCaretPos, UINT, HIWP);
	PARM(hwndListBox, HWND, LP);

	PLABEL(nKey);
	MOUT << '\'' << nKey << "' (" << (INT)(UCHAR)nKey << ')';
	POUTC(nCaretPos, INT);
	POUT(hwndListBox);

	return TRUE;
}

DECODERET(WM_CHARTOITEM)
{
	PARM(fuAction, INT, RET);

	POUT(fuAction);
	switch (fuAction)
	{
		case -2:
			MOUT << ids(IDS_HANDLED_BY_APPLICATION);
			break;

		case -1:
			MOUT << ids(IDS_PERFORM_DEFAULT_ACTION);
			break;

		default:
			MOUT << ids(IDS_SELECT_ITEM_AT_INDEX) << fuAction << ')';
			break;
	}

	return TRUE;
}

NODECODEPARM(WM_CHARTOITEM);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_DEADCHAR)
{
	DECODELIKE(WM_CHAR);
}

NODECODERET(WM_DEADCHAR);

NODECODEPARM(WM_DEADCHAR);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_GETHOTKEY);

DECODERET(WM_GETHOTKEY)
{
	PARM(vkey, UINT, RET);

	PLABEL(vkey);
	if (vkey)
	{
		PrintVirtualKey(vkey);
	}
	else
	{
		MOUT << ids(IDS_NONE);
	}

	return TRUE;
}

NODECODEPARM(WM_GETHOTKEY);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_HOTKEY)
{
	PARM(idHotKey, INT, WP);

	TABLEORVALUE(tblHotKey, idHotKey);
	// TODO: do a GlobalGetAtomName in the hook if the idHotKey is
	// in the proper range to try and get the name of the hotkey.

	return TRUE;
}

NODECODERET(WM_HOTKEY);

NODECODEPARM(WM_HOTKEY);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_KEYDOWN)
{
	PARM(nVirtKey, UINT, WP);
	PARM(lKeyData, UINT, LP);
	INT cRepeat = (INT)(unsigned short)LOWORD(lKeyData);
	CHAR szScanCode[8];
	WORD wScanCode = HIWORD(lKeyData) & 0xFF;
	BOOL fExtended = (HIWORD(lKeyData) & KF_EXTENDED) ? 1 : 0;
	BOOL fAltDown = (HIWORD(lKeyData) & KF_ALTDOWN) ? 1 : 0;
	BOOL fRepeat = (HIWORD(lKeyData) & KF_REPEAT) ? 1 : 0;
	BOOL fUp = (HIWORD(lKeyData) & KF_UP) ? 1 : 0;

	PLABEL(nVirtKey);
	PrintVirtualKey(nVirtKey);
	POUT(cRepeat);
	wsprintf(szScanCode, "%2.2X", wScanCode);
	PLABEL(ScanCode);
	MOUT << szScanCode;

	//
	// These are printed out as 1/0, not True/False to save space.
	//
	POUT(fExtended);
	POUT(fAltDown);
	POUT(fRepeat);
	POUT(fUp);

	return TRUE;
}

NODECODERET(WM_KEYDOWN);

NODECODEPARM(WM_KEYDOWN);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_KEYUP)
{
	DECODELIKE(WM_KEYDOWN);
}

NODECODERET(WM_KEYUP);

NODECODEPARM(WM_KEYUP);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SETHOTKEY)
{
	PARM(vkey, UINT, WP);

	PLABEL(vkey);
	PrintVirtualKey(vkey);

	return TRUE;
}

DECODERET(WM_SETHOTKEY)
{
	PARM(lResult, INT, RET);

	POUT(lResult);
	switch (lResult)
	{
		case 2:
			MOUT << ids(IDS_SUCCESSFUL_HOTKEY1);
			break;

		case 1:
			MOUT << ids(IDS_SUCCESSFUL_HOTKEY2);
			break;

		case 0:
			MOUT << ids(IDS_UNSUCCESSFUL_HOTKEY1);
			break;

		case -1:
			MOUT << ids(IDS_UNSUCCESSFUL_HOTKEY2);
			break;
	}

	return TRUE;
}

NODECODEPARM(WM_SETHOTKEY);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SYSCHAR)
{
	DECODELIKE(WM_CHAR);
}

NODECODERET(WM_SYSCHAR);

NODECODEPARM(WM_SYSCHAR);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SYSDEADCHAR)
{
	DECODELIKE(WM_CHAR);
}

NODECODERET(WM_SYSDEADCHAR);

NODECODEPARM(WM_SYSDEADCHAR);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SYSKEYDOWN)
{
	DECODELIKE(WM_KEYDOWN);
}


NODECODERET(WM_SYSKEYDOWN);

NODECODEPARM(WM_SYSKEYDOWN);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SYSKEYUP)
{
	DECODELIKE(WM_KEYDOWN);
}


NODECODERET(WM_SYSKEYUP);

NODECODEPARM(WM_SYSKEYUP);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_VKEYTOITEM)
{
	PARM(vkey, UINT, LOWP);
	PARM(nCaretPos, UINT, HIWP);
	PARM(hwndLB, HWND, LP);

	PLABEL(vkey);
	PrintVirtualKey(vkey);
	POUTC(nCaretPos, INT);
	POUT(hwndLB);

	return TRUE;
}

DECODERET(WM_VKEYTOITEM)
{
	DECODERETLIKE(WM_CHARTOITEM);
}

NODECODEPARM(WM_VKEYTOITEM);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\lbmsgs.cpp ===
//-----------------------------------------------------------------------------
//  LBMsgs.cpp
//
//  Listbox message (LB_*) crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

VALUETABLE tblFileAttrs[] =
{
	TABLEENTRY(DDL_READONLY),
	TABLEENTRY(DDL_HIDDEN),
	TABLEENTRY(DDL_SYSTEM),
	TABLEENTRY(DDL_DIRECTORY),
	TABLEENTRY(DDL_ARCHIVE),
	TABLEENTRY(DDL_DRIVES),
	TABLEENTRY(DDL_EXCLUSIVE),
	//
	// DDL_READWRITE is 0x0000, and so it should not be in the table.
	//
	//TABLEENTRY(DDL_READWRITE),
	TABLEEND
};

VALUETABLE tblLBRet[] =
{
	TABLEENTRY(LB_ERR),
	TABLEENTRY(LB_ERRSPACE),
	TABLEEND
};

static VALUETABLE tblLBRetOK[] =
{
	TABLEENTRY(LB_OKAY),
	TABLEENTRY(LB_ERR),
	TABLEENTRY(LB_ERRSPACE),
	TABLEEND
};

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_ADDFILE)
{
	PARM(lpszFilename, LPCTSTR, LP);

	POUTC(lpszFilename, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

DECODERET(LB_ADDFILE)
{
	DECODERETLIKE(LB_ADDSTRING);
}

DECODEPARM(LB_ADDFILE)
{
	DECODEPARMLIKE(LB_ADDSTRING);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_ADDSTRING)
{
	PARM(lpsz, LPCTSTR, LP);

	POUTC(lpsz, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

DECODERET(LB_ADDSTRING)
{
	PARM(index, INT, RET);

	TABLEORINT(tblLBRet, index);

	return TRUE;
}

DECODEPARM(LB_ADDSTRING)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(pstr, LPSTR, ED2);
		INDENT();
		P2OUTS(pstr);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_DELETESTRING)
{
	PARM(index, INT, WP);

	POUT(index);

	return TRUE;
}

DECODERET(LB_DELETESTRING)
{
	PARM(cItemsRemaining, INT, RET);

	TABLEORINT(tblLBRet, cItemsRemaining);

	return TRUE;
}

NODECODEPARM(LB_DELETESTRING);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_DIR)
{
	PARM(uAttrs, UINT, WP);
	PARM(lpszFileSpec, LPCTSTR, LP);

	TABLEFLAGS(tblFileAttrs, uAttrs);
	POUTC(lpszFileSpec, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

DECODERET(LB_DIR)
{
	DECODERETLIKE(LB_ADDSTRING);
}

DECODEPARM(LB_DIR)
{
	DECODEPARMLIKE(LB_ADDSTRING);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_FINDSTRING)
{
	PARM(indexStart, INT, WP);
	PARM(lpszFind, LPCTSTR, LP);

	POUT(indexStart);
	if (indexStart == -1)
	{
		MOUT << ids(IDS_FROM_THE_BEGINNING);
	}

	POUTC(lpszFind, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

DECODERET(LB_FINDSTRING)
{
	DECODERETLIKE(LB_ADDSTRING);
}

DECODEPARM(LB_FINDSTRING)
{
	DECODEPARMLIKE(LB_ADDSTRING);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_FINDSTRINGEXACT)
{
	DECODELIKE(LB_FINDSTRING);
}

DECODERET(LB_FINDSTRINGEXACT)
{
	DECODERETLIKE(LB_FINDSTRING);
}

DECODEPARM(LB_FINDSTRINGEXACT)
{
	DECODEPARMLIKE(LB_FINDSTRING);
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(LB_GETANCHORINDEX);

DECODERET(LB_GETANCHORINDEX)
{
	DECODERETLIKE(LB_ADDSTRING);
}

NODECODEPARM(LB_GETANCHORINDEX);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LB_GETCARETINDEX);

DECODERET(LB_GETCARETINDEX)
{
	DECODERETLIKE(LB_ADDSTRING);
}

NODECODEPARM(LB_GETCARETINDEX);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LB_GETCOUNT);

DECODERET(LB_GETCOUNT)
{
	PARM(cItems, INT, RET);

	TABLEORINT(tblLBRet, cItems);

	return TRUE;
}

NODECODEPARM(LB_GETCOUNT);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LB_GETCURSEL);

DECODERET(LB_GETCURSEL)
{
	DECODERETLIKE(LB_ADDSTRING);
}

NODECODEPARM(LB_GETCURSEL);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LB_GETHORIZONTALEXTENT);

DECODERET(LB_GETHORIZONTALEXTENT)
{
	PARM(cxExtent, INT, RET);

	TABLEORINT(tblLBRet, cxExtent);

	return TRUE;
}

NODECODEPARM(LB_GETHORIZONTALEXTENT);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_GETITEMDATA)
{
	PARM(index, INT, WP);

	POUT(index);

	return TRUE;
}

DECODERET(LB_GETITEMDATA)
{
	PARM(dwData, DWORD, RET);

	TABLEORDWORD(tblLBRet, dwData);

	return TRUE;
}

NODECODEPARM(LB_GETITEMDATA);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_GETITEMHEIGHT)
{
	DECODELIKE(LB_GETITEMDATA);
}

DECODERET(LB_GETITEMHEIGHT)
{
	PARM(cyItem, INT, RET);

	TABLEORINT(tblLBRet, cyItem);

	return TRUE;
}

NODECODEPARM(LB_GETITEMHEIGHT);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_GETITEMRECT)
{
	PARM(index, INT, WP);
	PARM(lprc, LPRECT, LP);

	POUT(index);
	POUTC(lprc, DWORD);

	return TRUE;
}

DECODERET(LB_GETITEMRECT)
{
	PARM(lResult, UINT, RET);
	PARM(lprc, LPRECT, LP);

	TABLEORVALUE(tblLBRetOK, lResult);

	if (lResult != LB_ERR)
	{
		POUTC(lprc, DWORD);

		PIFSIZEOF(RECT)
		{
			PARM(prc, LPRECT, ED);
			POUTRECT(prc);
		}
	}

	return TRUE;
}

DECODEPARM(LB_GETITEMRECT)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(prc, LPRECT, ED2);
		INDENT();
		P2OUT(prc, left);
		P2OUT(prc, top);
		P2OUT(prc, right);
		P2OUT(prc, bottom);
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(LB_GETLOCALE);

DECODERET(LB_GETLOCALE)
{
	PARM(dwLocaleID, DWORD, RET);

	POUT(dwLocaleID);

	return TRUE;
}

NODECODEPARM(LB_GETLOCALE);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_GETSEL)
{
	DECODELIKE(LB_GETITEMDATA);
}

DECODERET(LB_GETSEL)
{
	PARM(fSelected, UINT, RET);

	PLABEL(fSelected);
	if (!TableOrNothing(tblLBRet, fSelected))
	{
		MOUT << tf(fSelected);
	}

	return TRUE;
}

NODECODEPARM(LB_GETSEL);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LB_GETSELCOUNT);

DECODERET(LB_GETSELCOUNT)
{
	PARM(cItemsSelected, INT, RET);

	TABLEORINT(tblLBRet, cItemsSelected);

	return TRUE;
}

NODECODEPARM(LB_GETSELCOUNT);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_GETSELITEMS)
{
	PARM(cItems, INT, WP);
	PARM(lpnItems, LPINT, LP);

	POUT(cItems);
	POUTC(lpnItems, DWORD);

	return TRUE;
}

DECODERET(LB_GETSELITEMS)
{
	PARM(cItems, INT, RET);
	PARM(lpnItems, LPINT, LP);

	TABLEORINT(tblLBRet, cItems);

	PIFDATA()
	{
		PARM(pItems, PINT, ED);

		POUTC(lpnItems, DWORD);
		PrintIntArray(pItems, PSIZEOFED() / sizeof(INT), cItems);
	}

	return TRUE;
}

DECODEPARM(LB_GETSELITEMS)
{
	P2WPOUT();

	P2LPOUTPTR(INT array);
	P2IFDATA()
	{
		PARM(pItems, PINT, ED2);
		PARM(cItems, INT, RET2);
		INDENT();
		PrintIntArray2(pmps, pItems, P2SIZEOFED() / sizeof(INT), cItems);
		P2ENDLINE();
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_GETTEXT)
{
	PARM(index, INT, WP);
	PARM(lpszBuffer, LPCTSTR, LP);

	POUT(index);
	POUTC(lpszBuffer, DWORD);

	return TRUE;
}

DECODERET(LB_GETTEXT)
{
	PARM(cchText, INT, RET);
	PARM(lpszBuffer, LPCTSTR, LP);

	TABLEORINT(tblLBRet, cchText);
	POUTC(lpszBuffer, DWORD);
	PIFDATA()
	{
		PARM(pso, PPACK_STRINGORD, ED);

		PIFISORD(pso)
		{
			POUTORD(pso);
		}
		else
		{
			PARM(pstr, LPSTR, ED);
			POUTS(pstr);
		}
	}

	return TRUE;
}

DECODEPARM(LB_GETTEXT)
{
	P2WPOUT();

	P2LPOUTPTRSTR;
	P2IFDATA()
	{
		PARM(pso, PPACK_STRINGORD, ED2);

		INDENT();

		P2IFISORD(pso)
		{
			P2OUTORD(pso);
		}
		else
		{
			PARM(pstr, LPSTR, ED2);
			P2OUTS(pstr);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_GETTEXTLEN)
{
	DECODELIKE(LB_GETITEMDATA);
}

DECODERET(LB_GETTEXTLEN)
{
	PARM(cchText, INT, RET);

	TABLEORINT(tblLBRet, cchText);

	return TRUE;
}

NODECODEPARM(LB_GETTEXTLEN);

//////////////////////////////////////////////////////////////////////////////

NODECODE(LB_GETTOPINDEX);

DECODERET(LB_GETTOPINDEX)
{
	PARM(index, INT, RET);

	TABLEORINT(tblLBRet, index);

	return TRUE;
}

NODECODEPARM(LB_GETTOPINDEX);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_INSERTSTRING)
{
	PARM(index, INT, WP);
	PARM(lpsz, LPCTSTR, LP);

	POUT(index);
	if (index == -1)
	{
		MOUT << ids(IDS_END_OF_THE_LIST);
	}

	POUTC(lpsz, DWORD);
	PIFDATA()
	{
		PARM(pstr, LPSTR, ED);
		POUTS(pstr);
	}

	return TRUE;
}

DECODERET(LB_INSERTSTRING)
{
	DECODERETLIKE(LB_GETITEMDATA);
}

DECODEPARM(LB_INSERTSTRING)
{
	DECODEPARMLIKE(LB_ADDSTRING);
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(LB_RESETCONTENT);

NODECODERET(LB_RESETCONTENT);

NODECODEPARM(LB_RESETCONTENT);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SELECTSTRING)
{
	DECODELIKE(LB_FINDSTRING);
}

DECODERET(LB_SELECTSTRING)
{
	DECODERETLIKE(LB_GETITEMDATA);
}

DECODEPARM(LB_SELECTSTRING)
{
	DECODEPARMLIKE(LB_ADDSTRING);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SELITEMRANGE)
{
	PARM(fSelect, BOOL, WP);
	PARM(wFirst, UINT, LOLP);
	PARM(wLast, UINT, HILP);

	POUTB(fSelect);
	POUTC(wFirst, INT);
	POUTC(wLast, INT);

	return TRUE;
}

DECODERET(LB_SELITEMRANGE)
{
	PARM(lResult, UINT, RET);

	TABLEORVALUE(tblLBRetOK, lResult);

	return TRUE;
}

NODECODEPARM(LB_SELITEMRANGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SELITEMRANGEEX)
{
	PARM(indexFirst, UINT, WP);
	PARM(indexLast, UINT, LP);

	POUTC(indexFirst, INT);
	POUTC(indexLast, INT);
	if (indexFirst > indexLast)
	{
		MOUT << ids(IDS_UNSELECT_THE_RANGE);
	}

	return TRUE;
}

DECODERET(LB_SELITEMRANGEEX)
{
	DECODERETLIKE(LB_SELITEMRANGE);
}

NODECODEPARM(LB_SELITEMRANGEEX);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SETANCHORINDEX)
{
	DECODELIKE(LB_GETITEMDATA);
}

DECODERET(LB_SETANCHORINDEX)
{
	DECODERETLIKE(LB_SELITEMRANGE);
}

NODECODEPARM(LB_SETANCHORINDEX);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SETCARETINDEX)
{
	PARM(index, INT, WP);
	PARM(fScroll, BOOL, LP);

	POUT(index);
	POUTB(fScroll);

	return TRUE;
}

DECODERET(LB_SETCARETINDEX)
{
	DECODERETLIKE(LB_SELITEMRANGE);
}

NODECODEPARM(LB_SETCARETINDEX);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SETCOLUMNWIDTH)
{
	PARM(cxColumn, INT, WP);

	POUT(cxColumn);

	return TRUE;
}

NODECODERET(LB_SETCOLUMNWIDTH);

NODECODEPARM(LB_SETCOLUMNWIDTH);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SETCOUNT)
{
	PARM(cItems, INT, WP);

	POUT(cItems);

	return TRUE;
}

DECODERET(LB_SETCOUNT)
{
	DECODERETLIKE(LB_SELITEMRANGE);
}

NODECODEPARM(LB_SETCOUNT);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SETCURSEL)
{
	PARM(index, INT, WP);

	POUT(index);
	if (index == -1)
	{
		MOUT << ids(IDS_NO_SELECTION);
	}

	return TRUE;
}

DECODERET(LB_SETCURSEL)
{
	PARM(index, INT, WP);
	PARM(lResult, UINT, RET);

	PLABEL(lResult);
	if (index == -1 && lResult == (UINT)LB_ERR)
	{
		MOUT << "-1" << ids(IDS_SUCCESSFULLY_REMOVED_SELECT);
	}
	else
	{
		TableOrValue(tblLBRetOK, lResult);
	}

	return TRUE;
}

NODECODEPARM(LB_SETCURSEL);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SETHORIZONTALEXTENT)
{
	PARM(cxExtent, INT, WP);

	POUT(cxExtent);

	return TRUE;
}

NODECODERET(LB_SETHORIZONTALEXTENT);

NODECODEPARM(LB_SETHORIZONTALEXTENT);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SETITEMDATA)
{
	PARM(index, INT, WP);
	PARM(dwData, DWORD, LP);

	POUT(index);
	POUT(dwData);
	MOUT << " (" << (INT)dwData << ')';

	return TRUE;
}

DECODERET(LB_SETITEMDATA)
{
	DECODERETLIKE(LB_SELITEMRANGE);
}

NODECODEPARM(LB_SETITEMDATA);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SETITEMHEIGHT)
{
	PARM(index, INT, WP);
	PARM(cyItem, INT, LP);

	POUT(index);
	POUT(cyItem);

	return TRUE;
}

DECODERET(LB_SETITEMHEIGHT)
{
	DECODERETLIKE(LB_SELITEMRANGE);
}

NODECODEPARM(LB_SETITEMHEIGHT);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SETLOCALE)
{
	PARM(dwLocaleID, DWORD, WP);

	POUT(dwLocaleID);

	return TRUE;
}

DECODERET(LB_SETLOCALE)
{
	PARM(dwPrevLocaleID, DWORD, RET);

	TABLEORDWORD(tblLBRet, dwPrevLocaleID);

	return TRUE;
}

NODECODEPARM(LB_SETLOCALE);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SETSEL)
{
	PARM(fSelect, BOOL, WP);
	PARM(index, INT, LP);

	POUTB(fSelect);
	POUT(index);
	if (index == -1)
	{
		MOUT << ids(IDS_ALL_ITEMS);
	}

	return TRUE;
}

DECODERET(LB_SETSEL)
{
	DECODERETLIKE(LB_SELITEMRANGE);
}

NODECODEPARM(LB_SETSEL);

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SETTABSTOPS)
{
	PARM(cTabs, INT, WP);
	PARM(lpnTabs, LPINT, LP);

	POUT(cTabs);
	POUTC(lpnTabs, DWORD);

	PIFDATA()
	{
		PARM(pTabs, PINT, ED);

		PrintIntArray(pTabs, PSIZEOFED() / sizeof(INT), cTabs);
	}

	return TRUE;
}

DECODERET(LB_SETTABSTOPS)
{
	PARM(fSuccess, BOOL, RET);

	POUTB(fSuccess);

	return TRUE;
}

DECODEPARM(LB_SETTABSTOPS)
{
	P2WPOUT();

	P2LPOUTPTR(INT array);
	P2IFDATA()
	{
		PARM(pTabs, PINT, ED2);
		PARM(cTabs, INT, WP2);
		INDENT();
		PrintIntArray2(pmps, pTabs, P2SIZEOFED() / sizeof(INT), cTabs);
		P2ENDLINE();
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(LB_SETTOPINDEX)
{
	DECODELIKE(LB_GETITEMDATA);
}

DECODERET(LB_SETTOPINDEX)
{
	DECODERETLIKE(LB_SELITEMRANGE);
}

NODECODEPARM(LB_SETTOPINDEX);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\mdimsgs.cpp ===
//-----------------------------------------------------------------------------
//  MDIMsgs.cpp
//
//  MDI message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

VALUETABLE tblMDITile[] =
{
	TABLEENTRY(MDITILE_SKIPDISABLED),
	TABLEEND
};

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_CHILDACTIVATE);

NODECODERET(WM_CHILDACTIVATE);

NODECODEPARM(WM_CHILDACTIVATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MDIACTIVATE)
{
	UINT nClass;

	PARM(hwnd, HWND, HW);

	PIFSIZEOF(PACK_CLASS)
	{
		PARM(ppc, PPACK_CLASS, ED);
		nClass = ppc->nClass;
	}
	else
	{
		nClass = CLS_UNKNOWN;
	}

	if (nClass == CLS_MDICLIENT)
	{
		PARM(hwndChildAct, HWND, WP);
		POUT(hwndChildAct);
	}
	else
	{
		PARM(hwndChildDeact, HWND, WP);
		PARM(hwndChildAct, HWND, LP);

		POUT(hwndChildDeact);
		POUT(hwndChildAct);

		if (hwndChildAct == hwnd)
		{
			MOUT << ids(IDS_ACTIVATING);
		}
	}

	return TRUE;
}

NODECODERET(WM_MDIACTIVATE);

NODECODEPARM(WM_MDIACTIVATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MDICASCADE)
{
	PARM(fuCascade, UINT, WP);

	TABLEFLAGS(tblMDITile, fuCascade);

	return TRUE;
}

DECODERET(WM_MDICASCADE)
{
	PARM(fSuccess, BOOL, RET);

	POUTB(fSuccess);

	return TRUE;
}

NODECODEPARM(WM_MDICASCADE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MDICREATE)
{
	PARM(lpmdic, LPMDICREATESTRUCT, LP);

	POUTC(lpmdic, DWORD);

	return TRUE;
}

DECODERET(WM_MDICREATE)
{
	PARM(hwndChild, HWND, RET);

	POUT(hwndChild);

	return TRUE;
}

DECODEPARM(WM_MDICREATE)
{
	P2WPOUT();

	P2LPOUTPTR(MDICREATESTRUCT);
	P2IFSIZEOF(PACK_MDICREATESTRUCT)
	{
		PARM(ppmdic, PPACK_MDICREATESTRUCT, ED2);
		PARM(pmdic, LPMDICREATESTRUCT, &ppmdic->mdic);

		INDENT();

		if (ppmdic->fValidClass)
		{
			PARM(pszClass, LPSTR, ppmdic->szClass);
			P2OUTPTRSTR(pmdic, szClass);
			INDENT();
			P2OUTS(pszClass);
			OUTDENT();
		}
		else
		{
			CHAR szClass[50];

			if (GetClipboardFormatName((UINT)pmdic->szClass, szClass,
				sizeof(szClass) / sizeof(CHAR)))
			{
				P2LABEL(szClass);
				M2OUT << (DWORD)pmdic->szClass << ids(IDS_CLASS) << szClass << "')";
				P2ENDLINE();
			}
			else
			{
				P2OUTC(pmdic, szClass, DWORD);
			}
		}

		if (ppmdic->fValidTitle)
		{
			PARM(pszTitle, LPSTR, ppmdic->szTitle);
			P2OUTPTRSTR(pmdic, szTitle);
			INDENT();
			P2OUTS(pszTitle);
			OUTDENT();
		}
		else
		{
			P2OUTC(pmdic, szTitle, DWORD);
		}

		P2OUTC(pmdic, hOwner, DWORD);
		P2TABLEORINT(tblCreateWindowPos, pmdic, x);
		P2TABLEORINT(tblCreateWindowPos, pmdic, y);
		P2TABLEORINT(tblCreateWindowPos, pmdic, cx);
		P2TABLEORINT(tblCreateWindowPos, pmdic, cy);
		P2TABLEFLAGS(tblWindowStyles, pmdic, style);
		P2OUTC(pmdic, lParam, DWORD);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MDIDESTROY)
{
	PARM(hwndChild, HWND, WP);

	POUT(hwndChild);

	return TRUE;
}

NODECODERET(WM_MDIDESTROY);

NODECODEPARM(WM_MDIDESTROY);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MDIGETACTIVE)
{
	PARM(lpfMaximized, LPBOOL, LP);

	POUTC(lpfMaximized, DWORD);

	return TRUE;
}

DECODERET(WM_MDIGETACTIVE)
{
	PARM(hwndActiveChild, HWND, RET);
	PARM(lpfMaximized, LPBOOL, LP);

	POUT(hwndActiveChild);
	POUTC(lpfMaximized, DWORD);
	PIFDATA()
	{
		PARM(fMaximized, LPBOOL, ED);
		POUTPB(fMaximized);
	}

	return TRUE;
}

NODECODEPARM(WM_MDIGETACTIVE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_MDIICONARRANGE);

NODECODERET(WM_MDIICONARRANGE);

NODECODEPARM(WM_MDIICONARRANGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MDIMAXIMIZE)
{
	PARM(hwndMax, HWND, WP);

	POUT(hwndMax);

	return TRUE;
}

NODECODERET(WM_MDIMAXIMIZE);

NODECODEPARM(WM_MDIMAXIMIZE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MDINEXT)
{
	PARM(hwndChild, HWND, WP);
	PARM(fPrev, BOOL, LP);

	POUT(hwndChild);
	POUTB(fPrev);

	return TRUE;
}

NODECODERET(WM_MDINEXT);

NODECODEPARM(WM_MDINEXT);

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_MDIREFRESHMENU);

DECODERET(WM_MDIREFRESHMENU)
{
	PARM(hmenuFrame, HMENU, RET);

	POUTC(hmenuFrame, DWORD);

	return TRUE;
}

NODECODEPARM(WM_MDIREFRESHMENU);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MDIRESTORE)
{
	PARM(hwndRes, HWND, WP);

	POUT(hwndRes);

	return TRUE;
}

NODECODERET(WM_MDIRESTORE);

NODECODEPARM(WM_MDIRESTORE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MDISETMENU)
{
	PARM(hmenuFrame, HMENU, WP);
	PARM(hmenuWindow, HMENU, LP);

	POUTC(hmenuFrame, DWORD);
	POUTC(hmenuWindow, DWORD);

	return TRUE;
}

DECODERET(WM_MDISETMENU)
{
	PARM(hmenuFrameOld, HMENU, RET);

	POUTC(hmenuFrameOld, DWORD);

	return TRUE;
}

NODECODEPARM(WM_MDISETMENU);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MDITILE)
{
	PARM(fuTile, UINT, WP);

	PLABEL(fuTile);
	if (fuTile & MDITILE_HORIZONTAL)
	{
		MOUT << "MDITILE_HORIZONTAL";
	}
	else
	{
		MOUT << "MDITILE_VERTICAL";
	}

	if (fuTile & MDITILE_SKIPDISABLED)
	{
		MOUT << " | MDITILE_SKIPDISABLED";
	}

	return TRUE;
}

DECODERET(WM_MDITILE)
{
	PARM(fSuccess, BOOL, RET);

	POUTB(fSuccess);

	return TRUE;
}

NODECODEPARM(WM_MDITILE);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\met.h ===
// met.h
//
// The message encoding table.  This table has a type code that describes
// what additional work has to be done to grab extra data associated
// with that message and pass to the Spy app.  This is how strings
// and structures that lParam points to gets captured in the current
// process context and passed to Spy++ to display, for example.
//
// The table has been placed in a separate file for readability.
// It is statically initialized so it loads fast, and is in
// shared memory because it is common to all the processes
// that will load the hook DLL.  It is indexed by the message
// number, so be very careful not to add or delete any lines when
// editing it.
//

#ifndef __MET_H__
#define __MET_H__

SPYXXHK_SHDATA MSGENCODETABLE gmet[MAX_MESSAGES] =
{
	{MET_NOEXTRADATA, 0},										// 0x0000 WM_NULL
	{MET_CREATESTRUCTBOTH, sizeof(PACK_CREATESTRUCT)},			// 0x0001 WM_CREATE
	{MET_NOEXTRADATA, 0},										// 0x0002 WM_DESTROY
	{MET_NOEXTRADATA, 0},										// 0x0003 WM_MOVE
	{MET_NOEXTRADATA, 0},										// 0x0004
	{MET_NOEXTRADATA, 0},										// 0x0005 WM_SIZE
	{MET_NOEXTRADATA, 0},										// 0x0006 WM_ACTIVATE
	{MET_NOEXTRADATA, 0},										// 0x0007 WM_SETFOCUS
	{MET_NOEXTRADATA, 0},										// 0x0008 WM_KILLFOCUS
	{MET_NOEXTRADATA, 0},										// 0x0009
	{MET_NOEXTRADATA, 0},										// 0x000A WM_ENABLE
	{MET_NOEXTRADATA, 0},										// 0x000B WM_SETREDRAW
	{MET_STRINGBOTH, 0},										// 0x000C WM_SETTEXT
	{MET_STRINGRET, 0},											// 0x000D WM_GETTEXT
	{MET_NOEXTRADATA, 0},										// 0x000E WM_GETTEXTLENGTH
	{MET_NOEXTRADATA, 0},										// 0x000F WM_PAINT
	{MET_NOEXTRADATA, 0},										// 0x0010 WM_CLOSE
	{MET_NOEXTRADATA, 0},										// 0x0011 WM_QUERYENDSESSION
	{MET_NOEXTRADATA, 0},										// 0x0012 WM_QUIT
	{MET_NOEXTRADATA, 0},										// 0x0013 WM_QUERYOPEN
	{MET_NOEXTRADATA, 0},										// 0x0014 WM_ERASEBKGND
	{MET_NOEXTRADATA, 0},										// 0x0015 WM_SYSCOLORCHANGE
	{MET_NOEXTRADATA, 0},										// 0x0016 WM_ENDSESSION
	{MET_NOEXTRADATA, 0},										// 0x0017
	{MET_NOEXTRADATA, 0},										// 0x0018 WM_SHOWWINDOW
	{MET_NOEXTRADATA, 0},										// 0x0019
	{MET_STRINGBOTH, 0},										// 0x001A WM_WININICHANGE/WM_SETTINGCHANGE
	{MET_NOEXTRADATA, 0},										// 0x001B WM_DEVMODECHANGE
	{MET_NOEXTRADATA, 0},										// 0x001C WM_ACTIVATEAPP
	{MET_NOEXTRADATA, 0},										// 0x001D WM_FONTCHANGE
	{MET_NOEXTRADATA, 0},										// 0x001E WM_TIMECHANGE
	{MET_NOEXTRADATA, 0},										// 0x001F WM_CANCELMODE
	{MET_NOEXTRADATA, 0},										// 0x0020 WM_SETCURSOR
	{MET_NOEXTRADATA, 0},										// 0x0021 WM_MOUSEACTIVATE
	{MET_NOEXTRADATA, 0},										// 0x0022 WM_CHILDACTIVATE
	{MET_NOEXTRADATA, 0},										// 0x0023 WM_QUEUESYNC
	{MET_STRUCTBOTH, sizeof(MINMAXINFO)},						// 0x0024 WM_GETMINMAXINFO
	{MET_NOEXTRADATA, 0},										// 0x0025
	{MET_NOEXTRADATA, 0},										// 0x0026 WM_PAINTICON
	{MET_NOEXTRADATA, 0},										// 0x0027 WM_ICONERASEBKGND
	{MET_NOEXTRADATA, 0},										// 0x0028 WM_NEXTDLGCTL
	{MET_NOEXTRADATA, 0},										// 0x0029
	{MET_NOEXTRADATA, 0},										// 0x002A WM_SPOOLERSTATUS
	{MET_STRUCTBOTH, sizeof(DRAWITEMSTRUCT)},					// 0x002B WM_DRAWITEM
	{MET_STRUCTBOTH, sizeof(MEASUREITEMSTRUCT)},				// 0x002C WM_MEASUREITEM
	{MET_STRUCTBOTH, sizeof(DELETEITEMSTRUCT)},					// 0x002D WM_DELETEITEM
	{MET_NOEXTRADATA, 0},										// 0x002E WM_VKEYTOITEM
	{MET_NOEXTRADATA, 0},										// 0x002F WM_CHARTOITEM
	{MET_FONTBOTH, 0},											// 0x0030 WM_SETFONT
	{MET_FONTRET, 0},											// 0x0031 WM_GETFONT
	{MET_NOEXTRADATA, 0},										// 0x0032 WM_SETHOTKEY
	{MET_NOEXTRADATA, 0},										// 0x0033 WM_GETHOTKEY
	{MET_NOEXTRADATA, 0},										// 0x0034
	{MET_NOEXTRADATA, 0},										// 0x0035
	{MET_NOEXTRADATA, 0},										// 0x0036
	{MET_NOEXTRADATA, 0},										// 0x0037 WM_QUERYDRAGICON
	{MET_NOEXTRADATA, 0},										// 0x0038
	{MET_STRUCTBOTH, sizeof(COMPAREITEMSTRUCT)},				// 0x0039 WM_COMPAREITEM
	{MET_NOEXTRADATA, 0},										// 0x003A
	{MET_NOEXTRADATA, 0},										// 0x003B
	{MET_NOEXTRADATA, 0},										// 0x003C
	{MET_NOEXTRADATA, 0},										// 0x003D
	{MET_NOEXTRADATA, 0},										// 0x003E
	{MET_NOEXTRADATA, 0},										// 0x003F
	{MET_NOEXTRADATA, 0},										// 0x0040
	{MET_NOEXTRADATA, 0},										// 0x0041 WM_COMPACTING
	{MET_NOEXTRADATA, 0},										// 0x0042
	{MET_NOEXTRADATA, 0},										// 0x0043
	{MET_NOEXTRADATA, 0},										// 0x0044 WM_COMMNOTIFY
	{MET_NOEXTRADATA, 0},										// 0x0045
	{MET_STRUCTBOTH, sizeof(WINDOWPOS)},						// 0x0046 WM_WINDOWPOSCHANGING
	{MET_STRUCTBOTH, sizeof(WINDOWPOS)},						// 0x0047 WM_WINDOWPOSCHANGED
	{MET_NOEXTRADATA, 0},										// 0x0048 WM_POWER
	{MET_NOEXTRADATA, 0},										// 0x0049
	{MET_STRUCTBOTH, sizeof(COPYDATASTRUCT)},					// 0x004A WM_COPYDATA
	{MET_NOEXTRADATA, 0},										// 0x004B WM_CANCELJOURNAL
	{MET_NOEXTRADATA, 0},										// 0x004C
	{MET_NOEXTRADATA, 0},										// 0x004D
	{MET_STRUCTBOTH, sizeof(NMHDR)},							// 0x004E WM_NOTIFY
	{MET_NOEXTRADATA, 0},										// 0x004F
	{MET_NOEXTRADATA, 0},										// 0x0050 WM_INPUTLANGCHANGEREQUEST
	{MET_NOEXTRADATA, 0},										// 0x0051 WM_INPUTLANGCHANGE
	{MET_NOEXTRADATA, 0},										// 0x0052 WM_TCARD
	{MET_NOEXTRADATA, 0},										// 0x0053 WM_HELP
	{MET_NOEXTRADATA, 0},										// 0x0054 WM_USERCHANGED
	{MET_NOEXTRADATA, 0},										// 0x0055 WM_NOTIFYFORMAT
	{MET_NOEXTRADATA, 0},										// 0x0056
	{MET_NOEXTRADATA, 0},										// 0x0057
	{MET_NOEXTRADATA, 0},										// 0x0058
	{MET_NOEXTRADATA, 0},										// 0x0059
	{MET_NOEXTRADATA, 0},										// 0x005A
	{MET_NOEXTRADATA, 0},										// 0x005B
	{MET_NOEXTRADATA, 0},										// 0x005C
	{MET_NOEXTRADATA, 0},										// 0x005D
	{MET_NOEXTRADATA, 0},										// 0x005E
	{MET_NOEXTRADATA, 0},										// 0x005F
	{MET_NOEXTRADATA, 0},										// 0x0060
	{MET_NOEXTRADATA, 0},										// 0x0061
	{MET_NOEXTRADATA, 0},										// 0x0062
	{MET_NOEXTRADATA, 0},										// 0x0063
	{MET_NOEXTRADATA, 0},										// 0x0064
	{MET_NOEXTRADATA, 0},										// 0x0065
	{MET_NOEXTRADATA, 0},										// 0x0066
	{MET_NOEXTRADATA, 0},										// 0x0067
	{MET_NOEXTRADATA, 0},										// 0x0068
	{MET_NOEXTRADATA, 0},										// 0x0069
	{MET_NOEXTRADATA, 0},										// 0x006A
	{MET_NOEXTRADATA, 0},										// 0x006B
	{MET_NOEXTRADATA, 0},										// 0x006C
	{MET_NOEXTRADATA, 0},										// 0x006D
	{MET_NOEXTRADATA, 0},										// 0x006E
	{MET_NOEXTRADATA, 0},										// 0x006F
	{MET_NOEXTRADATA, 0},										// 0x0070
	{MET_NOEXTRADATA, 0},										// 0x0071
	{MET_NOEXTRADATA, 0},										// 0x0072
	{MET_NOEXTRADATA, 0},										// 0x0073
	{MET_NOEXTRADATA, 0},										// 0x0074
	{MET_NOEXTRADATA, 0},										// 0x0075
	{MET_NOEXTRADATA, 0},										// 0x0076
	{MET_NOEXTRADATA, 0},										// 0x0077
	{MET_NOEXTRADATA, 0},										// 0x0078
	{MET_NOEXTRADATA, 0},										// 0x0079
	{MET_NOEXTRADATA, 0},										// 0x007A
	{MET_NOEXTRADATA, 0},										// 0x007B WM_CONTEXTMENU
	{MET_NOEXTRADATA, 0},										// 0x007C WM_STYLECHANGING
	{MET_NOEXTRADATA, 0},										// 0x007D WM_STYLECHANGED
	{MET_NOEXTRADATA, 0},										// 0x007E WM_DISPLAYCHANGE
	{MET_NOEXTRADATA, 0},										// 0x007F WM_GETICON
	{MET_NOEXTRADATA, 0},										// 0x0080 WM_SETICON
	{MET_STRUCTBOTH, sizeof(CREATESTRUCT)},						// 0x0081 WM_NCCREATE
	{MET_NOEXTRADATA, 0},										// 0x0082 WM_NCDESTROY
	{MET_WM_NCCALCSIZEBOTH, 0},									// 0x0083 WM_NCCALCSIZE
	{MET_NOEXTRADATA, 0},										// 0x0084 WM_NCHITTEST
	{MET_NOEXTRADATA, 0},										// 0x0085 WM_NCPAINT
	{MET_NOEXTRADATA, 0},										// 0x0086 WM_NCACTIVATE
	{MET_NOEXTRADATA, 0},										// 0x0087 WM_GETDLGCODE
	{MET_NOEXTRADATA, 0},										// 0x0088
	{MET_NOEXTRADATA, 0},										// 0x0089
	{MET_NOEXTRADATA, 0},										// 0x008A
	{MET_NOEXTRADATA, 0},										// 0x008B
	{MET_NOEXTRADATA, 0},										// 0x008C
	{MET_NOEXTRADATA, 0},										// 0x008D
	{MET_NOEXTRADATA, 0},										// 0x008E
	{MET_NOEXTRADATA, 0},										// 0x008F
	{MET_NOEXTRADATA, 0},										// 0x0090
	{MET_NOEXTRADATA, 0},										// 0x0091
	{MET_NOEXTRADATA, 0},										// 0x0092
	{MET_NOEXTRADATA, 0},										// 0x0093
	{MET_NOEXTRADATA, 0},										// 0x0094
	{MET_NOEXTRADATA, 0},										// 0x0095
	{MET_NOEXTRADATA, 0},										// 0x0096
	{MET_NOEXTRADATA, 0},										// 0x0097
	{MET_NOEXTRADATA, 0},										// 0x0098
	{MET_NOEXTRADATA, 0},										// 0x0099
	{MET_NOEXTRADATA, 0},										// 0x009A
	{MET_NOEXTRADATA, 0},										// 0x009B
	{MET_NOEXTRADATA, 0},										// 0x009C
	{MET_NOEXTRADATA, 0},										// 0x009D
	{MET_NOEXTRADATA, 0},										// 0x009E
	{MET_NOEXTRADATA, 0},										// 0x009F
	{MET_NOEXTRADATA, 0},										// 0x00A0 WM_NCMOUSEMOVE
	{MET_NOEXTRADATA, 0},										// 0x00A1 WM_NCLBUTTONDOWN
	{MET_NOEXTRADATA, 0},										// 0x00A2 WM_NCLBUTTONUP
	{MET_NOEXTRADATA, 0},										// 0x00A3 WM_NCLBUTTONDBLCLK
	{MET_NOEXTRADATA, 0},										// 0x00A4 WM_NCRBUTTONDOWN
	{MET_NOEXTRADATA, 0},										// 0x00A5 WM_NCRBUTTONUP
	{MET_NOEXTRADATA, 0},										// 0x00A6 WM_NCRBUTTONDBLCLK
	{MET_NOEXTRADATA, 0},										// 0x00A7 WM_NCMBUTTONDOWN
	{MET_NOEXTRADATA, 0},										// 0x00A8 WM_NCMBUTTONUP
	{MET_NOEXTRADATA, 0},										// 0x00A9 WM_NCMBUTTONDBLCLK
	{MET_NOEXTRADATA, 0},										// 0x00AA
	{MET_NOEXTRADATA, 0},										// 0x00AB
	{MET_NOEXTRADATA, 0},										// 0x00AC
	{MET_NOEXTRADATA, 0},										// 0x00AD
	{MET_NOEXTRADATA, 0},										// 0x00AE
	{MET_NOEXTRADATA, 0},										// 0x00AF
	{MET_WPLPDWORDSRET, 0},										// 0x00B0 EM_GETSEL
	{MET_NOEXTRADATA, 0},										// 0x00B1 EM_SETSEL
	{MET_STRUCTRET, sizeof(RECT)},								// 0x00B2 EM_GETRECT
	{MET_NOEXTRADATA, 0},										// 0x00B3 EM_SETRECT
	{MET_NOEXTRADATA, 0},										// 0x00B4 EM_SETRECTNP
	{MET_NOEXTRADATA, 0},										// 0x00B5 EM_SCROLL
	{MET_NOEXTRADATA, 0},										// 0x00B6 EM_LINESCROLL
	{MET_NOEXTRADATA, 0},										// 0x00B7 EM_SCROLLCARET
	{MET_NOEXTRADATA, 0},										// 0x00B8 EM_GETMODIFY
	{MET_NOEXTRADATA, 0},										// 0x00B9 EM_SETMODIFY
	{MET_NOEXTRADATA, 0},										// 0x00BA EM_GETLINECOUNT
	{MET_NOEXTRADATA, 0},										// 0x00BB EM_LINEINDEX
	{MET_NOEXTRADATA, 0},										// 0x00BC EM_SETHANDLE
	{MET_NOEXTRADATA, 0},										// 0x00BD EM_GETHANDLE
	{MET_NOEXTRADATA, 0},										// 0x00BE EM_GETTHUMB
	{MET_NOEXTRADATA, 0},										// 0x00BF
	{MET_NOEXTRADATA, 0},										// 0x00C0
	{MET_NOEXTRADATA, 0},										// 0x00C1 EM_LINELENGTH
	{MET_STRINGBOTH, 0},										// 0x00C2 EM_REPLACESEL
	{MET_NOEXTRADATA, 0},										// 0x00C3
	{MET_EM_GETLINE, 0},										// 0x00C4 EM_GETLINE
	{MET_NOEXTRADATA, 0},										// 0x00C5 EM_LIMITTEXT
	{MET_NOEXTRADATA, 0},										// 0x00C6 EM_CANUNDO
	{MET_NOEXTRADATA, 0},										// 0x00C7 EM_UNDO
	{MET_NOEXTRADATA, 0},										// 0x00C8 EM_FMTLINES
	{MET_NOEXTRADATA, 0},										// 0x00C9 EM_LINEFROMCHAR
	{MET_NOEXTRADATA, 0},										// 0x00CA
	{MET_INTARRAYBOTH, 0},										// 0x00CB EM_SETTABSTOPS
	{MET_NOEXTRADATA, 0},										// 0x00CC EM_SETPASSWORDCHAR
	{MET_NOEXTRADATA, 0},										// 0x00CD EM_EMPTYUNDOBUFFER
	{MET_NOEXTRADATA, 0},										// 0x00CE EM_GETFIRSTVISIBLELINE
	{MET_NOEXTRADATA, 0},										// 0x00CF EM_SETREADONLY
	{MET_NOEXTRADATA, 0},										// 0x00D0 EM_SETWORDBREAKPROC
	{MET_NOEXTRADATA, 0},										// 0x00D1 EM_GETWORDBREAKPROC
	{MET_NOEXTRADATA, 0},										// 0x00D2 EM_GETPASSWORDCHAR
	{MET_NOEXTRADATA, 0},										// 0x00D3
	{MET_NOEXTRADATA, 0},										// 0x00D4
	{MET_NOEXTRADATA, 0},										// 0x00D5
	{MET_NOEXTRADATA, 0},										// 0x00D6
	{MET_NOEXTRADATA, 0},										// 0x00D7
	{MET_NOEXTRADATA, 0},										// 0x00D8
	{MET_NOEXTRADATA, 0},										// 0x00D9
	{MET_NOEXTRADATA, 0},										// 0x00DA
	{MET_NOEXTRADATA, 0},										// 0x00DB
	{MET_NOEXTRADATA, 0},										// 0x00DC
	{MET_NOEXTRADATA, 0},										// 0x00DD
	{MET_NOEXTRADATA, 0},										// 0x00DE
	{MET_NOEXTRADATA, 0},										// 0x00DF
	{MET_NOEXTRADATA, 0},										// 0x00E0 SBM_SETPOS
	{MET_NOEXTRADATA, 0},										// 0x00E1 SBM_GETPOS
	{MET_NOEXTRADATA, 0},										// 0x00E2 SBM_SETRANGE
	{MET_WPLPDWORDSRET, 0},										// 0x00E3 SBM_GETRANGE
	{MET_NOEXTRADATA, 0},										// 0x00E4 SBM_ENABLEARROWS
	{MET_NOEXTRADATA, 0},										// 0x00E5
	{MET_NOEXTRADATA, 0},										// 0x00E6 SBM_SETRANGEREDRAW
	{MET_NOEXTRADATA, 0},										// 0x00E7
	{MET_NOEXTRADATA, 0},										// 0x00E8
	{MET_NOEXTRADATA, 0},										// 0x00E9
	{MET_NOEXTRADATA, 0},										// 0x00EA
	{MET_NOEXTRADATA, 0},										// 0x00EB
	{MET_NOEXTRADATA, 0},										// 0x00EC
	{MET_NOEXTRADATA, 0},										// 0x00ED
	{MET_NOEXTRADATA, 0},										// 0x00EE
	{MET_NOEXTRADATA, 0},										// 0x00EF
	{MET_NOEXTRADATA, 0},										// 0x00F0 BM_GETCHECK
	{MET_NOEXTRADATA, 0},										// 0x00F1 BM_SETCHECK
	{MET_NOEXTRADATA, 0},										// 0x00F2 BM_GETSTATE
	{MET_NOEXTRADATA, 0},										// 0x00F3 BM_SETSTATE
	{MET_NOEXTRADATA, 0},										// 0x00F4 BM_SETSTYLE
	{MET_NOEXTRADATA, 0},										// 0x00F5
	{MET_NOEXTRADATA, 0},										// 0x00F6
	{MET_NOEXTRADATA, 0},										// 0x00F7
	{MET_NOEXTRADATA, 0},										// 0x00F8
	{MET_NOEXTRADATA, 0},										// 0x00F9
	{MET_NOEXTRADATA, 0},										// 0x00FA
	{MET_NOEXTRADATA, 0},										// 0x00FB
	{MET_NOEXTRADATA, 0},										// 0x00FC
	{MET_NOEXTRADATA, 0},										// 0x00FD
	{MET_NOEXTRADATA, 0},										// 0x00FE
	{MET_NOEXTRADATA, 0},										// 0x00FF
	{MET_NOEXTRADATA, 0},										// 0x0100 WM_KEYDOWN
	{MET_NOEXTRADATA, 0},										// 0x0101 WM_KEYUP
	{MET_NOEXTRADATA, 0},										// 0x0102 WM_CHAR
	{MET_NOEXTRADATA, 0},										// 0x0103 WM_DEADCHAR
	{MET_NOEXTRADATA, 0},										// 0x0104 WM_SYSKEYDOWN
	{MET_NOEXTRADATA, 0},										// 0x0105 WM_SYSKEYUP
	{MET_NOEXTRADATA, 0},										// 0x0106 WM_SYSCHAR
	{MET_NOEXTRADATA, 0},										// 0x0107 WM_SYSDEADCHAR
	{MET_NOEXTRADATA, 0},										// 0x0108
	{MET_NOEXTRADATA, 0},										// 0x0109
	{MET_NOEXTRADATA, 0},										// 0x010A
	{MET_NOEXTRADATA, 0},										// 0x010B
	{MET_NOEXTRADATA, 0},										// 0x010C
	{MET_NOEXTRADATA, 0},										// 0x010D WM_IME_STARTCOMPOSITION
	{MET_NOEXTRADATA, 0},										// 0x010E WM_IME_ENDCOMPOSITION
	{MET_NOEXTRADATA, 0},										// 0x010F WM_IME_COMPOSITION
	{MET_NOEXTRADATA, 0},										// 0x0110 WM_INITDIALOG
	{MET_CLASSBOTH, 0},											// 0x0111 WM_COMMAND
	{MET_NOEXTRADATA, 0},										// 0x0112 WM_SYSCOMMAND
	{MET_NOEXTRADATA, 0},										// 0x0113 WM_TIMER
	{MET_NOEXTRADATA, 0},										// 0x0114 WM_HSCROLL
	{MET_NOEXTRADATA, 0},										// 0x0115 WM_VSCROLL
	{MET_NOEXTRADATA, 0},										// 0x0116 WM_INITMENU
	{MET_NOEXTRADATA, 0},										// 0x0117 WM_INITMENUPOPUP
	{MET_NOEXTRADATA, 0},										// 0x0118
	{MET_NOEXTRADATA, 0},										// 0x0119
	{MET_NOEXTRADATA, 0},										// 0x011A
	{MET_NOEXTRADATA, 0},										// 0x011B
	{MET_NOEXTRADATA, 0},										// 0x011C
	{MET_NOEXTRADATA, 0},										// 0x011D
	{MET_NOEXTRADATA, 0},										// 0x011E
	{MET_NOEXTRADATA, 0},										// 0x011F WM_MENUSELECT
	{MET_NOEXTRADATA, 0},										// 0x0120 WM_MENUCHAR
	{MET_NOEXTRADATA, 0},										// 0x0121 WM_ENTERIDLE
	{MET_NOEXTRADATA, 0},										// 0x0122
	{MET_NOEXTRADATA, 0},										// 0x0123
	{MET_NOEXTRADATA, 0},										// 0x0124
	{MET_NOEXTRADATA, 0},										// 0x0125
	{MET_NOEXTRADATA, 0},										// 0x0126
	{MET_NOEXTRADATA, 0},										// 0x0127
	{MET_NOEXTRADATA, 0},										// 0x0128
	{MET_NOEXTRADATA, 0},										// 0x0129
	{MET_NOEXTRADATA, 0},										// 0x012A
	{MET_NOEXTRADATA, 0},										// 0x012B
	{MET_NOEXTRADATA, 0},										// 0x012C
	{MET_NOEXTRADATA, 0},										// 0x012D
	{MET_NOEXTRADATA, 0},										// 0x012E
	{MET_NOEXTRADATA, 0},										// 0x012F
	{MET_NOEXTRADATA, 0},										// 0x0130
	{MET_NOEXTRADATA, 0},										// 0x0131
	{MET_NOEXTRADATA, 0},										// 0x0132 WM_CTLCOLORMSGBOX
	{MET_NOEXTRADATA, 0},										// 0x0133 WM_CTLCOLOREDIT
	{MET_NOEXTRADATA, 0},										// 0x0134 WM_CTLCOLORLISTBOX
	{MET_NOEXTRADATA, 0},										// 0x0135 WM_CTLCOLORBTN
	{MET_NOEXTRADATA, 0},										// 0x0136 WM_CTLCOLORDLG
	{MET_NOEXTRADATA, 0},										// 0x0137 WM_CTLCOLORSCROLLBAR
	{MET_NOEXTRADATA, 0},										// 0x0138 WM_CTLCOLORSTATIC
	{MET_NOEXTRADATA, 0},										// 0x0139
	{MET_NOEXTRADATA, 0},										// 0x013A
	{MET_NOEXTRADATA, 0},										// 0x013B
	{MET_NOEXTRADATA, 0},										// 0x013C
	{MET_NOEXTRADATA, 0},										// 0x013D
	{MET_NOEXTRADATA, 0},										// 0x013E
	{MET_NOEXTRADATA, 0},										// 0x013F
	{MET_WPLPDWORDSRET, 0},										// 0x0140 CB_GETEDITSEL
	{MET_NOEXTRADATA, 0},										// 0x0141 CB_LIMITTEXT
	{MET_NOEXTRADATA, 0},										// 0x0142 CB_SETEDITSEL
	{MET_CBODSTRINGBOTH, 0},									// 0x0143 CB_ADDSTRING 
	{MET_NOEXTRADATA, 0},										// 0x0144 CB_DELETESTRING
	{MET_CBODSTRINGBOTH, 0},									// 0x0145 CB_DIR
	{MET_NOEXTRADATA, 0},										// 0x0146 CB_GETCOUNT
	{MET_NOEXTRADATA, 0},										// 0x0147 CB_GETCURSEL
	{MET_CBSTRINGORDRET, 0},									// 0x0148 CB_GETLBTEXT
	{MET_NOEXTRADATA, 0},										// 0x0149 CB_GETLBTEXTLEN
	{MET_CBODSTRINGBOTH, 0},									// 0x014A CB_INSERTSTRING
	{MET_NOEXTRADATA, 0},										// 0x014B CB_RESETCONTENT
	{MET_CBODSTRINGBOTH, 0},									// 0x014C CB_FINDSTRING
	{MET_CBODSTRINGBOTH, 0},									// 0x014D CB_SELECTSTRING
	{MET_NOEXTRADATA, 0},										// 0x014E CB_SETCURSEL
	{MET_NOEXTRADATA, 0},										// 0x014F CB_SHOWDROPDOWN
	{MET_NOEXTRADATA, 0},										// 0x0150 CB_GETITEMDATA
	{MET_NOEXTRADATA, 0},										// 0x0151 CB_SETITEMDATA
	{MET_STRUCTRET, sizeof(RECT)},								// 0x0152 CB_GETDROPPEDCONTROLRECT
	{MET_NOEXTRADATA, 0},										// 0x0153 CB_SETITEMHEIGHT
	{MET_NOEXTRADATA, 0},										// 0x0154 CB_GETITEMHEIGHT
	{MET_NOEXTRADATA, 0},										// 0x0155 CB_SETEXTENDEDUI
	{MET_NOEXTRADATA, 0},										// 0x0156 CB_GETEXTENDEDUI
	{MET_NOEXTRADATA, 0},										// 0x0157 CB_GETDROPPEDSTATE
	{MET_CBODSTRINGBOTH, 0},									// 0x0158 CB_FINDSTRINGEXACT
	{MET_NOEXTRADATA, 0},										// 0x0159 CB_SETLOCALE
	{MET_NOEXTRADATA, 0},										// 0x015A CB_GETLOCALE
	{MET_NOEXTRADATA, 0},										// 0x015B CB_MSGMAX
	{MET_NOEXTRADATA, 0},										// 0x015C
	{MET_NOEXTRADATA, 0},										// 0x015D
	{MET_NOEXTRADATA, 0},										// 0x015E
	{MET_NOEXTRADATA, 0},										// 0x015F
	{MET_NOEXTRADATA, 0},										// 0x0160
	{MET_NOEXTRADATA, 0},										// 0x0161
	{MET_NOEXTRADATA, 0},										// 0x0162
	{MET_NOEXTRADATA, 0},										// 0x0163
	{MET_NOEXTRADATA, 0},										// 0x0164
	{MET_NOEXTRADATA, 0},										// 0x0165
	{MET_NOEXTRADATA, 0},										// 0x0166
	{MET_NOEXTRADATA, 0},										// 0x0167
	{MET_NOEXTRADATA, 0},										// 0x0168
	{MET_NOEXTRADATA, 0},										// 0x0169
	{MET_NOEXTRADATA, 0},										// 0x016A
	{MET_NOEXTRADATA, 0},										// 0x016B
	{MET_NOEXTRADATA, 0},										// 0x016C
	{MET_NOEXTRADATA, 0},										// 0x016D
	{MET_NOEXTRADATA, 0},										// 0x016E
	{MET_NOEXTRADATA, 0},										// 0x016F
	{MET_NOEXTRADATA, 0},										// 0x0170 STM_SETICON
	{MET_NOEXTRADATA, 0},										// 0x0171 STM_GETICON
	{MET_NOEXTRADATA, 0},										// 0x0172 STM_MSGMAX
	{MET_NOEXTRADATA, 0},										// 0x0173
	{MET_NOEXTRADATA, 0},										// 0x0174
	{MET_NOEXTRADATA, 0},										// 0x0175
	{MET_NOEXTRADATA, 0},										// 0x0176
	{MET_NOEXTRADATA, 0},										// 0x0177
	{MET_NOEXTRADATA, 0},										// 0x0178
	{MET_NOEXTRADATA, 0},										// 0x0179
	{MET_NOEXTRADATA, 0},										// 0x017A
	{MET_NOEXTRADATA, 0},										// 0x017B
	{MET_NOEXTRADATA, 0},										// 0x017C
	{MET_NOEXTRADATA, 0},										// 0x017D
	{MET_NOEXTRADATA, 0},										// 0x017E
	{MET_NOEXTRADATA, 0},										// 0x017F
	{MET_LBODSTRINGBOTH, 0},									// 0x0180 LB_ADDSTRING
	{MET_LBODSTRINGBOTH, 0},									// 0x0181 LB_INSERTSTRING
	{MET_NOEXTRADATA, 0},										// 0x0182 LB_DELETESTRING
	{MET_NOEXTRADATA, 0},										// 0x0183 LB_SELITEMRANGEEX
	{MET_NOEXTRADATA, 0},										// 0x0184 LB_RESETCONTENT
	{MET_NOEXTRADATA, 0},										// 0x0185 LB_SETSEL
	{MET_NOEXTRADATA, 0},										// 0x0186 LB_SETCURSEL
	{MET_NOEXTRADATA, 0},										// 0x0187 LB_GETSEL
	{MET_NOEXTRADATA, 0},										// 0x0188 LB_GETCURSEL
	{MET_LBSTRINGORDRET, 0},									// 0x0189 LB_GETTEXT
	{MET_NOEXTRADATA, 0},										// 0x018A LB_GETTEXLEN
	{MET_NOEXTRADATA, 0},										// 0x018B LB_GETCOUNT
	{MET_LBODSTRINGBOTH, 0},									// 0x018C LB_SELECTSTRING
	{MET_STRINGBOTH, 0},										// 0x018D LB_DIR
	{MET_NOEXTRADATA, 0},										// 0x018E LB_GETTOPINDEX
	{MET_LBODSTRINGBOTH, 0},									// 0x018F LB_FINDSTRING
	{MET_NOEXTRADATA, 0},										// 0x0190 LB_GETSELCOUNT
	{MET_INTARRAYRET, 0},										// 0x0191 LB_GETSELITEMS
	{MET_INTARRAYBOTH, 0},										// 0x0192 LB_SETTABSTOPS
	{MET_NOEXTRADATA, 0},										// 0x0193 LB_GETHORIZONTALEXTENT
	{MET_NOEXTRADATA, 0},										// 0x0194 LB_SETHORIZONTALEXTENT
	{MET_NOEXTRADATA, 0},										// 0x0195 LB_SETCOLUMNWIDTH
	{MET_STRINGBOTH, 0},										// 0x0196 LB_ADDFILE
	{MET_NOEXTRADATA, 0},										// 0x0197 LB_SETTOPINDEX
	{MET_STRUCTRET, sizeof(RECT)},								// 0x0198 LB_GETITEMRECT
	{MET_NOEXTRADATA, 0},										// 0x0199 LB_GETITEMDATA
	{MET_NOEXTRADATA, 0},										// 0x019A LB_SETITEMDATA
	{MET_NOEXTRADATA, 0},										// 0x019B LB_SELITEMRANGE
	{MET_NOEXTRADATA, 0},										// 0x019C LB_SETANCHORINDEX
	{MET_NOEXTRADATA, 0},										// 0x019D LB_GETANCHORINDEX
	{MET_NOEXTRADATA, 0},										// 0x019E LB_SETCARETINDEX
	{MET_NOEXTRADATA, 0},										// 0x019F LB_GETCARETINDEX
	{MET_NOEXTRADATA, 0},										// 0x01A0 LB_SETITEMHEIGHT
	{MET_NOEXTRADATA, 0},										// 0x01A1 LB_GETITEMHEIGHT
	{MET_LBODSTRINGBOTH, 0},									// 0x01A2 LB_FINDSTRINGEXACT
	{MET_NOEXTRADATA, 0},										// 0x01A3
	{MET_NOEXTRADATA, 0},										// 0x01A4
	{MET_NOEXTRADATA, 0},										// 0x01A5 LB_SETLOCALE
	{MET_NOEXTRADATA, 0},										// 0x01A6 LB_GETLOCALE
	{MET_NOEXTRADATA, 0},										// 0x01A7 LB_SETCOUNT
	{MET_NOEXTRADATA, 0},										// 0x01A8 LB_MSGMAX
	{MET_NOEXTRADATA, 0},										// 0x01A9
	{MET_NOEXTRADATA, 0},										// 0x01AA
	{MET_NOEXTRADATA, 0},										// 0x01AB
	{MET_NOEXTRADATA, 0},										// 0x01AC
	{MET_NOEXTRADATA, 0},										// 0x01AD
	{MET_NOEXTRADATA, 0},										// 0x01AE
	{MET_NOEXTRADATA, 0},										// 0x01AF
	{MET_NOEXTRADATA, 0},										// 0x01B0
	{MET_NOEXTRADATA, 0},										// 0x01B1
	{MET_NOEXTRADATA, 0},										// 0x01B2
	{MET_NOEXTRADATA, 0},										// 0x01B3
	{MET_NOEXTRADATA, 0},										// 0x01B4
	{MET_NOEXTRADATA, 0},										// 0x01B5
	{MET_NOEXTRADATA, 0},										// 0x01B6
	{MET_NOEXTRADATA, 0},										// 0x01B7
	{MET_NOEXTRADATA, 0},										// 0x01B8
	{MET_NOEXTRADATA, 0},										// 0x01B9
	{MET_NOEXTRADATA, 0},										// 0x01BA
	{MET_NOEXTRADATA, 0},										// 0x01BB
	{MET_NOEXTRADATA, 0},										// 0x01BC
	{MET_NOEXTRADATA, 0},										// 0x01BD
	{MET_NOEXTRADATA, 0},										// 0x01BE
	{MET_NOEXTRADATA, 0},										// 0x01BF
	{MET_NOEXTRADATA, 0},										// 0x01C0
	{MET_NOEXTRADATA, 0},										// 0x01C1
	{MET_NOEXTRADATA, 0},										// 0x01C2
	{MET_NOEXTRADATA, 0},										// 0x01C3
	{MET_NOEXTRADATA, 0},										// 0x01C4
	{MET_NOEXTRADATA, 0},										// 0x01C5
	{MET_NOEXTRADATA, 0},										// 0x01C6
	{MET_NOEXTRADATA, 0},										// 0x01C7
	{MET_NOEXTRADATA, 0},										// 0x01C8
	{MET_NOEXTRADATA, 0},										// 0x01C9
	{MET_NOEXTRADATA, 0},										// 0x01CA
	{MET_NOEXTRADATA, 0},										// 0x01CB
	{MET_NOEXTRADATA, 0},										// 0x01CC
	{MET_NOEXTRADATA, 0},										// 0x01CD
	{MET_NOEXTRADATA, 0},										// 0x01CE
	{MET_NOEXTRADATA, 0},										// 0x01CF
	{MET_NOEXTRADATA, 0},										// 0x01D0
	{MET_NOEXTRADATA, 0},										// 0x01D1
	{MET_NOEXTRADATA, 0},										// 0x01D2
	{MET_NOEXTRADATA, 0},										// 0x01D3
	{MET_NOEXTRADATA, 0},										// 0x01D4
	{MET_NOEXTRADATA, 0},										// 0x01D5
	{MET_NOEXTRADATA, 0},										// 0x01D6
	{MET_NOEXTRADATA, 0},										// 0x01D7
	{MET_NOEXTRADATA, 0},										// 0x01D8
	{MET_NOEXTRADATA, 0},										// 0x01D9
	{MET_NOEXTRADATA, 0},										// 0x01DA
	{MET_NOEXTRADATA, 0},										// 0x01DB
	{MET_NOEXTRADATA, 0},										// 0x01DC
	{MET_NOEXTRADATA, 0},										// 0x01DD
	{MET_NOEXTRADATA, 0},										// 0x01DE
	{MET_NOEXTRADATA, 0},										// 0x01DF
	{MET_NOEXTRADATA, 0},										// 0x01E0
	{MET_NOEXTRADATA, 0},										// 0x01E1
	{MET_NOEXTRADATA, 0},										// 0x01E2
	{MET_NOEXTRADATA, 0},										// 0x01E3
	{MET_NOEXTRADATA, 0},										// 0x01E4
	{MET_NOEXTRADATA, 0},										// 0x01E5
	{MET_NOEXTRADATA, 0},										// 0x01E6
	{MET_NOEXTRADATA, 0},										// 0x01E7
	{MET_NOEXTRADATA, 0},										// 0x01E8
	{MET_NOEXTRADATA, 0},										// 0x01E9
	{MET_NOEXTRADATA, 0},										// 0x01EA
	{MET_NOEXTRADATA, 0},										// 0x01EB
	{MET_NOEXTRADATA, 0},										// 0x01EC
	{MET_NOEXTRADATA, 0},										// 0x01ED
	{MET_NOEXTRADATA, 0},										// 0x01EE
	{MET_NOEXTRADATA, 0},										// 0x01EF
	{MET_NOEXTRADATA, 0},										// 0x01F0
	{MET_NOEXTRADATA, 0},										// 0x01F1
	{MET_NOEXTRADATA, 0},										// 0x01F2
	{MET_NOEXTRADATA, 0},										// 0x01F3
	{MET_NOEXTRADATA, 0},										// 0x01F4
	{MET_NOEXTRADATA, 0},										// 0x01F5
	{MET_NOEXTRADATA, 0},										// 0x01F6
	{MET_NOEXTRADATA, 0},										// 0x01F7
	{MET_NOEXTRADATA, 0},										// 0x01F8
	{MET_NOEXTRADATA, 0},										// 0x01F9
	{MET_NOEXTRADATA, 0},										// 0x01FA
	{MET_NOEXTRADATA, 0},										// 0x01FB
	{MET_NOEXTRADATA, 0},										// 0x01FC
	{MET_NOEXTRADATA, 0},										// 0x01FD
	{MET_NOEXTRADATA, 0},										// 0x01FE
	{MET_NOEXTRADATA, 0},										// 0x01FF
	{MET_NOEXTRADATA, 0},										// 0x0200 WM_MOUSEMOVE
	{MET_NOEXTRADATA, 0},										// 0x0201 WM_LBUTTONDOWN
	{MET_NOEXTRADATA, 0},										// 0x0202 WM_LBUTTONUP
	{MET_NOEXTRADATA, 0},										// 0x0203 WM_LBUTTONDBLCLK
	{MET_NOEXTRADATA, 0},										// 0x0204 WM_RBUTTONDOWN
	{MET_NOEXTRADATA, 0},										// 0x0205 WM_RBUTTONUP
	{MET_NOEXTRADATA, 0},										// 0x0206 WM_RBUTTONDBLCLK
	{MET_NOEXTRADATA, 0},										// 0x0207 WM_MBUTTONDOWN
	{MET_NOEXTRADATA, 0},										// 0x0208 WM_MBUTTONUP
	{MET_NOEXTRADATA, 0},										// 0x0209 WM_MBUTTONDBLCLK
	{MET_NOEXTRADATA, 0},										// 0x020A
	{MET_NOEXTRADATA, 0},										// 0x020B
	{MET_NOEXTRADATA, 0},										// 0x020C
	{MET_NOEXTRADATA, 0},										// 0x020D
	{MET_NOEXTRADATA, 0},										// 0x020E
	{MET_NOEXTRADATA, 0},										// 0x020F
	{MET_NOEXTRADATA, 0},										// 0x0210 WM_PARENTNOTIFY
	{MET_NOEXTRADATA, 0},										// 0x0211 WM_ENTERMENULOOP
	{MET_NOEXTRADATA, 0},										// 0x0212 WM_EXITMENULOOP
	{MET_NOEXTRADATA, 0},										// 0x0213 WM_NEXTMENU
	{MET_NOEXTRADATA, 0},										// 0x0214 WM_SIZING
	{MET_NOEXTRADATA, 0},										// 0x0215 WM_CAPTURECHANGED
	{MET_NOEXTRADATA, 0},										// 0x0216 WM_MOVING
	{MET_NOEXTRADATA, 0},										// 0x0217
	{MET_NOEXTRADATA, 0},										// 0x0218 WM_POWERBROADCAST
	{MET_NOEXTRADATA, 0},										// 0x0219 WM_DEVICECHANGE
	{MET_NOEXTRADATA, 0},										// 0x021A
	{MET_NOEXTRADATA, 0},										// 0x021B
	{MET_NOEXTRADATA, 0},										// 0x021C
	{MET_NOEXTRADATA, 0},										// 0x021D
	{MET_NOEXTRADATA, 0},										// 0x021E
	{MET_NOEXTRADATA, 0},										// 0x021F
	{MET_MDICREATESTRUCTBOTH, sizeof(PACK_MDICREATESTRUCT)},	// 0x0220 WM_MDICREATE 
	{MET_NOEXTRADATA, 0},										// 0x0221 WM_MDIDESTROY
	{MET_CLASSBOTH, 0},											// 0x0222 WM_MDIACTIVATE
	{MET_NOEXTRADATA, 0},										// 0x0223 WM_MDIRESTORE
	{MET_NOEXTRADATA, 0},										// 0x0224 WM_MDINEXT
	{MET_NOEXTRADATA, 0},										// 0x0225 WM_MDIMAXIMIZE
	{MET_NOEXTRADATA, 0},										// 0x0226 WM_MDITILE
	{MET_NOEXTRADATA, 0},										// 0x0227 WM_MDICASCADE
	{MET_NOEXTRADATA, 0},										// 0x0228 WM_MDIICONARRANGE
	{MET_STRUCTRET, sizeof(BOOL)},								// 0x0229 WM_MDIGETACTIVE
	{MET_NOEXTRADATA, 0},										// 0x022A
	{MET_NOEXTRADATA, 0},										// 0x022B
	{MET_NOEXTRADATA, 0},										// 0x022C
	{MET_NOEXTRADATA, 0},										// 0x022D
	{MET_NOEXTRADATA, 0},										// 0x022E
	{MET_NOEXTRADATA, 0},										// 0x022F
	{MET_NOEXTRADATA, 0},										// 0x0230 WM_MDISETMENU
	{MET_NOEXTRADATA, 0},										// 0x0231
	{MET_NOEXTRADATA, 0},										// 0x0232
	{MET_NOEXTRADATA, 0},										// 0x0233 WM_DROPFILES
	{MET_NOEXTRADATA, 0},										// 0x0234 WM_MDIREFRESHMENU
	{MET_NOEXTRADATA, 0},										// 0x0235
	{MET_NOEXTRADATA, 0},										// 0x0236
	{MET_NOEXTRADATA, 0},										// 0x0237
	{MET_NOEXTRADATA, 0},										// 0x0238
	{MET_NOEXTRADATA, 0},										// 0x0239
	{MET_NOEXTRADATA, 0},										// 0x023A
	{MET_NOEXTRADATA, 0},										// 0x023B
	{MET_NOEXTRADATA, 0},										// 0x023C
	{MET_NOEXTRADATA, 0},										// 0x023D
	{MET_NOEXTRADATA, 0},										// 0x023E
	{MET_NOEXTRADATA, 0},										// 0x023F
	{MET_NOEXTRADATA, 0},										// 0x0240
	{MET_NOEXTRADATA, 0},										// 0x0241
	{MET_NOEXTRADATA, 0},										// 0x0242
	{MET_NOEXTRADATA, 0},										// 0x0243
	{MET_NOEXTRADATA, 0},										// 0x0244
	{MET_NOEXTRADATA, 0},										// 0x0245
	{MET_NOEXTRADATA, 0},										// 0x0246
	{MET_NOEXTRADATA, 0},										// 0x0247
	{MET_NOEXTRADATA, 0},										// 0x0248
	{MET_NOEXTRADATA, 0},										// 0x0249
	{MET_NOEXTRADATA, 0},										// 0x024A
	{MET_NOEXTRADATA, 0},										// 0x024B
	{MET_NOEXTRADATA, 0},										// 0x024C
	{MET_NOEXTRADATA, 0},										// 0x024D
	{MET_NOEXTRADATA, 0},										// 0x024E
	{MET_NOEXTRADATA, 0},										// 0x024F
	{MET_NOEXTRADATA, 0},										// 0x0250
	{MET_NOEXTRADATA, 0},										// 0x0251
	{MET_NOEXTRADATA, 0},										// 0x0252
	{MET_NOEXTRADATA, 0},										// 0x0253
	{MET_NOEXTRADATA, 0},										// 0x0254
	{MET_NOEXTRADATA, 0},										// 0x0255
	{MET_NOEXTRADATA, 0},										// 0x0256
	{MET_NOEXTRADATA, 0},										// 0x0257
	{MET_NOEXTRADATA, 0},										// 0x0258
	{MET_NOEXTRADATA, 0},										// 0x0259
	{MET_NOEXTRADATA, 0},										// 0x025A
	{MET_NOEXTRADATA, 0},										// 0x025B
	{MET_NOEXTRADATA, 0},										// 0x025C
	{MET_NOEXTRADATA, 0},										// 0x025D
	{MET_NOEXTRADATA, 0},										// 0x025E
	{MET_NOEXTRADATA, 0},										// 0x025F
	{MET_NOEXTRADATA, 0},										// 0x0260
	{MET_NOEXTRADATA, 0},										// 0x0261
	{MET_NOEXTRADATA, 0},										// 0x0262
	{MET_NOEXTRADATA, 0},										// 0x0263
	{MET_NOEXTRADATA, 0},										// 0x0264
	{MET_NOEXTRADATA, 0},										// 0x0265
	{MET_NOEXTRADATA, 0},										// 0x0266
	{MET_NOEXTRADATA, 0},										// 0x0267
	{MET_NOEXTRADATA, 0},										// 0x0268
	{MET_NOEXTRADATA, 0},										// 0x0269
	{MET_NOEXTRADATA, 0},										// 0x026A
	{MET_NOEXTRADATA, 0},										// 0x026B
	{MET_NOEXTRADATA, 0},										// 0x026C
	{MET_NOEXTRADATA, 0},										// 0x026D
	{MET_NOEXTRADATA, 0},										// 0x026E
	{MET_NOEXTRADATA, 0},										// 0x026F
	{MET_NOEXTRADATA, 0},										// 0x0270
	{MET_NOEXTRADATA, 0},										// 0x0271
	{MET_NOEXTRADATA, 0},										// 0x0272
	{MET_NOEXTRADATA, 0},										// 0x0273
	{MET_NOEXTRADATA, 0},										// 0x0274
	{MET_NOEXTRADATA, 0},										// 0x0275
	{MET_NOEXTRADATA, 0},										// 0x0276
	{MET_NOEXTRADATA, 0},										// 0x0277
	{MET_NOEXTRADATA, 0},										// 0x0278
	{MET_NOEXTRADATA, 0},										// 0x0279
	{MET_NOEXTRADATA, 0},										// 0x027A
	{MET_NOEXTRADATA, 0},										// 0x027B
	{MET_NOEXTRADATA, 0},										// 0x027C
	{MET_NOEXTRADATA, 0},										// 0x027D
	{MET_NOEXTRADATA, 0},										// 0x027E
	{MET_NOEXTRADATA, 0},										// 0x027F
	{MET_NOEXTRADATA, 0},										// 0x0280
	{MET_NOEXTRADATA, 0},										// 0x0281 WM_IME_SETCONTEXT
	{MET_NOEXTRADATA, 0},										// 0x0282 WM_IME_NOTIFY
	{MET_NOEXTRADATA, 0},										// 0x0283 WM_IME_CONTROL
	{MET_NOEXTRADATA, 0},										// 0x0284 WM_IME_COMPOSITIONFULL
	{MET_NOEXTRADATA, 0},										// 0x0285 WM_IME_SELECT
	{MET_NOEXTRADATA, 0},										// 0x0286 WM_IME_CHAR
	{MET_NOEXTRADATA, 0},										// 0x0287
	{MET_NOEXTRADATA, 0},										// 0x0288
	{MET_NOEXTRADATA, 0},										// 0x0289
	{MET_NOEXTRADATA, 0},										// 0x028A
	{MET_NOEXTRADATA, 0},										// 0x028B
	{MET_NOEXTRADATA, 0},										// 0x028C
	{MET_NOEXTRADATA, 0},										// 0x028D
	{MET_NOEXTRADATA, 0},										// 0x028E
	{MET_NOEXTRADATA, 0},										// 0x028F
	{MET_NOEXTRADATA, 0},										// 0x0290 WM_IME_KEYDOWN
	{MET_NOEXTRADATA, 0},										// 0x0291 WM_IME_KEYUP
	{MET_NOEXTRADATA, 0},										// 0x0292
	{MET_NOEXTRADATA, 0},										// 0x0293
	{MET_NOEXTRADATA, 0},										// 0x0294
	{MET_NOEXTRADATA, 0},										// 0x0295
	{MET_NOEXTRADATA, 0},										// 0x0296
	{MET_NOEXTRADATA, 0},										// 0x0297
	{MET_NOEXTRADATA, 0},										// 0x0298
	{MET_NOEXTRADATA, 0},										// 0x0299
	{MET_NOEXTRADATA, 0},										// 0x029A
	{MET_NOEXTRADATA, 0},										// 0x029B
	{MET_NOEXTRADATA, 0},										// 0x029C
	{MET_NOEXTRADATA, 0},										// 0x029D
	{MET_NOEXTRADATA, 0},										// 0x029E
	{MET_NOEXTRADATA, 0},										// 0x029F
	{MET_NOEXTRADATA, 0},										// 0x02A0
	{MET_NOEXTRADATA, 0},										// 0x02A1
	{MET_NOEXTRADATA, 0},										// 0x02A2
	{MET_NOEXTRADATA, 0},										// 0x02A3
	{MET_NOEXTRADATA, 0},										// 0x02A4
	{MET_NOEXTRADATA, 0},										// 0x02A5
	{MET_NOEXTRADATA, 0},										// 0x02A6
	{MET_NOEXTRADATA, 0},										// 0x02A7
	{MET_NOEXTRADATA, 0},										// 0x02A8
	{MET_NOEXTRADATA, 0},										// 0x02A9
	{MET_NOEXTRADATA, 0},										// 0x02AA
	{MET_NOEXTRADATA, 0},										// 0x02AB
	{MET_NOEXTRADATA, 0},										// 0x02AC
	{MET_NOEXTRADATA, 0},										// 0x02AD
	{MET_NOEXTRADATA, 0},										// 0x02AE
	{MET_NOEXTRADATA, 0},										// 0x02AF
	{MET_NOEXTRADATA, 0},										// 0x02B0
	{MET_NOEXTRADATA, 0},										// 0x02B1
	{MET_NOEXTRADATA, 0},										// 0x02B2
	{MET_NOEXTRADATA, 0},										// 0x02B3
	{MET_NOEXTRADATA, 0},										// 0x02B4
	{MET_NOEXTRADATA, 0},										// 0x02B5
	{MET_NOEXTRADATA, 0},										// 0x02B6
	{MET_NOEXTRADATA, 0},										// 0x02B7
	{MET_NOEXTRADATA, 0},										// 0x02B8
	{MET_NOEXTRADATA, 0},										// 0x02B9
	{MET_NOEXTRADATA, 0},										// 0x02BA
	{MET_NOEXTRADATA, 0},										// 0x02BB
	{MET_NOEXTRADATA, 0},										// 0x02BC
	{MET_NOEXTRADATA, 0},										// 0x02BD
	{MET_NOEXTRADATA, 0},										// 0x02BE
	{MET_NOEXTRADATA, 0},										// 0x02BF
	{MET_NOEXTRADATA, 0},										// 0x02C0
	{MET_NOEXTRADATA, 0},										// 0x02C1
	{MET_NOEXTRADATA, 0},										// 0x02C2
	{MET_NOEXTRADATA, 0},										// 0x02C3
	{MET_NOEXTRADATA, 0},										// 0x02C4
	{MET_NOEXTRADATA, 0},										// 0x02C5
	{MET_NOEXTRADATA, 0},										// 0x02C6
	{MET_NOEXTRADATA, 0},										// 0x02C7
	{MET_NOEXTRADATA, 0},										// 0x02C8
	{MET_NOEXTRADATA, 0},										// 0x02C9
	{MET_NOEXTRADATA, 0},										// 0x02CA
	{MET_NOEXTRADATA, 0},										// 0x02CB
	{MET_NOEXTRADATA, 0},										// 0x02CC
	{MET_NOEXTRADATA, 0},										// 0x02CD
	{MET_NOEXTRADATA, 0},										// 0x02CE
	{MET_NOEXTRADATA, 0},										// 0x02CF
	{MET_NOEXTRADATA, 0},										// 0x02D0
	{MET_NOEXTRADATA, 0},										// 0x02D1
	{MET_NOEXTRADATA, 0},										// 0x02D2
	{MET_NOEXTRADATA, 0},										// 0x02D3
	{MET_NOEXTRADATA, 0},										// 0x02D4
	{MET_NOEXTRADATA, 0},										// 0x02D5
	{MET_NOEXTRADATA, 0},										// 0x02D6
	{MET_NOEXTRADATA, 0},										// 0x02D7
	{MET_NOEXTRADATA, 0},										// 0x02D8
	{MET_NOEXTRADATA, 0},										// 0x02D9
	{MET_NOEXTRADATA, 0},										// 0x02DA
	{MET_NOEXTRADATA, 0},										// 0x02DB
	{MET_NOEXTRADATA, 0},										// 0x02DC
	{MET_NOEXTRADATA, 0},										// 0x02DD
	{MET_NOEXTRADATA, 0},										// 0x02DE
	{MET_NOEXTRADATA, 0},										// 0x02DF
	{MET_NOEXTRADATA, 0},										// 0x02E0
	{MET_NOEXTRADATA, 0},										// 0x02E1
	{MET_NOEXTRADATA, 0},										// 0x02E2
	{MET_NOEXTRADATA, 0},										// 0x02E3
	{MET_NOEXTRADATA, 0},										// 0x02E4
	{MET_NOEXTRADATA, 0},										// 0x02E5
	{MET_NOEXTRADATA, 0},										// 0x02E6
	{MET_NOEXTRADATA, 0},										// 0x02E7
	{MET_NOEXTRADATA, 0},										// 0x02E8
	{MET_NOEXTRADATA, 0},										// 0x02E9
	{MET_NOEXTRADATA, 0},										// 0x02EA
	{MET_NOEXTRADATA, 0},										// 0x02EB
	{MET_NOEXTRADATA, 0},										// 0x02EC
	{MET_NOEXTRADATA, 0},										// 0x02ED
	{MET_NOEXTRADATA, 0},										// 0x02EE
	{MET_NOEXTRADATA, 0},										// 0x02EF
	{MET_NOEXTRADATA, 0},										// 0x02F0
	{MET_NOEXTRADATA, 0},										// 0x02F1
	{MET_NOEXTRADATA, 0},										// 0x02F2
	{MET_NOEXTRADATA, 0},										// 0x02F3
	{MET_NOEXTRADATA, 0},										// 0x02F4
	{MET_NOEXTRADATA, 0},										// 0x02F5
	{MET_NOEXTRADATA, 0},										// 0x02F6
	{MET_NOEXTRADATA, 0},										// 0x02F7
	{MET_NOEXTRADATA, 0},										// 0x02F8
	{MET_NOEXTRADATA, 0},										// 0x02F9
	{MET_NOEXTRADATA, 0},										// 0x02FA
	{MET_NOEXTRADATA, 0},										// 0x02FB
	{MET_NOEXTRADATA, 0},										// 0x02FC
	{MET_NOEXTRADATA, 0},										// 0x02FD
	{MET_NOEXTRADATA, 0},										// 0x02FE
	{MET_NOEXTRADATA, 0},										// 0x02FF
	{MET_NOEXTRADATA, 0},										// 0x0300 WM_CUT
	{MET_NOEXTRADATA, 0},										// 0x0301 WM_COPY
	{MET_NOEXTRADATA, 0},										// 0x0302 WM_PASTE
	{MET_NOEXTRADATA, 0},										// 0x0303 WM_CLEAR
	{MET_NOEXTRADATA, 0},										// 0x0304 WM_UNDO
	{MET_NOEXTRADATA, 0},										// 0x0305 WM_RENDERFORMAT
	{MET_NOEXTRADATA, 0},										// 0x0306 WM_RENDERALLFORMATS
	{MET_NOEXTRADATA, 0},										// 0x0307 WM_DESTROYCLIPBOARD
	{MET_NOEXTRADATA, 0},										// 0x0308 WM_DRAWCLIPBOARD
	{MET_GLOBALSTRUCTBOTH, sizeof(PAINTSTRUCT)},				// 0x0309 WM_PAINTCLIPBOARD
	{MET_NOEXTRADATA, 0},										// 0x030A WM_VSCROLLCLIPBOARD
	{MET_GLOBALSTRUCTBOTH, sizeof(RECT)},						// 0x030B WM_SIZECLIPBOARD
	{MET_NOEXTRADATA, 0},										// 0x030C WM_ASKCBFORMATNAME
	{MET_NOEXTRADATA, 0},										// 0x030D WM_CHANGECBCHAIN
	{MET_NOEXTRADATA, 0},										// 0x030E WM_HSCROLLCLIPBOARD
	{MET_NOEXTRADATA, 0},										// 0x030F WM_QUERYNEWPALETTE
	{MET_NOEXTRADATA, 0},										// 0x0310 WM_PALETTEISCHANGING
	{MET_NOEXTRADATA, 0},										// 0x0311 WM_PALETTECHANGED
	{MET_NOEXTRADATA, 0},										// 0x0312 WM_HOTKEY
	{MET_NOEXTRADATA, 0},										// 0x0313
	{MET_NOEXTRADATA, 0},										// 0x0314
	{MET_NOEXTRADATA, 0},										// 0x0315
	{MET_NOEXTRADATA, 0},										// 0x0316
	{MET_NOEXTRADATA, 0},										// 0x0317 WM_PRINT
	{MET_NOEXTRADATA, 0},										// 0x0318 WM_PRINTCLIENT
	{MET_NOEXTRADATA, 0},										// 0x0319
	{MET_NOEXTRADATA, 0},										// 0x031A
	{MET_NOEXTRADATA, 0},										// 0x031B
	{MET_NOEXTRADATA, 0},										// 0x031C
	{MET_NOEXTRADATA, 0},										// 0x031D
	{MET_NOEXTRADATA, 0},										// 0x031E
	{MET_NOEXTRADATA, 0},										// 0x031F
	{MET_NOEXTRADATA, 0},										// 0x0320
	{MET_NOEXTRADATA, 0},										// 0x0321
	{MET_NOEXTRADATA, 0},										// 0x0322
	{MET_NOEXTRADATA, 0},										// 0x0323
	{MET_NOEXTRADATA, 0},										// 0x0324
	{MET_NOEXTRADATA, 0},										// 0x0325
	{MET_NOEXTRADATA, 0},										// 0x0326
	{MET_NOEXTRADATA, 0},										// 0x0327
	{MET_NOEXTRADATA, 0},										// 0x0328
	{MET_NOEXTRADATA, 0},										// 0x0329
	{MET_NOEXTRADATA, 0},										// 0x032A
	{MET_NOEXTRADATA, 0},										// 0x032B
	{MET_NOEXTRADATA, 0},										// 0x032C
	{MET_NOEXTRADATA, 0},										// 0x032D
	{MET_NOEXTRADATA, 0},										// 0x032E
	{MET_NOEXTRADATA, 0},										// 0x032F
	{MET_NOEXTRADATA, 0},										// 0x0330
	{MET_NOEXTRADATA, 0},										// 0x0331
	{MET_NOEXTRADATA, 0},										// 0x0332
	{MET_NOEXTRADATA, 0},										// 0x0333
	{MET_NOEXTRADATA, 0},										// 0x0334
	{MET_NOEXTRADATA, 0},										// 0x0335
	{MET_NOEXTRADATA, 0},										// 0x0336
	{MET_NOEXTRADATA, 0},										// 0x0337
	{MET_NOEXTRADATA, 0},										// 0x0338
	{MET_NOEXTRADATA, 0},										// 0x0339
	{MET_NOEXTRADATA, 0},										// 0x033A
	{MET_NOEXTRADATA, 0},										// 0x033B
	{MET_NOEXTRADATA, 0},										// 0x033C
	{MET_NOEXTRADATA, 0},										// 0x033D
	{MET_NOEXTRADATA, 0},										// 0x033E
	{MET_NOEXTRADATA, 0},										// 0x033F
	{MET_NOEXTRADATA, 0},										// 0x0340
	{MET_NOEXTRADATA, 0},										// 0x0341
	{MET_NOEXTRADATA, 0},										// 0x0342
	{MET_NOEXTRADATA, 0},										// 0x0343
	{MET_NOEXTRADATA, 0},										// 0x0344
	{MET_NOEXTRADATA, 0},										// 0x0345
	{MET_NOEXTRADATA, 0},										// 0x0346
	{MET_NOEXTRADATA, 0},										// 0x0347
	{MET_NOEXTRADATA, 0},										// 0x0348
	{MET_NOEXTRADATA, 0},										// 0x0349
	{MET_NOEXTRADATA, 0},										// 0x034A
	{MET_NOEXTRADATA, 0},										// 0x034B
	{MET_NOEXTRADATA, 0},										// 0x034C
	{MET_NOEXTRADATA, 0},										// 0x034D
	{MET_NOEXTRADATA, 0},										// 0x034E
	{MET_NOEXTRADATA, 0},										// 0x034F
	{MET_NOEXTRADATA, 0},										// 0x0350
	{MET_NOEXTRADATA, 0},										// 0x0351
	{MET_NOEXTRADATA, 0},										// 0x0352
	{MET_NOEXTRADATA, 0},										// 0x0353
	{MET_NOEXTRADATA, 0},										// 0x0354
	{MET_NOEXTRADATA, 0},										// 0x0355
	{MET_NOEXTRADATA, 0},										// 0x0356
	{MET_NOEXTRADATA, 0},										// 0x0357
	{MET_NOEXTRADATA, 0},										// 0x0358 WM_HANDHELDFIRST
	{MET_NOEXTRADATA, 0},										// 0x0359
	{MET_NOEXTRADATA, 0},										// 0x035A
	{MET_NOEXTRADATA, 0},										// 0x035B
	{MET_NOEXTRADATA, 0},										// 0x035C
	{MET_NOEXTRADATA, 0},										// 0x035D
	{MET_NOEXTRADATA, 0},										// 0x035E
	{MET_NOEXTRADATA, 0},										// 0x035F WM_HANDHELDLAST
	{MET_NOEXTRADATA, 0},										// 0x0360
	{MET_NOEXTRADATA, 0},										// 0x0361
	{MET_NOEXTRADATA, 0},										// 0x0360 WM_AFXFIRST
	{MET_NOEXTRADATA, 0},										// 0x0363
	{MET_NOEXTRADATA, 0},										// 0x0364
	{MET_NOEXTRADATA, 0},										// 0x0365
	{MET_NOEXTRADATA, 0},										// 0x0366
	{MET_NOEXTRADATA, 0},										// 0x0367
	{MET_NOEXTRADATA, 0},										// 0x0368
	{MET_NOEXTRADATA, 0},										// 0x0369
	{MET_NOEXTRADATA, 0},										// 0x036A
	{MET_NOEXTRADATA, 0},										// 0x036B
	{MET_NOEXTRADATA, 0},										// 0x036C
	{MET_NOEXTRADATA, 0},										// 0x036D
	{MET_NOEXTRADATA, 0},										// 0x036E
	{MET_NOEXTRADATA, 0},										// 0x036F
	{MET_NOEXTRADATA, 0},										// 0x0370
	{MET_NOEXTRADATA, 0},										// 0x0371
	{MET_NOEXTRADATA, 0},										// 0x0372
	{MET_NOEXTRADATA, 0},										// 0x0373
	{MET_NOEXTRADATA, 0},										// 0x0374
	{MET_NOEXTRADATA, 0},										// 0x0375
	{MET_NOEXTRADATA, 0},										// 0x0376
	{MET_NOEXTRADATA, 0},										// 0x0377
	{MET_NOEXTRADATA, 0},										// 0x0378
	{MET_NOEXTRADATA, 0},										// 0x0379
	{MET_NOEXTRADATA, 0},										// 0x037A
	{MET_NOEXTRADATA, 0},										// 0x037B
	{MET_NOEXTRADATA, 0},										// 0x037C
	{MET_NOEXTRADATA, 0},										// 0x037D
	{MET_NOEXTRADATA, 0},										// 0x037E
	{MET_NOEXTRADATA, 0},										// 0x037F WM_AFXLAST
	{MET_NOEXTRADATA, 0},										// 0x0380 WM_PENWINFIRST
	{MET_NOEXTRADATA, 0},										// 0x0381
	{MET_NOEXTRADATA, 0},										// 0x0382
	{MET_NOEXTRADATA, 0},										// 0x0383
	{MET_NOEXTRADATA, 0},										// 0x0384
	{MET_NOEXTRADATA, 0},										// 0x0385
	{MET_NOEXTRADATA, 0},										// 0x0386
	{MET_NOEXTRADATA, 0},										// 0x0387
	{MET_NOEXTRADATA, 0},										// 0x0388
	{MET_NOEXTRADATA, 0},										// 0x0389
	{MET_NOEXTRADATA, 0},										// 0x038A
	{MET_NOEXTRADATA, 0},										// 0x038B
	{MET_NOEXTRADATA, 0},										// 0x038C
	{MET_NOEXTRADATA, 0},										// 0x038D
	{MET_NOEXTRADATA, 0},										// 0x038E
	{MET_NOEXTRADATA, 0},										// 0x038F WM_PENWINLAST
	{MET_NOEXTRADATA, 0},										// 0x0390
	{MET_NOEXTRADATA, 0},										// 0x0391
	{MET_NOEXTRADATA, 0},										// 0x0392
	{MET_NOEXTRADATA, 0},										// 0x0393
	{MET_NOEXTRADATA, 0},										// 0x0394
	{MET_NOEXTRADATA, 0},										// 0x0395
	{MET_NOEXTRADATA, 0},										// 0x0396
	{MET_NOEXTRADATA, 0},										// 0x0397
	{MET_NOEXTRADATA, 0},										// 0x0398
	{MET_NOEXTRADATA, 0},										// 0x0399
	{MET_NOEXTRADATA, 0},										// 0x039A
	{MET_NOEXTRADATA, 0},										// 0x039B
	{MET_NOEXTRADATA, 0},										// 0x039C
	{MET_NOEXTRADATA, 0},										// 0x039D
	{MET_NOEXTRADATA, 0},										// 0x039E
	{MET_NOEXTRADATA, 0},										// 0x039F
	{MET_NOEXTRADATA, 0},										// 0x03A0
	{MET_NOEXTRADATA, 0},										// 0x03A1
	{MET_NOEXTRADATA, 0},										// 0x03A2
	{MET_NOEXTRADATA, 0},										// 0x03A3
	{MET_NOEXTRADATA, 0},										// 0x03A4
	{MET_NOEXTRADATA, 0},										// 0x03A5
	{MET_NOEXTRADATA, 0},										// 0x03A6
	{MET_NOEXTRADATA, 0},										// 0x03A7
	{MET_NOEXTRADATA, 0},										// 0x03A8
	{MET_NOEXTRADATA, 0},										// 0x03A9
	{MET_NOEXTRADATA, 0},										// 0x03AA
	{MET_NOEXTRADATA, 0},										// 0x03AB
	{MET_NOEXTRADATA, 0},										// 0x03AC
	{MET_NOEXTRADATA, 0},										// 0x03AD
	{MET_NOEXTRADATA, 0},										// 0x03AE
	{MET_NOEXTRADATA, 0},										// 0x03AF
	{MET_NOEXTRADATA, 0},										// 0x03B0
	{MET_NOEXTRADATA, 0},										// 0x03B1
	{MET_NOEXTRADATA, 0},										// 0x03B2
	{MET_NOEXTRADATA, 0},										// 0x03B3
	{MET_NOEXTRADATA, 0},										// 0x03B4
	{MET_NOEXTRADATA, 0},										// 0x03B5
	{MET_NOEXTRADATA, 0},										// 0x03B6
	{MET_NOEXTRADATA, 0},										// 0x03B7
	{MET_NOEXTRADATA, 0},										// 0x03B8
	{MET_NOEXTRADATA, 0},										// 0x03B9
	{MET_NOEXTRADATA, 0},										// 0x03BA
	{MET_NOEXTRADATA, 0},										// 0x03BB
	{MET_NOEXTRADATA, 0},										// 0x03BC
	{MET_NOEXTRADATA, 0},										// 0x03BD
	{MET_NOEXTRADATA, 0},										// 0x03BE
	{MET_NOEXTRADATA, 0},										// 0x03BF
	{MET_NOEXTRADATA, 0},										// 0x03C0
	{MET_NOEXTRADATA, 0},										// 0x03C1
	{MET_NOEXTRADATA, 0},										// 0x03C2
	{MET_NOEXTRADATA, 0},										// 0x03C3
	{MET_NOEXTRADATA, 0},										// 0x03C4
	{MET_NOEXTRADATA, 0},										// 0x03C5
	{MET_NOEXTRADATA, 0},										// 0x03C6
	{MET_NOEXTRADATA, 0},										// 0x03C7
	{MET_NOEXTRADATA, 0},										// 0x03C8
	{MET_NOEXTRADATA, 0},										// 0x03C9
	{MET_NOEXTRADATA, 0},										// 0x03CA
	{MET_NOEXTRADATA, 0},										// 0x03CB
	{MET_NOEXTRADATA, 0},										// 0x03CC
	{MET_NOEXTRADATA, 0},										// 0x03CD
	{MET_NOEXTRADATA, 0},										// 0x03CE
	{MET_NOEXTRADATA, 0},										// 0x03CF
	{MET_NOEXTRADATA, 0},										// 0x03D0
	{MET_NOEXTRADATA, 0},										// 0x03D1
	{MET_NOEXTRADATA, 0},										// 0x03D2
	{MET_NOEXTRADATA, 0},										// 0x03D3
	{MET_NOEXTRADATA, 0},										// 0x03D4
	{MET_NOEXTRADATA, 0},										// 0x03D5
	{MET_NOEXTRADATA, 0},										// 0x03D6
	{MET_NOEXTRADATA, 0},										// 0x03D7
	{MET_NOEXTRADATA, 0},										// 0x03D8
	{MET_NOEXTRADATA, 0},										// 0x03D9
	{MET_NOEXTRADATA, 0},										// 0x03DA
	{MET_NOEXTRADATA, 0},										// 0x03DB
	{MET_NOEXTRADATA, 0},										// 0x03DC
	{MET_NOEXTRADATA, 0},										// 0x03DD
	{MET_NOEXTRADATA, 0},										// 0x03DE
	{MET_NOEXTRADATA, 0},										// 0x03DF
	{MET_NOEXTRADATA, 0},										// 0x03E0
	{MET_NOEXTRADATA, 0},										// 0x03E1
	{MET_NOEXTRADATA, 0},										// 0x03E2
	{MET_NOEXTRADATA, 0},										// 0x03E3
	{MET_NOEXTRADATA, 0},										// 0x03E4
	{MET_NOEXTRADATA, 0},										// 0x03E5
	{MET_NOEXTRADATA, 0},										// 0x03E6
	{MET_NOEXTRADATA, 0},										// 0x03E7
	{MET_NOEXTRADATA, 0},										// 0x03E8
	{MET_NOEXTRADATA, 0},										// 0x03E9
	{MET_NOEXTRADATA, 0},										// 0x03EA
	{MET_NOEXTRADATA, 0},										// 0x03EB
	{MET_NOEXTRADATA, 0},										// 0x03EC
	{MET_NOEXTRADATA, 0},										// 0x03ED
	{MET_NOEXTRADATA, 0},										// 0x03EE
	{MET_NOEXTRADATA, 0},										// 0x03EF
	{MET_NOEXTRADATA, 0},										// 0x03F0
	{MET_NOEXTRADATA, 0},										// 0x03F1
	{MET_NOEXTRADATA, 0},										// 0x03F2
	{MET_NOEXTRADATA, 0},										// 0x03F3
	{MET_NOEXTRADATA, 0},										// 0x03F4
	{MET_NOEXTRADATA, 0},										// 0x03F5
	{MET_NOEXTRADATA, 0},										// 0x03F6
	{MET_NOEXTRADATA, 0},										// 0x03F7
	{MET_NOEXTRADATA, 0},										// 0x03F8
	{MET_NOEXTRADATA, 0},										// 0x03F9
	{MET_NOEXTRADATA, 0},										// 0x03FA
	{MET_NOEXTRADATA, 0},										// 0x03FB
	{MET_NOEXTRADATA, 0},										// 0x03FC
	{MET_NOEXTRADATA, 0},										// 0x03FD
	{MET_NOEXTRADATA, 0},										// 0x03FE
	{MET_NOEXTRADATA, 0}										// 0x03FF
};

SPYXXHK_SHDATA MSGENCODETABLE gmetDlg[MAX_DLG_MESSAGES] =
{
	{MET_NOEXTRADATA, 0},										// WM_USER+0 DM_GETDEFID
	{MET_NOEXTRADATA, 0}										// WM_USER+1 DM_SETDEFID
};

#ifndef DISABLE_WIN95_MESSAGES
SPYXXHK_SHDATA MSGENCODETABLE gmetAni[MAX_ANI_MESSAGES] =
{
	{MET_STRINGBOTH, 0},										// WM_USER+n ACM_OPEN
	{MET_NOEXTRADATA, 0},										// WM_USER+n ACM_PLAY
	{MET_NOEXTRADATA, 0}										// WM_USER+n ACM_STOP
};

SPYXXHK_SHDATA MSGENCODETABLE gmetHdr[MAX_HDR_MESSAGES] =
{
	{MET_NOEXTRADATA, 0},										// WM_USER+n HDM_GETITEMCOUNT
	{MET_STRUCTBOTH, sizeof(HD_ITEM)},							// WM_USER+n HDM_INSERTITEM  
	{MET_NOEXTRADATA, 0},										// WM_USER+n HDM_DELETEITEM  
	{MET_STRUCTBOTH, sizeof(HD_ITEM)},							// WM_USER+n HDM_GETITEM     
	{MET_STRUCTBOTH, sizeof(HD_ITEM)},							// WM_USER+n HDM_SETITEM     
	{MET_STRUCTBOTH, sizeof(HD_LAYOUT)},						// WM_USER+n HDM_LAYOUT      
	{MET_STRUCTBOTH, sizeof(HD_HITTESTINFO)}					// WM_USER+n HDM_HITTEST
};

SPYXXHK_SHDATA MSGENCODETABLE gmetTB[MAX_TB_MESSAGES] =
{
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_ENABLEBUTTON         
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_CHECKBUTTON          
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_PRESSBUTTON          
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_HIDEBUTTON           
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_INDETERMINATE        
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_ISBUTTONENABLED      
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_ISBUTTONCHECKED      
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_ISBUTTONPRESSED      
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_ISBUTTONHIDDEN       
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_ISBUTTONINDETERMINATE
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_SETSTATE             
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_GETSTATE             
	{MET_STRUCTBOTH, sizeof(TBADDBITMAP)},						// WM_USER+n TB_ADDBITMAP            
	{MET_STRUCTBOTH, sizeof(TBBUTTON)},							// WM_USER+n TB_ADDBUTTONS           
	{MET_STRUCTBOTH, sizeof(TBBUTTON)},							// WM_USER+n TB_INSERTBUTTON         
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_DELETEBUTTON         
	{MET_STRUCTRET, sizeof(TBBUTTON)},							// WM_USER+n TB_GETBUTTON            
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_BUTTONCOUNT          
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_COMMANDTOINDEX       
	{MET_STRUCTBOTH, sizeof(TBSAVEPARAMS)},						// WM_USER+n TB_SAVERESTORE          
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_CUSTOMIZE            
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_ADDSTRING            
	{MET_STRUCTRET, sizeof(RECT)},								// WM_USER+n TB_GETITEMRECT		    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_BUTTONSTRUCTSIZE	    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_SETBUTTONSIZE	    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_SETBITMAPSIZE	    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_AUTOSIZE		        
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_SETBUTTONTYPE	    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_GETTOOLTIPS		    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_SETTOOLTIPS		    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_SETPARENT		    
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_STRUCTRET, sizeof(RECT)},								// WM_USER+n TB_SETROWS
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_GETROWS
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_SETCMDID
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_CHANGEBITMAP
	{MET_NOEXTRADATA, 0},										// WM_USER+n TB_GETBITMAP
	{MET_STRINGRET, 0}											// WM_USER+n TB_GETBUTTONTEXT
};

SPYXXHK_SHDATA MSGENCODETABLE gmetTT[MAX_TT_MESSAGES] =
{
	{MET_NOEXTRADATA, 0},										// WM_USER+n TTM_ACTIVATE	
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n TTM_SETDELAYTIME
	{MET_STRUCTBOTH, sizeof(TOOLINFO)},							// WM_USER+n TTM_ADDTOOL		 
	{MET_STRUCTBOTH, sizeof(TOOLINFO)},							// WM_USER+n TTM_DELTOOL		 
	{MET_STRUCTBOTH, sizeof(TOOLINFO)},							// WM_USER+n TTM_NEWTOOLRECT	
	{MET_STRUCTBOTH, sizeof(MSG)},								// WM_USER+n TTM_RELAYEVENT	
	{MET_STRUCTBOTH, sizeof(TOOLINFO)},							// WM_USER+n TTM_GETTOOLINFO  
	{MET_STRUCTBOTH, sizeof(TOOLINFO)},							// WM_USER+n TTM_SETTOOLINFO  
	{MET_STRUCTBOTH, sizeof(TTHITTESTINFO)},					// WM_USER+n TTM_HITTEST      
	{MET_STRUCTBOTH, sizeof(TOOLINFO)},							// WM_USER+n TTM_GETTEXT      
	{MET_STRUCTBOTH, sizeof(TOOLINFO)},							// WM_USER+n TTM_UPDATETIPTEXT
	{MET_NOEXTRADATA, 0},										// WM_USER+n TTM_GETTOOLCOUNT 
	{MET_STRUCTBOTH, sizeof(TOOLINFO)},							// WM_USER+n TTM_ENUMTOOLS    
	{MET_STRUCTRET, sizeof(TOOLINFO)}							// WM_USER+n TTM_GETCURRENTTOOL
};

SPYXXHK_SHDATA MSGENCODETABLE gmetStat[MAX_STAT_MESSAGES] =
{
	{MET_STRINGBOTH, 0},										// WM_USER+n SB_SETTEXT		
	{MET_STRINGRET, 0},											// WM_USER+n SB_GETTEXT		
	{MET_NOEXTRADATA, 0},										// WM_USER+n SB_GETTEXTLENGTH
	{MET_NOEXTRADATA, 0},										// WM_USER+n SB_SETPARTS		
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n SB_GETPARTS		
	{MET_NOEXTRADATA, 0},										// WM_USER+n SB_GETBORDERS	
	{MET_NOEXTRADATA, 0},										// WM_USER+n SB_SETMINHEIGHT	
	{MET_NOEXTRADATA, 0},										// WM_USER+n SB_SIMPLE		
	{MET_STRUCTRET, sizeof(RECT)}								// WM_USER+n SB_GETRECT      
};

SPYXXHK_SHDATA MSGENCODETABLE gmetTrk[MAX_TRK_MESSAGES] =
{
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_GETPOS        
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_GETRANGEMIN   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_GETRANGEMAX   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_GETTIC        
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_SETTIC        
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_SETPOS        
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_SETRANGE      
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_SETRANGEMIN   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_SETRANGEMAX   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_CLEARTICS     
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_SETSEL        
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_SETSELSTART   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_SETSELEND     
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_GETPTICS      
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_GETTICPOS     
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_GETNUMTICS    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_GETSELSTART   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_GETSELEND  	  
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_CLEARSEL  	  
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_SETTICFREQ	
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_SETPAGESIZE   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_GETPAGESIZE   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_SETLINESIZE   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_GETLINESIZE   
	{MET_STRUCTRET, sizeof(RECT)},								// WM_USER+n TBM_GETTHUMBRECT  
	{MET_STRUCTRET, sizeof(RECT)},								// WM_USER+n TBM_GETCHANNELRECT
	{MET_NOEXTRADATA, 0},										// WM_USER+n TBM_SETTHUMBLENGTH
	{MET_NOEXTRADATA, 0}										// WM_USER+n TBM_GETTHUMBLENGTH 
};

SPYXXHK_SHDATA MSGENCODETABLE gmetUpDn[MAX_UD_MESSAGES] =
{
	{MET_NOEXTRADATA, 0},										// WM_USER+n UDM_SETRANGE
	{MET_NOEXTRADATA, 0},										// WM_USER+n UDM_GETRANGE
	{MET_NOEXTRADATA, 0},										// WM_USER+n UDM_SETPOS	
	{MET_NOEXTRADATA, 0},										// WM_USER+n UDM_GETPOS	
	{MET_NOEXTRADATA, 0},										// WM_USER+n UDM_SETBUDDY
	{MET_NOEXTRADATA, 0},										// WM_USER+n UDM_GETBUDDY
	{MET_NOEXTRADATA, 0},										// WM_USER+n UDM_SETACCEL
	{MET_NOEXTRADATA, 0},										// WM_USER+n UDM_GETACCEL
	{MET_NOEXTRADATA, 0},										// WM_USER+n UDM_SETBASE	
	{MET_NOEXTRADATA, 0}										// WM_USER+n UDM_GETBASE	
};

SPYXXHK_SHDATA MSGENCODETABLE gmetProg[MAX_PROG_MESSAGES] =
{
	{MET_NOEXTRADATA, 0},										// WM_USER+n PBM_SETRANGE
	{MET_NOEXTRADATA, 0},										// WM_USER+n PBM_SETPOS  
	{MET_NOEXTRADATA, 0},										// WM_USER+n PBM_DELTAPOS
	{MET_NOEXTRADATA, 0},										// WM_USER+n PBM_SETSTEP 
	{MET_NOEXTRADATA, 0}										// WM_USER+n PBM_STEPIT	
};

SPYXXHK_SHDATA MSGENCODETABLE gmetHK[MAX_HK_MESSAGES] =
{
	{MET_NOEXTRADATA, 0},										// WM_USER+n HKM_SETHOTKEY
	{MET_NOEXTRADATA, 0},										// WM_USER+n HKM_GETHOTKEY
	{MET_NOEXTRADATA, 0}										// WM_USER+n HKM_SETRULES 
};

SPYXXHK_SHDATA MSGENCODETABLE gmetLV[MAX_LV_MESSAGES] =
{
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETBKCOLOR     
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_SETBKCOLOR     
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETIMAGELIST   
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_SETIMAGELIST   
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETITEMCOUNT   
	{MET_STRUCTBOTH, sizeof(LV_ITEM)},							// WM_USER+n LVM_GETITEM
	{MET_STRUCTBOTH, sizeof(LV_ITEM)},							// WM_USER+n LVM_SETITEM        
	{MET_STRUCTBOTH, sizeof(LV_ITEM)},							// WM_USER+n LVM_INSERTITEM     
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_DELETEITEM     
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_DELETEALLITEMS 
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETCALLBACKMASK
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_SETCALLBACKMASK
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETNEXTITEM    
	{MET_STRUCTBOTH, sizeof(LV_FINDINFO)},						// WM_USER+n LVM_FINDITEM       
	{MET_STRUCTBOTH, sizeof(RECT)},								// WM_USER+n LVM_GETITEMRECT    
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_SETITEMPOSITION
	{MET_STRUCTRET, sizeof(POINT)},								// WM_USER+n LVM_GETITEMPOSITION
	{MET_STRINGBOTH, 0},										// WM_USER+n LVM_GETSTRINGWIDTH 
	{MET_STRUCTBOTH, sizeof(LV_HITTESTINFO)},					// WM_USER+n LVM_HITTEST        
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_ENSUREVISIBLE  
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_SCROLL         
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_REDRAWITEMS    
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_ARRANGE        
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_EDITLABEL      
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETEDITCONTROL 
	{MET_STRUCTBOTH, sizeof(LV_COLUMN)},						// WM_USER+n LVM_GETCOLUMN
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_SETCOLUMN      
	{MET_STRUCTBOTH, sizeof(LV_COLUMN)},						// WM_USER+n LVM_INSERTCOLUMN   
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_DELETECOLUMN   
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETCOLUMNWIDTH 
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_SETCOLUMNWIDTH 
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_STRUCTBOTH, sizeof(POINT)},							// WM_USER+n LVM_CREATEDRAGIMAGE
	{MET_STRUCTRET, sizeof(RECT)},								// WM_USER+n LVM_GETVIEWRECT    
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETTEXTCOLOR   
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_SETTEXTCOLOR   
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETTEXTBKCOLOR 
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_SETTEXTBKCOLOR 
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETTOPINDEX    
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETCOUNTPERPAGE
	{MET_STRUCTRET, sizeof(POINT)},								// WM_USER+n LVM_GETORIGIN      
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_UPDATE         
	{MET_STRUCTBOTH, sizeof(LV_ITEM)},							// WM_USER+n LVM_SETITEMSTATE   
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETITEMSTATE   
	{MET_STRUCTBOTH, sizeof(LV_ITEM)},							// WM_USER+n LVM_GETITEMTEXT    
	{MET_STRUCTBOTH, sizeof(LV_ITEM)},							// WM_USER+n LVM_SETITEMTEXT    
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_SETITEMCOUNT   
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_SORTITEMS      
	{MET_STRUCTBOTH, sizeof(POINT)},							// WM_USER+n LVM_SETITEMPOSITION32
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETSELECTEDCOUNT
	{MET_NOEXTRADATA, 0},										// WM_USER+n LVM_GETITEMSPACING
	{MET_STRINGRET, 0}											// WM_USER+n LVM_GETISEARCHSTRING
};

SPYXXHK_SHDATA MSGENCODETABLE gmetTV[MAX_TV_MESSAGES] =
{
	{MET_STRUCTBOTH, sizeof(TV_INSERTSTRUCT)},					// WM_USER+n TVM_INSERTITEM     
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_DELETEITEM     
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_EXPAND	       
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_STRUCTRET, sizeof(RECT)},								// WM_USER+n TVM_GETITEMRECT    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_GETCOUNT       
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_GETINDENT      
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_SETINDENT      
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_GETIMAGELIST   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_SETIMAGELIST   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_GETNEXTITEM	   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_SELECTITEM     
	{MET_STRUCTBOTH, sizeof(TV_ITEM)},							// WM_USER+n TVM_GETITEM        
	{MET_STRUCTBOTH, sizeof(TV_ITEM)},							// WM_USER+n TVM_SETITEM        
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_EDITLABEL      
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_GETEDITCONTROL 
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_GETVISIBLECOUNT
	{MET_STRUCTBOTH, sizeof(TV_HITTESTINFO)},					// WM_USER+n TVM_HITTEST        
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_CREATEDRAGIMAGE
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_SORTCHILDREN   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_ENSUREVISIBLE  
	{MET_STRUCTBOTH, sizeof(TV_SORTCB)},						// WM_USER+n TVM_SORTCHILDRENCB 
	{MET_NOEXTRADATA, 0},										// WM_USER+n TVM_ENDEDITLABELNOW
	{MET_STRINGRET, 0}											// WM_USER+n TVM_GETISEARCHSTRING
};

SPYXXHK_SHDATA MSGENCODETABLE gmetTab[MAX_TAB_MESSAGES] =
{
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_GETBKCOLOR    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_SETBKCOLOR    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_GETIMAGELIST  
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_SETIMAGELIST  
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_GETITEMCOUNT  
	{MET_STRUCTBOTH, sizeof(TC_ITEM)},							// WM_USER+n TCM_GETITEM       
	{MET_STRUCTBOTH, sizeof(TC_ITEM)},							// WM_USER+n TCM_SETITEM       
	{MET_STRUCTBOTH, sizeof(TC_ITEM)},							// WM_USER+n TCM_INSERTITEM    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_DELETEITEM    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_DELETEALLITEMS
	{MET_STRUCTRET, sizeof(RECT)},								// WM_USER+n TCM_GETITEMRECT   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_GETCURSEL     
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_SETCURSEL     
	{MET_STRUCTBOTH, sizeof(TC_HITTESTINFO)},					// WM_USER+n TCM_HITTEST       
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_SETITEMEXTRA  
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_NOEXTRADATA, 0},										// WM_USER+n
	{MET_STRUCTBOTH, sizeof(RECT)},								// WM_USER+n TCM_ADJUSTRECT	  
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_SETITEMSIZE	  
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_REMOVEIMAGE   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_SETPADDING    
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_GETROWCOUNT   
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_GETTOOLTIPS	
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_SETTOOLTIPS	
	{MET_NOEXTRADATA, 0},										// WM_USER+n TCM_GETCURFOCUS   
	{MET_NOEXTRADATA, 0}										// WM_USER+n TCM_SETCURFOCUS   
};
#endif	// DISABLE_WIN95_MESSAGES

#endif	// __MET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\msgdoc2.cpp ===
/*****************************************************************************\
*
* Module: MsgDoc2.cpp
*
* Contains static members of the CMsgDoc class.
*
\*****************************************************************************/

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"

#include <dde.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

int CMsgDoc::m_nLogging = 0;
BOOL CMsgDoc::m_fTestMode = FALSE;

CHAR CMsgDoc::m_szKeyMsgFilters[]			= "MsgFilters";
CHAR CMsgDoc::m_szKeyMsgFiltersMask[]		= "MsgFiltersMask";
CHAR CMsgDoc::m_szKeyDlgMsgFiltersMask[]	= "MsgFiltersMaskDlg";
#ifndef DISABLE_WIN95_MESSAGES
CHAR CMsgDoc::m_szKeyAniMsgFiltersMask[]	= "MsgFiltersMaskAni";
CHAR CMsgDoc::m_szKeyBLMsgFiltersMask[]		= "MsgFiltersMaskBL";
CHAR CMsgDoc::m_szKeyHdrMsgFiltersMask[]	= "MsgFiltersMaskHdr";
CHAR CMsgDoc::m_szKeyTBMsgFiltersMask[]		= "MsgFiltersMaskTB";
CHAR CMsgDoc::m_szKeyTTMsgFiltersMask[]		= "MsgFiltersMaskTT";
CHAR CMsgDoc::m_szKeyStatMsgFiltersMask[]	= "MsgFiltersMaskStat";
CHAR CMsgDoc::m_szKeyTrkMsgFiltersMask[]	= "MsgFiltersMaskTrk";
CHAR CMsgDoc::m_szKeyUpDnMsgFiltersMask[]	= "MsgFiltersMaskUpDn";
CHAR CMsgDoc::m_szKeyProgMsgFiltersMask[]	= "MsgFiltersMaskProg";
CHAR CMsgDoc::m_szKeyHKMsgFiltersMask[]		= "MsgFiltersMaskHK";
CHAR CMsgDoc::m_szKeyLVMsgFiltersMask[]		= "MsgFiltersMaskLV";
CHAR CMsgDoc::m_szKeyTVMsgFiltersMask[]		= "MsgFiltersMaskTV";
CHAR CMsgDoc::m_szKeyTabMsgFiltersMask[]	= "MsgFiltersMaskTab";
#endif	// DISABLE_WIN95_MESSAGES
CHAR CMsgDoc::m_szKeyWinFilters[]			= "WinFilters";
CHAR CMsgDoc::m_szKeyOutputFilters[]		= "OutputFilters";
CHAR CMsgDoc::m_szKeyOutputLogFile[]		= "OutputLogFile";
CHAR CMsgDoc::m_szKeyLines[]				= "Lines";

BOOL CMsgDoc::m_fMsgsUserDef;
BOOL CMsgDoc::m_fMsgsRegisteredDef;
BOOL CMsgDoc::m_fMsgsUndocumentedDef;
BOOL CMsgDoc::m_fIncludeParentDef;
BOOL CMsgDoc::m_fIncludeChildrenDef;
BOOL CMsgDoc::m_fIncludeProcessDef;
BOOL CMsgDoc::m_fIncludeThreadDef;
BOOL CMsgDoc::m_fShowNestingLevelDef;
BOOL CMsgDoc::m_fShowRawParmsDef;
BOOL CMsgDoc::m_fShowDecodedParmsDef;
BOOL CMsgDoc::m_fShowRawReturnDef;
BOOL CMsgDoc::m_fShowDecodedReturnDef;
BOOL CMsgDoc::m_fShowOriginTimeDef;
BOOL CMsgDoc::m_fShowMousePositionDef;
BOOL CMsgDoc::m_fLogToFileDef;
CString CMsgDoc::m_strLogFileNameDef;
BOOL CMsgDoc::m_fAppendFileDef;
int CMsgDoc::m_cLinesMaxDef;
int CMsgDoc::m_cShowReturnUseCount		= 0;

BYTE CMsgDoc::m_afSelectedDef[MAX_MESSAGES];
BYTE CMsgDoc::m_afDlgSelectedDef[MAX_DLG_MESSAGES];
#ifndef DISABLE_WIN95_MESSAGES
BYTE CMsgDoc::m_afAniSelectedDef[MAX_ANI_MESSAGES];
BYTE CMsgDoc::m_afHdrSelectedDef[MAX_HDR_MESSAGES];
BYTE CMsgDoc::m_afTBSelectedDef[MAX_TB_MESSAGES];
BYTE CMsgDoc::m_afTTSelectedDef[MAX_TT_MESSAGES];
BYTE CMsgDoc::m_afStatSelectedDef[MAX_STAT_MESSAGES];
BYTE CMsgDoc::m_afTrkSelectedDef[MAX_TRK_MESSAGES];
BYTE CMsgDoc::m_afUpDnSelectedDef[MAX_UD_MESSAGES];
BYTE CMsgDoc::m_afProgSelectedDef[MAX_PROG_MESSAGES];
BYTE CMsgDoc::m_afHKSelectedDef[MAX_HK_MESSAGES];
BYTE CMsgDoc::m_afLVSelectedDef[MAX_LV_MESSAGES];
BYTE CMsgDoc::m_afTVSelectedDef[MAX_TV_MESSAGES];
BYTE CMsgDoc::m_afTabSelectedDef[MAX_TAB_MESSAGES];
#endif	// DISABLE_WIN95_MESSAGES
BYTE CMsgDoc::m_BitTable[8] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };


//
// Message lookup table.  This will be initialized to be a sparse
// array with elements pointing into the m_aMsgDesc table.  It can
// be used to quickly look up the message description for a given
// integral message number.
//
PMSGDESC CMsgDoc::m_apmdLT[MAX_MESSAGES];

//
// Other message lookup tables.  These will be initialized to be a sparse
// array with elements pointing into the m_aMsgDesc table.  It can
// be used to quickly look up the message description for a given
// integral message number.
//
PMSGDESC CMsgDoc::m_apmdDlgLT[MAX_DLG_MESSAGES];
#ifndef DISABLE_WIN95_MESSAGES
PMSGDESC CMsgDoc::m_apmdAniLT[MAX_ANI_MESSAGES];
PMSGDESC CMsgDoc::m_apmdHdrLT[MAX_HDR_MESSAGES];
PMSGDESC CMsgDoc::m_apmdTBLT[MAX_TB_MESSAGES];
PMSGDESC CMsgDoc::m_apmdTTLT[MAX_TT_MESSAGES];
PMSGDESC CMsgDoc::m_apmdStatLT[MAX_STAT_MESSAGES];
PMSGDESC CMsgDoc::m_apmdTrkLT[MAX_TRK_MESSAGES];
PMSGDESC CMsgDoc::m_apmdUpDnLT[MAX_UD_MESSAGES];
PMSGDESC CMsgDoc::m_apmdProgLT[MAX_PROG_MESSAGES];
PMSGDESC CMsgDoc::m_apmdHKLT[MAX_HK_MESSAGES];
PMSGDESC CMsgDoc::m_apmdLVLT[MAX_LV_MESSAGES];
PMSGDESC CMsgDoc::m_apmdTVLT[MAX_TV_MESSAGES];
PMSGDESC CMsgDoc::m_apmdTabLT[MAX_TAB_MESSAGES];
#endif	// DISABLE_WIN95_MESSAGES

//
// Message description table.  Describes each message that can be spied on.
//
// This table is added to a listbox in the order shown.  Keep this
// list alphabetical, please!!
//
MSGDESC CMsgDoc::m_aMsgDesc[] =
{
#ifndef FEWMESSAGES
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(ACM_OPEN, MT_ANI),						// WM_USER+
	MSGDESCENTRY(ACM_PLAY, MT_ANI),						// WM_USER+
	MSGDESCENTRY(ACM_STOP, MT_ANI),						// WM_USER+
#endif	// DISABLE_WIN95_MESSAGES

	MSGDESCENTRY(BM_GETCHECK, MT_BM),					// 0x00F0
	MSGDESCENTRY(BM_GETSTATE, MT_BM),					// 0x00F2
	MSGDESCENTRY(BM_SETCHECK, MT_BM),					// 0x00F1
	MSGDESCENTRY(BM_SETSTATE, MT_BM),					// 0x00F3
	MSGDESCENTRY(BM_SETSTYLE, MT_BM),					// 0x00F4

	MSGDESCENTRY(CB_ADDSTRING, MT_CB),					// 0x0143
	MSGDESCENTRY(CB_DELETESTRING, MT_CB),				// 0x0144
	MSGDESCENTRY(CB_DIR, MT_CB),						// 0x0145
	MSGDESCENTRY(CB_FINDSTRING, MT_CB),					// 0x014C
	MSGDESCENTRY(CB_FINDSTRINGEXACT, MT_CB),			// 0x0158
	MSGDESCENTRY(CB_GETCOUNT, MT_CB),					// 0x0146
	MSGDESCENTRY(CB_GETCURSEL, MT_CB),					// 0x0147
	MSGDESCENTRY(CB_GETDROPPEDCONTROLRECT, MT_CB),		// 0x0152
	MSGDESCENTRY(CB_GETDROPPEDSTATE, MT_CB),			// 0x0157
	MSGDESCENTRY(CB_GETEDITSEL, MT_CB),					// 0x0140
	MSGDESCENTRY(CB_GETEXTENDEDUI, MT_CB),				// 0x0156
	MSGDESCENTRY(CB_GETITEMDATA, MT_CB),				// 0x0150
	MSGDESCENTRY(CB_GETITEMHEIGHT, MT_CB),				// 0x0154
	MSGDESCENTRY(CB_GETLBTEXT, MT_CB),					// 0x0148
	MSGDESCENTRY(CB_GETLBTEXTLEN, MT_CB),				// 0x0149
	MSGDESCENTRY(CB_GETLOCALE, MT_CB),					// 0x015A
	MSGDESCENTRY(CB_INSERTSTRING, MT_CB),				// 0x014A
	MSGDESCENTRY(CB_LIMITTEXT, MT_CB),					// 0x0141
	MSGDESCENTRY(CB_RESETCONTENT, MT_CB),				// 0x014B
	MSGDESCENTRY(CB_SELECTSTRING, MT_CB),				// 0x014D
	MSGDESCENTRY(CB_SETCURSEL, MT_CB),					// 0x014E
	MSGDESCENTRY(CB_SETEDITSEL, MT_CB),					// 0x0142
	MSGDESCENTRY(CB_SETEXTENDEDUI, MT_CB),				// 0x0155
	MSGDESCENTRY(CB_SETITEMDATA, MT_CB),				// 0x0151
	MSGDESCENTRY(CB_SETITEMHEIGHT, MT_CB),				// 0x0153
	MSGDESCENTRY(CB_SETLOCALE, MT_CB),					// 0x0159
	MSGDESCENTRY(CB_SHOWDROPDOWN, MT_CB),				// 0x014F

	MSGDESCENTRY(DM_GETDEFID, MT_DLG),					// WM_USER+0
	MSGDESCENTRY(DM_SETDEFID, MT_DLG),					// WM_USER+1

	MSGDESCENTRY(EM_CANUNDO, MT_EM),					// 0x00C6
	MSGDESCENTRY(EM_EMPTYUNDOBUFFER, MT_EM),			// 0x00CD
	MSGDESCENTRY(EM_FMTLINES, MT_EM),					// 0x00C8
	MSGDESCENTRY(EM_GETFIRSTVISIBLELINE, MT_EM),		// 0x00CE
	MSGDESCENTRY(EM_GETHANDLE, MT_EM),					// 0x00BD
	MSGDESCENTRY(EM_GETLINE, MT_EM),					// 0x00C4
	MSGDESCENTRY(EM_GETLINECOUNT, MT_EM),				// 0x00BA
	MSGDESCENTRY(EM_GETMODIFY, MT_EM),					// 0x00B8
	MSGDESCENTRY(EM_GETPASSWORDCHAR, MT_EM),			// 0x00D2
	MSGDESCENTRY(EM_GETRECT, MT_EM),					// 0x00B2
	MSGDESCENTRY(EM_GETSEL, MT_EM),						// 0x00B0
	MSGDESCENTRY(EM_GETWORDBREAKPROC, MT_EM),			// 0x00D1
	MSGDESCENTRY(EM_LIMITTEXT, MT_EM),					// 0x00C5
	MSGDESCENTRY(EM_LINEFROMCHAR, MT_EM),				// 0x00C9
	MSGDESCENTRY(EM_LINEINDEX, MT_EM),					// 0x00BB
	MSGDESCENTRY(EM_LINELENGTH, MT_EM),					// 0x00C1
	MSGDESCENTRY(EM_LINESCROLL, MT_EM),					// 0x00B6
	MSGDESCENTRY(EM_REPLACESEL, MT_EM),					// 0x00C2
	MSGDESCENTRY(EM_SCROLL, MT_EM),						// 0x00B5
	MSGDESCENTRY(EM_SCROLLCARET, MT_EM),				// 0x00B7
	MSGDESCENTRY(EM_SETHANDLE, MT_EM),					// 0x00BC
	MSGDESCENTRY(EM_SETMODIFY, MT_EM),					// 0x00B9
	MSGDESCENTRY(EM_SETPASSWORDCHAR, MT_EM),			// 0x00CC
	MSGDESCENTRY(EM_SETREADONLY, MT_EM),				// 0x00CF
	MSGDESCENTRY(EM_SETRECT, MT_EM),					// 0x00B3
	MSGDESCENTRY(EM_SETRECTNP, MT_EM),					// 0x00B4
	MSGDESCENTRY(EM_SETSEL, MT_EM),						// 0x00B1
	MSGDESCENTRY(EM_SETTABSTOPS, MT_EM),				// 0x00CB
	MSGDESCENTRY(EM_SETWORDBREAKPROC, MT_EM),			// 0x00D0
	MSGDESCENTRY(EM_UNDO, MT_EM),						// 0x00C7

#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(HDM_DELETEITEM, MT_HDR),				// WM_USER+
	MSGDESCENTRY(HDM_GETITEM, MT_HDR),					// WM_USER+
	MSGDESCENTRY(HDM_GETITEMCOUNT, MT_HDR),				// WM_USER+
	MSGDESCENTRY(HDM_HITTEST, MT_HDR),					// WM_USER+
	MSGDESCENTRY(HDM_INSERTITEM, MT_HDR),				// WM_USER+
	MSGDESCENTRY(HDM_LAYOUT, MT_HDR),					// WM_USER+
	MSGDESCENTRY(HDM_SETITEM, MT_HDR),					// WM_USER+
#endif	// DISABLE_WIN95_MESSAGES

#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(HKM_GETHOTKEY, MT_HK),					// WM_USER+
	MSGDESCENTRY(HKM_SETHOTKEY, MT_HK),					// WM_USER+
	MSGDESCENTRY(HKM_SETRULES, MT_HK),					// WM_USER+
#endif	// DISABLE_WIN95_MESSAGES

	MSGDESCENTRY(LB_ADDFILE, MT_LB),					// 0x0196
	MSGDESCENTRY(LB_ADDSTRING, MT_LB),					// 0x0180
	MSGDESCENTRY(LB_DELETESTRING, MT_LB),				// 0x0182
	MSGDESCENTRY(LB_DIR, MT_LB),						// 0x018D
	MSGDESCENTRY(LB_FINDSTRING, MT_LB),					// 0x018F
	MSGDESCENTRY(LB_FINDSTRINGEXACT, MT_LB),			// 0x01A2
	MSGDESCENTRY(LB_GETANCHORINDEX, MT_LB),				// 0x019D
	MSGDESCENTRY(LB_GETCARETINDEX, MT_LB),				// 0x019F
	MSGDESCENTRY(LB_GETCOUNT, MT_LB),					// 0x018B
	MSGDESCENTRY(LB_GETCURSEL, MT_LB),					// 0x0188
	MSGDESCENTRY(LB_GETHORIZONTALEXTENT, MT_LB),		// 0x0193
	MSGDESCENTRY(LB_GETITEMDATA, MT_LB),				// 0x0199
	MSGDESCENTRY(LB_GETITEMHEIGHT, MT_LB),				// 0x01A1
	MSGDESCENTRY(LB_GETITEMRECT, MT_LB),				// 0x0198
	MSGDESCENTRY(LB_GETLOCALE, MT_LB),					// 0x01A6
	MSGDESCENTRY(LB_GETSEL, MT_LB),						// 0x0187
	MSGDESCENTRY(LB_GETSELCOUNT, MT_LB),				// 0x0190
	MSGDESCENTRY(LB_GETSELITEMS, MT_LB),				// 0x0191
	MSGDESCENTRY(LB_GETTEXT, MT_LB),					// 0x0189
	MSGDESCENTRY(LB_GETTEXTLEN, MT_LB),					// 0x018A
	MSGDESCENTRY(LB_GETTOPINDEX, MT_LB),				// 0x018E
	MSGDESCENTRY(LB_INSERTSTRING, MT_LB),				// 0x0181
	MSGDESCENTRY(LB_RESETCONTENT, MT_LB),				// 0x0184
	MSGDESCENTRY(LB_SELECTSTRING, MT_LB),				// 0x018C
	MSGDESCENTRY(LB_SELITEMRANGE, MT_LB),				// 0x019B
	MSGDESCENTRY(LB_SELITEMRANGEEX, MT_LB),				// 0x0183
	MSGDESCENTRY(LB_SETANCHORINDEX, MT_LB),				// 0x019C
	MSGDESCENTRY(LB_SETCARETINDEX, MT_LB),				// 0x019E
	MSGDESCENTRY(LB_SETCOLUMNWIDTH, MT_LB),				// 0x0195
	MSGDESCENTRY(LB_SETCOUNT, MT_LB),					// 0x01A7
	MSGDESCENTRY(LB_SETCURSEL, MT_LB),					// 0x0186
	MSGDESCENTRY(LB_SETHORIZONTALEXTENT, MT_LB),		// 0x0194
	MSGDESCENTRY(LB_SETITEMDATA, MT_LB),				// 0x019A
	MSGDESCENTRY(LB_SETITEMHEIGHT, MT_LB),				// 0x01A0
	MSGDESCENTRY(LB_SETLOCALE, MT_LB),					// 0x01A5
	MSGDESCENTRY(LB_SETSEL, MT_LB),						// 0x0185
	MSGDESCENTRY(LB_SETTABSTOPS, MT_LB),				// 0x0192
	MSGDESCENTRY(LB_SETTOPINDEX, MT_LB),				// 0x0197

#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(LVM_ARRANGE, MT_LV),					// WM_USER+
	MSGDESCENTRY(LVM_CREATEDRAGIMAGE, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_DELETEALLITEMS, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_DELETECOLUMN, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_DELETEITEM, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_EDITLABEL, MT_LV),					// WM_USER+
	MSGDESCENTRY(LVM_ENSUREVISIBLE, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_FINDITEM, MT_LV),					// WM_USER+
	MSGDESCENTRY(LVM_GETBKCOLOR, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_GETCALLBACKMASK, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_GETCOLUMN, MT_LV),					// WM_USER+
	MSGDESCENTRY(LVM_GETCOLUMNWIDTH, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_GETCOUNTPERPAGE, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_GETEDITCONTROL, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_GETIMAGELIST, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_GETISEARCHSTRING, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_GETITEM, MT_LV),					// WM_USER+
	MSGDESCENTRY(LVM_GETITEMCOUNT, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_GETITEMPOSITION, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_GETITEMRECT, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_GETITEMSPACING, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_GETITEMSTATE, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_GETITEMTEXT, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_GETNEXTITEM, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_GETORIGIN, MT_LV),					// WM_USER+
	MSGDESCENTRY(LVM_GETSELECTEDCOUNT, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_GETSTRINGWIDTH, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_GETTEXTBKCOLOR, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_GETTEXTCOLOR, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_GETTOPINDEX, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_GETVIEWRECT, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_HITTEST, MT_LV),					// WM_USER+
	MSGDESCENTRY(LVM_INSERTCOLUMN, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_INSERTITEM, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_REDRAWITEMS, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_SCROLL, MT_LV),					// WM_USER+
	MSGDESCENTRY(LVM_SETBKCOLOR, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_SETCALLBACKMASK, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_SETCOLUMN, MT_LV),					// WM_USER+
	MSGDESCENTRY(LVM_SETCOLUMNWIDTH, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_SETIMAGELIST, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_SETITEM, MT_LV),					// WM_USER+
	MSGDESCENTRY(LVM_SETITEMCOUNT, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_SETITEMPOSITION, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_SETITEMPOSITION32, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_SETITEMSTATE, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_SETITEMTEXT, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_SETTEXTBKCOLOR, MT_LV),			// WM_USER+
	MSGDESCENTRY(LVM_SETTEXTCOLOR, MT_LV),				// WM_USER+
	MSGDESCENTRY(LVM_SORTITEMS, MT_LV),					// WM_USER+
	MSGDESCENTRY(LVM_UPDATE, MT_LV),					// WM_USER+
#endif	// DISABLE_WIN95_MESSAGES

#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(PBM_DELTAPOS, MT_PRG),					// WM_USER+
	MSGDESCENTRY(PBM_SETPOS, MT_PRG),					// WM_USER+
	MSGDESCENTRY(PBM_SETRANGE, MT_PRG),					// WM_USER+
	MSGDESCENTRY(PBM_SETSTEP, MT_PRG),					// WM_USER+
	MSGDESCENTRY(PBM_STEPIT, MT_PRG),					// WM_USER+
#endif	// DISABLE_WIN95_MESSAGES

	MSGDESCENTRY(SBM_ENABLE_ARROWS, MT_SBM),			// 0x00E4
	MSGDESCENTRY(SBM_GETPOS, MT_SBM),					// 0x00E1
	MSGDESCENTRY(SBM_GETRANGE, MT_SBM),					// 0x00E3
	MSGDESCENTRY(SBM_SETPOS, MT_SBM),					// 0x00E0
	MSGDESCENTRY(SBM_SETRANGE, MT_SBM),					// 0x00E2
	MSGDESCENTRY(SBM_SETRANGEREDRAW, MT_SBM),			// 0x00E6

#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(SB_GETBORDERS, MT_STB),				// WM_USER+
	MSGDESCENTRY(SB_GETPARTS, MT_STB),					// WM_USER+
	MSGDESCENTRY(SB_GETRECT, MT_STB),					// WM_USER+
	MSGDESCENTRY(SB_GETTEXT, MT_STB),					// WM_USER+
	MSGDESCENTRY(SB_GETTEXTLENGTH, MT_STB),				// WM_USER+
	MSGDESCENTRY(SB_SETMINHEIGHT, MT_STB),				// WM_USER+
	MSGDESCENTRY(SB_SETPARTS, MT_STB),					// WM_USER+
	MSGDESCENTRY(SB_SETTEXT, MT_STB),					// WM_USER+
	MSGDESCENTRY(SB_SIMPLE, MT_STB),					// WM_USER+
#endif	// DISABLE_WIN95_MESSAGES

	MSGDESCENTRY(STM_GETICON, MT_STM),					// 0x0171
	MSGDESCENTRY(STM_SETICON, MT_STM),					// 0x0170

#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(TBM_CLEARSEL, MT_TB),					// WM_USER+
	MSGDESCENTRY(TBM_CLEARTICS, MT_TB),					// WM_USER+
	MSGDESCENTRY(TBM_GETCHANNELRECT, MT_TB),			// WM_USER+
	MSGDESCENTRY(TBM_GETLINESIZE, MT_TB),				// WM_USER+
	MSGDESCENTRY(TBM_GETNUMTICS, MT_TB),				// WM_USER+
	MSGDESCENTRY(TBM_GETPAGESIZE, MT_TB),				// WM_USER+
	MSGDESCENTRY(TBM_GETPOS, MT_TB),					// WM_USER+
	MSGDESCENTRY(TBM_GETPTICS, MT_TB),					// WM_USER+
	MSGDESCENTRY(TBM_GETRANGEMAX, MT_TB),				// WM_USER+
	MSGDESCENTRY(TBM_GETRANGEMIN, MT_TB),				// WM_USER+
	MSGDESCENTRY(TBM_GETSELEND, MT_TB),					// WM_USER+
	MSGDESCENTRY(TBM_GETSELSTART, MT_TB),				// WM_USER+
	MSGDESCENTRY(TBM_GETTHUMBLENGTH, MT_TB),			// WM_USER+
	MSGDESCENTRY(TBM_GETTHUMBRECT, MT_TB),				// WM_USER+
	MSGDESCENTRY(TBM_GETTIC, MT_TB),					// WM_USER+
	MSGDESCENTRY(TBM_GETTICPOS, MT_TB),					// WM_USER+
	MSGDESCENTRY(TBM_SETLINESIZE, MT_TB),				// WM_USER+
	MSGDESCENTRY(TBM_SETPAGESIZE, MT_TB),				// WM_USER+
	MSGDESCENTRY(TBM_SETPOS, MT_TB),					// WM_USER+
	MSGDESCENTRY(TBM_SETRANGE, MT_TB),					// WM_USER+
	MSGDESCENTRY(TBM_SETRANGEMAX, MT_TB),				// WM_USER+
	MSGDESCENTRY(TBM_SETRANGEMIN, MT_TB),				// WM_USER+
	MSGDESCENTRY(TBM_SETSEL, MT_TB),					// WM_USER+
	MSGDESCENTRY(TBM_SETSELEND, MT_TB),					// WM_USER+
	MSGDESCENTRY(TBM_SETSELSTART, MT_TB),				// WM_USER+
	MSGDESCENTRY(TBM_SETTHUMBLENGTH, MT_TB),			// WM_USER+
	MSGDESCENTRY(TBM_SETTIC, MT_TB),					// WM_USER+
	MSGDESCENTRY(TBM_SETTICFREQ, MT_TB),				// WM_USER+
#endif	// DISABLE_WIN95_MESSAGES

#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(TB_ADDBITMAP, MT_TLB),					// WM_USER+
	MSGDESCENTRY(TB_ADDBUTTONS, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_ADDSTRING, MT_TLB),					// WM_USER+
	MSGDESCENTRY(TB_AUTOSIZE, MT_TLB),					// WM_USER+
	MSGDESCENTRY(TB_BUTTONCOUNT, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_BUTTONSTRUCTSIZE, MT_TLB),			// WM_USER+
	MSGDESCENTRY(TB_CHANGEBITMAP, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_CHECKBUTTON, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_COMMANDTOINDEX, MT_TLB),			// WM_USER+
	MSGDESCENTRY(TB_CUSTOMIZE, MT_TLB),					// WM_USER+
	MSGDESCENTRY(TB_DELETEBUTTON, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_ENABLEBUTTON, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_GETBITMAP, MT_TLB),					// WM_USER+
	MSGDESCENTRY(TB_GETBITMAPFLAGS, MT_TLB),			// WM_USER+
	MSGDESCENTRY(TB_GETBUTTON, MT_TLB),					// WM_USER+
	MSGDESCENTRY(TB_GETBUTTONTEXT, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_GETITEMRECT, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_GETROWS, MT_TLB),					// WM_USER+
	MSGDESCENTRY(TB_GETSTATE, MT_TLB),					// WM_USER+
	MSGDESCENTRY(TB_GETTOOLTIPS, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_HIDEBUTTON, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_INDETERMINATE, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_INSERTBUTTON, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_ISBUTTONCHECKED, MT_TLB),			// WM_USER+
	MSGDESCENTRY(TB_ISBUTTONENABLED, MT_TLB),			// WM_USER+
	MSGDESCENTRY(TB_ISBUTTONHIDDEN, MT_TLB),			// WM_USER+
	MSGDESCENTRY(TB_ISBUTTONINDETERMINATE, MT_TLB),		// WM_USER+
	MSGDESCENTRY(TB_ISBUTTONPRESSED, MT_TLB),			// WM_USER+
	MSGDESCENTRY(TB_PRESSBUTTON, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_SAVERESTORE, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_SETBITMAPSIZE, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_SETBUTTONSIZE, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_SETBUTTONTYPE, MT_TLB),				// WM_USER+
	MSGDESCENTRY(TB_SETCMDID, MT_TLB),					// WM_USER+
	MSGDESCENTRY(TB_SETPARENT, MT_TLB),					// WM_USER+
	MSGDESCENTRY(TB_SETROWS, MT_TLB),					// WM_USER+
	MSGDESCENTRY(TB_SETSTATE, MT_TLB),					// WM_USER+
	MSGDESCENTRY(TB_SETTOOLTIPS, MT_TLB),				// WM_USER+
#endif	// DISABLE_WIN95_MESSAGES

#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(TCM_ADJUSTRECT, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_DELETEALLITEMS, MT_TAB),			// WM_USER+
	MSGDESCENTRY(TCM_DELETEITEM, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_GETBKCOLOR, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_GETCURSEL, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_GETCURFOCUS, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_GETIMAGELIST, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_GETITEM, MT_TAB),					// WM_USER+
	MSGDESCENTRY(TCM_GETITEMCOUNT, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_GETITEMRECT, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_GETROWCOUNT, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_GETTOOLTIPS, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_HITTEST, MT_TAB),					// WM_USER+
	MSGDESCENTRY(TCM_INSERTITEM, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_REMOVEIMAGE, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_SETBKCOLOR, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_SETCURSEL, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_SETCURFOCUS, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_SETIMAGELIST, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_SETITEM, MT_TAB),					// WM_USER+
	MSGDESCENTRY(TCM_SETITEMEXTRA, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_SETITEMSIZE, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_SETPADDING, MT_TAB),				// WM_USER+
	MSGDESCENTRY(TCM_SETTOOLTIPS, MT_TAB),				// WM_USER+
#endif	// DISABLE_WIN95_MESSAGES

#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(TTM_ACTIVATE, MT_TT),					// WM_USER+
	MSGDESCENTRY(TTM_ADDTOOL, MT_TT),					// WM_USER+
	MSGDESCENTRY(TTM_DELTOOL, MT_TT),					// WM_USER+
	MSGDESCENTRY(TTM_ENUMTOOLS, MT_TT),					// WM_USER+
	MSGDESCENTRY(TTM_GETCURRENTTOOL, MT_TT),			// WM_USER+
	MSGDESCENTRY(TTM_GETTEXT, MT_TT),					// WM_USER+
	MSGDESCENTRY(TTM_GETTOOLCOUNT, MT_TT),				// WM_USER+
	MSGDESCENTRY(TTM_GETTOOLINFO, MT_TT),				// WM_USER+
	MSGDESCENTRY(TTM_HITTEST, MT_TT),					// WM_USER+
	MSGDESCENTRY(TTM_NEWTOOLRECT, MT_TT),				// WM_USER+
	MSGDESCENTRY(TTM_RELAYEVENT, MT_TT),				// WM_USER+
	MSGDESCENTRY(TTM_SETDELAYTIME, MT_TT),				// WM_USER+
	MSGDESCENTRY(TTM_SETTOOLINFO, MT_TT),				// WM_USER+
	MSGDESCENTRY(TTM_UPDATETIPTEXT, MT_TT),				// WM_USER+
#endif	// DISABLE_WIN95_MESSAGES

#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(TVM_CREATEDRAGIMAGE, MT_TV),			// WM_USER+
	MSGDESCENTRY(TVM_DELETEITEM, MT_TV),				// WM_USER+
	MSGDESCENTRY(TVM_EDITLABEL, MT_TV),					// WM_USER+
	MSGDESCENTRY(TVM_ENDEDITLABELNOW, MT_TV),			// WM_USER+
	MSGDESCENTRY(TVM_ENSUREVISIBLE, MT_TV),				// WM_USER+
	MSGDESCENTRY(TVM_EXPAND, MT_TV),					// WM_USER+
	MSGDESCENTRY(TVM_GETCOUNT, MT_TV),					// WM_USER+
	MSGDESCENTRY(TVM_GETEDITCONTROL, MT_TV),			// WM_USER+
	MSGDESCENTRY(TVM_GETIMAGELIST, MT_TV),				// WM_USER+
	MSGDESCENTRY(TVM_GETINDENT, MT_TV),					// WM_USER+
	MSGDESCENTRY(TVM_GETISEARCHSTRING, MT_TV),			// WM_USER+
	MSGDESCENTRY(TVM_GETITEM, MT_TV),					// WM_USER+
	MSGDESCENTRY(TVM_GETITEMRECT, MT_TV),				// WM_USER+
	MSGDESCENTRY(TVM_GETNEXTITEM, MT_TV),				// WM_USER+
	MSGDESCENTRY(TVM_GETVISIBLECOUNT, MT_TV),			// WM_USER+
	MSGDESCENTRY(TVM_HITTEST, MT_TV),					// WM_USER+
	MSGDESCENTRY(TVM_INSERTITEM, MT_TV),				// WM_USER+
	MSGDESCENTRY(TVM_SELECTITEM, MT_TV),				// WM_USER+
	MSGDESCENTRY(TVM_SETIMAGELIST, MT_TV),				// WM_USER+
	MSGDESCENTRY(TVM_SETINDENT, MT_TV),					// WM_USER+
	MSGDESCENTRY(TVM_SETITEM, MT_TV),					// WM_USER+
	MSGDESCENTRY(TVM_SORTCHILDREN, MT_TV),				// WM_USER+
	MSGDESCENTRY(TVM_SORTCHILDRENCB, MT_TV),			// WM_USER+
#endif	// DISABLE_WIN95_MESSAGES

#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(UDM_GETACCEL, MT_UD),					// WM_USER+
	MSGDESCENTRY(UDM_GETBASE, MT_UD),					// WM_USER+
	MSGDESCENTRY(UDM_GETBUDDY, MT_UD),					// WM_USER+
	MSGDESCENTRY(UDM_GETPOS, MT_UD),					// WM_USER+
	MSGDESCENTRY(UDM_GETRANGE, MT_UD),					// WM_USER+
	MSGDESCENTRY(UDM_SETACCEL, MT_UD),					// WM_USER+
	MSGDESCENTRY(UDM_SETBASE, MT_UD),					// WM_USER+
	MSGDESCENTRY(UDM_SETBUDDY, MT_UD),					// WM_USER+
	MSGDESCENTRY(UDM_SETPOS, MT_UD),					// WM_USER+
	MSGDESCENTRY(UDM_SETRANGE, MT_UD),					// WM_USER+
#endif	// DISABLE_WIN95_MESSAGES

	MSGDESCENTRY(WM_ACTIVATE, MT_MISC),					// 0x0006
	MSGDESCENTRY(WM_ACTIVATEAPP, MT_MISC),				// 0x001C
	MSGDESCENTRY(WM_ASKCBFORMATNAME, MT_CLIP),			// 0x030C
	MSGDESCENTRY(WM_CANCELJOURNAL, MT_MISC),			// 0x004B
	MSGDESCENTRY(WM_CANCELMODE, MT_MISC),				// 0x001F
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_CAPTURECHANGED, MT_MISC),			// 0x0215
#endif
	MSGDESCENTRY(WM_CHANGECBCHAIN, MT_CLIP),			// 0x030D
	MSGDESCENTRY(WM_CHAR, MT_KEYBD),					// 0x0102
	MSGDESCENTRY(WM_CHARTOITEM, MT_KEYBD),				// 0x002F
	MSGDESCENTRY(WM_CHILDACTIVATE, MT_MISC),			// 0x0022
	MSGDESCENTRY(WM_CLEAR, MT_CLIP),					// 0x0303
	MSGDESCENTRY(WM_CLOSE, MT_MISC),					// 0x0010
	MSGDESCENTRY(WM_COMMAND, MT_MISC),					// 0x0111
	MSGDESCENTRY(WM_COMPACTING, MT_MISC),				// 0x0041
	MSGDESCENTRY(WM_COMPAREITEM, MT_MISC),				// 0x0039
	MSGDESCENTRY(WM_CONVERTREQUESTEX, MT_IME),			// 0x0109
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_CONTEXTMENU, MT_MISC),				// 0x007B
#endif
	MSGDESCENTRY(WM_COPY, MT_CLIP),						// 0x0301
	MSGDESCENTRY(WM_COPYDATA, MT_MISC),					// 0x004A
	MSGDESCENTRY(WM_CREATE, MT_MISC),					// 0x0001
	MSGDESCENTRY(WM_CTLCOLORBTN, MT_MISC),				// 0x0135
	MSGDESCENTRY(WM_CTLCOLORDLG, MT_MISC),				// 0x0136
	MSGDESCENTRY(WM_CTLCOLOREDIT, MT_MISC),				// 0x0133
	MSGDESCENTRY(WM_CTLCOLORLISTBOX, MT_MISC),			// 0x0134
	MSGDESCENTRY(WM_CTLCOLORMSGBOX, MT_MISC),			// 0x0132
	MSGDESCENTRY(WM_CTLCOLORSCROLLBAR, MT_MISC),		// 0x0137
	MSGDESCENTRY(WM_CTLCOLORSTATIC, MT_MISC),			// 0x0138
	MSGDESCENTRY(WM_CUT, MT_CLIP),						// 0x0300

	MSGDESCENTRY(WM_DDE_ACK, MT_DDE),					// 0x03E4
	MSGDESCENTRY(WM_DDE_ADVISE, MT_DDE),				// 0x03E2
	MSGDESCENTRY(WM_DDE_DATA, MT_DDE),					// 0x03E5
	MSGDESCENTRY(WM_DDE_EXECUTE, MT_DDE),				// 0x03E8
	MSGDESCENTRY(WM_DDE_INITIATE, MT_DDE),				// 0x03E0
	MSGDESCENTRY(WM_DDE_POKE, MT_DDE),					// 0x03E7
	MSGDESCENTRY(WM_DDE_REQUEST, MT_DDE),				// 0x03E6
	MSGDESCENTRY(WM_DDE_TERMINATE, MT_DDE),				// 0x03E1
	MSGDESCENTRY(WM_DDE_UNADVISE, MT_DDE),				// 0x03E3

	MSGDESCENTRY(WM_DEADCHAR, MT_KEYBD),				// 0x0103
	MSGDESCENTRY(WM_DELETEITEM, MT_MISC),				// 0x002D
	MSGDESCENTRY(WM_DESTROY, MT_MISC),					// 0x0002
	MSGDESCENTRY(WM_DESTROYCLIPBOARD, MT_CLIP),			// 0x0307
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_DEVICECHANGE, MT_MISC),				// 0x0219
#endif
	MSGDESCENTRY(WM_DEVMODECHANGE, MT_MISC),			// 0x001B
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_DISPLAYCHANGE, MT_MISC),			// 0x007E
#endif
	MSGDESCENTRY(WM_DRAWCLIPBOARD, MT_CLIP),			// 0x0308
	MSGDESCENTRY(WM_DRAWITEM, MT_MISC),					// 0x002B
	MSGDESCENTRY(WM_DROPFILES, MT_MISC),				// 0x0233
	MSGDESCENTRY(WM_ENABLE, MT_MISC),					// 0x000A
	MSGDESCENTRY(WM_ENDSESSION, MT_MISC),				// 0x0016
	MSGDESCENTRY(WM_ENTERIDLE, MT_MISC),				// 0x0121
	MSGDESCENTRY(WM_ENTERMENULOOP, MT_MISC),			// 0x0211
	MSGDESCENTRY(WM_ERASEBKGND, MT_MISC),				// 0x0014
	MSGDESCENTRY(WM_EXITMENULOOP, MT_MISC),				// 0x0212
	MSGDESCENTRY(WM_FONTCHANGE, MT_MISC),				// 0x001D
	MSGDESCENTRY(WM_GETDLGCODE, MT_MISC),				// 0x0087
	MSGDESCENTRY(WM_GETFONT, MT_MISC),					// 0x0031
	MSGDESCENTRY(WM_GETHOTKEY, MT_KEYBD),				// 0x0033
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_GETICON, MT_MISC),					// 0x007F
#endif
	MSGDESCENTRY(WM_GETMINMAXINFO, MT_MISC),			// 0x0024
	MSGDESCENTRY(WM_GETTEXT, MT_MISC),					// 0x000D
	MSGDESCENTRY(WM_GETTEXTLENGTH, MT_MISC),			// 0x000E
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_HELP, MT_MISC),						// 0x0053
#endif
	MSGDESCENTRY(WM_HOTKEY, MT_KEYBD),					// 0x0312
	MSGDESCENTRY(WM_HSCROLL, MT_SBM),					// 0x0114
	MSGDESCENTRY(WM_HSCROLLCLIPBOARD, MT_CLIP),			// 0x030E
	MSGDESCENTRY(WM_ICONERASEBKGND, MT_MISC),			// 0x0027

	MSGDESCENTRY(WM_IMEKEYDOWN, MT_IME),				// 0x0290
	MSGDESCENTRY(WM_IMEKEYUP, MT_IME),					// 0x0291
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_IME_CHAR, MT_IME),					// 0x0286
	MSGDESCENTRY(WM_IME_COMPOSITION, MT_IME),			// 0x010F
	MSGDESCENTRY(WM_IME_COMPOSITIONFULL, MT_IME),		// 0x0284
	MSGDESCENTRY(WM_IME_CONTROL, MT_IME),				// 0x0283
	MSGDESCENTRY(WM_IME_ENDCOMPOSITION, MT_IME),		// 0x010E
	MSGDESCENTRY(WM_IME_KEYDOWN, MT_IME),				// 0x0290
	MSGDESCENTRY(WM_IME_KEYUP, MT_IME),					// 0x0291
	MSGDESCENTRY(WM_IME_NOTIFY, MT_IME),				// 0x0282
#endif
	MSGDESCENTRY(WM_IME_REPORT, MT_IME),				// 0x0280
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_IME_SELECT, MT_IME),				// 0x0285
	MSGDESCENTRY(WM_IME_SETCONTEXT, MT_IME),			// 0x0281
	MSGDESCENTRY(WM_IME_STARTCOMPOSITION, MT_IME),		// 0x010D
#endif
	MSGDESCENTRY(WM_INITDIALOG, MT_MISC),				// 0x0110
	MSGDESCENTRY(WM_INITMENU, MT_MISC),					// 0x0116
	MSGDESCENTRY(WM_INITMENUPOPUP, MT_MISC),			// 0x0117
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_INPUTLANGCHANGE, MT_MISC),			// 0x0051
	MSGDESCENTRY(WM_INPUTLANGCHANGEREQUEST, MT_MISC),	// 0x0050
#endif
	MSGDESCENTRY(WM_KEYDOWN, MT_KEYBD),					// 0x0100
	MSGDESCENTRY(WM_KEYUP, MT_KEYBD),					// 0x0101
	MSGDESCENTRY(WM_KILLFOCUS, MT_MISC),				// 0x0008
	MSGDESCENTRY(WM_LBUTTONDBLCLK, MT_MOUSE),			// 0x0203
	MSGDESCENTRY(WM_LBUTTONDOWN, MT_MOUSE),				// 0x0201
	MSGDESCENTRY(WM_LBUTTONUP, MT_MOUSE),				// 0x0202
	MSGDESCENTRY(WM_MBUTTONDBLCLK, MT_MOUSE),			// 0x0209
	MSGDESCENTRY(WM_MBUTTONDOWN, MT_MOUSE),				// 0x0207
	MSGDESCENTRY(WM_MBUTTONUP, MT_MOUSE),				// 0x0208

	MSGDESCENTRY(WM_MDIACTIVATE, MT_MDI),				// 0x0222
	MSGDESCENTRY(WM_MDICASCADE, MT_MDI),				// 0x0227
	MSGDESCENTRY(WM_MDICREATE, MT_MDI),					// 0x0220
	MSGDESCENTRY(WM_MDIDESTROY, MT_MDI),				// 0x0221
	MSGDESCENTRY(WM_MDIGETACTIVE, MT_MDI),				// 0x0229
	MSGDESCENTRY(WM_MDIICONARRANGE, MT_MDI),			// 0x0228
	MSGDESCENTRY(WM_MDIMAXIMIZE, MT_MDI),				// 0x0225
	MSGDESCENTRY(WM_MDINEXT, MT_MDI),					// 0x0224
	MSGDESCENTRY(WM_MDIREFRESHMENU, MT_MDI),			// 0x0234
	MSGDESCENTRY(WM_MDIRESTORE, MT_MDI),				// 0x0223
	MSGDESCENTRY(WM_MDISETMENU, MT_MDI),				// 0x0230
	MSGDESCENTRY(WM_MDITILE, MT_MDI),					// 0x0226

	MSGDESCENTRY(WM_MEASUREITEM, MT_MISC),				// 0x002C
	MSGDESCENTRY(WM_MENUCHAR, MT_MISC),					// 0x0120
	MSGDESCENTRY(WM_MENUSELECT, MT_MISC),				// 0x011F
	MSGDESCENTRY(WM_MOUSEACTIVATE, MT_MOUSE),			// 0x0021
#endif 	// FEWMESSAGES
	MSGDESCENTRY(WM_MOUSEMOVE, MT_MOUSE),				// 0x0200
#ifndef FEWMESSAGES
	MSGDESCENTRY(WM_MOVE, MT_MISC),						// 0x0003
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_MOVING, MT_MISC),					// 0x0216
#endif
	MSGDESCENTRY(WM_NCACTIVATE, MT_NC),					// 0x0086
	MSGDESCENTRY(WM_NCCALCSIZE, MT_NC),					// 0x0083
	MSGDESCENTRY(WM_NCCREATE, MT_NC),					// 0x0081
	MSGDESCENTRY(WM_NCDESTROY, MT_NC),					// 0x0082
	MSGDESCENTRY(WM_NCHITTEST, MT_NC),					// 0x0084
	MSGDESCENTRY(WM_NCLBUTTONDBLCLK, MT_NC),			// 0x00A3
	MSGDESCENTRY(WM_NCLBUTTONDOWN, MT_NC),				// 0x00A1
	MSGDESCENTRY(WM_NCLBUTTONUP, MT_NC),				// 0x00A2
	MSGDESCENTRY(WM_NCMBUTTONDBLCLK, MT_NC),			// 0x00A9
	MSGDESCENTRY(WM_NCMBUTTONDOWN, MT_NC),				// 0x00A7
	MSGDESCENTRY(WM_NCMBUTTONUP, MT_NC),				// 0x00A8
	MSGDESCENTRY(WM_NCMOUSEMOVE, MT_NC),				// 0x00A0
	MSGDESCENTRY(WM_NCPAINT, MT_NC),					// 0x0085
	MSGDESCENTRY(WM_NCRBUTTONDBLCLK, MT_NC),			// 0x00A6
	MSGDESCENTRY(WM_NCRBUTTONDOWN, MT_NC),				// 0x00A4
	MSGDESCENTRY(WM_NCRBUTTONUP, MT_NC),				// 0x00A5

	MSGDESCENTRY(WM_NEXTDLGCTL, MT_MISC),				// 0x0028
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_NEXTMENU, MT_MISC),					// 0x0213
#endif
	MSGDESCENTRY(WM_NOTIFY, MT_MISC),					// 0x004E
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_NOTIFYFORMAT, MT_MISC),				// 0x0055
#endif
	MSGDESCENTRY(WM_NULL, MT_MISC),						// 0x0000
	MSGDESCENTRY(WM_PAINT, MT_MISC),					// 0x000F
	MSGDESCENTRY(WM_PAINTCLIPBOARD, MT_CLIP),			// 0x0309
	MSGDESCENTRY(WM_PAINTICON, MT_MISC),				// 0x0026
	MSGDESCENTRY(WM_PALETTECHANGED, MT_MISC),			// 0x0311
	MSGDESCENTRY(WM_PALETTEISCHANGING, MT_MISC),		// 0x0310
	MSGDESCENTRY(WM_PARENTNOTIFY, MT_MOUSE),			// 0x0210
	MSGDESCENTRY(WM_PASTE, MT_CLIP),					// 0x0302
	MSGDESCENTRY(WM_POWER, MT_MISC),					// 0x0048
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_POWERBROADCAST, MT_MISC),			// 0x0218
	MSGDESCENTRY(WM_PRINT, MT_MISC),					// 0x0317
	MSGDESCENTRY(WM_PRINTCLIENT, MT_MISC),				// 0x0318
#endif
	MSGDESCENTRY(WM_QUERYDRAGICON, MT_MISC),			// 0x0037
	MSGDESCENTRY(WM_QUERYENDSESSION, MT_MISC),			// 0x0011
	MSGDESCENTRY(WM_QUERYNEWPALETTE, MT_MISC),			// 0x030F
	MSGDESCENTRY(WM_QUERYOPEN, MT_MISC),				// 0x0013
	MSGDESCENTRY(WM_QUEUESYNC, MT_MISC),				// 0x0023
	MSGDESCENTRY(WM_QUIT, MT_MISC),						// 0x0012
	MSGDESCENTRY(WM_RBUTTONDBLCLK, MT_MOUSE),			// 0x0206
	MSGDESCENTRY(WM_RBUTTONDOWN, MT_MOUSE),				// 0x0204
	MSGDESCENTRY(WM_RBUTTONUP, MT_MOUSE),				// 0x0205
	MSGDESCENTRY(WM_RENDERALLFORMATS, MT_CLIP),			// 0x0306
	MSGDESCENTRY(WM_RENDERFORMAT, MT_CLIP),				// 0x0305
	MSGDESCENTRY(WM_SETCURSOR, MT_MOUSE),				// 0x0020
	MSGDESCENTRY(WM_SETFOCUS, MT_MISC),					// 0x0007
	MSGDESCENTRY(WM_SETFONT, MT_MISC),					// 0x0030
	MSGDESCENTRY(WM_SETHOTKEY, MT_KEYBD),				// 0x0032
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_SETICON, MT_MISC),					// 0x0080
#endif
	MSGDESCENTRY(WM_SETREDRAW, MT_MISC),				// 0x000B
	MSGDESCENTRY(WM_SETTEXT, MT_MISC),					// 0x000C
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_SETTINGCHANGE, MT_MISC),			// 0x001A
#endif
	MSGDESCENTRY(WM_SHOWWINDOW, MT_MISC),				// 0x0018
	MSGDESCENTRY(WM_SIZE, MT_MISC),						// 0x0005
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_SIZING, MT_MISC),					// 0x0214
#endif
	MSGDESCENTRY(WM_SIZECLIPBOARD, MT_CLIP),			// 0x030B
	MSGDESCENTRY(WM_SPOOLERSTATUS, MT_MISC),			// 0x002A
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_STYLECHANGED, MT_MISC),				// 0x007D
	MSGDESCENTRY(WM_STYLECHANGING, MT_MISC),			// 0x007C
#endif
	MSGDESCENTRY(WM_SYSCHAR, MT_KEYBD),					// 0x0106
	MSGDESCENTRY(WM_SYSCOLORCHANGE, MT_MISC),			// 0x0015
	MSGDESCENTRY(WM_SYSCOMMAND, MT_MISC),				// 0x0112
	MSGDESCENTRY(WM_SYSDEADCHAR, MT_KEYBD),				// 0x0107
	MSGDESCENTRY(WM_SYSKEYDOWN, MT_KEYBD),				// 0x0104
	MSGDESCENTRY(WM_SYSKEYUP, MT_KEYBD),				// 0x0105
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_TCARD, MT_MISC),					// 0x0052
#endif
	MSGDESCENTRY(WM_TIMECHANGE, MT_MISC),				// 0x001E
	MSGDESCENTRY(WM_TIMER, MT_MISC),					// 0x0113
	MSGDESCENTRY(WM_UNDO, MT_CLIP),						// 0x0304
#ifndef DISABLE_WIN95_MESSAGES
	MSGDESCENTRY(WM_USERCHANGED, MT_MISC),				// 0x0054
#endif
	MSGDESCENTRY(WM_VKEYTOITEM, MT_KEYBD),				// 0x002E
	MSGDESCENTRY(WM_VSCROLL, MT_SBM),					// 0x0115
	MSGDESCENTRY(WM_VSCROLLCLIPBOARD, MT_CLIP),			// 0x030A
	MSGDESCENTRY(WM_WINDOWPOSCHANGED, MT_MISC),			// 0x0047
	MSGDESCENTRY(WM_WINDOWPOSCHANGING, MT_MISC),		// 0x0046
	MSGDESCENTRY(WM_WININICHANGE, MT_MISC)			  	// 0x001A
#endif 	//FEWMESSAGES
};

int CMsgDoc::m_cMsgs = sizeof(CMsgDoc::m_aMsgDesc) / sizeof(MSGDESC);
int CMsgDoc::m_iInitialTab = -1;



//-----------------------------------------------------------------------------
// CMsgDoc::InitStaticData
//-----------------------------------------------------------------------------

void CMsgDoc::InitStaticData(HKEY hkey)
{
	INT i;
	BYTE abMsgs[128];
	BYTE abDlgMsgs[MAX_DLG_MESSAGES/sizeof(BYTE)+1];
#ifndef DISABLE_WIN95_MESSAGES
	BYTE abAniMsgs[MAX_ANI_MESSAGES/sizeof(BYTE)+1];
	BYTE abHdrMsgs[MAX_HDR_MESSAGES/sizeof(BYTE)+1];
	BYTE abTBMsgs[MAX_TB_MESSAGES/sizeof(BYTE)+1];
	BYTE abTTMsgs[MAX_TT_MESSAGES/sizeof(BYTE)+1];
	BYTE abStatMsgs[MAX_STAT_MESSAGES/sizeof(BYTE)+1];
	BYTE abTrkMsgs[MAX_TRK_MESSAGES/sizeof(BYTE)+1];
	BYTE abUpDnMsgs[MAX_UD_MESSAGES/sizeof(BYTE)+1];
	BYTE abProgMsgs[MAX_PROG_MESSAGES/sizeof(BYTE)+1];
	BYTE abHKMsgs[MAX_HK_MESSAGES/sizeof(BYTE)+1];
	BYTE abLVMsgs[MAX_LV_MESSAGES/sizeof(BYTE)+1];
	BYTE abTVMsgs[MAX_TV_MESSAGES/sizeof(BYTE)+1];
	BYTE abTabMsgs[MAX_TAB_MESSAGES/sizeof(BYTE)+1];
#endif	// DISABLE_WIN95_MESSAGES
	DWORD cbData;
	DWORD dwType;
	DWORD fFlags;
	INT cLinesMax;
	CHAR szFile[_MAX_PATH];

	for (i = 0; i < m_cMsgs; i++)
	{
		//
		// Set the appropriate message descriptor lookup table entry.
		//
		if (m_aMsgDesc[i].msg >= 0 && m_aMsgDesc[i].msg < WM_USER)
			m_apmdLT[m_aMsgDesc[i].msg] = &m_aMsgDesc[i];
		else if (m_aMsgDesc[i].iMsgType == MT_DLG && m_aMsgDesc[i].msg >= WM_USER)
			m_apmdDlgLT[m_aMsgDesc[i].msg - WM_USER] = &m_aMsgDesc[i];
#ifndef DISABLE_WIN95_MESSAGES
		else if (m_aMsgDesc[i].iMsgType == MT_ANI && m_aMsgDesc[i].msg >= (WM_USER+100))
			m_apmdAniLT[m_aMsgDesc[i].msg - (WM_USER+100)] = &m_aMsgDesc[i];
		else if (m_aMsgDesc[i].iMsgType == MT_HDR && m_aMsgDesc[i].msg >= HDM_FIRST)
			m_apmdHdrLT[m_aMsgDesc[i].msg - HDM_FIRST] = &m_aMsgDesc[i];
		else if (m_aMsgDesc[i].iMsgType == MT_HK && m_aMsgDesc[i].msg >= (WM_USER+1))
			m_apmdHKLT[m_aMsgDesc[i].msg - (WM_USER+1)] = &m_aMsgDesc[i];
		else if (m_aMsgDesc[i].iMsgType == MT_LV && m_aMsgDesc[i].msg >= LVM_FIRST)
			m_apmdLVLT[m_aMsgDesc[i].msg - LVM_FIRST] = &m_aMsgDesc[i];
		else if (m_aMsgDesc[i].iMsgType == MT_PRG && m_aMsgDesc[i].msg >= (WM_USER+1))
			m_apmdProgLT[m_aMsgDesc[i].msg - (WM_USER+1)] = &m_aMsgDesc[i];
		else if (m_aMsgDesc[i].iMsgType == MT_STB && m_aMsgDesc[i].msg >= (WM_USER+1))
			m_apmdStatLT[m_aMsgDesc[i].msg - (WM_USER+1)] = &m_aMsgDesc[i];
		else if (m_aMsgDesc[i].iMsgType == MT_TB && m_aMsgDesc[i].msg >= WM_USER)
			m_apmdTrkLT[m_aMsgDesc[i].msg - WM_USER] = &m_aMsgDesc[i];
		else if (m_aMsgDesc[i].iMsgType == MT_TLB && m_aMsgDesc[i].msg >= (WM_USER+1))
			m_apmdTBLT[m_aMsgDesc[i].msg - (WM_USER+1)] = &m_aMsgDesc[i];
		else if (m_aMsgDesc[i].iMsgType == MT_TAB && m_aMsgDesc[i].msg >= TCM_FIRST)
			m_apmdTabLT[m_aMsgDesc[i].msg - TCM_FIRST] = &m_aMsgDesc[i];
		else if (m_aMsgDesc[i].iMsgType == MT_TT && m_aMsgDesc[i].msg >= (WM_USER+1))
			m_apmdTTLT[m_aMsgDesc[i].msg - (WM_USER+1)] = &m_aMsgDesc[i];
		else if (m_aMsgDesc[i].iMsgType == MT_TV && m_aMsgDesc[i].msg >= TV_FIRST)
			m_apmdTVLT[m_aMsgDesc[i].msg - TV_FIRST] = &m_aMsgDesc[i];
		else if (m_aMsgDesc[i].iMsgType == MT_UD && m_aMsgDesc[i].msg >= (WM_USER+101))
			m_apmdUpDnLT[m_aMsgDesc[i].msg - (WM_USER+101)] = &m_aMsgDesc[i];
#endif	// DISABLE_WIN95_MESSAGES
	}

	cbData = sizeof(abMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyMsgFiltersMask, NULL, &dwType, abMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_MESSAGES; i++)
		{
			if (abMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afSelectedDef[i] = TRUE;
		}
	}
	else
	{
		//
		// Select all messages by default
		//
		for (i = 0; i < MAX_MESSAGES; i++)
			m_afSelectedDef[i] = TRUE;
	}

	cbData = sizeof(abDlgMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyDlgMsgFiltersMask, NULL, &dwType, abDlgMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_DLG_MESSAGES; i++)
		{
			if (abDlgMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afDlgSelectedDef[i] = TRUE;
		}
	}
	else
	{
		for (i = 0; i < MAX_DLG_MESSAGES; i++)
			m_afDlgSelectedDef[i] = TRUE;
	}

#ifndef DISABLE_WIN95_MESSAGES
	cbData = sizeof(abAniMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyAniMsgFiltersMask, NULL, &dwType, abAniMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_ANI_MESSAGES; i++)
		{
			if (abAniMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afAniSelectedDef[i] = TRUE;
		}
	}
	else
	{
		for (i = 0; i < MAX_ANI_MESSAGES; i++)
			m_afAniSelectedDef[i] = TRUE;
	}

	cbData = sizeof(abHdrMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyHdrMsgFiltersMask, NULL, &dwType, abHdrMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_HDR_MESSAGES; i++)
		{
			if (abHdrMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afHdrSelectedDef[i] = TRUE;
		}
	}
	else
	{
		for (i = 0; i < MAX_HDR_MESSAGES; i++)
			m_afHdrSelectedDef[i] = TRUE;
	}

	cbData = sizeof(abTBMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyTBMsgFiltersMask, NULL, &dwType, abTBMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_TB_MESSAGES; i++)
		{
			if (abTBMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afTBSelectedDef[i] = TRUE;
		}
	}
	else
	{
		for (i = 0; i < MAX_TB_MESSAGES; i++)
			m_afTBSelectedDef[i] = TRUE;
	}

	cbData = sizeof(abTTMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyTTMsgFiltersMask, NULL, &dwType, abTTMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_TT_MESSAGES; i++)
		{
			if (abTTMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afTTSelectedDef[i] = TRUE;
		}
	}
	else
	{
		for (i = 0; i < MAX_TT_MESSAGES; i++)
			m_afTTSelectedDef[i] = TRUE;
	}

	cbData = sizeof(abStatMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyStatMsgFiltersMask, NULL, &dwType, abStatMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_STAT_MESSAGES; i++)
		{
			if (abStatMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afStatSelectedDef[i] = TRUE;
		}
	}
	else
	{
		for (i = 0; i < MAX_STAT_MESSAGES; i++)
			m_afStatSelectedDef[i] = TRUE;
	}

	cbData = sizeof(abTrkMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyTrkMsgFiltersMask, NULL, &dwType, abTrkMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_TRK_MESSAGES; i++)
		{
			if (abTrkMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afTrkSelectedDef[i] = TRUE;
		}
	}
	else
	{
		for (i = 0; i < MAX_TRK_MESSAGES; i++)
			m_afTrkSelectedDef[i] = TRUE;
	}

	cbData = sizeof(abUpDnMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyUpDnMsgFiltersMask, NULL, &dwType, abUpDnMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_UD_MESSAGES; i++)
		{
			if (abUpDnMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afUpDnSelectedDef[i] = TRUE;
		}
	}
	else
	{
		for (i = 0; i < MAX_UD_MESSAGES; i++)
			m_afUpDnSelectedDef[i] = TRUE;
	}

	cbData = sizeof(abProgMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyProgMsgFiltersMask, NULL, &dwType, abProgMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_PROG_MESSAGES; i++)
		{
			if (abProgMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afProgSelectedDef[i] = TRUE;
		}
	}
	else
	{
		for (i = 0; i < MAX_PROG_MESSAGES; i++)
			m_afProgSelectedDef[i] = TRUE;
	}

	cbData = sizeof(abHKMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyHKMsgFiltersMask, NULL, &dwType, abHKMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_HK_MESSAGES; i++)
		{
			if (abHKMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afHKSelectedDef[i] = TRUE;
		}
	}
	else
	{
		for (i = 0; i < MAX_HK_MESSAGES; i++)
			m_afHKSelectedDef[i] = TRUE;
	}

	cbData = sizeof(abLVMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyLVMsgFiltersMask, NULL, &dwType, abLVMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_LV_MESSAGES; i++)
		{
			if (abLVMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afLVSelectedDef[i] = TRUE;
		}
	}
	else
	{
		for (i = 0; i < MAX_LV_MESSAGES; i++)
			m_afLVSelectedDef[i] = TRUE;
	}

	cbData = sizeof(abTVMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyTVMsgFiltersMask, NULL, &dwType, abTVMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_TV_MESSAGES; i++)
		{
			if (abTVMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afTVSelectedDef[i] = TRUE;
		}
	}
	else
	{
		for (i = 0; i < MAX_TV_MESSAGES; i++)
			m_afTVSelectedDef[i] = TRUE;
	}

	cbData = sizeof(abTabMsgs);
	if (hkey && RegQueryValueEx(hkey, m_szKeyTabMsgFiltersMask, NULL, &dwType, abTabMsgs, &cbData) == ERROR_SUCCESS)
	{
		for (i = 0; i < MAX_TAB_MESSAGES; i++)
		{
			if (abTabMsgs[(UINT)i >> 3] & m_BitTable[i & 0x07])
				m_afTabSelectedDef[i] = TRUE;
		}
	}
	else
	{
		for (i = 0; i < MAX_TAB_MESSAGES; i++)
			m_afTabSelectedDef[i] = TRUE;
	}
#endif	// DISABLE_WIN95_MESSAGES

	cbData = sizeof(DWORD);
	if (hkey && RegQueryValueEx(hkey, m_szKeyMsgFilters, NULL, &dwType, (LPBYTE)&fFlags, &cbData) == ERROR_SUCCESS)
	{
		if (fFlags & REGFLAG_MSGFILTERS_USER)
			m_fMsgsUserDef = TRUE;

		if (fFlags & REGFLAG_MSGFILTERS_REGISTERED)
			m_fMsgsRegisteredDef = TRUE;

		if (fFlags & REGFLAG_MSGFILTERS_UNDOCUMENTED)
			m_fMsgsUndocumentedDef = TRUE;
	}
	else
	{
		//
		// Select all messages by default
		//
		m_fMsgsUserDef = TRUE;
		m_fMsgsRegisteredDef = TRUE;
		m_fMsgsUndocumentedDef = TRUE;
	}

	cbData = sizeof(DWORD);
	if (hkey && RegQueryValueEx(hkey, m_szKeyWinFilters, NULL, &dwType, (LPBYTE)&fFlags, &cbData) == ERROR_SUCCESS)
	{
		if (fFlags & REGFLAG_WINFILTERS_INCPARENT)
			m_fIncludeParentDef = TRUE;

		if (fFlags & REGFLAG_WINFILTERS_INCCHILDREN)
			m_fIncludeChildrenDef = TRUE;

		if (fFlags & REGFLAG_WINFILTERS_INCPROCESS)
			m_fIncludeProcessDef = TRUE;

		if (fFlags & REGFLAG_WINFILTERS_INCTHREAD)
			m_fIncludeThreadDef = TRUE;
	}
	else
	{
		//
		// Initial default is to only show the specified window
		//
		m_fIncludeParentDef = FALSE;
		m_fIncludeChildrenDef = FALSE;
		m_fIncludeProcessDef = FALSE;
		m_fIncludeThreadDef = FALSE;
	}

	cbData = sizeof(DWORD);
	if (hkey && RegQueryValueEx(hkey, m_szKeyOutputFilters, NULL, &dwType, (LPBYTE)&fFlags, &cbData) == ERROR_SUCCESS)
	{
		if (fFlags & REGFLAG_OUTPUTFILTERS_NESTLEVEL)
			m_fShowNestingLevelDef = TRUE;

		if (fFlags & REGFLAG_OUTPUTFILTERS_RAWPARM)
			m_fShowRawParmsDef = TRUE;

		if (fFlags & REGFLAG_OUTPUTFILTERS_DECODEPARM)
			m_fShowDecodedParmsDef = TRUE;

		if (fFlags & REGFLAG_OUTPUTFILTERS_RAWRET)
			m_fShowRawReturnDef = TRUE;

		if (fFlags & REGFLAG_OUTPUTFILTERS_DECODERET)
			m_fShowDecodedReturnDef = TRUE;

		if (fFlags & REGFLAG_OUTPUTFILTERS_SHOWTIME)
			m_fShowOriginTimeDef = TRUE;

		if (fFlags & REGFLAG_OUTPUTFILTERS_SHOWMOUSEPOS)
			m_fShowMousePositionDef = TRUE;

		if (fFlags & REGFLAG_OUTPUTFILTERS_LOGTOFILE)
			m_fLogToFileDef = TRUE;

		if (fFlags & REGFLAG_OUTPUTFILTERS_APPENDFILE)
			m_fAppendFileDef = TRUE;
	}
	else
	{
		//
		// Default is to show nesting levels, decoded parms and return value.
		//
		m_fShowNestingLevelDef = TRUE;
		m_fShowRawParmsDef = FALSE;
		m_fShowDecodedParmsDef = TRUE;
		m_fShowRawReturnDef = FALSE;
		m_fShowDecodedReturnDef = TRUE;
		m_fShowOriginTimeDef = FALSE;
		m_fShowMousePositionDef = FALSE;
		m_fLogToFileDef = FALSE;
		m_fAppendFileDef = TRUE;
	}

	cbData = sizeof(szFile);
	if ((hkey && RegQueryValueEx(hkey, m_szKeyOutputLogFile, NULL, &dwType, (LPBYTE)szFile, &cbData) == ERROR_SUCCESS) && (cbData > 0))
	{
		// make sure string is zero-terminated in correct place...
		szFile[cbData] = 0;
		m_strLogFileNameDef = szFile;
	}
	else
		m_strLogFileNameDef = "";

	cbData = sizeof(INT);
	if (hkey && RegQueryValueEx(hkey, m_szKeyLines, NULL, &dwType, (LPBYTE)&cLinesMax, &cbData) == ERROR_SUCCESS
		&& cLinesMax <= MAXLINESMAX && cLinesMax > 0)
	{
		m_cLinesMaxDef = cLinesMax;
	}
	else
	{
		m_cLinesMaxDef = MAXLINESDEFAULT;
	}
}



void CMsgDoc::SaveSettings(HKEY hkey)
{
	int i;
	BYTE abMsgs[128];
	BYTE abDlgMsgs[MAX_DLG_MESSAGES/sizeof(BYTE)+1];
#ifndef DISABLE_WIN95_MESSAGES
	BYTE abAniMsgs[MAX_ANI_MESSAGES/sizeof(BYTE)+1];
	BYTE abHdrMsgs[MAX_HDR_MESSAGES/sizeof(BYTE)+1];
	BYTE abTBMsgs[MAX_TB_MESSAGES/sizeof(BYTE)+1];
	BYTE abTTMsgs[MAX_TT_MESSAGES/sizeof(BYTE)+1];
	BYTE abStatMsgs[MAX_STAT_MESSAGES/sizeof(BYTE)+1];
	BYTE abTrkMsgs[MAX_TRK_MESSAGES/sizeof(BYTE)+1];
	BYTE abUpDnMsgs[MAX_UD_MESSAGES/sizeof(BYTE)+1];
	BYTE abProgMsgs[MAX_PROG_MESSAGES/sizeof(BYTE)+1];
	BYTE abHKMsgs[MAX_HK_MESSAGES/sizeof(BYTE)+1];
	BYTE abLVMsgs[MAX_LV_MESSAGES/sizeof(BYTE)+1];
	BYTE abTVMsgs[MAX_TV_MESSAGES/sizeof(BYTE)+1];
	BYTE abTabMsgs[MAX_TAB_MESSAGES/sizeof(BYTE)+1];
#endif	// DISABLE_WIN95_MESSAGES
	DWORD fFlags;

	memset(abMsgs, 0, sizeof(abMsgs));
	for (i = 0; i < MAX_MESSAGES; i++)
	{
		if (m_afSelectedDef[i] == TRUE)
			abMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abMsgs, sizeof(abMsgs));

	memset(abDlgMsgs, 0, sizeof(abDlgMsgs));
	for (i = 0; i < MAX_DLG_MESSAGES; i++)
	{
		if (m_afDlgSelectedDef[i] == TRUE)
			abDlgMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyDlgMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abDlgMsgs, sizeof(abDlgMsgs));

#ifndef DISABLE_WIN95_MESSAGES
	memset(abAniMsgs, 0, sizeof(abAniMsgs));
	for (i = 0; i < MAX_ANI_MESSAGES; i++)
	{
		if (m_afAniSelectedDef[i] == TRUE)
			abAniMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyAniMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abAniMsgs, sizeof(abAniMsgs));

	memset(abHdrMsgs, 0, sizeof(abHdrMsgs));
	for (i = 0; i < MAX_HDR_MESSAGES; i++)
	{
		if (m_afHdrSelectedDef[i] == TRUE)
			abHdrMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyHdrMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abHdrMsgs, sizeof(abHdrMsgs));

	memset(abTBMsgs, 0, sizeof(abTBMsgs));
	for (i = 0; i < MAX_TB_MESSAGES; i++)
	{
		if (m_afTBSelectedDef[i] == TRUE)
			abTBMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyTBMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abTBMsgs, sizeof(abTBMsgs));

	memset(abTTMsgs, 0, sizeof(abTTMsgs));
	for (i = 0; i < MAX_TT_MESSAGES; i++)
	{
		if (m_afTTSelectedDef[i] == TRUE)
			abTTMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyTTMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abTTMsgs, sizeof(abTTMsgs));

	memset(abStatMsgs, 0, sizeof(abStatMsgs));
	for (i = 0; i < MAX_STAT_MESSAGES; i++)
	{
		if (m_afStatSelectedDef[i] == TRUE)
			abStatMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyStatMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abStatMsgs, sizeof(abStatMsgs));

	memset(abTrkMsgs, 0, sizeof(abTrkMsgs));
	for (i = 0; i < MAX_TRK_MESSAGES; i++)
	{
		if (m_afTrkSelectedDef[i] == TRUE)
			abTrkMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyTrkMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abTrkMsgs, sizeof(abTrkMsgs));

	memset(abUpDnMsgs, 0, sizeof(abUpDnMsgs));
	for (i = 0; i < MAX_UD_MESSAGES; i++)
	{
		if (m_afUpDnSelectedDef[i] == TRUE)
			abUpDnMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyUpDnMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abUpDnMsgs, sizeof(abUpDnMsgs));

	memset(abProgMsgs, 0, sizeof(abProgMsgs));
	for (i = 0; i < MAX_PROG_MESSAGES; i++)
	{
		if (m_afProgSelectedDef[i] == TRUE)
			abProgMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyProgMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abProgMsgs, sizeof(abProgMsgs));

	memset(abHKMsgs, 0, sizeof(abHKMsgs));
	for (i = 0; i < MAX_HK_MESSAGES; i++)
	{
		if (m_afHKSelectedDef[i] == TRUE)
			abHKMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyHKMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abHKMsgs, sizeof(abHKMsgs));

	memset(abLVMsgs, 0, sizeof(abLVMsgs));
	for (i = 0; i < MAX_LV_MESSAGES; i++)
	{
		if (m_afLVSelectedDef[i] == TRUE)
			abLVMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyLVMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abLVMsgs, sizeof(abLVMsgs));

	memset(abTVMsgs, 0, sizeof(abTVMsgs));
	for (i = 0; i < MAX_TV_MESSAGES; i++)
	{
		if (m_afTVSelectedDef[i] == TRUE)
			abTVMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyTVMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abTVMsgs, sizeof(abTVMsgs));

	memset(abTabMsgs, 0, sizeof(abTabMsgs));
	for (i = 0; i < MAX_TAB_MESSAGES; i++)
	{
		if (m_afTabSelectedDef[i] == TRUE)
			abTabMsgs[(UINT)i >> 3] |= m_BitTable[i & 0x07];
	}

	RegSetValueEx(hkey, m_szKeyTabMsgFiltersMask, 0, REG_BINARY, (LPBYTE)abTabMsgs, sizeof(abTabMsgs));
#endif	// DISABLE_WIN95_MESSAGES

	fFlags = 0;
	if (m_fMsgsUserDef)
		fFlags |= REGFLAG_MSGFILTERS_USER;
	if (m_fMsgsRegisteredDef)
		fFlags |= REGFLAG_MSGFILTERS_REGISTERED;
	if (m_fMsgsUndocumentedDef)
		fFlags |= REGFLAG_MSGFILTERS_UNDOCUMENTED;
	RegSetValueEx(hkey, m_szKeyMsgFilters, 0, REG_DWORD, (LPBYTE)&fFlags, sizeof(DWORD));

	fFlags = 0;
	if (m_fIncludeParentDef)
		fFlags |= REGFLAG_WINFILTERS_INCPARENT;
	if (m_fIncludeChildrenDef)
		fFlags |= REGFLAG_WINFILTERS_INCCHILDREN;
	if (m_fIncludeProcessDef)
		fFlags |= REGFLAG_WINFILTERS_INCPROCESS;
	if (m_fIncludeThreadDef)
		fFlags |= REGFLAG_WINFILTERS_INCTHREAD;
	RegSetValueEx(hkey, m_szKeyWinFilters, 0, REG_DWORD, (LPBYTE)&fFlags, sizeof(DWORD));

	fFlags = 0;
	if (m_fShowNestingLevelDef)
		fFlags |= REGFLAG_OUTPUTFILTERS_NESTLEVEL;
	if (m_fShowRawParmsDef)
		fFlags |= REGFLAG_OUTPUTFILTERS_RAWPARM;
	if (m_fShowDecodedParmsDef)
		fFlags |= REGFLAG_OUTPUTFILTERS_DECODEPARM;
	if (m_fShowRawReturnDef)
		fFlags |= REGFLAG_OUTPUTFILTERS_RAWRET;
	if (m_fShowDecodedReturnDef)
		fFlags |= REGFLAG_OUTPUTFILTERS_DECODERET;
	if (m_fShowOriginTimeDef)
		fFlags |= REGFLAG_OUTPUTFILTERS_SHOWTIME;
	if (m_fShowMousePositionDef)
		fFlags |= REGFLAG_OUTPUTFILTERS_SHOWMOUSEPOS;
	if (m_fLogToFileDef)
		fFlags |= REGFLAG_OUTPUTFILTERS_LOGTOFILE;
	if (m_fAppendFileDef)
		fFlags |= REGFLAG_OUTPUTFILTERS_APPENDFILE;
	RegSetValueEx(hkey, m_szKeyOutputFilters, 0, REG_DWORD, (LPBYTE)&fFlags, sizeof(DWORD));

	RegSetValueEx(hkey, m_szKeyOutputLogFile, 0, REG_SZ, (LPBYTE)(LPCTSTR)m_strLogFileNameDef, m_strLogFileNameDef.GetLength());

	RegSetValueEx(hkey, m_szKeyLines, 0, REG_DWORD, (LPBYTE)&m_cLinesMaxDef, sizeof(DWORD));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\msgdoc.h ===
// msgdoc.h : header file
//

#define SRCHFLAG_MESSAGE_USEHANDLE		0x01
#define SRCHFLAG_MESSAGE_USEMSG			0x02
#define SRCHFLAG_MESSAGE_USEPOSTTYPE	0x04

/////////////////////////////////////////////////////////////////////////////
// CMsgDoc document

class CMsgView;

class CMsgDoc : public CDocument
{
	DECLARE_DYNCREATE(CMsgDoc)

protected:
	CMsgDoc();		  // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:
	void LogMsg(PMSGSTREAMDATA pmsd);
	void SetWindowToSpyOn(HWND hwnd);
	void SetThreadToSpyOn(DWORD tid);
	void SetProcessToSpyOn(DWORD pid);
	void SetNothingToSpyOn();
	int   GetObjectTypeSpyingOn()
	{
		return(m_nObjectType);
	}
	HWND  GetWindowSpyingOn()
	{
		if (GetObjectTypeSpyingOn() == OT_WINDOW)
			return(m_hwndToSpyOn);
		else
			return(NULL);
	}
	DWORD GetThreadSpyingOn()
	{
		if (GetObjectTypeSpyingOn() == OT_THREAD)
			return(m_tidToSpyOn);
		else
			return(0);
	}
	DWORD GetProcessSpyingOn()
	{
		if (GetObjectTypeSpyingOn() == OT_PROCESS)
			return(m_pidToSpyOn);
		else
			return(0);
	}
	BOOL IsSomethingSelected()
	{
		return (m_nObjectType != OT_NONE || m_fAllWindows);
	}
	BOOL IsLogging()
	{
		return m_fLogging;
	}
	void StartLogging()
	{
		if (!m_fLogging)
			OnMessagesStartStop();
	}
	void StopLogging()
	{
		if (m_fLogging)
			OnMessagesStartStop();
	}
	int ShowWindowFinder()
	{
		return ShowMessagesOptions(0);
	}
	BOOL IsLoggingToFile()
	{
		return m_fLogToFile;
	}
	BOOL IsAppendingToLogFile()
	{
		return m_fAppendFile;
	}
	CString GetLogFileName()
	{
		return m_strLogFileName;
	}

	BOOL DoFind();
	BOOL DoFindNext();
	BOOL DoFindPrev();
	BOOL HasValidFind();
	BOOL CompareLine(LINE *pLine);
	BOOL FindFirstMatchingLine();
	BOOL FindNextMatchingLine();
	BOOL FindPreviousMatchingLine();
	BOOL FindLastMatchingLine();
	


	BOOL MinBuildFriendFix(){return TRUE;}
// Implementation
protected:
	// data variables use in searching
	WORD	m_wSearchFlags;
	HWND 	m_hwndSelected;
	WORD 	m_wMsgSelected;
	UINT	m_uTypeSelected;
	BOOL	m_fSearchUp;	// TRUE if searching up, FALSE if searching down (from dialog)

	virtual ~CMsgDoc();
	virtual BOOL OnNewDocument();

	BOOL IsFilteredHwnd(HWND hwnd);
	void PrintMsg(MSGTYPE mt, PMSGSTREAMDATA pmsd);
	void UpdateTitle();
	int ShowMessagesOptions(UINT iInitialTab);

	inline void SetMaxLines(int cLinesMax);
	inline int GetMaxLines();
	inline BOOL IsSameThreadWindow(HWND hwnd);
	inline BOOL IsSameProcessWindow(HWND hwnd);

	int m_nObjectType;
	HWND m_hwndToSpyOn;
	DWORD m_tidToSpyOn;
	DWORD m_pidToSpyOn;

	CMsgView *m_pMsgView;
	BOOL m_fLogging;
	BOOL m_fMsgsUser;
	BOOL m_fMsgsRegistered;
	BOOL m_fMsgsUndocumented;
	BOOL m_fAllWindows;
	BOOL m_fIncludeParent;
	BOOL m_fIncludeChildren;
	BOOL m_fIncludeProcess;
	BOOL m_fIncludeThread;
	BOOL m_fShowNestingLevel;
	BOOL m_fShowRawParms;
	BOOL m_fShowDecodedParms;
	BOOL m_fShowRawReturn;
	BOOL m_fShowDecodedReturn;
	BOOL m_fShowOriginTime;
	BOOL m_fShowMousePosition;
	BYTE m_afSelected[MAX_MESSAGES];			// table of messages selected for logging
	BYTE m_afDlgSelected[MAX_DLG_MESSAGES];		// table of messages selected for logging (for dialogs)
#ifndef DISABLE_WIN95_MESSAGES
	BYTE m_afAniSelected[MAX_ANI_MESSAGES];		// table of messages selected for logging (for animate Chicago control)
	BYTE m_afHdrSelected[MAX_HDR_MESSAGES];		// table of messages selected for logging (for header Chicago control)
	BYTE m_afTBSelected[MAX_TB_MESSAGES];		// table of messages selected for logging (for toolbar Chicago control)
	BYTE m_afTTSelected[MAX_TT_MESSAGES];		// table of messages selected for logging (for tooltip Chicago control)
	BYTE m_afStatSelected[MAX_STAT_MESSAGES];	// table of messages selected for logging (for statusbar Chicago control)
	BYTE m_afTrkSelected[MAX_TRK_MESSAGES];		// table of messages selected for logging (for trackbar Chicago control)
	BYTE m_afUpDnSelected[MAX_UD_MESSAGES];		// table of messages selected for logging (for undown Chicago control)
	BYTE m_afProgSelected[MAX_PROG_MESSAGES];	// table of messages selected for logging (for progress Chicago control)
	BYTE m_afHKSelected[MAX_HK_MESSAGES];		// table of messages selected for logging (for hotkey Chicago control)
	BYTE m_afLVSelected[MAX_LV_MESSAGES];		// table of messages selected for logging (for listview Chicago control)
	BYTE m_afTVSelected[MAX_TV_MESSAGES];		// table of messages selected for logging (for treeview Chicago control)
	BYTE m_afTabSelected[MAX_TAB_MESSAGES];		// table of messages selected for logging (for tab Chicago control)
#endif	// DISABLE_WIN95_MESSAGES
	BOOL m_fLogToFile;
	CString m_strLogFileName;
	BOOL m_fAppendFile;
	HANDLE m_hLoggingFile;
	CMsgStream m_mout;

	friend class CMsgView;

	friend class CFiltersWindowDlgTab;
	friend class CFiltersMessageDlgTab;
	friend class CFiltersOutputDlgTab;

	friend class CSearchMessageDlg;

public:
	static void InitStaticData(HKEY hkey);
	static void SetTestMode(BOOL fTestMode) { m_fTestMode = fTestMode; }
	static void EnableHook(BOOL fEnable, BOOL fForce = FALSE);
	static void EnableSubclass(BOOL fEnable, BOOL fForce = FALSE);
	static void SaveSettings(HKEY hkey);

	static int m_iInitialTab;				// initial tab for Messages.Options tabbed dialog

	static PMSGDESC m_apmdLT[MAX_MESSAGES];	// Message lookup table
	static MSGDESC m_aMsgDesc[];			// Msg description table
	static int m_cMsgs;						// Msgs in msg desc table

	static PMSGDESC m_apmdDlgLT[MAX_DLG_MESSAGES];	// Message lookup table (for dialog box messages > WM_USER)
#ifndef DISABLE_WIN95_MESSAGES
	static PMSGDESC m_apmdAniLT[MAX_ANI_MESSAGES];	// Message lookup table (for animate Chicago control messages > WM_USER)
	static PMSGDESC m_apmdHdrLT[MAX_HDR_MESSAGES];	// Message lookup table (for header Chicago control messages > WM_USER)
	static PMSGDESC m_apmdTBLT[MAX_TB_MESSAGES];	// Message lookup table (for toolbar Chicago control messages > WM_USER)
	static PMSGDESC m_apmdTTLT[MAX_TT_MESSAGES];	// Message lookup table (for tooltip Chicago control messages > WM_USER)
	static PMSGDESC m_apmdStatLT[MAX_STAT_MESSAGES];// Message lookup table (for statusbar Chicago control messages > WM_USER)
	static PMSGDESC m_apmdTrkLT[MAX_TRK_MESSAGES];	// Message lookup table (for trackbar Chicago control messages > WM_USER)
	static PMSGDESC m_apmdUpDnLT[MAX_UD_MESSAGES];	// Message lookup table (for undown Chicago control messages > WM_USER)
	static PMSGDESC m_apmdProgLT[MAX_PROG_MESSAGES];// Message lookup table (for progress Chicago control messages > WM_USER)
	static PMSGDESC m_apmdHKLT[MAX_HK_MESSAGES];	// Message lookup table (for hotkey Chicago control messages > WM_USER)
	static PMSGDESC m_apmdLVLT[MAX_LV_MESSAGES];	// Message lookup table (for listview Chicago control messages > WM_USER)
	static PMSGDESC m_apmdTVLT[MAX_TV_MESSAGES];	// Message lookup table (for treeview Chicago control messages > WM_USER)
	static PMSGDESC m_apmdTabLT[MAX_TAB_MESSAGES];	// Message lookup table (for tab Chicago control messages > WM_USER)
#endif	// DISABLE_WIN95_MESSAGES

private:
	enum REGFLAG
	{
		REGFLAG_MSGFILTERS_USER				= 0x00000001,
		REGFLAG_MSGFILTERS_REGISTERED		= 0x00000002,
		REGFLAG_MSGFILTERS_UNDOCUMENTED		= 0x00000004,

		REGFLAG_WINFILTERS_INCPARENT		= 0x00000001,
		REGFLAG_WINFILTERS_INCCHILDREN		= 0x00000002,
		REGFLAG_WINFILTERS_INCPROCESS		= 0x00000004,
		REGFLAG_WINFILTERS_INCTHREAD		= 0x00000008,

		REGFLAG_OUTPUTFILTERS_NESTLEVEL		= 0x00000001,
		REGFLAG_OUTPUTFILTERS_RAWPARM		= 0x00000002,
		REGFLAG_OUTPUTFILTERS_DECODEPARM	= 0x00000004,
		REGFLAG_OUTPUTFILTERS_RAWRET		= 0x00000008,
		REGFLAG_OUTPUTFILTERS_DECODERET		= 0x00000010,
		REGFLAG_OUTPUTFILTERS_SHOWTIME 		= 0x00000020,
		REGFLAG_OUTPUTFILTERS_SHOWMOUSEPOS	= 0x00000040,
		REGFLAG_OUTPUTFILTERS_LOGTOFILE   	= 0x00000080,
		REGFLAG_OUTPUTFILTERS_APPENDFILE   	= 0x00000100
	};

	static int m_nLogging;					// Count of logging views
	static BOOL m_fTestMode;				// TRUE if in test mode
	static BYTE m_BitTable[];

	static BOOL m_fMsgsUserDef;
	static BOOL m_fMsgsRegisteredDef;
	static BOOL m_fMsgsUndocumentedDef;
	static BYTE m_afSelectedDef[];			// Default selected table
	static BYTE m_afDlgSelectedDef[];		// Default selected table (for dialog messages)
#ifndef DISABLE_WIN95_MESSAGES
	static BYTE m_afAniSelectedDef[];		// Default selected table (for animate Chicago control)
	static BYTE m_afBLSelectedDef[];		// Default selected table (for button-list Chicago control)
	static BYTE m_afHdrSelectedDef[];		// Default selected table (for header Chicago control)
	static BYTE m_afTBSelectedDef[];		// Default selected table (for toolbar Chicago control)
	static BYTE m_afTTSelectedDef[];		// Default selected table (for tooltip Chicago control)
	static BYTE m_afStatSelectedDef[];		// Default selected table (for statusbar Chicago control)
	static BYTE m_afTrkSelectedDef[];		// Default selected table (for trackbar Chicago control)
	static BYTE m_afUpDnSelectedDef[];		// Default selected table (for undown Chicago control)
	static BYTE m_afProgSelectedDef[];		// Default selected table (for progress Chicago control)
	static BYTE m_afHKSelectedDef[];		// Default selected table (for hotkey Chicago control)
	static BYTE m_afLVSelectedDef[];		// Default selected table (for listview Chicago control)
	static BYTE m_afTVSelectedDef[];		// Default selected table (for treeview Chicago control)
	static BYTE m_afTabSelectedDef[];		// Default selected table (for tab Chicago control)
#endif	// DISABLE_WIN95_MESSAGES
	static BOOL m_fIncludeParentDef;
	static BOOL m_fIncludeChildrenDef;
	static BOOL m_fIncludeProcessDef;
	static BOOL m_fIncludeThreadDef;
	static BOOL m_fShowNestingLevelDef;
	static BOOL m_fShowRawParmsDef;
	static BOOL m_fShowDecodedParmsDef;
	static BOOL m_fShowRawReturnDef;
	static BOOL m_fShowDecodedReturnDef;
	static BOOL m_fShowOriginTimeDef;
	static BOOL m_fShowMousePositionDef;
	static BOOL m_fLogToFileDef;
	static CString m_strLogFileNameDef;
	static BOOL m_fAppendFileDef;
	static int m_cLinesMaxDef;
	static int m_cShowReturnUseCount;

	static CHAR m_szSpyKey[];
	static CHAR m_szKeyMsgFilters[];
	static CHAR m_szKeyMsgFiltersMask[];
	static CHAR m_szKeyDlgMsgFiltersMask[];
#ifndef DISABLE_WIN95_MESSAGES
	static CHAR m_szKeyAniMsgFiltersMask[];
	static CHAR m_szKeyBLMsgFiltersMask[];
	static CHAR m_szKeyHdrMsgFiltersMask[];
	static CHAR m_szKeyTBMsgFiltersMask[];
	static CHAR m_szKeyTTMsgFiltersMask[];
	static CHAR m_szKeyStatMsgFiltersMask[];
	static CHAR m_szKeyTrkMsgFiltersMask[];
	static CHAR m_szKeyUpDnMsgFiltersMask[];
	static CHAR m_szKeyProgMsgFiltersMask[];
	static CHAR m_szKeyHKMsgFiltersMask[];
	static CHAR m_szKeyLVMsgFiltersMask[];
	static CHAR m_szKeyTVMsgFiltersMask[];
	static CHAR m_szKeyTabMsgFiltersMask[];
#endif	// DISABLE_WIN95_MESSAGES
	static CHAR m_szKeyWinFilters[];
	static CHAR m_szKeyOutputFilters[];
	static CHAR m_szKeyOutputLogFile[];
	static CHAR m_szKeyLines[];

	// Generated message map functions
protected:
	//{{AFX_MSG(CMsgDoc)
	afx_msg void OnMessagesStartStop();
	afx_msg void OnUpdateMessagesStartStop(CCmdUI* pCmdUI);
	afx_msg void OnMessagesOptions();
	afx_msg void OnUpdateMessagesOptions(CCmdUI* pCmdUI);
	afx_msg void OnMessagesClear();
	afx_msg void OnUpdateMessagesClear(CCmdUI* pCmdUI);
	afx_msg void OnSearchFind();
	afx_msg void OnUpdateSearchFind(CCmdUI* pCmdUI);
	afx_msg void OnSearchFindNext();
	afx_msg void OnUpdateSearchFindNext(CCmdUI* pCmdUI);
	afx_msg void OnSearchFindPrev();
	afx_msg void OnUpdateSearchFindPrev(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


//-----------------------------------------------------------------------------
// CMsgStream::IsSameThreadWindow
//
// Determines if a given hwnd belongs to the same thread as the hwnd
// that is being spied on.
//
// Arguments:
//
//  HWND hwnd - The window to check.
//
// Returns:
//  Non-zero if the window belongs to the same thread as the window that is
//  being spied on, zero otherwise.
//
//-----------------------------------------------------------------------------

inline BOOL CMsgDoc::IsSameThreadWindow(HWND hwnd)
{
	return (GetWindowThreadProcessId(hwnd, NULL) == m_tidToSpyOn);
}


//-----------------------------------------------------------------------------
// CMsgStream::IsSameProcessWindow
//
// Determines if a given hwnd belongs to the same process as the hwnd
// that is being spied on.
//
// Arguments:
//
//  HWND hwnd - The window to check.
//
// Returns:
//  Non-zero if the window belongs to the same process as the window that is
//  being spied on, zero otherwise.
//
//-----------------------------------------------------------------------------

inline BOOL CMsgDoc::IsSameProcessWindow(HWND hwnd)
{
	DWORD pid;

	GetWindowThreadProcessId(hwnd, &pid);

	return (pid == m_pidToSpyOn);
}


inline void CMsgDoc::SetMaxLines(int cLinesMax)
{
	m_pMsgView->SetMaxLines(cLinesMax);
}


inline int CMsgDoc::GetMaxLines()
{
	return m_pMsgView->GetMaxLines();
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\msgcrack.h ===
//-----------------------------------------------------------------------------
//  MsgCrack.h
//
//  Copyright (C) 1993, Microsoft Corporation
//
//  Purpose:
//
//  Message cracker header.
//
//  Note that there are three different classes of crackers.  The first
//  is called a message cracker.  This is called to format a line in a
//  message stream view.  It is passed a MSGSTREAMDATA pointer to the
//  message (which is immediately followed by any additional data, if
//  there is any defined for that message), and it writes to a
//  CMsgStream output stream, which adds a line to a CMsgLog window
//  when EndLine is called on it.  This cracker type must return
//  TRUE if it writes to the stream.  This return value is used by the
//  formatting code to determine if it needs to add a comma before
//  printing out the raw wParam and lParam values, for instance.
//  Based on the users output filters, these crackers may not even
//  get called (like if they only want to see raw parameters).
//
//  The second kind of a cracker is called a return value cracker,
//  and it is exactly the same except that it is called to format
//  a return value type message.
//
//  The third kind of cracker is called a parameter cracker.  It is
//  passed a slightly different kind of structure (PMSGSTREAMDATA2)
//  that has a pointer to the additional data instead of it being
//  tacked on the end, and it is passed a CMsgParmStream output
//  stream.  This cracker is called when the user is looking at
//  properties for a message, and the wParam/lParam and additional
//  data needs to be formatted and placed into a listbox in the
//  Property inspector.  The output stream will cause one line in
//  the listbox to be added when EndLine is called.  This kind of
//  cracker is not quite as performance sensitive as the previous
//  ones, because a single message is being inspected at a time,
//  instead of a potential flood of messages being logged in a view.
//
//  There are a number of useful macros below to use in the crackers,
//  but you must be careful to only use them in the appropriate type of
//  cracker function.  The message crackers and return value crackers can
//  generally share most output type macros, but these macros must not
//  be used in a message parameter cracker, for instance.
//
//  Revision History:
//
//  04/23/93 byrond  Created
//
//-----------------------------------------------------------------------------

//
// Define the following DBCS message.  This message currently only
// is defined in the KK winuser.h file.
//
#if !defined(WM_CONVERTREQUESTEX)
#define WM_CONVERTREQUESTEX	 0x0109
#endif

typedef struct
{
	UINT nValue;
	CHAR* pszValue;
} VALUETABLE;

#define ARRAY_LEN(Array)	(sizeof(Array) / sizeof(Array[0]))
#define TABLEENTRY(Value)	(UINT)(Value), #Value
#define TABLEEND			0, NULL
#define HANDLEENTRY(Value)	{0, Value, #Value}
#define HANDLEENTRYLAST		{0, 0, NULL}

//
// Prototypes for the Message Decode (cracker) functions.
//
typedef BOOL (*PFNDECODE)(PMSGSTREAMDATA);
typedef BOOL (*PFNDECODERET)(PMSGSTREAMDATA);
typedef void (*PFNDECODEPARM)(PMSGSTREAMDATA2, CMsgParmStream*);

//
// Macro to produce the declarations for a cracker function
// set for a specific message.
//
#define DECLAREDECODE(msg)				\
BOOL Msg##msg(PMSGSTREAMDATA pmsd);		\
BOOL Ret##msg(PMSGSTREAMDATA pmsd);		\
void Parm##msg(PMSGSTREAMDATA2 pmsd2, CMsgParmStream* pmps)

//
// Macro to form an entry in the message description table array.
//
#define MSGDESCENTRY(msg, iMsgType)	{msg, #msg, iMsgType, Msg##msg, Ret##msg, Parm##msg}

//-----------------------------------------------------------------------
// Macros to support defining the cracker functions (that are common
// to all types).
//

//
// Returns the True or False string based on the value of f.
//
#define tf(f)	((f) ? ids(IDS_TRUE) : ids(IDS_FALSE))

#define PARM(var, type, src)	type var = (type)src

//-----------------------------------------------------------------------
// Macros that are specific to the message and return value type crackers.
//

#define HW		pmsd->hwnd

#define WP		pmsd->wParam
#define LP		pmsd->lParam
#define LOWP	LOWORD(pmsd->wParam)
#define HIWP	HIWORD(pmsd->wParam)
#define LOLP	LOWORD(pmsd->lParam)
#define HILP	HIWORD(pmsd->lParam)

#define RET		pmsd->lResult
#define LORET	LOWORD(pmsd->lResult)
#define HIRET	HIWORD(pmsd->lResult)

#define ED		(pmsd + 1)

#define DECODE(msg)			BOOL Msg##msg(PMSGSTREAMDATA pmsd)

#define DECODERET(msg)		BOOL Ret##msg(PMSGSTREAMDATA pmsd)

#define DECODELIKE(msg)		return Msg##msg(pmsd)

#define DECODERETLIKE(msg)	return Ret##msg(pmsd)

#define NODECODE(msg)				\
BOOL Msg##msg(PMSGSTREAMDATA pmsd)	\
{									\
	UNREFERENCED_PARAMETER(pmsd);	\
	return FALSE;					\
}

#define NODECODERET(msg)			\
BOOL Ret##msg(PMSGSTREAMDATA pmsd)	\
{									\
	UNREFERENCED_PARAMETER(pmsd);	\
	return FALSE;					\
}

//
// The global output stream that all the message and return
// crackers write to.
//
#define MOUT				*g_pmout

//
// Macro that determines if there is any extra data.
//
#define PIFDATA()			if (pmsd->cb > sizeof(MSGSTREAMDATA))

//
// Returns the size of the extra data.
//
#define PSIZEOFED()			(pmsd->cb - sizeof(MSGSTREAMDATA))

//
// Verifies the size of the extra data against an expected structure size.
//
#define PIFSIZEOF(struct)	if ((pmsd->cb - sizeof(MSGSTREAMDATA)) == sizeof(struct))

//
// Verifies that the specified PACK_STRINGORD structure contains an
// ordinal.  If it does not, then it is a string and should be
// written out as such.
//
#define PIFISORD(pso)		if (pso->dwMarker == 0xFFFFFFFF)

//
// Macro to label a parameter (but not print the value yet).
//
#define PLABEL(parm)		MOUT << " " #parm ":";

//
// Macro to print out a labeled parameter in the crackers.
//
#define POUT(parm)			MOUT << " " #parm ":" << parm

//
// Macro to print out a labeled boolean parameter in the crackers.
//
#define POUTB(parm)			MOUT << " " #parm ":" << tf(parm)

//
// Macro to print out the value of a boolean parameter (using pointer to BOOL) in the crackers.
//
#define POUTPB(parm)		MOUT << " (" << tf(*parm) << ')'

//
// Macro to print out a labeled parameter with a cast in the crackers.
//
#define POUTC(parm, cast)	MOUT << " " #parm ":" << (cast)parm

//
// Macro to print out a string in quotes.  It does not print a label.
//
#define POUTS(pstr)			MOUT << " (\"" << pstr << "\")";

//
// Macro to print out an ordinal value.  It is labeled as "dwData"
// and placed within parenthesis.
// The pso parameter must be a pointer to a PACK_STRINGORD struct.
//
#define POUTORD(pso)		MOUT << " (dwData:" << pso->dwOrdinal << ')';

//
// Macro to print out a PRECT parameter (no label).
//
#define POUTRECT(prc)		MOUT << " (" << prc->left << ',' << prc->top << ")-(" << prc->right << ',' << prc->bottom << ')';

#define TABLEORVALUE(tbl, parm)			\
	PLABEL(parm);						\
	TableOrValue(tbl, parm);

#define TABLEORVALUEC(tbl, cast, parm)	\
	PLABEL(parm);						\
	TableOrValue(tbl, (cast)parm);

#define TABLEORDWORD(tbl, parm)			\
	PLABEL(parm);						\
	TableOrDWord(tbl, parm);

#define TABLEORINT(tbl, parm)			\
	PLABEL(parm);						\
	TableOrInt(tbl, parm);

#define TABLEFLAGS(tbl, parm)			\
	PLABEL(parm);						\
	TableFlags(tbl, parm);

//-----------------------------------------------------------------------
// Macros that are specific to the message parameter type crackers.
//

#define DECODEPARM(msg)										\
void Parm##msg(PMSGSTREAMDATA2 pmsd2, CMsgParmStream* pmps)

#define DECODEPARMLIKE(msg)									\
	Parm##msg(pmsd2, pmps)

#define NODECODEPARM(msg)									\
void Parm##msg(PMSGSTREAMDATA2 pmsd2, CMsgParmStream* pmps)	\
{															\
	DECODEPARMLIKE(Generic);								\
}

//
// Use this with the PARM macro to define a parameter that
// comes from wParam.
//
#define WP2					pmsd2->wParam

//
// Use this with the PARM macro to define a parameter that
// comes from wParam.
//
#define RET2				pmsd2->lResult

//
// Use this in the PARM macro to define that the parameter
// comes from the Extra Data field of pmsd2.
//
#define ED2					pmsd2->pbExtraData

//
// The output stream that all the parameter crackers
// write to.
//
#define M2OUT				*pmps

//
// Increases the indent level by one.  The indent level is
// used when EndLine() is called to determine how far to indent
// the line in the listbox.
//
#define INDENT()			pmps->Indent()

//
// Decreases the indent level by one.
//
#define OUTDENT()			pmps->Outdent()

//
// Macro to label a parameter (but not print the value yet).
//
#define P2LABEL(parm)		M2OUT << #parm << ": "

//
// Outputs a newline.
//
#define P2ENDLINE()			pmps->EndLine()

//
// Print out the wParam label and value.
//
#define P2WPOUT()																			\
	*pmps << "wParam: " << (DWORD)pmsd2->wParam;											\
	pmps->EndLine()

#define P2WPOUTPTR(struct)																	\
	*pmps << "wParam: " << (DWORD)pmsd2->wParam << ids(IDS_POINTER_TO) << #struct << ')';	\
	pmps->EndLine()

//
// Print out the lParam label and value.
//
#define P2LPOUT()																			\
	*pmps << "lParam: " << (DWORD)pmsd2->lParam;											\
	pmps->EndLine()

#define P2LPOUTPTR(struct)																	\
	*pmps << "lParam: " << (DWORD)pmsd2->lParam << ids(IDS_POINTER_TO) << #struct << ')';	\
	pmps->EndLine()

#define P2LPOUTPTRSTR																		\
	*pmps << "lParam: " << (DWORD)pmsd2->lParam << ids(IDS_POINTER_TO_STRING);				\
	pmps->EndLine()

#define P2IFRETURN()		if (pmsd2->fPostType == POSTTYPE_RETURN)

//
// Returns the size of the extra data.
//
#define P2SIZEOFED()		(pmsd2->cbExtraData)

#define P2IFSIZEOF(struct)	if (pmsd2->cbExtraData == sizeof(struct))

#define P2IFDATA()			if (pmsd2->cbExtraData != 0)

//
// Verifies that the specified PACK_STRINGORD structure contains an
// ordinal.  If it does not, then it is a string and should be
// written out as such.
//
#define P2IFISORD(pso)	PIFISORD(pso)

#define P2OUTPTR(ps, p, struct)																\
	*pmps << #p  << ": " << (DWORD)ps->p << ids(IDS_POINTER_TO) << #struct << ')';			\
	pmps->EndLine()

#define P2OUTPTRSTR(ps, p)																	\
	*pmps << #p  << ": " << (DWORD)ps->p << ids(IDS_POINTER_TO_STRING);						\
	pmps->EndLine()

//
// Macro to print out a labeled parameter.
//
#define P2OUT(ps, parm)																		\
	M2OUT << #parm << ": " << ps->parm;														\
	pmps->EndLine()

//
// Macro to print out a labeled boolean parameter in the crackers.
//
#define P2OUTB(ps, parm)																	\
	M2OUT << #parm << ": " << tf(ps->parm);													\
	pmps->EndLine()

//
// Macro to print out a labeled parameter with a cast in the crackers.
//
#define P2OUTC(ps, parm, cast)																\
	M2OUT << #parm << ": " << (cast)ps->parm;												\
	pmps->EndLine()

//
// Macro to print out a labeled POINT parameter.
//
#define P2OUTPT(ps, parm)																	\
	M2OUT << #parm << ": " << ps->parm.x													\
		<< ',' << ps->parm.y;																\
	pmps->EndLine()

//
// Macro to print out a labeled RECT parameter.
//
#define P2OUTRECT(ps, parm)																	\
	M2OUT << #parm << ": (" << ps->parm.left << ',' << ps->parm.top << ") - ("				\
		 << ps->parm.right << ',' << ps->parm.bottom << ')';								\
	pmps->EndLine()

//
// Macro to print out a string.
//
#define P2OUTS(pstr)																		\
	M2OUT << '\"' << pstr << '\"';															\
	pmps->EndLine()

//
// Macro to print out an ordinal value.  It is labeled as "dwData".
// The pso parameter must be a pointer to a PACK_STRINGORD struct.
//
#define P2OUTORD(pso)																		\
	M2OUT << "dwData:" << pso->dwOrdinal;													\
	pmps->EndLine()

#define P2TABLEORVALUE(tbl, ps, parm)														\
	P2LABEL(parm);																			\
	TableOrValue2(pmps, tbl, ps->parm);														\
	pmps->EndLine()

#define P2TABLEORDWORD(tbl, ps, parm)														\
	P2LABEL(parm);																			\
	TableOrDWord2(pmps, tbl, ps->parm);														\
	pmps->EndLine()

#define P2TABLEORINT(tbl, ps, parm)															\
	P2LABEL(parm);																			\
	TableOrInt2(pmps, tbl, ps->parm);														\
	pmps->EndLine()

#define P2TABLEFLAGS(tbl, ps, parm)															\
	P2LABEL(parm);																			\
	TableFlags2(pmps, tbl, ps->parm);														\
	pmps->EndLine()

//
// End of cracker macros.
//-----------------------------------------------------------------------

//
// MsgCrack.cpp
//

extern CMsgStream *g_pmout;

void TableOrValue(VALUETABLE *ptbl, UINT uValue);
void TableOrValue(VALUETABLE *ptbl, WORD wValue);
inline void TableOrValue(VALUETABLE *ptbl, INT iValue)
{
	TableOrValue(ptbl, (UINT)iValue);
}
inline void TableOrValue(VALUETABLE *ptbl, LRESULT lResult)
{
	TableOrValue(ptbl, (UINT)lResult);
}

void TableOrValueNotHot(VALUETABLE *ptbl, UINT uValue);
void TableOrDWord(VALUETABLE *ptbl, UINT uValue);
void TableOrInt(VALUETABLE *ptbl, UINT uValue);

BOOL TableOrNothing(VALUETABLE *ptbl, UINT uValue);
BOOL TableOrNothing(VALUETABLE *ptbl, WORD wValue);
inline BOOL TableOrNothing(VALUETABLE *ptbl, LRESULT lResult)
{
	return TableOrNothing(ptbl, (UINT)lResult);
}

BOOL TableOrNothingNotHot(VALUETABLE *ptbl, UINT uValue);
void TableFlags(VALUETABLE *ptbl, UINT uValue);
VOID PrintIntArray(PINT pInts, INT cInts, INT cMaxInts);
VOID PrintFont(PPACK_FONT ppf);

//
// Generic message parameter decoder function for messages that do
// not have parameters that point to structures or strings
//
DECODEPARM(Generic);				// ParmGeneric

VOID TableOrValue2(CMsgParmStream* pmps, VALUETABLE *ptbl, UINT uValue);
VOID TableOrDWord2(CMsgParmStream* pmps, VALUETABLE *ptbl, UINT uValue);
BOOL TableOrNothing2(CMsgParmStream* pmps, VALUETABLE *ptbl, UINT uValue);
VOID TableOrInt2(CMsgParmStream* pmps, VALUETABLE *ptbl, UINT uValue);
VOID TableFlags2(CMsgParmStream* pmps, VALUETABLE *ptbl, UINT uValue);
VOID PrintIntArray2(CMsgParmStream* pmps, PINT pInts, INT cInts, INT cMaxInts);

//
// AniMsgs.cpp
//
#ifndef DISABLE_WIN95_MESSAGES
DECLAREDECODE(ACM_OPEN);
DECLAREDECODE(ACM_PLAY);
DECLAREDECODE(ACM_STOP);
#endif	// DISABLE_WIN95_MESSAGES

//
// BtnMsgs.cpp
//
// TODO: DECLAREDECODE(BM_CLICK);
DECLAREDECODE(BM_GETCHECK);
DECLAREDECODE(BM_GETSTATE);
DECLAREDECODE(BM_SETCHECK);
DECLAREDECODE(BM_SETSTATE);
DECLAREDECODE(BM_SETSTYLE);

//
// CBMsgs.cpp
//
extern VALUETABLE tblCBRet[];

DECLAREDECODE(CB_ADDSTRING);
DECLAREDECODE(CB_DELETESTRING);
DECLAREDECODE(CB_DIR);
DECLAREDECODE(CB_FINDSTRING);
DECLAREDECODE(CB_FINDSTRINGEXACT);
DECLAREDECODE(CB_GETCOUNT);
DECLAREDECODE(CB_GETCURSEL);
DECLAREDECODE(CB_GETDROPPEDCONTROLRECT);
DECLAREDECODE(CB_GETDROPPEDSTATE);
DECLAREDECODE(CB_GETEDITSEL);
DECLAREDECODE(CB_GETEXTENDEDUI);
DECLAREDECODE(CB_GETITEMDATA);
DECLAREDECODE(CB_GETITEMHEIGHT);
DECLAREDECODE(CB_GETLBTEXT);
DECLAREDECODE(CB_GETLBTEXTLEN);
DECLAREDECODE(CB_GETLOCALE);
DECLAREDECODE(CB_INSERTSTRING);
DECLAREDECODE(CB_LIMITTEXT);
DECLAREDECODE(CB_RESETCONTENT);
DECLAREDECODE(CB_SELECTSTRING);
DECLAREDECODE(CB_SETCURSEL);
DECLAREDECODE(CB_SETEDITSEL);
DECLAREDECODE(CB_SETEXTENDEDUI);
DECLAREDECODE(CB_SETITEMDATA);
DECLAREDECODE(CB_SETITEMHEIGHT);
DECLAREDECODE(CB_SETLOCALE);
DECLAREDECODE(CB_SHOWDROPDOWN);

//
// ClipMsgs.cpp
//
extern VALUETABLE tblCBFormat[];

DECLAREDECODE(WM_ASKCBFORMATNAME);
DECLAREDECODE(WM_CHANGECBCHAIN);
DECLAREDECODE(WM_CLEAR);
DECLAREDECODE(WM_COPY);
DECLAREDECODE(WM_CUT);
DECLAREDECODE(WM_DESTROYCLIPBOARD);
DECLAREDECODE(WM_DRAWCLIPBOARD);
DECLAREDECODE(WM_HSCROLLCLIPBOARD);
DECLAREDECODE(WM_PAINTCLIPBOARD);
DECLAREDECODE(WM_PASTE);
DECLAREDECODE(WM_RENDERALLFORMATS);
DECLAREDECODE(WM_RENDERFORMAT);
DECLAREDECODE(WM_SIZECLIPBOARD);
DECLAREDECODE(WM_UNDO);
DECLAREDECODE(WM_VSCROLLCLIPBOARD);

//
// DDEMsgs.cpp
//
DECLAREDECODE(WM_DDE_ACK);
DECLAREDECODE(WM_DDE_ADVISE);
DECLAREDECODE(WM_DDE_DATA);
DECLAREDECODE(WM_DDE_EXECUTE);
DECLAREDECODE(WM_DDE_INITIATE);
DECLAREDECODE(WM_DDE_POKE);
DECLAREDECODE(WM_DDE_REQUEST);
DECLAREDECODE(WM_DDE_TERMINATE);
DECLAREDECODE(WM_DDE_UNADVISE);

//
// DlgMsgs.cpp
//
DECLAREDECODE(DM_GETDEFID);
DECLAREDECODE(DM_SETDEFID);
// TODO: DECLAREDECODE(DM_REPOSITION);

//
// EditMsgs.cpp
//
DECLAREDECODE(EM_CANUNDO);
// TODO: DECLAREDECODE(EM_CHARFROMPOS);
DECLAREDECODE(EM_EMPTYUNDOBUFFER);
DECLAREDECODE(EM_FMTLINES);
DECLAREDECODE(EM_GETFIRSTVISIBLELINE);
DECLAREDECODE(EM_GETHANDLE);
// TODO: DECLAREDECODE(EM_GETLIMITTEXT);
DECLAREDECODE(EM_GETLINE);
DECLAREDECODE(EM_GETLINECOUNT);
// TODO: DECLAREDECODE(EM_GETMARGINS);
DECLAREDECODE(EM_GETMODIFY);
DECLAREDECODE(EM_GETPASSWORDCHAR);
DECLAREDECODE(EM_GETRECT);
DECLAREDECODE(EM_GETSEL);
DECLAREDECODE(EM_GETTHUMB);
DECLAREDECODE(EM_GETWORDBREAKPROC);
DECLAREDECODE(EM_LIMITTEXT);
DECLAREDECODE(EM_LINEFROMCHAR);
DECLAREDECODE(EM_LINEINDEX);
DECLAREDECODE(EM_LINELENGTH);
DECLAREDECODE(EM_LINESCROLL);
// TODO: DECLAREDECODE(EM_POSFROMCHAR);
DECLAREDECODE(EM_REPLACESEL);
DECLAREDECODE(EM_SCROLL);
DECLAREDECODE(EM_SCROLLCARET);
// TODO: DECLAREDECODE(EM_SETFONT);
DECLAREDECODE(EM_SETHANDLE);
// TODO: DECLAREDECODE(EM_SETLIMITTEXT);
// TODO: DECLAREDECODE(EM_SETMARGINS);
DECLAREDECODE(EM_SETMODIFY);
DECLAREDECODE(EM_SETPASSWORDCHAR);
DECLAREDECODE(EM_SETREADONLY);
DECLAREDECODE(EM_SETRECT);
DECLAREDECODE(EM_SETRECTNP);
DECLAREDECODE(EM_SETSEL);
DECLAREDECODE(EM_SETTABSTOPS);
DECLAREDECODE(EM_SETWORDBREAKPROC);
DECLAREDECODE(EM_UNDO);

//
// HdrMsgs.cpp
//
#ifndef DISABLE_WIN95_MESSAGES
DECLAREDECODE(HDM_GETITEMCOUNT);
DECLAREDECODE(HDM_INSERTITEM);
DECLAREDECODE(HDM_DELETEITEM);
DECLAREDECODE(HDM_GETITEM);
DECLAREDECODE(HDM_SETITEM);
DECLAREDECODE(HDM_LAYOUT);
DECLAREDECODE(HDM_HITTEST);
#endif	// DISABLE_WIN95_MESSAGES

//
// HKMsgs.cpp
//
#ifndef DISABLE_WIN95_MESSAGES
DECLAREDECODE(HKM_SETHOTKEY);
DECLAREDECODE(HKM_GETHOTKEY);
DECLAREDECODE(HKM_SETRULES);
#endif	// DISABLE_WIN95_MESSAGES

//
// IMEMsgs.cpp
//
DECLAREDECODE(WM_CONVERTREQUESTEX);
DECLAREDECODE(WM_IMEKEYDOWN);
DECLAREDECODE(WM_IMEKEYUP);
DECLAREDECODE(WM_IME_REPORT);
DECLAREDECODE(WM_IME_STARTCOMPOSITION);
DECLAREDECODE(WM_IME_ENDCOMPOSITION);
DECLAREDECODE(WM_IME_COMPOSITION);
DECLAREDECODE(WM_IME_SETCONTEXT);
DECLAREDECODE(WM_IME_NOTIFY);
DECLAREDECODE(WM_IME_CONTROL);
DECLAREDECODE(WM_IME_COMPOSITIONFULL);
DECLAREDECODE(WM_IME_SELECT);
DECLAREDECODE(WM_IME_CHAR);
DECLAREDECODE(WM_IME_KEYDOWN);
DECLAREDECODE(WM_IME_KEYUP);

//
// KbdMsgs.cpp
//
DECLAREDECODE(WM_CHAR);
DECLAREDECODE(WM_CHARTOITEM);
DECLAREDECODE(WM_DEADCHAR);
DECLAREDECODE(WM_GETHOTKEY);
DECLAREDECODE(WM_HOTKEY);
DECLAREDECODE(WM_KEYDOWN);
DECLAREDECODE(WM_KEYUP);
DECLAREDECODE(WM_SETHOTKEY);
DECLAREDECODE(WM_SYSCHAR);
DECLAREDECODE(WM_SYSDEADCHAR);
DECLAREDECODE(WM_SYSKEYDOWN);
DECLAREDECODE(WM_SYSKEYUP);
DECLAREDECODE(WM_VKEYTOITEM);

//
// LBMsgs.cpp
//
extern VALUETABLE tblFileAttrs[];
extern VALUETABLE tblLBRet[];

DECLAREDECODE(LB_ADDFILE);
DECLAREDECODE(LB_ADDSTRING);
DECLAREDECODE(LB_DELETESTRING);
DECLAREDECODE(LB_DIR);
DECLAREDECODE(LB_FINDSTRING);
DECLAREDECODE(LB_FINDSTRINGEXACT);
DECLAREDECODE(LB_GETANCHORINDEX);
DECLAREDECODE(LB_GETCARETINDEX);
DECLAREDECODE(LB_GETCOUNT);
DECLAREDECODE(LB_GETCURSEL);
DECLAREDECODE(LB_GETHORIZONTALEXTENT);
DECLAREDECODE(LB_GETITEMDATA);
DECLAREDECODE(LB_GETITEMHEIGHT);
DECLAREDECODE(LB_GETITEMRECT);
DECLAREDECODE(LB_GETLOCALE);
DECLAREDECODE(LB_GETSEL);
DECLAREDECODE(LB_GETSELCOUNT);
DECLAREDECODE(LB_GETSELITEMS);
DECLAREDECODE(LB_GETTEXT);
DECLAREDECODE(LB_GETTEXTLEN);
DECLAREDECODE(LB_GETTOPINDEX);
DECLAREDECODE(LB_INSERTSTRING);
DECLAREDECODE(LB_RESETCONTENT);
DECLAREDECODE(LB_SELECTSTRING);
DECLAREDECODE(LB_SELITEMRANGE);
DECLAREDECODE(LB_SELITEMRANGEEX);
DECLAREDECODE(LB_SETANCHORINDEX);
DECLAREDECODE(LB_SETCARETINDEX);
DECLAREDECODE(LB_SETCOLUMNWIDTH);
DECLAREDECODE(LB_SETCOUNT);
DECLAREDECODE(LB_SETCURSEL);
DECLAREDECODE(LB_SETHORIZONTALEXTENT);
DECLAREDECODE(LB_SETITEMDATA);
DECLAREDECODE(LB_SETITEMHEIGHT);
DECLAREDECODE(LB_SETLOCALE);
DECLAREDECODE(LB_SETSEL);
DECLAREDECODE(LB_SETTABSTOPS);
DECLAREDECODE(LB_SETTOPINDEX);

//
// LVMsgs.cpp
//
#ifndef DISABLE_WIN95_MESSAGES
DECLAREDECODE(LVM_GETBKCOLOR);
DECLAREDECODE(LVM_SETBKCOLOR);
DECLAREDECODE(LVM_GETIMAGELIST);
DECLAREDECODE(LVM_SETIMAGELIST);
DECLAREDECODE(LVM_GETITEMCOUNT);
DECLAREDECODE(LVM_GETITEM);
DECLAREDECODE(LVM_SETITEM);
DECLAREDECODE(LVM_INSERTITEM);
DECLAREDECODE(LVM_DELETEITEM);
DECLAREDECODE(LVM_DELETEALLITEMS);
DECLAREDECODE(LVM_GETCALLBACKMASK);
DECLAREDECODE(LVM_SETCALLBACKMASK);
DECLAREDECODE(LVM_GETNEXTITEM);
DECLAREDECODE(LVM_FINDITEM);
DECLAREDECODE(LVM_GETITEMRECT);
DECLAREDECODE(LVM_SETITEMPOSITION);
DECLAREDECODE(LVM_GETITEMPOSITION);
DECLAREDECODE(LVM_GETSTRINGWIDTH);
DECLAREDECODE(LVM_HITTEST);
DECLAREDECODE(LVM_ENSUREVISIBLE);
DECLAREDECODE(LVM_SCROLL);
DECLAREDECODE(LVM_REDRAWITEMS);
DECLAREDECODE(LVM_ARRANGE);
DECLAREDECODE(LVM_EDITLABEL);
DECLAREDECODE(LVM_GETEDITCONTROL);
DECLAREDECODE(LVM_GETCOLUMN);
DECLAREDECODE(LVM_SETCOLUMN);
DECLAREDECODE(LVM_INSERTCOLUMN);
DECLAREDECODE(LVM_DELETECOLUMN);
DECLAREDECODE(LVM_GETCOLUMNWIDTH);
DECLAREDECODE(LVM_SETCOLUMNWIDTH);
DECLAREDECODE(LVM_CREATEDRAGIMAGE);
DECLAREDECODE(LVM_GETVIEWRECT);
DECLAREDECODE(LVM_GETTEXTCOLOR);
DECLAREDECODE(LVM_SETTEXTCOLOR);
DECLAREDECODE(LVM_GETTEXTBKCOLOR);
DECLAREDECODE(LVM_SETTEXTBKCOLOR);
DECLAREDECODE(LVM_GETTOPINDEX);
DECLAREDECODE(LVM_GETCOUNTPERPAGE);
DECLAREDECODE(LVM_GETORIGIN);
DECLAREDECODE(LVM_UPDATE);
DECLAREDECODE(LVM_SETITEMSTATE);
DECLAREDECODE(LVM_GETITEMSTATE);
DECLAREDECODE(LVM_GETITEMTEXT);
DECLAREDECODE(LVM_SETITEMTEXT);
DECLAREDECODE(LVM_SETITEMCOUNT);
DECLAREDECODE(LVM_SORTITEMS);
DECLAREDECODE(LVM_SETITEMPOSITION32);
DECLAREDECODE(LVM_GETSELECTEDCOUNT);
DECLAREDECODE(LVM_GETITEMSPACING);
DECLAREDECODE(LVM_GETISEARCHSTRING);
#endif	// DISABLE_WIN95_MESSAGES

//
// MDIMsgs.cpp
//
DECLAREDECODE(WM_CHILDACTIVATE);
DECLAREDECODE(WM_MDIACTIVATE);
DECLAREDECODE(WM_MDICASCADE);
DECLAREDECODE(WM_MDICREATE);
DECLAREDECODE(WM_MDIDESTROY);
DECLAREDECODE(WM_MDIGETACTIVE);
DECLAREDECODE(WM_MDIICONARRANGE);
DECLAREDECODE(WM_MDIMAXIMIZE);
DECLAREDECODE(WM_MDINEXT);
DECLAREDECODE(WM_MDIREFRESHMENU);
DECLAREDECODE(WM_MDIRESTORE);
DECLAREDECODE(WM_MDISETMENU);
DECLAREDECODE(WM_MDITILE);

//
// MousMsgs.cpp
//
extern VALUETABLE tblHitTest[];

DECLAREDECODE(WM_LBUTTONDBLCLK);
DECLAREDECODE(WM_LBUTTONDOWN);
DECLAREDECODE(WM_LBUTTONUP);
DECLAREDECODE(WM_MBUTTONDBLCLK);
DECLAREDECODE(WM_MBUTTONDOWN);
DECLAREDECODE(WM_MBUTTONUP);
DECLAREDECODE(WM_MOUSEACTIVATE);
DECLAREDECODE(WM_MOUSEMOVE);
DECLAREDECODE(WM_PARENTNOTIFY);
DECLAREDECODE(WM_RBUTTONDBLCLK);
DECLAREDECODE(WM_RBUTTONDOWN);
DECLAREDECODE(WM_RBUTTONUP);
DECLAREDECODE(WM_SETCURSOR);

//
// NCMsgs.cpp
//
DECLAREDECODE(WM_NCACTIVATE);
DECLAREDECODE(WM_NCCALCSIZE);
DECLAREDECODE(WM_NCCREATE);
DECLAREDECODE(WM_NCDESTROY);
DECLAREDECODE(WM_NCHITTEST);
DECLAREDECODE(WM_NCLBUTTONDBLCLK);
DECLAREDECODE(WM_NCLBUTTONDOWN);
DECLAREDECODE(WM_NCLBUTTONUP);
DECLAREDECODE(WM_NCMBUTTONDBLCLK);
DECLAREDECODE(WM_NCMBUTTONDOWN);
DECLAREDECODE(WM_NCMBUTTONUP);
DECLAREDECODE(WM_NCMOUSEMOVE);
DECLAREDECODE(WM_NCPAINT);
DECLAREDECODE(WM_NCRBUTTONDBLCLK);
DECLAREDECODE(WM_NCRBUTTONDOWN);
DECLAREDECODE(WM_NCRBUTTONUP);

//
// ProgMsgs.cpp
//
#ifndef DISABLE_WIN95_MESSAGES
DECLAREDECODE(PBM_SETRANGE);
DECLAREDECODE(PBM_SETPOS);
DECLAREDECODE(PBM_DELTAPOS);
DECLAREDECODE(PBM_SETSTEP);
DECLAREDECODE(PBM_STEPIT);
#endif	// DISABLE_WIN95_MESSAGES

//
// SBMsgs.cpp
//
DECLAREDECODE(SBM_ENABLE_ARROWS);
// TODO: DECLAREDECODE(SBM_GETPAGE);
DECLAREDECODE(SBM_GETPOS);
DECLAREDECODE(SBM_GETRANGE);
// TODO: DECLAREDECODE(SBM_GETSCROLLINFO);
// TODO: DECLAREDECODE(SBM_SETPAGE);
DECLAREDECODE(SBM_SETPOS);
DECLAREDECODE(SBM_SETRANGE);
DECLAREDECODE(SBM_SETRANGEREDRAW);
// TODO: DECLAREDECODE(SBM_SETSCROLLINFO);

//
//  StatMsgs.cpp
//
// TODO: DECLAREDECODE(STM_GETBITMAP);
DECLAREDECODE(STM_GETICON);
// TODO: DECLAREDECODE(STM_GETMETAPICT);
// TODO: DECLAREDECODE(STM_SETBITMAP);
DECLAREDECODE(STM_SETICON);
// TODO: DECLAREDECODE(STM_SETMETAPICT);

//
// StbMsgs.cpp
//
#ifndef DISABLE_WIN95_MESSAGES
DECLAREDECODE(SB_SETTEXT);
DECLAREDECODE(SB_GETTEXT);
DECLAREDECODE(SB_GETTEXTLENGTH);
DECLAREDECODE(SB_SETPARTS);
DECLAREDECODE(SB_GETPARTS);
DECLAREDECODE(SB_GETBORDERS);
DECLAREDECODE(SB_SETMINHEIGHT);
DECLAREDECODE(SB_SIMPLE);
DECLAREDECODE(SB_GETRECT);
#endif	// DISABLE_WIN95_MESSAGES

//
// TabMsgs.cpp
//
#ifndef DISABLE_WIN95_MESSAGES
DECLAREDECODE(TCM_GETBKCOLOR);
DECLAREDECODE(TCM_SETBKCOLOR);
DECLAREDECODE(TCM_GETIMAGELIST);
DECLAREDECODE(TCM_SETIMAGELIST);
DECLAREDECODE(TCM_GETITEMCOUNT);
DECLAREDECODE(TCM_GETITEM);
DECLAREDECODE(TCM_SETITEM);
DECLAREDECODE(TCM_INSERTITEM);
DECLAREDECODE(TCM_DELETEITEM);
DECLAREDECODE(TCM_DELETEALLITEMS);
DECLAREDECODE(TCM_GETITEMRECT);
DECLAREDECODE(TCM_GETCURSEL);
DECLAREDECODE(TCM_SETCURSEL);
DECLAREDECODE(TCM_HITTEST);
DECLAREDECODE(TCM_SETITEMEXTRA);
DECLAREDECODE(TCM_ADJUSTRECT);
DECLAREDECODE(TCM_SETITEMSIZE);
DECLAREDECODE(TCM_REMOVEIMAGE);
DECLAREDECODE(TCM_SETPADDING);
DECLAREDECODE(TCM_GETROWCOUNT);
DECLAREDECODE(TCM_GETTOOLTIPS);
DECLAREDECODE(TCM_SETTOOLTIPS);
DECLAREDECODE(TCM_GETCURFOCUS);
DECLAREDECODE(TCM_SETCURFOCUS);
#endif	// DISABLE_WIN95_MESSAGES

//
// TBMsgs.cpp
//
#ifndef DISABLE_WIN95_MESSAGES
DECLAREDECODE(TB_ENABLEBUTTON);
DECLAREDECODE(TB_CHECKBUTTON);
DECLAREDECODE(TB_PRESSBUTTON);
DECLAREDECODE(TB_HIDEBUTTON);
DECLAREDECODE(TB_INDETERMINATE);
DECLAREDECODE(TB_ISBUTTONENABLED);
DECLAREDECODE(TB_ISBUTTONCHECKED);
DECLAREDECODE(TB_ISBUTTONPRESSED);
DECLAREDECODE(TB_ISBUTTONHIDDEN);
DECLAREDECODE(TB_ISBUTTONINDETERMINATE);
DECLAREDECODE(TB_SETSTATE);
DECLAREDECODE(TB_GETSTATE);
DECLAREDECODE(TB_ADDBITMAP);
DECLAREDECODE(TB_ADDBUTTONS);
DECLAREDECODE(TB_INSERTBUTTON);
DECLAREDECODE(TB_DELETEBUTTON);
DECLAREDECODE(TB_GETBUTTON);
DECLAREDECODE(TB_BUTTONCOUNT);
DECLAREDECODE(TB_COMMANDTOINDEX);
DECLAREDECODE(TB_SAVERESTORE);
DECLAREDECODE(TB_CUSTOMIZE);
DECLAREDECODE(TB_ADDSTRING);
DECLAREDECODE(TB_GETITEMRECT);
DECLAREDECODE(TB_BUTTONSTRUCTSIZE);
DECLAREDECODE(TB_SETBUTTONSIZE);
DECLAREDECODE(TB_SETBITMAPSIZE);
DECLAREDECODE(TB_AUTOSIZE);
DECLAREDECODE(TB_SETBUTTONTYPE);
DECLAREDECODE(TB_GETTOOLTIPS);
DECLAREDECODE(TB_SETTOOLTIPS);
DECLAREDECODE(TB_SETPARENT);
DECLAREDECODE(TB_SETROWS);
DECLAREDECODE(TB_GETROWS);
DECLAREDECODE(TB_SETCMDID);
DECLAREDECODE(TB_CHANGEBITMAP);
DECLAREDECODE(TB_GETBITMAP);
DECLAREDECODE(TB_GETBUTTONTEXT);
DECLAREDECODE(TB_GETBITMAPFLAGS);
#endif	// DISABLE_WIN95_MESSAGES

//
// TrkMsgs.cpp
//
#ifndef DISABLE_WIN95_MESSAGES
DECLAREDECODE(TBM_GETPOS);
DECLAREDECODE(TBM_GETRANGEMIN);
DECLAREDECODE(TBM_GETRANGEMAX);
DECLAREDECODE(TBM_GETTIC);
DECLAREDECODE(TBM_SETTIC);
DECLAREDECODE(TBM_SETPOS);
DECLAREDECODE(TBM_SETRANGE);
DECLAREDECODE(TBM_SETRANGEMIN);
DECLAREDECODE(TBM_SETRANGEMAX);
DECLAREDECODE(TBM_CLEARTICS);
DECLAREDECODE(TBM_SETSEL);
DECLAREDECODE(TBM_SETSELSTART);
DECLAREDECODE(TBM_SETSELEND);
DECLAREDECODE(TBM_GETPTICS);
DECLAREDECODE(TBM_GETTICPOS);
DECLAREDECODE(TBM_GETNUMTICS);
DECLAREDECODE(TBM_GETSELSTART);
DECLAREDECODE(TBM_GETSELEND);
DECLAREDECODE(TBM_CLEARSEL);
DECLAREDECODE(TBM_SETTICFREQ);
DECLAREDECODE(TBM_SETPAGESIZE);
DECLAREDECODE(TBM_GETPAGESIZE);
DECLAREDECODE(TBM_SETLINESIZE);
DECLAREDECODE(TBM_GETLINESIZE);
DECLAREDECODE(TBM_GETTHUMBRECT);
DECLAREDECODE(TBM_GETCHANNELRECT);
DECLAREDECODE(TBM_SETTHUMBLENGTH);
DECLAREDECODE(TBM_GETTHUMBLENGTH);
#endif	// DISABLE_WIN95_MESSAGES

//
// TTMsgs.cpp
//
#ifndef DISABLE_WIN95_MESSAGES
DECLAREDECODE(TTM_ACTIVATE);
DECLAREDECODE(TTM_SETDELAYTIME);
DECLAREDECODE(TTM_ADDTOOL);
DECLAREDECODE(TTM_DELTOOL);
DECLAREDECODE(TTM_NEWTOOLRECT);
DECLAREDECODE(TTM_RELAYEVENT);
DECLAREDECODE(TTM_GETTOOLINFO);
DECLAREDECODE(TTM_SETTOOLINFO);
DECLAREDECODE(TTM_HITTEST);
DECLAREDECODE(TTM_GETTEXT);
DECLAREDECODE(TTM_UPDATETIPTEXT);
DECLAREDECODE(TTM_GETTOOLCOUNT);
DECLAREDECODE(TTM_ENUMTOOLS);
DECLAREDECODE(TTM_GETCURRENTTOOL);
#endif	// DISABLE_WIN95_MESSAGES

//
// TVMsgs.cpp
//
#ifndef DISABLE_WIN95_MESSAGES
DECLAREDECODE(TVM_INSERTITEM);
DECLAREDECODE(TVM_DELETEITEM);
DECLAREDECODE(TVM_EXPAND);
DECLAREDECODE(TVM_GETITEMRECT);
DECLAREDECODE(TVM_GETCOUNT);
DECLAREDECODE(TVM_GETINDENT);
DECLAREDECODE(TVM_SETINDENT);
DECLAREDECODE(TVM_GETIMAGELIST);
DECLAREDECODE(TVM_SETIMAGELIST);
DECLAREDECODE(TVM_GETNEXTITEM);
DECLAREDECODE(TVM_SELECTITEM);
DECLAREDECODE(TVM_GETITEM);
DECLAREDECODE(TVM_SETITEM);
DECLAREDECODE(TVM_EDITLABEL);
DECLAREDECODE(TVM_GETEDITCONTROL);
DECLAREDECODE(TVM_GETVISIBLECOUNT);
DECLAREDECODE(TVM_HITTEST);
DECLAREDECODE(TVM_CREATEDRAGIMAGE);
DECLAREDECODE(TVM_SORTCHILDREN);
DECLAREDECODE(TVM_ENSUREVISIBLE);
DECLAREDECODE(TVM_SORTCHILDRENCB);
DECLAREDECODE(TVM_ENDEDITLABELNOW);
DECLAREDECODE(TVM_GETISEARCHSTRING);
#endif	// DISABLE_WIN95_MESSAGES

//
// UpDnMsgs.cpp
//
#ifndef DISABLE_WIN95_MESSAGES
DECLAREDECODE(UDM_SETRANGE);
DECLAREDECODE(UDM_GETRANGE);
DECLAREDECODE(UDM_SETPOS);
DECLAREDECODE(UDM_GETPOS);
DECLAREDECODE(UDM_SETBUDDY);
DECLAREDECODE(UDM_GETBUDDY);
DECLAREDECODE(UDM_SETACCEL);
DECLAREDECODE(UDM_GETACCEL);
DECLAREDECODE(UDM_SETBASE);
DECLAREDECODE(UDM_GETBASE);
#endif	// DISABLE_WIN95_MESSAGES

//
// WinMsgs.cpp
//
extern VALUETABLE tblWindowStyles[];
extern VALUETABLE tblDialogStyles[];
extern VALUETABLE tblButtonStyles[];
extern VALUETABLE tblComboBoxStyles[];
extern VALUETABLE tblEditStyles[];
extern VALUETABLE tblListBoxStyles[];
extern VALUETABLE tblScrollBarStyles[];
extern VALUETABLE tblStaticStyles[];
extern VALUETABLE tblExtWindowStyles[];
extern VALUETABLE tblHeaderStyles[];
extern VALUETABLE tblToolbarStyles[];
extern VALUETABLE tblToolTipStyles[];
extern VALUETABLE tblStatusBarStyles[];
extern VALUETABLE tblTrackBarStyles[];
extern VALUETABLE tblUpDownStyles[];
extern VALUETABLE tblListViewStyles[];
extern VALUETABLE tblTreeViewStyles[];
extern VALUETABLE tblTabControlStyles[];
extern VALUETABLE tblAnimateStyles[];
extern VALUETABLE tblHScroll[];
extern VALUETABLE tblVScroll[];
extern VALUETABLE tblWindowPos[];
extern VALUETABLE tblCreateWindowPos[];
extern VALUETABLE tblTrueFalse[];

DECLAREDECODE(WM_ACTIVATE);
DECLAREDECODE(WM_ACTIVATEAPP);
DECLAREDECODE(WM_CANCELJOURNAL);
DECLAREDECODE(WM_CANCELMODE);
DECLAREDECODE(WM_CLOSE);
DECLAREDECODE(WM_COMMAND);
DECLAREDECODE(WM_COMPACTING);
DECLAREDECODE(WM_COMPAREITEM);
DECLAREDECODE(WM_COPYDATA);
// TODO: DECLAREDECODE(WM_CPL_LAUNCH);
// TODO: DECLAREDECODE(WM_CPL_LAUNCHED);
DECLAREDECODE(WM_CREATE);
DECLAREDECODE(WM_CTLCOLORBTN);
DECLAREDECODE(WM_CTLCOLORDLG);
DECLAREDECODE(WM_CTLCOLOREDIT);
DECLAREDECODE(WM_CTLCOLORLISTBOX);
DECLAREDECODE(WM_CTLCOLORMSGBOX);
DECLAREDECODE(WM_CTLCOLORSCROLLBAR);
DECLAREDECODE(WM_CTLCOLORSTATIC);
DECLAREDECODE(WM_DELETEITEM);
DECLAREDECODE(WM_DESTROY);
DECLAREDECODE(WM_DEVMODECHANGE);
DECLAREDECODE(WM_DRAWITEM);
DECLAREDECODE(WM_DROPFILES);
DECLAREDECODE(WM_ENABLE);
DECLAREDECODE(WM_ENDSESSION);
DECLAREDECODE(WM_ENTERIDLE);
DECLAREDECODE(WM_ENTERMENULOOP);
DECLAREDECODE(WM_EXITMENULOOP);
DECLAREDECODE(WM_ERASEBKGND);
DECLAREDECODE(WM_FONTCHANGE);
DECLAREDECODE(WM_GETDLGCODE);
DECLAREDECODE(WM_GETFONT);
DECLAREDECODE(WM_GETMINMAXINFO);
DECLAREDECODE(WM_GETTEXT);
DECLAREDECODE(WM_GETTEXTLENGTH);
DECLAREDECODE(WM_HSCROLL);
DECLAREDECODE(WM_ICONERASEBKGND);
DECLAREDECODE(WM_INITDIALOG);
DECLAREDECODE(WM_INITMENU);
DECLAREDECODE(WM_INITMENUPOPUP);
DECLAREDECODE(WM_KILLFOCUS);
DECLAREDECODE(WM_MEASUREITEM);
DECLAREDECODE(WM_MENUCHAR);
DECLAREDECODE(WM_MENUSELECT);
DECLAREDECODE(WM_MOVE);
DECLAREDECODE(WM_NEXTDLGCTL);
DECLAREDECODE(WM_NOTIFY);
DECLAREDECODE(WM_NULL);
DECLAREDECODE(WM_PAINT);
DECLAREDECODE(WM_PAINTICON);
DECLAREDECODE(WM_PALETTECHANGED);
DECLAREDECODE(WM_PALETTEISCHANGING);
DECLAREDECODE(WM_POWER);
DECLAREDECODE(WM_PRINT);
DECLAREDECODE(WM_PRINTCLIENT);
DECLAREDECODE(WM_QUERYDRAGICON);
DECLAREDECODE(WM_QUERYENDSESSION);
DECLAREDECODE(WM_QUERYNEWPALETTE);
DECLAREDECODE(WM_QUERYOPEN);
DECLAREDECODE(WM_QUEUESYNC);
DECLAREDECODE(WM_QUIT);
DECLAREDECODE(WM_SETFOCUS);
DECLAREDECODE(WM_SETFONT);
DECLAREDECODE(WM_SETREDRAW);
DECLAREDECODE(WM_SETTEXT);
DECLAREDECODE(WM_SETTINGCHANGE);
DECLAREDECODE(WM_SHOWWINDOW);
DECLAREDECODE(WM_SIZE);
DECLAREDECODE(WM_SPOOLERSTATUS);
DECLAREDECODE(WM_SYSCOLORCHANGE);
DECLAREDECODE(WM_SYSCOMMAND);
DECLAREDECODE(WM_TIMECHANGE);
DECLAREDECODE(WM_TIMER);
DECLAREDECODE(WM_VSCROLL);
DECLAREDECODE(WM_WINDOWPOSCHANGED);
DECLAREDECODE(WM_WINDOWPOSCHANGING);
DECLAREDECODE(WM_WININICHANGE);
DECLAREDECODE(WM_INPUTLANGCHANGEREQUEST);
DECLAREDECODE(WM_INPUTLANGCHANGE);
DECLAREDECODE(WM_TCARD);
DECLAREDECODE(WM_HELP);
DECLAREDECODE(WM_USERCHANGED);
DECLAREDECODE(WM_NOTIFYFORMAT);
DECLAREDECODE(WM_CONTEXTMENU);
DECLAREDECODE(WM_STYLECHANGING);
DECLAREDECODE(WM_STYLECHANGED);
DECLAREDECODE(WM_DISPLAYCHANGE);
DECLAREDECODE(WM_GETICON);
DECLAREDECODE(WM_SETICON);
DECLAREDECODE(WM_NEXTMENU);
DECLAREDECODE(WM_SIZING);
DECLAREDECODE(WM_CAPTURECHANGED);
DECLAREDECODE(WM_MOVING);
DECLAREDECODE(WM_POWERBROADCAST);
DECLAREDECODE(WM_DEVICECHANGE);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\msgdoc.cpp ===
// msgdoc.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"
#include "mainfrm.h"
#include "findtool.h"
#include "filtrdlg.h"
#include "srchdlgs.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMsgDoc

IMPLEMENT_DYNCREATE(CMsgDoc, CDocument)

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CMsgDoc::CMsgDoc()
{
	//
	// This variable is indirectly referenced in the destructor,
	// so we must initialize it early in case the object gets
	// destroyed before the bulk of initialization is done in
	// OnNewDocument.



	m_fLogging = FALSE;
	m_hwndSelected = NULL;
	m_wMsgSelected = 0;
	m_uTypeSelected = 0;
	m_fSearchUp = FALSE;
}

CMsgDoc::~CMsgDoc()
{
	//
	// Be sure to turn off logging!
	//
	if (m_fLogging)
	{
		OnMessagesStartStop();
	}

	POSITION pos;
	if (m_fLogToFile && ((pos = theApp.m_strlistLogFiles.Find(m_strLogFileName)) != NULL))
	{
		theApp.m_strlistLogFiles.RemoveAt(pos);
	}
}

BOOL CMsgDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	//
	// Cache the first (and only) view for this doc.
	//
	POSITION pos = GetFirstViewPosition();
	ASSERT(pos);
	m_pMsgView = (CMsgView *)GetNextView(pos);
	ASSERT(m_pMsgView);

	//
	// Be sure there really is only one view.
	//
	ASSERT(!pos);

	//
	// Attach the view to the CMsgStream object.
	//
	m_mout.SetView(m_pMsgView);

	m_fMsgsUser = m_fMsgsUserDef;
	m_fMsgsRegistered = m_fMsgsRegisteredDef;
	m_fMsgsUndocumented = m_fMsgsUndocumentedDef;

	memcpy(m_afSelected, m_afSelectedDef, MAX_MESSAGES * sizeof(BYTE));
	memcpy(m_afDlgSelected, m_afDlgSelectedDef, MAX_DLG_MESSAGES * sizeof(BYTE));
#ifndef DISABLE_WIN95_MESSAGES
	memcpy(m_afAniSelected,  m_afAniSelectedDef,  MAX_ANI_MESSAGES * sizeof(BYTE));
	memcpy(m_afHdrSelected,  m_afHdrSelectedDef,  MAX_HDR_MESSAGES * sizeof(BYTE));
	memcpy(m_afTBSelected,   m_afTBSelectedDef,   MAX_TB_MESSAGES * sizeof(BYTE));
	memcpy(m_afTTSelected,   m_afTTSelectedDef,   MAX_TT_MESSAGES * sizeof(BYTE));
	memcpy(m_afStatSelected, m_afStatSelectedDef, MAX_STAT_MESSAGES * sizeof(BYTE));
	memcpy(m_afTrkSelected,  m_afTrkSelectedDef,  MAX_TRK_MESSAGES * sizeof(BYTE));
	memcpy(m_afUpDnSelected, m_afUpDnSelectedDef, MAX_UD_MESSAGES * sizeof(BYTE));
	memcpy(m_afProgSelected, m_afProgSelectedDef, MAX_PROG_MESSAGES * sizeof(BYTE));
	memcpy(m_afHKSelected,   m_afHKSelectedDef,   MAX_HK_MESSAGES * sizeof(BYTE));
	memcpy(m_afLVSelected,   m_afLVSelectedDef,   MAX_LV_MESSAGES * sizeof(BYTE));
	memcpy(m_afTVSelected,   m_afTVSelectedDef,   MAX_TV_MESSAGES * sizeof(BYTE));
	memcpy(m_afTabSelected,  m_afTabSelectedDef,  MAX_TAB_MESSAGES * sizeof(BYTE));
#endif	// DISABLE_WIN95_MESSAGES

	m_fAllWindows = FALSE;
	m_fIncludeParent = m_fIncludeParentDef;
	m_fIncludeChildren = m_fIncludeChildrenDef;
	m_fIncludeThread = m_fIncludeThreadDef;
	m_fIncludeProcess = m_fIncludeProcessDef;

	m_fShowNestingLevel = m_fShowNestingLevelDef;
	m_fShowRawParms = m_fShowRawParmsDef;
	m_fShowDecodedParms = m_fShowDecodedParmsDef;
	m_fShowRawReturn = m_fShowRawReturnDef;
	m_fShowDecodedReturn = m_fShowDecodedReturnDef;
	m_fShowOriginTime = m_fShowOriginTimeDef;
	m_fShowMousePosition = m_fShowMousePositionDef;
	m_fLogToFile = m_fLogToFileDef;
	m_strLogFileName = m_strLogFileNameDef;

	//
	// Enable hook subclassing if this view wants to see return values.
	//
	if (m_fShowRawReturn)
		m_cShowReturnUseCount++;

	if (m_fShowDecodedReturn)
		m_cShowReturnUseCount++;

	if (m_cShowReturnUseCount)
		EnableSubclass(TRUE);

	SetMaxLines(m_cLinesMaxDef);

	//
	// Figure out what was last selected in one of the tree
	// views and set the window filters to that object as
	// appropriate.  This will be the object that we initially
	// start spying on.
	//
	switch (GetLastSelectedObjectType())
	{
		case OT_WINDOW:
			SetWindowToSpyOn((HWND)GetLastSelectedObject());
			break;

		case OT_THREAD:
			SetThreadToSpyOn(GetLastSelectedObject());
			break;

		case OT_PROCESS:
			SetProcessToSpyOn(GetLastSelectedObject());
			break;

		case OT_NONE:
			SetNothingToSpyOn();
			break;
	}

	UpdateTitle();

	//
	// Start viewing messages now, unless nothing is selected.
	//
	if (IsSomethingSelected() && GetSpyImmediate())
	{
		OnMessagesStartStop();
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// CMsgDoc::UpdateTitle
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

void CMsgDoc::UpdateTitle()
{
	CHAR szTitle[256];
	LPSTR psz;

	if (m_fAllWindows)
	{
		psz = ids(IDS_MESSAGES_ALL_WINDOWS);
	}
	else
	{
		switch (m_nObjectType)
		{
			case OT_WINDOW:
				wsprintf(szTitle, ids(IDS_MESSAGES_WINDOW), m_hwndToSpyOn);
				break;

			case OT_THREAD:
				wsprintf(szTitle, ids(IDS_MESSAGES_THREAD), m_tidToSpyOn);
				break;

			case OT_PROCESS:
				wsprintf(szTitle, ids(IDS_MESSAGES_PROCESS), m_pidToSpyOn);
				break;

			case OT_NONE:
				wsprintf(szTitle, ids(IDS_MESSAGES_NOTHING_SELECTED));
				break;
		}

		psz = szTitle;
	}

	SetTitle(psz);
}

//-----------------------------------------------------------------------------
// CMsgDoc::EnableHook
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

void CMsgDoc::EnableHook(BOOL fEnable, BOOL fForce)
{
	if (fForce || !m_fTestMode)
	{
		//
		// Set the flag in shared memory to the desired state.
		//
		gfHookEnabled = fEnable;
	}
}

//-----------------------------------------------------------------------------
// CMsgDoc::EnableSubclass
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

void CMsgDoc::EnableSubclass(BOOL fEnable, BOOL fForce)
{
	if (fForce || !m_fTestMode)
	{
		//
		// Set the flag in shared memory to the desired state.
		//
		gfEnableSubclass = fEnable;
	}
}

//-----------------------------------------------------------------------------
// CMsgDoc::SetWindowToSpyOn
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

void CMsgDoc::SetWindowToSpyOn(HWND hwnd)
{
	m_hwndToSpyOn = hwnd;
	m_tidToSpyOn = ::GetWindowThreadProcessId(hwnd, &m_pidToSpyOn);
	m_nObjectType = OT_WINDOW;
}

//-----------------------------------------------------------------------------
// CMsgDoc::SetThreadToSpyOn
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

void CMsgDoc::SetThreadToSpyOn(DWORD tid)
{
	m_hwndToSpyOn = NULL;
	m_tidToSpyOn = tid;
	m_pidToSpyOn = (DWORD)-1;
	m_nObjectType = OT_THREAD;
}

//-----------------------------------------------------------------------------
// CMsgDoc::SetProcessToSpyOn
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

void CMsgDoc::SetProcessToSpyOn(DWORD pid)
{
	m_hwndToSpyOn = NULL;
	m_tidToSpyOn = (DWORD)-1;
	m_pidToSpyOn = pid;
	m_nObjectType = OT_PROCESS;
}

//-----------------------------------------------------------------------------
// CMsgDoc::SetProcessToSpyOn
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

void CMsgDoc::SetNothingToSpyOn()
{
	m_hwndToSpyOn = NULL;
	m_tidToSpyOn = (DWORD)-1;
	m_pidToSpyOn = (DWORD)-1;
	m_nObjectType = OT_NONE;
}

void CMsgDoc::LogMsg(PMSGSTREAMDATA pmsd)
{
	//
	// Check the window filters to see if this is a message for
	// a window we are interested in.
	// Be sure to filter out return messages if the user
	// does not want to see them.
	//
	if (IsFilteredHwnd(pmsd->hwnd) && (pmsd->fPostType != POSTTYPE_RETURN || m_fShowRawReturn || m_fShowDecodedReturn))
	{
		MSGTYPE mt = GetMsgType(pmsd->msg, pmsd->hwnd);

		switch (mt)
		{
			case MT_NORMAL:
				if (m_afSelected[pmsd->msg])
				{
					PrintMsg(MT_NORMAL, pmsd);
				}

				break;

			case MT_DIALOG:
				if (m_afDlgSelected[pmsd->msg - WM_USER])
				{
					PrintMsg(MT_DIALOG, pmsd);
				}

				break;

#ifndef DISABLE_WIN95_MESSAGES
			case MT_ANIMATE:
				if (m_afAniSelected[pmsd->msg - (WM_USER + 100)])
				{
					PrintMsg(MT_ANIMATE, pmsd);
				}

				break;

			case MT_HEADER:
				if (m_afHdrSelected[pmsd->msg - HDM_FIRST])
				{
					PrintMsg(MT_HEADER, pmsd);
				}

				break;

			case MT_HOTKEY:
				if (m_afHKSelected[pmsd->msg - (WM_USER + 1)])
				{
					PrintMsg(MT_HOTKEY, pmsd);
				}

				break;

			case MT_LISTVIEW:
				if (m_afLVSelected[pmsd->msg - LVM_FIRST])
				{
					PrintMsg(MT_LISTVIEW, pmsd);
				}

				break;

			case MT_PROGRESS:
				if (m_afProgSelected[pmsd->msg - (WM_USER + 1)])
				{
					PrintMsg(MT_PROGRESS, pmsd);
				}

				break;

			case MT_STATUSBAR:
				if (m_afStatSelected[pmsd->msg - (WM_USER + 1)])
				{
					PrintMsg(MT_STATUSBAR, pmsd);
				}

				break;

			case MT_TOOLBAR:
				if (m_afTBSelected[pmsd->msg - (WM_USER + 1)])
				{
					PrintMsg(MT_TOOLBAR, pmsd);
				}

				break;

			case MT_TRACKBAR:
				if (m_afTrkSelected[pmsd->msg - WM_USER])
				{
					PrintMsg(MT_TRACKBAR, pmsd);
				}

				break;

			case MT_TABCTRL:
				if (m_afTabSelected[pmsd->msg - TCM_FIRST])
				{
					PrintMsg(MT_TABCTRL, pmsd);
				}

				break;

			case MT_TOOLTIP:
				if (m_afTTSelected[pmsd->msg - (WM_USER + 1)])
				{
					PrintMsg(MT_TOOLTIP, pmsd);
				}

				break;

			case MT_TREEVIEW:
				if (m_afTVSelected[pmsd->msg - TV_FIRST])
				{
					PrintMsg(MT_TREEVIEW, pmsd);
				}

				break;

			case MT_UPDOWN:
				if (m_afUpDnSelected[pmsd->msg - (WM_USER + 101)])
				{
					PrintMsg(MT_UPDOWN, pmsd);
				}

				break;
#endif	// DISABLE_WIN95_MESSAGES

			case MT_UNDOCUMENTED:
				if (m_fMsgsUndocumented)
				{
					PrintMsg(MT_UNDOCUMENTED, pmsd);
				}

				break;

			case MT_REGISTERED:
				if (m_fMsgsRegistered)
				{
					PrintMsg(MT_REGISTERED, pmsd);
				}

				break;

			case MT_USER:
				if (m_fMsgsUser)
				{
					PrintMsg(MT_USER, pmsd);
				}

				break;
		}
	}
}

//-----------------------------------------------------------------------------
// CMsgDoc::IsFilteredHwnd
//
// Returns TRUE if the specified hwnd passes the window filters
// in effect for this CMsgDoc.
//
// Arguments:
//  HWND hwnd - The window handle to check.
//
// Returns:
//  TRUE (actually, non-zero) if the hwnd passes the filters, FALSE if not.
//
//-----------------------------------------------------------------------------

BOOL CMsgDoc::IsFilteredHwnd(HWND hwnd)
{
	if (m_fAllWindows)
	{
		return TRUE;
	}

	switch (m_nObjectType)
	{
		case OT_WINDOW:
			return((m_hwndToSpyOn == hwnd) ||
				(m_fIncludeChildren && ::IsChild(m_hwndToSpyOn, hwnd)) ||
				(m_fIncludeParent && hwnd == ::GetParent(m_hwndToSpyOn)) ||
				(m_fIncludeThread && IsSameThreadWindow(hwnd)) ||
				(m_fIncludeProcess && IsSameProcessWindow(hwnd)));

		case OT_THREAD:
			return IsSameThreadWindow(hwnd);

		case OT_PROCESS:
			return IsSameProcessWindow(hwnd);
	}

	//
	// We should not get here.  If the object type is
	// not found in the above case statement (like
	// OT_NONE), then m_fAllWindows should be TRUE.
	//
	ASSERT(0);
	return FALSE;
}

//-----------------------------------------------------------------------------
// FormatDWORDTime
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

static CHAR szStringBuf[32];

LPSTR FormatDwordTime(DWORD dwTime)
{
	int msec, sec, min, hr;

    hr = (int)(dwTime / 3600000);

    dwTime = dwTime - (hr * 3600000);
    min = (int)(dwTime / 60000);

    dwTime = dwTime - (min * 60000);
    sec = (int)(dwTime / 1000);

    dwTime = dwTime - (sec * 1000);
    msec = (int)(dwTime);

	_stprintf(szStringBuf, "%d:%02d:%02d.%03d", hr, min, sec, msec);

	return szStringBuf;
}

//-----------------------------------------------------------------------------
// FormatPoint
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

LPSTR FormatPoint(LONG ptX, LONG ptY)
{
	_stprintf(szStringBuf, "(%ld, %ld)", ptX, ptY);

	return szStringBuf;
}

//-----------------------------------------------------------------------------
// CMsgDoc::PrintMsg
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

void CMsgDoc::PrintMsg(MSGTYPE mt, PMSGSTREAMDATA pmsd)
{
	INT i;
	LPSTR pszPostType;

	g_pmout = &m_mout;

	m_mout.SetMSDPointer(pmsd);

	switch (pmsd->fPostType)
	{
		case POSTTYPE_SENT:
			pszPostType = " S ";
			break;

		case POSTTYPE_POSTED:
			pszPostType = " P ";
			break;

		case POSTTYPE_RETURN:
			pszPostType = " R ";
			break;

		case POSTTYPE_SENTNORETURN:
			pszPostType = " s ";
			break;

		default:
			ASSERT(FALSE);
			break;
	}

	m_mout << pmsd->hwnd << pszPostType;

	if (m_fShowNestingLevel)
	{
		i = pmsd->nLevel;
		while (i--)
			m_mout << '.';
	}

	if (mt != MT_USER && mt != MT_UNDOCUMENTED && mt != MT_REGISTERED)
	{
#ifdef ONESHOTFILTER
		//
		// If the message was sent, we want to wait for the
		// return value before filtering out the message.
		//
		if (pmsd->fPostType != POSTTYPE_SENT)
		{
			//
			// Turn off the selected flag so that all following
			// occurences of this message will be filtered out.
			//
			if (mt == MT_DIALOG)
				m_afDlgSelected[pmsd->msg - WM_USER] = FALSE;
#ifndef DISABLE_WIN95_MESSAGES
			else if (mt == MT_ANIMATE)
				m_afAniSelected[pmsd->msg - (WM_USER + 100)] = FALSE;
			else if (mt == MT_HEADER)
				m_afHdrSelected[pmsd->msg - HDM_FIRST] = FALSE;
			else if (mt == MT_HOTKEY)
				m_afHKSelected[pmsd->msg - (WM_USER + 1)] = FALSE;
			else if (mt == MT_LISTVIEW)
				m_afLVSelected[pmsd->msg - LVM_FIRST] = FALSE;
			else if (mt == MT_PROGRESS)
				m_afProgSelected[pmsd->msg - (WM_USER + 1)] = FALSE;
			else if (mt == MT_STATUSBAR)
				m_afStatSelected[pmsd->msg - (WM_USER + 1)] = FALSE;
			else if (mt == MT_TOOLBAR)
				m_afTBSelected[pmsd->msg - (WM_USER + 1)] = FALSE;
			else if (mt == MT_TRACKBAR)
				m_afTrkSelected[pmsd->msg - WM_USER] = FALSE;
			else if (mt == MT_TABCTRL)
				m_afTabSelected[pmsd->msg - TCM_FIRST] = FALSE;
			else if (mt == MT_TOOLTIP)
				m_afTTSelected[pmsd->msg - (WM_USER + 1)] = FALSE;
			else if (mt == MT_TREEVIEW)
				m_afTVSelected[pmsd->msg - TV_FIRST] = FALSE;
			else if (mt == MT_UPDOWN)
				m_afUpDnSelected[pmsd->msg - (WM_USER + 101)] = FALSE;
#endif	// DISABLE_WIN95_MESSAGES
			else
				m_afSelected[pmsd->msg] = FALSE;
		}
#endif	// ONESHOTFILTER

		if (mt == MT_DIALOG)
			m_mout << m_apmdDlgLT[pmsd->msg - WM_USER]->pszMsg;
#ifndef DISABLE_WIN95_MESSAGES
		else if (mt == MT_ANIMATE)
			m_mout << m_apmdAniLT[pmsd->msg - (WM_USER + 100)]->pszMsg;
		else if (mt == MT_HEADER)
			m_mout << m_apmdHdrLT[pmsd->msg - HDM_FIRST]->pszMsg;
		else if (mt == MT_HOTKEY)
			m_mout << m_apmdHKLT[pmsd->msg - (WM_USER + 1)]->pszMsg;
		else if (mt == MT_LISTVIEW)
			m_mout << m_apmdLVLT[pmsd->msg - LVM_FIRST]->pszMsg;
		else if (mt == MT_PROGRESS)
			m_mout << m_apmdProgLT[pmsd->msg - (WM_USER + 1)]->pszMsg;
		else if (mt == MT_STATUSBAR)
			m_mout << m_apmdStatLT[pmsd->msg - (WM_USER + 1)]->pszMsg;
		else if (mt == MT_TOOLBAR)
			m_mout << m_apmdTBLT[pmsd->msg - (WM_USER + 1)]->pszMsg;
		else if (mt == MT_TRACKBAR)
			m_mout << m_apmdTrkLT[pmsd->msg - WM_USER]->pszMsg;
		else if (mt == MT_TABCTRL)
			m_mout << m_apmdTabLT[pmsd->msg - TCM_FIRST]->pszMsg;
		else if (mt == MT_TOOLTIP)
			m_mout << m_apmdTTLT[pmsd->msg - (WM_USER + 1)]->pszMsg;
		else if (mt == MT_TREEVIEW)
			m_mout << m_apmdTVLT[pmsd->msg - TV_FIRST]->pszMsg;
		else if (mt == MT_UPDOWN)
			m_mout << m_apmdUpDnLT[pmsd->msg - (WM_USER + 101)]->pszMsg;
#endif	// DISABLE_WIN95_MESSAGES
		else
			m_mout << m_apmdLT[pmsd->msg]->pszMsg;

		if (pmsd->fPostType == POSTTYPE_RETURN)
		{
			BOOL fDecoded;

			if (m_fShowDecodedReturn)
			{
				if (mt == MT_DIALOG)
					fDecoded = (*m_apmdDlgLT[pmsd->msg - WM_USER]->pfnDecodeRet)(pmsd);
#ifndef DISABLE_WIN95_MESSAGES
				else if (mt == MT_ANIMATE)
					fDecoded = (*m_apmdAniLT[pmsd->msg - (WM_USER + 100)]->pfnDecodeRet)(pmsd);
				else if (mt == MT_HEADER)
					fDecoded = (*m_apmdHdrLT[pmsd->msg - HDM_FIRST]->pfnDecodeRet)(pmsd);
				else if (mt == MT_HOTKEY)
					fDecoded = (*m_apmdHKLT[pmsd->msg - (WM_USER + 1)]->pfnDecodeRet)(pmsd);
				else if (mt == MT_LISTVIEW)
					fDecoded = (*m_apmdLVLT[pmsd->msg - LVM_FIRST]->pfnDecodeRet)(pmsd);
				else if (mt == MT_PROGRESS)
					fDecoded = (*m_apmdProgLT[pmsd->msg - (WM_USER + 1)]->pfnDecodeRet)(pmsd);
				else if (mt == MT_STATUSBAR)
					fDecoded = (*m_apmdStatLT[pmsd->msg - (WM_USER + 1)]->pfnDecodeRet)(pmsd);
				else if (mt == MT_TOOLBAR)
					fDecoded = (*m_apmdTBLT[pmsd->msg - (WM_USER + 1)]->pfnDecodeRet)(pmsd);
				else if (mt == MT_TRACKBAR)
					fDecoded = (*m_apmdTrkLT[pmsd->msg - WM_USER]->pfnDecodeRet)(pmsd);
				else if (mt == MT_TABCTRL)
					fDecoded = (*m_apmdTabLT[pmsd->msg - TCM_FIRST]->pfnDecodeRet)(pmsd);
				else if (mt == MT_TOOLTIP)
					fDecoded = (*m_apmdTTLT[pmsd->msg - (WM_USER + 1)]->pfnDecodeRet)(pmsd);
				else if (mt == MT_TREEVIEW)
					fDecoded = (*m_apmdTVLT[pmsd->msg - TV_FIRST]->pfnDecodeRet)(pmsd);
				else if (mt == MT_UPDOWN)
					fDecoded = (*m_apmdUpDnLT[pmsd->msg - (WM_USER + 101)]->pfnDecodeRet)(pmsd);
#endif	// DISABLE_WIN95_MESSAGES
				else
					fDecoded = (*m_apmdLT[pmsd->msg]->pfnDecodeRet)(pmsd);
			}
			else
			{
				fDecoded = FALSE;
			}

			if (m_fShowRawReturn)
			{
				if (fDecoded)
				{
					m_mout << " [lResult:" << (DWORD)pmsd->lResult << ']';
				}
				else
				{
					m_mout << " lResult:" << (DWORD)pmsd->lResult;
				}
			}

			m_mout.EndLine();
		}
		else
		{
			BOOL fDecoded;

			if (m_fShowDecodedParms)
			{
				if (mt == MT_DIALOG)
					fDecoded = (*m_apmdDlgLT[pmsd->msg - WM_USER]->pfnDecode)(pmsd);
#ifndef DISABLE_WIN95_MESSAGES
				else if (mt == MT_ANIMATE)
					fDecoded = (*m_apmdAniLT[pmsd->msg - (WM_USER + 100)]->pfnDecode)(pmsd);
				else if (mt == MT_HEADER)
					fDecoded = (*m_apmdHdrLT[pmsd->msg - HDM_FIRST]->pfnDecode)(pmsd);
				else if (mt == MT_HOTKEY)
					fDecoded = (*m_apmdHKLT[pmsd->msg - (WM_USER + 1)]->pfnDecode)(pmsd);
				else if (mt == MT_LISTVIEW)
					fDecoded = (*m_apmdLVLT[pmsd->msg - LVM_FIRST]->pfnDecode)(pmsd);
				else if (mt == MT_PROGRESS)
					fDecoded = (*m_apmdProgLT[pmsd->msg - (WM_USER + 1)]->pfnDecode)(pmsd);
				else if (mt == MT_STATUSBAR)
					fDecoded = (*m_apmdStatLT[pmsd->msg - (WM_USER + 1)]->pfnDecode)(pmsd);
				else if (mt == MT_TOOLBAR)
					fDecoded = (*m_apmdTBLT[pmsd->msg - (WM_USER + 1)]->pfnDecode)(pmsd);
				else if (mt == MT_TRACKBAR)
					fDecoded = (*m_apmdTrkLT[pmsd->msg - WM_USER]->pfnDecode)(pmsd);
				else if (mt == MT_TABCTRL)
					fDecoded = (*m_apmdTabLT[pmsd->msg - TCM_FIRST]->pfnDecode)(pmsd);
				else if (mt == MT_TOOLTIP)
					fDecoded = (*m_apmdTTLT[pmsd->msg - (WM_USER + 1)]->pfnDecode)(pmsd);
				else if (mt == MT_TREEVIEW)
					fDecoded = (*m_apmdTVLT[pmsd->msg - TV_FIRST]->pfnDecode)(pmsd);
				else if (mt == MT_UPDOWN)
					fDecoded = (*m_apmdUpDnLT[pmsd->msg - (WM_USER + 101)]->pfnDecode)(pmsd);
#endif	// DISABLE_WIN95_MESSAGES
				else
					fDecoded = (*m_apmdLT[pmsd->msg]->pfnDecode)(pmsd);
			}
			else
			{
				fDecoded = FALSE;
			}

			if (m_fShowRawParms)
			{
				if (fDecoded)
				{
					m_mout << " [wParam:" << (DWORD)pmsd->wParam << " lParam:" << (DWORD)pmsd->lParam;

					if (m_fShowOriginTime && pmsd->fPostType == POSTTYPE_POSTED)
					{
						m_mout << " time:" << FormatDwordTime((DWORD)pmsd->time);
					}

					if (m_fShowMousePosition && pmsd->fPostType == POSTTYPE_POSTED)
					{
						m_mout << " point:" << FormatPoint(pmsd->ptX, pmsd->ptY);
					}

					m_mout << ']';
				}
				else
				{
					m_mout << " wParam:" << (DWORD)pmsd->wParam << " lParam:" << (DWORD)pmsd->lParam;

					if (m_fShowOriginTime && pmsd->fPostType == POSTTYPE_POSTED)
					{
						m_mout << " time:" << FormatDwordTime((DWORD)pmsd->time);
					}

					if (m_fShowMousePosition && pmsd->fPostType == POSTTYPE_POSTED)
					{
						m_mout << " point:" << FormatPoint(pmsd->ptX, pmsd->ptY);
					}
				}
			}

			m_mout.EndLine();
		}
	}
	else
	{
		//
		// Not a normal message.  First print the message number
		// (may include a descriptive string for its type).
		//
		switch (mt)
		{
			case MT_USER:
				m_mout << "message:0x" << (WORD)pmsd->msg << ids(IDS_USERDEFINED) << "WM_USER+" << pmsd->msg - WM_USER << ']';
				break;

			case MT_UNDOCUMENTED:
				m_mout << "message:0x" << (WORD)pmsd->msg << ids(IDS_UNDOCUMENTED);
				break;

			case MT_REGISTERED:
				{
					CHAR sz[256];

					m_mout << "message:0x" << (WORD)pmsd->msg << ids(IDS_REGISTERED);

					if (GetClipboardFormatName(pmsd->msg, sz, sizeof(sz) / sizeof(CHAR)))
					{
						m_mout << ":\"" << sz << '"';
					}

					m_mout << ']';
				}

				break;
		}

		//
		// For return values, print the lResult.  Otherwise print
		// the raw wParam and lParam values.
		//
		if (pmsd->fPostType == POSTTYPE_RETURN)
		{
			m_mout << " lResult:" << (DWORD)pmsd->lResult;
		}
		else
		{
			if (m_fShowDecodedParms || m_fShowRawParms)
			{
				m_mout << " wParam:" << (DWORD)pmsd->wParam << " lParam:" << (DWORD)pmsd->lParam;

				if (m_fShowOriginTime && pmsd->fPostType == POSTTYPE_POSTED)
				{
					m_mout << " time:" << FormatDwordTime((DWORD)pmsd->time);
				}

				if (m_fShowMousePosition && pmsd->fPostType == POSTTYPE_POSTED)
				{
					m_mout << " point:" << FormatPoint(pmsd->ptX, pmsd->ptY);
				}
			}
		}

		m_mout.EndLine();
	}
}


BEGIN_MESSAGE_MAP(CMsgDoc, CDocument)
	//{{AFX_MSG_MAP(CMsgDoc)
	ON_COMMAND(ID_MESSAGES_STARTSTOP, OnMessagesStartStop)
	ON_UPDATE_COMMAND_UI(ID_MESSAGES_STARTSTOP, OnUpdateMessagesStartStop)
	ON_COMMAND(ID_MESSAGES_OPTIONS, OnMessagesOptions)
	ON_UPDATE_COMMAND_UI(ID_MESSAGES_OPTIONS, OnUpdateMessagesOptions)
	ON_COMMAND(ID_MESSAGES_CLEAR, OnMessagesClear)
	ON_UPDATE_COMMAND_UI(ID_MESSAGES_CLEAR, OnUpdateMessagesClear)
	ON_COMMAND(ID_SEARCH_FIND, OnSearchFind)
	ON_UPDATE_COMMAND_UI(ID_SEARCH_FIND, OnUpdateSearchFind)
	ON_COMMAND(ID_SEARCH_FINDNEXT, OnSearchFindNext)
	ON_UPDATE_COMMAND_UI(ID_SEARCH_FINDNEXT, OnUpdateSearchFindNext)
	ON_COMMAND(ID_SEARCH_FINDPREV, OnSearchFindPrev)
	ON_UPDATE_COMMAND_UI(ID_SEARCH_FINDPREV, OnUpdateSearchFindPrev)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMsgDoc commands

//-----------------------------------------------------------------------------
// CMsgDoc::OnMessagesStartStop
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

void CMsgDoc::OnMessagesStartStop()
{
	if (m_fLogging)
	{
		m_fLogging = FALSE;

		//
		// Disable the hook if there are no other viewers logging.
		//
		m_nLogging--;
		if (m_nLogging == 0)
			EnableHook(FALSE);

		//
		// if logging to a file, close the file handle.
		//
		if (m_fLogToFile && m_hLoggingFile != INVALID_HANDLE_VALUE)
		{
			CloseHandle(m_hLoggingFile);
		}
	}
	else
	{
		m_fLogging = TRUE;

		//
		// Enable the hook if there were no previous views logging.
		//
		m_nLogging++;
		if (m_nLogging == 1)
			EnableHook(TRUE);

		//
		// if logging to a file, open the file and set file pointer to end
		// of file so as to continue the log where it left off previously.
		//
		if (m_fLogToFile)
		{
			m_hLoggingFile = CreateFile((LPCSTR)m_strLogFileName, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			if (m_hLoggingFile != INVALID_HANDLE_VALUE)
				SetFilePointer(m_hLoggingFile, 0, NULL, FILE_END);
			else
			{
				DWORD dwError = GetLastError();
				SpyMessageBox(IDS_CANNOTLOGTOFILE2);
				m_fLogToFile = FALSE;
			}
		}
	}
}

void CMsgDoc::OnUpdateMessagesStartStop(CCmdUI* pCmdUI)
{
	int iDesiredImage;

	if (m_fLogging)
	{
		pCmdUI->SetText(ids(IDS_STOPLOGGINGMENU));
		pCmdUI->Enable(TRUE);
		iDesiredImage = INDEX_STOP_IMAGE;
	}
	else
	{
		pCmdUI->SetText(ids(IDS_STARTLOGGINGMENU));
		pCmdUI->Enable(m_nObjectType != OT_NONE || m_fAllWindows);
		iDesiredImage = INDEX_START_IMAGE;
	}

	CToolBar* pToolBar = &((CMainFrame*)theApp.m_pMainWnd)->m_wndToolBar;
	int iToolBtn = pToolBar->CommandToIndex(ID_MESSAGES_STARTSTOP);
	UINT nID;
	UINT nStyle;
	int iImage;
	pToolBar->GetButtonInfo(iToolBtn, nID, nStyle, iImage);

	if (iImage != iDesiredImage)
	{
		pToolBar->SetButtonInfo(iToolBtn, nID, nStyle, iDesiredImage);
	}
}

void CMsgDoc::OnMessagesOptions()
{
	ShowMessagesOptions(m_iInitialTab);
}

void CMsgDoc::OnUpdateMessagesOptions(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(!m_fLogging || !m_fLogToFile);
}

int CMsgDoc::ShowMessagesOptions(UINT iInitialTab)
{
	CFiltersTabbedDialog dlg(IDS_MESSAGESTREAMFILTERS, NULL, iInitialTab);

	dlg.AddTab(new CFiltersWindowDlgTab(IDD_FILTERSWINDOWTAB, IDS_WINDOWSTAB));
	dlg.AddTab(new CFiltersMessageDlgTab(IDD_FILTERSMESSAGETAB, IDS_MESSAGESTAB));
	dlg.AddTab(new CFiltersOutputDlgTab(IDD_FILTERSOUTPUTTAB, IDS_OUTPUTTAB));

	dlg.SetDocPointer(this);

	return(dlg.DoModal());
}

void CMsgDoc::OnMessagesClear()
{
	//
	// Delete all the lines in the view
	//
	m_pMsgView->m_MsgLog.ClearAll();

	//
	// if logging to a file, clear the file as well...
	//
	if (m_fLogToFile)
	{
		if (IsLogging() && m_hLoggingFile != INVALID_HANDLE_VALUE)
		{
			CloseHandle(m_hLoggingFile);
			m_hLoggingFile = CreateFile((LPCSTR)m_strLogFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		}
		else
		{
			m_hLoggingFile = CreateFile((LPCSTR)m_strLogFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			CloseHandle(m_hLoggingFile);
		}
	}
}

void CMsgDoc::OnUpdateMessagesClear(CCmdUI* pCmdUI)
{
	//
	// Enable only if there are lines to clear
	//
	pCmdUI->Enable(!m_pMsgView->m_MsgLog.IsEmpty());
}

void CMsgDoc::OnSearchFind()
{
	DoFind();
	return;
}

void CMsgDoc::OnUpdateSearchFind(CCmdUI* pCmdUI)
{
	pCmdUI->SetText(ids(IDS_MENU_FINDMESSAGE));
	pCmdUI->Enable(!m_pMsgView->m_MsgLog.IsEmpty());
	return;
}

void CMsgDoc::OnSearchFindNext()
{
	DoFindNext();
	return;
}

void CMsgDoc::OnUpdateSearchFindNext(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(!m_pMsgView->m_MsgLog.IsEmpty() && HasValidFind());
	return;
}

void CMsgDoc::OnSearchFindPrev()
{
	DoFindPrev();
	return;
}

void CMsgDoc::OnUpdateSearchFindPrev(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(!m_pMsgView->m_MsgLog.IsEmpty() && HasValidFind());
	return;
}

BOOL CMsgDoc::DoFind()
{
#ifdef USE_TABBED_SEARCH_DIALOGS
	CSearchTabbedDialog dlgTest(IDS_SEARCHCAPTION, NULL, (UINT)-1);

	dlgTest.AddTab(new CSearchWindowDlgTab(IDD_SEARCHMESSAGETAB, IDS_SEARCHMESSAGETAB));

	dlgTest.DoModal();
#else	// USE_TABBED_SEARCH_DIALOGS
	CSearchMessageDlg dlg;
	CMsgView *pmvActive = (CMsgView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());
	LINE *pLineArray = pmvActive->m_MsgLog.GetLinesArray();
	int iCur = pmvActive->m_MsgLog.GetCurSel(),
		iFirst = pmvActive->m_MsgLog.GetFirstIndex(), 
		iMax = pmvActive->m_MsgLog.GetNumLines();
	LINE *pLine = &pLineArray[(iCur + iFirst) % iMax];

	m_hwndSelected = pLine->msd2.hwnd;
	m_wMsgSelected = pLine->msd2.msg;
	m_uTypeSelected = pLine->msd2.fPostType;

	dlg.SetWindow(m_hwndSelected); 
	dlg.SetMessage(m_wMsgSelected);
	dlg.SetType(m_uTypeSelected);
	dlg.SetDirection(m_fSearchUp);

	if (dlg.DoModal() == TRUE)
	{
		m_wSearchFlags	= dlg.GetSearchFlags();
		m_hwndSelected	= dlg.GetWindow();
		m_wMsgSelected	= dlg.GetMessage();
		m_uTypeSelected	= dlg.GetType();
		m_fSearchUp		= dlg.GetDirection();

		if (m_fSearchUp)
		{
			if (!FindPreviousMatchingLine() && !FindLastMatchingLine())
			{
				// notify user that no matching node found
				SpyMessageBox(IDS_NO_MATCHING_MSG);
			}
		}
		else
		{
			if (!FindNextMatchingLine() && !FindFirstMatchingLine())
			{
				// notify user that no matching node found
				SpyMessageBox(IDS_NO_MATCHING_MSG);
			}
		}
	}
#endif	// USE_TABBED_SEARCH_DIALOGS

	return(TRUE);
}

BOOL CMsgDoc::DoFindNext()
{
	if (!FindNextMatchingLine() && !FindFirstMatchingLine())
	{
		// notify user that no next matching node found
		SpyMessageBox(IDS_NO_NEXT_MATCH_MSG);
	}

	return(TRUE);
}

BOOL CMsgDoc::DoFindPrev()
{
	if (!FindPreviousMatchingLine() && !FindLastMatchingLine())
	{
		// notify user that no previous matching node found
		SpyMessageBox(IDS_NO_PREV_MATCH_MSG);
	}

	return(TRUE);
}

BOOL CMsgDoc::HasValidFind()
{
	BOOL fRet = (m_wSearchFlags != 0);

	if (fRet && m_wSearchFlags & SRCHFLAG_MESSAGE_USEHANDLE)
	{
		fRet &= m_hwndSelected != NULL;
	}

	if (fRet && m_wSearchFlags & SRCHFLAG_MESSAGE_USEMSG)
	{
		fRet &= m_wMsgSelected != 0;
	}

	if (fRet && m_wSearchFlags & SRCHFLAG_MESSAGE_USEPOSTTYPE)
	{
		fRet &= (m_uTypeSelected >= 0 && m_uTypeSelected <= 3);
	}

	return(fRet);
}

BOOL CMsgDoc::CompareLine(LINE *pLine)
{
	// do comparison of node contents with search criteria
	switch (m_wSearchFlags)
	{
		case SRCHFLAG_MESSAGE_USEHANDLE:

			if (pLine->msd2.hwnd == m_hwndSelected)
			{
				return(TRUE);
			}
			break;

		case SRCHFLAG_MESSAGE_USEMSG:

			if ((pLine->msd2.hwnd != NULL) && 
				(pLine->msd2.msg == m_wMsgSelected))
			{
				return(TRUE);
			}
			break;

		case SRCHFLAG_MESSAGE_USEPOSTTYPE:

			if ((pLine->msd2.hwnd != NULL) && 
				(pLine->msd2.fPostType == m_uTypeSelected))
			{
				return(TRUE);
			}
			break;

		case (SRCHFLAG_MESSAGE_USEHANDLE | SRCHFLAG_MESSAGE_USEMSG):

			if ((pLine->msd2.hwnd == m_hwndSelected) && 
				(pLine->msd2.msg == m_wMsgSelected))
			{
				return(TRUE);
			}
			break;

		case (SRCHFLAG_MESSAGE_USEHANDLE | SRCHFLAG_MESSAGE_USEPOSTTYPE):

			if ((pLine->msd2.hwnd == m_hwndSelected) &&
				(pLine->msd2.fPostType == m_uTypeSelected))
			{
				return(TRUE);
			}
			break;

		case (SRCHFLAG_MESSAGE_USEPOSTTYPE | SRCHFLAG_MESSAGE_USEMSG):

			if ((pLine->msd2.hwnd != NULL) && 
				(pLine->msd2.fPostType == m_uTypeSelected) &&
				(pLine->msd2.msg == m_wMsgSelected))
			{
				return(TRUE);
			}
			break;

		case (SRCHFLAG_MESSAGE_USEHANDLE | SRCHFLAG_MESSAGE_USEPOSTTYPE | SRCHFLAG_MESSAGE_USEMSG):

			if ((pLine->msd2.hwnd == m_hwndSelected) &&
				(pLine->msd2.msg == m_wMsgSelected) &&
				(pLine->msd2.fPostType == m_uTypeSelected))
			{
				return(TRUE);
			}
			break;

		default:
			return(FALSE);
	}

	return(FALSE);
}

BOOL CMsgDoc::FindFirstMatchingLine()
{
	CMsgView *pmvActive;
	
	pmvActive = (CMsgView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	LINE *pLine;
	LINE *pLineArray = pmvActive->m_MsgLog.GetLinesArray();
	int iFirst = pmvActive->m_MsgLog.GetFirstIndex(), 
		iMax = pmvActive->m_MsgLog.GetNumLines();

	for (int i = 0; i < iMax; i++)
	{
		pLine = &pLineArray[(i + iFirst) % iMax];

		// do comparison of node contents with search criteria
		if (CompareLine(pLine))
		{
			pmvActive->m_MsgLog.SelectLine(i);
			pmvActive->m_MsgLog.ShowSelection();
			return(TRUE);
		}
	}

	return(FALSE);
}

BOOL CMsgDoc::FindNextMatchingLine()
{
	CMsgView *pmvActive;
	
	pmvActive = (CMsgView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	LINE *pLine;
	LINE *pLineArray = pmvActive->m_MsgLog.GetLinesArray();
	int iFirst = pmvActive->m_MsgLog.GetFirstIndex(), 
		iCur = pmvActive->m_MsgLog.GetCurSel(),
		iMax = pmvActive->m_MsgLog.GetNumLines();

	for (int i = iCur + 1; i < iMax; i++)
	{
		pLine = &pLineArray[(i + iFirst) % iMax];

		// do comparison of node contents with search criteria
		// do comparison of node contents with search criteria
		if (CompareLine(pLine))
		{
			pmvActive->m_MsgLog.SelectLine(i);
			pmvActive->m_MsgLog.ShowSelection();
			return(TRUE);
		}
	}

	return(FALSE);
}

BOOL CMsgDoc::FindPreviousMatchingLine()
{
	CMsgView *pmvActive;
	
	pmvActive = (CMsgView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	LINE *pLine;
	LINE *pLineArray = pmvActive->m_MsgLog.GetLinesArray();
	int iFirst = pmvActive->m_MsgLog.GetFirstIndex(), 
		iCur = pmvActive->m_MsgLog.GetCurSel(),
		iMax = pmvActive->m_MsgLog.GetNumLines();

	for (int i = iCur - 1; i >= 0; i--)
	{
		pLine = &pLineArray[(i + iFirst) % iMax];

		// do comparison of node contents with search criteria
		// do comparison of node contents with search criteria
		if (CompareLine(pLine))
		{
			pmvActive->m_MsgLog.SelectLine(i);
			pmvActive->m_MsgLog.ShowSelection();
			return(TRUE);
		}
	}

	return(FALSE);
}

BOOL CMsgDoc::FindLastMatchingLine()
{
	CMsgView *pmvActive;
	
	pmvActive = (CMsgView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	LINE *pLine;
	LINE *pLineArray = pmvActive->m_MsgLog.GetLinesArray();
	int iFirst = pmvActive->m_MsgLog.GetFirstIndex(), 
		iMax = pmvActive->m_MsgLog.GetNumLines();

	for (int i = iMax - 1; i >= 0; i--)
	{
		pLine = &pLineArray[(i + iFirst) % iMax];

		// do comparison of node contents with search criteria
		// do comparison of node contents with search criteria
		if (CompareLine(pLine))
		{
			pmvActive->m_MsgLog.SelectLine(i);
			pmvActive->m_MsgLog.ShowSelection();
			return(TRUE);
		}
	}

	return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\mousmsgs.cpp ===
//-----------------------------------------------------------------------------
//  MousMsgs.cpp
//
//  Mouse message crackers.

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

VALUETABLE tblHitTest[] =
{
	TABLEENTRY(HTERROR),
	TABLEENTRY(HTTRANSPARENT),
	TABLEENTRY(HTNOWHERE),
	TABLEENTRY(HTCLIENT),
	TABLEENTRY(HTCAPTION),
	TABLEENTRY(HTSYSMENU),
	TABLEENTRY(HTGROWBOX),
	TABLEENTRY(HTSIZE),
	TABLEENTRY(HTMENU),
	TABLEENTRY(HTHSCROLL),
	TABLEENTRY(HTVSCROLL),
	TABLEENTRY(HTREDUCE),
	TABLEENTRY(HTZOOM),
	TABLEENTRY(HTLEFT),
	TABLEENTRY(HTRIGHT),
	TABLEENTRY(HTTOP),
	TABLEENTRY(HTTOPLEFT),
	TABLEENTRY(HTTOPRIGHT),
	TABLEENTRY(HTBOTTOM),
	TABLEENTRY(HTBOTTOMLEFT),
	TABLEENTRY(HTBOTTOMRIGHT),
	TABLEENTRY(HTBORDER),
	TABLEEND
};

static VALUETABLE tblKeyFlags[] =
{
	TABLEENTRY(MK_CONTROL),
	TABLEENTRY(MK_LBUTTON),
	TABLEENTRY(MK_MBUTTON),
	TABLEENTRY(MK_RBUTTON),
	TABLEENTRY(MK_SHIFT),
	TABLEEND
};

static VALUETABLE tblActivate[] =
{
	TABLEENTRY(MA_ACTIVATE),
	TABLEENTRY(MA_NOACTIVATE),
	TABLEENTRY(MA_ACTIVATEANDEAT),
	TABLEENTRY(MA_NOACTIVATEANDEAT),
	TABLEEND
};

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_LBUTTONDBLCLK)
{
	PARM(fwKeys, UINT, WP);
	PARM(xPos, INT, (short)LOLP);
	PARM(yPos, INT, (short)HILP);

	TABLEFLAGS(tblKeyFlags, fwKeys);
	POUT(xPos);
	POUT(yPos);

	return TRUE;
}

NODECODERET(WM_LBUTTONDBLCLK);

NODECODEPARM(WM_LBUTTONDBLCLK);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_LBUTTONDOWN)
{
	DECODELIKE(WM_LBUTTONDBLCLK);
}

NODECODERET(WM_LBUTTONDOWN);

NODECODEPARM(WM_LBUTTONDOWN);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_LBUTTONUP)
{
	DECODELIKE(WM_LBUTTONDBLCLK);
}

NODECODERET(WM_LBUTTONUP);

NODECODEPARM(WM_LBUTTONUP);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MBUTTONDBLCLK)
{
	DECODELIKE(WM_LBUTTONDBLCLK);
}

NODECODERET(WM_MBUTTONDBLCLK);

NODECODEPARM(WM_MBUTTONDBLCLK);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MBUTTONDOWN)
{
	DECODELIKE(WM_LBUTTONDBLCLK);
}

NODECODERET(WM_MBUTTONDOWN);

NODECODEPARM(WM_MBUTTONDOWN);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MBUTTONUP)
{
	DECODELIKE(WM_LBUTTONDBLCLK);
}

NODECODERET(WM_MBUTTONUP);

NODECODEPARM(WM_MBUTTONUP);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MOUSEACTIVATE)
{
	PARM(hwndTopLevel, HWND, WP);
	PARM(nHittest, UINT, (INT)LOLP);
	PARM(uMsg, UINT, HILP);

	POUT(hwndTopLevel);
	TABLEORVALUE(tblHitTest, nHittest);
	PLABEL(uMsg);
	if (uMsg < WM_USER && CMsgDoc::m_apmdLT[uMsg])
	{
		MOUT << CMsgDoc::m_apmdLT[uMsg]->pszMsg;
	}
	else
	{
		MOUT << (WORD)uMsg;
	}

	return TRUE;
}

DECODERET(WM_MOUSEACTIVATE)
{
	PARM(fuActivate, UINT, RET);

	TABLEORVALUE(tblActivate, fuActivate);

	return TRUE;
}

NODECODEPARM(WM_MOUSEACTIVATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_MOUSEMOVE)
{
	DECODELIKE(WM_LBUTTONDBLCLK);
}

NODECODERET(WM_MOUSEMOVE);

NODECODEPARM(WM_MOUSEMOVE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_PARENTNOTIFY)
{
	PARM(fwEvent, UINT, LOWP);

	PLABEL(fwEvent);
	if (fwEvent < WM_USER && CMsgDoc::m_apmdLT[fwEvent])
	{
		MOUT << CMsgDoc::m_apmdLT[fwEvent]->pszMsg;
	}
	else
	{
		MOUT << (WORD)fwEvent;
	}

	switch (fwEvent)
	{
		case WM_CREATE:
		case WM_DESTROY:
			{
				PARM(idChild, UINT, HIWP);
				PARM(hwndChild, HWND, LP);

				POUTC(idChild, WORD);
				MOUT << " (" << (INT)idChild << ')';
				POUT(hwndChild);
			}

			break;

		case WM_LBUTTONDOWN:
		case WM_MBUTTONDOWN:
		case WM_RBUTTONDOWN:
			{
				PARM(xPos, INT, LOLP);
				PARM(yPos, INT, HILP);

				POUT(xPos);
				POUT(yPos);
			}

			break;
	}

	return TRUE;
}

NODECODERET(WM_PARENTNOTIFY);

NODECODEPARM(WM_PARENTNOTIFY);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_RBUTTONDBLCLK)
{
	DECODELIKE(WM_LBUTTONDBLCLK);
}

NODECODERET(WM_RBUTTONDBLCLK);

NODECODEPARM(WM_RBUTTONDBLCLK);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_RBUTTONDOWN)
{
	DECODELIKE(WM_LBUTTONDBLCLK);
}

NODECODERET(WM_RBUTTONDOWN);

NODECODEPARM(WM_RBUTTONDOWN);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_RBUTTONUP)
{
	DECODELIKE(WM_LBUTTONDBLCLK);
}

NODECODERET(WM_RBUTTONUP);

NODECODEPARM(WM_RBUTTONUP);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_SETCURSOR)
{
	PARM(hwnd, HWND, WP);
	PARM(nHittest, UINT, (INT)LOLP);
	PARM(wMouseMsg, WORD, HILP);

	POUT(hwnd);
	TABLEORVALUE(tblHitTest, nHittest);

	//
	// Note that a wMouseMsg value of zero is possible, when the
	// window enters menu mode.  That is the reason for "greater
	// than zero" test below.
	//
	PLABEL(wMouseMsg);
	if (wMouseMsg > 0 && wMouseMsg < WM_USER &&
		CMsgDoc::m_apmdLT[wMouseMsg])
	{
		MOUT << CMsgDoc::m_apmdLT[wMouseMsg]->pszMsg;
	}
	else
	{
		MOUT << (WORD)wMouseMsg;
	}

	return TRUE;
}

DECODERET(WM_SETCURSOR)
{
	PARM(fHaltProcessing, BOOL, RET);

	POUTB(fHaltProcessing);

	return TRUE;
}

NODECODEPARM(WM_SETCURSOR);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\msgcrack.cpp ===
//-----------------------------------------------------------------------------
//  MsgCrack.cpp
//
//  Copyright (C) 1993, Microsoft Corporation
//
//  Purpose:
//
//  Support routines for cracking messages.
//
//  Revision History:
//
//  04/01/93 byrond	 Created.
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CMsgStream * g_pmout;



//-----------------------------------------------------------------------------
// TableOrValue(UINT uValue)
//
// Prints (as a help topic) the value of uValue if found in the specified
// table, otherwise prints it out as either a DWORD or WORD value, depending
// on its size.
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

VOID TableOrValue(VALUETABLE *ptbl, UINT uValue)
{
	if (!(TableOrNothing(ptbl, uValue)))
	{
		if (uValue > 0xFFFF)
		{
			MOUT << (DWORD)uValue;
		}
		else
		{
			MOUT << (WORD)uValue;
		}
	}
}



//-----------------------------------------------------------------------------
// TableOrValue(WORD wValue)
//
// Prints (as a help topic) the value of wValue if found in the specified
// table, otherwise prints it out as a WORD value.
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

VOID TableOrValue(VALUETABLE *ptbl, WORD wValue)
{
	if (!(TableOrNothing(ptbl, wValue)))
	{
		MOUT << wValue;
	}
}



//-----------------------------------------------------------------------------
// TableOrValueNotHot(UINT uValue)
//
// Prints (but NOT as a help topic) the value of uValue if found in the
// specified table, otherwise prints it out as either a DWORD or WORD
// value, depending on its size.
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

VOID TableOrValueNotHot(VALUETABLE *ptbl, UINT uValue)
{
	if (!(TableOrNothingNotHot(ptbl, uValue)))
	{
		if (uValue > 0xFFFF)
		{
			MOUT << (DWORD)uValue;
		}
		else
		{
			MOUT << (WORD)uValue;
		}
	}
}



//-----------------------------------------------------------------------------
// TableOrDWord
//
// Prints (as a help topic) the value of uValue if found in the specified
// table, otherwise prints it out as a DWORD value.
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

VOID TableOrDWord(VALUETABLE *ptbl, UINT uValue)
{
	if (!(TableOrNothing(ptbl, uValue)))
	{
		MOUT << (DWORD)uValue;
	}
}



//-----------------------------------------------------------------------------
// TableOrInt
//
// Prints (as a help topic) the value of uValue if found in the specified
// table, otherwise prints it out as an INT value.
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

VOID TableOrInt(VALUETABLE *ptbl, UINT uValue)
{
	if (!(TableOrNothing(ptbl, uValue)))
	{
		MOUT << (INT)uValue;
	}
}



//-----------------------------------------------------------------------------
// TableOrNothing
//
// Prints (as a help topic) the value of uValue if found in the specified
// table, otherwise does not print anything out and returns FALSE.
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

BOOL TableOrNothing(VALUETABLE *ptbl, UINT uValue)
{
	while (ptbl->pszValue)
	{
		if (uValue == ptbl->nValue)
		{
			MOUT << ptbl->pszValue;
			return TRUE;
		}

		ptbl++;
	}

	return FALSE;
}



//-----------------------------------------------------------------------------
// TableOrNothing
//
// Prints (as a help topic) the value of wValue if found in the specified
// table, otherwise does not print anything out and returns FALSE.
// Only the LOWORD of the value in the table is compared to wValue.
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

BOOL TableOrNothing(VALUETABLE *ptbl, WORD wValue)
{
	while (ptbl->pszValue)
	{
		if (wValue == (WORD)ptbl->nValue)
		{
			MOUT << ptbl->pszValue;
			return TRUE;
		}

		ptbl++;
	}

	return FALSE;
}



//-----------------------------------------------------------------------------
// TableOrNothingNotHot
//
// Prints (but NOT as a help topic) the value of uValue if found in the
// specified table, otherwise does not print anything out and returns FALSE.
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

BOOL TableOrNothingNotHot(VALUETABLE *ptbl, UINT uValue)
{
	while (ptbl->pszValue)
	{
		if (uValue == ptbl->nValue)
		{
			MOUT << ptbl->pszValue;
			return TRUE;
		}

		ptbl++;
	}

	return FALSE;
}



//-----------------------------------------------------------------------------
// TableFlags
//
// Prints (as a help topic) the flag values found in uValue that match
// the flags found in the specified table, separated by " | ".  If there
// are any bits remaining in the uValue parameter that are not accounted
// for after checking all the flags in the table, they will be printed
// out at the end as a WORD or DWORD.
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

VOID TableFlags(VALUETABLE *ptbl, UINT uValue)
{
	BOOL fPrevious = FALSE;

	while (ptbl->pszValue)
	{
		if (ptbl->nValue & uValue)
		{
			if (fPrevious)
			{
				MOUT << " | ";
			}
			else
			{
				fPrevious = TRUE;
			}

			MOUT << ptbl->pszValue;
			uValue &= ~ptbl->nValue;
		}

		ptbl++;
	}

	//
	// Was there nothing written or are there any bits that are left?
	//
	if (!fPrevious || uValue)
	{
		if (fPrevious)
		{
			MOUT << " | ";
		}

		if (uValue > 0xFFFF)
		{
			MOUT << (DWORD)uValue;
		}
		else
		{
			MOUT << (WORD)uValue;
		}
	}
}



//-----------------------------------------------------------------------------
// PrintIntArray
//
// Prints out a list of integers in an array separated by commas.
// If there was originally more integers than are available for
// display, it will add trailing ellipses on the end.
//
// Arguments:
//  PINT pInts	  - Pointer to an array of ints.
//  INT cInts	   - Ints in the pInts array.
//  INT cMaxInts	- The total original ints.  If this is larger than
//					cInts then the ellipses will be shown.
//
//-----------------------------------------------------------------------------

VOID PrintIntArray(PINT pInts, INT cInts, INT cMaxInts)
{
	int i;
	BOOL fPrevWritten = FALSE;

	for (i = 0; i < cInts; i++)
	{
		if (fPrevWritten)
		{
			MOUT << ',';
		}
		else
		{
			MOUT << ' ';
			fPrevWritten = TRUE;
		}

		MOUT << *pInts;
		pInts++;
	}

	if (cMaxInts > cInts)
	{
		MOUT << "...";
	}
}



//-----------------------------------------------------------------------------
// PrintFont
//
// Prints out the font name and point size given a pointer to
// a PACK_FONT structure.
//
// Arguments:
//  PPACK_FONT ppf - Pointer to a PACK_FONT structure.  If the nHeight field
//				   is -1, then the PACK_FONT structure is considered invalid
//				   and nothing is printed.
//
//-----------------------------------------------------------------------------

VOID PrintFont(PPACK_FONT ppf)
{
	if (ppf->nHeight != -1)
	{
		int nPointSize;
		int cyPixelsPerInch;
		HDC hdc;

		//
		// Calculate the point size given the pixels.
		//
		hdc = ::GetDC(theApp.m_pMainWnd->m_hWnd);
		cyPixelsPerInch = GetDeviceCaps(hdc, LOGPIXELSY);
		ReleaseDC(theApp.m_pMainWnd->m_hWnd, hdc);
		nPointSize = MulDiv(ppf->nHeight, 72, cyPixelsPerInch);

		MOUT << " (\"" << ppf->szFaceName << "\" " << nPointSize << ids(IDS_POINT_ABBREV) << ')';
	}
}



//-----------------------------------------------------------------------------
// ParmDecode
//
// The generic parameter decoder function.  This function is called to
// do the parameter decoding of all messages that do not have specific
// decoding that needs to be done (neither wParam nor lParam points to
// a string or a structure).
//
// Arguments:
//  Same as all parameter decoder functions.
//
//-----------------------------------------------------------------------------

DECODEPARM(Generic)
{
	P2WPOUT();
	P2LPOUT();
}



//-----------------------------------------------------------------------------
// TableOrValue2(...UINT uValue)
//
// Prints the value of uValue if found in the specified
// table, otherwise prints it out as either a DWORD or
// WORD value, depending on its size.
//
// Used for parameter decoding crackers only, NOT for message or
// return value crackers!
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

VOID TableOrValue2(CMsgParmStream* pmps, VALUETABLE *ptbl, UINT uValue)
{
	if (!(TableOrNothing2(pmps, ptbl, uValue)))
	{
		if (uValue > 0xFFFF)
		{
			*pmps << (DWORD)uValue;
		}
		else
		{
			*pmps << (WORD)uValue;
		}
	}
}



//-----------------------------------------------------------------------------
// TableOrDWord2
//
// Prints the value of uValue if found in the specified
// table, otherwise prints it out as a DWORD value.
//
// Used for parameter decoding crackers only, NOT for message or
// return value crackers!
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

VOID TableOrDWord2(CMsgParmStream* pmps, VALUETABLE *ptbl, UINT uValue)
{
	if (!(TableOrNothing2(pmps, ptbl, uValue)))
	{
		*pmps << (DWORD)uValue;
	}
}



//-----------------------------------------------------------------------------
// TableOrNothing2
//
// Prints the value of uValue if found in the specified table,
// otherwise does not print anything out and returns FALSE.
//
// Used for parameter decoding crackers only, NOT for message or
// return value crackers!
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

BOOL TableOrNothing2(CMsgParmStream* pmps, VALUETABLE *ptbl, UINT uValue)
{
	while (ptbl->pszValue)
	{
		if (uValue == ptbl->nValue)
		{
			*pmps << ptbl->pszValue;
			return TRUE;
		}

		ptbl++;
	}

	return FALSE;
}



//-----------------------------------------------------------------------------
// TableOrInt2
//
// Prints the value of uValue if found in the specified
// table, otherwise prints it out as an INT value.
//
// Used for parameter decoding crackers only, NOT for message or
// return value crackers!
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

VOID TableOrInt2(CMsgParmStream* pmps, VALUETABLE *ptbl, UINT uValue)
{
	if (!(TableOrNothing2(pmps, ptbl, uValue)))
	{
		*pmps << (INT)uValue;
	}
}



//-----------------------------------------------------------------------------
// TableFlags2
//
// Prints the flag values found in uValue that match the flags
// found in the specified table, separated by " | ".  If there
// are any bits remaining in the uValue parameter that are not
// accounted for after checking all the flags in the table, they
// will be printed out at the end as a WORD or DWORD.
//
// Used for parameter decoding crackers only, NOT for message or
// return value crackers!
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

VOID TableFlags2(CMsgParmStream* pmps, VALUETABLE *ptbl, UINT uValue)
{
	BOOL fPrevious = FALSE;

	while (ptbl->pszValue)
	{
		if (ptbl->nValue & uValue)
		{
			if (fPrevious)
			{
				*pmps << " | ";
			}
			else
			{
				fPrevious = TRUE;
			}

			*pmps << ptbl->pszValue;
			uValue &= ~ptbl->nValue;
		}

		ptbl++;
	}

	//
	// Was there nothing written or are there any bits that are left?
	//
	if (!fPrevious || uValue)
	{
		if (fPrevious)
		{
			*pmps << " | ";
		}

		if (uValue > 0xFFFF)
		{
			*pmps << (DWORD)uValue;
		}
		else
		{
			*pmps << (WORD)uValue;
		}
	}
}



//-----------------------------------------------------------------------------
// PrintIntArray2
//
// Prints out a list of integers in an array separated by commas.
// If there was originally more integers than are available for
// display, it will add trailing ellipses on the end.
//
// Used for parameter decoding crackers only, NOT for message or
// return value crackers!
//
// Arguments:
//  CMsgParmStream* pmps	- The stream to write to.
//  PINT pInts			  - Pointer to an array of ints.
//  INT cInts			   - Ints in the pInts array.
//  INT cMaxInts			- The total original ints.  If this is larger than
//							cInts then the ellipses will be shown.
//
//-----------------------------------------------------------------------------

VOID PrintIntArray2(CMsgParmStream* pmps, PINT pInts, INT cInts, INT cMaxInts)
{
	int i;
	BOOL fPrevWritten = FALSE;

	for (i = 0; i < cInts; i++)
	{
		if (fPrevWritten)
		{
			M2OUT << ", ";
		}
		else
		{
			fPrevWritten = TRUE;
		}

		M2OUT << *pInts;
		pInts++;
	}

	if (cMaxInts > cInts)
	{
		M2OUT << " ...";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\msgfdlg.cpp ===
// msgfdlg.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"
#include "findtool.h"
#include "filtrdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFiltersMessageDlgTab dialog

//
// The message group table that describes the different message groups
// that a message can belong to.  This table is indexed by the message
// type constants (MT_*).  If it is changed, these indices must be
// updated as well!
//
MSGGROUP CFiltersMessageDlgTab::m_aMsgGroup[] =
{
	//
	// The first entry is the miscellaneous group.  This one will not
	// have a corresponding checkbox in the Message Filters dialog
	// because they cannot be selected as a group.
	//
	{0,				0, 0},	// MT_MISC
	{IDC_FMT_DDE,	0, 0},	// MT_DDE
	{IDC_FMT_CLIP,	0, 0},	// MT_CLIP
	{IDC_FMT_MOUSE,	0, 0},	// MT_MOUSE
	{IDC_FMT_NC,	0, 0},	// MT_NC
	{IDC_FMT_KEYBD,	0, 0},	// MT_KEYBD
	{IDC_FMT_BM,	0, 0},	// MT_BM
	{IDC_FMT_CB,	0, 0},	// MT_CB
	{IDC_FMT_EM,	0, 0},	// MT_EM
	{IDC_FMT_LB,	0, 0},	// MT_LB
	{IDC_FMT_STM,	0, 0},	// MT_STM
	{IDC_FMT_MDI,	0, 0},	// MT_MDI
	{IDC_FMT_SBM,	0, 0},	// MT_SBM
	{IDC_FMT_IME,	0, 0},	// MT_IME
	{IDC_FMT_DLG,	0, 0},	// MT_DLG
	{IDC_FMT_ANI, 	0, 0},	// MT_ANI
	{IDC_FMT_HDR, 	0, 0},	// MT_HDR
	{IDC_FMT_HK,  	0, 0},	// MT_HK
	{IDC_FMT_LV,  	0, 0},	// MT_LV
	{IDC_FMT_PROG,	0, 0},	// MT_PRG
	{IDC_FMT_STAT,	0, 0},	// MT_STB
	{IDC_FMT_TRK, 	0, 0},	// MT_TB
	{IDC_FMT_TB,  	0, 0},	// MT_TLB
	{IDC_FMT_TAB, 	0, 0},	// MT_TAB
	{IDC_FMT_TT,  	0, 0},	// MT_TT
	{IDC_FMT_TV,  	0, 0},	// MT_TV
	{IDC_FMT_UD,  	0, 0},	// MT_UD
};

int CFiltersMessageDlgTab::m_cMsgGroups = sizeof(CFiltersMessageDlgTab::m_aMsgGroup) / sizeof(MSGGROUP);
BOOL CFiltersMessageDlgTab::m_fInitializedStatic = FALSE;



CFiltersMessageDlgTab::~CFiltersMessageDlgTab()
{
	if (m_paiSelected)
	{
		delete [] m_paiSelected;
	}

	if (m_paiSelected2)
	{
		delete [] m_paiSelected2;
	}
}



BEGIN_MESSAGE_MAP(CFiltersMessageDlgTab, CDlgTab)
	//{{AFX_MSG_MAP(CFiltersMessageDlgTab)
	ON_BN_CLICKED(IDC_FMT_ALL, OnClickedMsgFiltersAll)
	ON_BN_CLICKED(IDC_FMT_NONE, OnClickedMsgFiltersNone)
	ON_BN_CLICKED(IDC_FMT_BM, OnClickedMsgFiltersBM)
	ON_BN_CLICKED(IDC_FMT_CB, OnClickedMsgFiltersCB)
	ON_BN_CLICKED(IDC_FMT_CLIP, OnClickedMsgFiltersClip)
	ON_BN_CLICKED(IDC_FMT_DDE, OnClickedMsgFiltersDDE)
	ON_BN_CLICKED(IDC_FMT_EM, OnClickedMsgFiltersEM)
	ON_BN_CLICKED(IDC_FMT_KEYBD, OnClickedMsgFiltersKeybd)
	ON_BN_CLICKED(IDC_FMT_LB, OnClickedMsgFiltersLB)
	ON_BN_CLICKED(IDC_FMT_MOUSE, OnClickedMsgFiltersMouse)
	ON_BN_CLICKED(IDC_FMT_NC, OnClickedMsgFiltersNC)
	ON_BN_CLICKED(IDC_FMT_STM, OnClickedMsgFiltersSTM)
	ON_BN_CLICKED(IDC_FMT_MDI, OnClickedMsgFiltersMDI)
	ON_BN_CLICKED(IDC_FMT_SBM, OnClickedMsgFiltersSBM)
	ON_BN_CLICKED(IDC_FMT_IME, OnClickedMsgFiltersIME)
	ON_BN_CLICKED(IDC_FMT_DLG, OnClickedMsgFiltersDlg)
	ON_BN_CLICKED(IDC_FMT_ANI, OnClickedMsgFiltersAni)
	ON_BN_CLICKED(IDC_FMT_HDR, OnClickedMsgFiltersHdr)
	ON_BN_CLICKED(IDC_FMT_HK, OnClickedMsgFiltersHK)
	ON_BN_CLICKED(IDC_FMT_LV, OnClickedMsgFiltersLV)
	ON_BN_CLICKED(IDC_FMT_PROG, OnClickedMsgFiltersProg)
	ON_BN_CLICKED(IDC_FMT_STAT, OnClickedMsgFiltersStat)
	ON_BN_CLICKED(IDC_FMT_TAB, OnClickedMsgFiltersTab)
	ON_BN_CLICKED(IDC_FMT_TB, OnClickedMsgFiltersTB)
	ON_BN_CLICKED(IDC_FMT_TRK, OnClickedMsgFiltersTrk)
	ON_BN_CLICKED(IDC_FMT_TT, OnClickedMsgFiltersTT)
	ON_BN_CLICKED(IDC_FMT_TV, OnClickedMsgFiltersTV)
	ON_BN_CLICKED(IDC_FMT_UD, OnClickedMsgFiltersUD)
	ON_LBN_SELCHANGE(IDC_FMT_LIST, OnSelchangeMsgFiltersList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



//-----------------------------------------------------------------------------
// CFiltersMessageDlgTab::InitStaticData
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

void CFiltersMessageDlgTab::InitStaticData()
{
	INT i;

	//
	// Calculate the counts in the message groups.  This is best
	// done at run time to be safe.
	//
	for (i = 0; i < CMsgDoc::m_cMsgs; i++)
	{
		//
		// Increment the total for the group that this message
		// belongs to.
		//
		m_aMsgGroup[CMsgDoc::m_aMsgDesc[i].iMsgType].cMsgs++;
	}

	m_fInitializedStatic = TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CFiltersMessageDlgTab message handlers

BOOL CFiltersMessageDlgTab::OnInitDialog()
{
	int i;
	int iSel;
	PMSGDESC pmd;
	CListBox* pMsgsListBox = (CListBox*)GetDlgItem(IDC_FMT_LIST);

	CDlgTab::OnInitDialog();

	BeginWaitCursor();

	if (!m_fInitializedStatic)
	{
		InitStaticData();
	}

	CFont* pFont = GetStdFont(font_Normal);
	ASSERT(pFont);
	HFONT hfont = (HFONT)pFont->m_hObject;

	SendDlgItemMessage(IDC_FMT_LIST, WM_SETFONT, (WPARAM)hfont, FALSE);

	m_pDoc = ((CFiltersTabbedDialog*)GetParent())->m_pDoc;

	//
	// Allocate arrays of integers large enough to hold the indexes
	// of all the messages in the message table.
	//
	m_paiSelected = new int[CMsgDoc::m_cMsgs];
	m_paiSelected2 = new int[CMsgDoc::m_cMsgs];

	for (i = 0; i < m_cMsgGroups; i++)
	{
		m_aMsgGroup[i].cUseCount = 0;
	}

	for (i = 0, pmd = CMsgDoc::m_aMsgDesc; i < CMsgDoc::m_cMsgs; i++, pmd++)
	{
		iSel = pMsgsListBox->AddString(pmd->pszMsg);
		pMsgsListBox->SetItemDataPtr(iSel, pmd);

		if (pmd->msg < WM_USER)
		{
			if (m_pDoc->m_afSelected[pmd->msg])
			{
				pMsgsListBox->SetSel(iSel);
				m_aMsgGroup[pmd->iMsgType].cUseCount++;
			}
		}
		else
		{
			switch(pmd->iMsgType)
			{
				case MT_DLG:

					if (m_pDoc->m_afDlgSelected[pmd->msg - WM_USER])
					{
						pMsgsListBox->SetSel(iSel);
						m_aMsgGroup[pmd->iMsgType].cUseCount++;
					}
					break;
#ifndef DISABLE_WIN95_MESSAGES
				case MT_ANI:

					if (m_pDoc->m_afAniSelected[pmd->msg - (WM_USER + 100)])
					{
						pMsgsListBox->SetSel(iSel);
						m_aMsgGroup[pmd->iMsgType].cUseCount++;
					}
					break;

				case MT_HDR:

					if (m_pDoc->m_afHdrSelected[pmd->msg - HDM_FIRST])
					{
						pMsgsListBox->SetSel(iSel);
						m_aMsgGroup[pmd->iMsgType].cUseCount++;
					}
					break;

				case MT_HK:

					if (m_pDoc->m_afHKSelected[pmd->msg - (WM_USER + 1)])
					{
						pMsgsListBox->SetSel(iSel);
						m_aMsgGroup[pmd->iMsgType].cUseCount++;
					}
					break;

				case MT_LV:

					if (m_pDoc->m_afLVSelected[pmd->msg - LVM_FIRST])
					{
						pMsgsListBox->SetSel(iSel);
						m_aMsgGroup[pmd->iMsgType].cUseCount++;
					}
					break;

				case MT_PRG:

					if (m_pDoc->m_afProgSelected[pmd->msg - (WM_USER + 1)])
					{
						pMsgsListBox->SetSel(iSel);
						m_aMsgGroup[pmd->iMsgType].cUseCount++;
					}
					break;

				case MT_STB:

					if (m_pDoc->m_afStatSelected[pmd->msg - (WM_USER + 1)])
					{
						pMsgsListBox->SetSel(iSel);
						m_aMsgGroup[pmd->iMsgType].cUseCount++;
					}
					break;

				case MT_TB:

					if (m_pDoc->m_afTrkSelected[pmd->msg - WM_USER])
					{
						pMsgsListBox->SetSel(iSel);
						m_aMsgGroup[pmd->iMsgType].cUseCount++;
					}
					break;

				case MT_TLB:

					if (m_pDoc->m_afTBSelected[pmd->msg - (WM_USER + 1)])
					{
						pMsgsListBox->SetSel(iSel);
						m_aMsgGroup[pmd->iMsgType].cUseCount++;
					}
					break;

				case MT_TAB:

					if (m_pDoc->m_afTabSelected[pmd->msg - TCM_FIRST])
					{
						pMsgsListBox->SetSel(iSel);
						m_aMsgGroup[pmd->iMsgType].cUseCount++;
					}
					break;

				case MT_TT:

					if (m_pDoc->m_afTTSelected[pmd->msg - (WM_USER + 1)])
					{
						pMsgsListBox->SetSel(iSel);
						m_aMsgGroup[pmd->iMsgType].cUseCount++;
					}
					break;

				case MT_TV:

					if (m_pDoc->m_afTVSelected[pmd->msg - TV_FIRST])
					{
						pMsgsListBox->SetSel(iSel);
						m_aMsgGroup[pmd->iMsgType].cUseCount++;
					}
					break;

				case MT_UD:

					if (m_pDoc->m_afUpDnSelected[pmd->msg - (WM_USER + 101)])
					{
						pMsgsListBox->SetSel(iSel);
						m_aMsgGroup[pmd->iMsgType].cUseCount++;
					}
					break;
#endif	// DISABLE_WIN95_MESSAGES
			}
		}
	}

	//
	// Set the selection rectangle to the first item in the listbox.
	//
	pMsgsListBox->SetCaretIndex(0);

	//
	// Loop through all the message groups.
	//
	for (i = 0; i < m_cMsgGroups; i++)
	{
		//
		// Is at least one message in the group selected, and is
		// there a checkbox for the group?
		//
		if (m_aMsgGroup[i].cUseCount && m_aMsgGroup[i].idCheckBox)
		{
			//
			// Check the corresponding checkbox.  If all messages
			// in the group are selected, the checkbox is checked.
			// If only some are selected, the checkbox is set to
			// grayed (3-state).
			//
			CheckDlgButton(m_aMsgGroup[i].idCheckBox, (m_aMsgGroup[i].cUseCount == m_aMsgGroup[i].cMsgs) ? 1 : 2);
		}
	}

	if (m_pDoc->m_fMsgsUser)
	{
		CheckDlgButton(IDC_FMT_USER, 1);
	}

	if (m_pDoc->m_fMsgsRegistered)
	{
		CheckDlgButton(IDC_FMT_REGISTERED, 1);
	}

	if (m_pDoc->m_fMsgsUndocumented)
	{
		CheckDlgButton(IDC_FMT_UNDOCUMENTED, 1);
	}

	m_cItemsSave = pMsgsListBox->GetSelItems(CMsgDoc::m_cMsgs, m_paiSelected);

	EndWaitCursor();

	return TRUE;  // return TRUE  unless you set the focus to a control
}



void CFiltersMessageDlgTab::OnClickedMsgFiltersAll()
{
	int i;
	CListBox* pMsgsListBox = (CListBox*)GetDlgItem(IDC_FMT_LIST);

	//
	// Select all lines in the listbox.
	//
	pMsgsListBox->SetSel(-1, TRUE);

	for (i = 0; i < m_cMsgGroups; i++)
	{
		m_aMsgGroup[i].cUseCount = m_aMsgGroup[i].cMsgs;
		if (m_aMsgGroup[i].idCheckBox)
		{
			CheckDlgButton(m_aMsgGroup[i].idCheckBox, 1);
		}
	}

	m_cItemsSave = pMsgsListBox->GetSelItems(CMsgDoc::m_cMsgs, m_paiSelected);

	CheckDlgButton(IDC_FMT_USER, 1);
	CheckDlgButton(IDC_FMT_REGISTERED, 1);
	CheckDlgButton(IDC_FMT_UNDOCUMENTED, 1);
}



void CFiltersMessageDlgTab::OnClickedMsgFiltersNone()
{
	int i;
	CListBox* pMsgsListBox = (CListBox*)GetDlgItem(IDC_FMT_LIST);

	//
	// Unselect all lines in the listbox.
	//
	pMsgsListBox->SetSel(-1, FALSE);

	for (i = 0; i < m_cMsgGroups; i++)
	{
		m_aMsgGroup[i].cUseCount = 0;
		if (m_aMsgGroup[i].idCheckBox)
		{
			CheckDlgButton(m_aMsgGroup[i].idCheckBox, 0);
		}
	}

	m_cItemsSave = 0;

	CheckDlgButton(IDC_FMT_USER, 0);
	CheckDlgButton(IDC_FMT_REGISTERED, 0);
	CheckDlgButton(IDC_FMT_UNDOCUMENTED, 0);
}



void CFiltersMessageDlgTab::OnClickedMsgFiltersBM()
{
	OnClickedGroup(MT_BM);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersCB()
{
	OnClickedGroup(MT_CB);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersClip()
{
	OnClickedGroup(MT_CLIP);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersDDE()
{
	OnClickedGroup(MT_DDE);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersEM()
{
	OnClickedGroup(MT_EM);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersKeybd()
{
	OnClickedGroup(MT_KEYBD);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersLB()
{
	OnClickedGroup(MT_LB);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersMouse()
{
	OnClickedGroup(MT_MOUSE);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersNC()
{
	OnClickedGroup(MT_NC);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersSTM()
{
	OnClickedGroup(MT_STM);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersMDI()
{
	OnClickedGroup(MT_MDI);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersSBM()
{
	OnClickedGroup(MT_SBM);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersIME()
{
	OnClickedGroup(MT_IME);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersDlg() 
{
	OnClickedGroup(MT_DLG);
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersAni() 
{
#ifndef DISABLE_WIN95_MESSAGES
	OnClickedGroup(MT_ANI);
#endif	// DISABLE_WIN95_MESSAGES
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersHdr() 
{
#ifndef DISABLE_WIN95_MESSAGES
	OnClickedGroup(MT_HDR);
#endif	// DISABLE_WIN95_MESSAGES
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersHK() 
{
#ifndef DISABLE_WIN95_MESSAGES
	OnClickedGroup(MT_HK);
#endif	// DISABLE_WIN95_MESSAGES
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersLV() 
{
#ifndef DISABLE_WIN95_MESSAGES
	OnClickedGroup(MT_LV);
#endif	// DISABLE_WIN95_MESSAGES
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersProg() 
{
#ifndef DISABLE_WIN95_MESSAGES
	OnClickedGroup(MT_PRG);
#endif	// DISABLE_WIN95_MESSAGES
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersStat() 
{
#ifndef DISABLE_WIN95_MESSAGES
	OnClickedGroup(MT_STB);
#endif	// DISABLE_WIN95_MESSAGES
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersTab() 
{
#ifndef DISABLE_WIN95_MESSAGES
	OnClickedGroup(MT_TAB);
#endif	// DISABLE_WIN95_MESSAGES
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersTB() 
{
#ifndef DISABLE_WIN95_MESSAGES
	OnClickedGroup(MT_TLB);
#endif	// DISABLE_WIN95_MESSAGES
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersTrk() 
{
#ifndef DISABLE_WIN95_MESSAGES
	OnClickedGroup(MT_TB);
#endif	// DISABLE_WIN95_MESSAGES
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersTT() 
{
#ifndef DISABLE_WIN95_MESSAGES
	OnClickedGroup(MT_TT);
#endif	// DISABLE_WIN95_MESSAGES
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersTV() 
{
#ifndef DISABLE_WIN95_MESSAGES
	OnClickedGroup(MT_TV);
#endif	// DISABLE_WIN95_MESSAGES
}

void CFiltersMessageDlgTab::OnClickedMsgFiltersUD() 
{
#ifndef DISABLE_WIN95_MESSAGES
	OnClickedGroup(MT_UD);
#endif	// DISABLE_WIN95_MESSAGES
}

void CFiltersMessageDlgTab::OnClickedGroup(int iGroup)
{
	int i;
	BOOL fChecked;
	int iTopIndex;
	int cItems;
	int iSel;
	BOOL fSel;
	PMSGGROUP pmg;
	PMSGDESC pmd;
	CListBox* pMsgsListBox = (CListBox*)GetDlgItem(IDC_FMT_LIST);

	ASSERT(iGroup < m_cMsgGroups);
	pmg = &m_aMsgGroup[iGroup];

	fChecked = IsDlgButtonChecked(pmg->idCheckBox);
	if (fChecked == 1)
		fChecked = FALSE;
	else
		fChecked = TRUE;

	if (fChecked)
	{
		pMsgsListBox->SetRedraw(FALSE);
		iTopIndex = pMsgsListBox->GetTopIndex();
	}

	//
	// Get the list of currently selected items.
	//
	cItems = pMsgsListBox->GetSelItems(CMsgDoc::m_cMsgs, m_paiSelected);

	//
	// Look for all the messages in this group.
	//
	for (i = 0, iSel = 0; i < CMsgDoc::m_cMsgs; i++)
	{
		pmd = (PMSGDESC)pMsgsListBox->GetItemDataPtr(i);
		ASSERT(pmd);
		if (pmd->iMsgType == iGroup)
		{
			//
			// Bump up through the list of selected items, looking
			// to see if this item is currently selected.
			//
			for (fSel = FALSE; iSel < cItems && m_paiSelected[iSel] <= i; iSel++)
			{
				//
				// A match was found.  The item is selected.
				//
				if (m_paiSelected[iSel] == i)
				{
					fSel = TRUE;
					break;
				}
			}

			//
			// Is the current selection state of the item
			// different from the desired selection state?
			//
			if (fSel != fChecked)
			{
				//
				// Update the use count of the group that contains
				// this message.
				//
				m_aMsgGroup[pmd->iMsgType].cUseCount += fChecked ? 1 : -1;

				//
				// Select/deselect the message in the list box.
				//
				pMsgsListBox->SetSel(i, fChecked);
			}
		}
	}

	//
	// Be sure that the checkboxes reflect the updated
	// status of the message group use counts.
	//
	UpdateCheckBoxes();

	if (fChecked)
	{
		pMsgsListBox->SetTopIndex(iTopIndex);
		pMsgsListBox->SetRedraw();
		pMsgsListBox->Invalidate(FALSE);
	}

	m_cItemsSave = pMsgsListBox->GetSelItems(CMsgDoc::m_cMsgs, m_paiSelected);
}



void CFiltersMessageDlgTab::OnSelchangeMsgFiltersList()
{
	int i;
	int iSel;
	int cItems;
	int cSelItemsMax;
	BOOL fSel;
	PMSGDESC pmd;
	CListBox* pMsgsListBox = (CListBox*)GetDlgItem(IDC_FMT_LIST);

	cItems = pMsgsListBox->GetSelItems(CMsgDoc::m_cMsgs, m_paiSelected2);
	if (cItems == m_cItemsSave)
	{
		//
		// Nothing changed except for the selection
		// rectangle moving.  We are done.
		//
		return;
	}

	if (cItems > m_cItemsSave)
	{
		//
		// A message was selected.  Look for it.
		//
		for (i = 0; i < m_cItemsSave &&	m_paiSelected[i] == m_paiSelected2[i]; i++);

		iSel = m_paiSelected2[i];
		fSel = TRUE;
	}
	else
	{
		//
		// A message was unselected.  Look for it.
		//
		for (i = 0; i < cItems && m_paiSelected[i] == m_paiSelected2[i]; i++);

		iSel = m_paiSelected[i];
		fSel = FALSE;
	}

	//
	// Get the currently selected item.  It was either
	// just turned on or off.
	//
	pmd = (PMSGDESC)pMsgsListBox->GetItemDataPtr(iSel);

	//
	// Update the use count for the group that this
	// message belongs to.
	//
	m_aMsgGroup[pmd->iMsgType].cUseCount += fSel ? 1 : -1;

	//
	// Be sure that the checkboxes reflect the updated
	// status of the message group use counts.
	//
	UpdateCheckBoxes();

	//
	// Save away the new selected item array.
	//
	cSelItemsMax = max(cItems, m_cItemsSave);
	for (i = 0; i < cSelItemsMax; i++)
	{
		m_paiSelected[i] = m_paiSelected2[i];
	}

	m_cItemsSave = cItems;
}


void CFiltersMessageDlgTab::UpdateCheckBoxes()
{
	int i;
	int fState;

	for (i = 0; i < m_cMsgGroups; i++)
	{
		if (m_aMsgGroup[i].idCheckBox)
		{
			if (m_aMsgGroup[i].cUseCount == m_aMsgGroup[i].cMsgs)
				fState = 1;
			else if (m_aMsgGroup[i].cUseCount == 0)
				fState = 0;
			else
				fState = 2;

			CheckDlgButton(m_aMsgGroup[i].idCheckBox, fState);
		}
	}
}



void CFiltersMessageDlgTab::CommitTab()
{
	int cItems;
	int i;
	PMSGDESC pmd;
	CListBox* pMsgsListBox = (CListBox*)GetDlgItem(IDC_FMT_LIST);

	cItems = pMsgsListBox->GetSelItems(CMsgDoc::m_cMsgs, m_paiSelected);

	//
	// Unselect all messages first.
	//
	for (i = 0; i < CMsgDoc::m_cMsgs; i++)
	{
		if (CMsgDoc::m_aMsgDesc[i].msg < WM_USER)
			m_pDoc->m_afSelected[CMsgDoc::m_aMsgDesc[i].msg] = FALSE;
		else
		{
			switch(CMsgDoc::m_aMsgDesc[i].iMsgType)
			{
				case MT_DLG:

					m_pDoc->m_afDlgSelected[CMsgDoc::m_aMsgDesc[i].msg - WM_USER] = FALSE;
					break;
#ifndef DISABLE_WIN95_MESSAGES
				case MT_ANI:

					m_pDoc->m_afAniSelected[CMsgDoc::m_aMsgDesc[i].msg - (WM_USER + 100)] = FALSE;
					break;

				case MT_HDR:

					m_pDoc->m_afHdrSelected[CMsgDoc::m_aMsgDesc[i].msg - HDM_FIRST] = FALSE;
					break;

				case MT_HK:

					m_pDoc->m_afHKSelected[CMsgDoc::m_aMsgDesc[i].msg - (WM_USER + 1)] = FALSE;
					break;

				case MT_LV:

					m_pDoc->m_afLVSelected[CMsgDoc::m_aMsgDesc[i].msg - LVM_FIRST] = FALSE;
					break;

				case MT_PRG:

					m_pDoc->m_afProgSelected[CMsgDoc::m_aMsgDesc[i].msg - (WM_USER + 1)] = FALSE;
					break;

				case MT_STB:

					m_pDoc->m_afStatSelected[CMsgDoc::m_aMsgDesc[i].msg - (WM_USER + 1)] = FALSE;
					break;

				case MT_TB:

					m_pDoc->m_afTrkSelected[CMsgDoc::m_aMsgDesc[i].msg - WM_USER] = FALSE;
					break;

				case MT_TLB:

					m_pDoc->m_afTBSelected[CMsgDoc::m_aMsgDesc[i].msg - (WM_USER + 1)] = FALSE;
					break;

				case MT_TAB:

					m_pDoc->m_afTabSelected[CMsgDoc::m_aMsgDesc[i].msg - TCM_FIRST] = FALSE;
					break;

				case MT_TT:

					m_pDoc->m_afTTSelected[CMsgDoc::m_aMsgDesc[i].msg - (WM_USER + 1)] = FALSE;
					break;

				case MT_TV:

					m_pDoc->m_afTVSelected[CMsgDoc::m_aMsgDesc[i].msg - TV_FIRST] = FALSE;
					break;

				case MT_UD:

					m_pDoc->m_afUpDnSelected[CMsgDoc::m_aMsgDesc[i].msg - (WM_USER + 101)] = FALSE;
					break;
#endif	// DISABLE_WIN95_MESSAGES
			}
		}
	}

	//
	// Mark all the messages that are selected.
	//
	for (i = 0; i < cItems; i++)
	{
		pmd = (PMSGDESC)pMsgsListBox->GetItemDataPtr(m_paiSelected[i]);
		ASSERT(pmd);
		if (pmd->msg < WM_USER)
			m_pDoc->m_afSelected[pmd->msg] = TRUE;
		else
		{
			switch(pmd->iMsgType)
			{
				case MT_DLG:

					m_pDoc->m_afDlgSelected[pmd->msg - WM_USER] = TRUE;
					break;
#ifndef DISABLE_WIN95_MESSAGES
				case MT_ANI:

					m_pDoc->m_afAniSelected[pmd->msg - (WM_USER + 100)] = TRUE;
					break;

				case MT_HDR:

					m_pDoc->m_afHdrSelected[pmd->msg - HDM_FIRST] = TRUE;
					break;

				case MT_HK:

					m_pDoc->m_afHKSelected[pmd->msg - (WM_USER + 1)] = TRUE;
					break;

				case MT_LV:

					m_pDoc->m_afLVSelected[pmd->msg - LVM_FIRST] = TRUE;
					break;

				case MT_PRG:

					m_pDoc->m_afProgSelected[pmd->msg - (WM_USER + 1)] = TRUE;
					break;

				case MT_STB:

					m_pDoc->m_afStatSelected[pmd->msg - (WM_USER + 1)] = TRUE;
					break;

				case MT_TB:

					m_pDoc->m_afTrkSelected[pmd->msg - WM_USER] = TRUE;
					break;

				case MT_TLB:

					m_pDoc->m_afTBSelected[pmd->msg - (WM_USER + 1)] = TRUE;
					break;

				case MT_TAB:

					m_pDoc->m_afTabSelected[pmd->msg - TCM_FIRST] = TRUE;
					break;

				case MT_TT:

					m_pDoc->m_afTTSelected[pmd->msg - (WM_USER + 1)] = TRUE;
					break;

				case MT_TV:

					m_pDoc->m_afTVSelected[pmd->msg - TV_FIRST] = TRUE;
					break;

				case MT_UD:

					m_pDoc->m_afUpDnSelected[pmd->msg - (WM_USER + 101)] = TRUE;
					break;
#endif	// DISABLE_WIN95_MESSAGES
			}
		}
	}

	m_pDoc->m_fMsgsUser = IsDlgButtonChecked(IDC_FMT_USER);
	m_pDoc->m_fMsgsRegistered = IsDlgButtonChecked(IDC_FMT_REGISTERED);
	m_pDoc->m_fMsgsUndocumented = IsDlgButtonChecked(IDC_FMT_UNDOCUMENTED);

	//
	// If they have selected "Save as Default", copy the
	// current settings to the default settings.
	//
	if (IsDlgButtonChecked(IDC_FMT_SAVE))
	{
		CMsgDoc::m_fMsgsUserDef = m_pDoc->m_fMsgsUser;
		CMsgDoc::m_fMsgsRegisteredDef = m_pDoc->m_fMsgsRegistered;
		CMsgDoc::m_fMsgsUndocumentedDef = m_pDoc->m_fMsgsUndocumented;

		memcpy(m_pDoc->m_afSelectedDef,     m_pDoc->m_afSelected,     MAX_MESSAGES * sizeof(BYTE));
		memcpy(m_pDoc->m_afDlgSelectedDef,  m_pDoc->m_afDlgSelected,  MAX_DLG_MESSAGES * sizeof(BYTE));
#ifndef DISABLE_WIN95_MESSAGES
		memcpy(m_pDoc->m_afAniSelectedDef,  m_pDoc->m_afAniSelected,  MAX_ANI_MESSAGES * sizeof(BYTE));
		memcpy(m_pDoc->m_afHdrSelectedDef,  m_pDoc->m_afHdrSelected,  MAX_HDR_MESSAGES * sizeof(BYTE));
		memcpy(m_pDoc->m_afTBSelectedDef,   m_pDoc->m_afTBSelected,   MAX_TB_MESSAGES * sizeof(BYTE));
		memcpy(m_pDoc->m_afTTSelectedDef,   m_pDoc->m_afTTSelected,   MAX_TT_MESSAGES * sizeof(BYTE));
		memcpy(m_pDoc->m_afStatSelectedDef, m_pDoc->m_afStatSelected, MAX_STAT_MESSAGES * sizeof(BYTE));
		memcpy(m_pDoc->m_afTrkSelectedDef,  m_pDoc->m_afTrkSelected,  MAX_TRK_MESSAGES * sizeof(BYTE));
		memcpy(m_pDoc->m_afUpDnSelectedDef, m_pDoc->m_afUpDnSelected, MAX_UD_MESSAGES * sizeof(BYTE));
		memcpy(m_pDoc->m_afProgSelectedDef, m_pDoc->m_afProgSelected, MAX_PROG_MESSAGES * sizeof(BYTE));
		memcpy(m_pDoc->m_afHKSelectedDef,   m_pDoc->m_afHKSelected,   MAX_HK_MESSAGES * sizeof(BYTE));
		memcpy(m_pDoc->m_afLVSelectedDef,   m_pDoc->m_afLVSelected,   MAX_LV_MESSAGES * sizeof(BYTE));
		memcpy(m_pDoc->m_afTVSelectedDef,   m_pDoc->m_afTVSelected,   MAX_TV_MESSAGES * sizeof(BYTE));
		memcpy(m_pDoc->m_afTabSelectedDef,  m_pDoc->m_afTabSelected,  MAX_TAB_MESSAGES * sizeof(BYTE));
#endif	// DISABLE_WIN95_MESSAGES
	}

	CDlgTab::CommitTab();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\msghook.cpp ===
/*****************************************************************************\
*
* Module: MsgHook.cpp
*
*   Contains the message hooking code for Spy++.
*
* History:
*
\*****************************************************************************/

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static HANDLE ghHookThread = NULL;		// Hook thread handle
static HANDLE ghWriterMutex;			// Writer mutex
static HANDLE ghAccessMutex;			// Access to data mutex
static HANDLE ghReadEvent;				// Data was just read event
static HANDLE ghWrittenEvent;			// Data was just written event
static HANDLE ghOtherProcessDataEvent;	// Process data was just written event
static BYTE gabPacket[CBMSGPACKETMAX];	// Private buffer area for the packet

static CHAR gszProcessPacketClass[]		// Class for ProcessPacket window
	= "SpyxxProcessPacket";
static HWND ghwndProcessPacket;			// Hwnd that processes hook packets

//
// Array of initializing strings for the class atom array.
// This table must be updated if the CLS_* defines are
// changed!
//
static LPSTR gapszClasses[MAXCLASSATOMS] =
{
	"Button",				// CLS_BUTTON
	"ComboBox",				// CLS_COMBOBOX
	"Edit",					// CLS_EDIT
	"ListBox",				// CLS_LISTBOX
	"MDIClient",			// CLS_MDICLIENT
	"ScrollBar",			// CLS_SCROLLBAR
	"Static",				// CLS_STATIC
#ifndef DISABLE_WIN95_MESSAGES
	"#32770",				// CLS_DIALOG
	"SysAnimate32",			// CLS_ANIMATE		
	"SysHeader32",			// CLS_HEADER		
	"ToolbarWindow32",		// CLS_TOOLBAR		
	"tooltips_class32",		// CLS_TOOLTIP		
	"msctls_statusbar32",	// CLS_STATUSBAR	
	"msctls_trackbar32",	// CLS_TRACKBAR	
	"msctls_updown32",		// CLS_UPDOWN		
	"msctls_progress32",	// CLS_PROGRESS	
	"msctls_hotkey32",		// CLS_HOTKEY		
	"SysListView32",		// CLS_LISTVIEW	
	"SysTreeView32",		// CLS_TREEVIEW	
	"SysTabControl32"		// CLS_TABCTRL		
#else	// DISABLE_WIN95_MESSAGES
	"#32770"				// CLS_DIALOG
#endif	// DISABLE_WIN95_MESSAGES

};


DWORD WINAPI HookMain(LPVOID lpv);
LRESULT CALLBACK ProcessPacketWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);



//-----------------------------------------------------------------------------
// LogMsg
//
// Logs a message received from the hook.  It will pass it to each
// open and running message stream view.
//
// Arguments:
//
//
//
//-----------------------------------------------------------------------------

void LogMsg(PMSGSTREAMDATA pmsd)
{
	ASSERT(theApp.m_pMsgDocTemplate);

	//
	// Pass the message to all message stream docs
	//
	POSITION pos = theApp.m_pMsgDocTemplate->GetFirstDocPosition();
	while (pos)
	{
		CMsgDoc* pDoc = (CMsgDoc *)theApp.m_pMsgDocTemplate->GetNextDoc(pos);
		if (pDoc->IsLogging())
		{
			pDoc->LogMsg(pmsd);
		}
	}
}



/*****************************************************************************\
* CreateHookThread
*
*
*
* Arguments:
*
*
*
* Returns:
*
*
\*****************************************************************************/

BOOL CreateHookThread(void)
{
	DWORD id;
	WNDCLASS wc;

	wc.style = 0;
	wc.lpfnWndProc = ProcessPacketWndProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = AfxGetInstanceHandle();
	wc.hIcon = 0;
	wc.hCursor = 0;
	wc.hbrBackground = 0;
	wc.lpszMenuName = 0;
	wc.lpszClassName = gszProcessPacketClass;
	if (!RegisterClass(&wc))
		return FALSE;

	//
	// Create the window that will receive and process messages
	// from the hook thread.  This window MUST be created by the
	// main thread, not the hook processing thread.  This avoids
	// some nasty multithreaded problems.
	//
	ghwndProcessPacket = CreateWindow(gszProcessPacketClass, NULL, WS_CHILD, 0, 0, 0, 0,
		theApp.m_pMainWnd->m_hWnd, NULL, AfxGetInstanceHandle(), NULL);

	if (!ghwndProcessPacket)
	{
		return FALSE;
	}

	if (!(ghHookThread = CreateThread(NULL, 0, HookMain, 0L, STANDARD_RIGHTS_REQUIRED, &id)))
	{
		return FALSE;
	}

	CloseHandle(ghHookThread);

	return TRUE;
}



/*****************************************************************************\
* HookMain
*
*
*
* Arguments:
*
*
*
* Returns:
*
*
\*****************************************************************************/

DWORD WINAPI HookMain(LPVOID)
{
	DWORD cbSize;
	INT i;

	//
	// Initialize the shared memory globals for the message hook.
	//
	goffRead = 0;
	goffWrite = 0;
	gcMsgPackets = 0;
	ghWriterMutex = CreateMutex(NULL, FALSE, WRITERMUTEXNAME);
	ghAccessMutex = CreateMutex(NULL, FALSE, ACCESSMUTEXNAME);
	ghReadEvent = CreateEvent(NULL, TRUE, FALSE, READEVENTNAME);
	ghWrittenEvent = CreateEvent(NULL, TRUE, FALSE, WRITTENEVENTNAME);
	ghOtherProcessDataEvent = CreateEvent(NULL, TRUE, FALSE, OTHERPROCESSDATAEVENTNAME);

	//
	// Get the main thread ID and process ID for Spy++.
	// This code assumes that the main thread created
	// the main window.
	//
	gtidSpyxx = GetWindowThreadProcessId(theApp.m_pMainWnd->m_hWnd, &gpidSpyxx);

#ifndef DISABLE_WIN95_MESSAGES
	if (theApp.IsChicago())
		gapszClasses[CLS_UPDOWN] = "msctls_updown\0";

	//
	// Initialize the class atom array.
	//
	for (i = 0; i < MAXCLASSATOMS; i++)
	{
		if (i < CLS_ANIMATE)
		{
			gaaClasses[i] = (ATOM)RegisterClipboardFormat(gapszClasses[i]);
		}
		else
		{
			HWND hwndTmp = ::CreateWindowEx(0, gapszClasses[i], gapszClasses[i],
							0, 0, 0, 0, 0, NULL, NULL, theApp.m_hInstance, NULL);
			ASSERT(hwndTmp);
			gaaClasses[i] = (ATOM)::GetClassWord(hwndTmp, GCW_ATOM);
			::DestroyWindow(hwndTmp);
		}
		ASSERT(gaaClasses[i]);
	}
#else
	for (i = 0; i < MAXCLASSATOMS; i++)
	{
		gaaClasses[i] = (ATOM)RegisterClipboardFormat(gapszClasses[i]);
		ASSERT(gaaClasses[i]);
	}
#endif

	CMsgDoc::EnableSubclass(FALSE);
	CMsgDoc::EnableHook(FALSE);
	SetMsgHook(TRUE);

	for (;;)
	{
		WaitForSingleObject(ghWrittenEvent, INFINITE);
		WaitForSingleObject(ghAccessMutex, INFINITE);

		cbSize = *((PDWORD)(gabMsgBuf + goffRead));
		if (!cbSize)
		{
			goffRead = 0;
			cbSize = *((PDWORD)(gabMsgBuf + goffRead));
		}

		memcpy(gabPacket, gabMsgBuf + goffRead, cbSize);

		goffRead += cbSize;
		gcMsgPackets--;
		if (gcMsgPackets == 0)
		{
			ResetEvent(ghWrittenEvent);
		}

		ReleaseMutex(ghAccessMutex);
		SetEvent(ghReadEvent);

		SendMessage(ghwndProcessPacket, WM_USER_PROCESSPACKET, 0, (LPARAM)gabPacket);
	}

	ASSERT(FALSE);  // not reached
	return 0;
}



//-----------------------------------------------------------------------------
// ProcessPacketWndProc
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

LRESULT CALLBACK ProcessPacketWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
		case WM_USER_PROCESSPACKET:
			LogMsg((PMSGSTREAMDATA)lParam);
			return 0;

		default:
			return DefWindowProc(hwnd, msg, wParam, lParam);
	}
}



/*****************************************************************************\
* SetMsgHook
*
* Sets the windows hooks used to trap the messages.  After this
* is called with a TRUE for fSet, the messages will start flowing
* through the hook DLL.
*
* Arguments:
*   BOOL fSet - TRUE to hook, FALSE to unhook.
*
* Returns:
*   TRUE if successful.
*
\*****************************************************************************/
#ifndef WH_CALLWNDPROCRET
//
// Hook number for WH_CALLWNDPROCRET
// defined in winuser.h in Chicago
//
#undef  WH_MAX
#define WH_CALLWNDPROCRET 12
#define WH_MAX 12
#endif	// WH_CALLWNDPROCRET

BOOL SetMsgHook(BOOL fSet)
{
	static HHOOK hhkGetMessage = 0;
	static HHOOK hhkCallWndProc = 0;
	static HHOOK hhkCallWndRetProc = 0;
	static HINSTANCE hmodHook = 0;

	if (fSet)
	{
		if (!hmodHook)
		{
			if (!(hmodHook = GetModuleHandle("spyhk30")))
			{
				return FALSE;
			}
		}

		if (!hhkGetMessage)
		{
			if (!(hhkGetMessage = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)SpyxxGetMsgProc, hmodHook, 0)))
			{
				return FALSE;
			}
			ghhkMsgHook = hhkGetMessage;
		}

		if (!hhkCallWndProc)
		{
			if (!(hhkCallWndProc = SetWindowsHookEx(WH_CALLWNDPROC, (HOOKPROC)SpyxxCallWndProc, hmodHook, 0)))
			{
				UnhookWindowsHookEx(hhkGetMessage);
				return FALSE;
			}
			ghhkCallHook = hhkCallWndProc;
		}

		if (theApp.IsChicago() && !hhkCallWndRetProc)
		{
			if (!(hhkCallWndRetProc = SetWindowsHookEx(WH_CALLWNDPROCRET, (HOOKPROC)SpyxxCallWndRetProc, hmodHook, 0)))
			{
				UnhookWindowsHookEx(hhkGetMessage);
				UnhookWindowsHookEx(hhkCallWndProc);
				return FALSE;
			}
			ghhkRetHook = hhkCallWndRetProc;
		}
	}
	else
	{
		//
		// Be sure that there are no messages that have caused a
		// window to be subclassed but have not finished going
		// through the hooks subclass procedure.  This must be
		// checked for, or there is a possibility of a thread
		// being ready to be dispatched to the subclass proc
		// or even still having the subclass proc on its stack
		// as a return address when the unhook is done, which
		// will remove the spy hook dll from the processes
		// address space!
		//
		while (gcSubclass)
		{
			//
			// Allow a little time for the hook to clear out.
			//
			Sleep(50);
		}

		if (hhkGetMessage)
		{
			UnhookWindowsHookEx(hhkGetMessage);
			hhkGetMessage = NULL;
		}

		if (hhkCallWndProc)
		{
			UnhookWindowsHookEx(hhkCallWndProc);
			hhkCallWndProc = NULL;
		}

		if (theApp.IsChicago() && hhkCallWndProc)
		{
			UnhookWindowsHookEx(hhkCallWndRetProc);
			hhkCallWndRetProc = NULL;
		}
	}

	return TRUE;
}



//-----------------------------------------------------------------------------
// GetOtherProcessData
//
// Gets data, possibly from another process.  The window may belong
// to another process, so the method that is used is to post a special
// message to the window which is detected by the get message hook,
// which then does the actual api calls in the context of the
// other process, and trips an event that the caller of this function
// will wait on.
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

BOOL GetOtherProcessData(HWND hwnd, POTHERPROCESSDATA popd)
{
	INT i;
	DWORD pidHwnd;

	//
	// If the window cannot be spied upon, don't
	// bother posting the message.  Some windows do NOT get their
	// messages sent to hooks, and we will timeout for sure.
	//
	if (!IsSpyableWindow(hwnd))
	{
		return FALSE;
	}

	//
	// Special case requests for the Spy++ app windows.  This is
	// necessary because the Spy++ app would wait for the posted
	// message (to itself) to be processed, but it would never
	// get back to the GetMessage call to process it and would
	// thus timeout on the wait.
	//
	GetWindowThreadProcessId(hwnd, &pidHwnd);
	if (pidHwnd == gpidSpyxx)
	{
		CHAR szClass[64];

		GetClassName(hwnd, szClass, sizeof(szClass) / sizeof(CHAR));
		popd->pfnWndProc = (WNDPROC)GetWindowLong(hwnd, GWL_WNDPROC);
		popd->fValidWC = GetClassInfo(NULL, szClass, &popd->wc);
		*popd->szMenuName = 0;
		if (popd->fValidWC && popd->wc.lpszMenuName)
		{
			//
			// Is the menu name a string or an ordinal?
			//
			if (HIWORD(popd->wc.lpszMenuName))
			{
				//
				// Copy the string
				//
				_tcscpy(popd->szMenuName, popd->wc.lpszMenuName);
			}
			else
			{
				//
				// Convert the ordinal into a string
				//
				*popd->szMenuName = '#';
				_itoa((INT)LOWORD((DWORD)popd->wc.lpszMenuName), &(popd->szMenuName[1]), 10);
			}
		}

		return TRUE;
	}

	ResetEvent(ghOtherProcessDataEvent);

	//
	// Post the message.  Try up to 25 times (in case the other apps
	// queue is full) with a 1/5 second between tries.
	//
	gopd.hwnd = hwnd;
	for (i = 0; i < 25; i++)
	{
		if (PostMessage(hwnd, gmsgOtherProcessData, 0, 0))
		{
			break;
		}

		Sleep(200);
	}

	if (i == 25)
	{
		return FALSE;
	}

	//
	// Wait for the hook to get the message and respond to it by
	// filling in the other process data struct.  Return TRUE if the
	// wait did not timeout.
	//
	if (WaitForSingleObject(ghOtherProcessDataEvent, TIMEOUT_OTHERPROCESSDATA) == WAIT_OBJECT_0)
	{
		WaitForSingleObject(ghAccessMutex, INFINITE);
		memcpy(popd, &gopd, sizeof(OTHERPROCESSDATA));
		ReleaseMutex(ghAccessMutex);

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}



//-----------------------------------------------------------------------------
// IsSpyableWindow
//
// Returns TRUE if this window can be spied upon by Spy++.
//
// The system does not send messages for certain windows through
// the hook chain.  This includes the desktop window, popup menu
// and console windows.
//
// Arguments:
//  HWND hwnd - Window to check
//
// Returns:
//  TRUE if the window can be spied upon, FALSE if not.
//
//-----------------------------------------------------------------------------

BOOL IsSpyableWindow(HWND hwnd)
{
	CHAR szClass[256];
	DWORD dwProcess;

	if (!IsWindow(hwnd))
	{
		return FALSE;
	}

	//
	// Cannot spy on a window if we are unable to get its thread
	// or process id. This includes Icon Title windows for consoles.
	//
	if (GetWindowThreadProcessId(hwnd, &dwProcess) == 0)
	{
		return FALSE;
	}

	//
	// Cannot spy on the popup menu window, desktop window, or consoles.
	//
	GetClassName(hwnd, szClass, sizeof(szClass) / sizeof(CHAR));
	if (_tcscmp(szClass, "#32768") == 0	||				// PopupMenu
		_tcscmp(szClass, "#32769") == 0 ||				// Desktop
		_tcscmp(szClass, "tty") == 0 ||					// Consoles (Chicago)
		_tcscmp(szClass, "ConsoleWindowClass") == 0)	// Consoles (NT)
	{
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\msglog.h ===
// msglog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMsgLog window

typedef struct
{
	int cchText;
	LPSTR pszText;
	MSGSTREAMDATA2 msd2;
} LINE;


class CMsgLog : public CWnd
{
// Construction
public:
	CMsgLog();

// Attributes
public:

// Operations
public:
	void SetMaxLines(int cLinesMax);
	int GetMaxLines()
	{
		return m_cLinesMax;
	}
	int GetNumLines()
	{
		return m_cLines;
	}
	int GetFirstIndex()
	{
		return m_iFirst;
	}
	void SetFont(CFont* pFont, BOOL bRedraw = TRUE);
	void AddLine(LPSTR psz, PMSGSTREAMDATA pmsd);
	void ClearAll();
	void SelectLine(int iSelect);
	void ShowSelection();
	int GetCurSel()
	{
		return m_iSelected;
	}
	void ShowSelItemProperties();
	void ShowViewedItemProperties(CMsgView *pView);
	BOOL IsEmpty();
	PMSGDESC GetPopupMsgDesc()
	{
		return m_pmdPopup;
	}
	LINE *GetLinesArray()
	{
		return(m_aLines);
	}

// Implementation
public:
	virtual ~CMsgLog();

protected:
	void VerticalScroll(int n);
	void HorizontalScroll(int n);
	int GetVisibleChars();
	void UpdateScrollBars(BOOL bRedraw);
	void CalcLineSizes();
	void InvalidateLine(int iLine);

	int m_iFirst;				// Index of first line in queue
	int m_cLines;				// Number of lines in queue
	int m_iTop;					// Index of line at top of window
	int m_iLeft;				// X offset of the window
	int m_cchMax;				// Max String Length
	int m_cLinesMax;			// Max number of LINEs
	int m_cMaxVisibleLines;		// Max whole visible lines possible
	int m_iSelected;			// Index of selected line (-1 for no selection)
	HFONT m_hfont;				// Font to draw with
	int m_Tdx;					// Font width
	int m_Tdy;					// Font height
	LINE* m_aLines;				// Array of m_cLinesMax LINEs
	PMSGDESC m_pmdPopup;		// Last msg clicked on to bring up popup menu
	BOOL m_fFocusLostBetween;	// was focus lost and regained between SelectLine() calls?
	RECT m_rcFocus;				// focus rectangle in message log view -- keep for horz scroll

	// Generated message map functions
protected:
	//{{AFX_MSG(CMsgLog)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnPaint();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\msgview.cpp ===
// msgview.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"
#include "fontdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMsgView

IMPLEMENT_DYNCREATE(CMsgView, CView)

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CMsgView::CMsgView()
{
}

CMsgView::~CMsgView()
{
}


BEGIN_MESSAGE_MAP(CMsgView, CView)
	//{{AFX_MSG_MAP(CMsgView)
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_COMMAND(ID_VIEW_FONT, OnViewFont)
	ON_WM_CREATE()
	ON_WM_SETFOCUS()
	ON_COMMAND(ID_VIEW_PROPERTIES, OnViewProperties)
	ON_UPDATE_COMMAND_UI(ID_VIEW_PROPERTIES, OnUpdateViewProperties)
	ON_COMMAND(ID_VIEW_HELPONMESSAGE, OnViewHelpOnMessage)
	ON_UPDATE_COMMAND_UI(ID_VIEW_HELPONMESSAGE, OnUpdateViewHelpOnMessage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



void CMsgView::AddLine(LPSTR psz, PMSGSTREAMDATA pmsd)
{
	m_MsgLog.AddLine(psz, pmsd);

	CMsgDoc *pMsgDoc = GetDocument();

	ASSERT(pMsgDoc != NULL);

	if (pMsgDoc->m_fLogToFile && pMsgDoc->m_hLoggingFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwLen;
		WriteFile(pMsgDoc->m_hLoggingFile, psz, (DWORD)_tcslen(psz), (LPDWORD)&dwLen, NULL);
		ASSERT(dwLen == (DWORD)_tcslen(psz));
		WriteFile(pMsgDoc->m_hLoggingFile, "\r\n", (DWORD)2, (LPDWORD)&dwLen, NULL);
	}
}



/////////////////////////////////////////////////////////////////////////////
// CMsgView drawing

void CMsgView::OnPaint()
{
	// do not call CView::OnPaint since it will call OnDraw
	CWnd::OnPaint();
}

void CMsgView::OnDraw(CDC*)
{
	// do nothing here
}



/////////////////////////////////////////////////////////////////////////////
// CMsgView message handlers

void CMsgView::OnViewFont()
{
	HFONT hfontNew;

	if (hfontNew = SpyFontDialog(m_hfont))
	{
		HFONT hfontOld = m_hfont;

		SetFont(CFont::FromHandle(hfontNew));
		::DeleteObject(hfontOld);
	}
}

int CMsgView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CView::OnCreate(lpCreateStruct) == -1)
	{
		return -1;
	}

	if (m_MsgLog.Create(NULL, NULL, WS_VISIBLE | WS_CHILD, CRect(0, 0, 0, 0), this, 0) == -1)
	{
		return -1;
	}

	CFont Font;
	Font.CreateFontIndirect(&theApp.m_DefLogFont);
	SetFont(&Font, FALSE);
	Font.Detach();

	return 0;
}



void CMsgView::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);

	m_MsgLog.MoveWindow(CRect(0, 0, cx, cy));
}



void CMsgView::OnSetFocus(CWnd* pOldWnd)
{
	m_MsgLog.SetFocus();
}

void CMsgView::OnViewProperties()
{
	if (m_MsgLog.IsEmpty())
		m_MsgLog.ShowViewedItemProperties(this);
	else
		m_MsgLog.ShowSelItemProperties();
}

void CMsgView::OnUpdateViewProperties(CCmdUI* pCmdUI)
{
	//
	// Enable only if there is a selected item.
	//
	pCmdUI->Enable((m_MsgLog.IsEmpty()) || (m_MsgLog.GetCurSel() != -1));
}



void CMsgView::OnViewHelpOnMessage()
{
	//
	// Get a pointer to the message description struct for the
	// last message that was clicked on to bring up the context
	// popup menu.
	//
	PMSGDESC pmd = m_MsgLog.GetPopupMsgDesc();

	if (pmd)
	{
		theApp.InvokeWinHelp((DWORD)pmd->pszMsg, HELPTYPE_MSGHELP);
	}
}

void CMsgView::OnUpdateViewHelpOnMessage(CCmdUI* pCmdUI)
{
	//
	// Enable only if a known message was clicked on.  This
	// must be done because we can only show help on messages
	// that are known (we need a valid string to show help
	// on, of course!)
	//
//	pCmdUI->Enable(m_MsgLog.GetPopupMsgDesc() != NULL);
	pCmdUI->Enable(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\msgptabs.cpp ===
// msgptabs.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"
#include "hotlinkc.h"
#include "proptab.h"
#include "msgptabs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CMessageGeneralPropTab

CMessageGeneralPropTab::~CMessageGeneralPropTab()
{
}


INT CMessageGeneralPropTab::m_aControlIDs[] =
{
	IDC_MGT_HWND,
	IDC_MGT_NESTLEVEL,
	IDC_MGT_MESSAGE1,
	IDC_MGT_MESSAGE2,
	IDC_MGT_LRESULT,
	IDC_MGT_LIST,
	0
};


BEGIN_MESSAGE_MAP(CMessageGeneralPropTab, CPropertyTab)
	//{{AFX_MSG_MAP(CMessageGeneralPropTab)
	ON_BN_CLICKED(IDC_MGT_MSGHELP, OnMessageHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMessageGeneralPropTab message handlers

BOOL CMessageGeneralPropTab::OnInitDialog()
{
	CPropertyTab::OnInitDialog();

	m_HotLinkWindowHandle.SubclassDlgItem(IDC_MGT_HWND, this);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CMessageGeneralPropTab::UpdateFields()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	m_HotLinkWindowHandle.SetJumpObject((DWORD)pTabDlg->m_msd2.hwnd);

	SetDlgItemInt(IDC_MGT_NESTLEVEL, pTabDlg->m_msd2.nLevel);
	SetDlgItemText(IDC_MGT_MESSAGE1, pTabDlg->m_strMessage1);
	SetDlgItemText(IDC_MGT_MESSAGE2, pTabDlg->m_strMessage2);

	if (pTabDlg->m_msd2.fPostType == POSTTYPE_RETURN)
	{
		GetDlgItem(IDC_MGT_LRESULTLABEL)->ShowWindow(TRUE);
		SetDlgItemText(IDC_MGT_LRESULT, FormatHex(pTabDlg->m_msd2.lResult));
	}
	else
	{
		GetDlgItem(IDC_MGT_LRESULTLABEL)->ShowWindow(FALSE);
		SetDlgItemText(IDC_MGT_LRESULT, "");
	}

	//
	// Show the parameters in the listbox.  To do this, we construct
	// a CMsgParmStream object that the parm cracker will write to,
	// attach the listbox to it then call the appropriate cracker.
	//
	CMsgParmStream MsgParmStream;
	CListBox* pLB = (CListBox *)GetDlgItem(IDC_MGT_LIST);
	pLB->ResetContent();
	MsgParmStream.SetOutputLB(pLB);

	switch (pTabDlg->m_msd2.mtMsgType)
	{
		case MT_NORMAL:
			//
			// Call the message specific parm decoder.
			//
			(*CMsgDoc::m_apmdLT[pTabDlg->m_msd2.msg]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);

			//
			// Enable the help button.
			//
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;

		case MT_DIALOG:
			(*CMsgDoc::m_apmdDlgLT[pTabDlg->m_msd2.msg - WM_USER]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;

#ifndef DISABLE_WIN95_MESSAGES
		case MT_ANIMATE:
			(*CMsgDoc::m_apmdAniLT[pTabDlg->m_msd2.msg - (WM_USER + 100)]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;

		case MT_HEADER:
			(*CMsgDoc::m_apmdHdrLT[pTabDlg->m_msd2.msg - HDM_FIRST]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;

		case MT_HOTKEY:
			(*CMsgDoc::m_apmdHKLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;

		case MT_LISTVIEW:
			(*CMsgDoc::m_apmdLVLT[pTabDlg->m_msd2.msg - LVM_FIRST]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;

		case MT_PROGRESS:
			(*CMsgDoc::m_apmdProgLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;

		case MT_STATUSBAR:
			(*CMsgDoc::m_apmdStatLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;

		case MT_TOOLBAR:
			(*CMsgDoc::m_apmdTBLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;

		case MT_TRACKBAR:
			(*CMsgDoc::m_apmdTrkLT[pTabDlg->m_msd2.msg - WM_USER]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;

		case MT_TABCTRL:
			(*CMsgDoc::m_apmdTabLT[pTabDlg->m_msd2.msg - TCM_FIRST]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;

		case MT_TOOLTIP:
			(*CMsgDoc::m_apmdTTLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;

		case MT_TREEVIEW:
			(*CMsgDoc::m_apmdTVLT[pTabDlg->m_msd2.msg - TV_FIRST]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;

		case MT_UPDOWN:
			(*CMsgDoc::m_apmdUpDnLT[pTabDlg->m_msd2.msg - (WM_USER + 101)]->pfnDecodeParm)(&pTabDlg->m_msd2, &MsgParmStream);
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;
#endif	// DISABLE_WIN95_MESSAGES
		default:
			//
			// Call a generic parm decoder.
			//
			ParmGeneric(&pTabDlg->m_msd2, &MsgParmStream);

			//
			// No help for unknown messages, so disable the button.
			//
			GetDlgItem(IDC_MGT_MSGHELP)->EnableWindow(FALSE);
			break;
	}

	//
	// Set the horizontal extent on the scrollbar to the widest
	// string that was logged by the stream.  Note that we add
	// a little slop here to be SURE we don't clip the string.
	//
	pLB->SendMessage(LB_SETHORIZONTALEXTENT, MsgParmStream.GetMaxLineWidth() + 10, 0);
}



void CMessageGeneralPropTab::OnMessageHelp()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	//
	// Must be a known message (the button should be grayed if not)
	//
	switch(pTabDlg->m_msd2.mtMsgType)
	{
		case MT_NORMAL:
			ASSERT(pTabDlg->m_msd2.msg < MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdLT[pTabDlg->m_msd2.msg]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdLT[pTabDlg->m_msd2.msg]->pszMsg, HELPTYPE_MSGHELP);
			break;

		case MT_DIALOG:
			ASSERT(pTabDlg->m_msd2.msg >= MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdDlgLT[pTabDlg->m_msd2.msg - WM_USER]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdDlgLT[pTabDlg->m_msd2.msg - WM_USER]->pszMsg, HELPTYPE_MSGHELP);
			break;

#ifndef DISABLE_WIN95_MESSAGES
		case MT_ANIMATE:
			ASSERT(pTabDlg->m_msd2.msg >= MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdAniLT[pTabDlg->m_msd2.msg - (WM_USER + 100)]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdAniLT[pTabDlg->m_msd2.msg - (WM_USER + 100)]->pszMsg, HELPTYPE_MSGHELP);
			break;

		case MT_HEADER:
			ASSERT(pTabDlg->m_msd2.msg >= MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdHdrLT[pTabDlg->m_msd2.msg - HDM_FIRST]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdHdrLT[pTabDlg->m_msd2.msg - HDM_FIRST]->pszMsg, HELPTYPE_MSGHELP);
			break;

		case MT_HOTKEY:
			ASSERT(pTabDlg->m_msd2.msg >= MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdHKLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdHKLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]->pszMsg, HELPTYPE_MSGHELP);
			break;

		case MT_LISTVIEW:
			ASSERT(pTabDlg->m_msd2.msg >= MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdLVLT[pTabDlg->m_msd2.msg - LVM_FIRST]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdLVLT[pTabDlg->m_msd2.msg - LVM_FIRST]->pszMsg, HELPTYPE_MSGHELP);
			break;

		case MT_PROGRESS:
			ASSERT(pTabDlg->m_msd2.msg >= MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdProgLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdProgLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]->pszMsg, HELPTYPE_MSGHELP);
			break;

		case MT_STATUSBAR:
			ASSERT(pTabDlg->m_msd2.msg >= MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdStatLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdStatLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]->pszMsg, HELPTYPE_MSGHELP);
			break;

		case MT_TOOLBAR:
			ASSERT(pTabDlg->m_msd2.msg >= MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdTBLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdTBLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]->pszMsg, HELPTYPE_MSGHELP);
			break;

		case MT_TRACKBAR:
			ASSERT(pTabDlg->m_msd2.msg >= MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdTrkLT[pTabDlg->m_msd2.msg - WM_USER]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdTrkLT[pTabDlg->m_msd2.msg - WM_USER]->pszMsg, HELPTYPE_MSGHELP);
			break;

		case MT_TABCTRL:
			ASSERT(pTabDlg->m_msd2.msg >= MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdTabLT[pTabDlg->m_msd2.msg - TCM_FIRST]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdTabLT[pTabDlg->m_msd2.msg - TCM_FIRST]->pszMsg, HELPTYPE_MSGHELP);
			break;

		case MT_TOOLTIP:
			ASSERT(pTabDlg->m_msd2.msg >= MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdTTLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdTTLT[pTabDlg->m_msd2.msg - (WM_USER + 1)]->pszMsg, HELPTYPE_MSGHELP);
			break;

		case MT_TREEVIEW:
			ASSERT(pTabDlg->m_msd2.msg >= MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdTVLT[pTabDlg->m_msd2.msg - TV_FIRST]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdTVLT[pTabDlg->m_msd2.msg - TV_FIRST]->pszMsg, HELPTYPE_MSGHELP);
			break;

		case MT_UPDOWN:
			ASSERT(pTabDlg->m_msd2.msg >= MAX_MESSAGES);
			ASSERT(CMsgDoc::m_apmdUpDnLT[pTabDlg->m_msd2.msg - (WM_USER + 101)]);
			theApp.InvokeWinHelp((DWORD)CMsgDoc::m_apmdUpDnLT[pTabDlg->m_msd2.msg - (WM_USER + 101)]->pszMsg, HELPTYPE_MSGHELP);
			break;
#endif	// DISABLE_WIN95_MESSAGES
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\msgview.h ===
// msgview.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMsgView view

class CMsgDoc;

class CMsgView : public CView
{
	DECLARE_DYNCREATE(CMsgView)
protected:
	CMsgView();		 // protected constructor used by dynamic creation
	CMsgDoc * GetDocument() const { return (CMsgDoc *)CView::GetDocument(); }

// Attributes
public:

// Operations
public:
	void AddLine(LPSTR psz, PMSGSTREAMDATA pmsd);
	void SetFont(CFont* pFont, BOOL bRedraw = TRUE)
	{
		m_MsgLog.SetFont(pFont, bRedraw);
		m_hfont = (HFONT)pFont->m_hObject;
	}
	inline void SetMaxLines(int cLinesMax);
	inline int GetMaxLines();

// Implementation
protected:
	virtual ~CMsgView();
	virtual void OnDraw(CDC* pDC);	  // overridden to draw this view

	CMsgLog m_MsgLog;
	HFONT m_hfont;

	friend class CMsgDoc;
	friend class CMsgLog;

	// Generated message map functions
protected:
	//{{AFX_MSG(CMsgView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg void OnViewFont();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnViewProperties();
	afx_msg void OnUpdateViewProperties(CCmdUI* pCmdUI);
	afx_msg void OnViewHelpOnMessage();
	afx_msg void OnUpdateViewHelpOnMessage(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

inline void CMsgView::SetMaxLines(int cLinesMax)
{
	m_MsgLog.SetMaxLines(cLinesMax);
}

inline int CMsgView::GetMaxLines()
{
	return m_MsgLog.GetMaxLines();
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\msglog.cpp ===
// msglog.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMsgLog

#define FIRST()			(m_iFirst)
#define TOP()			((m_iFirst + m_iTop) % m_cLinesMax)
#define LAST()			((m_iFirst + m_cLines) % m_cLinesMax)
#define SELECTED()		((m_iFirst + m_iSelected) % m_cLinesMax)
#define INC(x)			((x) = ++(x) % m_cLinesMax)
#define OFFSETX			(m_Tdx/2)

#define BOUND(x,mn,mx)	((x) < (mn) ? (mn) : ((x) > (mx) ? (mx) : (x)))

#define FTwixtI3(l,x,h)	((x)>=(l) && (x<=h))

CMsgLog::CMsgLog()
{
	m_aLines = NULL;
	m_hfont = NULL;
	m_iSelected = -1;
	m_cchMax = 200;
	m_pmdPopup = NULL;

	//
	// Set to non-zero values until SetFont is called, or the
	// create might end up causing a divide by zero error.
	//
	m_Tdx = 1;
	m_Tdy = 1;
}

CMsgLog::~CMsgLog()
{
}

BEGIN_MESSAGE_MAP(CMsgLog, CWnd)
	//{{AFX_MSG_MAP(CMsgLog)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_WM_VSCROLL()
	ON_WM_HSCROLL()
	ON_WM_PAINT()
	ON_WM_KEYDOWN()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_RBUTTONDOWN()
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMsgLog message handlers

int CMsgLog::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

void CMsgLog::OnDestroy()
{
	CWnd::OnDestroy();

	int i;
	int iQueue;

	iQueue = FIRST();
	for (i = 0; i < m_cLines; i++, INC(iQueue))
	{
		ASSERT(m_aLines[iQueue].pszText != NULL);
		delete [] m_aLines[iQueue].pszText;
		delete [] m_aLines[iQueue].msd2.pbExtraData;
	}

	delete [] m_aLines;
}

void CMsgLog::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	CalcLineSizes();
	UpdateScrollBars(TRUE);
}

void CMsgLog::CalcLineSizes()
{
	//
	// Determine the number of full lines that can be drawn in
	// the current client area.
	//
	CRect Rect;
	GetClientRect(&Rect);
	ASSERT(m_Tdy);
	m_cMaxVisibleLines = Rect.Height() / m_Tdy;
}

void CMsgLog::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	switch (nSBCode)
	{
		case SB_LINEDOWN:
			VerticalScroll(1);
			break;

		case SB_LINEUP:
			VerticalScroll(-1);
			break;

		case SB_PAGEUP:
			VerticalScroll(-m_cMaxVisibleLines);
			break;

		case SB_PAGEDOWN:
			VerticalScroll(m_cMaxVisibleLines);
			break;

		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
			VerticalScroll(nPos - m_iTop);
			break;

		case SB_ENDSCROLL:
			break;
	}
}

void CMsgLog::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	switch (nSBCode)
	{
		case SB_LINEDOWN:
			HorizontalScroll(1);
			break;

		case SB_LINEUP:
			HorizontalScroll(-1);
			break;

		case SB_PAGEUP:
			HorizontalScroll(-GetVisibleChars());
			break;

		case SB_PAGEDOWN:
			HorizontalScroll(GetVisibleChars());
			break;

		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
			HorizontalScroll(nPos - m_iLeft);
			break;

		case SB_ENDSCROLL:
			break;
	}
}

void CMsgLog::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	int iQueue;
	int xco;
	int yco;
	int i;
	int cDrawLines;
	HBRUSH hb;
	COLORREF c;
	RECT rcT;

	dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
	c = GetSysColor(COLOR_WINDOW);
	dc.SetBkColor(c);
	hb = CreateSolidBrush(c);

	//
	// SetFont must be called before painting.
	//
	ASSERT(m_hfont);

	dc.SelectObject(m_hfont);

	iQueue = TOP();
	cDrawLines = m_cLines - m_iTop;

	xco = OFFSETX - m_iLeft * m_Tdx;
	yco = 0;

	rcT.left = dc.m_ps.rcPaint.left;
	rcT.right = dc.m_ps.rcPaint.right;

	for (i = 0; i < cDrawLines; i++)
	{
		if (FTwixtI3((int)dc.m_ps.rcPaint.top, yco,(int)dc.m_ps.rcPaint.bottom)
			|| FTwixtI3((int)dc.m_ps.rcPaint.top, yco + (int)m_Tdy, (int)dc.m_ps.rcPaint.bottom))
		{
			rcT.top = yco;
			rcT.bottom = yco + m_Tdy;

			if (m_aLines[iQueue].pszText == NULL || *(m_aLines[iQueue].pszText) == 0)
			{
				FillRect(dc.m_ps.hdc, &rcT, hb);
			}
			else
			{
				CWnd *pFocus = GetFocus();

				if (m_iSelected != -1 && iQueue == SELECTED())
				{
					if (pFocus == this || pFocus == GetParent())
					{
						dc.SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT));
						dc.SetBkColor(GetSysColor(COLOR_HIGHLIGHT));
						dc.ExtTextOut(xco, yco, ETO_OPAQUE, &rcT, m_aLines[iQueue].pszText, m_aLines[iQueue].cchText, NULL);
						dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
						dc.SetBkColor(GetSysColor(COLOR_WINDOW));

						GetClientRect(&m_rcFocus);
						m_rcFocus.top = rcT.top;
						m_rcFocus.bottom = rcT.bottom;
						dc.DrawFocusRect(&m_rcFocus);
					}
					else
					{
						dc.ExtTextOut(xco, yco, ETO_OPAQUE, &rcT, m_aLines[iQueue].pszText, m_aLines[iQueue].cchText, NULL);

						CBrush brush;
						if (brush.CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)))
						{
							GetClientRect(&m_rcFocus);
							m_rcFocus.top = rcT.top;
							m_rcFocus.bottom = rcT.bottom;
							dc.FrameRect(&m_rcFocus, &brush);
						}
					}
				}
				else
				{
					dc.ExtTextOut(xco, yco, ETO_OPAQUE, &rcT, m_aLines[iQueue].pszText, m_aLines[iQueue].cchText, NULL);
				}
			}
		}

		yco += m_Tdy;
		INC(iQueue);
	}

	//
	// Erase the rest of the client area below the lines we just
	// painted above.
	//
	if (yco < dc.m_ps.rcPaint.bottom)
	{
		rcT.top = yco;
		rcT.bottom = dc.m_ps.rcPaint.bottom;
		FillRect(dc.m_ps.hdc, &rcT, hb);
	}

	DeleteObject((HANDLE)hb);
}

void CMsgLog::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	switch (nChar)
	{
		int iCurSel;
		case VK_UP:
			if (GetCurSel() > 0)
			{
				// the ordering of get selection, set selection, scroll is important here.
				// this keeps the selected item at the top of the list during scrolling...
				iCurSel = GetCurSel();
				SelectLine(iCurSel - 1);
				if (iCurSel == m_iTop)
					VerticalScroll(-1);
			}
			break;

		case VK_DOWN:
			if (GetCurSel() < (m_cLines - 1))
			{
				// the ordering of get selection, set selection, scroll is important here.
				// this keeps the selected item at the top of the list during scrolling...
				iCurSel = GetCurSel();
				SelectLine(iCurSel + 1);
				if (iCurSel == m_iTop + m_cMaxVisibleLines - 1)
					VerticalScroll(1);
			}
			break;

		case VK_PRIOR:
			if (m_iTop < m_cMaxVisibleLines)
			{
				SelectLine(0);
				VerticalScroll(-m_iTop);
			}
			else
			{
				SelectLine(GetCurSel() - m_cMaxVisibleLines);
				VerticalScroll(-m_cMaxVisibleLines);
			}
			break;

		case VK_NEXT:
			if (m_iTop + 2 * m_cMaxVisibleLines + 1 > m_cLines)
			{
				SelectLine(m_cLines - 1);
				VerticalScroll(m_cLines - m_iTop - m_cMaxVisibleLines);
			}
			else
			{
				SelectLine(GetCurSel() + m_cMaxVisibleLines);
				VerticalScroll(m_cMaxVisibleLines);
			}
			break;

		case VK_LEFT:
			HorizontalScroll(-1);
			break;

		case VK_RIGHT:
			HorizontalScroll(1);
			break;

		case VK_HOME:
			if (m_cLines)
			{
				SelectLine(0);
				VerticalScroll(-m_iTop);
			}
			break;

		case VK_END:
			if (m_cLines)
			{
				SelectLine(m_cLines - 1);
				VerticalScroll(m_cLines - m_iTop - m_cMaxVisibleLines);
			}
			break;
	}
}

void CMsgLog::ClearAll()
{
	int i;
	int iQueue;

	iQueue = FIRST();
	for (i = 0; i < m_cLines; i++, INC(iQueue))
	{
		ASSERT(m_aLines[iQueue].pszText != NULL);
		delete [] m_aLines[iQueue].pszText;
		m_aLines[iQueue].pszText = NULL;
		delete [] m_aLines[iQueue].msd2.pbExtraData;
		m_aLines[iQueue].msd2.pbExtraData = NULL;
	}

	m_cLines = 0;
	m_iFirst = 0;
	m_iTop = 0;
	m_iLeft = 0;

	SelectLine(-1);

	UpdateScrollBars(FALSE);
	InvalidateRect(NULL, TRUE);
	UpdateWindow();
}

void CMsgLog::VerticalScroll(int n)
{
	int iMinPos;
	int iMaxPos;

	GetScrollRange(SB_VERT, &iMinPos, &iMaxPos);

	n = BOUND(m_iTop + n, iMinPos, iMaxPos) - m_iTop;
	if (n)
	{
		m_iTop += n;
		ScrollWindow(0, -n * m_Tdy, NULL, NULL);
		SetScrollPos(SB_VERT, m_iTop, TRUE);
	}
	UpdateWindow();
}

void CMsgLog::HorizontalScroll(int n)
{
	RECT rc;
	int iMinPos;
	int iMaxPos;

	GetScrollRange(SB_HORZ, &iMinPos, &iMaxPos);
	GetClientRect(&rc);

	n = BOUND(m_iLeft + n, iMinPos, iMaxPos) - m_iLeft;
	if (n)
	{
		CDC* pDC = CDC::FromHandle(::GetDC(m_hWnd));

		m_iLeft += n;

		if (m_iSelected != -1)
			pDC->DrawFocusRect(&m_rcFocus);	// to eliminate focus rect before scrolling
		ScrollWindow(-n * m_Tdx, 0, &rc, &rc);
		if (m_iSelected != -1)
			pDC->DrawFocusRect(&m_rcFocus);	// to restore focus rect after scrolling

		SetScrollPos(SB_HORZ, m_iLeft, TRUE);

		::ReleaseDC(m_hWnd, pDC->m_hDC);
	}
	UpdateWindow();
}

int CMsgLog::GetVisibleChars()
{
	RECT rcClient;

	ASSERT(m_Tdx);

	GetClientRect(&rcClient);

	return (rcClient.right - rcClient.left - OFFSETX) / m_Tdx;
}

void CMsgLog::AddLine(LPSTR psz, PMSGSTREAMDATA pmsd)
{
	int iLine;   // lines of output to show
	int cScroll;
	int cch = _tcslen(psz);
	int iNew;

	//
	// Number of lines actually displayed in the current window
	//
	iLine = m_cLines - m_iTop;

	if (m_cLines == m_cLinesMax)
	{
		iNew = m_iFirst;
		delete [] m_aLines[iNew].pszText;
		delete [] m_aLines[iNew].msd2.pbExtraData;
		m_aLines[iNew].msd2.pbExtraData = NULL;

		INC(m_iFirst);

		if (m_iTop > 0)
		{
			m_iTop--;
		}

		//
		// Do we have a selection?
		//
		if (m_iSelected != -1)
		{
			//
			// Is the selection at the top line?
			//
			if (m_iSelected == 0)
			{
				//
				// The selected line just rolled off the top of the
				// log.  Clear the selection.
				//
				SelectLine(-1);
			}
			else
			{
				//
				// Decrement the index to the selection.  Note that
				// since we are not changing the selection (just
				// adjusting the index to it to account for the line
				// that was just deleted) we do not need to call
				// SelectLine().
				//
				m_iSelected--;
			}
		}
	}
	else
	{
		iNew = LAST();
		m_cLines++;
	}

	LINE* pLineNew = &m_aLines[iNew];

	if ((pLineNew->pszText = new CHAR[cch + 1]) == NULL)
	{
		return;
	}

	_tcscpy(pLineNew->pszText, psz);
	pLineNew->cchText = cch;

	pLineNew->msd2.fPostType	= pmsd->fPostType;
	pLineNew->msd2.nLevel	   = pmsd->nLevel;
	pLineNew->msd2.hwnd		 = pmsd->hwnd;
	pLineNew->msd2.msg		  = pmsd->msg;
	pLineNew->msd2.wParam	   = pmsd->wParam;
	pLineNew->msd2.lParam	   = pmsd->lParam;
	pLineNew->msd2.lResult	  = pmsd->lResult;
	pLineNew->msd2.mtMsgType = GetMsgType(pmsd->msg, pmsd->hwnd);

	//
	// Determine if there is additional data and copy it if necessary.
	// Note that pmsd->cb is the whole size of the packet, including
	// any additional data, which will be found at the first byte
	// past the MSGSTREAMDATA structure.  Therefore, if the size in
	// pmsd->cb is greater than the size of a PMSGSTREAMDATA structure,
	// there must be additional data.
	//
	if (pLineNew->msd2.cbExtraData = pmsd->cb - sizeof(MSGSTREAMDATA))
	{
		pLineNew->msd2.pbExtraData = new BYTE[pLineNew->msd2.cbExtraData];
		memcpy(pLineNew->msd2.pbExtraData, pmsd + 1, pLineNew->msd2.cbExtraData);
	}
	else
	{
		pLineNew->msd2.pbExtraData = NULL;
	}

	//
	// Invalidate the area where the new line will be so that
	// it gets painted.  This is actually done by invalidating
	// all of the client area below the line just before the
	// one that was just added.
	//
	RECT rcClient;
	GetClientRect(&rcClient);

	//
	// However, we must handle the special case where the max lines
	// allowed can all be visible at once and we have reached the
	// max lines.  If this is NOT the case, we move the rectangle
	// to invalidate down to only invalidate the new line.  Otherwise,
	// we must invalidate the entire area or the existing lines
	// that just got logically scrolled up will not get painted
	// properly.
	//
	if (m_cLinesMax > m_cMaxVisibleLines || m_cLines != m_cLinesMax)
	{
		rcClient.top += iLine * m_Tdy;
	}

	InvalidateRect(&rcClient, TRUE);

	//
	// If we have more lines than we can display, scroll the window
	// such that the last line printed is now at the bottom.
	//
	if (iLine + 1 > m_cMaxVisibleLines)
	{
		cScroll = iLine + 1 - m_cMaxVisibleLines;
		UpdateScrollBars(FALSE);
		VerticalScroll(cScroll);
	}
}

void CMsgLog::UpdateScrollBars(BOOL bRedraw)
{
	int iRange;

	/* Update the scroll bars */
	iRange = m_cLines - m_cMaxVisibleLines;

	if (iRange < 0)
	{
		iRange = 0;
		VerticalScroll(-m_iTop);
	}

	SetScrollRange(SB_VERT, 0, iRange, FALSE);
	SetScrollPos(SB_VERT, m_iTop, bRedraw);

	iRange = m_cchMax - GetVisibleChars() + 1;
	if (iRange < 0)
	{
		iRange = 0;
		HorizontalScroll(-m_iLeft);
	}

	SetScrollRange(SB_HORZ, 0, iRange, FALSE);
	SetScrollPos(SB_HORZ, m_iLeft, bRedraw);
}

void CMsgLog::ShowSelection()
{
	if ((m_iSelected >= m_iTop) && (m_iSelected < (m_iTop + m_cMaxVisibleLines)))
		return;
	else if (m_iSelected < m_iTop)
		VerticalScroll(-(m_iTop - m_iSelected));
	else if (m_iSelected >= (m_iTop + m_cMaxVisibleLines))
		VerticalScroll(m_iSelected - (m_iTop + m_cMaxVisibleLines) + 1);
}

BOOL CMsgLog::IsEmpty()
{
	//
	// It is empty if the line count is zero.
	//
	return (m_cLines == 0) ? TRUE : FALSE;
}

void CMsgLog::SetFont(CFont* pFont, BOOL bRedraw)
{
	TEXTMETRIC tm;

	m_hfont = (HFONT)pFont->m_hObject;

	/* Find out the size of a Char in the font */
	CDC dc;
	CFont* pFontOld;
	dc.Attach(::GetDC(NULL));
	pFontOld = dc.SelectObject(pFont);
	dc.GetTextMetrics(&tm);
	dc.SelectObject(pFontOld);
	dc.Detach();

	m_Tdy = (int)tm.tmHeight;
	m_Tdx = (int)tm.tmAveCharWidth;

	//
	// Force the size calculations to be done because the height
	// of the new font may have changed the number of visible lines.
	//
	CalcLineSizes();
	UpdateScrollBars(FALSE);

	if (bRedraw)
	{
		InvalidateRect(NULL, TRUE);
		UpdateWindow();
	}
}

void CMsgLog::SetMaxLines(int cLinesMax)
{
	LINE* aLinesNew;
	int i;
	int iQueue;

	//
	// Zero is not valid
	//
	ASSERT(cLinesMax != 0);

	//
	// Allocate a new array with the requested number of lines.
	// Note that we do a memset to quickly zero out the memory
	// instead of looping through each one.  This is only ok
	// because we initially want each line structure set to
	// all zeros.
	//
	aLinesNew = new LINE[cLinesMax];
	memset(aLinesNew, 0, sizeof(LINE) * cLinesMax);

	if (m_aLines)
	{
		//
		// Are we making the maximum lines be less than the current
		// lines the log has?  If so, we need to delete the extra
		// lines.
		//
		if (cLinesMax < m_cLines)
		{
			int cDelete = m_cLines - cLinesMax;

			//
			// Is the selected line one of the lines that is
			// being surplused?
			//
			if (m_iSelected != -1 && m_iSelected < cDelete)
			{
				//
				// Yes, clear the selection.
				//
				SelectLine(-1);
			}
			else
			{
				//
				// No, we can still have a selection, but we must
				// adjust the index down by the number of lines
				// that are being deleted.  Note that since we
				// are not actually changing the line that was
				// selected (just its index), we do not need to
				// call SelectLine().
				//
				m_iSelected -= cDelete;
			}

			iQueue = FIRST();
			while (cDelete--)
			{
				delete [] m_aLines[iQueue].pszText;
				delete [] m_aLines[iQueue].msd2.pbExtraData;

				INC(iQueue);
			}

			m_iFirst = iQueue;
			m_cLines = cLinesMax;
		}

		i = 0;
		iQueue = FIRST();
		while (i < m_cLines)
		{
			//
			// Do a memberwise copy of the old line structure to
			// the new one.  Note that this will copy the pointers
			// as well, including pszText and msd2.pbExtraData.
			// This is what we want, because we don't want to
			// have to allocate new blocks for these things
			// for speed.  If the line structures were a class,
			// then we would have to orphan off the old memory
			// by setting the pointers to NULL (or the destructor
			// would free the memory block out from under us!)
			// but since m_aLines is just an array of structures
			// we don't need to worry about it.
			//
			aLinesNew[i] = m_aLines[iQueue];

			i++;
			INC(iQueue);
		}

		//
		// Poof the old array now.
		//
		delete [] m_aLines;
	}
	else
	{
		m_cLines = 0;
	}

	m_iFirst = 0;
	m_iTop = 0;
	m_iLeft = 0;
	m_cLinesMax = cLinesMax;
	m_aLines = aLinesNew;

	UpdateScrollBars(TRUE);
	InvalidateRect(NULL, TRUE);
	UpdateWindow();
}

void CMsgLog::SelectLine(int iSelect)
{
	if (iSelect > (m_cLines - 1) || (!m_fFocusLostBetween && (iSelect == m_iSelected)))
	{
		return;
	}

	m_fFocusLostBetween = FALSE;
	InvalidateLine(m_iSelected);
	InvalidateLine(iSelect);

	m_iSelected = iSelect;
	if (iSelect != -1)
		SetLastSelectedObject((DWORD)&m_aLines[SELECTED()].msd2, OT_MESSAGE);
	else
		SetLastSelectedObject((DWORD)0, OT_NONE);
}

void CMsgLog::InvalidateLine(int iLine)
{
	if (iLine >= m_iTop && iLine <= m_iTop + m_cMaxVisibleLines)
	{
		RECT rc;

		GetClientRect(&rc);
		rc.top = (iLine - m_iTop) * m_Tdy;
		rc.bottom = rc.top + m_Tdy;

		InvalidateRect(&rc, TRUE);
	}
}

void CMsgLog::OnLButtonDown(UINT nFlags, CPoint point)
{
	CWnd::OnLButtonDown(nFlags, point);

	SelectLine(m_iTop + (point.y / m_Tdy));
}

void CMsgLog::ShowSelItemProperties()
{
	//
	// We must check for a valid selection here.  The following
	// scenario is possible:
	// 1. The user selects an item with the right mouse popup menu.
	// 2. More messages come in and scroll the selected line off the
	//	top and out of the circular buffer, thus removing any selection.
	// 3. The user then selects the "Properties" menu item, which is
	//	still enabled.
	//
	if (m_iSelected != -1)
	{
		CPropertyInspector::ShowObjectProperties((DWORD)&m_aLines[SELECTED()].msd2, OT_MESSAGE);
		InvalidateLine(GetCurSel());
		UpdateWindow();
	}
}

void CMsgLog::ShowViewedItemProperties(CMsgView *pView)
{
//	CPropertyInspector::ShowObjectProperties((DWORD)&m_aLines[SELECTED()].msd2, OT_MESSAGE);
	CMsgDoc *pDoc = pView->GetDocument();

	switch (pDoc->GetObjectTypeSpyingOn())
	{
		case OT_WINDOW:
			CPropertyInspector::ShowObjectProperties((DWORD)pDoc->GetWindowSpyingOn(), OT_WINDOW);
			break;

		case OT_THREAD:
			CPropertyInspector::ShowObjectProperties((DWORD)pDoc->GetThreadSpyingOn(), OT_THREAD);
			break;

		case OT_PROCESS:
			CPropertyInspector::ShowObjectProperties((DWORD)pDoc->GetProcessSpyingOn(), OT_PROCESS);
			break;

		case OT_NONE:
		default:
			break;
	}

	InvalidateLine(GetCurSel());
	UpdateWindow();
}

void CMsgLog::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	//
	// Be sure that the double-click hit a valid line
	//
	if (m_iTop + (point.y / m_Tdy) < m_cLines)
	{
		ShowSelItemProperties();
	}
}

void CMsgLog::OnRButtonDown(UINT nFlags, CPoint point)
{
	CWnd::OnRButtonDown(nFlags, point);

	//
	// Be sure that the click hit a valid line
	//
	if (m_iTop + (point.y / m_Tdy) < m_cLines)
	{
		SelectLine(m_iTop + (point.y / m_Tdy));

		PMSGSTREAMDATA2 pmsd2 = &m_aLines[SELECTED()].msd2;

		CString str;
		CMenu MenuPopup;
		if (!MenuPopup.CreatePopupMenu())
		{
			return;
		}

		str.LoadString(IDS_HELPON);

		switch (pmsd2->mtMsgType)
		{
			case MT_NORMAL:
				m_pmdPopup = CMsgDoc::m_apmdLT[pmsd2->msg];
				str += m_pmdPopup->pszMsg;
				break;

			case MT_DIALOG:
				m_pmdPopup = CMsgDoc::m_apmdDlgLT[pmsd2->msg - WM_USER];
				str += m_pmdPopup->pszMsg;
				break;

#ifndef DISABLE_WIN95_MESSAGES
			case MT_ANIMATE:
				m_pmdPopup = CMsgDoc::m_apmdAniLT[pmsd2->msg - (WM_USER + 100)];
				str += m_pmdPopup->pszMsg;
				break;

			case MT_HEADER:
				m_pmdPopup = CMsgDoc::m_apmdHdrLT[pmsd2->msg - HDM_FIRST];
				str += m_pmdPopup->pszMsg;
				break;

			case MT_HOTKEY:
				m_pmdPopup = CMsgDoc::m_apmdHKLT[pmsd2->msg - (WM_USER + 1)];
				str += m_pmdPopup->pszMsg;
				break;

			case MT_LISTVIEW:
				m_pmdPopup = CMsgDoc::m_apmdLVLT[pmsd2->msg - LVM_FIRST];
				str += m_pmdPopup->pszMsg;
				break;

			case MT_PROGRESS:
				m_pmdPopup = CMsgDoc::m_apmdProgLT[pmsd2->msg - (WM_USER + 1)];
				str += m_pmdPopup->pszMsg;
				break;

			case MT_STATUSBAR:
				m_pmdPopup = CMsgDoc::m_apmdStatLT[pmsd2->msg - (WM_USER + 1)];
				str += m_pmdPopup->pszMsg;
				break;

			case MT_TOOLBAR:
				m_pmdPopup = CMsgDoc::m_apmdTBLT[pmsd2->msg - (WM_USER + 1)];
				str += m_pmdPopup->pszMsg;
				break;

			case MT_TRACKBAR:
				m_pmdPopup = CMsgDoc::m_apmdTrkLT[pmsd2->msg - WM_USER];
				str += m_pmdPopup->pszMsg;
				break;

			case MT_TABCTRL:
				m_pmdPopup = CMsgDoc::m_apmdTabLT[pmsd2->msg - TCM_FIRST];
				str += m_pmdPopup->pszMsg;
				break;

			case MT_TOOLTIP:
				m_pmdPopup = CMsgDoc::m_apmdTTLT[pmsd2->msg - (WM_USER + 1)];
				str += m_pmdPopup->pszMsg;
				break;

			case MT_TREEVIEW:
				m_pmdPopup = CMsgDoc::m_apmdTVLT[pmsd2->msg - TV_FIRST];
				str += m_pmdPopup->pszMsg;
				break;

			case MT_UPDOWN:
				m_pmdPopup = CMsgDoc::m_apmdUpDnLT[pmsd2->msg - (WM_USER + 101)];
				str += m_pmdPopup->pszMsg;
				break;
#endif	// DISABLE_WIN95_MESSAGES
			default:
				m_pmdPopup = NULL;
				CString str2;
				str2.LoadString(IDS_MESSAGE);
				str += str2;
				break;
		}

		MenuPopup.AppendMenu(MF_STRING, ID_VIEW_HELPONMESSAGE, str);

		str.LoadString(IDS_PROPERTIES);
		MenuPopup.AppendMenu(MF_STRING, ID_VIEW_PROPERTIES, str);

		ClientToScreen(&point);
		MenuPopup.TrackPopupMenu(TPM_RIGHTBUTTON, point.x, point.y, theApp.m_pMainWnd);
	}
}

void CMsgLog::OnKillFocus(CWnd* pNewWnd)
{
	CWnd::OnKillFocus(pNewWnd);
	
	SetLastSelectedObject(0, OT_NONE);

	InvalidateLine(GetCurSel());
	UpdateWindow();
	m_fFocusLostBetween = TRUE;
}

void CMsgLog::OnSetFocus(CWnd* pOldWnd)
{
	CWnd::OnSetFocus(pOldWnd);
	
	InvalidateLine(GetCurSel());
	UpdateWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\mstream.cpp ===
/*****************************************************************************\
*
* Module: mstream.cpp
*
* Message Stream support.
*
* History:
*   03/30/93 Byron Dazey	Created.
*
\*****************************************************************************/

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

mstream& mstream::operator<<(WORD w)
{
	//
	// Save the original flags.
	//
	long flagsOld = this->flags();

	//
	// Print with leading zeros, width of 4, uppercase and hex.
	//
	this->width(4);
	this->setf(ios::hex);

	//
	// Print the word value in the standard way.
	//
	ostream::operator<<(w);

	//
	// Restore the state.
	//
	this->flags(flagsOld);

	return *this;
}


mstream& mstream::operator<<(DWORD dw)
{
	//
	// Save the original flags.
	//
	long flagsOld = this->flags();

	//
	// Print with leading zeros, width of 8, uppercase and hex.
	//
	this->width(8);
	this->setf(ios::hex);

	//
	// Print the dword value in the standard way.
	//
	ostream::operator<<(dw);

	//
	// Restore the state.
	//
	this->flags(flagsOld);

	return *this;
}


mstream& mstream::operator<<(HWND hwnd)
{
	//
	// Is the hwnd not null?
	//
	if (hwnd)
	{
		//
		// Print the hwnd as a DWORD.
		//
		*this << (DWORD)hwnd;
	}
	else
	{
		//
		// Just print out a string describing the hwnd as NULL.
		//
		*this << ids(IDS_NULL);
	}

	return *this;
}



void CMsgStream::EndLine()
{
	//
	// Don't add a blank line...
	//
	ASSERT(pcount());

	//
	// You must call SetMSDPointer before doing an "EndLine"!
	//
	ASSERT(GetMSDPointer());

	//
	// Null terminate the string in the buffer and
	// get a pointer to it.
	//
	*this << ends;
	LPSTR psz = str();

	m_pMsgView->AddLine(psz, GetMSDPointer());

	//
	// Reset the string pointer to the beginning of the buffer.
	//
	rdbuf()->freeze(0);
	seekp(0);
}



void CMsgParmStream::EndLine()
{
	CHAR szBuf[260];

	//
	// Don't add a blank line...
	//
	ASSERT(pcount());

	//
	// You must call SetOutputLB before doing an "EndLine"!
	//
	ASSERT(m_pListBox);

	//
	// Null terminate the string in the buffer and
	// get a pointer to it.
	//
	*this << ends;
	LPSTR psz = str();

	if (m_nIndent)
	{
		szBuf[0] = 0;
		for (int i = 0; i < m_nIndent; i++)
		{
			_tcscat(szBuf, "    ");
		}

		_tcscat(szBuf, psz);
		psz = szBuf;
	}

	m_pListBox->InsertString(-1, psz);

	//
	// Calculate the width of the string and update the max width member.
	//
	CDC* pDC = m_pListBox->GetDC();
	CFont* pFontOld = pDC->SelectObject(m_pListBox->GetFont());
	CSize Size = pDC->GetTextExtent(psz, strlen(psz));
	pDC->SelectObject(pFontOld);
	m_pListBox->ReleaseDC(pDC);

	if (Size.cx > m_cxMaxWidth)
	{
		m_cxMaxWidth = Size.cx;
	}

	//
	// Reset the string pointer to the beginning of the buffer.
	//
	rdbuf()->freeze(0);
	seekp(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\msgptabs.h ===
// msgptabs.h : header file
//


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CMessageGeneralPropTab window

class CMessageGeneralPropTab : public CPropertyTab
{
// Construction
public:
	CMessageGeneralPropTab(UINT nIDTemplate, UINT nIDCaption)
		: CPropertyTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CMessageGeneralPropTab)
	enum { IDD = IDD_MESSAGEGENERALTAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CMessageGeneralPropTab();
	virtual void UpdateFields();

protected:
	virtual PINT GetControlIDTable()
	{
		return m_aControlIDs;
	}

	CHotLinkCtrlWnd m_HotLinkWindowHandle;

	static INT m_aControlIDs[];

	// Generated message map functions
protected:
	//{{AFX_MSG(CMessageGeneralPropTab)
	virtual BOOL OnInitDialog();
	afx_msg void OnMessageHelp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\mstream.h ===
//-----------------------------------------------------------------------------
//  mstream.h
//
//  Copyright (C) 1993, Microsoft Corporation
//
//  Purpose:
//
//  Header for Spy Message Streams.
//
//  Notes:
//
//  Message streams are initialized with the fill character as '0'
//  and the case for printing hex values as "ios::uppercase".  This
//  is because it is so commonly used to print dword values in hex,
//  and our format for that is a width of 8, zero padded and in hex.
//  This is different than standard C++ streams, which default to
//  a fill character of ' ' and lowercase for alphabetic hex digits.
//
//  DWORD values are always printed as 8 digit hex values (ex. "0010FF4E").
//  To print a value in this format, simply cast it to a DWORD in the stream.
//
//  INT's are always printed in decimal.
//
//  mstream is the base class.  It contains the support for formatting
//  different data types properly.
//
//  CMsgStream is a derived class that writes to the CMsgLog
//  output windows.  It is used to write out the messages that
//  get logged there.
//
//  CMsgParmStream is another derived class that writes to the listbox
//  in the Property Inspector.  It is used to write out the message
//  parameters in that dialog, specifically details about parameters
//  that are pointers to structures (captured by the hook).
//
//  Revision History:
//
//  04/02/93 byrond Created.
//
//-----------------------------------------------------------------------------

#include <iostream.h>
#include <strstrea.h>
#include <iomanip.h>



#define MMANIP(T) __MMANIP_##T
#define MAPP(T) __MAPP_##T

#define MMANIPdeclare(T)  \
class MMANIP(T) { \
public: \
	MMANIP(T)(mstream& (*f)(mstream&,T), T t) { _fp = f; _tp = t; } \
	friend mstream& operator<<(mstream& s, MMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:	\
	mstream& (* _fp)(mstream&,T); \
	T _tp; \
};  \
class MAPP(T) { \
public: \
	MAPP(T)(mstream& (*f)(mstream&,T)) { _fp = f; } \
	MMANIP(T) operator()(T t) { return MMANIP(T)(_fp,t); } \
private:	\
	mstream& (* _fp)(mstream&,T); \
};


class mstream: public ostrstream
{
	public:
		mstream() : ostrstream()
		{
			//
			// By default, mstreams pad with zeros and print
			// hex digits in uppercase.
			//
			this->fill('0');
			this->setf(ios::uppercase);
		}

		mstream& operator<<(HWND hwnd);

		mstream& operator<<(int i)
		{
			return (mstream&)ostrstream::operator<<(i);
		}

		mstream& operator<<(unsigned int ui)
		{
			return (mstream&)ostrstream::operator<<(ui);
		}

		mstream& operator<<(long l)
		{
			return (mstream&)ostrstream::operator<<(l);
		}

		mstream& operator<<(WORD w);	   // unsigned short.
		mstream& operator<<(DWORD dw);	 // unsigned long.

		mstream& operator<<(char c)
		{
			return (mstream&)ostrstream::operator<<(c);
		}

		mstream& operator<<(unsigned char uc)
		{
			return (mstream&)ostrstream::operator<<(uc);
		}

		mstream& operator<<(char * psz)
		{
			return (mstream&)ostrstream::operator<<(psz);
		}

		inline mstream& operator<<(mstream& (*f)(mstream&))
		 { (void)(*f)(*this); return *this; }
		inline mstream& operator<<(ostrstream& (*f)(ostrstream&))
		 { (void)(*f)(*this); return *this; }
		inline mstream& operator<<(ostream& (*f)(ostream&))
		 { (void)(*f)(*this); return *this; }
		inline mstream& operator<<(ios& (*f)(ios&))
		 { (void)(*f)(*this); return *this; }
};



class CMsgView;

class CMsgStream: public mstream
{
	public:
		void SetView(CMsgView *pMsgView)
		{
			m_pMsgView = pMsgView;
		}

		void SetMSDPointer(PMSGSTREAMDATA pmsd)
		{
			m_pmsd = pmsd;
		}

		PMSGSTREAMDATA GetMSDPointer()
		{
			return m_pmsd;
		}

		void EndLine();

	private:
		CMsgView *m_pMsgView;
		PMSGSTREAMDATA m_pmsd;
};




class CMsgParmStream: public mstream
{
	public:
		CMsgParmStream() : mstream()
		{
			m_nIndent = 0;
			m_cxMaxWidth = 0;
		}

	public:
		void SetOutputLB(CListBox *pListBox)
		{
			m_pListBox = pListBox;
		}

		void EndLine();

		void Indent()
		{
			m_nIndent++;
		}

		void Outdent()
		{
			ASSERT(m_nIndent);
			m_nIndent--;
		}

		int GetMaxLineWidth()
		{
			return m_cxMaxWidth;
		}

	private:
		CListBox *m_pListBox;
		int m_nIndent;
		int m_cxMaxWidth;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\prcnode.cpp ===
// prctreec.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "treectl.h"
#include "spytreec.h"
#include "prcnode.h"
#include "thdnode.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CPrcTreeNode

IMPLEMENT_DYNCREATE(CPrcTreeNode, CSpyTreeNode);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

BOOL CPrcTreeNode::Create(CPROCDB *pProcessDatabase, int iPrcIndex, CMapPtrToPtr* pThdMap)
{
	LPWSTR pszExe;
	CPROCDB::PRFCNTRPROC PrfCntrProc;
	CPROCDB::PRFCNTRTHRD PrfCntrThrd;
	int iCount = 0, iLoop = pProcessDatabase->GetNumThreads(), iNumThreads = 0;

	memset((void *)&PrfCntrProc, 0, sizeof(CPROCDB::PRFCNTRPROC));
	pProcessDatabase->GetPrfCntrProc(iPrcIndex, &PrfCntrProc);

	m_pid = (DWORD)PrfCntrProc.dwProcessId;

	pszExe = (LPWSTR)pProcessDatabase->GetProcessName(iPrcIndex);
	m_strModule = wcsupr(pszExe);

	for (; iCount < iLoop; iCount++)
	{
		memset((void *)&PrfCntrThrd, 0, sizeof(CPROCDB::PRFCNTRTHRD));
		pProcessDatabase->GetPrfCntrThrd(iCount, &PrfCntrThrd);

		if (PrfCntrThrd.dwProcessId == PrfCntrProc.dwProcessId)
		{
			CThdTreeNode* pThdTreeNode = new CThdTreeNode;
			pThdTreeNode->Create(pProcessDatabase, iCount);
			this->AddChild(pThdTreeNode);
			pThdMap->SetAt((void*)pThdTreeNode->GetObjectHandle(), pThdTreeNode);
			iNumThreads++;
		}
	}

	int iSupposedNumThreads = pProcessDatabase->GetNumProcessThreads(iPrcIndex);
	ASSERT(iNumThreads == iSupposedNumThreads);

	return TRUE;
}



BOOL CPrcTreeNode::Create(HANDLE hProcessList, DWORD dwProcessID, char *szExePath, CMapPtrToPtr* pThdMap)
{
	m_pid = dwProcessID;

	char szFileName[_MAX_FNAME];
	_splitpath(szExePath, NULL, NULL, szFileName, NULL);

	m_strModule = szFileName;
//	m_strModule += " (";
//	m_strModule += szExePath;
//	m_strModule += ")";

	HANDLE hThreadList;
	THREADENTRY32 te32;

	te32.dwSize = sizeof(THREADENTRY32);

	if ((hThreadList = (*theApp.pfnCreateToolhelp32Snapshot)(TH32CS_SNAPTHREAD, 0)) != NULL)
	{
		if ((*theApp.pfnThread32First)(hThreadList, &te32))
		{
			if (te32.th32OwnerProcessID == dwProcessID)
			{
				CThdTreeNode* pThdTreeNode = new CThdTreeNode;
				pThdTreeNode->Create(hThreadList, te32.th32ThreadID, szExePath);
				this->AddChild(pThdTreeNode);
				pThdMap->SetAt((void*)pThdTreeNode->GetObjectHandle(), pThdTreeNode);
			}

			while ((*theApp.pfnThread32Next)(hThreadList, &te32))
			{
				if (te32.th32OwnerProcessID == dwProcessID)
				{
					CThdTreeNode* pThdTreeNode = new CThdTreeNode;
					pThdTreeNode->Create(hThreadList, te32.th32ThreadID, szExePath);
					this->AddChild(pThdTreeNode);
					pThdMap->SetAt((void*)pThdTreeNode->GetObjectHandle(), pThdTreeNode);
				}
			}
		}

		CloseHandle(hThreadList);
	}

	return TRUE;
}



void CPrcTreeNode::GetDescription(CString& str)
{
	LPSTR psz = str.GetBuffer(260);

	_stprintf(psz, ids(IDS_PROCESS_PARAM), m_pid, m_strModule.GetBuffer(0));

	str.ReleaseBuffer();
	m_strModule.ReleaseBuffer();
}



void CPrcTreeNode::ShowProperties()
{
	CPropertyInspector::ShowObjectProperties((DWORD)m_pid, OT_PROCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\outfdlg.cpp ===
// outfdlg.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"
#include "findtool.h"
#include "filtrdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFiltersOutputDlgTab dialog

CFiltersOutputDlgTab::~CFiltersOutputDlgTab()
{
}

BEGIN_MESSAGE_MAP(CFiltersOutputDlgTab, CDlgTab)
	//{{AFX_MSG_MAP(CFiltersOutputDlgTab)
	ON_BN_CLICKED(IDC_FOT_LOGTOFILE, OnClickedLogToFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFiltersOutputDlgTab message handlers

BOOL CFiltersOutputDlgTab::OnInitDialog()
{
	CDlgTab::OnInitDialog();

	CFont* pFont = GetStdFont(font_Normal);
	ASSERT(pFont);
	HFONT hfont = (HFONT)pFont->m_hObject;

	SendDlgItemMessage(IDC_FOT_LINES, WM_SETFONT, (WPARAM)hfont, FALSE);

	m_pDoc = ((CFiltersTabbedDialog*)GetParent())->m_pDoc;

	if (m_pDoc->m_fShowNestingLevel)
	{
		CheckDlgButton(IDC_FOT_NESTLEVEL, 1);
	}

	if (m_pDoc->m_fShowRawParms)
	{
		CheckDlgButton(IDC_FOT_RAWPARM, 1);
	}

	if (m_pDoc->m_fShowDecodedParms)
	{
		CheckDlgButton(IDC_FOT_DECODEPARM, 1);
	}

	if (m_pDoc->m_fShowRawReturn)
	{
		CheckDlgButton(IDC_FOT_RAWRET, 1);
	}

	if (m_pDoc->m_fShowDecodedReturn)
	{
		CheckDlgButton(IDC_FOT_DECODERET, 1);
	}

	if (m_pDoc->m_fShowOriginTime)
	{
		CheckDlgButton(IDC_FOT_SHOWTIME, 1);
	}

	if (m_pDoc->m_fShowMousePosition)
	{
		CheckDlgButton(IDC_FOT_SHOWPOINT, 1);
	}

	SetDlgItemInt(IDC_FOT_LINES, m_pDoc->GetMaxLines());

	if (m_pDoc->m_fLogToFile)
	{
		CheckDlgButton(IDC_FOT_LOGTOFILE, 1);
		GetDlgItem(IDC_FOT_LOGFILENAME)->EnableWindow(TRUE);
		GetDlgItem(IDC_FOT_LOGFILEAPPEND)->EnableWindow(TRUE);
		GetDlgItem(IDC_FOT_LOGFILEOVERWRITE)->EnableWindow(TRUE);
	}
	else
	{
		CheckDlgButton(IDC_FOT_LOGTOFILE, 0);
		GetDlgItem(IDC_FOT_LOGFILENAME)->EnableWindow(FALSE);
		GetDlgItem(IDC_FOT_LOGFILEAPPEND)->EnableWindow(FALSE);
		GetDlgItem(IDC_FOT_LOGFILEOVERWRITE)->EnableWindow(FALSE);
	}

	SetDlgItemText(IDC_FOT_LOGFILENAME, m_pDoc->m_strLogFileName);

	if (m_pDoc->m_fAppendFile)
	{
		CheckDlgButton(IDC_FOT_LOGFILEAPPEND, 1);
	}
	else
	{
		CheckDlgButton(IDC_FOT_LOGFILEOVERWRITE, 1);
	}

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CFiltersOutputDlgTab::OnClickedLogToFile()
{
	GetDlgItem(IDC_FOT_LOGFILENAME)->EnableWindow(IsDlgButtonChecked(IDC_FOT_LOGTOFILE));
	GetDlgItem(IDC_FOT_LOGFILEAPPEND)->EnableWindow(IsDlgButtonChecked(IDC_FOT_LOGTOFILE));
	GetDlgItem(IDC_FOT_LOGFILEOVERWRITE)->EnableWindow(IsDlgButtonChecked(IDC_FOT_LOGTOFILE));
}

BOOL CFiltersOutputDlgTab::ValidateTab()
{
	BOOL fTranslated;
	int cLinesMax = (int)GetDlgItemInt(IDC_FOT_LINES, &fTranslated, TRUE);

	if (!fTranslated || cLinesMax < 1 || cLinesMax > MAXLINESMAX)
	{
		SpyMessageBox(IDS_MSG_INVALIDMAXLINES);
		GetDlgItem(IDC_FOT_LINES)->SetFocus();
		return FALSE;
	}

	CHAR szTmp[_MAX_PATH];
	if (IsDlgButtonChecked(IDC_FOT_LOGTOFILE))
	{
		HANDLE hFile;

		if (!GetDlgItemText(IDC_FOT_LOGFILENAME, szTmp, sizeof(szTmp)))
		{
			SpyMessageBox(IDS_MSG_NOLOGFILE);
			GetDlgItem(IDC_FOT_LOGFILENAME)->SetFocus();
			return FALSE;
		}
		else if (((m_pDoc->m_strLogFileName != szTmp) && (theApp.m_strlistLogFiles.Find(szTmp) != NULL)) ||
				((m_pDoc->m_strLogFileNameDef == szTmp) && (theApp.m_strlistLogFiles.Find(szTmp) != NULL)))
		{
			// if szTmp != m_strLogFileName then the user has changed the file name since dialog init.  if
			// szTmp == m_strLogFileNameDef then the user has not changed the file name (ever).  we should
			// verify the uniqueness of the name in either of these cases.  if m_strLogFileName == szTmp and
			// m_strLogFileNameDef != szTmp then the user has changed the name before (and it was unique) so
			// we do not need to verify it again (which will fail since file name is already in global list).
			SpyMessageBox(IDS_CANNOTLOGTOFILE);
			GetDlgItem(IDC_FOT_LOGFILENAME)->SetFocus();
			return FALSE;
		}
		else if ((hFile = CreateFile(szTmp, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
		{
			SpyMessageBox(IDS_MSG_INVALIDLOGFILE);
			GetDlgItem(IDC_FOT_LOGFILENAME)->SetFocus();
			return FALSE;
		}
		else
			CloseHandle(hFile);
	}

	return TRUE;
}

void CFiltersOutputDlgTab::CommitTab()
{
	BOOL fTranslated;
	int cLinesMax = (int)GetDlgItemInt(IDC_FOT_LINES, &fTranslated, TRUE);

	m_pDoc->m_fShowNestingLevel = IsDlgButtonChecked(IDC_FOT_NESTLEVEL);
	m_pDoc->m_fShowRawParms = IsDlgButtonChecked(IDC_FOT_RAWPARM);
	m_pDoc->m_fShowDecodedParms = IsDlgButtonChecked(IDC_FOT_DECODEPARM);

	//
	// When getting the options for displaying the return
	// values, be sure to keep the return value display
	// use count up to date!
	//

	if (IsDlgButtonChecked(IDC_FOT_RAWRET))
	{
		if (!m_pDoc->m_fShowRawReturn)
		{
			m_pDoc->m_fShowRawReturn = TRUE;
			m_pDoc->m_cShowReturnUseCount++;
		}
	}
	else
	{
		if (m_pDoc->m_fShowRawReturn)
		{
			m_pDoc->m_fShowRawReturn = FALSE;
			m_pDoc->m_cShowReturnUseCount--;
		}
	}

	if (IsDlgButtonChecked(IDC_FOT_DECODERET))
	{
		if (!m_pDoc->m_fShowDecodedReturn)
		{
			m_pDoc->m_fShowDecodedReturn = TRUE;
			m_pDoc->m_cShowReturnUseCount++;
		}
	}
	else
	{
		if (m_pDoc->m_fShowDecodedReturn)
		{
			m_pDoc->m_fShowDecodedReturn = FALSE;
			m_pDoc->m_cShowReturnUseCount--;
		}
	}

	m_pDoc->m_fShowOriginTime = IsDlgButtonChecked(IDC_FOT_SHOWTIME);
	m_pDoc->m_fShowMousePosition = IsDlgButtonChecked(IDC_FOT_SHOWPOINT);
	m_pDoc->m_fLogToFile = IsDlgButtonChecked(IDC_FOT_LOGTOFILE);
	m_pDoc->m_fAppendFile = IsDlgButtonChecked(IDC_FOT_LOGFILEAPPEND);

	CHAR szTmp[_MAX_PATH];
	GetDlgItemText(IDC_FOT_LOGFILENAME, szTmp, sizeof(szTmp));

	if (m_pDoc->m_fLogToFile)
	{
		if (m_pDoc->m_strLogFileName != szTmp)
		{
			// we've already verified that specified file name is unique--if it's different
			// from the previous log file name then delete the previous file name from the
			// global list.
			POSITION pos = theApp.m_strlistLogFiles.Find(m_pDoc->m_strLogFileName);
			if (pos != NULL)
				theApp.m_strlistLogFiles.RemoveAt(pos);
		}

		theApp.m_strlistLogFiles.AddTail(szTmp);
		if (!m_pDoc->m_fAppendFile)
		{
			HANDLE hLoggingFile = CreateFile((LPCSTR)szTmp, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			if (hLoggingFile != NULL)
				CloseHandle(hLoggingFile);
		}
	}

	m_pDoc->m_strLogFileName = szTmp;

	//
	// Enable/disable hook subclassing depending on whether any
	// message stream views still want to see return values.
	//
	CMsgDoc::EnableSubclass(m_pDoc->m_cShowReturnUseCount ? TRUE : FALSE);

	m_pDoc->SetMaxLines(cLinesMax);

	//
	// If they have selected "Save as Default", copy the
	// current settings to the default settings.
	//
	if (IsDlgButtonChecked(IDC_FOT_SAVE))
	{
		CMsgDoc::m_fShowNestingLevelDef = m_pDoc->m_fShowNestingLevel;
		CMsgDoc::m_fShowRawParmsDef = m_pDoc->m_fShowRawParms;
		CMsgDoc::m_fShowDecodedParmsDef = m_pDoc->m_fShowDecodedParms;
		CMsgDoc::m_fShowRawReturnDef = m_pDoc->m_fShowRawReturn;
		CMsgDoc::m_fShowDecodedReturnDef = m_pDoc->m_fShowDecodedReturn;
		CMsgDoc::m_fShowOriginTimeDef = m_pDoc->m_fShowOriginTime;
		CMsgDoc::m_fShowMousePositionDef = m_pDoc->m_fShowMousePosition;
		CMsgDoc::m_fLogToFileDef = m_pDoc->m_fLogToFile;
		CMsgDoc::m_strLogFileNameDef = m_pDoc->m_strLogFileName;
		CMsgDoc::m_fAppendFileDef = m_pDoc->m_fAppendFile;
		CMsgDoc::m_cLinesMaxDef = cLinesMax;
	}

	CDlgTab::CommitTab();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\ncmsgs.cpp ===
//-----------------------------------------------------------------------------
//  NCMsgs.cpp
//
//  Non-Client message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

static VALUETABLE tblValidRectFlags[] =
{
	TABLEENTRY(WVR_ALIGNTOP),
	TABLEENTRY(WVR_ALIGNLEFT),
	TABLEENTRY(WVR_ALIGNBOTTOM),
	TABLEENTRY(WVR_ALIGNRIGHT),
	TABLEENTRY(WVR_HREDRAW),
	TABLEENTRY(WVR_VREDRAW),
	TABLEENTRY(WVR_VALIDRECTS),
	TABLEEND
};

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCACTIVATE)
{
	PARM(fActive, BOOL, WP);

	POUTB(fActive);

	return TRUE;
}

DECODERET(WM_NCACTIVATE)
{
	PARM(fActive, BOOL, WP);
	PARM(fDeactivateOK, BOOL, RET);

	if (fActive)
	{
		//
		// Print nothing.
		//
		return FALSE;
	}
	else
	{
		POUTB(fDeactivateOK);
		return TRUE;
	}
}

NODECODEPARM(WM_NCACTIVATE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCCALCSIZE)
{
	PARM(fCalcValidRects, BOOL, WP);

	POUTB(fCalcValidRects);

	if (fCalcValidRects)
	{
		PARM(lpncsp, LPNCCALCSIZE_PARAMS, LP);
		POUTC(lpncsp, DWORD);
	}
	else
	{
		PARM(lprc, LPRECT, LP);
		POUTC(lprc, DWORD);
	}

	return TRUE;
}

DECODERET(WM_NCCALCSIZE)
{
	PARM(fuValidRect, UINT, RET);
	PARM(fCalcValidRects, BOOL, WP);

	TABLEFLAGS(tblValidRectFlags, fuValidRect);

	if (fCalcValidRects)
	{
		PARM(lpncsp, LPNCCALCSIZE_PARAMS, LP);
		POUTC(lpncsp, DWORD);
	}
	else
	{
		PARM(lprc, LPRECT, LP);
		POUTC(lprc, DWORD);
	}

	return TRUE;
}

DECODEPARM(WM_NCCALCSIZE)
{
	PARM(fCalcValidRects, BOOL, WP2);

	P2WPOUT();

	if (fCalcValidRects)
	{
		//
		// If fCalcValidRects is not TRUE, then lParam does NOT
		// point to a valid NCCALCSIZE_PARAMS structure, so we
		// don't want to label it as doing so (and we certainly
		// wouldn't want to dereference it in the hook!)
		//
		P2LPOUTPTR(NCCALCSIZE_PARAMS);
		P2IFSIZEOF(PACK_NCCALCSIZE)
		{
			PARM(ppack, PPACK_NCCALCSIZE, ED2);

			PARM(pnccp, LPNCCALCSIZE_PARAMS, &ppack->nccp);
			INDENT();
			P2OUTRECT(pnccp, rgrc[0]);
			P2OUTRECT(pnccp, rgrc[1]);
			P2OUTRECT(pnccp, rgrc[2]);

			P2OUTPTR(pnccp, lppos, WINDOWPOS);
			PARM(lppos, PWINDOWPOS, &ppack->wp);
			INDENT();
			P2OUT(lppos, hwnd);
			P2OUT(lppos, hwndInsertAfter);
			P2OUT(lppos, x);
			P2OUT(lppos, y);
			P2OUT(lppos, cx);
			P2OUT(lppos, cy);
			P2TABLEFLAGS(tblWindowPos, lppos, flags);
		}
	}
	else
	{
		//
		// If fCalcValidRects is FALSE, lParam points to a RECT.
		//
		P2LPOUTPTR(RECT);
		P2IFSIZEOF(RECT)
		{
			PARM(lprc, LPRECT, ED2);
			INDENT();
			P2OUT(lprc, left);
			P2OUT(lprc, top);
			P2OUT(lprc, right);
			P2OUT(lprc, bottom);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCCREATE)
{
	PARM(lpcs, LPCREATESTRUCT, LP);

	POUTC(lpcs, DWORD);

	return TRUE;
}

DECODERET(WM_NCCREATE)
{
	PARM(fContinue, BOOL, RET);

	POUTB(fContinue);

	return TRUE;
}

DECODEPARM(WM_NCCREATE)
{
	DECODEPARMLIKE(WM_CREATE);
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(WM_NCDESTROY);

NODECODERET(WM_NCDESTROY);

NODECODEPARM(WM_NCDESTROY);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCHITTEST)
{
	PARM(xPos, INT, (short)LOLP);
	PARM(yPos, INT, (short)HILP);

	POUT(xPos);
	POUT(yPos);

	return TRUE;
}

DECODERET(WM_NCHITTEST)
{
	PARM(nHittest, UINT, RET);

	TABLEORVALUE(tblHitTest, nHittest);

	return TRUE;
}

NODECODEPARM(WM_NCHITTEST);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCLBUTTONDBLCLK)
{
	PARM(nHittest, INT, WP);
	PARM(xPos, INT, (short)LOLP);
	PARM(yPos, INT, (short)HILP);

	TABLEORVALUEC(tblHitTest, WORD, nHittest);
	POUT(xPos);
	POUT(yPos);

	return TRUE;
}

NODECODERET(WM_NCLBUTTONDBLCLK);

NODECODEPARM(WM_NCLBUTTONDBLCLK);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCLBUTTONDOWN)
{
	DECODELIKE(WM_NCLBUTTONDBLCLK);
}

NODECODERET(WM_NCLBUTTONDOWN);

NODECODEPARM(WM_NCLBUTTONDOWN);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCLBUTTONUP)
{
	DECODELIKE(WM_NCLBUTTONDBLCLK);
}

NODECODERET(WM_NCLBUTTONUP);

NODECODEPARM(WM_NCLBUTTONUP);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCMBUTTONDBLCLK)
{
	DECODELIKE(WM_NCLBUTTONDBLCLK);
}

NODECODERET(WM_NCMBUTTONDBLCLK);

NODECODEPARM(WM_NCMBUTTONDBLCLK);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCMBUTTONDOWN)
{
	DECODELIKE(WM_NCLBUTTONDBLCLK);
}

NODECODERET(WM_NCMBUTTONDOWN);

NODECODEPARM(WM_NCMBUTTONDOWN);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCMBUTTONUP)
{
	DECODELIKE(WM_NCLBUTTONDBLCLK);
}

NODECODERET(WM_NCMBUTTONUP);

NODECODEPARM(WM_NCMBUTTONUP);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCMOUSEMOVE)
{
	DECODELIKE(WM_NCLBUTTONDBLCLK);
}

NODECODERET(WM_NCMOUSEMOVE);

NODECODEPARM(WM_NCMOUSEMOVE);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCPAINT)
{
	PARM(hrgn, HRGN, WP);

	POUTC(hrgn, DWORD);

	return TRUE;
}

NODECODERET(WM_NCPAINT);

NODECODEPARM(WM_NCPAINT);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCRBUTTONDBLCLK)
{
	DECODELIKE(WM_NCLBUTTONDBLCLK);
}

NODECODERET(WM_NCRBUTTONDBLCLK);

NODECODEPARM(WM_NCRBUTTONDBLCLK);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCRBUTTONDOWN)
{
	DECODELIKE(WM_NCLBUTTONDBLCLK);
}

NODECODERET(WM_NCRBUTTONDOWN);

NODECODEPARM(WM_NCRBUTTONDOWN);

//////////////////////////////////////////////////////////////////////////////

DECODE(WM_NCRBUTTONUP)
{
	DECODELIKE(WM_NCLBUTTONDBLCLK);
}

NODECODERET(WM_NCRBUTTONUP);

NODECODEPARM(WM_NCRBUTTONUP);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\prcptabs.cpp ===
// prcptabs.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#pragma message("Remove local copy of TLHELP32.H when official version available.")

#include "hotlinkc.h"
#include "proptab.h"
#include "prcptabs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CProcessGeneralPropTab

CProcessGeneralPropTab::~CProcessGeneralPropTab()
{
}

INT CProcessGeneralPropTab::m_aControlIDs[] =
{
	IDC_PGT_PROCESSID,
	IDC_PGT_EXECUTABLE,
	IDC_PGT_CPUTIME,
	IDC_PGT_USERTIME,
	IDC_PGT_PRIVILEGEDTIME,
	IDC_PGT_ELAPSEDTIME,
	IDC_PGT_BASEPRIORITY,
	IDC_PGT_NUMTHREADS,
	0
};

BEGIN_MESSAGE_MAP(CProcessGeneralPropTab, CPropertyTab)
	//{{AFX_MSG_MAP(CProcessGeneralPropTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProcessGeneralPropTab message handlers

BOOL CProcessGeneralPropTab::OnInitDialog()
{
	CPropertyTab::OnInitDialog();

// begin special font mucking-around
	if (_getmbcp() != 0)
	{
		CFont* pFont = GetStdFont(font_Fixed);
		ASSERT(pFont);
		HFONT hfont = (HFONT)pFont->m_hObject;

		SendDlgItemMessage(IDC_PGT_EXECUTABLE, WM_SETFONT, (WPARAM)hfont, FALSE);
	}
// end special font mucking-around

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CProcessGeneralPropTab::UpdateFields()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	if (!theApp.IsChicago())
	{
		// Win32
		SetDlgItemText(IDC_PGT_PROCESSID, FormatHex((DWORD)pTabDlg->m_ProcessInfo.dwProcessId));
		SetDlgItemText(IDC_PGT_EXECUTABLE, pTabDlg->m_strExecutable);
		SetDlgItemText(IDC_PGT_CPUTIME, FormatTime(pTabDlg->m_ProcessInfo.liPctCPUTime));
		SetDlgItemText(IDC_PGT_USERTIME, FormatTime(pTabDlg->m_ProcessInfo.liPctUserTime));
		SetDlgItemText(IDC_PGT_PRIVILEGEDTIME, FormatTime(pTabDlg->m_ProcessInfo.liPctPrivTime));
		SetDlgItemText(IDC_PGT_ELAPSEDTIME, FormatTimeDiff(pTabDlg->m_ProcessInfo.liElapsedTime, pTabDlg->m_ProcessInfo.PerfTime));
		SetDlgItemText(IDC_PGT_BASEPRIORITY, FormatULong(pTabDlg->m_ProcessInfo.dwPriorityBase));
		SetDlgItemText(IDC_PGT_NUMTHREADS, FormatULong(pTabDlg->m_ProcessInfo.dwThrdCnt));
	}
	else
	{
		// Chicago
		SetDlgItemText(IDC_PGT_PROCESSID, FormatHex((DWORD)pTabDlg->m_ProcessEntry.th32ProcessID));
		SetDlgItemText(IDC_PGT_EXECUTABLE, pTabDlg->m_strExecutable);
	//	SetDlgItemText(IDC_PGT_CPUTIME, FormatTimeAdd(pTabDlg->m_ftPrcKernelTime, pTabDlg->m_ftPrcUserTime));
	//	SetDlgItemText(IDC_PGT_USERTIME, FormatTime(pTabDlg->m_ftPrcUserTime));
	//	SetDlgItemText(IDC_PGT_PRIVILEGEDTIME, FormatTime(pTabDlg->m_ftPrcKernelTime));
	//	SetDlgItemText(IDC_PGT_ELAPSEDTIME, FormatTimeDiff(pTabDlg->m_stPrcSnapshotTime, pTabDlg->m_ftPrcCreationTime));
		GetDlgItem(IDC_PGT_CPUTIMELABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_PGT_CPUTIME)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_PGT_USERTIMELABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_PGT_USERTIME)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_PGT_PRIVILEGEDTIMELABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_PGT_PRIVILEGEDTIME)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_PGT_ELAPSEDTIMELABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_PGT_ELAPSEDTIME)->ShowWindow(SW_HIDE);
		SetDlgItemText(IDC_PGT_BASEPRIORITY, FormatULong(pTabDlg->m_ProcessEntry.pcPriClassBase));
		SetDlgItemText(IDC_PGT_NUMTHREADS, FormatULong(pTabDlg->m_ProcessEntry.cntThreads));
	}
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CProcessMemoryPropTab

CProcessMemoryPropTab::~CProcessMemoryPropTab()
{
}

INT CProcessMemoryPropTab::m_aControlIDs[] =
{
	IDC_PMT_VIRTUAL,
	IDC_PMT_PEAKVIRTUAL,
	IDC_PMT_WORKINGSET,
	IDC_PMT_PEAKWORKINGSET,
	IDC_PMT_PAGEDPOOL,
	IDC_PMT_NONPAGEDPOOL,
	IDC_PMT_PRIVATEBYTES,
	IDC_PMT_FREEBYTES,
	IDC_PMT_RESERVEDBYTES,
	IDC_PMT_FREEIMAGEBYTES,
	IDC_PMT_RESERVEDIMAGEBYTES,
	0
};

BEGIN_MESSAGE_MAP(CProcessMemoryPropTab, CPropertyTab)
	//{{AFX_MSG_MAP(CProcessMemoryPropTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProcessMemoryPropTab message handlers

void CProcessMemoryPropTab::UpdateFields()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	if (!theApp.IsChicago())
	{
		// Win32
		SetDlgItemText(IDC_PMT_VIRTUAL, FormatKb(pTabDlg->m_ProcessInfo.dwVirtBytes));
		SetDlgItemText(IDC_PMT_PEAKVIRTUAL, FormatKb(pTabDlg->m_ProcessInfo.dwVirtBytesPeak));
		SetDlgItemText(IDC_PMT_WORKINGSET, FormatKb(pTabDlg->m_ProcessInfo.dwWorkingSet));
		SetDlgItemText(IDC_PMT_PEAKWORKINGSET, FormatKb(pTabDlg->m_ProcessInfo.dwWorkingSetPeak));
		SetDlgItemText(IDC_PMT_PAGEDPOOL, FormatKb(pTabDlg->m_ProcessInfo.dwPoolPagedBytes));
		SetDlgItemText(IDC_PMT_NONPAGEDPOOL, FormatKb(pTabDlg->m_ProcessInfo.dwPoolNonPagedBytes));
		SetDlgItemText(IDC_PMT_PRIVATEBYTES, FormatKb(pTabDlg->m_ProcessInfo.dwPrivateBytes));
		SetDlgItemText(IDC_PMT_FREEBYTES, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwBytesFree));
		SetDlgItemText(IDC_PMT_RESERVEDBYTES, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwBytesReserved));
		SetDlgItemText(IDC_PMT_FREEIMAGEBYTES, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwBytesImgFree));
		SetDlgItemText(IDC_PMT_RESERVEDIMAGEBYTES, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwBytesImgReserved));
	}
	else
	{
		// Chicago
		SetDlgItemText(IDC_PMT_VIRTUAL, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PMT_PEAKVIRTUAL, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PMT_WORKINGSET, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PMT_PEAKWORKINGSET, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PMT_PAGEDPOOL, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PMT_NONPAGEDPOOL, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PMT_PRIVATEBYTES, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PMT_FREEBYTES, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PMT_RESERVEDBYTES, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PMT_FREEIMAGEBYTES, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PMT_RESERVEDIMAGEBYTES, ids(IDS_UNAVAILABLE));
	}
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CProcessPageFilePropTab

CProcessPageFilePropTab::~CProcessPageFilePropTab()
{
}

INT CProcessPageFilePropTab::m_aControlIDs[] =
{
	IDC_PPT_PAGEFILE,
	IDC_PPT_PEAKPAGEFILE,
	IDC_PPT_PAGEFAULTS,
	0
};

BEGIN_MESSAGE_MAP(CProcessPageFilePropTab, CPropertyTab)
	//{{AFX_MSG_MAP(CProcessPageFilePropTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProcessPageFilePropTab message handlers

void CProcessPageFilePropTab::UpdateFields()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	if (!theApp.IsChicago())
	{
		// Win32
		SetDlgItemText(IDC_PPT_PAGEFILE, FormatKb(pTabDlg->m_ProcessInfo.dwPageFilesBytes));
		SetDlgItemText(IDC_PPT_PEAKPAGEFILE, FormatKb(pTabDlg->m_ProcessInfo.dwPageFilesBytesPeak));
		SetDlgItemText(IDC_PPT_PAGEFAULTS, FormatULong(pTabDlg->m_ProcessInfo.dwPageFltsPerSec));
	}
	else
	{
		// Chicago
		SetDlgItemText(IDC_PPT_PAGEFILE, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PPT_PEAKPAGEFILE, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PPT_PAGEFAULTS, ids(IDS_UNAVAILABLE));
	}
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CProcessFileIOPropTab

CProcessFileIOPropTab::~CProcessFileIOPropTab()
{
}

INT CProcessFileIOPropTab::m_aControlIDs[] =
{
	IDC_PFT_CONTROLBYTES,
	IDC_PFT_CONTROLOPS,
	IDC_PFT_READBYTES,
	IDC_PFT_READOPS,
	IDC_PFT_WRITEBYTES,
	IDC_PFT_WRITEOPS,
	0
};

BEGIN_MESSAGE_MAP(CProcessFileIOPropTab, CPropertyTab)
	//{{AFX_MSG_MAP(CProcessFileIOPropTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProcessFileIOPropTab message handlers

void CProcessFileIOPropTab::UpdateFields()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	if (!theApp.IsChicago())
	{
		// Win32
		SetDlgItemText(IDC_PFT_CONTROLBYTES, FormatKb(pTabDlg->m_ProcessInfo.liFileCtrlBytesPerSec));
		SetDlgItemText(IDC_PFT_CONTROLOPS, FormatULong(pTabDlg->m_ProcessInfo.dwFileCtrlOpsPerSec));
		SetDlgItemText(IDC_PFT_READBYTES, FormatKb(pTabDlg->m_ProcessInfo.liFileReadBytesPerSec));
		SetDlgItemText(IDC_PFT_READOPS, FormatULong(pTabDlg->m_ProcessInfo.dwFileReadOpsPerSec));
		SetDlgItemText(IDC_PFT_WRITEBYTES, FormatKb(pTabDlg->m_ProcessInfo.liFileWriteBytesPerSec));
		SetDlgItemText(IDC_PFT_WRITEOPS, FormatULong(pTabDlg->m_ProcessInfo.dwFileWriteOpsPerSec));
	}
	else
	{
		// Chicago
		SetDlgItemText(IDC_PFT_CONTROLBYTES, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PFT_CONTROLOPS, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PFT_READBYTES, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PFT_READOPS, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PFT_WRITEBYTES, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PFT_WRITEOPS, ids(IDS_UNAVAILABLE));
	}
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CProcessSpacePropTab

CProcessSpacePropTab::~CProcessSpacePropTab()
{
}

INT CProcessSpacePropTab::m_aControlIDs[] =
{
	IDC_PST_SELECTSPACETYPE,
	IDC_PST_BYTES_EXEC,
	IDC_PST_BYTES_EXECRO,
	IDC_PST_BYTES_EXECRW,
	IDC_PST_BYTES_EXECWC,
	IDC_PST_BYTES_NA,
	IDC_PST_BYTES_RO,
	IDC_PST_BYTES_RW,
	IDC_PST_BYTES_WC,
	0
};

BEGIN_MESSAGE_MAP(CProcessSpacePropTab, CPropertyTab)
	//{{AFX_MSG_MAP(CProcessSpacePropTab)
	ON_CBN_SELCHANGE(IDC_PST_SELECTSPACETYPE, OnSpaceTypeChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProcessSpacePropTab message handlers

void CProcessSpacePropTab::UpdateFields()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	CComboBox *pCombo = (CComboBox *)GetDlgItem(IDC_PST_SELECTSPACETYPE);

	pCombo->ResetContent();
	pCombo->AddString(ids(IDS_IMAGE));
	pCombo->AddString(ids(IDS_MAPPED));
	pCombo->AddString(ids(IDS_RESERVED));
	pCombo->AddString(ids(IDS_UNASSIGNED));

	pCombo->SetCurSel(0);

	if (!theApp.IsChicago())
	{
		// Win32
		SetDlgItemText(IDC_PST_BYTES_EXEC,   FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpE));
		SetDlgItemText(IDC_PST_BYTES_EXECRO, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpER));
		SetDlgItemText(IDC_PST_BYTES_EXECRW, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpERW));
		SetDlgItemText(IDC_PST_BYTES_EXECWC, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpEWC));
		SetDlgItemText(IDC_PST_BYTES_NA,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpNA));
		SetDlgItemText(IDC_PST_BYTES_RO,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpR));
		SetDlgItemText(IDC_PST_BYTES_RW,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpRW));
		SetDlgItemText(IDC_PST_BYTES_WC,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpWC));
	}
	else
	{
		// Chicago
		SetDlgItemText(IDC_PST_BYTES_EXEC,   ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_EXECRO, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_EXECRW, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_EXECWC, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_NA,     ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_RO,     ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_RW,     ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_WC,     ids(IDS_UNAVAILABLE));
	}
}

void CProcessSpacePropTab::OnSpaceTypeChange()
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	CComboBox *pCombo = (CComboBox *)GetDlgItem(IDC_PST_SELECTSPACETYPE);

	int iSel = pCombo->GetCurSel();

	if (!theApp.IsChicago())
	{
		// Win32
		switch (iSel)
		{
			case (IDS_IMAGE - IDS_IMAGE):
				SetDlgItemText(IDC_PST_BYTES_EXEC,   FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpE));
				SetDlgItemText(IDC_PST_BYTES_EXECRO, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpER));
				SetDlgItemText(IDC_PST_BYTES_EXECRW, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpERW));
				SetDlgItemText(IDC_PST_BYTES_EXECWC, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpEWC));
				SetDlgItemText(IDC_PST_BYTES_NA,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpNA));
				SetDlgItemText(IDC_PST_BYTES_RO,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpR));
				SetDlgItemText(IDC_PST_BYTES_RW,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpRW));
				SetDlgItemText(IDC_PST_BYTES_WC,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwImgSpWC));
				break;

			case (IDS_MAPPED - IDS_IMAGE):
				SetDlgItemText(IDC_PST_BYTES_EXEC,   FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwMapSpE));
				SetDlgItemText(IDC_PST_BYTES_EXECRO, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwMapSpER));
				SetDlgItemText(IDC_PST_BYTES_EXECRW, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwMapSpERW));
				SetDlgItemText(IDC_PST_BYTES_EXECWC, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwMapSpEWC));
				SetDlgItemText(IDC_PST_BYTES_NA,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwMapSpNA));
				SetDlgItemText(IDC_PST_BYTES_RO,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwMapSpR));
				SetDlgItemText(IDC_PST_BYTES_RW,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwMapSpRW));
				SetDlgItemText(IDC_PST_BYTES_WC,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwMapSpWC));
				break;

			case (IDS_RESERVED - IDS_IMAGE):
				SetDlgItemText(IDC_PST_BYTES_EXEC,   FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwResSpE));
				SetDlgItemText(IDC_PST_BYTES_EXECRO, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwResSpER));
				SetDlgItemText(IDC_PST_BYTES_EXECRW, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwResSpERW));
				SetDlgItemText(IDC_PST_BYTES_EXECWC, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwResSpEWC));
				SetDlgItemText(IDC_PST_BYTES_NA,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwResSpNA));
				SetDlgItemText(IDC_PST_BYTES_RO,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwResSpR));
				SetDlgItemText(IDC_PST_BYTES_RW,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwResSpRW));
				SetDlgItemText(IDC_PST_BYTES_WC,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwResSpWC));
				break;

			case (IDS_UNASSIGNED - IDS_IMAGE):
				SetDlgItemText(IDC_PST_BYTES_EXEC,   FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwUnassSpE));
				SetDlgItemText(IDC_PST_BYTES_EXECRO, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwUnassSpER));
				SetDlgItemText(IDC_PST_BYTES_EXECRW, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwUnassSpERW));
				SetDlgItemText(IDC_PST_BYTES_EXECWC, FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwUnassSpEWC));
				SetDlgItemText(IDC_PST_BYTES_NA,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwUnassSpNA));
				SetDlgItemText(IDC_PST_BYTES_RO,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwUnassSpR));
				SetDlgItemText(IDC_PST_BYTES_RW,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwUnassSpRW));
				SetDlgItemText(IDC_PST_BYTES_WC,     FormatKb(pTabDlg->m_ProcessAddrSpcInfo.dwUnassSpWC));
				break;
		}
	}
	else
	{
		// Chicago
		SetDlgItemText(IDC_PST_BYTES_EXEC,   ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_EXECRO, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_EXECRW, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_EXECWC, ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_NA,     ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_RO,     ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_RW,     ids(IDS_UNAVAILABLE));
		SetDlgItemText(IDC_PST_BYTES_WC,     ids(IDS_UNAVAILABLE));
	}
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\prcnode.h ===
// prcnode.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CPrcTreeNode object

class CPrcTreeNode : public CSpyTreeNode
{
	DECLARE_DYNCREATE(CPrcTreeNode);

public:
	// Win32 version
	BOOL Create(CPROCDB *pProcessDatabase, int iPrcIndex, CMapPtrToPtr* pThdMap);
	// Chicago version
	BOOL Create(HANDLE hProcessList, DWORD dwProcessID, char *szExePath, CMapPtrToPtr* pThdMap);

// Attributes

// Operations
public:
	virtual void GetDescription(CString& str);
	virtual void ShowProperties();
	virtual int GetBitmapIndex()
	{
		return IDX_PRCBITMAP;
	}
	virtual DWORD GetObjectHandle()
	{
		return (DWORD)m_pid;
	}
	virtual int GetObjectType()
	{
		return OT_PROCESS;
	}
	virtual CString GetModule()
	{
		return m_strModule;
	}

// Implementation
protected:
	DWORD m_pid;
	CString m_strModule;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\prcptabs.h ===
// prcptabs.h : header file
//


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CProcessGeneralPropTab window

class CProcessGeneralPropTab : public CPropertyTab
{
// Construction
public:
	CProcessGeneralPropTab(UINT nIDTemplate, UINT nIDCaption)
		: CPropertyTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CProcessGeneralPropTab)
	enum { IDD = IDD_PROCESSGENERALTAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CProcessGeneralPropTab();
	virtual void UpdateFields();

protected:
	virtual PINT GetControlIDTable()
	{
		return m_aControlIDs;
	}

	CHotLinkCtrlPrc m_HotLinkParentProcessID;

	static INT m_aControlIDs[];

	// Generated message map functions
protected:
	//{{AFX_MSG(CProcessGeneralPropTab)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CProcessMemoryPropTab window

class CProcessMemoryPropTab : public CPropertyTab
{
// Construction
public:
	CProcessMemoryPropTab(UINT nIDTemplate, UINT nIDCaption)
		: CPropertyTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CProcessMemoryPropTab)
	enum { IDD = IDD_PROCESSMEMORYTAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CProcessMemoryPropTab();
	virtual void UpdateFields();

protected:
	virtual PINT GetControlIDTable()
	{
		return m_aControlIDs;
	}

	static INT m_aControlIDs[];

	// Generated message map functions
protected:
	//{{AFX_MSG(CProcessMemoryPropTab)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CProcessPageFilePropTab window

class CProcessPageFilePropTab : public CPropertyTab
{
// Construction
public:
	CProcessPageFilePropTab(UINT nIDTemplate, UINT nIDCaption)
		: CPropertyTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CProcessPageFilePropTab)
	enum { IDD = IDD_PROCESSPAGEFILETAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CProcessPageFilePropTab();
	virtual void UpdateFields();

protected:
	virtual PINT GetControlIDTable()
	{
		return m_aControlIDs;
	}

	static INT m_aControlIDs[];

	// Generated message map functions
protected:
	//{{AFX_MSG(CProcessPageFilePropTab)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CProcessFileIOPropTab window

class CProcessFileIOPropTab : public CPropertyTab
{
// Construction
public:
	CProcessFileIOPropTab(UINT nIDTemplate, UINT nIDCaption)
		: CPropertyTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CProcessFileIOPropTab)
	enum { IDD = IDD_PROCESSFILEIOTAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CProcessFileIOPropTab();
	virtual void UpdateFields();

protected:
	virtual PINT GetControlIDTable()
	{
		return m_aControlIDs;
	}

	static INT m_aControlIDs[];

	// Generated message map functions
protected:
	//{{AFX_MSG(CProcessFileIOPropTab)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CProcessSpacePropTab window

class CProcessSpacePropTab : public CPropertyTab
{
// Construction
public:
	CProcessSpacePropTab(UINT nIDTemplate, UINT nIDCaption)
		: CPropertyTab(nIDTemplate, nIDCaption) {}

// Dialog Data
	//{{AFX_DATA(CProcessSpacePropTab)
	enum { IDD = IDD_PROCESSSPACETAB };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CProcessSpacePropTab();
	virtual void UpdateFields();

protected:
	virtual PINT GetControlIDTable()
	{
		return m_aControlIDs;
	}

	static INT m_aControlIDs[];

	// Generated message map functions
protected:
	//{{AFX_MSG(CProcessSpacePropTab)
	afx_msg void OnSpaceTypeChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\prctreed.h ===
// prctreed.h : header file
//

#define SRCHFLAG_PROCESS_USEPROCESS	0x01
#define SRCHFLAG_PROCESS_USEMODULE	0x02

/////////////////////////////////////////////////////////////////////////////
// CPrcTreeDoc document

class CPrcTreeDoc : public CSpyTreeDoc
{
	DECLARE_DYNCREATE(CPrcTreeDoc);

protected:
	CPrcTreeDoc();		  // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Implementation
protected:
	// data variables use in searching
	WORD 	m_wSearchFlags;
	DWORD	m_dwProcess;
	CString	m_strModule;
	BOOL	m_fSearchUp;	// TRUE if searching up, FALSE if searching down (from dialog)

	virtual void InitializeData();
	virtual void SetSearchMenuText(CCmdUI *pCmdUI);
	virtual BOOL DoFind();
	virtual BOOL DoFindNext();
	virtual BOOL DoFindPrev();
	virtual BOOL HasValidFind();
	virtual BOOL FindFirstMatchingNode();
	virtual BOOL FindNextMatchingNode();
	virtual BOOL FindPreviousMatchingNode();
	virtual BOOL FindLastMatchingNode();
	virtual ~CPrcTreeDoc();

	// Generated message map functions
protected:
	//{{AFX_MSG(CPrcTreeDoc)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\prfdb.cpp ===
/*************************************************************
Module name: PrfDB.CPP
*************************************************************/

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////


PCPRFOBJTYPE CPRFDB::GetFirstObject(void) const
{
	return((PCPRFOBJTYPE)((PBYTE) m_pPrfDataBlk + m_pPrfDataBlk->HeaderLength));
}


//////////////////////////////////////////////////////////////


PCPRFOBJTYPE CPRFDB::GetNextObject(PCPRFOBJTYPE pPrfObjType) const
{
	return((PCPRFOBJTYPE)((PBYTE) pPrfObjType + pPrfObjType->TotalByteLength));
}


//////////////////////////////////////////////////////////////


int CPRFDB::GetNumObjects(void) const
{
	return(m_pPrfDataBlk->NumObjectTypes);
}


//////////////////////////////////////////////////////////////


PCPRFOBJTYPE CPRFDB::FindObjFromTitleIndex(DWORD dwTitleIndex) const
{
	PCPRFOBJTYPE pPrfObjType = GetFirstObject();
	int n = 0;

	while ((pPrfObjType != NULL) && (n < GetNumObjects())) {
		if (pPrfObjType->ObjectNameTitleIndex == dwTitleIndex)
			return(pPrfObjType);

		pPrfObjType = GetNextObject(pPrfObjType);
		n++;
	}
	return(pPrfObjType);
}


//////////////////////////////////////////////////////////////


PCPRFOBJTYPE CPRFDB::FindObjFromIndex(int nIndexObj) const
{
	PCPRFOBJTYPE pPrfObjType = NULL;
	int n = 0;

	if (nIndexObj < GetNumObjects())
	{
		pPrfObjType = GetFirstObject();
		for (; n < nIndexObj; n++)
			pPrfObjType = GetNextObject(pPrfObjType);
	}
	return(pPrfObjType);
}


//////////////////////////////////////////////////////////////


int CPRFDB::GetNumInstances(PCPRFOBJTYPE pPrfObjType) const 
{
	return(pPrfObjType->NumInstances);
}


//////////////////////////////////////////////////////////////


PCPRFINSTDEF CPRFDB::GetFirstInst(PCPRFOBJTYPE pPrfObjType) const
{
	return((PCPRFINSTDEF)((PBYTE) pPrfObjType + pPrfObjType->DefinitionLength));
}


//////////////////////////////////////////////////////////////


PCPRFINSTDEF CPRFDB::GetNextInst(PCPRFINSTDEF pPrfInstDef) const
{
	PCPRFCNTRBLK pPrfCntrBlk;
	pPrfCntrBlk = (PPERF_COUNTER_BLOCK) ((PBYTE) pPrfInstDef + pPrfInstDef->ByteLength);
	return((PCPRFINSTDEF)((PBYTE) pPrfCntrBlk + pPrfCntrBlk->ByteLength));
}


//////////////////////////////////////////////////////////////


PCPRFINSTDEF CPRFDB::FindInstFromIndex(PCPRFOBJTYPE pPrfObjType, int nIndexInst) const
{
	PCPRFINSTDEF pPrfInstDef = GetFirstInst(pPrfObjType);
	int nIndex = 0;

	if (nIndexInst < pPrfObjType->NumInstances)
	{
		while (nIndex++ < nIndexInst)
		{
			pPrfInstDef = GetNextInst(pPrfInstDef);
		}
	}
	return(pPrfInstDef);
}


//////////////////////////////////////////////////////////////


PCPRFINSTDEF CPRFDB::FindInstPrnt(PCPRFINSTDEF pPrfInstDef) const
{
	PCPRFOBJTYPE pPrfObjType;
	pPrfObjType = FindObjFromTitleIndex(pPrfInstDef->ParentObjectTitleIndex);
	if (pPrfObjType != NULL)
		pPrfInstDef = FindInstFromIndex(pPrfObjType, pPrfInstDef->ParentObjectInstance);
	else
		pPrfInstDef = NULL;
	return(pPrfInstDef);
}


//////////////////////////////////////////////////////////////


PCPRFINSTDEF CPRFDB::GetInst(PCPRFOBJTYPE pPrfObjType, int nIndexInst) const
{
	PCPRFINSTDEF pPrfInstDef = GetFirstInst(pPrfObjType);
	while (nIndexInst--) 
		pPrfInstDef = GetNextInst(pPrfInstDef);
	return(pPrfInstDef);
}


//////////////////////////////////////////////////////////////


LPCTSTR CPRFDB::GetInstName(PCPRFINSTDEF pPrfInstDef) const
{
	return((LPCTSTR)((PBYTE) pPrfInstDef + pPrfInstDef->NameOffset));
}


//////////////////////////////////////////////////////////////


PCPRFCNTRDEF CPRFDB::GetFirstCntr(PCPRFOBJTYPE pPrfObjType) const
{
	return((PCPRFCNTRDEF)((PBYTE) pPrfObjType + pPrfObjType->HeaderLength));
}


//////////////////////////////////////////////////////////////


PCPRFCNTRDEF CPRFDB::GetNextCntr(PCPRFCNTRDEF pPrfCntrDef) const
{
	return((PCPRFCNTRDEF)((PBYTE) pPrfCntrDef + pPrfCntrDef->ByteLength));
}


//////////////////////////////////////////////////////////////


int CPRFDB::GetNumCntrs(PCPRFOBJTYPE pPrfObjType) const
{
	return(pPrfObjType->NumCounters);
}


//////////////////////////////////////////////////////////////


PCPRFCNTRDEF CPRFDB::FindCntrFromTitleIndex(DWORD dwTitleIndex, PCPRFOBJTYPE pPrfObjType) const
{
	PCPRFCNTRDEF pPrfCntrDef = GetFirstCntr(pPrfObjType);
	int n = 0;

	while ((pPrfCntrDef != NULL) && (n < GetNumCntrs(pPrfObjType)))
	{
		if (pPrfCntrDef->CounterNameTitleIndex == dwTitleIndex)
			return(pPrfCntrDef);

		pPrfCntrDef = GetNextCntr(pPrfCntrDef);
		n++;
	}
	return(pPrfCntrDef);
}


//////////////////////////////////////////////////////////////


void * const CPRFDB::GetCntrData(PCPRFINSTDEF pPrfInstDef, PCPRFCNTRDEF pPrfCntrDef) const
{
	PCPRFCNTRBLK pPrfCntrBlk;

	pPrfCntrBlk = (PPERF_COUNTER_BLOCK)((PBYTE) pPrfInstDef + pPrfInstDef->ByteLength);
	return((PVOID)((PBYTE)pPrfCntrBlk + pPrfCntrDef->CounterOffset));
}


//////////////////////// End Of File /////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\prctreed.cpp ===
// prctreed.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "spytreed.h"
#include "prctreed.h"
#include "treectl.h"
#include "imgwell.h"
#include "spytreec.h"
#include "prcnode.h"
#include "thdnode.h"
#include "findtool.h"
#include "spytreev.h"
#include "srchdlgs.h"
#include "mainfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPrcTreeDoc

IMPLEMENT_DYNCREATE(CPrcTreeDoc, CSpyTreeDoc);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CPrcTreeDoc::CPrcTreeDoc()
{
	m_dwProcess = (DWORD)-1;
	m_strModule.Empty();
	m_fSearchUp = FALSE;
}



CPrcTreeDoc::~CPrcTreeDoc()
{
}



void CPrcTreeDoc::InitializeData()
{
	CMapPtrToPtr ThdMap;

	if (!theApp.IsChicago())
	{
		// Win32
//		enum CPROCDB::PROCDBERR error;
		WORD wQueryType = (PROCDBQ_PROCESS | PROCDBQ_THREAD);
		CPROCDB ProcessDatabase(wQueryType/*, &error*/);
		int iCount = 0, iLoop = ProcessDatabase.GetNumProcesses();

		for (; iCount < iLoop; iCount++)
		{
			CPrcTreeNode* pPrcTreeNode = new CPrcTreeNode;
			pPrcTreeNode->Create(&ProcessDatabase, iCount, &ThdMap);
			m_TopLevelNodeList.AddTail(pPrcTreeNode);
		}
	}
	else
	{
		// Chicago
		HANDLE hProcessList;
		PROCESSENTRY32 pe32;

		pe32.dwSize = sizeof(PROCESSENTRY32);

		if ((hProcessList = (*theApp.pfnCreateToolhelp32Snapshot)(TH32CS_SNAPPROCESS, 0)) != NULL)
		{
			if ((*theApp.pfnProcess32First)(hProcessList, &pe32))
			{
				CPrcTreeNode* pPrcTreeNode = new CPrcTreeNode;
				if (pe32.dwSize >= sizeof(PROCESSENTRY32))
					pPrcTreeNode->Create(hProcessList, pe32.th32ProcessID, pe32.szExeFile, &ThdMap);
				else
					pPrcTreeNode->Create(hProcessList, pe32.th32ProcessID, "", &ThdMap);
				m_TopLevelNodeList.AddTail(pPrcTreeNode);

				while ((*theApp.pfnProcess32Next)(hProcessList, &pe32))
				{
					CPrcTreeNode* pPrcTreeNode = new CPrcTreeNode;
					if (pe32.dwSize >= sizeof(PROCESSENTRY32))
						pPrcTreeNode->Create(hProcessList, pe32.th32ProcessID, pe32.szExeFile, &ThdMap);
					else
						pPrcTreeNode->Create(hProcessList, pe32.th32ProcessID, "", &ThdMap);
					m_TopLevelNodeList.AddTail(pPrcTreeNode);
				}
			}

			CloseHandle(hProcessList);
		}
	}

	CThdTreeNode::AddChildren(&ThdMap);
}

void CPrcTreeDoc::SetSearchMenuText(CCmdUI *pCmdUI)
{
	pCmdUI->SetText(ids(IDS_MENU_FINDPROCESS));
}

BOOL CPrcTreeDoc::DoFind()
{
#ifdef USE_TABBED_SEARCH_DIALOGS
	CSearchTabbedDialog dlgTest(IDS_SEARCHCAPTION, NULL, (UINT)-1);

	dlgTest.AddTab(new CSearchProcessDlgTab(IDD_SEARCHPROCESSTAB, IDS_SEARCHPROCESSTAB));
	dlgTest.AddTab(new CSearchThreadDlgTab(IDD_SEARCHTHREADTAB, IDS_SEARCHTHREADTAB));
	dlgTest.AddTab(new CSearchWindowDlgTab(IDD_SEARCHWINDOWTAB, IDS_SEARCHWINDOWTAB));

	dlgTest.DoModal();
#else	// USE_TABBED_SEARCH_DIALOGS
	CSearchProcessDlg dlg;
	CSpyTreeView *pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());
	CPrcTreeNode *pcptn = (CPrcTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(pcstvActive->m_SpyTreeCtl.GetCurSel())->m_dwData;

	m_dwProcess = pcptn->GetObjectHandle();
	m_strModule = pcptn->GetModule();

	dlg.SetSelectedProcess(m_dwProcess);
	dlg.SetModule(m_strModule);
	dlg.SetDirection(m_fSearchUp);

	if (dlg.DoModal() == TRUE)
	{
		m_wSearchFlags	= dlg.GetSearchFlags();
		m_dwProcess		= dlg.GetSelectedProcess();
		m_strModule		= dlg.GetModule();
		m_fSearchUp		= dlg.GetDirection();

		if (m_fSearchUp)
		{
			if (!FindPreviousMatchingNode() && !FindLastMatchingNode())
			{
				// notify user that no matching node found
				SpyMessageBox(IDS_NO_MATCHING_PRC);
			}
		}
		else
		{
			if (!FindNextMatchingNode() && !FindFirstMatchingNode())
			{
				// notify user that no matching node found
				SpyMessageBox(IDS_NO_MATCHING_PRC);
			}
		}
	}
#endif	// USE_TABBED_SEARCH_DIALOGS

	return(TRUE);
}

BOOL CPrcTreeDoc::DoFindNext()
{
	if (!FindNextMatchingNode() && !FindFirstMatchingNode())
	{
		// notify user that no next matching node found
		SpyMessageBox(IDS_NO_NEXT_MATCH_PRC);
	}

	return(TRUE);
}

BOOL CPrcTreeDoc::DoFindPrev()
{
	if (!FindPreviousMatchingNode() && !FindLastMatchingNode())
	{
		// notify user that no previous matching node found
		SpyMessageBox(IDS_NO_PREV_MATCH_PRC);
	}

	return(TRUE);
}

BOOL CPrcTreeDoc::HasValidFind()
{
	if (m_wSearchFlags & SRCHFLAG_PROCESS_USEPROCESS)
		return(FALSE);
	else if (m_wSearchFlags & SRCHFLAG_PROCESS_USEMODULE)
		return(!m_strModule.IsEmpty());
	else
		return(FALSE);
}

BOOL CPrcTreeDoc::FindFirstMatchingNode()
{
	CSpyTreeView *pcstvActive;
	
	pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	CPrcTreeNode *pcptn;

	for (int i = 0; i < pcstvActive->m_SpyTreeCtl.GetListBox()->GetCount(); i++)
	{
		pcptn = (CPrcTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(i)->m_dwData;

		if (!(pcptn->IsKindOf(RUNTIME_CLASS(CPrcTreeNode))))
			continue;

		// do comparison of node contents with search criteria
		switch (m_wSearchFlags)
		{
			case SRCHFLAG_PROCESS_USEPROCESS:

				if (pcptn->GetObjectHandle() == m_dwProcess)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;

			case SRCHFLAG_PROCESS_USEMODULE:

				if (pcptn->GetModule() == m_strModule)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;
		}
	}

	return(FALSE);
}

BOOL CPrcTreeDoc::FindNextMatchingNode()
{
	CSpyTreeView *pcstvActive;
	
	pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	CPrcTreeNode *pcptn;

	for (int i = pcstvActive->m_SpyTreeCtl.GetCurSel() + 1; i < pcstvActive->m_SpyTreeCtl.GetListBox()->GetCount(); i++)
	{
		pcptn = (CPrcTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(i)->m_dwData;

		if (!(pcptn->IsKindOf(RUNTIME_CLASS(CPrcTreeNode))))
			continue;

		// do comparison of node contents with search criteria
		switch (m_wSearchFlags)
		{
			case SRCHFLAG_PROCESS_USEPROCESS:

				if (pcptn->GetObjectHandle() == m_dwProcess)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;

			case SRCHFLAG_PROCESS_USEMODULE:

				if (pcptn->GetModule() == m_strModule)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;
		}
	}

	return(FALSE);
}

BOOL CPrcTreeDoc::FindPreviousMatchingNode()
{
	CSpyTreeView *pcstvActive;
	
	pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	CPrcTreeNode *pcptn;

	for (int i = pcstvActive->m_SpyTreeCtl.GetCurSel() - 1; i >= 0; i--)
	{
		pcptn = (CPrcTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(i)->m_dwData;

		if (!(pcptn->IsKindOf(RUNTIME_CLASS(CPrcTreeNode))))
			continue;

		// do comparison of node contents with search criteria
		switch (m_wSearchFlags)
		{
			case SRCHFLAG_PROCESS_USEPROCESS:

				if (pcptn->GetObjectHandle() == m_dwProcess)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;

			case SRCHFLAG_PROCESS_USEMODULE:

				if (pcptn->GetModule() == m_strModule)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;
		}
	}

	return(FALSE);
}

BOOL CPrcTreeDoc::FindLastMatchingNode()
{
	CSpyTreeView *pcstvActive;
	
	pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());

	CPrcTreeNode *pcptn;

	for (int i = pcstvActive->m_SpyTreeCtl.GetListBox()->GetCount() - 1; i >= 0; i--)
	{
		pcptn = (CPrcTreeNode *)pcstvActive->m_SpyTreeCtl.GetNode(i)->m_dwData;

		if (!(pcptn->IsKindOf(RUNTIME_CLASS(CPrcTreeNode))))
			continue;

		// do comparison of node contents with search criteria
		switch (m_wSearchFlags)
		{
			case SRCHFLAG_PROCESS_USEPROCESS:

				if (pcptn->GetObjectHandle() == m_dwProcess)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;

			case SRCHFLAG_PROCESS_USEMODULE:

				if (pcptn->GetModule() == m_strModule)
				{
					pcstvActive->m_SpyTreeCtl.SetCurSel(i);
					return(TRUE);
				}
				break;
		}
	}

	return(FALSE);
}

BEGIN_MESSAGE_MAP(CPrcTreeDoc, CSpyTreeDoc)
	//{{AFX_MSG_MAP(CPrcTreeDoc)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\prftilib.h ===
/************************************************************
Module name: PrfTILib.H
************************************************************/

#define PTI_PROCESS_OBJECT						230
#define PTI_PROCESS_PROCESSID					784
#define PTI_PROCESS_PROCESSOR_TIME				6
#define PTI_PROCESS_PRIVILEGED_TIME				144
#define PTI_PROCESS_USER_TIME					142
#define PTI_PROCESS_ELAPSED_TIME				684
#define PTI_PROCESS_WORKING_SET					180
#define PTI_PROCESS_WORKING_SET_PEAK			178
#define PTI_PROCESS_VIRTUAL_BYTES				174
#define PTI_PROCESS_VIRTUAL_BYTES_PEAK			172
#define PTI_PROCESS_POOL_PAGED_BYTES			56
#define PTI_PROCESS_POOL_NONPAGED_BYTES			58
#define PTI_PROCESS_PAGEFILE_BYTES				184
#define PTI_PROCESS_PAGEFILE_BYTES_PEAK			182
#define PTI_PROCESS_PRIORITY_BASE				682
#define PTI_PROCESS_PRIVATE_BYTES				186
#define PTI_PROCESS_FAULT_COUNT					28
#define PTI_PROCESS_THREAD_COUNT				680
#define PTI_PROCESS_FILE_CONTROL_BYTES			20
#define PTI_PROCESS_FILE_CONTROL_OPERATIONS		14
#define PTI_PROCESS_FILE_READ_BYTES				16
#define PTI_PROCESS_FILE_READ_OPERATIONS		10
#define PTI_PROCESS_FILE_WRITE_BYTES			18
#define PTI_PROCESS_FILE_WRITE_OPERATIONS		12

#define PTI_THREAD_OBJECT						232
#define PTI_THREAD_THREADID						804
#define PTI_THREAD_PROCESSID					784
#define PTI_THREAD_PROCESSOR_TIME				6
#define PTI_THREAD_PRIVILEGED_TIME				144
#define PTI_THREAD_USER_TIME					142
#define PTI_THREAD_ELAPSED_TIME					684
#define PTI_THREAD_START_ADDRESS				706
#define PTI_THREAD_CURRENT_PRIORITY				694
#define PTI_THREAD_BASE_PRIORITY				682
#define PTI_THREAD_CONTEXT_SWITCHES				146
#define PTI_THREAD_STATE						46
#define PTI_THREAD_WAIT_REASON					336

#define PTI_THREAD_DETAILS_OBJECT				816
#define PTI_THREAD_USER_PC						708

#define PTI_IMAGE_OBJECT						740
#define PTI_IMAGE_NOACCESS						788
#define PTI_IMAGE_READONLY						790
#define PTI_IMAGE_READWRITE						792
#define PTI_IMAGE_WRITECOPY						794
#define PTI_IMAGE_EXECUTABLE					796
#define PTI_IMAGE_EXE_READONLY					798
#define PTI_IMAGE_EXE_READWRITE					800
#define PTI_IMAGE_EXE_WRITECOPY					802

#define PTI_PROCESS_ADDRESS_SPACE_OBJECT		786
#define PTI_PROCADDR_PROCESSID					784
#define PTI_PROCADDR_BYTES_FREE					782
#define PTI_PROCADDR_BYTES_RESERVED				780
#define PTI_PROCADDR_BYTES_IMAGE_FREE			778	
#define PTI_PROCADDR_BYTES_IMAGE_RESERVED		776
#define PTI_PROCADDR_IMAGE_NOACCESS				760
#define PTI_PROCADDR_IMAGE_READONLY				762
#define PTI_PROCADDR_IMAGE_READWRITE			764
#define PTI_PROCADDR_IMAGE_WRITECOPY			766
#define PTI_PROCADDR_IMAGE_EXECUTABLE			768
#define PTI_PROCADDR_IMAGE_EXECREADONLY			770
#define PTI_PROCADDR_IMAGE_EXECREADWRITE		772
#define PTI_PROCADDR_IMAGE_EXECWRITECOPY		774
#define PTI_PROCADDR_MAPPED_NOACCESS			710
#define PTI_PROCADDR_MAPPED_READONLY			712
#define PTI_PROCADDR_MAPPED_READWRITE			714
#define PTI_PROCADDR_MAPPED_WRITECOPY			716
#define PTI_PROCADDR_MAPPED_EXECUTABLE			718
#define PTI_PROCADDR_MAPPED_EXECREADONLY		720
#define PTI_PROCADDR_MAPPED_EXECREADWRITE		722
#define PTI_PROCADDR_MAPPED_EXECWRITECOPY		724
#define PTI_PROCADDR_RESERVED_NOACCESS			726
#define PTI_PROCADDR_RESERVED_READONLY			728
#define PTI_PROCADDR_RESERVED_READWRITE			730
#define PTI_PROCADDR_RESERVED_WRITECOPY			732
#define PTI_PROCADDR_RESERVED_EXECUTABLE		734
#define PTI_PROCADDR_RESERVED_EXECREADONLY		736
#define PTI_PROCADDR_RESERVED_EXECREADWRITE		738
#define PTI_PROCADDR_RESERVED_EXECWRITECOPY		742
#define PTI_PROCADDR_UNASSIGNED_NOACCESS		744
#define PTI_PROCADDR_UNASSIGNED_READONLY		746
#define PTI_PROCADDR_UNASSIGNED_READWRITE		748
#define PTI_PROCADDR_UNASSIGNED_WRITECOPY		750
#define PTI_PROCADDR_UNASSIGNED_EXECUTABLE		752
#define PTI_PROCADDR_UNASSIGNED_EXECREADONLY	754
#define PTI_PROCADDR_UNASSIGNED_EXECREADWRITE	756
#define PTI_PROCADDR_UNASSIGNED_EXECWRITECOPY	758

//////////////////////// End Of File ////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\prftxtdb.h ===
/*************************************************************
Module name: PrfTxtDB.H
*************************************************************/

// Performance Counter Title and Help Text Database.
class CPRFTXTDB
{
	private:
	static LPWSTR	sm_mszCounterText;
	static LPWSTR	sm_mszHelpText;
	static int		sm_nLastCounter, sm_nLastHelp;
	static long		sm_nInstancesOfClass;
	static HANDLE	sm_hEventDataLoaded;

//////////////////////////////////////////////////////////////

	int NumStrings (LPCTSTR mszStrings) const;
	LPCWSTR GetStringNum (LPCTSTR mszStrings, int n) const;

//////////////////////////////////////////////////////////////
	public:

	~CPRFTXTDB(void);
	CPRFTXTDB(int nPreferredLanguageID = LANG_ENGLISH);

	int GetNumOfCounters(void) const;
	int CounterNumFromIndex(int nIndex) const;
	int CounterIndexFromNum(int nNum) const;
	LPCWSTR CounterTextFromIndex(int nIndex) const;
	LPCWSTR CounterTextFromNum(int nNum) const;

	int GetNumOfHelpTexts(void) const;
	int HelpNumFromIndex(int nIndex) const;
	int HelpIndexFromNum(int nNum) const;
	LPCWSTR HelpTextFromIndex(int nIndex) const;
	LPCWSTR HelpTextFromNum(int nNum) const;
};

//////////////////////// End Of File /////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\prfdb.h ===
/*************************************************************
Module name: PrfDB.H
*************************************************************/

#ifndef _PRFDB_H_
#define _PRFDB_H_

typedef const PERF_DATA_BLOCK * PCPRFDATABLK;
typedef const PERF_OBJECT_TYPE * PCPRFOBJTYPE;
typedef const PERF_INSTANCE_DEFINITION * PCPRFINSTDEF;
typedef const PERF_COUNTER_DEFINITION * PCPRFCNTRDEF;
typedef const PERF_COUNTER_BLOCK * PCPRFCNTRBLK;
	
class CPRFDB
{
	PCPRFDATABLK m_pPrfDataBlk;

	public:
	CPRFDB (PCPRFDATABLK pPrfDataBlk)
	{
		m_pPrfDataBlk = pPrfDataBlk;
	}
	~CPRFDB (void) {}

	private:
	PCPRFOBJTYPE GetFirstObject(void) const;
	PCPRFOBJTYPE GetNextObject(PCPRFOBJTYPE pPrfObjType) const;
	int GetNumObjects(void) const;

	public:
	PCPRFOBJTYPE FindObjFromTitleIndex(DWORD dwTitleIndex) const;
	PCPRFOBJTYPE FindObjFromIndex(int nIndexObj) const;

	PCPRFINSTDEF FindInstFromIndex(PCPRFOBJTYPE pPrfObjType, int nIndexInst) const;
	int GetNumInstances(PCPRFOBJTYPE pPrfObjType) const;
	PCPRFINSTDEF GetFirstInst(PCPRFOBJTYPE pPrfObjType) const;
	PCPRFINSTDEF GetNextInst(PCPRFINSTDEF pPrfInstDef) const;
	PCPRFINSTDEF GetInst(PCPRFOBJTYPE pPrfObjType, int nIndexInst) const;
	LPCTSTR GetInstName(PCPRFINSTDEF pPrfInstDef) const;
	LPCWSTR GetInstName(PCPRFOBJTYPE pPrfObjType, int nIndexInst) const;
	PCPRFINSTDEF FindInstPrnt(PCPRFINSTDEF pPrfInstDef) const;

	int GetNumCntrs(PCPRFOBJTYPE pPrfObjType) const;
	PCPRFCNTRDEF GetFirstCntr(PCPRFOBJTYPE pPrfObjType) const;
	PCPRFCNTRDEF GetNextCntr(PCPRFCNTRDEF pPrfCntrDef) const;
	PCPRFCNTRDEF GetCntrFromTitleIndex(DWORD dwTitleIndex, PCPRFOBJTYPE pPrfObjType) const;
	void * const GetCntrData(PCPRFINSTDEF pPrfInstDef, PCPRFCNTRDEF pPrfCntrDef) const;
	PCPRFCNTRDEF FindCntrFromTitleIndex(DWORD dwTitleIndex, PCPRFOBJTYPE pPrfObjType) const;
};

#endif	// _PRFDB_H_

//////////////////////// End Of File /////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\prftxtdb.cpp ===
/*************************************************************
Module name: PrfTxtDB.CPP
*************************************************************/

#include "stdafx.h"
#pragma hdrstop

#include "prftxtdb.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////


long	CPRFTXTDB::sm_nInstancesOfClass = -1;
HANDLE	CPRFTXTDB::sm_hEventDataLoaded;
LPWSTR	CPRFTXTDB::sm_mszCounterText;
LPWSTR	CPRFTXTDB::sm_mszHelpText;
int		CPRFTXTDB::sm_nLastCounter;
int		CPRFTXTDB::sm_nLastHelp;


//////////////////////////////////////////////////////////////


CPRFTXTDB::CPRFTXTDB(int nPreferredLanguageID)
{
	HKEY hkey;
	DWORD dwType, cbData;


	InterlockedIncrement(&sm_nInstancesOfClass);
	sm_hEventDataLoaded = CreateEvent(NULL, TRUE, FALSE, __TEXT("CPRFCNTTXTDB"));

	if (GetLastError() != ERROR_ALREADY_EXISTS)
	{
		// The title and help text has never been read 
		// from the registry; let's do it now.
		LPCTSTR szPerflib = __TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
		LONG lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPerflib, 0, KEY_QUERY_VALUE, &hkey);
		// JMR: Do error checking here.

		// The data was found OK; initialize the static 
		// data members.
		cbData = sizeof(sm_nLastCounter);
		RegQueryValueEx(hkey, __TEXT("Last Counter"), NULL, &dwType, (LPBYTE) &sm_nLastCounter, &cbData);

		cbData = sizeof(sm_nLastHelp);
		RegQueryValueEx(hkey, __TEXT("Last Help"), NULL, &dwType, (LPBYTE) &sm_nLastHelp, &cbData);

		RegCloseKey(hkey);


		TCHAR szBuf[100];
		_stprintf(szBuf, __TEXT("%s\\%03d"), szPerflib, nPreferredLanguageID);
		lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, 0, KEY_QUERY_VALUE, &hkey);
		if ((lRes != ERROR_SUCCESS) && (nPreferredLanguageID != LOCALE_IDEFAULTLANGUAGE))
		{
			// Couldn't find the help data for the preferred 
			// language; let's try getting the data for the 
			// default language.
			_stprintf(szBuf, __TEXT("%s\\%03d"), szPerflib, LOCALE_IDEFAULTLANGUAGE);
			lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, 0, KEY_QUERY_VALUE, &hkey);
		}

		if (lRes != ERROR_SUCCESS)
		{
			// The data couldn't be found regardless of the 
			// language used to retrieve.
		}
		else
		{
			// Get the size of the buffer needed for the Counter title text.
			RegQueryValueEx(hkey, __TEXT("Counters"), NULL, &dwType, NULL, &cbData);
			HANDLE hHeap = GetProcessHeap();
			sm_mszCounterText = (LPWSTR) HeapAlloc(hHeap, 0, cbData);
			// JMR: Check for NULL
			RegQueryValueEx(hkey, __TEXT("Counters"), NULL, &dwType, (LPBYTE) sm_mszCounterText, &cbData);

			// Get the size of the buffer needed for the Help title text.
			RegQueryValueEx(hkey, __TEXT("Help"), NULL, &dwType, NULL, &cbData);
			sm_mszHelpText = (LPWSTR) HeapAlloc(hHeap, 0, cbData);
			// JMR: Check for NULL
			RegQueryValueEx(hkey, __TEXT("Help"), NULL, &dwType, (LPBYTE) sm_mszCounterText, &cbData);


			RegCloseKey(hkey);

			// Signal to this thread and other threads that 
			// the data is ready.
			SetEvent(sm_hEventDataLoaded);
		}
	}
	WaitForSingleObject(sm_hEventDataLoaded, INFINITE);
}


//////////////////////////////////////////////////////////////


CPRFTXTDB::~CPRFTXTDB(void)
{
	HANDLE hHeap = GetProcessHeap();
	HeapFree(hHeap, 0, sm_mszHelpText);
	HeapFree(hHeap, 0, sm_mszCounterText);
	CloseHandle(sm_hEventDataLoaded);
	if (InterlockedDecrement(&sm_nInstancesOfClass) < 0)
		sm_hEventDataLoaded = NULL;
}


//////////////////////////////////////////////////////////////


int CPRFTXTDB::NumStrings(LPCTSTR mszStrings) const 
{
	for (int n = 0; mszStrings[0] != 0; n++)
		mszStrings = _tcschr(mszStrings, 0) + 1;
	return(n);
}


//////////////////////////////////////////////////////////////


LPCWSTR CPRFTXTDB::GetStringNum(LPCTSTR mszStrings, int n) const
{
	// JMR: Check for end of strings here
	for (; n > 0; n--) 
		mszStrings = _tcschr(mszStrings, 0) + 1;
	return((LPCWSTR)mszStrings);
}


//////////////////////////////////////////////////////////////


int CPRFTXTDB::GetNumOfCounters(void) const
{
	return(NumStrings((LPCTSTR)sm_mszCounterText) / 2);
}


//////////////////////////////////////////////////////////////


int CPRFTXTDB::CounterNumFromIndex(int nIndex) const
{
	int n;
	_stscanf((LPCTSTR)GetStringNum((LPCTSTR)sm_mszCounterText, nIndex * 2), 
		(LPCTSTR)__TEXT("%d"), &n);
	return(n);
}


//////////////////////////////////////////////////////////////


LPCWSTR CPRFTXTDB::CounterTextFromIndex(int nIndex) const
{
	return(GetStringNum((LPCTSTR)sm_mszCounterText, nIndex * 2 + 1));
}


//////////////////////////////////////////////////////////////


LPCWSTR CPRFTXTDB::CounterTextFromNum(int nNum) const
{
	int nIndex = CounterIndexFromNum(nNum);
	// JMR: Error check for invalid nIndex;
	return(CounterTextFromIndex(nIndex));
}


//////////////////////////////////////////////////////////////


int CPRFTXTDB::CounterIndexFromNum(int nNum) const
{
	for (int nIndex = 0; nIndex < GetNumOfCounters(); nIndex++)
		if (nNum == CounterNumFromIndex(nIndex))
			return(nIndex);
	return(-1);
}


//////////////////////////////////////////////////////////////


int CPRFTXTDB::GetNumOfHelpTexts (void) const {
	return(NumStrings((LPCTSTR)sm_mszHelpText) / 2);
}


//////////////////////////////////////////////////////////////


int CPRFTXTDB::HelpNumFromIndex(int nIndex) const
{
	int n;
	_stscanf((LPCTSTR)__TEXT("%d"), (LPCTSTR)GetStringNum((LPCTSTR)sm_mszHelpText, nIndex * 2), &n);
	return(n);
}


//////////////////////////////////////////////////////////////


LPCWSTR CPRFTXTDB::HelpTextFromIndex(int nIndex) const
{
	return(GetStringNum((LPCTSTR)sm_mszHelpText, nIndex * 2 + 1));
}


//////////////////////////////////////////////////////////////


int CPRFTXTDB::HelpIndexFromNum(int nNum) const
{
	for (int nIndex = 0; nIndex < GetNumOfHelpTexts(); nIndex++)
		if (nNum == HelpNumFromIndex(nIndex))
			return(nIndex);
	return(-1);
}


//////////////////////////////////////////////////////////////


LPCWSTR CPRFTXTDB::HelpTextFromNum(int nNum) const
{
	int nIndex = HelpIndexFromNum(nNum);
	// JMR: Error check for invalid nIndex;
	return(HelpTextFromIndex(nIndex));
}


//////////////////////// End Of File /////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\procdb.cpp ===
/*************************************************************
Module name: ProcDB.CPP
*************************************************************/

#include "stdafx.h"
#pragma hdrstop

#include "prftilib.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////
TCHAR szKeyData[32] = "";

DWORD dwTIProcess = 230, dwTIThread = 232, dwTIProcAddrSpace = 786, dwTIImage = 740, dwTIThreadDet = 816;

/*
Process object instance names are process names, no parent
Thread object instance names are thread numbers, Parent is Process Object
Process Address Space Object instance names are Process Names, no parent
Image Object names are filenames of mapped images. Parent is Process Address Space Object
Thread Detail Object instances are thread numbers, Parent is Process Address Space Object
*/

#define SZ_DUMMY 10

int GetRegDataBound(HKEY hkey)
{
	TCHAR chDummy[SZ_DUMMY];
	DWORD cSubKeys;
	DWORD cbMaxSubkey;
	DWORD cbMaxClass;
	DWORD cValues;
	DWORD cbMaxValueName;

	DWORD cbMaxValueData;
	DWORD cbSecurityDescriptor;
	FILETIME ftLastWriteTime;

	DWORD lErr;
	DWORD cbClassSize = SZ_DUMMY;

	lErr = RegQueryInfoKey(hkey, chDummy, &cbClassSize, NULL, &cSubKeys, &cbMaxSubkey, &cbMaxClass,
		&cValues, &cbMaxValueName, &cbMaxValueData, &cbSecurityDescriptor, &ftLastWriteTime);

	if (lErr == ERROR_SUCCESS)
		return cbMaxValueData;
	else
		return -1;
}


BOOL GetRegDataString(WORD wQueryType)
{
	HKEY hKeyData;
	LONG lErr;
	LPTSTR lptstr;
	int   iSize;
	DWORD dwType;

	DWORD dwSize;
	int   iIndex;

	lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009"),
		0, KEY_ALL_ACCESS, &hKeyData);
	ASSERT(lErr == ERROR_SUCCESS);

	iSize = GetRegDataBound(hKeyData);

	if (iSize == -1)
	    return(FALSE);

	iSize++;
	lptstr = (LPTSTR)malloc(iSize * sizeof(TCHAR));
	dwSize = iSize;

	lErr = RegQueryValueEx(hKeyData, TEXT("Counters"), 0, &dwType, (LPBYTE) lptstr, &dwSize);
	ASSERT(lErr == ERROR_SUCCESS);

	char szIndex[8];
//	BOOL fGotProcess = FALSE, fGotThread = FALSE;
	BOOL fRetVal = FALSE, fGotProcess = FALSE, fGotThread = FALSE, fGotProcAS = FALSE, fGotThrdDet = FALSE;

	while (*lptstr)
	{
		_stscanf(lptstr, TEXT(" %d"), &iIndex);
		lptstr += lstrlen(lptstr) + 1;
		if ((wQueryType | PROCDBQ_PROCESS) && (!_tcsicmp(lptstr, "Process")))
		{
			if (_tcslen(szKeyData))
				_tcscat(szKeyData, " ");
			_tcscat(szKeyData, itoa(iIndex, szIndex, 10));
			fGotProcess = TRUE;
		}
		else if ((wQueryType | PROCDBQ_PROCESSAS) && (!_tcsicmp(lptstr, "Process Address Space")))
		{
			if (_tcslen(szKeyData))
				_tcscat(szKeyData, " ");
			_tcscat(szKeyData, itoa(iIndex, szIndex, 10));
			fGotProcAS = TRUE;
		}
		else if ((wQueryType | PROCDBQ_THREAD) && (!_tcsicmp(lptstr, "Thread")))
		{
			if (_tcslen(szKeyData))
				_tcscat(szKeyData, " ");
			_tcscat(szKeyData, itoa(iIndex, szIndex, 10));
			fGotThread = TRUE;
		}
		else if ((wQueryType | PROCDBQ_THREADDET) && (!_tcsicmp(lptstr, "Thread Details")))
		{
			if (_tcslen(szKeyData))
				_tcscat(szKeyData, " ");
			_tcscat(szKeyData, itoa(iIndex, szIndex, 10));
			fGotThrdDet = TRUE;
		}
		lptstr += lstrlen(lptstr) + 1;
	}

	lErr = RegCloseKey(hKeyData);
	ASSERT(lErr == ERROR_SUCCESS);

	if (wQueryType | PROCDBQ_PROCESS)
		fRetVal |= fGotProcess;
	if (wQueryType | PROCDBQ_PROCESSAS)
		fRetVal |= fGotProcAS;
	if (wQueryType | PROCDBQ_THREAD)
		fRetVal |= fGotThread;
	if (wQueryType | PROCDBQ_THREADDET)
		fRetVal |= fGotThrdDet;

	return(fRetVal);
}


void CPROCDB::GetPrfData(WORD wQueryType)
{
	// Objects: Process(230), Thread(232), Process Address Space(786), Image(740), Thread Details(816)
	static HANDLE hHeap;
	static DWORD cbData	= 32 * 1024;

	if (m_lpbPrfData == NULL)
	{
		hHeap = GetProcessHeap();
		m_lpbPrfData = (LPBYTE) HeapAlloc(hHeap, 0, cbData);
	}

	cbData = HeapSize(hHeap, 0, m_lpbPrfData);

	if (!_tcslen(szKeyData))
	{
		if (!GetRegDataString(wQueryType))
//			_tcscpy(szKeyData, "230 232");
			_tcscpy(szKeyData, "230 232 786 816");
	}

	while (TRUE)
	{
		DWORD dwType, dwLen = cbData;
		long lRes;

		lRes = RegQueryValueEx(HKEY_PERFORMANCE_DATA, szKeyData, NULL, &dwType, m_lpbPrfData, &dwLen);
		if (lRes != ERROR_MORE_DATA) 
			break;
		m_lpbPrfData = (LPBYTE) HeapReAlloc(hHeap, 0, m_lpbPrfData, cbData *= 2);
	}

	theApp.m_bDidPerfQueries = TRUE;

	// We have the performance data.
	m_pPrfDB = new CPRFDB((PPERF_DATA_BLOCK) m_lpbPrfData);
}


//////////////////////////////////////////////////////////////


CPROCDB::CPROCDB(WORD wQueryType/*, PROCDBERR *lpPROCDBError*/)
{
	m_lpbPrfData = NULL;
	Refresh(wQueryType/*, lpPROCDBError*/);
}


//////////////////////////////////////////////////////////////


CPROCDB::~CPROCDB(void)
{
	if (m_lpbPrfData != NULL)
	{
		delete(m_pPrfDB);
		HeapFree(GetProcessHeap(), 0, m_lpbPrfData);
		m_lpbPrfData = NULL;
	}
}


//////////////////////////////////////////////////////////////


void CPROCDB::Refresh(WORD wQueryType/*, PROCDBERR *lpPROCDBError*/)
{
//	*lpPROCDBError = PROCDBE_NOERROR;
//	m_lpbPrfData = NULL;
	GetPrfData(wQueryType);
}
		

//////////////////////////////////////////////////////////////


int CPROCDB::GetNumProcesses(void) const
{
	int nNumProcesses = 0;
	// Find Process Object in performance data.
	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIProcess);
	if (pPrfObjType != NULL)
	{
		// If found, NumInstances indicates number 
		// of running processes
		nNumProcesses = pPrfObjType->NumInstances;		
	}
	return(nNumProcesses);
}


//////////////////////////////////////////////////////////////


int CPROCDB::GetProcIndexFromId(DWORD dwProcessId) const
{
	int nNumProcesses = GetNumProcesses();

	while (nNumProcesses--)
	{
		PRFCNTRPROC PrfCntrProc;
		GetPrfCntrProc(nNumProcesses, &PrfCntrProc);
		if (PrfCntrProc.dwProcessId == dwProcessId)
			return(nNumProcesses);
	}
	return(-1);
}


//////////////////////////////////////////////////////////////


int CPROCDB::GetProcASIndexFromId(DWORD dwProcessId) const
{
	int nNumProcesses = GetNumProcesses();

	while (nNumProcesses--)
	{
		PRFCNTRPROCAS PrfCntrProcAddrSpc;
		GetPrfCntrProcAS(nNumProcesses, &PrfCntrProcAddrSpc);
		if (PrfCntrProcAddrSpc.dwProcessId == dwProcessId)
			return(nNumProcesses);
	}
	return(-1);
}


//////////////////////////////////////////////////////////////


LPCWSTR CPROCDB::GetProcessName(int nIndexPrc) const
{
	LPCWSTR szProcessName = NULL;

	// Find Process Object in performance data.
	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIProcess);
	if (pPrfObjType != NULL)
	{
		// If found, Get the nIndexPrc'th instance
		PCPRFINSTDEF pPrfInstDef = m_pPrfDB->GetInst(pPrfObjType, nIndexPrc);
		if (pPrfInstDef != NULL)
			szProcessName = (LPCWSTR)m_pPrfDB->GetInstName(pPrfInstDef);
	}
	return(szProcessName);
}


//////////////////////////////////////////////////////////////


int CPROCDB::GetNumThreads(void) const
{
	int nNumThreads = 0;
	// Find Thread Object in performance data.
	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIThread);
	if (pPrfObjType != NULL)
	{
		// If found, NumInstances indicates number 
		// of running threads
		nNumThreads = pPrfObjType->NumInstances;		
	}
	return(nNumThreads);
}


//////////////////////////////////////////////////////////////
//
//
//int CPROCDB::GetNumProcessThreads (int nIndexPrc) const {
//	int nNumThreads = 0;
//	// Find Thread Object in performance data.
//	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIThread);
//	if (pPrfObjType != NULL) {
//		// If found, get first thread instance.
//		PCPRFINSTDEF pPrfInstDef = m_pPrfDB->GetFirstInst(pPrfObjType);
//		// Walk the list of instances and count the number of
//		// instances whose ParentObjectIndex equals nIndexPrc.
//		if (pPrfInstDef->ParentObjectInstance == (DWORD) nIndexPrc)
//			nNumThreads++;
//	}
//	return(nNumThreads);
//}


//////////////////////////////////////////////////////////////


int CPROCDB::GetNumProcessThreads(int nIndexPrc) const
{
	int nNumThreads = 0;
	// Find Thread Object in performance data.
	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIThread);
	if (pPrfObjType != NULL)
	{
		// If found, get first thread instance.
		PCPRFINSTDEF pPrfInstDef = m_pPrfDB->GetFirstInst(pPrfObjType);
		// Walk the list of instances and count the number of
		// instances whose ParentObjectIndex equals nIndexPrc.
		int nInstNum = 0, nNumInstances = m_pPrfDB->GetNumInstances(pPrfObjType);
		for (; nInstNum < nNumInstances; nInstNum++)
		{
			// ALERT: I am assumming that the Process names are 
			// enumerated in the same order for both the Process 
			// object instances and the Process Address Space 
			// Object instance
			if (pPrfInstDef->ParentObjectInstance == (DWORD) nIndexPrc)
				nNumThreads++;
			pPrfInstDef = m_pPrfDB->GetNextInst(pPrfInstDef);
		}
	}
	return(nNumThreads);
}


//////////////////////////////////////////////////////////////


int CPROCDB::GetThrdIndexFromId(DWORD dwThreadId) const
{
	int nNumThreads = GetNumThreads();

	while (nNumThreads--)
	{
		PRFCNTRTHRD PrfCntrThrd;
		GetPrfCntrThrd(nNumThreads, &PrfCntrThrd);
		if (PrfCntrThrd.dwThreadId == dwThreadId)
			return(nNumThreads);
	}
	return(-1);
}


//////////////////////////////////////////////////////////////


LPCWSTR CPROCDB::GetThreadName(int nIndexThd) const
{
	LPCWSTR szThreadName = NULL;

	// Find Thread Object in performance data.
	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIThread);
	if (pPrfObjType != NULL)
	{
		// If found, Get the nIndexPrc'th instance
		PCPRFINSTDEF pPrfInstDef = m_pPrfDB->GetInst(pPrfObjType, nIndexThd);
		if (pPrfInstDef != NULL)
			szThreadName = (LPCWSTR)GetProcessName(pPrfInstDef->ParentObjectInstance);
	}
	return(szThreadName);
}


//////////////////////////////////////////////////////////////


int CPROCDB::GetNumImages(void) const
{
	int nNumImages = 0;
	// Find Image Object in performance data.
	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIImage);
	if (pPrfObjType != NULL)
	{
		// If found, NumInstances indicates number 
		// of images
		nNumImages = pPrfObjType->NumInstances;		
	}
	return(nNumImages);
}


//////////////////////////////////////////////////////////////


int CPROCDB::GetNumProcessImages(int nIndexPrc) const
{
	int nNumImages = 0;
	// Find Image Object in performance data.
	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIImage);
	if (pPrfObjType != NULL)
	{
		// If found, get first image instance.
		PCPRFINSTDEF pPrfInstDef = m_pPrfDB->GetFirstInst(pPrfObjType);
		// Walk the list of instances and count the number of
		// instances whose ParentObjectIndex equals nIndexPrc.

		int nInstNum = 0, nNumInstances = m_pPrfDB->GetNumInstances(pPrfObjType);
		for (; nInstNum < nNumInstances; nInstNum++)
		{
			// ALERT: I am assumming that the Process names are 
			// enumerated in the same order for both the Process 
			// object instances and the Process Address Space 
			// Object instance
			if (pPrfInstDef->ParentObjectInstance == (DWORD) nIndexPrc)
				nNumImages++;
			pPrfInstDef = m_pPrfDB->GetNextInst(pPrfInstDef);
		}
	}
	return(nNumImages);
}


//////////////////////////////////////////////////////////////


LPCWSTR CPROCDB::GetImageName(int nIndexPrc, int nIndexImg) const
{
	LPCWSTR szImageName = NULL;
	int nNumImages = 0;

	// Find Image Object in performance data.
	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIImage);
	if (pPrfObjType != NULL) {
		// If found, get first image instance.
		PCPRFINSTDEF pPrfInstDef = m_pPrfDB->GetFirstInst(pPrfObjType);
		// Walk the list of instances and count the number of
		// instances whose ParentObjectIndex equals nIndexPrc.

		while ((pPrfInstDef != NULL) && (nNumImages <= nIndexImg))
		{
			// ALERT: I am assumming that the Process names are 
			// enumerated in the same order for both the Process 
			// object instances and the Process Address Space 
			// Object instance
			if (pPrfInstDef->ParentObjectInstance == (DWORD) nIndexPrc)
			{
				if (nNumImages++ == nIndexImg)
					szImageName = (LPCWSTR)m_pPrfDB->GetInstName(pPrfInstDef);
			}

			pPrfInstDef = m_pPrfDB->GetNextInst(pPrfInstDef);
		}
	}
	return(szImageName);
}


//////////////////////////////////////////////////////////////


BOOL CPROCDB::GetPrfCntrProc(int nIndexPrc, PRFCNTRPROC *lpPrfCntrProc) const
{
	// Find Process Object in performance data.
	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIProcess);
	if (pPrfObjType == NULL) 
		return(FALSE);
		
	// If found, get the nIndexPrc'th instance
	PCPRFINSTDEF pPrfInstDef = m_pPrfDB->GetInst(pPrfObjType, nIndexPrc);
	if (pPrfInstDef == NULL) 
		return(FALSE);
		
	int nCntr = 0, nNumCntrs = m_pPrfDB->GetNumCntrs(pPrfObjType);
	PCPRFCNTRDEF pPrfCntrDef = m_pPrfDB->GetFirstCntr(pPrfObjType);
	memcpy(&lpPrfCntrProc->PerfTime, &pPrfObjType->PerfTime, sizeof(pPrfObjType->PerfTime));
	memcpy(&lpPrfCntrProc->PerfFreq, &pPrfObjType->PerfFreq, sizeof(pPrfObjType->PerfFreq));

	for (; nCntr < nNumCntrs; nCntr++)
	{
		void * const pCntrData = m_pPrfDB->GetCntrData(pPrfInstDef, pPrfCntrDef);
		int cbDataLen = pPrfCntrDef->CounterSize;
		switch (pPrfCntrDef->CounterNameTitleIndex)
		{
			case PTI_PROCESS_PRIVILEGED_TIME:
				memcpy(&lpPrfCntrProc->liPctPrivTime, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_PROCESSOR_TIME:
				memcpy(&lpPrfCntrProc->liPctCPUTime, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_USER_TIME:
				memcpy(&lpPrfCntrProc->liPctUserTime, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_ELAPSED_TIME:
				memcpy(&lpPrfCntrProc->liElapsedTime, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_FILE_CONTROL_BYTES:
				memcpy(&lpPrfCntrProc->liFileCtrlBytesPerSec, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_FILE_CONTROL_OPERATIONS:
				memcpy(&lpPrfCntrProc->dwFileCtrlOpsPerSec, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_FILE_READ_BYTES:
				memcpy(&lpPrfCntrProc->liFileReadBytesPerSec, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_FILE_READ_OPERATIONS:
				memcpy(&lpPrfCntrProc->dwFileReadOpsPerSec, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_FILE_WRITE_BYTES:
				memcpy(&lpPrfCntrProc->liFileWriteBytesPerSec, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_FILE_WRITE_OPERATIONS:
				memcpy(&lpPrfCntrProc->dwFileWriteOpsPerSec, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_PROCESSID:
				memcpy(&lpPrfCntrProc->dwProcessId, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_FAULT_COUNT:
				memcpy(&lpPrfCntrProc->dwPageFltsPerSec, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_PAGEFILE_BYTES:
				memcpy(&lpPrfCntrProc->dwPageFilesBytes, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_PAGEFILE_BYTES_PEAK:
				memcpy(&lpPrfCntrProc->dwPageFilesBytesPeak, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_POOL_NONPAGED_BYTES:
				memcpy(&lpPrfCntrProc->dwPoolNonPagedBytes, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_POOL_PAGED_BYTES:
				memcpy(&lpPrfCntrProc->dwPoolPagedBytes, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_PRIORITY_BASE:
				memcpy(&lpPrfCntrProc->dwPriorityBase, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_PRIVATE_BYTES:
				memcpy(&lpPrfCntrProc->dwPrivateBytes, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_THREAD_COUNT:
				memcpy(&lpPrfCntrProc->dwThrdCnt, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_VIRTUAL_BYTES:
				memcpy(&lpPrfCntrProc->dwVirtBytes, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_VIRTUAL_BYTES_PEAK:
				memcpy(&lpPrfCntrProc->dwVirtBytesPeak, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_WORKING_SET:
				memcpy(&lpPrfCntrProc->dwWorkingSet, pCntrData, cbDataLen);
				break;
			case PTI_PROCESS_WORKING_SET_PEAK:
				memcpy(&lpPrfCntrProc->dwWorkingSetPeak, pCntrData, cbDataLen);
				break;
		}
		pPrfCntrDef = m_pPrfDB->GetNextCntr(pPrfCntrDef);
	}
	return(TRUE);
}


//////////////////////////////////////////////////////////////


BOOL CPROCDB::GetPrfCntrProcAS(int nIndexPrc, PRFCNTRPROCAS *lpPrfCntrProcAS) const
{
	// Find Process Object in performance data.
	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIProcAddrSpace);
	if (pPrfObjType == NULL) 
		return(FALSE);
		
	// If found, get the nIndexPrc'th instance
	PCPRFINSTDEF pPrfInstDef = m_pPrfDB->GetInst(pPrfObjType, nIndexPrc);
	if (pPrfInstDef == NULL) 
		return(FALSE);
		
	int nCntr = 0, nNumCntrs = m_pPrfDB->GetNumCntrs(pPrfObjType);
	PCPRFCNTRDEF pPrfCntrDef = m_pPrfDB->GetFirstCntr(pPrfObjType);
	memcpy(&lpPrfCntrProcAS->PerfTime, &pPrfObjType->PerfTime, sizeof(pPrfObjType->PerfTime));
	memcpy(&lpPrfCntrProcAS->PerfFreq, &pPrfObjType->PerfFreq, sizeof(pPrfObjType->PerfFreq));

	for (; nCntr < nNumCntrs; nCntr++)
	{
		void * const pCntrData = m_pPrfDB->GetCntrData(pPrfInstDef, pPrfCntrDef);
		int cbDataLen = pPrfCntrDef->CounterSize;
		switch (pPrfCntrDef->CounterNameTitleIndex) {
			case PTI_PROCADDR_BYTES_FREE:
				memcpy(&lpPrfCntrProcAS->dwBytesFree, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_BYTES_IMAGE_FREE:
				memcpy(&lpPrfCntrProcAS->dwBytesImgFree, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_BYTES_IMAGE_RESERVED:
				memcpy(&lpPrfCntrProcAS->dwBytesImgReserved, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_BYTES_RESERVED:
				memcpy(&lpPrfCntrProcAS->dwBytesReserved, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_PROCESSID:
				memcpy(&lpPrfCntrProcAS->dwProcessId, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_IMAGE_EXECREADONLY:
				memcpy(&lpPrfCntrProcAS->dwImgSpER, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_IMAGE_EXECREADWRITE:
				memcpy(&lpPrfCntrProcAS->dwImgSpERW, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_IMAGE_EXECWRITECOPY:
				memcpy(&lpPrfCntrProcAS->dwImgSpEWC, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_IMAGE_EXECUTABLE:
				memcpy(&lpPrfCntrProcAS->dwImgSpE, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_IMAGE_NOACCESS:
				memcpy(&lpPrfCntrProcAS->dwImgSpNA, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_IMAGE_READONLY:
				memcpy(&lpPrfCntrProcAS->dwImgSpR, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_IMAGE_READWRITE:
				memcpy(&lpPrfCntrProcAS->dwImgSpRW, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_IMAGE_WRITECOPY:
				memcpy(&lpPrfCntrProcAS->dwImgSpWC, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_MAPPED_EXECREADONLY:
				memcpy(&lpPrfCntrProcAS->dwMapSpER, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_MAPPED_EXECREADWRITE:
				memcpy(&lpPrfCntrProcAS->dwMapSpERW, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_MAPPED_EXECWRITECOPY:
				memcpy(&lpPrfCntrProcAS->dwMapSpEWC, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_MAPPED_EXECUTABLE:
				memcpy(&lpPrfCntrProcAS->dwMapSpE, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_MAPPED_NOACCESS:
				memcpy(&lpPrfCntrProcAS->dwMapSpNA, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_MAPPED_READONLY:
				memcpy(&lpPrfCntrProcAS->dwMapSpR, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_MAPPED_READWRITE:
				memcpy(&lpPrfCntrProcAS->dwMapSpRW, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_MAPPED_WRITECOPY:
				memcpy(&lpPrfCntrProcAS->dwMapSpWC, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_RESERVED_EXECREADONLY:
				memcpy(&lpPrfCntrProcAS->dwResSpER, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_RESERVED_EXECREADWRITE:
				memcpy(&lpPrfCntrProcAS->dwResSpERW, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_RESERVED_EXECWRITECOPY:
				memcpy(&lpPrfCntrProcAS->dwResSpEWC, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_RESERVED_EXECUTABLE:
				memcpy(&lpPrfCntrProcAS->dwResSpE, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_RESERVED_NOACCESS:
				memcpy(&lpPrfCntrProcAS->dwResSpNA, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_RESERVED_READONLY:
				memcpy(&lpPrfCntrProcAS->dwResSpR, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_RESERVED_READWRITE:
				memcpy(&lpPrfCntrProcAS->dwResSpRW, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_RESERVED_WRITECOPY:
				memcpy(&lpPrfCntrProcAS->dwResSpWC, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_UNASSIGNED_EXECREADONLY:
				memcpy(&lpPrfCntrProcAS->dwUnassSpER, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_UNASSIGNED_EXECREADWRITE:
				memcpy(&lpPrfCntrProcAS->dwUnassSpERW, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_UNASSIGNED_EXECWRITECOPY:
				memcpy(&lpPrfCntrProcAS->dwUnassSpEWC, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_UNASSIGNED_EXECUTABLE:
				memcpy(&lpPrfCntrProcAS->dwUnassSpE, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_UNASSIGNED_NOACCESS:
				memcpy(&lpPrfCntrProcAS->dwUnassSpNA, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_UNASSIGNED_READONLY:
				memcpy(&lpPrfCntrProcAS->dwUnassSpR, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_UNASSIGNED_READWRITE:
				memcpy(&lpPrfCntrProcAS->dwUnassSpRW, pCntrData, cbDataLen);
				break;
			case PTI_PROCADDR_UNASSIGNED_WRITECOPY:
				memcpy(&lpPrfCntrProcAS->dwUnassSpWC, pCntrData, cbDataLen);
				break;
		}
		pPrfCntrDef = m_pPrfDB->GetNextCntr(pPrfCntrDef);
	}
	return(TRUE);
}


//////////////////////////////////////////////////////////////


BOOL CPROCDB::GetPrfCntrThrd(int nIndexThd, PRFCNTRTHRD *lpPrfCntrThrd) const
{
	// Find Process Object in performance data.
	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIThread);
	if (pPrfObjType == NULL) 
		return(FALSE);
		
	// If found, get the nIndexThd'th instance
	PCPRFINSTDEF pPrfInstDef = m_pPrfDB->GetInst(pPrfObjType, nIndexThd);
	if (pPrfInstDef == NULL) 
		return(FALSE);
		
	int nCntr = 0, nNumCntrs = m_pPrfDB->GetNumCntrs(pPrfObjType);
	PCPRFCNTRDEF pPrfCntrDef = m_pPrfDB->GetFirstCntr(pPrfObjType);
	memcpy(&lpPrfCntrThrd->PerfTime, &pPrfObjType->PerfTime, sizeof(pPrfObjType->PerfTime));
	memcpy(&lpPrfCntrThrd->PerfFreq, &pPrfObjType->PerfFreq, sizeof(pPrfObjType->PerfFreq));

	for (; nCntr < nNumCntrs; nCntr++)
	{
		void * const pCntrData = m_pPrfDB->GetCntrData(pPrfInstDef, pPrfCntrDef);
		int cbDataLen = pPrfCntrDef->CounterSize;
		switch (pPrfCntrDef->CounterNameTitleIndex)
		{
			case PTI_THREAD_PRIVILEGED_TIME:
				memcpy(&lpPrfCntrThrd->liPctPrivTime, pCntrData, cbDataLen);
				break;
			case PTI_THREAD_PROCESSOR_TIME:
				memcpy(&lpPrfCntrThrd->liPctCPUTime, pCntrData, cbDataLen);
				break;
			case PTI_THREAD_USER_TIME:
				memcpy(&lpPrfCntrThrd->liPctUserTime, pCntrData, cbDataLen);
				break;
			case PTI_THREAD_CONTEXT_SWITCHES:
				memcpy(&lpPrfCntrThrd->dwCntxSwtchPerSec, pCntrData, cbDataLen);
				break;
			case PTI_THREAD_ELAPSED_TIME:
				memcpy(&lpPrfCntrThrd->liElapsedTime, pCntrData, cbDataLen);
				break;
			case PTI_THREAD_PROCESSID:
				memcpy(&lpPrfCntrThrd->dwProcessId, pCntrData, cbDataLen);
				break;
			case PTI_THREAD_THREADID:
				memcpy(&lpPrfCntrThrd->dwThreadId, pCntrData, cbDataLen);
				break;
			case PTI_THREAD_BASE_PRIORITY:
				memcpy(&lpPrfCntrThrd->dwPriorityBase, pCntrData, cbDataLen);
				break;
			case PTI_THREAD_CURRENT_PRIORITY:
				memcpy(&lpPrfCntrThrd->dwPriorityCrnt, pCntrData, cbDataLen);
				break;
			case PTI_THREAD_START_ADDRESS:
				memcpy(&lpPrfCntrThrd->dwStartAddr, pCntrData, cbDataLen);
				break;
			case PTI_THREAD_STATE:
				memcpy(&lpPrfCntrThrd->dwThreadState, pCntrData, cbDataLen);
				break;
			case PTI_THREAD_WAIT_REASON:
				memcpy(&lpPrfCntrThrd->dwThreadWaitReason, pCntrData, cbDataLen);
				break;
		}
		pPrfCntrDef = m_pPrfDB->GetNextCntr(pPrfCntrDef);
	}
	return(TRUE);
}


//////////////////////////////////////////////////////////////


BOOL CPROCDB::GetPrfCntrThrdDet(int nIndexThd, PRFCNTRTHRDDET *lpPrfCntrThrdDet) const
{
	// Find Process Object in performance data.
	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIThreadDet);
	if (pPrfObjType == NULL) 
		return(FALSE);
		
	// If found, get the nIndexThd'th instance
	PCPRFINSTDEF pPrfInstDef = m_pPrfDB->GetInst(pPrfObjType, nIndexThd);
	if (pPrfInstDef == NULL) 
		return(FALSE);
		
	int nCntr = 0, nNumCntrs = m_pPrfDB->GetNumCntrs(pPrfObjType);
	PCPRFCNTRDEF pPrfCntrDef = m_pPrfDB->GetFirstCntr(pPrfObjType);
	memcpy(&lpPrfCntrThrdDet->PerfTime, &pPrfObjType->PerfTime, sizeof(pPrfObjType->PerfTime));
	memcpy(&lpPrfCntrThrdDet->PerfFreq, &pPrfObjType->PerfFreq, sizeof(pPrfObjType->PerfFreq));

	for (; nCntr < nNumCntrs; nCntr++)
	{
		void * const pCntrData = m_pPrfDB->GetCntrData(pPrfInstDef, pPrfCntrDef);
		int cbDataLen = pPrfCntrDef->CounterSize;
		switch (pPrfCntrDef->CounterNameTitleIndex)
		{
			case PTI_THREAD_USER_PC:	// Thread Details object - User PC
				memcpy(&lpPrfCntrThrdDet->dwUserPC, pCntrData, cbDataLen);
				break;
		}
		pPrfCntrDef = m_pPrfDB->GetNextCntr(pPrfCntrDef);
	}
	return(TRUE);
}


//////////////////////////////////////////////////////////////


BOOL CPROCDB::GetPrfCntrImg(int nIndexPrc, int nIndexImg, PRFCNTRIMG *lpPrfCntrImg) const
{
	// Find Process Object in performance data.
	PCPRFOBJTYPE pPrfObjType = m_pPrfDB->FindObjFromTitleIndex(dwTIImage);
	if (pPrfObjType == NULL) 
		return(FALSE);
		
	// If found, get the nIndexPrc'th instance
	PCPRFINSTDEF pPrfInstDef = m_pPrfDB->GetInst(pPrfObjType, nIndexPrc);
	if (pPrfInstDef == NULL) 
		return(FALSE);
		
	int nCntr = 0, nNumCntrs = m_pPrfDB->GetNumCntrs(pPrfObjType);
	PCPRFCNTRDEF pPrfCntrDef = m_pPrfDB->GetFirstCntr(pPrfObjType);
	memcpy(&lpPrfCntrImg->PerfTime, &pPrfObjType->PerfTime, sizeof(pPrfObjType->PerfTime));
	memcpy(&lpPrfCntrImg->PerfFreq, &pPrfObjType->PerfFreq, sizeof(pPrfObjType->PerfFreq));

	for (; nCntr < nNumCntrs; nCntr++)
	{
		void * const pCntrData = m_pPrfDB->GetCntrData(pPrfInstDef, pPrfCntrDef);
		int cbDataLen = pPrfCntrDef->CounterSize;
		switch (pPrfCntrDef->CounterNameTitleIndex)
		{
			case PTI_IMAGE_EXECUTABLE:
				memcpy(&lpPrfCntrImg->dwE, pCntrData, cbDataLen);
				break;
			case PTI_IMAGE_EXE_READONLY:
				memcpy(&lpPrfCntrImg->dwER, pCntrData, cbDataLen);
				break;
			case PTI_IMAGE_EXE_READWRITE:
				memcpy(&lpPrfCntrImg->dwERW, pCntrData, cbDataLen);
				break;
			case PTI_IMAGE_EXE_WRITECOPY:
				memcpy(&lpPrfCntrImg->dwEWC, pCntrData, cbDataLen);
				break;
			case PTI_IMAGE_NOACCESS:
				memcpy(&lpPrfCntrImg->dwNA, pCntrData, cbDataLen);
				break;
			case PTI_IMAGE_READONLY:
				memcpy(&lpPrfCntrImg->dwR, pCntrData, cbDataLen);
				break;
			case PTI_IMAGE_READWRITE:
				memcpy(&lpPrfCntrImg->dwRW, pCntrData, cbDataLen);
				break;
			case PTI_IMAGE_WRITECOPY:
				memcpy(&lpPrfCntrImg->dwWC, pCntrData, cbDataLen);
				break;
		}
		pPrfCntrDef = m_pPrfDB->GetNextCntr(pPrfCntrDef);
	}
	return(TRUE);
}


//////////////////////// End Of File /////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\procdb.h ===
/*************************************************************
Module name: ProcDB.H
*************************************************************/

#ifndef _PROCDB_H_
#define _PROCDB_H_

class CPROCDB
{
	#define PROCDBQ_PROCESS		0x0001
	#define PROCDBQ_PROCESSAS	0x0002
	#define PROCDBQ_THREAD		0x0004
	#define PROCDBQ_THREADDET	0x0008
	#define PROCDBQ_IMAGE		0x0010

	public:
//		enum PROCDBERR {PROCDBE_NOERROR,};

	private:
		public:
		CPRFDB *m_pPrfDB;
		private:
		LPBYTE m_lpbPrfData;

		void GetPrfData(WORD wQueryType);

	public:
		CPROCDB (WORD wQueryType/*, PROCDBERR *lpPROCDBError*/);
		~CPROCDB (void);
		// Copy constructor goes here.

		void Refresh (WORD wQueryType/*, PROCDBERR *lpPROCDBError*/);

		struct PRFCNTRPROC
		{
			LARGE_INTEGER PerfTime;
			LARGE_INTEGER PerfFreq;			
			LARGE_INTEGER liPctPrivTime;			// PERF_100NSEC_TIMER
			LARGE_INTEGER liPctCPUTime;				// PERF_100NSEC_TIMER
			LARGE_INTEGER liPctUserTime;			// PERF_100NSEC_TIMER
			DWORD dwCntxSwtchPerSec;				// PERF_COUNTER_COUNTER
			LARGE_INTEGER liElapsedTime;			// PERF_ELAPSED_TIMER

			LARGE_INTEGER liFileCtrlBytesPerSec;	// PERF_COUNTER_BULK_COUNT
			DWORD dwFileCtrlOpsPerSec;				// PERF_COUNTER_COUNTER

			LARGE_INTEGER liFileReadBytesPerSec;	// PERF_COUNTER_BULK_COUNT
			DWORD dwFileReadOpsPerSec;				// PERF_COUNTER_COUNTER

			LARGE_INTEGER liFileWriteBytesPerSec;	// PERF_COUNTER_BULK_COUNT
			DWORD dwFileWriteOpsPerSec;				// PERF_COUNTER_COUNTER

			DWORD dwProcessId;						// PERF_COUNTER_RAWCOUNT

			DWORD dwPageFltsPerSec;					// PERF_COUNTER_COUNTER
			DWORD dwPageFilesBytes;					// PERF_COUNTER_RAWCOUNT
			DWORD dwPageFilesBytesPeak;				// PERF_COUNTER_RAWCOUNT

			DWORD dwPoolNonPagedBytes;				// PERF_COUNTER_RAWCOUNT
			DWORD dwPoolPagedBytes;					// PERF_COUNTER_RAWCOUNT

			DWORD dwPriorityBase;					// PERF_COUNTER_RAWCOUNT
			DWORD dwPrivateBytes;					// PERF_COUNTER_RAWCOUNT
			DWORD dwThrdCnt;						// PERF_COUNTER_RAWCOUNT

			DWORD dwVirtBytes;						// PERF_COUNTER_RAWCOUNT
			DWORD dwVirtBytesPeak;					// PERF_COUNTER_RAWCOUNT

			DWORD dwWorkingSet;						// PERF_COUNTER_RAWCOUNT
			DWORD dwWorkingSetPeak;					// PERF_COUNTER_RAWCOUNT
		};
		BOOL GetPrfCntrProc (int nIndexPrc, PRFCNTRPROC *lpPrfCntrProc) const;
		int GetNumProcesses (void) const;
		int GetProcIndexFromId (DWORD dwProcessId) const;
		LPCWSTR GetProcessName (int nIndexPrc) const;

		int GetNumProcessThreads (int nIndexPrc) const;
		int GetNumProcessImages (int nIndexPrc) const;

		struct PRFCNTRPROCAS
		{
			LARGE_INTEGER PerfTime;
			LARGE_INTEGER PerfFreq;			
			DWORD dwBytesFree;						// PERF_COUNTER_RAWCOUNT
			DWORD dwBytesImgFree;					// PERF_COUNTER_RAWCOUNT
			DWORD dwBytesImgReserved;				// PERF_COUNTER_RAWCOUNT
			DWORD dwBytesReserved;					// PERF_COUNTER_RAWCOUNT

			DWORD dwProcessId;						// PERF_COUNTER_RAWCOUNT

			DWORD dwImgSpER;						// PERF_COUNTER_RAWCOUNT
			DWORD dwImgSpERW;						// PERF_COUNTER_RAWCOUNT
			DWORD dwImgSpEWC;						// PERF_COUNTER_RAWCOUNT
			DWORD dwImgSpE;							// PERF_COUNTER_RAWCOUNT
			DWORD dwImgSpNA;						// PERF_COUNTER_RAWCOUNT
			DWORD dwImgSpR;							// PERF_COUNTER_RAWCOUNT
			DWORD dwImgSpRW;						// PERF_COUNTER_RAWCOUNT
			DWORD dwImgSpWC;						// PERF_COUNTER_RAWCOUNT

			DWORD dwMapSpER;						// PERF_COUNTER_RAWCOUNT
			DWORD dwMapSpERW;						// PERF_COUNTER_RAWCOUNT
			DWORD dwMapSpEWC;						// PERF_COUNTER_RAWCOUNT
			DWORD dwMapSpE;							// PERF_COUNTER_RAWCOUNT
			DWORD dwMapSpNA;						// PERF_COUNTER_RAWCOUNT
			DWORD dwMapSpR;							// PERF_COUNTER_RAWCOUNT
			DWORD dwMapSpRW;						// PERF_COUNTER_RAWCOUNT
			DWORD dwMapSpWC;						// PERF_COUNTER_RAWCOUNT

			DWORD dwResSpER;						// PERF_COUNTER_RAWCOUNT
			DWORD dwResSpERW;						// PERF_COUNTER_RAWCOUNT
			DWORD dwResSpEWC;						// PERF_COUNTER_RAWCOUNT
			DWORD dwResSpE;							// PERF_COUNTER_RAWCOUNT
			DWORD dwResSpNA;						// PERF_COUNTER_RAWCOUNT
			DWORD dwResSpR;							// PERF_COUNTER_RAWCOUNT
			DWORD dwResSpRW;						// PERF_COUNTER_RAWCOUNT
			DWORD dwResSpWC;						// PERF_COUNTER_RAWCOUNT

			DWORD dwUnassSpER;						// PERF_COUNTER_RAWCOUNT
			DWORD dwUnassSpERW;						// PERF_COUNTER_RAWCOUNT
			DWORD dwUnassSpEWC;						// PERF_COUNTER_RAWCOUNT
			DWORD dwUnassSpE;	 					// PERF_COUNTER_RAWCOUNT
			DWORD dwUnassSpNA;						// PERF_COUNTER_RAWCOUNT
			DWORD dwUnassSpR;						// PERF_COUNTER_RAWCOUNT
			DWORD dwUnassSpRW;						// PERF_COUNTER_RAWCOUNT
			DWORD dwUnassSpWC;						// PERF_COUNTER_RAWCOUNT
		};
		BOOL GetPrfCntrProcAS (int nIndexPrc, PRFCNTRPROCAS *lpPrfCntrProcAS) const;
		int GetProcASIndexFromId (DWORD dwProcessId) const;

		struct PRFCNTRTHRD
		{
			LARGE_INTEGER PerfTime;
			LARGE_INTEGER PerfFreq;			
			LARGE_INTEGER liPctPrivTime;			// PERF_100NSEC_TIMER
			LARGE_INTEGER liPctCPUTime;				// PERF_100NSEC_TIMER
			LARGE_INTEGER liPctUserTime;			// PERF_100NSEC_TIMER
			DWORD dwCntxSwtchPerSec;				// PERF_COUNTER_COUNTER
			LARGE_INTEGER liElapsedTime;			// PERF_ELAPSED_TIMER
			DWORD dwProcessId;						// PERF_COUNTER_RAWCOUNT
			DWORD dwThreadId;						// PERF_COUNTER_RAWCOUNT
			DWORD dwPriorityBase;					// PERF_COUNTER_RAWCOUNT
			DWORD dwPriorityCrnt;					// PERF_COUNTER_RAWCOUNT
			DWORD dwStartAddr;						// PERF_COUNTER_RAWCOUNT
			DWORD dwThreadState;					// PERF_COUNTER_RAWCOUNT
			DWORD dwThreadWaitReason;				// PERF_COUNTER_RAWCOUNT
		};
		BOOL GetPrfCntrThrd (int nIndexThd, PRFCNTRTHRD *lpPrfCntrThrd) const;
		int GetNumThreads (void) const;
		int GetThrdIndexFromId (DWORD dwThreadId) const;
		LPCWSTR GetThreadName (int nIndexThd) const;

		struct PRFCNTRIMG
		{
			LARGE_INTEGER PerfTime;
			LARGE_INTEGER PerfFreq;			
			DWORD dwE;								// PERF_COUNTER_RAWCOUNT
			DWORD dwER;								// PERF_COUNTER_RAWCOUNT
			DWORD dwERW;							// PERF_COUNTER_RAWCOUNT
			DWORD dwEWC;							// PERF_COUNTER_RAWCOUNT
			DWORD dwNA;								// PERF_COUNTER_RAWCOUNT
			DWORD dwR;								// PERF_COUNTER_RAWCOUNT
			DWORD dwRW;								// PERF_COUNTER_RAWCOUNT
			DWORD dwWC;								// PERF_COUNTER_RAWCOUNT
		};
		BOOL GetPrfCntrImg (int nIndexPrc, int nIndexImg, PRFCNTRIMG *lpPrfCntrImg) const;
		int GetNumImages (void) const;
		LPCWSTR GetImageName (int nIndexPrc, int nIndexImg) const;

		struct PRFCNTRTHRDDET
		{
			LARGE_INTEGER PerfTime;
			LARGE_INTEGER PerfFreq;			
			DWORD dwUserPC;							// PERF_COUNTER_RAWCOUNT
		};
		BOOL GetPrfCntrThrdDet (int nIndexThd, PRFCNTRTHRDDET *lpPrfCntrThrdDet) const;
};

#endif	//_PROCDB_H_

//////////////////////// End Of File /////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\property.h ===
//
// property.h
//
// Include file with worker routines used by the property pages.
//

//
// The Handles Table  structure.  This is used to build tables of handles
// for displaying in the property pages.
//
typedef struct
{
	HANDLE handle;
	LPSTR idObject;
	LPSTR pszName;
} HANDLESTABLE;

LPSTR FormatHex(DWORD dwValue);
LPSTR FormatHandle(HANDLE handle);
LPSTR FormatInt(INT iValue);
LPSTR FormatULong(ULONG ulValue);
LPSTR FormatKb(DWORD dwValue);
LPSTR FormatKb(LARGE_INTEGER liValue);
LPSTR FormatTime(LARGE_INTEGER liTime);
LPSTR FormatTime(FILETIME ftTime);
LPSTR FormatTimeDiff(LARGE_INTEGER liTimeBegin, LARGE_INTEGER liTimeEnd);
LPSTR FormatTimeDiff(SYSTEMTIME stTime, FILETIME ftTime);
LPSTR FormatTimeAdd(FILETIME ftTime1, FILETIME ftTime2);
LPSTR FormatWord(WORD w);
LPSTR FormatHandleFromTable(HANDLE handle, HANDLESTABLE *pht);
LPSTR FormatULongFromTable(ULONG ulValue, VALUETABLE *pvt);
void FillLBFromStrList(CListBox* pListBox, CStringList* pStrList);
void FillCBFromStrList(CComboBox* pComboBox, CStringList* pStrList);
MSGTYPE GetMsgType(UINT msg);
MSGTYPE GetMsgType(UINT msg, HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\progmsgs.cpp ===
//-----------------------------------------------------------------------------
//  ProgMsgs.cpp
//
//  Progress gauge (Chicago control) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifndef DISABLE_WIN95_MESSAGES
//////////////////////////////////////////////////////////////////////////////

DECODE(PBM_SETRANGE)
{
	PARM(nMinRange, INT, LOLP);
	PARM(nMaxRange, INT, HILP);

	POUT(nMinRange);
	POUT(nMaxRange);

	return TRUE;
}

DECODERET(PBM_SETRANGE)
{
	PARM(nPrevMinRange, INT, LORET);
	PARM(nPrevMaxRange, INT, HIRET);

	POUT(nPrevMinRange);
	POUT(nPrevMaxRange);

	return TRUE;
}

NODECODEPARM(PBM_SETRANGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(PBM_SETPOS)
{
	PARM(nNewPos, INT, WP);
	POUT(nNewPos);

	return TRUE;
}

DECODERET(PBM_SETPOS)
{
	PARM(nPrevPos, INT, RET);
	POUT(nPrevPos);

	return TRUE;
}

NODECODEPARM(PBM_SETPOS);

//////////////////////////////////////////////////////////////////////////////

DECODE(PBM_DELTAPOS)
{
	PARM(nIncrement, INT, WP);
	POUT(nIncrement);

	return TRUE;
}

DECODERET(PBM_DELTAPOS)
{
	PARM(nPrevPos, INT, RET);
	POUT(nPrevPos);

	return TRUE;
}

NODECODEPARM(PBM_DELTAPOS);

//////////////////////////////////////////////////////////////////////////////

DECODE(PBM_SETSTEP)
{
	PARM(nStepInc, INT, WP);
	POUT(nStepInc);

	return TRUE;
}

DECODERET(PBM_SETSTEP)
{
	PARM(nPrevStepInc, INT, RET);
	POUT(nPrevStepInc);

	return TRUE;
}

NODECODEPARM(PBM_SETSTEP);

//////////////////////////////////////////////////////////////////////////////

NODECODE(PBM_STEPIT);

DECODERET(PBM_STEPIT)
{
	PARM(nPrevPos, INT, RET);
	POUT(nPrevPos);

	return TRUE;
}

NODECODEPARM(PBM_STEPIT);

//////////////////////////////////////////////////////////////////////////////
#endif	// DISABLE_WIN95_MESSAGES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\property.cpp ===
// property.cpp : Worker routines for property pages.
//

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


//
// This single static buffer is used to format and return a string from
// several routines.  This means that the caller of these routines
// must make a copy of the returned string before calling one of
// the formatting functions again.
//
static CHAR szStringBuffer[128];


LPSTR FormatHex(DWORD dwValue)
{
	sprintf(szStringBuffer, "%08lX", dwValue);
	return szStringBuffer;
}

LPSTR FormatHandle(HANDLE handle)
{
	if (handle)
	{
		return FormatHex((DWORD)handle);
	}
	else
	{
		return ids(IDS_NONE_NOSPACE);
	}
}

LPSTR FormatInt(INT iValue)
{
	_itoa(iValue, szStringBuffer, 10);
	return szStringBuffer;
}

LPSTR FormatULong(ULONG ulValue)
{
	sprintf(szStringBuffer, "%lu", ulValue);
	return szStringBuffer;
}

LPSTR FormatKb(DWORD dwValue)
{
	sprintf(szStringBuffer, "%lu (%lu Kb)", dwValue, dwValue / 1024);
	return szStringBuffer;
}

#define Li2Double(x) ((double)((x).HighPart) * 4.294967296E9 + (double)((x).LowPart))

LPSTR FormatKb(LARGE_INTEGER liValue)
{
	double fValue = Li2Double(liValue);

	sprintf(szStringBuffer, "%.0f (%.0f Kb)", fValue, fValue / 1024);
	return szStringBuffer;
}

LPSTR FormatTime(LARGE_INTEGER liTime)
{
	int msec, sec, min, hr;

    double f = Li2Double(liTime)/1.0E7/3600;

    hr = (int)f;

    f = f - hr;
    min = (int)(f = f * 60);

    f = f - min;
    sec = (int)(f = f * 60);

    f = f - sec;
    msec = (int)(f * 1000);

	_stprintf(szStringBuffer, "%d:%02d:%02d.%03d", hr, min, sec, msec);

	return szStringBuffer;
}

LPSTR FormatTime(FILETIME ftTime)
{
	return(ids(IDS_UNAVAILABLE));

	UNREFERENCED_PARAMETER(ftTime);
}

LPSTR FormatTimeDiff(LARGE_INTEGER liTimeBegin, LARGE_INTEGER liTimeEnd)
{
	int msec, sec, min, hr;

    double fBegin = Li2Double(liTimeBegin)/1.0E7/3600;
    double fEnd   = Li2Double(liTimeEnd)/1.0E7/3600;

	double f = fEnd - fBegin;

	if (f == fEnd)
		return(ids(IDS_UNAVAILABLE));

    hr = (int)f;

    f = f - hr;
    min = (int)(f = f * 60);

    f = f - min;
    sec = (int)(f = f * 60);

    f = f - sec;
    msec = (int)(f * 1000);

	_stprintf(szStringBuffer, "%d:%02d:%02d.%03d", hr, min, sec, msec);

	return szStringBuffer;
}

LPSTR FormatTimeDiff(SYSTEMTIME stTime, FILETIME ftTime)
{
	return(ids(IDS_UNAVAILABLE));

	UNREFERENCED_PARAMETER(ftTime);
	UNREFERENCED_PARAMETER(stTime);
}

LPSTR FormatTimeAdd(FILETIME ftTime1, FILETIME ftTime2)
{
	return(ids(IDS_UNAVAILABLE));

	UNREFERENCED_PARAMETER(ftTime1);
	UNREFERENCED_PARAMETER(ftTime2);
}

LPSTR FormatWord(WORD w)
{
	sprintf(szStringBuffer, "%04X", w);
	return szStringBuffer;
}

LPSTR FormatHandleFromTable(HANDLE handle, HANDLESTABLE *pht)
{
	if (!handle)
	{
		return ids(IDS_NONE_NOSPACE);
	}

	while (pht->pszName)
	{
		if (handle == pht->handle)
		{
			return pht->pszName;
		}

		pht++;
	}

	return FormatHex((DWORD)handle);
}

LPSTR FormatULongFromTable(ULONG ulValue, VALUETABLE *pvt)
{
	while (pvt->pszValue)
	{
		if (ulValue == pvt->nValue)
		{
			return pvt->pszValue;
		}

		pvt++;
	}

	return FormatHex(ulValue);
}

void FillLBFromStrList(CListBox* pListBox, CStringList* pStrList)
{
	POSITION pos;

	pListBox->ResetContent();
	pos = pStrList->GetHeadPosition();
	while (pos)
	{
		pListBox->AddString(pStrList->GetNext(pos));
	}
}

void FillCBFromStrList(CComboBox* pComboBox, CStringList* pStrList)
{
	POSITION pos;

	pComboBox->ResetContent();
	pos = pStrList->GetHeadPosition();
	while (pos)
	{
		pComboBox->AddString(pStrList->GetNext(pos));
	}

	pComboBox->SetCurSel(0);
}

MSGTYPE GetMsgType(UINT msg)
{
	//
	// Is this message in the reserved system range?
	//
	if (msg < MAX_MESSAGES)
	{
		//
		// Do we find it in our lookup table?
		//
		if (CMsgDoc::m_apmdLT[msg])
		{
			return MT_NORMAL;
		}
		else
		{
			//
			// Not found in our table.  Must not be documented.
			//
			return MT_UNDOCUMENTED;
		}
	}
	else
	{
		//
		// Is it a registered message (0xC000 - 0xFFFF)?
		//
		if (msg >= MIN_REGISTEREDMSG)
		{
			return MT_REGISTERED;
		}
		else
		{
			//
			// Must be a WM_USER message.
			//
			return MT_USER;
		}
	}
}

MSGTYPE GetMsgType(UINT msg, HWND hwnd)
{
	//
	// Is this message in the reserved system range?
	//
	if (msg < MAX_MESSAGES)
	{
		//
		// Do we find it in our lookup table?
		//
		if (CMsgDoc::m_apmdLT[msg])
		{
			return MT_NORMAL;
		}
		else
		{
			//
			// Not found in our table.  Must not be documented.
			//
			return MT_UNDOCUMENTED;
		}
	}
	else
	{
		//
		// Is it a registered message (0xC000 - 0xFFFF)?
		//
		if (msg >= MIN_REGISTEREDMSG)
		{
			return MT_REGISTERED;
		}
		else
		{
			CHAR szClass[128];

			GetClassName(hwnd, szClass, sizeof(szClass));

			if (_tcscmp(szClass, "#32770") == 0)
			{
				switch(msg)
				{
					case DM_GETDEFID:
					case DM_SETDEFID:
						return MT_DIALOG;

					default:
						return MT_USER;
				}
			}
#ifndef DISABLE_WIN95_MESSAGES
			else if (_tcsicmp(szClass, "SysHeader32") == 0)
			{
				switch(msg)
				{
					case HDM_GETITEMCOUNT:
					case HDM_INSERTITEM:
					case HDM_DELETEITEM:
					case HDM_GETITEM:
					case HDM_SETITEM:
					case HDM_LAYOUT:
					case HDM_HITTEST:
						return MT_HEADER;

					default:
						return MT_USER;
				}
			}
			else if (_tcsicmp(szClass, "ToolbarWindow32") == 0)
			{
				switch(msg)
				{
					case TB_ENABLEBUTTON:
					case TB_CHECKBUTTON:
					case TB_PRESSBUTTON:
					case TB_HIDEBUTTON:
					case TB_INDETERMINATE:
					case TB_ISBUTTONENABLED:
					case TB_ISBUTTONCHECKED:
					case TB_ISBUTTONPRESSED:
					case TB_ISBUTTONHIDDEN:
					case TB_ISBUTTONINDETERMINATE:
					case TB_SETSTATE:
					case TB_GETSTATE:
					case TB_ADDBITMAP:
					case TB_ADDBUTTONS:
					case TB_INSERTBUTTON:
					case TB_DELETEBUTTON:
					case TB_GETBUTTON:
					case TB_BUTTONCOUNT:
					case TB_COMMANDTOINDEX:
					case TB_SAVERESTORE:
					case TB_CUSTOMIZE:
					case TB_ADDSTRING:
					case TB_GETITEMRECT:
					case TB_BUTTONSTRUCTSIZE:
					case TB_SETBUTTONSIZE:
					case TB_SETBITMAPSIZE:
					case TB_AUTOSIZE:
					case TB_SETBUTTONTYPE:
					case TB_GETTOOLTIPS:
					case TB_SETTOOLTIPS:
					case TB_SETPARENT:
					case TB_SETROWS:
					case TB_GETROWS:
					case TB_SETCMDID:
					case TB_CHANGEBITMAP:
					case TB_GETBITMAP:
					case TB_GETBUTTONTEXT:
						return MT_TOOLBAR;

					default:
						return MT_USER;
				}
			}
			else if (_tcsicmp(szClass, "tooltips_class32") == 0)
			{
				switch(msg)
				{
					case TTM_ACTIVATE:
					case TTM_SETDELAYTIME:
					case TTM_ADDTOOL:
					case TTM_DELTOOL:
					case TTM_NEWTOOLRECT:
					case TTM_RELAYEVENT:
					case TTM_GETTOOLINFO:
					case TTM_SETTOOLINFO:
					case TTM_HITTEST:
					case TTM_GETTEXT:
					case TTM_UPDATETIPTEXT:
					case TTM_GETTOOLCOUNT:
					case TTM_ENUMTOOLS:
					case TTM_GETCURRENTTOOL:
						return MT_TOOLTIP;

					default:
						return MT_USER;
				}
			}
			else if (_tcsicmp(szClass, "msctls_statusbar32") == 0)
			{
				switch(msg)
				{
					case SB_SETTEXT:
					case SB_GETTEXT:
					case SB_GETTEXTLENGTH:
					case SB_SETPARTS:
					case SB_GETPARTS:
					case SB_GETBORDERS:
					case SB_SETMINHEIGHT:
					case SB_SIMPLE:
					case SB_GETRECT:
						return MT_STATUSBAR;

					default:
						return MT_USER;
				}
			}
			else if (_tcsicmp(szClass, "msctls_trackbar32") == 0)
			{
				switch(msg)
				{
					case TBM_GETPOS:
					case TBM_GETRANGEMIN:
					case TBM_GETRANGEMAX:
					case TBM_GETTIC:
					case TBM_SETTIC:
					case TBM_SETPOS:
					case TBM_SETRANGE:
					case TBM_SETRANGEMIN:
					case TBM_SETRANGEMAX:
					case TBM_CLEARTICS:
					case TBM_SETSEL:
					case TBM_SETSELSTART:
					case TBM_SETSELEND:
					case TBM_GETPTICS:
					case TBM_GETTICPOS:
					case TBM_GETNUMTICS:
					case TBM_GETSELSTART:
					case TBM_GETSELEND:
					case TBM_CLEARSEL:
					case TBM_SETTICFREQ:
					case TBM_SETPAGESIZE:
					case TBM_GETPAGESIZE:
					case TBM_SETLINESIZE:
					case TBM_GETLINESIZE:
					case TBM_GETTHUMBRECT:
					case TBM_GETCHANNELRECT:
					case TBM_SETTHUMBLENGTH:
					case TBM_GETTHUMBLENGTH:
						return MT_TRACKBAR;

					default:
						return MT_USER;
				}
			}
			else if (_tcsicmp(szClass, "msctls_updown") == 0)
			{
				switch(msg)
				{
					case UDM_SETRANGE:
					case UDM_GETRANGE:
					case UDM_SETPOS:
					case UDM_GETPOS:
					case UDM_SETBUDDY:
					case UDM_GETBUDDY:
					case UDM_SETACCEL:
					case UDM_GETACCEL:
					case UDM_SETBASE:
					case UDM_GETBASE:
						return MT_UPDOWN;

					default:
						return MT_USER;
				}
			}
			else if (_tcsicmp(szClass, "msctls_progress32") == 0)
			{
				switch(msg)
				{
					case PBM_SETRANGE:
					case PBM_SETPOS:
					case PBM_DELTAPOS:
					case PBM_SETSTEP:
					case PBM_STEPIT:
						return MT_PROGRESS;

					default:
						return MT_USER;
				}
			}
			else if (_tcsicmp(szClass, "msctls_hotkey32") == 0)
			{
				switch(msg)
				{
					case HKM_SETHOTKEY:
					case HKM_GETHOTKEY:
					case HKM_SETRULES:
						return MT_HOTKEY;

					default:
						return MT_USER;
				}
			}
			else if (_tcsicmp(szClass, "SysListView32") == 0)
			{
				switch(msg)
				{
					case LVM_GETBKCOLOR:
					case LVM_SETBKCOLOR:
					case LVM_GETIMAGELIST:
					case LVM_SETIMAGELIST:
					case LVM_GETITEMCOUNT:
					case LVM_GETITEM:
					case LVM_SETITEM:
					case LVM_INSERTITEM:
					case LVM_DELETEITEM:
					case LVM_DELETEALLITEMS:
					case LVM_GETCALLBACKMASK:
					case LVM_SETCALLBACKMASK:
					case LVM_GETNEXTITEM:
					case LVM_FINDITEM:
					case LVM_GETITEMRECT:
					case LVM_SETITEMPOSITION:
					case LVM_GETITEMPOSITION:
					case LVM_GETSTRINGWIDTH:
					case LVM_HITTEST:
					case LVM_ENSUREVISIBLE:
					case LVM_SCROLL:
					case LVM_REDRAWITEMS:
					case LVM_ARRANGE:
					case LVM_EDITLABEL:
					case LVM_GETEDITCONTROL:
					case LVM_GETCOLUMN:
					case LVM_SETCOLUMN:
					case LVM_INSERTCOLUMN:
					case LVM_DELETECOLUMN:
					case LVM_GETCOLUMNWIDTH:
					case LVM_SETCOLUMNWIDTH:
					case LVM_CREATEDRAGIMAGE:
					case LVM_GETVIEWRECT:
					case LVM_GETTEXTCOLOR:
					case LVM_SETTEXTCOLOR:
					case LVM_GETTEXTBKCOLOR:
					case LVM_SETTEXTBKCOLOR:
					case LVM_GETTOPINDEX:
					case LVM_GETCOUNTPERPAGE:
					case LVM_GETORIGIN:
					case LVM_UPDATE:
					case LVM_SETITEMSTATE:
					case LVM_GETITEMSTATE:
					case LVM_GETITEMTEXT:
					case LVM_SETITEMTEXT:
					case LVM_SETITEMCOUNT:
					case LVM_SORTITEMS:
					case LVM_SETITEMPOSITION32:
					case LVM_GETSELECTEDCOUNT:
					case LVM_GETITEMSPACING:
					case LVM_GETISEARCHSTRING:
						return MT_LISTVIEW;

					default:
						return MT_USER;
				}
			}
			else if (_tcsicmp(szClass, "SysTreeView32") == 0)
			{
				switch(msg)
				{
					case TVM_INSERTITEM:
					case TVM_DELETEITEM:
					case TVM_EXPAND:
					case TVM_GETITEMRECT:
					case TVM_GETCOUNT:
					case TVM_GETINDENT:
					case TVM_SETINDENT:
					case TVM_GETIMAGELIST:
					case TVM_SETIMAGELIST:
					case TVM_GETNEXTITEM:
					case TVM_SELECTITEM:
					case TVM_GETITEM:
					case TVM_SETITEM:
					case TVM_EDITLABEL:
					case TVM_GETEDITCONTROL:
					case TVM_GETVISIBLECOUNT:
					case TVM_HITTEST:
					case TVM_CREATEDRAGIMAGE:
					case TVM_SORTCHILDREN:
					case TVM_ENSUREVISIBLE:
					case TVM_SORTCHILDRENCB:
					case TVM_ENDEDITLABELNOW:
					case TVM_GETISEARCHSTRING:
						return MT_TREEVIEW;

					default:
						return MT_USER;
				}
			}
			else if (_tcsicmp(szClass, "SysTabControl32") == 0)
			{
				switch(msg)
				{
					case TCM_GETBKCOLOR:
					case TCM_SETBKCOLOR:
					case TCM_GETIMAGELIST:
					case TCM_SETIMAGELIST:
					case TCM_GETITEMCOUNT:
					case TCM_GETITEM:
					case TCM_SETITEM:
					case TCM_INSERTITEM:
					case TCM_DELETEITEM:
					case TCM_DELETEALLITEMS:
					case TCM_GETITEMRECT:
					case TCM_GETCURSEL:
					case TCM_SETCURSEL:
					case TCM_HITTEST:
					case TCM_SETITEMEXTRA:
					case TCM_ADJUSTRECT:
					case TCM_SETITEMSIZE:
					case TCM_REMOVEIMAGE:
					case TCM_SETPADDING:
					case TCM_GETROWCOUNT:
					case TCM_GETTOOLTIPS:
					case TCM_SETTOOLTIPS:
					case TCM_GETCURFOCUS:
					case TCM_SETCURFOCUS:
						return MT_TABCTRL;

					default:
						return MT_USER;
				}
			}
			else if (_tcsicmp(szClass, "SysAnimate32") == 0)
			{
				switch(msg)
				{
					case ACM_OPEN:
					case ACM_PLAY:
					case ACM_STOP:
						return MT_ANIMATE;

					default:
						return MT_USER;
				}
			}
#endif	// DISABLE_WIN95_MESSAGES
			else
				return MT_USER;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\propinsp.cpp ===
// propinsp.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "proptab.h"
#include "hotlinkc.h"
#include "wndptabs.h"
#include "prcptabs.h"
#include "thdptabs.h"
#include "msgptabs.h"
#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Support for the last selected object maintenance.

static DWORD g_dwObjectLast = 0;
static int g_nObjectTypeLast = OT_NONE;
static BOOL g_bSpyImmediately = FALSE;

void SetLastSelectedObject(DWORD dwObject, int nObjectType)
{
	g_dwObjectLast = dwObject;
	g_nObjectTypeLast = nObjectType;
}

DWORD GetLastSelectedObject()
{
	return g_dwObjectLast;
}

int GetLastSelectedObjectType()
{
	return g_nObjectTypeLast;
}

void ChangeToLastSelectedObject()
{
	if (g_pInspector && g_nObjectTypeLast != OT_NONE)
	{
		g_pInspector->ChangeObject(g_dwObjectLast, g_nObjectTypeLast);
	}
}

void SetSpyImmediate(BOOL bDirect)
{
	g_bSpyImmediately = bDirect;
}

BOOL GetSpyImmediate()
{
	return g_bSpyImmediately;
}

/////////////////////////////////////////////////////////////////////////////
// CPropertyInspector

//
// Global pointer to the one instance of the Properties Inspector.
//
CPropertyInspector* g_pInspector = NULL;

void CPropertyInspector::ShowObjectProperties(DWORD dwObject, int nObjectType)
{
	if (!g_pInspector)
	{
		int iSelectTab;

		switch (nObjectType)
		{
			case OT_WINDOW:
				iSelectTab = theApp.GetWinTabCur();
				break;

			case OT_PROCESS:
				iSelectTab = theApp.GetPrcTabCur();
				break;

			case OT_THREAD:
				iSelectTab = theApp.GetThdTabCur();
				break;

			case OT_MESSAGE:
				iSelectTab = theApp.GetMsgTabCur();
				break;
		}

		CPropertyInspector* pDlg = new CPropertyInspector(IDS_PROPERTYINSPECTOR, NULL, iSelectTab);

		pDlg->SetObject(dwObject, nObjectType);
		pDlg->Create();
	}
	else
	{
		g_pInspector->ChangeObject(dwObject, nObjectType);
	}
}

CPropertyInspector::CPropertyInspector(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectTab, COMMIT_MODEL commitModel)
	: CTabbedDialog(nIDCaption, pParentWnd, iSelectTab, commitModel)//, m_ProcessDatabase(&m_pdbError)
{
	SetValidObjectFlag(FALSE);
	m_nObjectType = OT_NONE;
	m_dwObject = (DWORD)-1;
	m_fObjectTypeChanged = TRUE;

	g_pInspector = this;
}

CPropertyInspector::~CPropertyInspector()
{
	switch (m_nObjectType)
	{
		case OT_WINDOW:
			theApp.SetWinTabCur(m_nTabCur);
			break;

		case OT_PROCESS:
			theApp.SetPrcTabCur(m_nTabCur);
			break;

		case OT_THREAD:
			theApp.SetThdTabCur(m_nTabCur);
			break;

		case OT_MESSAGE:
			theApp.SetMsgTabCur(m_nTabCur);
			break;
	}

	g_pInspector = NULL;
}

VALUETABLE CPropertyInspector::m_astClass[] =
{
	TABLEENTRY(CS_GLOBALCLASS),
	TABLEENTRY(CS_BYTEALIGNWINDOW),
	TABLEENTRY(CS_BYTEALIGNCLIENT),
	TABLEENTRY(CS_SAVEBITS),
	TABLEENTRY(CS_NOCLOSE),
	TABLEENTRY(CS_NOKEYCVT),
	TABLEENTRY(CS_PARENTDC),		// TODO: is this obsolete?
	TABLEENTRY(CS_CLASSDC),
	TABLEENTRY(CS_OWNDC),
	TABLEENTRY(CS_DBLCLKS),
	TABLEENTRY(CS_KEYCVTWINDOW),	// TODO: is this obsolete?
	TABLEENTRY(CS_HREDRAW),
	TABLEENTRY(CS_VREDRAW),
	0, NULL
};

VALUETABLE CPropertyInspector::m_astColor[] =
{
	TABLEENTRY(COLOR_SCROLLBAR),
	TABLEENTRY(COLOR_BACKGROUND),
	TABLEENTRY(COLOR_ACTIVECAPTION),
	TABLEENTRY(COLOR_INACTIVECAPTION),
	TABLEENTRY(COLOR_MENU),
	TABLEENTRY(COLOR_WINDOW),
	TABLEENTRY(COLOR_WINDOWFRAME),
	TABLEENTRY(COLOR_MENUTEXT),
	TABLEENTRY(COLOR_WINDOWTEXT),
	TABLEENTRY(COLOR_CAPTIONTEXT),
	TABLEENTRY(COLOR_ACTIVEBORDER),
	TABLEENTRY(COLOR_INACTIVEBORDER),
	TABLEENTRY(COLOR_APPWORKSPACE),
	TABLEENTRY(COLOR_HIGHLIGHT),
	TABLEENTRY(COLOR_HIGHLIGHTTEXT),
	TABLEENTRY(COLOR_BTNFACE),
	TABLEENTRY(COLOR_BTNSHADOW),
	TABLEENTRY(COLOR_GRAYTEXT),
	TABLEENTRY(COLOR_BTNTEXT),
	TABLEENTRY(COLOR_INACTIVECAPTIONTEXT),
	TABLEENTRY(COLOR_BTNHIGHLIGHT),
	0, NULL
};

HANDLESTABLE CPropertyInspector::m_ahtSystemCursors[] =
{
	HANDLEENTRY(IDC_ARROW),
	HANDLEENTRY(IDC_IBEAM),
	HANDLEENTRY(IDC_WAIT),
	HANDLEENTRY(IDC_CROSS),
	HANDLEENTRY(IDC_UPARROW),
//	HANDLEENTRY(IDC_SIZE),
//	HANDLEENTRY(IDC_ICON),
	HANDLEENTRY(IDC_SIZENWSE),
	HANDLEENTRY(IDC_SIZENESW),
	HANDLEENTRY(IDC_SIZEWE),
	HANDLEENTRY(IDC_SIZENS),
	HANDLEENTRY(IDC_SIZEALL),
	HANDLEENTRY(IDC_NO),
	HANDLEENTRY(IDC_APPSTARTING),
	HANDLEENTRYLAST
};

HANDLESTABLE CPropertyInspector::m_ahtSystemIcons[] =
{
	HANDLEENTRY(IDI_APPLICATION),
	HANDLEENTRY(IDI_HAND),
	HANDLEENTRY(IDI_QUESTION),
	HANDLEENTRY(IDI_EXCLAMATION),
	HANDLEENTRY(IDI_ASTERISK),
	HANDLEENTRYLAST
};

void CPropertyInspector::InitializeTables()
{
	HANDLESTABLE *pht;

	// Initialize the system cursor and icon table.  The system
	// cursors and icons will have the same handle value in all
	// processes.
	//
	// dolphin 11776 [patbr] don't DestroyCursor()/DestroyIcon the 
	// cursors/icons loaded here--improper, plus RIPs on Chicago.

	pht = m_ahtSystemCursors;
	while (pht->pszName)
	{
		pht->handle = (HANDLE)::LoadCursor(NULL, pht->idObject);
		pht++;
	}

	pht = m_ahtSystemIcons;
	while (pht->pszName)
	{
		pht->handle = (HANDLE)::LoadIcon(NULL, pht->idObject);
		pht++;
	}
}

BOOL CPropertyInspector::SetObject(DWORD dwObject, int nObjectType)
{
	BOOL fResult;

	switch (nObjectType)
	{
		case OT_WINDOW:
			fResult = SetWindowObject((HWND)dwObject);
			break;

		case OT_PROCESS:
			fResult = SetProcessObject(dwObject);
			break;

		case OT_THREAD:
			fResult = SetThreadObject(dwObject);
			break;

		case OT_MESSAGE:
			fResult = SetMessageObject((PMSGSTREAMDATA2)dwObject);
			break;

		case OT_NONE:
			fResult = SetNoObject();
			break;

		default:
			ASSERT(FALSE);
			fResult = FALSE;
			break;
	}

	m_dwObject = dwObject;
	m_nObjectType = nObjectType;

	return fResult;
}

BOOL CPropertyInspector::SetObjectType(int nObjectType)
{
	if ((nObjectType == m_nObjectType) && (m_tabRow.MaxTab() >= 0))
	{
		return(FALSE);
	}

	switch (m_nObjectType)
	{
		case OT_WINDOW:
			theApp.SetWinTabCur(m_nTabCur);
			break;

		case OT_PROCESS:
			theApp.SetPrcTabCur(m_nTabCur);
			break;

		case OT_THREAD:
			theApp.SetThdTabCur(m_nTabCur);
			break;

		case OT_MESSAGE:
			theApp.SetMsgTabCur(m_nTabCur);
			break;
	}

	ClearAllTabs();

	m_fObjectTypeChanged = TRUE;

	switch (nObjectType)
	{
		case OT_WINDOW:
			nCaptionID = IDS_WINDOWPROPERTIES;
			AddTab(new CWindowGeneralPropTab(IDD_WINDOWGENERALTAB, IDS_GENERALTAB));
			AddTab(new CWindowStylesPropTab(IDD_WINDOWSTYLESTAB, IDS_STYLESTAB));
			AddTab(new CWindowWindowsPropTab(IDD_WINDOWWINDOWSTAB, IDS_WINDOWSTAB));
			AddTab(new CWindowClassPropTab(IDD_WINDOWCLASSTAB, IDS_CLASSTAB));
			AddTab(new CWindowProcessPropTab(IDD_WINDOWPROCESSTAB, IDS_PROCESSTAB));
			break;

		case OT_PROCESS:
			nCaptionID = IDS_PROCESSPROPERTIES;
			AddTab(new CProcessGeneralPropTab(IDD_PROCESSGENERALTAB, IDS_GENERALTAB));
			if (!theApp.IsChicago())
			{
				AddTab(new CProcessMemoryPropTab(IDD_PROCESSMEMORYTAB, IDS_MEMORYTAB));
				AddTab(new CProcessPageFilePropTab(IDD_PROCESSPAGEFILETAB, IDS_PAGEFILETAB));
				AddTab(new CProcessSpacePropTab(IDD_PROCESSSPACETAB, IDS_SPACETAB));
			//	AddTab(new CProcessFileIOPropTab(IDD_PROCESSFILEIOTAB, IDS_FILEIOTAB));
			}
			break;

		case OT_THREAD:
			nCaptionID = IDS_THREADPROPERTIES;
			AddTab(new CThreadGeneralPropTab(IDD_THREADGENERALTAB, IDS_GENERALTAB));
			break;

		case OT_MESSAGE:
			nCaptionID = IDS_MESSAGEPROPERTIES;
			AddTab(new CMessageGeneralPropTab(IDD_MESSAGEGENERALTAB, IDS_GENERALTAB));
			break;

		case OT_NONE:
			nCaptionID = IDS_PROPERTYINSPECTOR;
			break;

		default:
			ASSERT(FALSE);
			break;
	}

	m_strCaption.LoadString(nCaptionID);

	return(TRUE);
}

BOOL CPropertyInspector::SetNoObject()
{
	return(SetObjectType(OT_NONE));
}

BOOL CPropertyInspector::SetWindowObject(HWND hwnd)
{
	BOOL fRet = SetObjectType(OT_WINDOW);
	m_hwnd = hwnd;
	return(fRet);
}

BOOL CPropertyInspector::RefreshWindowObjectData()
{
	CHAR szBuf[260];
	CHAR szClass[260];
	RECT rc;
	RECT rcClient;
	POINT pt;
	BOOL fGotOPD;
	OTHERPROCESSDATA opd;
	WORD w;
	DWORD dw;
	int cb;
	LPSTR psz;
	BOOL fOK;
	int i;
	int cbWndExtra;

	//
	// InitializeTables() must be called first!
	//
	if (!IsWindow(m_hwnd) || !::GetClassName(m_hwnd, szClass, sizeof(szClass) / sizeof(CHAR)))
	{
		return FALSE;
	}

	//
	// Try to obtain the other process data.  If this fails, we will
	// have to try and get our values another way.
	//
	fGotOPD = GetOtherProcessData(m_hwnd, &opd);

	//
	// Get the text.  Handle ordinal values properly.
	//
	*szBuf = 0;
	::GetWindowText(m_hwnd, szBuf, sizeof(szBuf) / sizeof(CHAR));
	if (*(PWORD)szBuf == 0xFFFF)
	{
		i = (INT)(*((PWORD)(&szBuf[2])));
		wsprintf(szBuf, "#%d", i);
	}
	m_strWindowCaption = szBuf;

	::GetWindowRect(m_hwnd, &rc);
	wsprintf(szBuf, "(%d, %d)-(%d, %d), %dx%d", rc.left, rc.top, rc.right, rc.bottom, rc.right - rc.left, rc.bottom - rc.top);
	if (::IsIconic(m_hwnd))
	{
		_tcscat(szBuf, ids(IDS_MINIMIZED));
	}
	else if (::IsZoomed(m_hwnd))
	{
		_tcscat(szBuf, ids(IDS_MAXIMIZED));
	}
	m_strRectangle = szBuf;

	::GetClientRect(m_hwnd, &rcClient);
	pt.x = 0;
	pt.y = 0;
	::ClientToScreen(m_hwnd, &pt);
	::OffsetRect(&rcClient, pt.x - rc.left, pt.y - rc.top);
	wsprintf(szBuf, "(%d, %d)-(%d, %d), %dx%d", rcClient.left, rcClient.top, rcClient.right, rcClient.bottom, 
		rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
	m_strClientRect = szBuf;

	if (::IsIconic(m_hwnd) || ::IsZoomed(m_hwnd))
	{
		WINDOWPLACEMENT wndpl;

		if (::GetWindowPlacement(m_hwnd, &wndpl))
		{
			wsprintf(szBuf, "(%d, %d)-(%d, %d), %dx%d",
				wndpl.rcNormalPosition.left, wndpl.rcNormalPosition.top,
				wndpl.rcNormalPosition.right, wndpl.rcNormalPosition.bottom,
				wndpl.rcNormalPosition.right - wndpl.rcNormalPosition.left,
				wndpl.rcNormalPosition.bottom - wndpl.rcNormalPosition.top);
			m_strRestoredRect = szBuf;
		}
		else
		{
			m_strRestoredRect = ids(IDS_UNAVAILABLE);
		}
	}
	else
	{
		m_strRestoredRect = m_strRectangle;
	}

	m_dwID = ::GetWindowLong(m_hwnd, GWL_ID);
	m_dwUserData = ::GetWindowLong(m_hwnd, GWL_USERDATA);

	m_strClassName = szClass;

	DWORD dwStyles = m_flStyles = GetWindowLong(m_hwnd, GWL_STYLE);
	FillStrListFromTable(&m_strListStyles, &dwStyles, tblWindowStyles);

	if (!m_strClassName.CompareNoCase("BUTTON"))
	{
		AppendStrListFromButtonTable(&m_strListStyles, dwStyles, tblButtonStyles);
	}
	else if (!m_strClassName.CompareNoCase("COMBOBOX"))
	{
		FillStrListFromTable(&m_strListStyles, &dwStyles, tblComboBoxStyles, FALSE, FALSE, TRUE);
	}
	else if (!m_strClassName.CompareNoCase("EDIT"))
	{
		AppendStrListFromEditTable(&m_strListStyles, dwStyles, tblEditStyles);
	}
	else if (!m_strClassName.CompareNoCase("LISTBOX"))
	{
		FillStrListFromTable(&m_strListStyles, &dwStyles, tblListBoxStyles, FALSE, FALSE, TRUE);
	}
	else if (!m_strClassName.CompareNoCase("SCROLLBAR"))
	{
		AppendStrListFromScrollTable(&m_strListStyles, dwStyles, tblScrollBarStyles);
	}
	else if (!m_strClassName.CompareNoCase("STATIC"))
	{
		FillStrListFromTable(&m_strListStyles, &dwStyles, tblStaticStyles, FALSE, TRUE, TRUE);
	}
#ifndef DISABLE_WIN95_MESSAGES
	else if (!m_strClassName.CompareNoCase("SysHeader32"))
	{
		FillStrListFromTable(&m_strListStyles, &dwStyles, tblHeaderStyles, FALSE, FALSE, TRUE);
	}
#endif
	else if (!m_strClassName.CompareNoCase("ToolbarWindow32"))
	{
		FillStrListFromTable(&m_strListStyles, &dwStyles, tblToolbarStyles, FALSE, FALSE, TRUE);
	}
#ifndef DISABLE_WIN95_MESSAGES
	else if (!m_strClassName.CompareNoCase("tooltips_class32"))
	{
		FillStrListFromTable(&m_strListStyles, &dwStyles, tblToolTipStyles, FALSE, FALSE, TRUE);
	}
	else if (!m_strClassName.CompareNoCase("msctls_statusbar32"))
	{
		FillStrListFromTable(&m_strListStyles, &dwStyles, tblStatusBarStyles, FALSE, FALSE, TRUE);
	}
	else if (!m_strClassName.CompareNoCase("msctls_trackbar32"))
	{
		AppendStrListFromTrackBarTable(&m_strListStyles, dwStyles, tblTrackBarStyles);
	}
#endif
	else if (!m_strClassName.CompareNoCase("msctls_updown32") || !m_strClassName.CompareNoCase("msctls_updown"))
	{
		FillStrListFromTable(&m_strListStyles, &dwStyles, tblUpDownStyles, FALSE, FALSE, TRUE);
	}
 #ifndef DISABLE_WIN95_MESSAGES
	else if (!m_strClassName.CompareNoCase("SysListView32"))
	{
		AppendStrListFromListViewTable(&m_strListStyles, dwStyles, tblListViewStyles);
	}
	else if (!m_strClassName.CompareNoCase("SysTreeView32"))
	{
		FillStrListFromTable(&m_strListStyles, &dwStyles, tblTreeViewStyles, FALSE, FALSE, TRUE);
	}
	else if (!m_strClassName.CompareNoCase("SysTabControl32"))
	{
		AppendStrListFromTabControlTable(&m_strListStyles, dwStyles, tblTabControlStyles);
	}
	else if (!m_strClassName.CompareNoCase("SysAnimate32"))
	{
		FillStrListFromTable(&m_strListStyles, &dwStyles, tblAnimateStyles, FALSE, FALSE, TRUE);
	}
#endif
	else
	{
		FillStrListFromTable(&m_strListStyles, &dwStyles, tblWindowStyles, FALSE, FALSE, TRUE);
	}

	dwStyles = m_flExtStyles = GetWindowLong(m_hwnd, GWL_EXSTYLE);
	FillStrListFromTable(&m_strListExtStyles, &dwStyles, tblExtWindowStyles, TRUE, FALSE, TRUE);

	m_hwndNext = ::GetWindow(m_hwnd, GW_HWNDNEXT);
	m_hwndPrevious = ::GetWindow(m_hwnd, GW_HWNDPREV);
	m_hwndChild = ::GetWindow(m_hwnd, GW_CHILD);
	m_hwndParent = ::GetParent(m_hwnd);
	m_hwndOwner = ::GetWindow(m_hwnd, GW_OWNER);

	if (psz = GetExpandedClassName(szClass))
	{
		m_strClassName += psz;
	}

	w = GetClassWord(m_hwnd, GCW_ATOM);
	if (w)
	{
		m_strClassAtom = FormatWord(w);
	}
	else
	{
		m_strClassAtom = ids(IDS_UNAVAILABLE);
	}

	if (fGotOPD && opd.fValidWC)
	{
		dw = opd.wc.style;
		fOK = TRUE;
	}
	else
	{
		SetLastError(0);
		dw = GetClassLong(m_hwnd, GCL_STYLE);
		fOK = !GetLastError();
	}

	if (fOK)
	{
		m_strClassStyles = FormatHex(dw);
		FillStrListFromTable(&m_strListClassStyles, &dw, m_astClass);
	}
	else
	{
		m_strClassStyles = ids(IDS_UNAVAILABLE);
	}

	if (fGotOPD && opd.fValidWC)
	{
		cbWndExtra = opd.wc.cbWndExtra;
		fOK = TRUE;
	}
	else
	{
		SetLastError(0);
		cbWndExtra = (INT)GetClassLong(m_hwnd, GCL_CBWNDEXTRA);
		fOK = !GetLastError();
	}

	m_strListExtraBytes.RemoveAll();
	if (fOK)
	{
		m_strClassWndExtraBytes = FormatInt(cbWndExtra);

		for (i = 0; i < cbWndExtra; i += sizeof(DWORD))
		{
			wsprintf(szBuf, "+%-8d", i);

			SetLastError(0);

			//
			// Check for the case where they don't have a full DWORD left.
			//
			if (cbWndExtra - i == 2)
			{
				dw = (WORD)::GetWindowWord(m_hwnd, i);
				if (GetLastError())
				{
					_tcscat(szBuf, ids(IDS_UNAVAILABLE));
				}
				else
				{
					_tcscat(szBuf, FormatWord((WORD)dw));
				}
			}
			else
			{
				dw = (DWORD)GetWindowLong(m_hwnd, i);
				if (GetLastError())
				{
					_tcscat(szBuf, ids(IDS_UNAVAILABLE));
				}
				else
				{
					_tcscat(szBuf, FormatHex(dw));
				}
			}

			m_strListExtraBytes.AddTail(szBuf);
		}
	}
	else
	{
		m_strClassWndExtraBytes = ids(IDS_UNAVAILABLE);
	}

	if (fGotOPD && opd.fValidWC)
	{
		cb = opd.wc.cbClsExtra;
		fOK = TRUE;
	}
	else
	{
		SetLastError(0);
		cb = (INT)GetClassLong(m_hwnd, GCL_CBCLSEXTRA);
		fOK = !GetLastError();
	}

	m_strListClassExtraBytes.RemoveAll();
	if (fOK)
	{
		m_strClassExtraBytes = FormatInt(cb);

		if (cb)
		{
			for (i = 0; i < cb; i += sizeof(DWORD))
			{
				wsprintf(szBuf, "+%-8d", i);

				SetLastError(0);

				//
				// Check for the case where they don't have a full DWORD left.
				//
				if (cb - i == 2)
				{
					dw = (WORD)::GetClassWord(m_hwnd, i);
					if (GetLastError())
					{
						_tcscat(szBuf, ids(IDS_UNAVAILABLE));
					}
					else
					{
						_tcscat(szBuf, FormatWord((WORD)dw));
					}
				}
				else
				{
					dw = (DWORD)GetClassLong(m_hwnd, i);
					if (GetLastError())
					{
						_tcscat(szBuf, ids(IDS_UNAVAILABLE));
					}
					else
					{
						_tcscat(szBuf, FormatHex(dw));
					}
				}

				m_strListClassExtraBytes.AddTail(szBuf);
			}
		}
	}
	else
	{
		m_strClassExtraBytes = ids(IDS_UNAVAILABLE);
	}

	if (fGotOPD && opd.fValidWC)
	{
		dw = (DWORD)opd.wc.hInstance;
		fOK = TRUE;
	}
	else
	{
		SetLastError(0);
		dw = GetClassLong(m_hwnd, GCL_HMODULE);
		fOK = !GetLastError();
	}

	if (fOK)
	{
		m_strClassInstance = FormatHex(dw);
	}
	else
	{
		m_strClassInstance = ids(IDS_UNAVAILABLE);
	}

	if (fGotOPD && opd.fValidWC)
	{
		dw = (DWORD)opd.wc.lpfnWndProc;
		fOK = TRUE;
	}
	else
	{
		SetLastError(0);
		if (IsWindowUnicode(m_hwnd))
		{
			dw = GetClassLongW(m_hwnd, GCL_WNDPROC);
		}
		else
		{
			dw = GetClassLongA(m_hwnd, GCL_WNDPROC);
		}
		fOK = !GetLastError();
	}

	if (fOK)
	{
		m_strClassWndProc = FormatHex(dw);
	}
	else
	{
		m_strClassWndProc = ids(IDS_UNAVAILABLE);
	}

	if (fGotOPD)
	{
		if (!(*opd.szMenuName))
		{
			m_strClassMenuName = ids(IDS_NONE_NOSPACE);
		}
		else
		{
			m_strClassMenuName = opd.szMenuName;
		}
	}
	else
	{
		m_strClassMenuName = ids(IDS_UNAVAILABLE);
	}

	if (fGotOPD && opd.fValidWC)
	{
		dw = (DWORD)opd.wc.hIcon;
		fOK = TRUE;
	}
	else
	{
		SetLastError(0);
		dw = GetClassLong(m_hwnd, GCL_HICON);
		fOK = !GetLastError();
	}

	if (fOK)
	{
		m_strClassIcon = FormatHandleFromTable((HANDLE)dw, m_ahtSystemIcons);
	}
	else
	{
		m_strClassIcon = ids(IDS_UNAVAILABLE);
	}

	if (fGotOPD && opd.fValidWC)
	{
		dw = (DWORD)opd.wc.hCursor;
		fOK = TRUE;
	}
	else
	{
		SetLastError(0);
		dw = GetClassLong(m_hwnd, GCL_HCURSOR);
		fOK = !GetLastError();
	}

	if (fOK)
	{
		m_strClassCursor = FormatHandleFromTable((HANDLE)dw, m_ahtSystemCursors);
	}
	else
	{
		m_strClassCursor = ids(IDS_UNAVAILABLE);
	}

	if (fGotOPD && opd.fValidWC)
	{
		dw = (DWORD)opd.wc.hbrBackground;
		fOK = TRUE;
	}
	else
	{
		SetLastError(0);
		dw = GetClassLong(m_hwnd, GCL_HBRBACKGROUND);
		fOK = !GetLastError();
	}

	if (fOK)
	{
		VALUETABLE* pvt = m_astColor;
		psz = NULL;

		while (pvt->pszValue)
		{
			if (dw - 1 == pvt->nValue)
			{
				psz = pvt->pszValue;
				break;
			}

			pvt++;
		}

		if (psz)
		{
			m_strClassBrush = psz;
		}
		else
		{
			m_strClassBrush = FormatHandle((HANDLE)dw);
		}
	}
	else
	{
		m_strClassBrush = ids(IDS_UNAVAILABLE);
	}

	m_ThreadID = ::GetWindowThreadProcessId(m_hwnd, &m_ProcessID);
	if (m_ThreadID)
	{
		m_fValidProcessThreadID = TRUE;
	}
	else
	{
		m_fValidProcessThreadID = FALSE;
	}

	m_hInstance = (HINSTANCE)::GetWindowLong(m_hwnd, GWL_HINSTANCE);

	if (fGotOPD && opd.pfnWndProc)
	{
		m_strWndProc = FormatHex((DWORD)opd.pfnWndProc);
	}
	else
	{
		m_strWndProc = ids(IDS_UNAVAILABLE);

	}

	if (IsWindowUnicode(m_hwnd))
	{
		m_strWndProc += ids(IDS_UNICODE);
	}

	if (fGotOPD && opd.fValidWC && opd.pfnWndProc != opd.wc.lpfnWndProc)
	{
		m_strWndProc += ids(IDS_SUBCLASSED);
	}

	return TRUE;
}

void CPropertyInspector::FillStrListFromTable(CStringList* pStrList, DWORD *flStyle, VALUETABLE *pvt,
	BOOL fRemoveAll, BOOL fOneEntry, BOOL fPrintExtras)
{
	DWORD dwTempStyle = *flStyle;
	BOOL  fFound = FALSE;

	if (fRemoveAll)
		pStrList->RemoveAll();

	while (pvt->pszValue && !fFound)
	{
		if ((dwTempStyle & pvt->nValue) == pvt->nValue)
		{
			pStrList->AddTail(pvt->pszValue);
			dwTempStyle &= ~pvt->nValue;
			if (fOneEntry)
				fFound = TRUE;
		}

		pvt++;
	}
	if (fPrintExtras && dwTempStyle)
		pStrList->AddTail(FormatHex(dwTempStyle));

	*flStyle = dwTempStyle;	// so styles don't get parsed twice
}

void CPropertyInspector::AppendStrListFromButtonTable(CStringList* pStrList, DWORD flStyle, VALUETABLE *pvt)
{
	DWORD dwTempStyle = flStyle;

	while (pvt->pszValue)
	{
		if ((dwTempStyle & pvt->nValue) == pvt->nValue)
		{
			if ((pvt->nValue == BS_PUSHBUTTON) && 
				(!(flStyle & BS_3STATE) && !(flStyle & BS_AUTO3STATE) && 
				!(flStyle & BS_AUTOCHECKBOX) && !(flStyle & BS_AUTORADIOBUTTON) && 
				!(flStyle & BS_CHECKBOX) && !(flStyle & BS_DEFPUSHBUTTON) && 
				!(flStyle & BS_GROUPBOX) && !(flStyle & BS_RADIOBUTTON)))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if (pvt->nValue != BS_PUSHBUTTON)
			{
				pStrList->AddTail(pvt->pszValue);
			}
			dwTempStyle &= ~pvt->nValue;
		}

		pvt++;
	}
	if (dwTempStyle)
		pStrList->AddTail(FormatHex(dwTempStyle));
}

void CPropertyInspector::AppendStrListFromScrollTable(CStringList* pStrList, DWORD flStyle, VALUETABLE *pvt)
{
	DWORD dwTempStyle = flStyle;

	while (pvt->pszValue)
	{
		if ((dwTempStyle & pvt->nValue) == pvt->nValue)
		{
			if ((pvt->nValue == SBS_HORZ) && 
				(!(flStyle & SBS_VERT) && !(flStyle & SBS_SIZEBOX)))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if ((pvt->nValue == SBS_VERT) && !(flStyle & SBS_SIZEBOX))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if ((pvt->nValue == SBS_TOPALIGN) && !(flStyle & SBS_SIZEBOX))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if ((pvt->nValue == SBS_LEFTALIGN) && !(flStyle & SBS_SIZEBOX))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if ((pvt->nValue == SBS_BOTTOMALIGN) && !(flStyle & SBS_SIZEBOX))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if ((pvt->nValue == SBS_RIGHTALIGN) && !(flStyle & SBS_SIZEBOX))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if ((pvt->nValue == SBS_SIZEBOXTOPLEFTALIGN) && (flStyle & SBS_SIZEBOX))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if ((pvt->nValue == SBS_SIZEBOXBOTTOMRIGHTALIGN) && (flStyle & SBS_SIZEBOX))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if (pvt->nValue == SBS_SIZEBOX)
			{
				pStrList->AddTail(pvt->pszValue);
			}
			dwTempStyle &= ~pvt->nValue;
		}

		pvt++;
	}
	if (dwTempStyle)
		pStrList->AddTail(FormatHex(dwTempStyle));
}

void CPropertyInspector::AppendStrListFromEditTable(CStringList* pStrList, DWORD flStyle, VALUETABLE *pvt)
{
	DWORD dwTempStyle = flStyle;

	while (pvt->pszValue)
	{
		if ((dwTempStyle & pvt->nValue) == pvt->nValue)
		{
			if ((pvt->nValue == ES_LEFT) && 
				(!(flStyle & ES_CENTER) && !(flStyle & ES_RIGHT)))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if (pvt->nValue != ES_LEFT)
			{
				pStrList->AddTail(pvt->pszValue);
			}
			dwTempStyle &= ~pvt->nValue;
		}

		pvt++;
	}
	if (dwTempStyle)
		pStrList->AddTail(FormatHex(dwTempStyle));
}

#ifndef DISABLE_WIN95_MESSAGES
void CPropertyInspector::AppendStrListFromTrackBarTable(CStringList* pStrList, DWORD flStyle, VALUETABLE *pvt)
{
	DWORD dwTempStyle = flStyle;

	while (pvt->pszValue)
	{
		if ((dwTempStyle & pvt->nValue) == pvt->nValue)
		{
			if ((pvt->nValue == TBS_HORZ) && (!(flStyle & TBS_VERT)))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if ((pvt->nValue == TBS_BOTTOM) && (!(flStyle & TBS_TOP)))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if ((pvt->nValue == TBS_RIGHT) && (!(flStyle & TBS_LEFT)))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if (pvt->nValue != TBS_HORZ && pvt->nValue != TBS_BOTTOM && pvt->nValue != TBS_RIGHT)
			{
				pStrList->AddTail(pvt->pszValue);
			}
			dwTempStyle &= ~pvt->nValue;
		}

		pvt++;
	}
	if (dwTempStyle)
		pStrList->AddTail(FormatHex(dwTempStyle));
}

void CPropertyInspector::AppendStrListFromListViewTable(CStringList* pStrList, DWORD flStyle, VALUETABLE *pvt)
{
	DWORD dwTempStyle = flStyle;

	while (pvt->pszValue)
	{
		if ((dwTempStyle & pvt->nValue) == pvt->nValue)
		{
			if ((pvt->nValue == LVS_ICON) && (!(flStyle & LVS_REPORT) && !(flStyle & LVS_SMALLICON) && !(flStyle & LVS_LIST)))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if (pvt->nValue != LVS_ICON)
			{
				pStrList->AddTail(pvt->pszValue);
			}
			dwTempStyle &= ~pvt->nValue;
		}

		pvt++;
	}
	if (dwTempStyle)
		pStrList->AddTail(FormatHex(dwTempStyle));
}

void CPropertyInspector::AppendStrListFromTabControlTable(CStringList* pStrList, DWORD flStyle, VALUETABLE *pvt)
{
	DWORD dwTempStyle = flStyle;

	while (pvt->pszValue)
	{
		if ((dwTempStyle & pvt->nValue) == pvt->nValue)
		{
			if ((pvt->nValue == TCS_TABS) && (!(flStyle & TCS_BUTTONS)))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if ((pvt->nValue == TCS_SINGLELINE) && (!(flStyle & TCS_MULTILINE)))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if ((pvt->nValue == TCS_RIGHTJUSTIFY) && (!(flStyle & TCS_FIXEDWIDTH) && !(flStyle & TCS_RAGGEDRIGHT)))
			{
				pStrList->AddTail(pvt->pszValue);
			}
			else if (pvt->nValue != TCS_TABS && pvt->nValue != TCS_SINGLELINE && pvt->nValue != TCS_RIGHTJUSTIFY)
			{
				pStrList->AddTail(pvt->pszValue);
			}
			dwTempStyle &= ~pvt->nValue;
		}

		pvt++;
	}
	if (dwTempStyle)
		pStrList->AddTail(FormatHex(dwTempStyle));
}

#endif //DISABLE_WIN95_MESSAGES

BOOL CPropertyInspector::SetProcessObject(DWORD pid)
{
	BOOL fRet = SetObjectType(OT_PROCESS);
	m_pid = pid;
	return(fRet);
}

BOOL CPropertyInspector::RefreshProcessObjectData()
{
	if (!theApp.IsChicago())
	{
		// Win32
		WORD wQueryType = (PROCDBQ_PROCESS | PROCDBQ_PROCESSAS);
		CPROCDB ProcessDatabase(wQueryType/*, &error*/);
	//	int iPrcIndex;
		int iPrcIndex, iPrcASIndex;
		LPWSTR pszExe;

		if ((iPrcIndex = ProcessDatabase.GetProcIndexFromId(m_pid)) == -1)
			return(FALSE);
		if ((iPrcASIndex = ProcessDatabase.GetProcASIndexFromId(m_pid)) == -1)
			return(FALSE);
		memset((void *)&m_ProcessInfo, 0, sizeof(CPROCDB::PRFCNTRPROC));
		memset((void *)&m_ProcessAddrSpcInfo, 0, sizeof(CPROCDB::PRFCNTRPROCAS));
		ProcessDatabase.GetPrfCntrProc(iPrcIndex, &m_ProcessInfo);
		ProcessDatabase.GetPrfCntrProcAS(iPrcASIndex, &m_ProcessAddrSpcInfo);
		pszExe = (LPWSTR)ProcessDatabase.GetProcessName(iPrcIndex);
		m_strExecutable = wcsupr(pszExe);
	}
	else
	{
		// Chicago
		HANDLE hProcessList;
		PROCESSENTRY32 pe32;

		pe32.dwSize = sizeof(PROCESSENTRY32);

		if ((hProcessList = (*theApp.pfnCreateToolhelp32Snapshot)(TH32CS_SNAPPROCESS, 0)) != NULL)
		{
			if ((*theApp.pfnProcess32First)(hProcessList, &pe32))
			{
				if (pe32.th32ProcessID == m_pid)
				{
					memcpy((void *)&m_ProcessEntry, (void *)&pe32, sizeof(PROCESSENTRY32));
					// GetTimesForProcess();
				}
				else
				{
					while ((*theApp.pfnProcess32Next)(hProcessList, &pe32))
					{
						if (pe32.th32ProcessID == m_pid)
						{
							memcpy((void *)&m_ProcessEntry, (void *)&pe32, sizeof(PROCESSENTRY32));
							// GetTimesForProcess();
							break;
						}
					}
				}
			}

			if (pe32.dwSize >= sizeof(PROCESSENTRY32))
			{
				char szFileName[_MAX_FNAME];
				_splitpath(m_ProcessEntry.szExeFile, NULL, NULL, szFileName, NULL);
				m_strExecutable = szFileName;
			}
			else
				m_strExecutable = ids(IDS_UNAVAILABLE);

			CloseHandle(hProcessList);
		}
	}

	return(TRUE);
}

void CPropertyInspector::GetTimesForProcess()
{
	HANDLE hProcess;
	
	if ((hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, m_pid)) != NULL)
	{
		GetSystemTime(&m_stPrcSnapshotTime);
		GetProcessTimes(hProcess, &m_ftPrcCreationTime, &m_ftPrcExitTime, &m_ftPrcKernelTime, &m_ftPrcUserTime);
	}
}

BOOL CPropertyInspector::SetThreadObject(DWORD tid)
{
	BOOL fRet = SetObjectType(OT_THREAD);
	m_tid = tid;
	return(fRet);
}

BOOL CPropertyInspector::RefreshThreadObjectData()
{
	if (!theApp.IsChicago())
	{
		// Win32
		WORD wQueryType = (PROCDBQ_THREAD | PROCDBQ_THREADDET);
		CPROCDB ProcessDatabase(wQueryType/*, &error*/);
		int iThdIndex;
		LPWSTR pszExe;

		if ((iThdIndex = ProcessDatabase.GetThrdIndexFromId(m_tid)) == -1)
			return(FALSE);
		memset((void *)&m_ThreadInfo, 0, sizeof(CPROCDB::PRFCNTRTHRD));
		memset((void *)&m_ThreadDetInfo, 0, sizeof(CPROCDB::PRFCNTRTHRDDET));
		ProcessDatabase.GetPrfCntrThrd(iThdIndex, &m_ThreadInfo);
		ProcessDatabase.GetPrfCntrThrdDet(iThdIndex, &m_ThreadDetInfo);
		pszExe = (LPWSTR)ProcessDatabase.GetThreadName(iThdIndex);
		m_strExecutable = wcsupr(pszExe);
	}
	else
	{
		// Chicago
		HANDLE hThreadList;
		THREADENTRY32 te32;

		te32.dwSize = sizeof(THREADENTRY32);

		if ((hThreadList = (*theApp.pfnCreateToolhelp32Snapshot)(TH32CS_SNAPTHREAD, 0)) != NULL)
		{
			if ((*theApp.pfnThread32First)(hThreadList, &te32))
			{
				if (te32.th32ThreadID == m_tid)
				{
					memcpy((void *)&m_ThreadEntry, (void *)&te32, sizeof(THREADENTRY32));
					// GetTimesForThread();
				}
				else
				{
					while ((*theApp.pfnThread32Next)(hThreadList, &te32))
					{
						if (te32.th32ThreadID == m_tid)
						{
							memcpy((void *)&m_ThreadEntry, (void *)&te32, sizeof(THREADENTRY32));
							// GetTimesForThread();
							break;
						}
					}
				}
			}

			CloseHandle(hThreadList);

			HANDLE hProcessList;
			PROCESSENTRY32 pe32;

			pe32.dwSize = sizeof(PROCESSENTRY32);

			if ((hProcessList = (*theApp.pfnCreateToolhelp32Snapshot)(TH32CS_SNAPPROCESS, 0)) != NULL)
			{
				if ((*theApp.pfnProcess32First)(hProcessList, &pe32))
				{
					if (pe32.th32ProcessID == m_ThreadEntry.th32OwnerProcessID)
					{
						memcpy((void *)&m_ProcessEntry, (void *)&pe32, sizeof(PROCESSENTRY32));
						// GetTimesForProcess();
					}
					else
					{
						while ((*theApp.pfnProcess32Next)(hProcessList, &pe32))
						{
							if (pe32.th32ProcessID == m_ThreadEntry.th32OwnerProcessID)
							{
								memcpy((void *)&m_ProcessEntry, (void *)&pe32, sizeof(PROCESSENTRY32));
								// GetTimesForProcess();
								break;
							}
						}
					}
				}

				if (pe32.dwSize >= sizeof(PROCESSENTRY32))
				{
					char szFileName[_MAX_FNAME];
					_splitpath(m_ProcessEntry.szExeFile, NULL, NULL, szFileName, NULL);
					m_strExecutable = szFileName;
				}
				else
					m_strExecutable = ids(IDS_UNAVAILABLE);

				CloseHandle(hProcessList);
			}
		}
	}

	return(TRUE);
}

void CPropertyInspector::GetTimesForThread()
{
	HANDLE hThread;
	
	if ((hThread = OpenProcess(THREAD_QUERY_INFORMATION, FALSE, m_tid)) != NULL)
	{
		GetSystemTime(&m_stThdSnapshotTime);
		GetThreadTimes(hThread, &m_ftThdCreationTime, &m_ftThdExitTime, &m_ftThdKernelTime, &m_ftThdUserTime);
	}
}

BOOL CPropertyInspector::SetMessageObject(PMSGSTREAMDATA2 pmsd2)
{
	BOOL fRet = SetObjectType(OT_MESSAGE);
	m_msd2 = *pmsd2;
	return(fRet);
}

BOOL CPropertyInspector::RefreshMessageObjectData()
{
	CHAR szBuf[256];
	CHAR szBuf2[128];
	LPSTR pszPostType;

	switch (m_msd2.fPostType)
	{
		case POSTTYPE_SENT:
			pszPostType = ids(IDS_SENT);
			break;

		case POSTTYPE_POSTED:
			pszPostType = ids(IDS_POSTED);
			break;

		case POSTTYPE_RETURN:
			pszPostType = ids(IDS_RETURN);
			break;

		case POSTTYPE_SENTNORETURN:
			pszPostType = ids(IDS_SENT_RETURN_UNAVAIL);
			break;

		default:
			//
			// Bogus value for fPostType!
			//
			ASSERT(FALSE);
			break;
	}

	sprintf(szBuf, "%4.4X  %s", m_msd2.msg, pszPostType);
	m_strMessage1 = szBuf;

	switch (m_msd2.mtMsgType)
	{
		case MT_NORMAL:
			m_strMessage2 = CMsgDoc::m_apmdLT[m_msd2.msg]->pszMsg;
			break;

		case MT_DIALOG:
			sprintf(szBuf, "%s", CMsgDoc::m_apmdDlgLT[m_msd2.msg - WM_USER]->pszMsg, m_msd2.msg - WM_USER);
			m_strMessage2 = szBuf;
			break;
#ifndef DISABLE_WIN95_MESSAGES
		case MT_ANIMATE:
			sprintf(szBuf, "%s", CMsgDoc::m_apmdAniLT[m_msd2.msg - (WM_USER + 100)]->pszMsg, m_msd2.msg - (WM_USER + 100));
			m_strMessage2 = szBuf;
			break;

		case MT_HEADER:
			sprintf(szBuf, "%s", CMsgDoc::m_apmdHdrLT[m_msd2.msg - HDM_FIRST]->pszMsg, m_msd2.msg - HDM_FIRST);
			m_strMessage2 = szBuf;
			break;

		case MT_HOTKEY:
			sprintf(szBuf, "%s", CMsgDoc::m_apmdHKLT[m_msd2.msg - (WM_USER + 1)]->pszMsg, m_msd2.msg - (WM_USER + 1));
			m_strMessage2 = szBuf;
			break;

		case MT_LISTVIEW:
			sprintf(szBuf, "%s", CMsgDoc::m_apmdLVLT[m_msd2.msg - LVM_FIRST]->pszMsg, m_msd2.msg - LVM_FIRST);
			m_strMessage2 = szBuf;
			break;

		case MT_PROGRESS:
			sprintf(szBuf, "%s", CMsgDoc::m_apmdProgLT[m_msd2.msg - (WM_USER + 1)]->pszMsg, m_msd2.msg - (WM_USER + 1));
			m_strMessage2 = szBuf;
			break;

		case MT_STATUSBAR:
			sprintf(szBuf, "%s", CMsgDoc::m_apmdStatLT[m_msd2.msg - (WM_USER + 1)]->pszMsg, m_msd2.msg - (WM_USER + 1));
			m_strMessage2 = szBuf;
			break;

		case MT_TOOLBAR:
			sprintf(szBuf, "%s", CMsgDoc::m_apmdTBLT[m_msd2.msg - (WM_USER + 1)]->pszMsg, m_msd2.msg - (WM_USER + 1));
			m_strMessage2 = szBuf;
			break;

		case MT_TRACKBAR:
			sprintf(szBuf, "%s", CMsgDoc::m_apmdTrkLT[m_msd2.msg - WM_USER]->pszMsg, m_msd2.msg - WM_USER);
			m_strMessage2 = szBuf;
			break;

		case MT_TABCTRL:
			sprintf(szBuf, "%s", CMsgDoc::m_apmdTabLT[m_msd2.msg - TCM_FIRST]->pszMsg, m_msd2.msg - TCM_FIRST);
			m_strMessage2 = szBuf;
			break;

		case MT_TOOLTIP:
			sprintf(szBuf, "%s", CMsgDoc::m_apmdTTLT[m_msd2.msg - (WM_USER + 1)]->pszMsg, m_msd2.msg - (WM_USER + 1));
			m_strMessage2 = szBuf;
			break;

		case MT_TREEVIEW:
			sprintf(szBuf, "%s", CMsgDoc::m_apmdTVLT[m_msd2.msg - TV_FIRST]->pszMsg, m_msd2.msg - TV_FIRST);
			m_strMessage2 = szBuf;
			break;

		case MT_UPDOWN:
			sprintf(szBuf, "%s", CMsgDoc::m_apmdUpDnLT[m_msd2.msg - (WM_USER + 101)]->pszMsg, m_msd2.msg - (WM_USER + 101));
			m_strMessage2 = szBuf;
			break;
#endif	// DISABLE_WIN95_MESSAGES
		case MT_UNDOCUMENTED:
			m_strMessage2 = ids(IDS_UNDOCUMENTED);
			break;

		case MT_REGISTERED:
			if (GetClipboardFormatName(m_msd2.msg, szBuf2,
				sizeof(szBuf2) / sizeof(CHAR)))
			{
				wsprintf(szBuf, ids(IDS_REGISTERED_PARAM), szBuf2);
				m_strMessage2 = szBuf;
			}
			else
			{
				m_strMessage2 = ids(IDS_REGISTERED);
			}

			break;

		case MT_USER:
			wsprintf(szBuf, "WM_USER+%d", m_msd2.msg - WM_USER);
			m_strMessage2 = szBuf;
			break;
	}

	return TRUE;
}

void CPropertyInspector::OnRefresh()
{
	BOOL fValidObject;
	BOOL fEnableRefresh = TRUE;

	switch (m_nObjectType)
	{
		case OT_WINDOW:
			fValidObject = RefreshWindowObjectData();
			break;

		case OT_PROCESS:
			fValidObject = RefreshProcessObjectData();
			break;

		case OT_THREAD:
			fValidObject = RefreshThreadObjectData();
			break;

		case OT_MESSAGE:
			fValidObject = RefreshMessageObjectData();
			fEnableRefresh = FALSE;
			break;

		case OT_NONE:
			fValidObject = FALSE;
			fEnableRefresh = FALSE;
			break;

		default:
			ASSERT(FALSE);
			break;
	}

	SetValidObjectFlag(fValidObject);

	if (fValidObject)
	{
		for (int nTab = 0; nTab < m_tabs.GetSize(); nTab++)
		{
			((CPropertyTab*)GetTab(nTab))->SetRefreshFlag(TRUE);
		}

		if (m_nTabCur != -1)
		{
			CPropertyTab* pTab = (CPropertyTab*)GetTab(m_nTabCur);
			if (pTab->GetSafeHwnd())
			{
				pTab->UpdateFields();
				pTab->SetRefreshFlag(FALSE);
			}
		}
		m_StaticMessage.ShowWindow(SW_HIDE);
	}
	else
	{
		UINT idsInvalid;
		DWORD dwObject;
		CHAR szMsg[100];

		ClearAllTabs();

		switch (m_nObjectType)
		{
			case OT_WINDOW:
				idsInvalid = IDS_INVALIDWINDOW;
				dwObject = (DWORD)m_hwnd;
				break;

			case OT_PROCESS:
				idsInvalid = IDS_INVALIDPROCESS;
				dwObject = m_pid;
				break;

			case OT_THREAD:
				idsInvalid = IDS_INVALIDTHREAD;
				dwObject = m_tid;
				break;

			case OT_MESSAGE:
				//
				// Messages cannot become invalid...
				//
				ASSERT(FALSE);
				break;

			case OT_NONE:
				break;

			default:
				ASSERT(FALSE);
				break;
		}

		if (m_nObjectType == OT_NONE)
		{
			m_StaticMessage.SetWindowText(ids(IDS_NOTHINGSELECTED));
		}
		else
		{
			wsprintf(szMsg, "%s (%08X)", ids(idsInvalid), dwObject);
			m_StaticMessage.SetWindowText(szMsg);
		}
		m_StaticMessage.ShowWindow(SW_SHOW);
		fEnableRefresh = FALSE;
	}

	m_btnRefresh.EnableWindow(fEnableRefresh);

	if (m_fObjectTypeChanged)
	{
		SetWindowText(m_strCaption);
		m_fObjectTypeChanged = FALSE;
	}

	//
	// Force the properties window to be shown.  This is needed
	// the first time that it is created, because we create it
	// invisible to avoid some flashing of the fields as they
	// are updated.
	//
	ShowWindow(SW_SHOW);
}

void CPropertyInspector::CreateButtons()
{
	CTabbedDialog::CreateButtons();

	CString str;
	CRect rcEmpty;
	rcEmpty.SetRectEmpty();

	str.LoadString(IDS_REFRESH);
	m_btnRefresh.Create(str, WS_CHILD | WS_VISIBLE, rcEmpty, this, IDC_REFRESH);

	//
	// Calculate the height of the std bold font.
	//
	TEXTMETRIC tm;
	CDC dc;
	CFont* pFont = GetStdFont(font_NormalBold);
	CFont* pFontOld;
	dc.Attach(::GetDC(NULL));
	pFontOld = dc.SelectObject(pFont);
	dc.GetTextMetrics(&tm);
	dc.SelectObject(pFontOld);
	dc.Detach();

	//
	// Calculate the area where the tabs go.
	//
	CRect rectPage;
	CRect margins;
	GetClientRect(rectPage);
	GetMargins(margins);

	rectPage.left += margins.left;
	rectPage.right -= margins.right;
	rectPage.bottom -= margins.bottom;
	rectPage.InflateRect(-6, -6);

	//
	// Adjust the top down so that the static control will be centered
	// vertically.
	//
	rectPage.top += (rectPage.Height() - tm.tmHeight) / 2;

	//
	// Create a horizontally centering text control.
	// It is not initially visible.
	//
	m_StaticMessage.Create(NULL, WS_CHILD | SS_CENTER, rectPage, this);
	m_StaticMessage.SetFont(pFont);
}

CButton* CPropertyInspector::GetButtonFromIndex(int index)
{
	//
	// This determines the order that the buttons are shown
	// left to right in the dialog.
	//
	switch (index)
	{
		case 0:
			return &m_btnOk;			// The Close button, actually...

		case 1:
			return &m_btnRefresh;	   // Our Refresh button.

		case 2:
			return &m_btnHelp;		  // Help button is always last.

		default:
			return NULL;
	}
}

BEGIN_MESSAGE_MAP(CPropertyInspector, CTabbedDialog)
	//{{AFX_MSG_MAP(CPropertyInspector)
	ON_COMMAND(IDC_REFRESH, OnRefresh)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

int CPropertyInspector::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CTabbedDialog::OnCreate(lpCreateStruct) == -1)
		return -1;

	//
	// Post a message that causes a refresh to be done.  This
	// has to be done in this fashion so that the window can
	// get all of the other messages (specifically WM_SIZE)
	// that it needs to get before we try and access the
	// data and refresh the current tab.  The problem was this:
	// We create the property inspector, then set the type of
	// object.  This causes the different tabs to be added.
	// Then we call DoModal on it, which causes the main window
	// and the first tab to get created.  But suppose that the
	// object we set is invalid?  What would happen is that
	// the OnRefresh handler clears all the tabs and shows
	// the "Invalid xxx" message in the middle, then the code
	// continued and when the OnSize handler in CTabbedDialog
	// got called, it tried to get the size of the current
	// tab so that it can size the dialog, but we just cleared
	// all tabs and everything crashes.
	//
	// By posting the refresh, we avoid clearing the tabs until
	// after the inspector has gotten WM_SIZE.  To avoid flashing,
	// however, we make the inspector invisible and only show
	// it after the refresh has been done.
	//
	PostMessage(WM_COMMAND, IDC_REFRESH);

	return 0;
}

BOOL CPropertyInspector::PreCreateWindow(CREATESTRUCT& cs)
{
	//
	// Turn off the WS_VISIBLE style for the property inspector.
	// This avoids a flash when it initially comes up, because
	// of the roundabout way that we have to cause the fields
	// to be refreshed.
	//
	cs.style &= ~WS_VISIBLE;

	return CTabbedDialog::PreCreateWindow(cs);
}

void CPropertyInspector::ChangeObject(DWORD dwObject, int nObjectType)
{
	if (m_dwObject == dwObject && m_nObjectType == nObjectType)
	{
		//
		// Nothing changed...
		//
		return;
	}

	if (m_nTabCur != -1)
	{
		CString strCaption = m_tabRow.GetTabString(m_nTabCur);
		m_DialogMap.RememberTab(nCaptionID, strCaption);
	}

	BOOL fNew = SetObject(dwObject, nObjectType);

	CString strTabCaption;
	int iInitialTab = 0;
	if (m_DialogMap.LookupTab(nCaptionID, strTabCaption))
	{
		for (int i = 0; i <= m_tabRow.MaxTab(); i++)
		{
			if (m_tabRow.GetTabString(i) == strTabCaption)
			{
				iInitialTab = i;
				break;
			}
		}
	}

	SelectTab(iInitialTab);
	// use fNew here to know whether to refresh m_ProcessDatabase...
	OnRefresh();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\resource.h ===
// Microsoft Visual C++ generated include file.
// Used by spyxx.rc
//
#define IDR_MAINFRAME                   2
#define IDR_MSGTYPE                     3
#define IDR_PRCTREETYPE                 4
#define IDR_THDTREETYPE                 5
#define IDR_WNDTREETYPE                 6
#define IDI_FINDTOOL                    8
#define IDI_FINDTOOL2                   9
#define IDC_FINDTOOL                    10
#define IDB_FOLDERS                     11
#define IDB_EXPNODES                    12
#define IDR_VERSION1                    13
#define IDC_JUMPHAND                    14
#define IDB_SCROLL                      16
#define IDB_SCROLL_L                    17
#define IDB_SCROLL_R                    18
#define IDB_SCROLL_LD                   19
#define IDB_SCROLL_RD                   20
#define IDB_TREECTL                     24
#define IDD_FINDWINDOW                  24
#define IDB_LARGEABOUT                  25
#define IDI_SPYXX2                      26
#define IDD_SEARCH_FINDWINDOW           26
#define IDD_SEARCH_FINDPROCESS          27
#define IDD_SEARCH_FINDTHREAD           28
#define IDD_SEARCH_FINDMESSAGE          29
#define IDS_GENERALTAB                  51
#define IDS_MEMORYTAB                   52
#define IDS_PAGEFILETAB                 53
#define IDS_SPACETAB                    54
#define IDS_STYLESTAB                   55
#define IDS_WINDOWSTAB                  56
#define IDS_CLASSTAB                    57
#define IDS_PROCESSTAB                  58
#define IDS_WINDOWPROPERTIES            59
#define IDS_THREADPROPERTIES            60
#define IDS_PROCESSPROPERTIES           61
#define IDS_MESSAGESTREAMFILTERS        62
#define IDS_MESSAGESTAB                 63
#define IDS_OUTPUTTAB                   64
#define IDS_MESSAGEPROPERTIES           65
#define IDS_ERROR_HELP_NOFILE           66
#define IDS_HELP_DEFAULTDIR             67
#define IDS_PROPERTIES                  68
#define IDS_HELPON                      69
#define IDS_MESSAGESMENU                70
#define IDS_MESSAGE                     71
#define IDS_TABDLG_OK                   72
#define IDS_TABDLG_CANCEL               73
#define IDS_TABDLG_CLOSE                74
#define IDS_TABDLG_HELP                 75
#define IDS_MSG_INVALIDMAXLINES         76
#define IDS_REFRESH                     77
#define IDS_SEARCHCAPTION               78
#define IDS_SEARCHWINDOWTAB             79
#define IDS_SEARCHPROCESSTAB            80
#define IDS_SEARCHTHREADTAB             81
#define IDS_SEARCHMESSAGETAB            82
#define IDS_SEARCHOBJECTTAB             83
#define IDS_HIGHLIGHTWINDOW             84
#define IDS_FILEIOTAB                   85
#define IDS_MSG_NOLOGFILE               86
#define IDS_MSG_INVALIDLOGFILE          87
#define IDS_NO_NEXT_MATCH_WND           88
#define IDS_NO_PREV_MATCH_WND           89
#define IDS_NO_NEXT_MATCH_PRC           90
#define IDS_NO_PREV_MATCH_PRC           91
#define IDS_NO_NEXT_MATCH_THD           92
#define IDS_NO_PREV_MATCH_THD           93
#define IDS_NO_NEXT_MATCH_MSG           94
#define IDS_NO_PREV_MATCH_MSG           95
#define IDS_NO_VALID_WND_SRCH           96
#define IDS_NO_VALID_PRC_SRCH           97
#define IDS_NO_VALID_THD_SRCH           98
#define IDS_NO_VALID_MSG_SRCH           99
#define IDS_NO_MATCHING_WND             100
#define IDS_NO_MATCHING_PRC             101
#define IDS_NO_MATCHING_THD             102
#define IDS_NO_MATCHING_MSG             103
#define IDS_CANNOTLOGTOFILE             104
#define IDS_CANNOTLOGTOFILE2            105
#define IDS_FW_INVALIDHWND              106
#define IDS_WND_NOT_SPYABLE             107
#define IDS_PRC_NOT_SPYABLE             108
#define IDS_THD_NOT_SPYABLE             109
#define IDS_PT_NOT_AVAILABLE            110
#define IDS_OS_IS_WIN32S                111
#define IDD_ABOUT                       150
#define IDC_ABOUT_ICON                  151
#define IDC_ABOUT_LICENSECOMPANY        152
#define IDC_ABOUT_LICENSENAME           153
#define IDC_ABOUT_VERSION               154
#define IDC_ABOUT_MSDEV                 155
#define IDD_WINDOWGENERALTAB            200
#define IDC_WGT_WINDOWHANDLE            201
#define IDC_WGT_TEXT                    202
#define IDC_WGT_RECTANGLE               203
#define IDC_WGT_RESTOREDRECT            204
#define IDC_WGT_CLIENTRECT              205
#define IDC_WGT_MENUHANDLE              206
#define IDC_WGT_EXTRABYTES              207
#define IDC_WGT_USERDATA                208
#define IDC_WGT_MENUHANDLELABEL         209
#define IDD_WINDOWCLASSTAB              300
#define IDC_WCT_BACKGROUNDBRUSH         301
#define IDC_WCT_CLASSATOM               302
#define IDC_WCT_CLASSEXTRABYTES         303
#define IDC_WCT_CLASSEXTRABYTESCOMBO    304
#define IDC_WCT_CLASSNAME               305
#define IDC_WCT_CURSORHANDLE            306
#define IDC_WCT_ICONHANDLE              307
#define IDC_WCT_INSTANCEHANDLE          308
#define IDC_WCT_MENUNAME                309
#define IDC_WCT_STYLES                  310
#define IDC_WCT_STYLESCOMBO             311
#define IDC_WCT_WINDOWEXTRABYTES        312
#define IDC_WCT_WINDOWPROC              313
#define IDD_WINDOWSTYLESTAB             400
#define IDC_WST_STYLES                  401
#define IDC_WST_STYLESLIST              402
#define IDC_WST_EXTSTYLES               403
#define IDC_WST_EXTSTYLESLIST           404
#define IDD_WINDOWWINDOWSTAB            500
#define IDC_WWT_FIRSTCHILD              501
#define IDC_WWT_NEXTWINDOW              502
#define IDC_WWT_OWNERWINDOW             503
#define IDC_WWT_PARENTWINDOW            504
#define IDC_WWT_PREVWINDOW              505
#define IDD_WINDOWPROCESSTAB            600
#define IDC_WPT_INSTANCEHANDLE          601
#define IDC_WPT_PROCESSID               602
#define IDC_WPT_THREADID                603
#define IDC_WPT_WINDOWPROC              604
#define IDD_PROCESSGENERALTAB           700
#define IDC_PGT_BASEPRIORITY            701
#define IDC_PGT_ELAPSEDTIMELABEL        702
#define IDC_PGT_ELAPSEDTIME             703
#define IDC_PGT_EXECUTABLE              704
#define IDC_PGT_PRIVILEGEDTIMELABEL     705
#define IDC_PGT_PRIVILEGEDTIME          706
#define IDC_PGT_PROCESSID               707
#define IDC_PGT_USERTIMELABEL           708
#define IDC_PGT_USERTIME                709
#define IDC_PGT_CPUTIMELABEL            710
#define IDC_PGT_CPUTIME                 711
#define IDC_PGT_NUMTHREADS              712
#define IDD_PROCESSGENERALTAB_NT        799
#define IDD_PROCESSMEMORYTAB            800
#define IDC_PMT_NONPAGEDPOOL            801
#define IDC_PMT_PAGEDPOOL               802
#define IDC_PMT_PEAKVIRTUAL             805
#define IDC_PMT_PEAKWORKINGSET          806
#define IDC_PMT_PRIVATEBYTES            807
#define IDC_PMT_VIRTUAL                 808
#define IDC_PMT_WORKINGSET              809
#define IDC_PMT_FREEBYTES               810
#define IDC_PMT_RESERVEDBYTES           811
#define IDC_PMT_FREEIMAGEBYTES          812
#define IDC_PMT_RESERVEDIMAGEBYTES      813
#define IDD_PROCESSFILEIOTAB            850
#define IDC_PFT_CONTROLBYTES            851
#define IDC_PFT_CONTROLOPS              852
#define IDC_PFT_READBYTES               853
#define IDC_PFT_READOPS                 854
#define IDC_PFT_WRITEBYTES              855
#define IDC_PFT_WRITEOPS                856
#define IDD_PROCESSPAGEFILETAB          900
#define IDC_PPT_PAGEFAULTS              901
#define IDC_PPT_PAGEFILE                902
#define IDC_PPT_PEAKPAGEFILE            903
#define IDD_PROCESSSPACETAB             950
#define IDC_PST_BYTES_EXEC              951
#define IDC_PST_BYTES_EXECRO            952
#define IDC_PST_BYTES_EXECRW            953
#define IDC_PST_BYTES_EXECWC            954
#define IDC_PST_BYTES_NA                955
#define IDC_PST_BYTES_RO                956
#define IDC_PST_BYTES_RW                957
#define IDC_PST_BYTES_WC                958
#define IDC_PST_SELECTSPACETYPE         959
#define IDD_THREADGENERALTAB            1000
#define IDC_TGT_BASEPRIORITY            1001
#define IDC_TGT_CONTEXTSWITCHESLABEL    1003
#define IDC_TGT_CONTEXTSWITCHES         1004
#define IDC_TGT_CURRENTPRIORITY         1005
#define IDC_TGT_ELAPSEDTIMELABEL        1006
#define IDC_TGT_ELAPSEDTIME             1007
#define IDC_TGT_EXECUTABLE              1008
#define IDC_TGT_PRIVILEGEDTIMELABEL     1009
#define IDC_TGT_PRIVILEGEDTIME          1010
#define IDC_TGT_PROCESSID               1011
#define IDC_TGT_STARTADDRESSLABEL       1012
#define IDC_TGT_STARTADDRESS            1013
#define IDC_TGT_THREADID                1014
#define IDC_TGT_THREADSTATELABEL        1015
#define IDC_TGT_THREADSTATE             1016
#define IDC_TGT_USERPCLABEL             1017
#define IDC_TGT_USERPC                  1018
#define IDC_TGT_USERTIMELABEL           1019
#define IDC_TGT_USERTIME                1020
#define IDC_TGT_WAITREASONLABEL         1021
#define IDC_TGT_WAITREASON              1022
#define IDC_TGT_CPUTIMELABEL            1023
#define IDC_TGT_CPUTIME                 1024
#define IDD_THREADGENERALTAB_NT         1099
#define IDD_MESSAGEGENERALTAB           1100
#define IDC_MGT_HWND                    1101
#define IDC_MGT_LRESULT                 1102
#define IDC_MGT_MESSAGE1                1104
#define IDC_MGT_MESSAGE2                1105
#define IDC_MGT_NESTLEVEL               1106
#define IDC_MGT_MSGHELP                 1107
#define IDC_MGT_LIST                    1108
#define IDC_MGT_LRESULTLABEL            1109
#define IDD_FILTERSMESSAGETAB           1200
#define IDC_FMT_ALL                     1201
#define IDC_FMT_BM                      1202
#define IDC_FMT_CB                      1203
#define IDC_FMT_CLIP                    1204
#define IDC_FMT_DDE                     1205
#define IDC_FMT_EM                      1206
#define IDC_FMT_KEYBD                   1207
#define IDC_FMT_LB                      1208
#define IDC_FMT_LIST                    1209
#define IDC_FMT_MDI                     1210
#define IDC_FMT_MOUSE                   1211
#define IDC_FMT_NC                      1212
#define IDC_FMT_NONE                    1213
#define IDC_FMT_REGISTERED              1214
#define IDC_FMT_SAVE                    1215
#define IDC_FMT_SBM                     1216
#define IDC_FMT_STM                     1217
#define IDC_FMT_UNDOCUMENTED            1218
#define IDC_FMT_USER                    1219
#define IDC_FMT_IME                     1220
#define IDC_FMT_DLG                     1221
#define IDD_FILTERSOUTPUTTAB            1300
#define IDC_FOT_DECODEPARM              1301
#define IDC_FOT_DECODERET               1302
#define IDC_FOT_LINES                   1303
#define IDC_FOT_NESTLEVEL               1304
#define IDC_FOT_RAWPARM                 1305
#define IDC_FOT_RAWRET                  1306
#define IDC_FOT_SAVE                    1307
#define IDC_FOT_SHOWTIME                1308
#define IDC_FOT_SHOWPOINT               1309
#define IDC_FOT_LOGTOFILE               1310
#define IDC_FOT_LOGFILENAME             1311
#define IDD_FILTERSWINDOWTAB            1400
#define IDC_FWT_ALLWINDOWS              1401
#define IDC_FWT_CHILDREN                1402
#define IDC_FWT_FINDTOOL                1403
#define IDC_FWT_HIDE                    1404
#define IDC_FWT_PARENT                  1405
#define IDC_FWT_SAMEPROCESS             1406
#define IDC_FWT_SAMETHREAD              1407
#define IDC_FWT_SAVE                    1408
#define IDC_FWT_SOBCLASS                1409
#define IDC_FWT_SOBCLASSLABEL           1410
#define IDC_FWT_SOBNOSELECTIONLABEL     1411
#define IDC_FWT_SOBHANDLE               1412
#define IDC_FWT_SOBHANDLELABEL          1413
#define IDC_FWT_SOBPROCESS              1414
#define IDC_FWT_SOBPROCESSLABEL         1415
#define IDC_FWT_SOBRECT                 1416
#define IDC_FWT_SOBRECTLABEL            1417
#define IDC_FWT_SOBSTYLE                1418
#define IDC_FWT_SOBSTYLELABEL           1419
#define IDC_FWT_SOBTEXT                 1420
#define IDC_FWT_SOBTEXTLABEL            1421
#define IDC_FWT_SOBTHREAD               1422
#define IDC_FWT_SOBTHREADLABEL          1423
#define IDD_FONT                        1500
#define IDC_FONT_SAVE                   1501
#define IDD_NOHELPFILE                  1600
#define IDC_HELPPATH1                   1601
#define IDD_SEARCHMESSAGETAB            1601
#define IDC_HELPPATH2                   1602
#define IDD_SEARCHPROCESSTAB            1602
#define IDC_ERRORTEXT                   1603
#define IDD_SEARCHTHREADTAB             1603
#define IDC_INFO_ICON                   1604
#define IDD_SEARCHWINDOWTAB             1604
#define IDD_SEARCHOBJECTTAB             1605
#define IDC_FW_FINDTOOL                 1608
#define IDC_FW_HIDESPY                  1609
#define IDC_FW_CAPTIONLABEL             1611
#define IDC_FW_CLASSLABEL               1612
#define IDC_FW_STYLELABEL               1613
#define IDC_FW_RECTLABEL                1614
#define IDC_FW_SHOWPROPERTIES           1615
#define IDC_FW_SHOWMESSAGES             1616
#define IDC_FW_ENTERHWND                1617
#define IDC_FW_CAPTION                  1619
#define IDC_FW_CLASS                    1620
#define IDC_FW_STYLE                    1621
#define IDC_FW_RECT                     1622
#define IDC_SEARCH_FW_ENTERCAPTION      1623
#define IDC_SEARCH_FW_ENTERCLASS        1624
#define IDC_SEARCH_FW_ENTERHWND         1625
#define IDC_SEARCH_FW_FINDTOOL          1626
#define IDC_SEARCH_FW_HIDESPY           1627
#define IDC_SEARCH_FW_UPDIRECTION       1628
#define IDC_SEARCH_FW_DOWNDIRECTION     1629
#define IDC_SEARCH_FP_ENTERPROCESS      1632
#define IDC_SEARCH_FP_ENTERMODULE       1633
#define IDC_SEARCH_FP_UPDIRECTION       1634
#define IDC_SEARCH_FP_DOWNDIRECTION     1635
#define IDC_SEARCH_FT_ENTERTHREAD       1636
#define IDC_SEARCH_FT_ENTERMODULE       1637
#define IDC_SEARCH_FT_UPDIRECTION       1638
#define IDC_SEARCH_FT_DOWNDIRECTION     1639
#define IDC_SEARCH_FM_ENTERHWND         1640
#define IDC_SEARCH_FM_FINDTOOL          1641
#define IDC_SEARCH_FM_HIDESPY           1642
#define IDC_SEARCH_FM_SELECTMSG         1643
#define IDC_SEARCH_FM_SELECTTYPE        1644
#define IDC_SEARCH_FM_UPDIRECTION       1645
#define IDC_SEARCH_FM_DOWNDIRECTION     1646
#define IDC_SEARCH_OBJECT_WINDOW        1647
#define IDC_SEARCH_OBJECT_PROCESS       1648
#define IDC_SEARCH_OBJECT_THREAD        1649
#define IDC_SEARCH_OBJECT_MESSAGE       1650
#define IDC_FMT_ANI                     1651
#define IDC_FMT_BL                      1652
#define IDC_FMT_HDR                     1653
#define IDC_FMT_TB                      1654
#define IDC_FMT_TT                      1655
#define IDC_FMT_STAT                    1656
#define IDC_FMT_TRK                     1657
#define IDC_FMT_UD                      1658
#define IDC_FMT_PROG                    1659
#define IDC_FMT_HK                      1660
#define IDC_FMT_LV                      1661
#define IDC_FMT_TV                      1662
#define IDC_FMT_TAB                     1663
#define IDC_FOT_LOGFILEAPPEND           1664
#define IDC_FOT_LOGFILEOVERWRITE        1665
#define ID_VIEW_PROPERTIES              5003
#define ID_VIEW_HELPONMESSAGE           5006
#define ID_WINDOW_REFRESH               5008
#define IDC_REFRESH                     5009
#define ID_SPY_MESSAGES                 5009
#define ID_SPY_WINDOWS                  5010
#define ID_SPY_PROCESSES                5011
#define ID_SPY_THREADS                  5012
#define ID_VIEW_FONT                    5013
#define ID_MESSAGES_STARTSTOP           5014
#define ID_MESSAGES_CLEAR               5016
#define ID_MESSAGES_OPTIONS             5017
#define ID_SPY_MESSAGESDIRECT           5018
#define ID_TREE_EXPAND_ONE_LEVEL        5019
#define ID_TREE_EXPAND_BRANCH           5020
#define ID_TREE_EXPAND_ALL              5021
#define ID_TREE_COLLAPSE                5022
#define ID_SPY_FINDWINDOW               5023
#define ID_SEARCH_FIND                  5024
#define ID_SEARCH_FINDNEXT              5025
#define ID_SEARCH_FINDPREV              5026
#define ID_SPY_HIGHLIGHTWINDOW          5027
#define IDS_CONTINUECREATION            10000
#define IDS_DONTCONTINUECREATION        10001
#define IDS_INVALIDWINDOW               10002
#define IDS_INVALIDPROCESS              10003
#define IDS_INVALIDTHREAD               10004
#define IDS_STARTLOGGINGMENU            10005
#define IDS_STOPLOGGINGMENU             10006
#define IDS_NOTHINGSELECTED             10007
#define IDS_PROPERTYINSPECTOR           10008
#define IDS_CONTROLID                   10009
#define IDS_MENUHANDLE                  10010
#define IDS_USE_DEFAULT_CURSOR          10011
#define IDS_END_FROM_TASK_LIST          10012
#define IDS_LOGOFF_OR_SHUTDOWN          10013
#define IDS_USE_DEFAULT_FONT            10014
#define IDS_SHOWWINDOW_CALLED           10015
#define IDS_TRUE                        10016
#define IDS_FALSE                       10017
#define IDS_POINTER_TO                  10018
#define IDS_FROM_THE_BEGINNING          10019
#define IDS_THE_SELECTION_FIELD         10020
#define IDS_END_OF_THE_LIST             10021
#define IDS_NO_SELECTION                10022
#define IDS_SUCCESSFULLY_REMOVED_SELECT 10023
#define IDS_REMOVE_THE_SELECTION        10024
#define IDS_THE_LAST_CHARACTER          10025
#define IDS_SUCCESS                     10026
#define IDS_NO_PASSWORD_CHARACTER       10027
#define IDS_CURRENT_LINE                10028
#define IDS_LINE_IS_OUT_OF_RANGE        10029
#define IDS_NONE                        10030
#define IDS_SELECT_ALL_TEXT             10031
#define IDS_SET_TABS_TO_DEFAULT         10032
#define IDS_HANDLED_BY_APPLICATION      10033
#define IDS_PERFORM_DEFAULT_ACTION      10034
#define IDS_SELECT_ITEM_AT_INDEX        10035
#define IDS_OPEN_PAREN                  10036
#define IDS_CLOSE_PAREN                 10037
#define IDS_SUCCESSFUL_HOTKEY1          10038
#define IDS_SUCCESSFUL_HOTKEY2          10039
#define IDS_UNSUCCESSFUL_HOTKEY1        10040
#define IDS_UNSUCCESSFUL_HOTKEY2        10041
#define IDS_UNSELECT_THE_RANGE          10042
#define IDS_ALL_ITEMS                   10043
#define IDS_ACTIVATING                  10044
#define IDS_UNCHECKED                   10045
#define IDS_CHECKED                     10046
#define IDS_INDETERMINATE               10047
#define IDS_POINT_ABBREV                10048
#define IDS_MESSAGES_ALL_WINDOWS        10049
#define IDS_MESSAGES_WINDOW             10050
#define IDS_MESSAGES_THREAD             10051
#define IDS_MESSAGES_PROCESS            10052
#define IDS_MESSAGES_NOTHING_SELECTED   10053
#define IDS_UNDOCUMENTED                10054
#define IDS_REGISTERED                  10055
#define IDS_UNAVAILABLE                 10056
#define IDS_SYSTEM_PROCESS              10057
#define IDS_MINIMIZED                   10058
#define IDS_MAXIMIZED                   10059
#define IDS_UNICODE                     10060
#define IDS_SUBCLASSED                  10061
#define IDS_POPUPMENU                   10062
#define IDS_DESKTOP                     10063
#define IDS_DIALOG                      10064
#define IDS_WINSWITCH                   10065
#define IDS_ICONTITLE                   10066
#define IDS_SENT                        10067
#define IDS_POSTED                      10068
#define IDS_RETURN                      10069
#define IDS_SENT_RETURN_UNAVAIL         10070
#define IDS_WINDOWLABEL                 10071
#define IDS_TEXTLABEL                   10072
#define IDS_CLASSLABEL                  10073
#define IDS_THREADIDLABEL               10074
#define IDS_PROCESSIDLABEL              10075
#define IDS_EXECUTABLELABEL             10076
#define IDS_INVALID                     10077
#define IDS_SENT_FROM_A_MENU            10078
#define IDS_SENT_FROM_AN_ACCEL          10079
#define IDS_1_PRECEDES_2                10080
#define IDS_1_MATCHES_2                 10081
#define IDS_1_FOLLOWS_2                 10082
#define IDS_SYSTEM_FONT                 10083
#define IDS_DISCARD_CHAR_AND_BEEP       10084
#define IDS_CLOSE_ACTIVE_MENU           10085
#define IDS_SELECT_MENU_ITEM            10086
#define IDS_MENU_WAS_CLOSED             10087
#define IDS_HANDLE_CONTROL_FOCUS        10088
#define IDS_PREV_RECEIVES_FOCUS         10089
#define IDS_NEXT_RECEIVES_FOCUS         10090
#define IDS_REGISTERED_PARAM            10091
#define IDS_INVALID_PARAM               10092
#define IDS_CLASS                       10093
#define IDS_PROCESS_PARAM               10094
#define IDS_THREAD_PARAM                10095
#define IDS_WINDOW_PARAM                10096
#define IDS_NONE_NOSPACE                10097
#define IDS_NAVIGATION_TO_INVALID       10098
#define IDS_NAVIGATION_FROM_INVALID     10099
#define IDS_NULL                        10100
#define IDS_POINTER_TO_STRING           10101
#define IDS_THDP_INITIALIZED            10102
#define IDS_THDP_READY                  10103
#define IDS_THDP_RUNNING                10104
#define IDS_THDP_STANDBY                10105
#define IDS_THDP_TERMINATED             10106
#define IDS_THDP_WAIT                   10107
#define IDS_THDP_TRANSITION             10108
#define IDS_THDP_UNKNOWN                10109
#define IDS_THDP_EXECUTIVE              10110
#define IDS_THDP_FREE_PAGE              10111
#define IDS_THDP_PAGE_IN                10112
#define IDS_THDP_POOL_ALLOCATION        10113
#define IDS_THDP_EXECUTION_DELAY        10114
#define IDS_THDP_SUSPENDED              10115
#define IDS_THDP_USER_REQUEST           10116
#define IDS_THDP_EVENT_PAIR_HIGH        10117
#define IDS_THDP_EVENT_PAIR_LOW         10118
#define IDS_THDP_LPC_RECEIVE            10119
#define IDS_THDP_LPC_REPLY              10120
#define IDS_THDP_VIRTUAL_MEMORY         10121
#define IDS_THDP_PAGE_OUT               10122
#define IDS_MENU_FINDMESSAGE            10123
#define IDS_MENU_FINDWINDOW             10124
#define IDS_MENU_FINDPROCESS            10125
#define IDS_MENU_FINDTHREAD             10126
#define IDS_IMAGE                       10127
#define IDS_MAPPED                      10128
#define IDS_RESERVED                    10129
#define IDS_UNASSIGNED                  10130
#define IDS_POSTTYPE_POSTED             10131
#define IDS_POSTTYPE_SENT               10132
#define IDS_POSTTYPE_SENTNORETURN       10133
#define IDS_POSTTYPE_RETURN             10134
#define IDS_USERDEFINED                 10135

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        27
#define _APS_NEXT_COMMAND_VALUE         5024
#define _APS_NEXT_CONTROL_VALUE         1666
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\proptab.h ===
// proptab.h : header file
//


class CPropertyTab : public CDlgTab
{
// Construction
public:
	CPropertyTab(UINT nIDTemplate, UINT nIDCaption)
		: CDlgTab(nIDTemplate, nIDCaption)
	{
		SetRefreshFlag(TRUE);
	}

// Implementation
public:
	virtual ~CPropertyTab();
	virtual BOOL Activate(CTabbedDialog* pParentWnd, CPoint position);
	virtual void UpdateFields() {};

	void SetRefreshFlag(BOOL fRefreshData)
	{
		m_fRefreshData = fRefreshData;
	}
	BOOL GetRefreshFlag()
	{
		return m_fRefreshData;
	}

protected:
	virtual PINT GetControlIDTable()
	{
		return NULL;
	}

protected:
	BOOL m_fRefreshData;

	// Generated message map functions
protected:
	//{{AFX_MSG(CPropertyTab)
	virtual BOOL OnInitDialog();
	afx_msg LRESULT OnHotLink(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\sbmsgs.cpp ===
//-----------------------------------------------------------------------------
//  SBMsgs.cpp
//
//  Scroll Bar message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

static VALUETABLE tblESBFlags[] =
{
	TABLEENTRY(ESB_ENABLE_BOTH),
	TABLEENTRY(ESB_DISABLE_LTUP),
	TABLEENTRY(ESB_DISABLE_RTDN),
	TABLEENTRY(ESB_DISABLE_BOTH),
	TABLEEND
};

//////////////////////////////////////////////////////////////////////////////

DECODE(SBM_ENABLE_ARROWS)
{
	PARM(fuArrowFlags, UINT, WP);

	TABLEORVALUE(tblESBFlags, fuArrowFlags);

	return TRUE;
}

DECODERET(SBM_ENABLE_ARROWS)
{
	PARM(fSuccess, BOOL, RET);

	POUTB(fSuccess);

	return TRUE;
}

NODECODEPARM(SBM_ENABLE_ARROWS);

//////////////////////////////////////////////////////////////////////////////
/*
// TODO: do some cracking here!
NODECODE(SBM_GETPAGE);

NODECODERET(SBM_GETPAGE);

NODECODEPARM(SBM_GETPAGE);
*/
//////////////////////////////////////////////////////////////////////////////

NODECODE(SBM_GETPOS);

DECODERET(SBM_GETPOS)
{
	PARM(nPos, INT, RET);

	POUT(nPos);

	return TRUE;
}

NODECODEPARM(SBM_GETPOS);

//////////////////////////////////////////////////////////////////////////////

DECODE(SBM_GETRANGE)
{
	PARM(lpnMinPos, LPINT, WP);
	PARM(lpnMaxPos, LPINT, LP);

	POUTC(lpnMinPos, DWORD);
	POUTC(lpnMaxPos, DWORD);

	return TRUE;
}

DECODERET(SBM_GETRANGE)
{
	PARM(lpnMinPos, LPINT, WP);
	PARM(lpnMaxPos, LPINT, LP);

	PIFSIZEOF(PACK_WPLPDWORDS)
	{
		PARM(ppwld, PPACK_WPLPDWORDS, ED);

		POUTC(lpnMinPos, DWORD);
		if (ppwld->fValidWP)
		{
			MOUT << " (" << (INT)ppwld->nWP << ')';
		}

		POUTC(lpnMaxPos, DWORD);
		if (ppwld->fValidLP)
		{
			MOUT << " (" << (INT)ppwld->nLP << ')';
		}
	}
	else
	{
		POUTC(lpnMinPos, DWORD);
		POUTC(lpnMaxPos, DWORD);
	}

	return TRUE;
}

DECODEPARM(SBM_GETRANGE)
{
	P2IFSIZEOF(PACK_WPLPDWORDS)
	{
		PARM(ppwld, PPACK_WPLPDWORDS, ED2);

		if (ppwld->fValidWP)
		{
			P2WPOUTPTR(int);
			INDENT();
			M2OUT << (INT)ppwld->nWP;
			P2ENDLINE();
			OUTDENT();
		}
		else
		{
			P2WPOUT();
		}

		if (ppwld->fValidLP)
		{
			P2LPOUTPTR(int);
			INDENT();
			M2OUT << (INT)ppwld->nLP;
			P2ENDLINE();
			OUTDENT();
		}
		else
		{
			P2WPOUT();
		}
	}
	else
	{
		P2WPOUT();
		P2LPOUT();
	}
}

//////////////////////////////////////////////////////////////////////////////
/*
// TODO: do some cracking here!
NODECODE(SBM_SETPAGE);

NODECODERET(SBM_SETPAGE);

NODECODEPARM(SBM_SETPAGE);
*/
//////////////////////////////////////////////////////////////////////////////

DECODE(SBM_SETPOS)
{
	PARM(nPos, INT, WP);
	PARM(fRedraw, BOOL, LP);

	POUT(nPos);
	POUTB(fRedraw);

	return TRUE;
}

DECODERET(SBM_SETPOS)
{
	PARM(nPosPrevious, INT, RET);

	POUT(nPosPrevious);

	return TRUE;
}

NODECODEPARM(SBM_SETPOS);

//////////////////////////////////////////////////////////////////////////////

DECODE(SBM_SETRANGE)
{
	PARM(nMinPos, INT, WP);
	PARM(nMaxPos, INT, LP);

	POUT(nMinPos);
	POUT(nMaxPos);

	return TRUE;
}

DECODERET(SBM_SETRANGE)
{
	DECODERETLIKE(SBM_SETPOS);
}

NODECODEPARM(SBM_SETRANGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(SBM_SETRANGEREDRAW)
{
	DECODELIKE(SBM_SETRANGE);
}

DECODERET(SBM_SETRANGEREDRAW)
{
	DECODERETLIKE(SBM_SETPOS);
}

NODECODEPARM(SBM_SETRANGEREDRAW);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\proptab.cpp ===
// proptab.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "proptab.h"
#include "hotlinkc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CPropertyTab

CPropertyTab::~CPropertyTab()
{
}


BEGIN_MESSAGE_MAP(CPropertyTab, CDlgTab)
	//{{AFX_MSG_MAP(CPropertyTab)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_HOTLINK, OnHotLink)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropertyTab message handlers


BOOL CPropertyTab::OnInitDialog()
{
	CDlgTab::OnInitDialog();

	PINT paControlIDs = GetControlIDTable();

	if (paControlIDs)
	{
		CFont* pFont = GetStdFont(font_Normal);
		ASSERT(pFont);
		HFONT hfont = (HFONT)pFont->m_hObject;

		while (*paControlIDs)
		{
			SendDlgItemMessage(*paControlIDs, WM_SETFONT, (WPARAM)hfont, FALSE);
			paControlIDs++;
		}
	}

	//
	// Update the dialogs fields with the current set of data,
	// but only if the object is valid (which means the data
	// has also been properly initialized).
	//
	if (((CPropertyInspector*)GetParent())->GetValidObjectFlag())
	{
		UpdateFields();
		SetRefreshFlag(FALSE);
	}

	return TRUE;  // return TRUE  unless you set the focus to a control
}



BOOL CPropertyTab::Activate(CTabbedDialog* pParentWnd, CPoint position)
{
	//
	// If this tab has already been loaded and the data in it
	// needs to be refreshed, do the updating now before it is
	// activated (which will show it) to prevent the old data
	// briefly showing.  If it has not already been loaded, we
	// don't need to do anything because the load will refresh
	// the data at OnInitDialog time.
	//
	if (m_hWnd != NULL && GetRefreshFlag())
	{
		UpdateFields();
		SetRefreshFlag(FALSE);
	}

	return CDlgTab::Activate(pParentWnd, position);
}


LPARAM CPropertyTab::OnHotLink(WPARAM wParam, LPARAM lParam)
{
	CPropertyInspector* pTabDlg = (CPropertyInspector*)GetParent();

	pTabDlg->ChangeObject((DWORD)wParam, (int)lParam);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\reshk.h ===
// Microsoft Visual C++ generated include file.
// Used by spyxxhk.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\propinsp.h ===
// propinsp.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CPropertyInspector window

class CPropertyInspector : public CTabbedDialog
{
// Construction
public:
	CPropertyInspector(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectTab = -1, COMMIT_MODEL commitModel = commitOnTheFly);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// Implementation
public:
	virtual ~CPropertyInspector();

	void SetValidObjectFlag(BOOL fValidObject)
	{
		m_fValidObject = fValidObject;
	}
	BOOL GetValidObjectFlag()
	{
		return m_fValidObject;
	}

	BOOL SetObject(DWORD dwObject, int nObjectType);
	void ChangeObject(DWORD dwObject, int nObjectType);

	static void InitializeTables();

protected:
	//
	// Modeless support.
	//
	virtual void PostNcDestroy()
	{
		delete this;
	}

	virtual void CreateButtons();
	virtual CButton* GetButtonFromIndex(int index);

	void FillStrListFromTable(CStringList* pStrList, DWORD *flStyle, VALUETABLE *pvt, BOOL fRemoveAll = TRUE,
					BOOL fOneEntry = FALSE, BOOL fPrintExtras = FALSE);
	void AppendStrListFromButtonTable(CStringList* pStrList, DWORD flStyle, VALUETABLE *pvt);
	void AppendStrListFromScrollTable(CStringList* pStrList, DWORD flStyle, VALUETABLE *pvt);
	void AppendStrListFromEditTable(CStringList* pStrList, DWORD flStyle, VALUETABLE *pvt);
	void AppendStrListFromTrackBarTable(CStringList* pStrList, DWORD flStyle, VALUETABLE *pvt);
	void AppendStrListFromListViewTable(CStringList* pStrList, DWORD flStyle, VALUETABLE *pvt);
	void AppendStrListFromTabControlTable(CStringList* pStrList, DWORD flStyle, VALUETABLE *pvt);

	BOOL SetObjectType(int nObjectType);
	BOOL SetWindowObject(HWND hwnd);
	BOOL SetProcessObject(DWORD tid);
	BOOL SetThreadObject(DWORD tid);
	BOOL SetMessageObject(PMSGSTREAMDATA2 pmsd2);
	BOOL SetNoObject();

	void OnRefresh();
	BOOL RefreshWindowObjectData();
	BOOL RefreshProcessObjectData();
	void GetTimesForProcess();
	BOOL RefreshThreadObjectData();
	void GetTimesForThread();
	BOOL RefreshMessageObjectData();

public:
	static void ShowObjectProperties(DWORD dwObject, int nObjectType);

protected:
	static VALUETABLE m_astClass[];
	static VALUETABLE m_astColor[];
	static HANDLESTABLE m_ahtSystemCursors[];
	static HANDLESTABLE m_ahtSystemIcons[];

protected:
	CButton m_btnRefresh;
	CStatic m_StaticMessage;

	int m_nObjectType;
	DWORD m_dwObject;
	BOOL m_fValidObject;
	BOOL m_fObjectTypeChanged;

	//
	// Data variables for when a window is selected:
	//
	HWND m_hwnd;
	CString m_strWindowCaption;
	CString m_strRectangle;
	CString m_strRestoredRect;
	CString m_strClientRect;
	DWORD m_dwID;
	DWORD m_dwUserData;
	CStringList m_strListExtraBytes;

	DWORD m_flStyles;
	DWORD m_flExtStyles;
	CStringList m_strListStyles;
	CStringList m_strListExtStyles;

	HWND m_hwndNext;
	HWND m_hwndPrevious;
	HWND m_hwndParent;
	HWND m_hwndChild;
	HWND m_hwndOwner;

	CString m_strClassName;
	CString m_strClassAtom;
	CString m_strClassStyles;
	CStringList m_strListClassStyles;
	CString m_strClassWndExtraBytes;
	CString m_strClassExtraBytes;
	CStringList m_strListClassExtraBytes;
	CString m_strClassInstance;
	CString m_strClassWndProc;
	CString m_strClassMenuName;
	CString m_strClassIcon;
	CString m_strClassCursor;
	CString m_strClassBrush;

	DWORD m_ProcessID;
	DWORD m_ThreadID;
	BOOL m_fValidProcessThreadID;
	HINSTANCE m_hInstance;
	CString m_strWndProc;

	CString m_strExecutable;
	//
	// Data variables for when a process is selected:
	//
	DWORD m_pid;
	// Win32 process data
	CPROCDB::PRFCNTRPROC m_ProcessInfo;
	CPROCDB::PRFCNTRPROCAS m_ProcessAddrSpcInfo;
	// Chicago process data
	PROCESSENTRY32	m_ProcessEntry;
	FILETIME		m_ftPrcCreationTime;
	FILETIME		m_ftPrcExitTime;
	FILETIME		m_ftPrcKernelTime;
	FILETIME		m_ftPrcUserTime;
	SYSTEMTIME		m_stPrcSnapshotTime;

	//
	// Data variables for when a thread is selected:
	//
	DWORD m_tid;
	// Win32 process data
	CPROCDB::PRFCNTRTHRD m_ThreadInfo;
	CPROCDB::PRFCNTRTHRDDET m_ThreadDetInfo;
	// Chicago thread data
	THREADENTRY32	m_ThreadEntry;
	FILETIME		m_ftThdCreationTime;
	FILETIME		m_ftThdExitTime;
	FILETIME		m_ftThdKernelTime;
	FILETIME		m_ftThdUserTime;
	SYSTEMTIME		m_stThdSnapshotTime;

	//
	// Data variables for when a message is selected:
	//
	MSGSTREAMDATA2 m_msd2;
	CString m_strMessage1;
	CString m_strMessage2;

	// Generated message map functions
protected:
	//{{AFX_MSG(CPropertyInspector)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CPropertyTab;

	friend class CWindowGeneralPropTab;
	friend class CWindowStylesPropTab;
	friend class CWindowWindowsPropTab;
	friend class CWindowClassPropTab;
	friend class CWindowProcessPropTab;

	friend class CProcessGeneralPropTab;
	friend class CProcessMemoryPropTab;
	friend class CProcessPageFilePropTab;
	friend class CProcessFileIOPropTab;
	friend class CProcessSpacePropTab;

	friend class CThreadGeneralPropTab;

	friend class CMessageGeneralPropTab;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\spytreec.cpp ===
// spytreec.c : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "treectl.h"
#include "imgwell.h"
#include "spytreec.h"
#include "imgwell.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


CImageWell CSpyTreeCtl::c_imageSpyWell;

/////////////////////////////////////////////////////////////////////////////
// CSpyTreeCtl

CSpyTreeCtl::CSpyTreeCtl()
{
	if (!c_imageSpyWell.IsOpen())
	{
		VERIFY(c_imageSpyWell.Load(IDB_FOLDERS, CSize(16, 16)));
		VERIFY(c_imageSpyWell.Open());
		VERIFY(c_imageSpyWell.CalculateMask());
	}
}

CSpyTreeCtl::~CSpyTreeCtl()
{
}


BEGIN_MESSAGE_MAP(CSpyTreeCtl, CTreeCtl)
	//{{AFX_MSG_MAP(CSpyTreeCtl)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_LBN_DBLCLK(IDCW_TREELISTBOX, OnLbDblClk)
	ON_LBN_SETFOCUS(IDCW_TREELISTBOX, OnLbSetFocus)
	ON_LBN_KILLFOCUS(IDCW_TREELISTBOX, OnLbKillFocus)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CSpyTreeCtl message handlers


int CSpyTreeCtl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	// load in our glyph bitmaps and inform the tree control of these
	if (!m_bmFolders.LoadBitmap(IDB_FOLDERS))
		return -1;  // failed to create our bitmap

	if (!m_bmExpandNodes.LoadBitmap(IDB_EXPNODES))
	{
		m_bmFolders.DeleteObject(); // failed to create our bitmap
		return -1;
	}

	if (CTreeCtl::OnCreate(lpCreateStruct) == -1)
	{
		m_bmFolders.DeleteObject();
		m_bmExpandNodes.DeleteObject();
		return -1;  // failed to create our tree control
	}

	return 0;
}

void CSpyTreeCtl::OnDestroy()
{
	CTreeCtl::OnDestroy();

	// destroy our glyph bitmaps
	m_bmFolders.DeleteObject();
	m_bmExpandNodes.DeleteObject();
}



BOOL
CSpyTreeCtl::InsertLevel(CNode* pParentNode, int nParentIndex, BOOL bExpandAll)
{
	POSITION pos;
	CSpyTreeNode* pSpyTreeNodeParent;
	CSpyTreeNode* pSpyTreeNodeChild;
	CString str;

	pSpyTreeNodeParent = (CSpyTreeNode*)pParentNode->m_dwData;

	pos = pSpyTreeNodeParent->GetFirstChildPosition();
	while (pos)
	{
		CNode* pNode;
		int iNode;

		pSpyTreeNodeChild = (CSpyTreeNode*)pSpyTreeNodeParent->GetNextChild(pos);
		pSpyTreeNodeChild->GetDescription(str);
		if (!InsertNode(pParentNode, nParentIndex, str, (DWORD)pSpyTreeNodeChild, pNode, iNode))
		{
			TRACE("CSpyTreeCtl::InsertLevel: call to InsertNode failed!\n");
			return FALSE;
		}

		if (bExpandAll && !InsertLevel(pNode, iNode, TRUE))
		{
			return FALSE;
		}
	}

	return TRUE;
}



void CSpyTreeCtl::DrawNodeGlyph(CDC* pDC, CNode* pNode, BOOL /*bHighlight*/, CPoint pt)
{
	CSpyTreeNode* pSpyTreeNode = (CSpyTreeNode*)pNode->m_dwData;
//	m_iwFolders.DrawImage(pDC, pt, pSpyTreeNode->GetBitmapIndex(), 0);
	c_imageSpyWell.DrawImage(pDC, pt, pSpyTreeNode->GetBitmapIndex(), 0);
}



BOOL CSpyTreeCtl::NodeIsExpandable(CNode* pNode)
{
	CSpyTreeNode* pSpyTreeNode;

	if (pNode)
	{
		pSpyTreeNode = (CSpyTreeNode*)pNode->m_dwData;

		return pSpyTreeNode->GetFirstChildPosition() ? TRUE : FALSE;
	}
	return FALSE;
}



//void CSpyTreeCtl::GetNodeTitle(CNode*, CString &)
//{
//	ASSERT(FALSE); //Never should get here if I don't dirty something.
//}



void CSpyTreeCtl::ShowSelItemProperties()
{
	//
	// Get the node for the currently selected item.
	//
	CSpyTreeNode* pSpyTreeNode = (CSpyTreeNode*)GetData();

	if (pSpyTreeNode)
	{
		pSpyTreeNode->ShowProperties();
	}
}



void CSpyTreeCtl::OnLbDblClk()
{
	ShowSelItemProperties();
}



void CSpyTreeCtl::OnLbSetFocus()
{
	//
	// Get the node for the currently selected item.
	//
	CSpyTreeNode* pSpyTreeNode = (CSpyTreeNode*)GetData();

	if (pSpyTreeNode)
	{
		SetLastSelectedObject(pSpyTreeNode->GetObjectHandle(), pSpyTreeNode->GetObjectType());
	}

	CTreeCtl::InvalSelection();
}



void CSpyTreeCtl::OnLbKillFocus()
{
	SetLastSelectedObject(0, OT_NONE);

	CTreeCtl::InvalSelection();
}



void CSpyTreeCtl::OnSelect(int nIndex)
{
	//
	// Get the node for the currently selected item.
	//
	CSpyTreeNode* pSpyTreeNode = (CSpyTreeNode*)GetData();

	if (pSpyTreeNode)
	{
		SetLastSelectedObject(pSpyTreeNode->GetObjectHandle(), pSpyTreeNode->GetObjectType());
	}
}



void CSpyTreeCtl::OnRightButtonDown(UINT nFlags, CPoint pt)
{
	CMDIChildWnd *pParent = (CMDIChildWnd *)(GetParent()->GetParent());
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CMDIChildWnd)));

	((CMDIFrameWnd *)(theApp.m_pMainWnd))->MDIActivate(pParent);
	
	SetActiveWindow();
	SetFocus();

	int index = ItemFromPoint(pt);

	if (index != -1)
	{
		SetCurSel(index);
		OnSelect(index);

		CString str;
		CMenu MenuPopup;
		if (!MenuPopup.CreatePopupMenu())
		{
			return;
		}

		if (GetLastSelectedObjectType() != OT_WINDOW || IsSpyableWindow((HWND)GetLastSelectedObject()))
		{
			str.LoadString(IDS_MESSAGESMENU);
			MenuPopup.AppendMenu(MF_STRING, ID_SPY_MESSAGESDIRECT, str);
		}

		if (GetLastSelectedObjectType() == OT_WINDOW && ::IsWindowVisible((HWND)GetLastSelectedObject()))
		{
			str.LoadString(IDS_HIGHLIGHTWINDOW);
			MenuPopup.AppendMenu(MF_STRING, ID_SPY_HIGHLIGHTWINDOW, str);
		}

		str.LoadString(IDS_PROPERTIES);
		MenuPopup.AppendMenu(MF_STRING, ID_VIEW_PROPERTIES, str);

		ClientToScreen(&pt);
		MenuPopup.TrackPopupMenu(TPM_RIGHTBUTTON, pt.x, pt.y, theApp.m_pMainWnd);
	}
}



/////////////////////////////////////////////////////////////////////////////
// CSpyTreeNode

IMPLEMENT_DYNCREATE(CSpyTreeNode, CObject);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CSpyTreeNode::~CSpyTreeNode()
{
	POSITION pos;
	CSpyTreeNode* pTreeNode;

	pos = GetFirstChildPosition();
	while (pos)
	{
		pTreeNode = GetNextChild(pos);
		delete pTreeNode;
	}
}



//
// CSpyTreeNode static data and functions
//

int CSpyTreeNode::m_cUsage = 0;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\spytreev.cpp ===
// spytreev.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "treectl.h"
#include "spytreec.h"
#include "spytreev.h"
#include "spytreed.h"
#include "fontdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSpyTreeView

IMPLEMENT_DYNCREATE(CSpyTreeView, CView)

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CSpyTreeView::CSpyTreeView()
{
}

CSpyTreeView::~CSpyTreeView()
{
}


BEGIN_MESSAGE_MAP(CSpyTreeView, CView)
	//{{AFX_MSG_MAP(CSpyTreeView)
	ON_WM_SIZE()
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_COMMAND(ID_VIEW_FONT, OnViewFont)
	ON_COMMAND(ID_VIEW_PROPERTIES, OnViewProperties)
	ON_UPDATE_COMMAND_UI(ID_VIEW_PROPERTIES, OnUpdateViewProperties)
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSpyTreeView drawing

void CSpyTreeView::OnPaint()
{
	// do not call CView::OnPaint since it will call OnDraw
	CWnd::OnPaint();
}

void CSpyTreeView::OnDraw(CDC*)
{
	// do nothing here
}

/////////////////////////////////////////////////////////////////////////////
// CSpyTreeView message handlers

void CSpyTreeView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
	CSpyTreeNode* pSpyTreeNode;
	CString str;
	POSITION pos;
	CSpyTreeDoc* pDoc;

	BeginWaitCursor();

	m_SpyTreeCtl.FreeAllTreeData();

	pDoc = (CSpyTreeDoc*)GetDocument();

	m_SpyTreeCtl.SetSorting(pDoc->SortLines());

	pos = pDoc->m_TopLevelNodeList.GetHeadPosition();
	while (pos)
	{
		pSpyTreeNode = (CSpyTreeNode*)pDoc->m_TopLevelNodeList.GetNext(pos);
		pSpyTreeNode->GetDescription(str);
		m_SpyTreeCtl.InsertNode(-1, str, (DWORD)pSpyTreeNode);
	}

	m_SpyTreeCtl.SetCurSel(0);

	if (pDoc->ExpandFirstLine())
	{
		m_SpyTreeCtl.Expand();
	}

	m_SpyTreeCtl.RecalcHorizontalExtent();

	EndWaitCursor();
}

int CSpyTreeView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CView::OnCreate(lpCreateStruct) == -1)
	{
		return -1;
	}

	LONG gwl = GetWindowLong(this->m_hWnd, GWL_STYLE);
	gwl |= (WS_CLIPSIBLINGS | WS_CLIPCHILDREN);
	SetWindowLong(this->m_hWnd, GWL_STYLE, gwl);

	if (m_SpyTreeCtl.Create(NULL, NULL, WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
		CRect(0, 0, 0, 0), this, 0) == -1)
	{
		return -1;
	}

	CFont Font;
	Font.CreateFontIndirect(&theApp.m_DefLogFont);
	SetFont(&Font, FALSE);
	Font.Detach();

	return 0;
}

void CSpyTreeView::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);

	m_SpyTreeCtl.MoveWindow(CRect(0, 0, cx, cy));
}

void CSpyTreeView::OnViewFont()
{
	HFONT hfontNew;

	if (hfontNew = SpyFontDialog(m_hfont))
	{
		HFONT hfontOld = m_hfont;

		SetFont(CFont::FromHandle(hfontNew));
		::DeleteObject(hfontOld);
	}
}

void CSpyTreeView::OnViewProperties()
{
	m_SpyTreeCtl.ShowSelItemProperties();
}

void CSpyTreeView::OnUpdateViewProperties(CCmdUI* pCmdUI)
{
	//
	// Enable only if there is a selected item in the tree.
	//
	pCmdUI->Enable(m_SpyTreeCtl.GetCurSel() != LB_ERR);
}

void CSpyTreeView::OnSetFocus(CWnd* pOldWnd)
{
	m_SpyTreeCtl.SetFocus();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\spytreec.h ===
// spytreec.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CSpyTreeCtl window

class CSpyTreeCtl : public CTreeCtl
{
// Construction
public:
	CSpyTreeCtl();

// Attributes
public:

// Operations
public:
	virtual BOOL InsertLevel(CNode* pNode, int nIndex, BOOL bExpandAll = FALSE);
	virtual void DrawNodeGlyph(CDC* pDC, CNode* pNode, BOOL bHighlight, CPoint pt);
	virtual BOOL NodeIsExpandable(CNode* pNode);
	virtual void ShowSelItemProperties();

	virtual void OnSelect(int nIndex);	  // called on selection change
	virtual void OnRightButtonDown(UINT nFlags, CPoint pt);

	void SetSorting(BOOL fSorted)
	{
		m_bSorted = fSorted;
	}

// Implementation
public:
	virtual ~CSpyTreeCtl();

	CBitmap m_bmFolders;
	CBitmap m_bmExpandNodes;

	// Generated message map functions
protected:
	static CImageWell c_imageSpyWell;

	//{{AFX_MSG(CSpyTreeCtl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnLbDblClk();
	afx_msg void OnLbSetFocus();
	afx_msg void OnLbKillFocus();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};



/////////////////////////////////////////////////////////////////////////////
// CSpyTreeNode object

class CSpyTreeNode : public CObject
{
	DECLARE_DYNCREATE(CSpyTreeNode);

public:
	CSpyTreeNode() {};
	virtual ~CSpyTreeNode();

// Attributes
public:

// Operations
public:
	virtual void GetDescription(CString& str)
	{
		// must be overridden to be useful...
		// would be pure virtual but that breaks DECLARE_DYNCREATE() above.
		ASSERT(FALSE);
	}
	virtual void ShowProperties()
	{
		// must be overridden to be useful...
		// would be pure virtual but that breaks DECLARE_DYNCREATE() above.
		ASSERT(FALSE);
	}
	virtual int GetBitmapIndex()
	{
		// must be overridden to be useful...
		// would be pure virtual but that breaks DECLARE_DYNCREATE() above.
		ASSERT(FALSE);
		return(0);
	}
	virtual DWORD GetObjectHandle()
	{
		// must be overridden to be useful...
		// would be pure virtual but that breaks DECLARE_DYNCREATE() above.
		ASSERT(FALSE);
		return(0);
	}
	virtual int GetObjectType()
	{
		// must be overridden to be useful...
		// would be pure virtual but that breaks DECLARE_DYNCREATE() above.
		ASSERT(FALSE);
		return(0);
	}

	virtual POSITION AddChild(CSpyTreeNode* pTreeNode)
	{
		return m_ChildList.AddTail(pTreeNode);
	}
	virtual POSITION GetFirstChildPosition()
	{
		return m_ChildList.GetHeadPosition();
	}
	virtual CSpyTreeNode*& GetNextChild(POSITION& pos)
	{
		return (CSpyTreeNode*&)m_ChildList.GetNext(pos);
	}

protected:
//	static PSYSTEM_PROCESS_INFORMATION m_pProcessBuffer;
	static int m_cUsage;

// Implementation
protected:
	CObList m_ChildList;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\spytreev.h ===
// spytreev.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSpyTreeView view

class CSpyTreeView : public CView
{
	DECLARE_DYNCREATE(CSpyTreeView)
protected:
	CSpyTreeView();		 // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:
	void SetFont(CFont* pFont, BOOL bRedraw = TRUE)
	{
		m_SpyTreeCtl.SetFont(pFont, bRedraw);
		m_hfont = (HFONT)pFont->m_hObject;
	}

// Implementation
protected:
	virtual ~CSpyTreeView();
	virtual void OnDraw(CDC* pDC);	  // overridden to draw this view
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);

protected:
	CSpyTreeCtl m_SpyTreeCtl;
	HFONT m_hfont;

	// Generated message map functions
protected:
	//{{AFX_MSG(CSpyTreeView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg void OnViewFont();
	afx_msg void OnViewProperties();
	afx_msg void OnUpdateViewProperties(CCmdUI* pCmdUI);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CSpyTreeDoc;
	friend class CWndTreeDoc;
	friend class CPrcTreeDoc;
	friend class CThdTreeDoc;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\spyxx.cpp ===
// spy.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#pragma hdrstop

#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"

#include "hotlinkc.h"

#include "treectl.h"
#include "spytreed.h"
#include "spytreec.h"
#include "spytreev.h"

#include "wndnode.h"
#include "wndtreed.h"
#include "prctreed.h"
#include "thdtreed.h"

#include "mainfrm.h"
#include "aboutdlg.h"
#include "findtool.h"
#include "findwdlg.h"
#include "spyxxmdi.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

void idsDelete();	// forward declaration for idsDelete()

/////////////////////////////////////////////////////////////////////////////
// CSpyApp

CHAR CSpyApp::m_szSpyKey[] = "Software\\Microsoft\\Spy++ 3.0";
CHAR CSpyApp::m_szKeyDefFont[] = "DefFont";
CHAR CSpyApp::m_szKeyMainPos[] = "MainPos";
CHAR CSpyApp::m_szKeyDecodeStructs[] = "DecodeStructs";
CHAR CSpyApp::m_szMaximizeMDI[] = "MaximizeMDI";
BOOL CSpyApp::m_bIsChicago = FALSE;
BOOL CSpyApp::m_bIsDaytona = FALSE;
BOOL CSpyApp::m_bIsMDIMaximized = -1;
int  CSpyApp::m_nWinTabCur = -1;
int  CSpyApp::m_nPrcTabCur = -1;
int  CSpyApp::m_nThdTabCur = -1;
int  CSpyApp::m_nMsgTabCur = -1;

HINSTANCE		CSpyApp::hToolhelp32 = NULL;
SNAPSHOTPROC	CSpyApp::pfnCreateToolhelp32Snapshot = NULL;
HEAPLISTPROC	CSpyApp::pfnHeap32ListFirst = NULL;
HEAPLISTPROC	CSpyApp::pfnHeap32ListNext = NULL;
HEAP32FIRSTPROC	CSpyApp::pfnHeap32First = NULL;
HEAP32NEXTPROC	CSpyApp::pfnHeap32Next = NULL;
READPROCMEMPROC	CSpyApp::pfnToolhelp32ReadProcessMemory = NULL;
PROCESSLISTPROC	CSpyApp::pfnProcess32First = NULL;
PROCESSLISTPROC	CSpyApp::pfnProcess32Next = NULL;
THREADLISTPROC	CSpyApp::pfnThread32First = NULL;
THREADLISTPROC	CSpyApp::pfnThread32Next = NULL;
MODULELISTPROC	CSpyApp::pfnModule32First = NULL;
MODULELISTPROC	CSpyApp::pfnModule32Next = NULL;


BEGIN_MESSAGE_MAP(CSpyApp, CWinApp)
	//{{AFX_MSG_MAP(CSpyApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_COMMAND(ID_SPY_MESSAGES, OnSpyMessages)
	ON_COMMAND(ID_SPY_MESSAGESDIRECT, OnSpyMessagesDirect)
	ON_COMMAND(ID_SPY_HIGHLIGHTWINDOW, OnSpyHighlightWindow)
	ON_COMMAND(ID_SPY_WINDOWS, OnSpyWindows)
	ON_COMMAND(ID_SPY_PROCESSES, OnSpyProcesses)
	ON_COMMAND(ID_SPY_THREADS, OnSpyThreads)
	ON_COMMAND(ID_SPY_FINDWINDOW, OnSpyFindWindow)
	ON_UPDATE_COMMAND_UI(ID_SPY_PROCESSES, OnUpdateSpyProcesses)
	ON_UPDATE_COMMAND_UI(ID_SPY_THREADS, OnUpdateSpyThreads)
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_INDEX, CWinApp::OnHelpIndex)
	ON_COMMAND(ID_HELP_USING, CWinApp::OnHelpUsing)
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
	ON_COMMAND(ID_DEFAULT_HELP, CWinApp::OnHelpIndex)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// utility functions

// call this function twice to turn on and off window border highlighting
void HighlightWindowBorder(HWND hwndHighlight)
{
	HDC hdc;
	RECT rc;
	HPEN hpen;
	HPEN hpenOld;
	HBRUSH hbrOld;
	int cxBorder = ::GetSystemMetrics(SM_CXBORDER);
	int cyBorder = ::GetSystemMetrics(SM_CYBORDER);
	int cxFrame  = ::GetSystemMetrics(SM_CXFRAME);
	int cyFrame  = ::GetSystemMetrics(SM_CYFRAME);
	int cxScreen = ::GetSystemMetrics(SM_CXSCREEN);
	int cyScreen = ::GetSystemMetrics(SM_CYSCREEN);

	::GetWindowRect(hwndHighlight, &rc);
	hdc = ::GetWindowDC(hwndHighlight);
	::SetROP2(hdc, R2_NOT);
	hpen = ::CreatePen(PS_INSIDEFRAME, 3 * cxBorder, RGB(0, 0, 0));

	hpenOld = (HPEN)::SelectObject(hdc, hpen);
	hbrOld = (HBRUSH)::SelectObject(hdc, ::GetStockObject(NULL_BRUSH));
	if (::IsZoomed(hwndHighlight))
		::Rectangle(hdc, cxFrame, cyFrame, cxScreen + cxFrame, cyScreen + cyFrame);
	else
		::Rectangle(hdc, 0, 0, rc.right - rc.left, rc.bottom - rc.top);
	::SelectObject(hdc, hbrOld);
	::SelectObject(hdc, hpenOld);

	::ReleaseDC(hwndHighlight, hdc);
	::DeleteObject(hpen);
}

void FlashWindowBorder(HWND hwndFlash)
{
	for (int i = 1; i <= 5; i++)
	{
		HighlightWindowBorder(hwndFlash);
		Sleep(100);
		HighlightWindowBorder(hwndFlash);
		Sleep(100);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSpyApp construction

CSpyApp::CSpyApp()
//	:m_ProcessDatabase(&m_pdbError)
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CSpyApp object

CSpyApp NEAR theApp;

/////////////////////////////////////////////////////////////////////////////
// CSpyApp initialization

BOOL CSpyApp::InitInstance()
{
	HKEY hkey;
	DWORD dwType;
	DWORD cbData;
	BOOL fDecodeStructs;
	BOOL fMainPosValid;
	WINDOWPLACEMENT wndpl;
	HANDLE hmutexStartup;

	//
	// Create/Open the Spy startup mutex.  This is part of the
	// mechanism that is used to determine if another instance
	// of Spy++ is running.  This is not allowed because there
	// is only one shared memory queue that is used to pass the
	// hook information across, and with multiple copies of Spy++
	// running they would be fighting over reading the queue.
	//
	hmutexStartup = CreateMutex(NULL, FALSE, STARTUPMUTEXNAME);
	ASSERT(hmutexStartup);

	//
	// Grab the mutex without waiting.  If we fail because another
	// copy of Spy++ has the mutex (and is initializing), then exit.
	// We don't need to activate the other copy in this case because
	// it will activate itself as soon as it is done initializing.
	//
	if (WaitForSingleObject(hmutexStartup, 0) != WAIT_OBJECT_0)
	{
		CloseHandle(hmutexStartup);
		return FALSE;
	}

	//
	// Search for another instance of Spy++ and activate it if it
	// is found.  Since it did not have the startup mutex claimed
	// we can be sure that the window has been created by now and
	// will be found by enumerating top-level windows.
	//
	HWND hwndPrevInst = GetWindow(GetDesktopWindow(), GW_CHILD);
	while (hwndPrevInst)
	{
		if (GetWindowLong(hwndPrevInst, GWL_USERDATA) == SPYXX_WINDOW_SIGNATURE)
		{
			if (IsIconic(hwndPrevInst))
			{
				ShowWindow(hwndPrevInst, SW_SHOWNORMAL);
			}

			SetForegroundWindow(hwndPrevInst);
			BringWindowToTop(hwndPrevInst);
			ReleaseMutex(hmutexStartup);
			CloseHandle(hmutexStartup);
			return FALSE;
		}

		hwndPrevInst = GetWindow(hwndPrevInst, GW_HWNDNEXT);
	}

	m_hiconApp = LoadIcon(IDR_MAINFRAME);
	ASSERT(m_hiconApp);
	m_hcurFindTool = LoadCursor(IDC_FINDTOOL);
	ASSERT(m_hcurFindTool);
	m_hiconFindTool = LoadIcon(IDI_FINDTOOL);
	ASSERT(m_hiconFindTool);
	m_hiconFindTool2 = LoadIcon(IDI_FINDTOOL2);
	ASSERT(m_hiconFindTool2);

	m_BrushWindow.CreateSolidBrush(GetSysColor(COLOR_WINDOW));

	// hook up to the 3d control DLL (the new way)...
	if (_getmbcp() == 0)
		Enable3dControls();

	// set dialog background color to match system colors
	SetDialogBkColor(GetSysColor(COLOR_BTNFACE));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	if (RegOpenKey(HKEY_CURRENT_USER, m_szSpyKey, &hkey) != ERROR_SUCCESS)
	{
		hkey = NULL;
	}

	//
	// Get the default font from the registry
	//
	cbData = sizeof(m_DefLogFont);
	if (!hkey || RegQueryValueEx(hkey, m_szKeyDefFont, NULL, &dwType, (LPBYTE)&m_DefLogFont, &cbData) != ERROR_SUCCESS)
	{
		//
		// Cannot get the font from the registry.  Use the
		// system font as the default font.
		//
		HFONT hfont = (HFONT)GetStockObject(SYSTEM_FONT);
		::GetObject(hfont, sizeof(m_DefLogFont), &m_DefLogFont);
	}

	//
	// Get the main window's last position from the registy
	//
	fMainPosValid = FALSE;
	cbData = sizeof(wndpl);
	if (hkey && RegQueryValueEx(hkey, m_szKeyMainPos, NULL, &dwType, (LPBYTE)&wndpl, &cbData) == ERROR_SUCCESS)
	{
		if (m_nCmdShow != SW_SHOWNORMAL && m_nCmdShow != SW_SHOW)
		{
			//
			// The shell is launching the app in some special
			// state.  We should respect it no matter what
			// state the app was in when it was last closed.
			//
			wndpl.showCmd = m_nCmdShow;
		}
		else if (wndpl.showCmd == SW_SHOWMINIMIZED)
		{
			//
			// Don't start minimized if the app was last closed
			// when minimized.
			//
			wndpl.showCmd = SW_RESTORE;
		}

		wndpl.length = sizeof(wndpl);
		fMainPosValid = TRUE;
	}

	cbData = sizeof(BOOL);
	if (!hkey || RegQueryValueEx(hkey, m_szKeyDecodeStructs, NULL, &dwType, (LPBYTE)&fDecodeStructs, &cbData) != ERROR_SUCCESS)
	{
		//
		// Capture and decode structures and strings is on by default
		//
		fDecodeStructs = TRUE;
	}

	BOOL bIsMDIMaximized;
	cbData = sizeof(BOOL);
	if (!hkey || RegQueryValueEx(hkey, m_szMaximizeMDI, NULL, &dwType, (LPBYTE)&bIsMDIMaximized, &cbData) != ERROR_SUCCESS)
	{
		//
		// maximized MDI on startup is off by default
		//
		bIsMDIMaximized = FALSE;
	}

	//
	// Set the shared global that turns on/off decoding structs in the hook.
	//
	gfDecodeStructs = fDecodeStructs;

	//
	// Initialize the message document type static data.
	//
	CMsgDoc::InitStaticData(hkey);

	if (hkey)
	{
		RegCloseKey(hkey);
	}

	CPropertyInspector::InitializeTables();
	CHotLinkCtrl::InitStaticData();

	// Register the application's document templates.  Document templates
	// serve as the connection between documents, frame windows and views.
	// Use CSpyMDIChildWnd rather than CMDIChildWindow so that OnSize can
	// be trapped in order to save whether MDI state is maximized or not.

	m_pMsgDocTemplate = new CMultiDocTemplate(IDR_MSGTYPE,
			RUNTIME_CLASS(CMsgDoc), RUNTIME_CLASS(CSpyMDIChildWnd), RUNTIME_CLASS(CMsgView));
	AddDocTemplate(m_pMsgDocTemplate);

	m_pWndTreeDocTemplate = new CMultiDocTemplate(IDR_WNDTREETYPE,
			RUNTIME_CLASS(CWndTreeDoc), RUNTIME_CLASS(CSpyMDIChildWnd), RUNTIME_CLASS(CSpyTreeView));
	AddDocTemplate(m_pWndTreeDocTemplate);

	m_pPrcTreeDocTemplate = new CMultiDocTemplate(IDR_PRCTREETYPE,
			RUNTIME_CLASS(CPrcTreeDoc), RUNTIME_CLASS(CSpyMDIChildWnd), RUNTIME_CLASS(CSpyTreeView));
	AddDocTemplate(m_pPrcTreeDocTemplate);

	m_pThdTreeDocTemplate = new CMultiDocTemplate(IDR_THDTREETYPE,
			RUNTIME_CLASS(CThdTreeDoc), RUNTIME_CLASS(CSpyMDIChildWnd), RUNTIME_CLASS(CSpyTreeView));
	AddDocTemplate(m_pThdTreeDocTemplate);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
	{
		ReleaseMutex(hmutexStartup);
		CloseHandle(hmutexStartup);
		return FALSE;
	}

	if (fMainPosValid)
	{
		SetWindowPlacement(pMainFrame->m_hWnd, &wndpl);
	}
	else
	{
		pMainFrame->ShowWindow(m_nCmdShow);
	}

	pMainFrame->UpdateWindow();
	m_pMainWnd = pMainFrame;

	// check Windows version and set m_bIsChicago flag accordingly.
	DWORD dwWindowsVersion = GetVersion();
	// check the 'Win32s' bit
	if (dwWindowsVersion & 0x80000000)
	{
		// bit is set, we are running on either Win32s or Chicago
		if (LOBYTE(LOWORD(dwWindowsVersion)) > 3)
		{
			m_bIsChicago = TRUE;
			gfOnChicago = TRUE;

			// now set up the Chicago ToolHelp function pointers
			if ((hToolhelp32 = LoadLibrary("kernel32.dll")) != NULL)
			{
				pfnCreateToolhelp32Snapshot = (SNAPSHOTPROC)GetProcAddress(hToolhelp32, "CreateToolhelp32Snapshot");
				pfnHeap32ListFirst = (HEAPLISTPROC)GetProcAddress(hToolhelp32, "Heap32ListFirst");
				pfnHeap32ListNext = (HEAPLISTPROC)GetProcAddress(hToolhelp32, "Heap32ListNext");
				pfnHeap32First = (HEAP32FIRSTPROC)GetProcAddress(hToolhelp32, "Heap32First");
				pfnHeap32Next = (HEAP32NEXTPROC)GetProcAddress(hToolhelp32, "Heap32Next");
				pfnToolhelp32ReadProcessMemory = (READPROCMEMPROC)GetProcAddress(hToolhelp32, "Toolhelp32ReadProcessMemory");
				pfnProcess32First = (PROCESSLISTPROC)GetProcAddress(hToolhelp32, "Process32First");
				pfnProcess32Next = (PROCESSLISTPROC)GetProcAddress(hToolhelp32, "Process32Next");
				pfnThread32First = (THREADLISTPROC)GetProcAddress(hToolhelp32, "Thread32First");
				pfnThread32Next = (THREADLISTPROC)GetProcAddress(hToolhelp32, "Thread32Next");
				pfnModule32First = (MODULELISTPROC)GetProcAddress(hToolhelp32, "Module32First");
				pfnModule32Next = (MODULELISTPROC)GetProcAddress(hToolhelp32, "Module32Next");

				if (pfnCreateToolhelp32Snapshot == NULL || 
					pfnHeap32ListFirst == NULL || 
					pfnHeap32ListNext == NULL || 
					pfnHeap32First == NULL || 
					pfnHeap32Next == NULL || 
					pfnToolhelp32ReadProcessMemory == NULL || 
					pfnProcess32First == NULL || 
					pfnProcess32Next == NULL || 
					pfnThread32First == NULL || 
					pfnThread32Next == NULL || 
					pfnModule32First == NULL || 
					pfnModule32Next == NULL)
				{
					FreeLibrary(hToolhelp32);
					hToolhelp32 = NULL;
				}
			}

			if (hToolhelp32 == NULL)
			{
				// warn user that process/thread information will not be available
				SpyMessageBox(IDS_PT_NOT_AVAILABLE);
			}
		}
		else
		{
			// we are on Win32s, bail!
//			SpyMessageBox(IDS_OS_IS_WIN32S, MB_OK, MB_ICONSTOP);
			::MessageBox(m_pMainWnd->m_hWnd, ids(IDS_OS_IS_WIN32S), "Spy++", MB_OK | MB_ICONSTOP | MB_TASKMODAL);
			return(FALSE);
		}
	}
	else
	{
		// we are running on Windows NT, check if it's Daytona...
		if ((LOBYTE(LOWORD(dwWindowsVersion)) == 3) && (HIBYTE(LOWORD(dwWindowsVersion)) >= 50))
		{
			m_bIsDaytona = TRUE;
			gfOnDaytona = TRUE;
		}
	}

	// TODO: add code here to reload the last size and positions of the
	// child MDI tree views.  But don't do message stream views because the
	// hwnd they were spying on may or may not be valid anymore!  Only
	// create a default view if there are no MDI children saved from
	// last time.

	m_pWndTreeDocTemplate->OpenDocumentFile(NULL);

	m_bIsMDIMaximized = bIsMDIMaximized;
	if (m_bIsMDIMaximized)
	{
		CMDIChildWnd *pcmcwActive = (CMDIChildWnd *)(((CMDIFrameWnd *)m_pMainWnd)->MDIGetActive());
		((CMDIFrameWnd *)m_pMainWnd)->MDIMaximize(pcmcwActive);
	}

	CreateHookThread();

	ReleaseMutex(hmutexStartup);
	CloseHandle(hmutexStartup);
	OnSpyMessages();
	return TRUE;
}

int CSpyApp::ExitInstance()
{
	HKEY hkey;

	if (RegCreateKey(HKEY_CURRENT_USER, m_szSpyKey, &hkey) == ERROR_SUCCESS)
	{
		RegSetValueEx(hkey, m_szKeyDefFont, 0, REG_BINARY, (LPBYTE)&m_DefLogFont, sizeof(m_DefLogFont));

		if (m_fMainWndplValid)
		{
			RegSetValueEx(hkey, m_szKeyMainPos, 0, REG_BINARY, (LPBYTE)&m_wndplMain, sizeof(m_wndplMain));
		}

		RegSetValueEx(hkey, m_szKeyDecodeStructs, 0, REG_DWORD, (LPBYTE)&gfDecodeStructs, sizeof(BOOL));

		RegSetValueEx(hkey, m_szMaximizeMDI, 0, REG_DWORD, (LPBYTE)&m_bIsMDIMaximized, sizeof(BOOL));

		CMsgDoc::SaveSettings(hkey);

		RegCloseKey(hkey);
	}

	if (m_bDidPerfQueries)
	{
		// RegCloseKey is required so that network transports 
		// and drivers can be removed or installed (which 
		// cannot happen while they are open for monitoring.)
		RegCloseKey(HKEY_PERFORMANCE_DATA);
	}

	if (hToolhelp32)
		FreeLibrary(hToolhelp32);

	idsDelete();

	return CWinApp::ExitInstance();
}

void CSpyApp::OnAppAbout()
{
	CAboutDlg Dlg;

	Dlg.DoModal();
}

void CSpyApp::OnSpyMessages()
{
	// We only show the message log window after the user selects OK from the 
	// Messages.Options dialog.  If the user hits the Cancel button in Messages.Options,
	// we should destroy the message log window without ever showing it.

	// don't allow immediate spying when message log created--wait until after
	// message options dialog is dismissed (with OK).
	SetSpyImmediate(FALSE);

	// create the document with view hidden (until OK pressed in message options)
	// by calling OpenDocumentFile with bMakeVisible set to FALSE.
	CMsgDoc* pMsgDoc = (CMsgDoc*)m_pMsgDocTemplate->OpenDocumentFile(NULL, FALSE);
	if (pMsgDoc)
	{
		if (pMsgDoc->ShowWindowFinder() == IDCANCEL)
			pMsgDoc->OnCloseDocument();
		else
		{
			POSITION pos = pMsgDoc->GetFirstViewPosition();
			CView *pView = pMsgDoc->GetNextView(pos);
			ASSERT(pos == NULL);	// should only be one view!

			// now perform the initial update which was not previously performed
			// because we called OpenDocumentFile() with bMakeVisible set to FALSE.
			CFrameWnd *pFrame = (CFrameWnd *)pView->GetParent();

			// comment out to get V2 build to work.
			//pFrame->InitialUpdateFrame(pMsgDoc, TRUE);

			pMsgDoc->StartLogging();
		}
	}
}

void CSpyApp::OnSpyMessagesDirect()
{
	// allow immediate spying when message log created.
	SetSpyImmediate(TRUE);

	m_pMsgDocTemplate->OpenDocumentFile(NULL);
}

void CSpyApp::OnSpyHighlightWindow()
{
	FlashWindowBorder((HWND)GetLastSelectedObject());
}

void CSpyApp::OnSpyWindows()
{
	BeginWaitCursor();
	m_pWndTreeDocTemplate->OpenDocumentFile(NULL);
	EndWaitCursor();
}

void CSpyApp::OnSpyProcesses()
{
	BeginWaitCursor();
	m_pPrcTreeDocTemplate->OpenDocumentFile(NULL);
	EndWaitCursor();
}

void CSpyApp::OnUpdateSpyProcesses(CCmdUI *pCmdUI)
{
	pCmdUI->Enable(!m_bIsChicago || hToolhelp32 != NULL);
}

void CSpyApp::OnSpyThreads()
{
	BeginWaitCursor();
	m_pThdTreeDocTemplate->OpenDocumentFile(NULL);
	EndWaitCursor();
}

void CSpyApp::OnUpdateSpyThreads(CCmdUI *pCmdUI)
{
	pCmdUI->Enable(!m_bIsChicago || hToolhelp32 != NULL);
}

void CSpyApp::OnSpyFindWindow()
{
	CFindWindowDlg dlg(theApp.m_pMainWnd);

	if (dlg.DoModal() == IDOK)
	{
		// user pressd OK in dialog
		if (dlg.GetSelectedHwnd() != NULL)
		{
			// window handle is not NULL and is valid
			if (dlg.m_ShowProperties)
			{
				// user wants to see properties of window
				CPropertyInspector::ShowObjectProperties((DWORD)dlg.GetSelectedHwnd(), OT_WINDOW);
			}
			else if (dlg.m_ShowMessages)
			{
				// user wants to see message stream for window
				SetLastSelectedObject((DWORD)dlg.GetSelectedHwnd(), OT_WINDOW);
				OnSpyMessagesDirect();
			}
		}
	}
}

BOOL CSpyApp::OnIdle(LONG lCount)
{
	if (CWinApp::OnIdle(lCount))
	{
		return 1;
	}

	ChangeToLastSelectedObject();

	return 0;
}

//-----------------------------------------------------------------------------
// ids
//
// This function will return a string, given the string id.  If this
// is the first time that the string has been retrieved, memory will
// be allocated for it and it will be loaded.  After it is loaded once,
// it is then cached in an array and is available for later without
// having to load it again.
//
// Arguments:
//  UINT idString - String ID of the string to retrieve.
//
// Returns:
//  Pointer to the string.
//
//-----------------------------------------------------------------------------

static CHAR* apsz[MAX_STRINGIDS];	   // String resource array cache.

CHAR* ids(UINT idString)
{
	CHAR* psz;
	int index;

	//
	// Check for a string id that is too low.  They must start
	// at STRINGID_BASE.
	//
	ASSERT(idString >= STRINGID_BASE);

	//
	// Check for a string id that is too high.  The value of
	// MAX_STRINGIDS must be increased!
	//
	ASSERT(idString < STRINGID_BASE + MAX_STRINGIDS);

	index = idString - STRINGID_BASE;
	if (apsz[index])
	{
		return apsz[index];
	}

	CString Str;

	if (Str.LoadString(idString))
	{
		psz = new CHAR[Str.GetLength() + 1];
		_tcscpy(psz, Str);
		apsz[index] = psz;
		return psz;
	}
	else
	{
		//
		// Right now we return something that will keep the caller from
		// faulting.  But are we obfuscating a potential problem?
		//
		return "";
	}
}

//-----------------------------------------------------------------------------
// idsDelete
//
// This function will return clean up the apsz string array.
// If the array is not cleaned up, it's a memory leak!
//
//-----------------------------------------------------------------------------

void idsDelete()
{
	CHAR* psz;
	int index;

	for (index = STRINGID_BASE; index < STRINGID_BASE + MAX_STRINGIDS; index++)
	{
		if ((psz = apsz[index-STRINGID_BASE]) != NULL)
			delete psz;
	}
}

//-----------------------------------------------------------------------------
// GetExpandedClassName
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

LPSTR GetExpandedClassName(LPSTR pszClass)
{
	if (*pszClass == '#')
	{
		if (_tcscmp(pszClass, "#32768") == 0)
		{
			return ids(IDS_POPUPMENU);
		}
		else if (_tcscmp(pszClass, "#32769") == 0)
		{
			return ids(IDS_DESKTOP);
		}
		else if (_tcscmp(pszClass, "#32770") == 0)
		{
			return ids(IDS_DIALOG);
		}
		else if (_tcscmp(pszClass, "#32771") == 0)
		{
			return ids(IDS_WINSWITCH);
		}
		else if (_tcscmp(pszClass, "#32772") == 0)
		{
			return ids(IDS_ICONTITLE);
		}
	}

	return NULL;
}

//-----------------------------------------------------------------------------
// SpyMessageBox
//
//
//
// Arguments:
//
//
//
// Returns:
//
//
//-----------------------------------------------------------------------------

int SpyMessageBox(UINT nIDPrompt, UINT nType, UINT nIcon)
{
	return AfxMessageBox(nIDPrompt, nType | nIcon | MB_TASKMODAL);
}

/////////////////////////////////////////////////////////////////////////////
// following code is copied from VSHELL\STDFONT.CPP
#define MAX_FONT_NAME 51
struct FontEntry
{
	TCHAR szName[MAX_FONT_NAME];	// REVIEW: Is this too small?
	int iSize;
	BOOL bAdjustSize;	// if true use -MulDiv(iSize, LOGPIXELSY, 72)
};

// the following table is from Visual C++ shell.
// dolphin 13830 [patbr] changed from Spy++ table
static BASED_CODE FontEntry FontNames[4][3] =
{
	{
		{"MS Sans Serif",	8,	TRUE},
		{"lr ",		12,	TRUE},
		{"System",			10,	TRUE}
	}, {
		{"Small Fonts",		-9,	FALSE},
		{"Terminal",		-9,	FALSE},
		{"Terminal",		-9,	FALSE}
	}, {
		{"Courier",			14,	FALSE},
		{"FixedSys",		14,	FALSE},
		{"FixedSys",		14,	FALSE}
	}, {
		{"MS Sans Serif",	8,	TRUE},
		{"lr ",		12,	TRUE},
		{"System",			10,	TRUE}
	}
};

static FontEntry* GetStdFontInfo(int iType, int* pnCharset = NULL)
{
	ASSERT(iType >= 0 && iType < font_count);

	int iFacename, nCharset;

	switch (_getmbcp())
	{
	case OEM_JAPAN:
		iFacename = 1;
		nCharset = SHIFTJIS_CHARSET;
		break;

	case OEM_PRC:
	case OEM_TAIWAN:
	case OEM_KOR_WANGSUNG:
	case OEM_KOR_JOHAB:
		iFacename = 2;
		nCharset = SHIFTJIS_CHARSET;		// REVIEW: What should this be?
		break;

	default:
		iFacename = 0;
		nCharset = ANSI_CHARSET;
		break;
	}
	
	if (pnCharset != NULL)
		*pnCharset = nCharset;

	static FontEntry fe;
/*
	CString strValName;
	switch (iType/2)
	{
		case 0:
			strValName = "Normal";
			break;
		case 1:
			strValName = "Small";
			break;
		case 2:
			strValName = "Fixed";
			break;
		default:
			// An invalid font type
			ASSERT( 0 );
	}
*/
	fe = FontNames[iType/2][iFacename];

	return &fe;
}

void GetStdFontInfo(int iType, CString& strFace, int& ptSize)
{
	FontEntry* pfe = GetStdFontInfo(iType);
	strFace = pfe->szName;
	ptSize = pfe->iSize;
}

// NOTE: The LOGFONT returned by this function is temporary!
const LOGFONT* GetStdLogfont( const int iType, CDC *pDC /* = NULL */ )
{
	static LOGFONT lf;
	
	int nCharset;
	FontEntry* pfe = GetStdFontInfo(iType, &nCharset);

	if (!pDC)
	{
		CWindowDC dc(NULL);
		lf.lfHeight = pfe->bAdjustSize ? -MulDiv(pfe->iSize, dc.GetDeviceCaps(LOGPIXELSY), 72) : pfe->iSize;
	}
	else
	{
		lf.lfHeight = pfe->bAdjustSize ? -MulDiv(pfe->iSize, pDC->GetDeviceCaps(LOGPIXELSY), 72) : pfe->iSize;
	}
	lf.lfWidth = 0;
	lf.lfEscapement = 0;
	lf.lfOrientation = 0;
	lf.lfWeight = ((iType & 1) && (_getmbcp() == 0)) ? FW_BOLD : FW_NORMAL;
	lf.lfItalic = FALSE;
	if (iType == font_NormalUnderline || iType == font_NormalUnderlineBold)
		lf.lfUnderline = TRUE;
	else
		lf.lfUnderline = FALSE;
	lf.lfStrikeOut = FALSE;
	lf.lfCharSet = nCharset;
	lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	lf.lfQuality = DEFAULT_QUALITY;
	lf.lfPitchAndFamily = DEFAULT_PITCH | FW_DONTCARE;
	lstrcpy( lf.lfFaceName, pfe->szName );

	return &lf;
}

CFont* GetStdFont(const int iType)
{
	static CFont fonts[font_count];
	
	ASSERT(iType >= 0 && iType < font_count);
	
	if (fonts[iType].m_hObject == NULL)
		VERIFY(fonts[iType].CreateFontIndirect(GetStdLogfont(iType)));
	
	return &fonts[iType];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\spytreed.cpp ===
// spytreed.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "treectl.h"
#include "spytreed.h"
#include "spytreec.h"
#include "imgwell.h"
#include "spytreev.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSpyTreeDoc

IMPLEMENT_DYNCREATE(CSpyTreeDoc, CDocument);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CSpyTreeDoc::CSpyTreeDoc()
{
}



CSpyTreeDoc::~CSpyTreeDoc()
{
}



BOOL CSpyTreeDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	InitializeData();

	return TRUE;
}



void CSpyTreeDoc::DeleteContents()
{
	POSITION pos;
	CSpyTreeNode* pSpyTreeNode;

	pos = m_TopLevelNodeList.GetHeadPosition();
	while (pos)
	{
		pSpyTreeNode = (CSpyTreeNode*)m_TopLevelNodeList.GetNext(pos);
		delete pSpyTreeNode;
	}

	m_TopLevelNodeList.RemoveAll();
}



BEGIN_MESSAGE_MAP(CSpyTreeDoc, CDocument)
	//{{AFX_MSG_MAP(CSpyTreeDoc)
	ON_COMMAND(ID_WINDOW_REFRESH, OnWindowRefresh)
	ON_COMMAND(ID_TREE_EXPAND_ONE_LEVEL, OnTreeExpandOneLevel)
	ON_UPDATE_COMMAND_UI(ID_TREE_EXPAND_ONE_LEVEL, OnUpdateTreeExpandOneLevel)
	ON_COMMAND(ID_TREE_EXPAND_BRANCH, OnTreeExpandBranch)
	ON_UPDATE_COMMAND_UI(ID_TREE_EXPAND_BRANCH, OnUpdateTreeExpandBranch)
	ON_COMMAND(ID_TREE_EXPAND_ALL, OnTreeExpandAll)
	ON_UPDATE_COMMAND_UI(ID_TREE_EXPAND_ALL, OnUpdateTreeExpandAll)
	ON_COMMAND(ID_TREE_COLLAPSE, OnTreeCollapse)
	ON_UPDATE_COMMAND_UI(ID_TREE_COLLAPSE, OnUpdateTreeCollapse)
	ON_COMMAND(ID_SEARCH_FIND, OnSearchFind)
	ON_UPDATE_COMMAND_UI(ID_SEARCH_FIND, OnUpdateSearchFind)
	ON_COMMAND(ID_SEARCH_FINDNEXT, OnSearchFindNext)
	ON_UPDATE_COMMAND_UI(ID_SEARCH_FINDNEXT, OnUpdateSearchFindNext)
	ON_COMMAND(ID_SEARCH_FINDPREV, OnSearchFindPrev)
	ON_UPDATE_COMMAND_UI(ID_SEARCH_FINDPREV, OnUpdateSearchFindPrev)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSpyTreeDoc commands

void CSpyTreeDoc::OnWindowRefresh()
{
	DeleteContents();
	InitializeData();
	UpdateAllViews(NULL);
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnTreeExpandOneLevel()
{
	POSITION pos;
	CSpyTreeView *pcstvCur, *pcstvActive;

	BeginWaitCursor();
	pos = GetFirstViewPosition();
	while (pos)
	{
		pcstvCur = (CSpyTreeView *)GetNextView(pos);
		pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());
		if (pcstvCur == pcstvActive)
		{
			pcstvCur->m_SpyTreeCtl.Expand(pcstvCur->m_SpyTreeCtl.GetCurSel(), FALSE);
			break;
		}
	}
	EndWaitCursor();
	return;
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnUpdateTreeExpandOneLevel(CCmdUI* pCmdUI)
{
	POSITION pos;
	CSpyTreeView *pcstvCur, *pcstvActive;
	
	pos = GetFirstViewPosition();
	while (pos)
	{
		pcstvCur = (CSpyTreeView *)GetNextView(pos);
		pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());
		if (pcstvCur == pcstvActive)
		{
			BOOL bEnable;

			bEnable = pcstvCur->m_SpyTreeCtl.NodeIsExpandable(pcstvCur->m_SpyTreeCtl.GetNode(pcstvCur->m_SpyTreeCtl.GetCurSel()));
			bEnable &= !(pcstvCur->m_SpyTreeCtl.IsExpanded(pcstvCur->m_SpyTreeCtl.GetCurSel()));
			pCmdUI->Enable(bEnable);
			break;
		}
	}
	return;
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnTreeExpandBranch()
{
	POSITION pos;
	CSpyTreeView *pcstvCur, *pcstvActive;
	
	BeginWaitCursor();
	pos = GetFirstViewPosition();
	while (pos)
	{
		pcstvCur = (CSpyTreeView *)GetNextView(pos);
		pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());
		if (pcstvCur == pcstvActive)
		{
			pcstvCur->m_SpyTreeCtl.Expand(pcstvCur->m_SpyTreeCtl.GetCurSel(), TRUE);
			break;
		}
	}
	EndWaitCursor();
	return;
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnUpdateTreeExpandBranch(CCmdUI* pCmdUI)
{
	POSITION pos;
	CSpyTreeView *pcstvCur, *pcstvActive;
	
	pos = GetFirstViewPosition();
	while (pos)
	{
		pcstvCur = (CSpyTreeView *)GetNextView(pos);
		pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());
		if (pcstvCur == pcstvActive)
		{
			pCmdUI->Enable(pcstvCur->m_SpyTreeCtl.NodeIsExpandable(pcstvCur->m_SpyTreeCtl.GetNode(pcstvCur->m_SpyTreeCtl.GetCurSel())));
			break;
		}
	}
	return;
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnTreeExpandAll()
{
	POSITION pos;
	CSpyTreeView *pcstvCur, *pcstvActive;
	
	BeginWaitCursor();
	pos = GetFirstViewPosition();
	while (pos)
	{
		pcstvCur = (CSpyTreeView *)GetNextView(pos);
		pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());
		if (pcstvCur == pcstvActive)
		{
			pcstvCur->m_SpyTreeCtl.ExpandAll();
			break;
		}
	}
	EndWaitCursor();
	return;
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnUpdateTreeExpandAll(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(TRUE);
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnTreeCollapse()
{
	POSITION pos;
	CSpyTreeView *pcstvCur, *pcstvActive;
	
	BeginWaitCursor();
	pos = GetFirstViewPosition();
	while (pos)
	{
		pcstvCur = (CSpyTreeView *)GetNextView(pos);
		pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());
		if (pcstvCur == pcstvActive)
		{
			pcstvCur->m_SpyTreeCtl.Collapse(pcstvCur->m_SpyTreeCtl.GetCurSel());
			break;
		}
	}
	EndWaitCursor();
	return;
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnUpdateTreeCollapse(CCmdUI* pCmdUI)
{
	POSITION pos;
	CSpyTreeView *pcstvCur, *pcstvActive;
	
	pos = GetFirstViewPosition();
	while (pos)
	{
		pcstvCur = (CSpyTreeView *)GetNextView(pos);
		pcstvActive = (CSpyTreeView *)(((CMDIFrameWnd *)(theApp.m_pMainWnd))->GetActiveFrame()->GetActiveView());
		if (pcstvCur == pcstvActive)
		{
			pCmdUI->Enable(pcstvCur->m_SpyTreeCtl.IsExpanded(pcstvCur->m_SpyTreeCtl.GetCurSel()));
			break;
		}
	}
	return;
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnSearchFind()
{
	DoFind();
	return;
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnUpdateSearchFind(CCmdUI* pCmdUI)
{
	SetSearchMenuText(pCmdUI);	// virtual--sets text to Find Window, Find Process, etc.
	pCmdUI->Enable(TRUE);
	return;
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnSearchFindNext()
{
	DoFindNext();
	return;
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnUpdateSearchFindNext(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(HasValidFind());
	return;
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnSearchFindPrev()
{
	DoFindPrev();
	return;
}

/////////////////////////////////////////////////////////////////////////////

void CSpyTreeDoc::OnUpdateSearchFindPrev(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(HasValidFind());
	return;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\spytreed.h ===
// spytreed.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSpyTreeDoc document

class CSpyTreeDoc : public CDocument
{
	DECLARE_DYNCREATE(CSpyTreeDoc);

protected:
	CSpyTreeDoc();		  // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Implementation
protected:
	virtual void InitializeData()
	{
		//
		// This must be overridden to be useful.
		//
		ASSERT(0);
	}

	virtual void SetSearchMenuText(CCmdUI *pCmdUI)
	{
		//
		// This must be overridden to be useful.
		//
		ASSERT(0);
	}

	virtual BOOL DoFind()
	{
		//
		// This must be overridden to be useful.
		//
		ASSERT(0);
		return(FALSE);
	}

	virtual BOOL DoFindNext()
	{
		//
		// This must be overridden to be useful.
		//
		ASSERT(0);
		return(FALSE);
	}

	virtual BOOL DoFindPrev()
	{
		//
		// This must be overridden to be useful.
		//
		ASSERT(0);
		return(FALSE);
	}

	virtual BOOL HasValidFind()
	{
		//
		// This must be overridden to be useful.
		//
		ASSERT(0);
		return(FALSE);
	}

	virtual BOOL ExpandFirstLine()
	{
		return FALSE;
	}

	virtual BOOL SortLines()
	{
		return TRUE;
	}

	virtual ~CSpyTreeDoc();
	virtual BOOL OnNewDocument();
	virtual void DeleteContents();

	CObList m_TopLevelNodeList;

	friend class CSpyTreeView;

	// Generated message map functions
protected:
	//{{AFX_MSG(CSpyTreeDoc)
	afx_msg void OnWindowRefresh();
	afx_msg void OnTreeExpandOneLevel();
	afx_msg void OnUpdateTreeExpandOneLevel(CCmdUI* pCmdUI);
	afx_msg void OnTreeExpandBranch();
	afx_msg void OnUpdateTreeExpandBranch(CCmdUI* pCmdUI);
	afx_msg void OnTreeExpandAll();
	afx_msg void OnUpdateTreeExpandAll(CCmdUI* pCmdUI);
	afx_msg void OnTreeCollapse();
	afx_msg void OnUpdateTreeCollapse(CCmdUI* pCmdUI);
	afx_msg void OnSearchFind();
	afx_msg void OnUpdateSearchFind(CCmdUI* pCmdUI);
	afx_msg void OnSearchFindNext();
	afx_msg void OnUpdateSearchFindNext(CCmdUI* pCmdUI);
	afx_msg void OnSearchFindPrev();
	afx_msg void OnUpdateSearchFindPrev(CCmdUI* pCmdUI);
	afx_msg void OnPrintTree();
	afx_msg void OnUpdatePrintTree(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\spyxxpch.cpp ===
// spyxxpch.cpp
// source file used to trigger rebuild of spy++ pre-compiled header file.

#include "stdafx.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\spyxx.h ===
// spy.h : main header file for the SPY application
//

//#define WIN32_LEAN_AND_MEAN

#define OEM_JAPAN			932
#define OEM_PRC				936
#define OEM_TAIWAN			950
#define OEM_KOR_WANGSUNG	949
#define OEM_KOR_JOHAB		1361
#define OEM_US				437

//
// Chicago ToolHelp function typedefs
//
typedef HANDLE (WINAPI *SNAPSHOTPROC)(DWORD, DWORD);
typedef BOOL (WINAPI *HEAPLISTPROC)(HANDLE, LPHEAPLIST32);
typedef BOOL (WINAPI *HEAP32FIRSTPROC)(LPHEAPENTRY32, DWORD, DWORD);
typedef BOOL (WINAPI *HEAP32NEXTPROC)(LPHEAPENTRY32);
typedef BOOL (WINAPI *READPROCMEMPROC)(DWORD, LPCVOID, LPVOID, DWORD, LPDWORD);
typedef BOOL (WINAPI *PROCESSLISTPROC)(HANDLE, LPPROCESSENTRY32);
typedef BOOL (WINAPI *THREADLISTPROC)(HANDLE, LPTHREADENTRY32);
typedef BOOL (WINAPI *MODULELISTPROC)(HANDLE, LPMODULEENTRY32);

/////////////////////////////////////////////////////////////////////////////
// Standard font handling

enum FontType
{
	font_Normal,			// MS Sans Serif 8, MS SVbN 10, System 10
	font_NormalBold,
	font_Small,				// Small Fonts (-9), Terminal (-9), Terminal (-9)
	font_SmallBold,
	font_Fixed,				// Courier (14), FixedSys (14), FixedSys (14)
	font_FixedBold,
	font_NormalUnderline,	// MS Sans Serif 8, MS SVbN 10, System 10
	font_NormalUnderlineBold,
	font_count				// Not a font, just provides a count
};

CFont* GetStdFont(const int iType);

// NOTE: The LOGFONT returned by this is temporary
const LOGFONT* GetStdLogfont(const int iType, CDC *pDC = NULL);

/////////////////////////////////////////////////////////////////////////////
// CSpyApp:
// See spy.cpp for the implementation of this class
//

class CSpyApp : public CWinApp
{
public:
	CSpyApp();

	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
	virtual BOOL OnIdle(LONG lCount);

	void InvokeWinHelp(DWORD dwData, int helpType);

	BOOL IsChicago() {return(m_bIsChicago);}
	BOOL IsDaytona() {return(m_bIsDaytona);}

	int GetWinTabCur() {return(m_nWinTabCur);}
	int GetPrcTabCur() {return(m_nPrcTabCur);}
	int GetThdTabCur() {return(m_nThdTabCur);}
	int GetMsgTabCur() {return(m_nMsgTabCur);}
	void SetWinTabCur(int nTab) {m_nWinTabCur = nTab;}
	void SetPrcTabCur(int nTab) {m_nPrcTabCur = nTab;}
	void SetThdTabCur(int nTab) {m_nThdTabCur = nTab;}
	void SetMsgTabCur(int nTab) {m_nMsgTabCur = nTab;}

	HICON m_hiconApp;
	HCURSOR m_hcurFindTool;
	HICON m_hiconFindTool;
	HICON m_hiconFindTool2;
	CBrush m_BrushWindow;
	LOGFONT m_DefLogFont;
	BOOL m_fMainWndplValid;
	WINDOWPLACEMENT m_wndplMain;
	CMultiDocTemplate *m_pMsgDocTemplate;
	CMultiDocTemplate *m_pWndTreeDocTemplate;
	CMultiDocTemplate *m_pPrcTreeDocTemplate;
	CMultiDocTemplate *m_pThdTreeDocTemplate;

	BOOL m_bDidPerfQueries;
	CStringList m_strlistLogFiles;

	static BOOL m_bIsMDIMaximized;

// Chicago process/thread function pointers
	static HINSTANCE		hToolhelp32;

	static SNAPSHOTPROC		pfnCreateToolhelp32Snapshot;

	static HEAPLISTPROC		pfnHeap32ListFirst;
	static HEAPLISTPROC		pfnHeap32ListNext;
	static HEAP32FIRSTPROC	pfnHeap32First;
	static HEAP32NEXTPROC	pfnHeap32Next;
	static READPROCMEMPROC	pfnToolhelp32ReadProcessMemory;

	static PROCESSLISTPROC	pfnProcess32First;
	static PROCESSLISTPROC	pfnProcess32Next;

	static THREADLISTPROC	pfnThread32First;
	static THREADLISTPROC	pfnThread32Next;

	static MODULELISTPROC	pfnModule32First;
	static MODULELISTPROC	pfnModule32Next;

// Overrides
	virtual BOOL InitInstance();
	virtual int ExitInstance();

// Implementation
private:
	static CHAR m_szSpyKey[];
	static CHAR m_szKeyDefFont[];
	static CHAR m_szKeyMainPos[];
	static CHAR m_szKeyDecodeStructs[];
	static CHAR m_szMaximizeMDI[];
	static BOOL m_bIsChicago;
	static BOOL m_bIsDaytona;

	static int m_nWinTabCur;
	static int m_nPrcTabCur;
	static int m_nThdTabCur;
	static int m_nMsgTabCur;

	//{{AFX_MSG(CSpyApp)
	afx_msg void OnAppAbout();
	afx_msg void OnSpyMessages();
	afx_msg void OnSpyMessagesDirect();
	afx_msg void OnSpyHighlightWindow();
	afx_msg void OnSpyWindows();
	afx_msg void OnSpyProcesses();
	afx_msg void OnSpyThreads();
	afx_msg void OnSpyFindWindow();
	afx_msg void OnUpdateSpyProcesses(CCmdUI *pCmdUI);
	afx_msg void OnUpdateSpyThreads(CCmdUI *pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//
// Define this to enter a mode where Spy++ will only log one occurrence
// of each message.  It changes the settings to filter out each message
// after a single one of them is logged.  This allows us to more easily
// determine what messages are not getting logged and try to ensure
// that all of our message crackers are getting exercised.
//
//#define ONESHOTFILTER

#define MIN_REGISTEREDMSG			0xC000	// Minimum registered msg value.
#define MAXLINESDEFAULT				750		// Default max msg stream lines.
#define TIMEOUT_OTHERPROCESSDATA	10000	// OtherProcessData msg timeout

//
// Maximum number of lines to keep.  Note that if this value is changed,
// the text of the IDS_MSG_INVALIDMAXLINES message MUST be updated as well!
//
#define MAXLINESMAX					20000	// Maximum max msg stream lines.

//
// Message sent to the ProcessPacket window when a hook packet needs to be
// processed.  wParam is 0, lParam is a pointer to a MSGSTREAMDATA
// structure.
//
#define WM_USER_PROCESSPACKET		(WM_USER + 111)

//
// Message group types.  These are indices into the message group table
// array for the CMsgDoc object.  If these are changed, the table must
// be updated to match!
//
#define MT_MISC		0
#define MT_DDE		1
#define MT_CLIP		2
#define MT_MOUSE	3
#define MT_NC		4
#define MT_KEYBD	5
#define MT_BM		6
#define MT_CB		7
#define MT_EM		8
#define MT_LB		9
#define MT_STM		10
#define MT_MDI		11
#define MT_SBM		12
#define MT_IME		13
#define MT_DLG		14
#ifndef DISABLE_WIN95_MESSAGES
#define MT_ANI		15
#define MT_HDR		16
#define MT_HK		17
#define MT_LV		18
#define MT_PRG		19
#define MT_STB		20
#define MT_TB		21
#define MT_TLB		22
#define MT_TAB		23
#define MT_TT		24
#define MT_TV		25
#define MT_UD		26
#endif	// DISABLE_WIN95_MESSAGES

//
// Object type defines.
//
#define OT_NONE		(-1)
#define OT_WINDOW	0
#define OT_THREAD	1
#define OT_PROCESS	2
#define OT_MESSAGE	3

//
// These are the indices to the bitmaps used for the different
// object types in the tree controls.  The order shown MUST match
// the order that the images appear from left to right in the
// IDB_FOLDERS bitmap!
//
#define IDX_WNDBITMAP		0	// Windows
#define IDX_THDBITMAP		1	// Threads
#define IDX_PRCBITMAP		2	// Processes
#define MAX_OBJECTBITMAPS	3

//
// These are the indices to the Message/Start Logging and
// Message/Stop Logging graphics in the toolbar bitmap.
// If you modify the toolbar bitmap, you MUST update these
// indices!  They need to be hardcoded numbers because
// of the way toolbars were designed.  The Start/Stop Logging
// command is one that changes its image based on its state.
//
#define INDEX_START_IMAGE	4
#define INDEX_STOP_IMAGE	18

//
// Starting offset for string resources accessed using the ids() function.
//
#define STRINGID_BASE		10000

//
// Maximum number of string resources accessed using the ids() function.
// This number should be kept low to save memory, but it must be large
// enough to cover all the string resources that will be retrieved
// using the ids() function (which start at STRINGID_BASE).
//
#define MAX_STRINGIDS		140

//
// The Message Description Table structure that describes each message
// that Spy++ understands.
//
typedef struct
{
	UINT msg;
	LPTSTR pszMsg;
	INT iMsgType;
	PFNDECODE pfnDecode;
	PFNDECODERET pfnDecodeRet;
	PFNDECODEPARM pfnDecodeParm;
} MSGDESC, *PMSGDESC;

//
// The message group structure.  A table of these structures describes
// each different group of messages that can be selected/deselected
// for viewing using the Message Filters dialog.
//
typedef struct
{
	INT idCheckBox;
	INT cMsgs;
	INT cUseCount;
} MSGGROUP, *PMSGGROUP;

//
// spy.cpp
//
extern CSpyApp theApp;
int SpyMessageBox(UINT nIDPrompt, UINT nType = MB_OK, UINT nIcon = MB_ICONEXCLAMATION);
CHAR* ids(UINT idString);
LPSTR GetExpandedClassName(LPSTR);

//
// msghook.cpp
//
void LogMsg(PMSGSTREAMDATA pmsd);
BOOL CreateHookThread(void);
BOOL SetMsgHook(BOOL fSet);
BOOL GetOtherProcessData(HWND hwnd, POTHERPROCESSDATA popd);
BOOL IsSpyableWindow(HWND hwnd);

//
// help.cpp
//
// Help type constants.  These are passed to InvokeWinHelp() and
// determine what type of help is being requested.
//
#define HELPTYPE_INDEX			0	// Index help
#define HELPTYPE_HELPONHELP		1	// Help on using help
#define HELPTYPE_CONTEXT		2	// A Spy++ help context
#define HELPTYPE_MSGHELP		3	// Help on a msg (from Win32 help)

CString GetRegString(LPCSTR szSection, LPCSTR szKey, LPCSTR szDefault = NULL);
BOOL WriteRegString(LPCSTR szSection, LPCSTR szKey, LPCSTR szVal);

//
// propinsp.cpp
//
void SetLastSelectedObject(DWORD dwObject, int nObjectType);
DWORD GetLastSelectedObject();
int GetLastSelectedObjectType();
void ChangeToLastSelectedObject();
void SetSpyImmediate(BOOL bDirect);
BOOL GetSpyImmediate();

extern CPropertyInspector* g_pInspector;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\spyxxmdi.cpp ===
// spyxxmdi.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "spyxxmdi.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSpyMDIChildWnd

IMPLEMENT_DYNCREATE(CSpyMDIChildWnd, CMDIChildWnd)

CSpyMDIChildWnd::CSpyMDIChildWnd()
{
}

CSpyMDIChildWnd::~CSpyMDIChildWnd()
{
}

BEGIN_MESSAGE_MAP(CSpyMDIChildWnd, CMDIChildWnd)
	//{{AFX_MSG_MAP(CSpyMDIChildWnd)
	ON_WM_CREATE()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL fIgnoreSizing = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CSpyMDIChildWnd message handlers

int CSpyMDIChildWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
	{
		return -1;
	}

	fIgnoreSizing = TRUE;

	return 0;
}

void CSpyMDIChildWnd::OnSize(UINT nType, int cx, int cy) 
{
	CMDIChildWnd::OnSize(nType, cx, cy);
	
	if (!fIgnoreSizing)
	{
		if (nType == SIZE_MAXIMIZED)
			theApp.m_bIsMDIMaximized = TRUE;
		else
			theApp.m_bIsMDIMaximized = FALSE;
	}
	else
		fIgnoreSizing = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\spyxxhk.c ===
//  SpyxxHk.c

#include <windows.h>

#ifndef WM_NOTIFY
// WM_NOTIFY is new in later versions of Win32
#define WM_NOTIFY 0x004e
typedef struct tagNMHDR
{
	HWND hwndFrom;
	UINT idFrom;
	UINT code;
} NMHDR;
#endif //!WM_NOTIFY

#if (WINVER < 0x400)
	#define _REDEF_WINVER
	#undef WINVER
	#define WINVER 0x0400
#endif
#include <commctrl.h>
#ifdef _REDEF_WINVER
	#undef _REDEF_WINVER
	#undef WINVER
	#define WINVER 0x030A
#endif

#include <stdlib.h>

#include "spyxxhk.h"

//
// Define this to NOT do an actual add of packets to the shared
// memory queue.  This is for testing and guarantees that the hook
// will never need to block waiting for the reader to clear room
// in the queue.
//
//#define DONTUSEQUEUE

//
// Maximum number of slots in the subclass queue.  This determines the
// maximum number of windows in a process that have been subclassed
// but have not yet had all messages processed for them.
//
#define MAXQUEUE		64

//
// Size of the message packet buffer area.
//
#define CBMSGBUFFER			 8000

typedef struct
{
	HWND hwnd;
	WNDPROC pfnPrev;
	INT cSub;
} SUBCLASSQUEUE, *PSUBCLASSQUEUE;

#ifndef WH_CALLWNDPROCRET
//
// Message structure used by WH_CALLWNDPROCRET
// defined in winuser.h in Chicago
//
typedef struct tagCWPRETSTRUCT {
	LRESULT	lResult;
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPRETSTRUCT, *PCWPRETSTRUCT, NEAR *NPCWPRETSTRUCT, FAR *LPCWPRETSTRUCT;
#endif	// WH_CALLWNDPROCRET

///////////////////////////////////////////////////////////////////////////////
// Shared memory data segment.
//
// All these variables MUST be initialized for the compiler to place them
// in the .shdata segment instead of the .BSS segment!!!
//
///////////////////////////////////////////////////////////////////////////////

#pragma data_seg(".shdata")

SPYXXHK_SHDATA BOOL gfOnChicago = FALSE;				// TRUE if the application is running on Chicago
SPYXXHK_SHDATA BOOL gfOnDaytona = FALSE;				// TRUE if the application is running on Daytona
SPYXXHK_SHDATA HHOOK ghhkMsgHook = NULL;				// hook from SetWindowsHookEx(WH_GETMESSAGE)
SPYXXHK_SHDATA HHOOK ghhkCallHook = NULL;				// hook from SetWindowsHookEx(WH_CALLWNDPROC)
SPYXXHK_SHDATA HHOOK ghhkRetHook = NULL;				// hook from SetWindowsHookEx(WH_CALLWNDPROCRET) (Chicago only)
SPYXXHK_SHDATA BOOL gfHookEnabled = 0;					// TRUE if the hook is enabled
SPYXXHK_SHDATA BOOL gfEnableSubclass = FALSE;			// TRUE if subclassing is enabled
SPYXXHK_SHDATA BOOL gfDecodeStructs = FALSE;			// TRUE if structs/strings are cracked
SPYXXHK_SHDATA UINT gcSubclass = 0;						// Count of subclassed messages
SPYXXHK_SHDATA DWORD gpidSpyxx = 0;						// Process ID of the Spy++ app
SPYXXHK_SHDATA DWORD gtidSpyxx = 0;						// Thread ID of Spy++'s main thread
SPYXXHK_SHDATA DWORD goffRead = 0;						// Read offset
SPYXXHK_SHDATA DWORD goffWrite = 0;						// Write offset
SPYXXHK_SHDATA UINT gcMsgPackets = 0;					// Count of message packets
SPYXXHK_SHDATA ATOM gaaClasses[MAXCLASSATOMS] = { 0 };	// Class atom array

//
// Message buffer area.  Be sure that there is extra room at the end
// to write a DWORD of zero so that the reader will know when to
// wrap around.  It simplifies the wrapping logic to guarantee that
// at least one more DWORD can always be written after the "end" of
// the buffer.
//
SPYXXHK_SHDATA BYTE gabMsgBuf[CBMSGBUFFER + sizeof(DWORD)] = { 0 };

//
// Variables used for obtaining data from another process
//
SPYXXHK_SHDATA UINT gmsgOtherProcessData = 0;// Registered message
SPYXXHK_SHDATA OTHERPROCESSDATA gopd = { 0 };// Structure for other process data

//
// Bring in the message encoding table.  This is in a separate file
// for readability.
//
#include "met.h"

#pragma data_seg()

///////////////////////////////////////////////////////////////////////////////
// Private (instance) memory segment
///////////////////////////////////////////////////////////////////////////////

PRIVATE HANDLE ghWriterMutex;				// Writer mutex
PRIVATE HANDLE ghAccessMutex;				// Access to data mutex
PRIVATE HANDLE ghReadEvent;					// Data was just read event
PRIVATE HANDLE ghWrittenEvent;				// Data was just written event
PRIVATE HANDLE ghOtherProcessDataEvent;		// Process data was just written event
PRIVATE UINT gcSubclassThisProcess = 0;		// Subclassed msgs for this process
PRIVATE INT gnLevel = 0;					// Message nesting level
PRIVATE CRITICAL_SECTION gcsQueue;			// Critical section for queue access
PRIVATE INT gcQueue = 0;					// High water mark of the queue
PRIVATE SUBCLASSQUEUE gascq[MAXQUEUE];		// Hwnd database queue

///////////////////////////////////////////////////////////////////////////////
// Function declarations.
///////////////////////////////////////////////////////////////////////////////

__declspec(dllexport) BOOL WINAPI DLLEntryPoint(HINSTANCE hinstDLL,	DWORD fdwReason, LPVOID lpvReserved);
LRESULT WINAPI SpyxxSubclassWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

PRIVATE UINT SubclassWnd(HWND hwnd, UINT msg);
PRIVATE BOOL AddSlot(HWND hwnd, WNDPROC pfnPrev);
PRIVATE INT UnSubclassWnd(HWND hwnd, WNDPROC *ppfnPrev);
PRIVATE VOID PostToRadar(UINT fPostType, INT nLevel, LRESULT lResult, HWND hwnd, UINT msg,
						WPARAM wParam, LPARAM lParam, DWORD time, LONG ptX, LONG ptY);
PRIVATE PBYTE GetMsgPacket(DWORD cbSize);
PRIVATE DWORD StringSizeof(LPCSTR psz, BOOL* pfLongString);
PRIVATE void StringCopy(CHAR* pszDest, LPCSTR pszSrc, DWORD cb, BOOL fLongString);
PRIVATE VOID CopyFont(PPACK_FONT ppf, HFONT hfont);

#ifdef _DEBUG
VOID dprintf(LPTSTR fmt, ...);
#endif

//-----------------------------------------------------------------------------
// DLLEntryPoint
//-----------------------------------------------------------------------------

__declspec(dllexport) BOOL WINAPI DLLEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	if (fdwReason == DLL_PROCESS_ATTACH)
	{
		ghWriterMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, WRITERMUTEXNAME);
		ghAccessMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, ACCESSMUTEXNAME);
		ghReadEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, READEVENTNAME);
		ghWrittenEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, WRITTENEVENTNAME);
		ghOtherProcessDataEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, OTHERPROCESSDATAEVENTNAME);
		InitializeCriticalSection(&gcsQueue);
	}
	else if (fdwReason == DLL_PROCESS_DETACH)
	{
		//
		// Remove the count of pending subclassed messages for this
		// process from the total count.  The local count will normally
		// be zero at this point, but if this process is abnormally
		// terminating, we MUST remove any local count from the total
		// count here or the total count will never reach zero again.
		//
		WaitForSingleObject(ghAccessMutex, INFINITE);
		gcSubclass -= gcSubclassThisProcess;
		ReleaseMutex(ghAccessMutex);

		CloseHandle(ghWriterMutex);
		CloseHandle(ghAccessMutex);
		CloseHandle(ghReadEvent);
		CloseHandle(ghWrittenEvent);
		CloseHandle(ghOtherProcessDataEvent);
		DeleteCriticalSection(&gcsQueue);
	}

	return TRUE;
}

/*****************************************************************************\
* SpyxxGetMsgProc
*
* The Get Message hook function.
*
\*****************************************************************************/

SPYXXHK_API LRESULT CALLBACK SpyxxGetMsgProc(INT nCode, WPARAM wParam, LPARAM lParam)
{
	PMSG pmsg;
	DWORD pidMsgHwnd;

	pmsg = (PMSG)lParam;

	if (nCode == HC_ACTION && wParam & PM_REMOVE && pmsg && pmsg->hwnd)
	{
		if (pmsg->message == gmsgOtherProcessData)
		{
			//
			// Double-check to be sure this isn't an old message that
			// finally got processed after we timed out.
			//
			if (pmsg->hwnd == gopd.hwnd)
			{
				CHAR szClass[128];

				GetClassName(pmsg->hwnd, szClass, sizeof(szClass) / sizeof(CHAR));

				WaitForSingleObject(ghAccessMutex, INFINITE);

				//
				// Call the Unicode or ANSI GetWindowLong depending on
				// whether the window is currently Unicode or ANSI.
				// This ensures that we do not get back a thunk.
				//
				if (IsWindowUnicode(pmsg->hwnd))
				{
					gopd.pfnWndProc = (WNDPROC)GetWindowLongW(pmsg->hwnd, GWL_WNDPROC);
				}
				else
				{
					gopd.pfnWndProc = (WNDPROC)GetWindowLongA(pmsg->hwnd, GWL_WNDPROC);
				}

				gopd.fValidWC = GetClassInfo(NULL, szClass, &gopd.wc);
				*gopd.szMenuName = 0;
				if (gopd.fValidWC)
				{
					//
					// Is there a menu name?
					//
					if (gopd.wc.lpszMenuName)
					{
						//
						// Is the menu name a string or an ordinal?
						//
						if (HIWORD(gopd.wc.lpszMenuName))
						{
							//
							// Copy the string
							//
							strcpy(gopd.szMenuName, gopd.wc.lpszMenuName);
						}
						else
						{
							//
							// Convert the ordinal into a string
							//
							*gopd.szMenuName = '#';
							_itoa((INT)LOWORD(gopd.wc.lpszMenuName), &gopd.szMenuName[1], 10);
						}
					}

					//
					// If this window is unicode, we must use the
					// unicode api to get the wndproc value, or
					// we will get back a thunk instead of the real
					// proc.
					//
					if (IsWindowUnicode(pmsg->hwnd))
					{
						gopd.wc.lpfnWndProc = (WNDPROC)GetClassLongW(pmsg->hwnd, GCL_WNDPROC);
					}
				}

				ReleaseMutex(ghAccessMutex);

				SetEvent(ghOtherProcessDataEvent);
			}

			//
			// Turn the message into a benign WM_NULL message before
			// the app gets it.
			//
			pmsg->message = WM_NULL;
			pmsg->wParam = 0;
			pmsg->lParam = 0;
		}
		else if (gfHookEnabled)
		{
			//
			// Do not log the message if it is for a Spy++ window.
			//
			GetWindowThreadProcessId(pmsg->hwnd, &pidMsgHwnd);
			if (pidMsgHwnd != gpidSpyxx)
			{
				PostToRadar(POSTTYPE_POSTED, 0, 0, pmsg->hwnd, pmsg->message,
					pmsg->wParam, pmsg->lParam, pmsg->time, pmsg->pt.x, pmsg->pt.y);
			}
		}
	}

	return CallNextHookEx(ghhkMsgHook, nCode, wParam, lParam);
}

/*****************************************************************************\
* SpyxxCallWndProc
*
* The Call Window Proc (Send Message) hook function.
*
\*****************************************************************************/

SPYXXHK_API LRESULT CALLBACK SpyxxCallWndProc(INT nCode, WPARAM wParam, LPARAM lParam)
{
	PCWPSTRUCT pcwps;
	DWORD pidMsgHwnd;
	LRESULT lRes;

	lRes = CallNextHookEx(ghhkCallHook, nCode, wParam, lParam);

	pcwps = (PCWPSTRUCT)lParam;

	if (gfHookEnabled && nCode == HC_ACTION && pcwps && pcwps->hwnd)
	{
		//
		// Do not log the message if it is for a Spy++ window,
		// or if this is a Spy++ thread sending the message.
		// If messages to Spy++ windows were logged, this would
		// immediately cause infinite recursion when Spy++ tried
		// to log a message (which could cause another message
		// to be sent, etc).
		//
		// We must also strip out messages that are being sent
		// from the Spy++ first (main) thread to a window in another
		// process.  This is necessary because trying to log
		// the message could cause a deadlock case, where the
		// second thread in Spy++ is blocked trying to send
		// a message to a window created by the first thread,
		// but the first thread is blocked here waiting for
		// the second thread to clear out some packets from
		// the message buffer queue.
		//
		GetWindowThreadProcessId(pcwps->hwnd, &pidMsgHwnd);
		if (pidMsgHwnd != gpidSpyxx && GetCurrentThreadId() != gtidSpyxx)
		{
			UINT fPostType = POSTTYPE_SENT;

			if (!gfOnChicago && gfEnableSubclass)
			{
				fPostType = SubclassWnd(pcwps->hwnd, pcwps->message);
			}

			//
			// Post the sent message information.  The return results
			// will be posted later, in the SpyxxSubclassWndProc function.
			//
			PostToRadar(fPostType, gnLevel, 0, pcwps->hwnd,
				pcwps->message, pcwps->wParam, pcwps->lParam, 0, 0, 0);
		}
	}

	return lRes;
}

/*****************************************************************************\
* SpyxxCallWndRetProc
*
* The Call Window Proc Return (Send Message return) hook function.
*
\*****************************************************************************/

SPYXXHK_API LRESULT CALLBACK SpyxxCallWndRetProc(INT nCode, WPARAM wParam, LPARAM lParam)
{
	PCWPRETSTRUCT pcwprs;
	DWORD pidMsgHwnd;
	LRESULT lRes;

	lRes = CallNextHookEx(ghhkRetHook, nCode, wParam, lParam);

	pcwprs = (PCWPRETSTRUCT)lParam;

	if (gfHookEnabled && nCode == HC_ACTION && pcwprs && pcwprs->hwnd)
	{
		//
		// Do not log the message if it is for a Spy++ window,
		// or if this is a Spy++ thread sending the message.
		// If messages to Spy++ windows were logged, this would
		// immediately cause infinite recursion when Spy++ tried
		// to log a message (which could cause another message
		// to be sent, etc).
		//
		// We must also strip out messages that are being sent
		// from the Spy++ first (main) thread to a window in another
		// process.  This is necessary because trying to log
		// the message could cause a deadlock case, where the
		// second thread in Spy++ is blocked trying to send
		// a message to a window created by the first thread,
		// but the first thread is blocked here waiting for
		// the second thread to clear out some packets from
		// the message buffer queue.
		//
		GetWindowThreadProcessId(pcwprs->hwnd, &pidMsgHwnd);
		if (pidMsgHwnd != gpidSpyxx && GetCurrentThreadId() != gtidSpyxx)
		{
			UINT fPostType = POSTTYPE_RETURN;

			//
			// Post the sent message information.  The return results
			// will be posted later, in the SpyxxSubclassWndProc function.
			//
			PostToRadar(fPostType, gnLevel, pcwprs->lResult, pcwprs->hwnd,
				pcwprs->message, pcwprs->wParam, pcwprs->lParam, 0, 0, 0);
		}
	}

	return lRes;
}

//-----------------------------------------------------------------------------
// SpyxxSubclassWndProc
//-----------------------------------------------------------------------------

LRESULT WINAPI SpyxxSubclassWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult;
	WNDPROC pfnPrev;
	INT cSub;

	cSub = UnSubclassWnd(hwnd, &pfnPrev);

	//
	// Increment the nesting level, then call the original window proc
	//
	gnLevel++;
	lResult = CallWindowProc(pfnPrev, hwnd, msg, wParam, lParam);
	gnLevel--;

	PostToRadar(POSTTYPE_RETURN, gnLevel, lResult, hwnd, msg, wParam, lParam, 0, 0, 0);

	//
	// If there are still pending messages to process, we must
	// resubclass the window now so that they are not lost.
	//
	if (cSub)
	{
		SetWindowLong(hwnd, GWL_WNDPROC, (DWORD)SpyxxSubclassWndProc);
	}

	//
	// Decrement the subclass count.
	//
	WaitForSingleObject(ghAccessMutex, INFINITE);
	gcSubclass--;
	gcSubclassThisProcess--;
	ReleaseMutex(ghAccessMutex);

	return lResult;
}

//-----------------------------------------------------------------------------
// SubclassWnd
//-----------------------------------------------------------------------------

PRIVATE UINT SubclassWnd(HWND hwnd, UINT msg)
{
	UINT fPostType = POSTTYPE_SENT;
	WNDPROC pfnPrev;

	EnterCriticalSection(&gcsQueue);

	//
	// Subclass the window.
	//
	pfnPrev = (WNDPROC)SetWindowLong(hwnd, GWL_WNDPROC, (DWORD)SpyxxSubclassWndProc);

	if (pfnPrev)
	{
		//
		// Store away the previous proc address.
		//
		if (AddSlot(hwnd, pfnPrev))
		{
			//
			// Increment the subclass counts.
			//
			WaitForSingleObject(ghAccessMutex, INFINITE);
			gcSubclass++;
			gcSubclassThisProcess++;
			ReleaseMutex(ghAccessMutex);
		}
		else
		{
			//
			// No room in the queue for the hwnd.  Unsubclass
			// the window.  Return value for this message will
			// not be available.
			//
			SetWindowLong(hwnd, GWL_WNDPROC, (DWORD)pfnPrev);
			fPostType = POSTTYPE_SENTNORETURN;
		}
	}
	else
	{
		//
		// The subclass failed for some reason.  This is
		// probably because this is a send to a window in
		// another process.  The return value will not be
		// available.
		//
		fPostType = POSTTYPE_SENTNORETURN;
	}

	LeaveCriticalSection(&gcsQueue);
	return fPostType;
}

//-----------------------------------------------------------------------------
// AddSlot
//
// Adds an entry to the subclass queue for the specified window.  If the
// window is already found in the queue, increments the count for that
// entry instead of making a new one.
//
// This routine assumes that it is called while owning the subclass queue
// critical section.
//-----------------------------------------------------------------------------

PRIVATE BOOL AddSlot(HWND hwnd, WNDPROC pfnPrev)
{
	INT i;
	PSUBCLASSQUEUE pscq;

	for (pscq = gascq, i = 0; i < gcQueue; i++, pscq++)
	{
		if (pscq->hwnd == hwnd)
		{
			//
			// The hwnd is already in the queue.  Is this the same
			// previous proc (or already subclassed)?
			//
			if (pfnPrev == SpyxxSubclassWndProc	|| pfnPrev == pscq->pfnPrev)
			{
				//
				// Update the reference count and return success.
				//
				pscq->cSub++;
				return TRUE;
			}
			else
			{
				//
				// This is a different proc from the original one.
				// Something funny is going on, so we should not allow
				// the subclass.
				//
#ifdef _DEBUG
				{
					CHAR szClass[128] = "(unknown)";

					GetClassName(hwnd, szClass, sizeof(szClass));
					dprintf("SPYXXHK:Hwnd %8.8X, class \"%s\", pfnNow %8.8X, pfnPrev %8.8X proc was changed!", hwnd, szClass, pfnPrev, pscq->pfnPrev);
					//DebugBreak();
				}
#endif
				return FALSE;
			}
		}
	}

	//
	// Did we run out of slots in the queue?
	//
	if (i == MAXQUEUE)
	{
		return FALSE;
	}

	//
	// Add a new slot at the top of the queue.
	//
	pscq->hwnd = hwnd;
	pscq->pfnPrev = pfnPrev;
	pscq->cSub = 1;
	gcQueue++;

	return TRUE;
}

//-----------------------------------------------------------------------------
// UnSubclassWnd
//-----------------------------------------------------------------------------

PRIVATE INT UnSubclassWnd(HWND hwnd, WNDPROC *ppfnPrev)
{
	INT i;
	INT cSubRet;
	PSUBCLASSQUEUE pscq;

	EnterCriticalSection(&gcsQueue);

	for (pscq = gascq, i = 0; i < gcQueue; i++, pscq++)
	{
		if (pscq->hwnd == hwnd)
		{
			pscq->cSub--;
			cSubRet = pscq->cSub;
			*ppfnPrev = pscq->pfnPrev;

			//
			// Unsubclass the window right away!
			//
			SetWindowLong(hwnd, GWL_WNDPROC, (DWORD)pscq->pfnPrev);

			//
			// Did the reference count go down to zero?
			//
			if (!cSubRet)
			{
				//
				// Are we the slot at the top of the queue?
				//
				if (i == gcQueue - 1)
				{
					//
					// Compact the queue.  The gcQueue counter is a
					// "high-water mark" that needs to be dropped
					// down to the next highest slot that is in use.
					//
					while (--gcQueue)
					{
						pscq--;

						if (pscq->hwnd)
							break;
					}
				}
				else
				{
					//
					// Just mark this slot as free.  Don't bother
					// compacting the queue right now.
					//
					pscq->hwnd = (HWND)0;
				}
			}

			LeaveCriticalSection(&gcsQueue);
			return cSubRet;
		}
	}

	//
	// We should never get to here...
	//

	LeaveCriticalSection(&gcsQueue);

#ifdef _DEBUG
	{
		CHAR szClass[128] = "(unknown)";

		GetClassName(hwnd, szClass, sizeof(szClass));
		dprintf("SPYXXHK:Hwnd %8.8X, class \"%s\" was not found in queue!", hwnd, szClass);
		DebugBreak();
	}
#endif

	*ppfnPrev = 0;
	return 0;
}

//-----------------------------------------------------------------------------
// PostToRadar
//-----------------------------------------------------------------------------

PRIVATE VOID PostToRadar(UINT fPostType, INT nLevel, LRESULT lResult, HWND hwnd, UINT msg,
						WPARAM wParam, LPARAM lParam, DWORD time, LONG ptX, LONG ptY)
{
#ifndef DONTUSEQUEUE
	PMSGSTREAMDATA pmsd;
	DWORD cbSize;
	DWORD cbExtraData = 0;
	WORD fEncoding;
	BOOL fLongString;
	BOOL fOrdinal;
	BOOL fHasExtra = FALSE;

	//
	// Only try to crack the structures and strings pointed to
	// by wParam/lParam if this is a known message, the message
	// encoding table says there is something to do and the
	// Spy++ app has enabled this feature.
	//
	if (gfDecodeStructs)
	{
		if (msg < MAX_MESSAGES)
		{
			if ((fEncoding = gmet[msg].fEncoding) != MET_NOEXTRADATA)
				fHasExtra = TRUE;
		}
		else
		{
			switch (GetWindowClass(hwnd))
			{
				case CLS_DIALOG:
					if (msg >= DM_GETDEFID && msg <= DM_SETDEFID)
						if ((fEncoding = gmetDlg[msg-WM_USER].fEncoding) != MET_NOEXTRADATA)
							fHasExtra = TRUE;
					break;
#ifndef DISABLE_WIN95_MESSAGES
				case CLS_ANIMATE:
					if (msg >= ACM_OPEN && msg <= ACM_STOP)
						if ((fEncoding = gmetAni[msg-(WM_USER+100)].fEncoding) != MET_NOEXTRADATA)
							fHasExtra = TRUE;
					break;

				case CLS_HEADER:
					if (msg >= HDM_GETITEMCOUNT && msg <= HDM_HITTEST)
						if ((fEncoding = gmetHdr[msg-HDM_FIRST].fEncoding) != MET_NOEXTRADATA)
							fHasExtra = TRUE;
					break;

				case CLS_TOOLBAR:
					if (msg >= TB_ENABLEBUTTON && msg <= TB_GETBUTTONTEXT)
						if ((fEncoding = gmetTB[msg-(WM_USER+1)].fEncoding) != MET_NOEXTRADATA)
							fHasExtra = TRUE;
					break;

				case CLS_TOOLTIP:
					if (msg >= TTM_ACTIVATE && msg <= TTM_GETCURRENTTOOL)
						if ((fEncoding = gmetTT[msg-(WM_USER+1)].fEncoding) != MET_NOEXTRADATA)
							fHasExtra = TRUE;
					break;

				case CLS_STATUSBAR:
					if (msg >= SB_SETTEXT && msg <= SB_GETRECT)
						if ((fEncoding = gmetStat[msg-(WM_USER+1)].fEncoding) != MET_NOEXTRADATA)
							fHasExtra = TRUE;
					break;

				case CLS_TRACKBAR:
					if (msg >= TBM_GETPOS && msg <= TBM_GETTHUMBLENGTH)
						if ((fEncoding = gmetTrk[msg-WM_USER].fEncoding) != MET_NOEXTRADATA)
							fHasExtra = TRUE;
					break;

				case CLS_UPDOWN:
					if (msg >= UDM_SETRANGE && msg <= UDM_GETBASE)
						if ((fEncoding = gmetUpDn[msg-(WM_USER+101)].fEncoding) != MET_NOEXTRADATA)
							fHasExtra = TRUE;
					break;

				case CLS_PROGRESS:
					if (msg >= PBM_SETRANGE && msg <= PBM_STEPIT)
						if ((fEncoding = gmetProg[msg-(WM_USER+1)].fEncoding) != MET_NOEXTRADATA)
							fHasExtra = TRUE;
					break;

				case CLS_HOTKEY:
					if (msg >= HKM_SETHOTKEY && msg <= HKM_SETRULES)
						if ((fEncoding = gmetHK[msg-(WM_USER+1)].fEncoding) != MET_NOEXTRADATA)
							fHasExtra = TRUE;
					break;

				case CLS_LISTVIEW:
					if (msg >= LVM_GETBKCOLOR && msg <= LVM_GETISEARCHSTRING)
						if ((fEncoding = gmetLV[msg-LVM_FIRST].fEncoding) != MET_NOEXTRADATA)
							fHasExtra = TRUE;
					break;

				case CLS_TREEVIEW:
					if (msg >= TVM_INSERTITEM && msg <= TVM_GETISEARCHSTRING)
						if ((fEncoding = gmetTV[msg-TV_FIRST].fEncoding) != MET_NOEXTRADATA)
							fHasExtra = TRUE;
					break;

				case CLS_TABCTRL:
					if (msg >= TCM_GETBKCOLOR && msg <= TCM_SETCURFOCUS)
						if ((fEncoding = gmetTab[msg-TCM_FIRST].fEncoding) != MET_NOEXTRADATA)
							fHasExtra = TRUE;
					break;
#endif	// DISABLE_WIN95_MESSAGES
				default:
					fHasExtra = FALSE;
					break;
			}
		}		
	}

	if (fHasExtra)
	{
		switch (fEncoding)
		{
			case MET_STRUCTRET:
				if (msg < MAX_MESSAGES)
				{
					if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmet[msg].cbExtraData))
						cbExtraData = gmet[msg].cbExtraData;
				}
				else
				{
					switch (GetWindowClass(hwnd))
					{
						case CLS_DIALOG:
							if (msg >= DM_GETDEFID && msg <= DM_SETDEFID)
								if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmetDlg[msg-WM_USER].cbExtraData))
									cbExtraData = gmetDlg[msg-WM_USER].cbExtraData;
							break;
#ifndef DISABLE_WIN95_MESSAGES
						case CLS_ANIMATE:
							if (msg >= ACM_OPEN && msg <= ACM_STOP)
								if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmetAni[msg-(WM_USER+100)].cbExtraData))
									cbExtraData = gmetAni[msg-(WM_USER+100)].cbExtraData;
							break;

						case CLS_HEADER:
							if (msg >= HDM_GETITEMCOUNT && msg <= HDM_HITTEST)
								if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmetHdr[msg-HDM_FIRST].cbExtraData))
									cbExtraData = gmetHdr[msg-HDM_FIRST].cbExtraData;
							break;

						case CLS_TOOLBAR:
							if (msg >= TB_ENABLEBUTTON && msg <= TB_GETBUTTONTEXT)
								if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmetTB[msg-(WM_USER+1)].cbExtraData))
									cbExtraData = gmetTB[msg-(WM_USER+1)].cbExtraData;
							break;

						case CLS_TOOLTIP:
							if (msg >= TTM_ACTIVATE && msg <= TTM_GETCURRENTTOOL)
								if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmetTT[msg-(WM_USER+1)].cbExtraData))
									cbExtraData = gmetTT[msg-(WM_USER+1)].cbExtraData;
							break;

						case CLS_STATUSBAR:
							if (msg >= SB_SETTEXT && msg <= SB_GETRECT)
								if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmetStat[msg-(WM_USER+1)].cbExtraData))
									cbExtraData = gmetStat[msg-(WM_USER+1)].cbExtraData;
							break;

						case CLS_TRACKBAR:
							if (msg >= TBM_GETPOS && msg <= TBM_GETTHUMBLENGTH)
								if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmetTrk[msg-WM_USER].cbExtraData))
									cbExtraData = gmetTrk[msg-WM_USER].cbExtraData;
							break;

						case CLS_UPDOWN:
							if (msg >= UDM_SETRANGE && msg <= UDM_GETBASE)
								if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmetUpDn[msg-(WM_USER+101)].cbExtraData))
									cbExtraData = gmetUpDn[msg-(WM_USER+101)].cbExtraData;
							break;

						case CLS_PROGRESS:
							if (msg >= PBM_SETRANGE && msg <= PBM_STEPIT)
								if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmetProg[msg-(WM_USER+1)].cbExtraData))
									cbExtraData = gmetProg[msg-(WM_USER+1)].cbExtraData;
							break;

						case CLS_HOTKEY:
							if (msg >= HKM_SETHOTKEY && msg <= HKM_SETRULES)
								if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmetHK[msg-(WM_USER+1)].cbExtraData))
									cbExtraData = gmetHK[msg-(WM_USER+1)].cbExtraData;
							break;

						case CLS_LISTVIEW:
							if (msg >= LVM_GETBKCOLOR && msg <= LVM_GETISEARCHSTRING)
								if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmetLV[msg-LVM_FIRST].cbExtraData))
									cbExtraData = gmetLV[msg-LVM_FIRST].cbExtraData;
							break;

						case CLS_TREEVIEW:
							if (msg >= TVM_INSERTITEM && msg <= TVM_GETISEARCHSTRING)
								if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmetTV[msg-TV_FIRST].cbExtraData))
									cbExtraData = gmetTV[msg-TV_FIRST].cbExtraData;
							break;

						case CLS_TABCTRL:
							if (msg >= TCM_GETBKCOLOR && msg <= TCM_SETCURFOCUS)
								if (fPostType == POSTTYPE_RETURN && !IsBadReadPtr((LPVOID)lParam, gmetTab[msg-TCM_FIRST].cbExtraData))
									cbExtraData = gmetTab[msg-TCM_FIRST].cbExtraData;
							break;
#endif	// DISABLE_WIN95_MESSAGES
						default:
							break;
					}
				}		
				break;

			case MET_STRUCTBOTH:
			case MET_CREATESTRUCTBOTH:
			case MET_MDICREATESTRUCTBOTH:
				if (msg < MAX_MESSAGES)
				{
					if (!IsBadReadPtr((LPVOID)lParam, gmet[msg].cbExtraData))
						cbExtraData = gmet[msg].cbExtraData;
				}
				else
				{
					switch (GetWindowClass(hwnd))
					{
						case CLS_DIALOG:
							if (msg >= DM_GETDEFID && msg <= DM_SETDEFID)
								if (!IsBadReadPtr((LPVOID)lParam, gmetDlg[msg-WM_USER].cbExtraData))
									cbExtraData = gmetDlg[msg-WM_USER].cbExtraData;
							break;
#ifndef DISABLE_WIN95_MESSAGES
						case CLS_ANIMATE:
							if (msg >= ACM_OPEN && msg <= ACM_STOP)
								if (!IsBadReadPtr((LPVOID)lParam, gmetAni[msg-(WM_USER+100)].cbExtraData))
									cbExtraData = gmetAni[msg-(WM_USER+100)].cbExtraData;
							break;

						case CLS_HEADER:
							if (msg >= HDM_GETITEMCOUNT && msg <= HDM_HITTEST)
								if (!IsBadReadPtr((LPVOID)lParam, gmetHdr[msg-HDM_FIRST].cbExtraData))
									cbExtraData = gmetHdr[msg-HDM_FIRST].cbExtraData;
							break;

						case CLS_TOOLBAR:
							if (msg >= TB_ENABLEBUTTON && msg <= TB_GETBUTTONTEXT)
								if (!IsBadReadPtr((LPVOID)lParam, gmetTB[msg-(WM_USER+1)].cbExtraData))
									cbExtraData = gmetTB[msg-(WM_USER+1)].cbExtraData;
							break;

						case CLS_TOOLTIP:
							if (msg >= TTM_ACTIVATE && msg <= TTM_GETCURRENTTOOL)
								if (!IsBadReadPtr((LPVOID)lParam, gmetTT[msg-(WM_USER+1)].cbExtraData))
									cbExtraData = gmetTT[msg-(WM_USER+1)].cbExtraData;
							break;

						case CLS_STATUSBAR:
							if (msg >= SB_SETTEXT && msg <= SB_GETRECT)
								if (!IsBadReadPtr((LPVOID)lParam, gmetStat[msg-(WM_USER+1)].cbExtraData))
									cbExtraData = gmetStat[msg-(WM_USER+1)].cbExtraData;
							break;

						case CLS_TRACKBAR:
							if (msg >= TBM_GETPOS && msg <= TBM_GETTHUMBLENGTH)
								if (!IsBadReadPtr((LPVOID)lParam, gmetTrk[msg-WM_USER].cbExtraData))
									cbExtraData = gmetTrk[msg-WM_USER].cbExtraData;
							break;

						case CLS_UPDOWN:
							if (msg >= UDM_SETRANGE && msg <= UDM_GETBASE)
								if (!IsBadReadPtr((LPVOID)lParam, gmetUpDn[msg-(WM_USER+101)].cbExtraData))
									cbExtraData = gmetUpDn[msg-(WM_USER+101)].cbExtraData;
							break;

						case CLS_PROGRESS:
							if (msg >= PBM_SETRANGE && msg <= PBM_STEPIT)
								if (!IsBadReadPtr((LPVOID)lParam, gmetProg[msg-(WM_USER+1)].cbExtraData))
									cbExtraData = gmetProg[msg-(WM_USER+1)].cbExtraData;
							break;

						case CLS_HOTKEY:
							if (msg >= HKM_SETHOTKEY && msg <= HKM_SETRULES)
								if (!IsBadReadPtr((LPVOID)lParam, gmetHK[msg-(WM_USER+1)].cbExtraData))
									cbExtraData = gmetHK[msg-(WM_USER+1)].cbExtraData;
							break;

						case CLS_LISTVIEW:
							if (msg >= LVM_GETBKCOLOR && msg <= LVM_GETISEARCHSTRING)
								if (!IsBadReadPtr((LPVOID)lParam, gmetLV[msg-LVM_FIRST].cbExtraData))
									cbExtraData = gmetLV[msg-LVM_FIRST].cbExtraData;
							break;

						case CLS_TREEVIEW:
							if (msg >= TVM_INSERTITEM && msg <= TVM_GETISEARCHSTRING)
								if (!IsBadReadPtr((LPVOID)lParam, gmetTV[msg-TV_FIRST].cbExtraData))
									cbExtraData = gmetTV[msg-TV_FIRST].cbExtraData;
							break;

						case CLS_TABCTRL:
							if (msg >= TCM_GETBKCOLOR && msg <= TCM_SETCURFOCUS)
								if (!IsBadReadPtr((LPVOID)lParam, gmetTab[msg-TCM_FIRST].cbExtraData))
									cbExtraData = gmetTab[msg-TCM_FIRST].cbExtraData;
							break;
#endif	// DISABLE_WIN95_MESSAGES
						default:
							break;
					}
				}		
				break;

			case MET_STRINGRET:
				if (msg < MAX_MESSAGES)
				{
					if (fPostType == POSTTYPE_RETURN && lParam && !IsBadStringPtr((LPVOID)lParam, (UINT)-1))
						cbExtraData = StringSizeof((LPCSTR)lParam, &fLongString);
				}
				else
				{
					switch (GetWindowClass(hwnd))
					{
						case CLS_DIALOG:
#ifndef DISABLE_WIN95_MESSAGES
						case CLS_ANIMATE:
						case CLS_HEADER:
						case CLS_TOOLBAR:
						case CLS_TOOLTIP:
						case CLS_STATUSBAR:
						case CLS_TRACKBAR:
						case CLS_UPDOWN:
						case CLS_PROGRESS:
						case CLS_HOTKEY:
						case CLS_LISTVIEW:
						case CLS_TREEVIEW:
						case CLS_TABCTRL:
#endif	// DISABLE_WIN95_MESSAGES
							if (fPostType == POSTTYPE_RETURN && lParam && !IsBadStringPtr((LPVOID)lParam, (UINT)-1))
								cbExtraData = StringSizeof((LPCSTR)lParam, &fLongString);
							break;
						default:
							break;
					}
				}		
				break;

			case MET_STRINGBOTH:
				if (msg < MAX_MESSAGES)
				{
					if (lParam && !IsBadStringPtr((LPVOID)lParam, (UINT)-1))
						cbExtraData = StringSizeof((LPCSTR)lParam, &fLongString);
				}
				else
				{
					switch (GetWindowClass(hwnd))
					{
						case CLS_DIALOG:
#ifndef DISABLE_WIN95_MESSAGES
						case CLS_ANIMATE:
						case CLS_HEADER:
						case CLS_TOOLBAR:
						case CLS_TOOLTIP:
						case CLS_STATUSBAR:
						case CLS_TRACKBAR:
						case CLS_UPDOWN:
						case CLS_PROGRESS:
						case CLS_HOTKEY:
						case CLS_LISTVIEW:
						case CLS_TREEVIEW:
						case CLS_TABCTRL:
#endif	// DISABLE_WIN95_MESSAGES
							if (lParam && !IsBadStringPtr((LPVOID)lParam, (UINT)-1))
								cbExtraData = StringSizeof((LPCSTR)lParam, &fLongString);
							break;
						default:
							break;
					}
				}		
				break;

			case MET_LBODSTRINGBOTH:
				//
				// Prepare to copy the string, but first check to be sure
				// that this is not an ownerdrawn listbox that does not
				// have strings.  This is necessary because the psz value
				// specified for these messages to this type of a listbox
				// is NOT a valid string pointer.
				//
				if (lParam && !IsBadStringPtr((LPVOID)lParam, (UINT)-1))
				{
					DWORD flStyle = GetWindowLong(hwnd, GWL_STYLE);

					if (!(flStyle & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)) || (flStyle & LBS_HASSTRINGS))
					{
						cbExtraData = StringSizeof((LPCSTR)lParam, &fLongString);
					}
				}

				break;

			case MET_CBODSTRINGBOTH:
				//
				// Prepare to copy the string, but first check to be sure
				// that this is not an ownerdrawn combobox that does not
				// have strings.  This is necessary because the psz value
				// specified for these messages to this type of a combobox
				// is NOT a valid string pointer.
				//
				if (lParam && !IsBadStringPtr((LPVOID)lParam, (UINT)-1))
				{
					DWORD flStyle = GetWindowLong(hwnd, GWL_STYLE);

					if (!(flStyle & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)) || (flStyle & CBS_HASSTRINGS))
					{
						cbExtraData = StringSizeof((LPCSTR)lParam, &fLongString);
					}
				}

				break;

			case MET_LBSTRINGORDRET:
				if (fPostType == POSTTYPE_RETURN && lParam)
				{
					DWORD flStyle = GetWindowLong(hwnd, GWL_STYLE);

					if (!(flStyle & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)) || (flStyle & LBS_HASSTRINGS))
					{
						cbExtraData = StringSizeof((LPCSTR)lParam, &fLongString);
						fOrdinal = FALSE;
					}
					else
					{
						cbExtraData = sizeof(PACK_STRINGORD);
						fOrdinal = TRUE;
					}
				}

				break;

			case MET_CBSTRINGORDRET:
				if (fPostType == POSTTYPE_RETURN && lParam)
				{
					DWORD flStyle = GetWindowLong(hwnd, GWL_STYLE);

					if (!(flStyle & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)) || (flStyle & CBS_HASSTRINGS))
					{
						cbExtraData = StringSizeof((LPCSTR)lParam, &fLongString);
						fOrdinal = FALSE;
					}
					else
					{
						cbExtraData = sizeof(PACK_STRINGORD);
						fOrdinal = TRUE;
					}
				}

				break;

			case MET_WM_NCCALCSIZEBOTH:
				//
				// Only dereference the pointer in lParam if
				// wParam (fCalcValidRects) is TRUE!
				//
				if (wParam)
				{
					LPNCCALCSIZE_PARAMS p2 = (LPNCCALCSIZE_PARAMS)lParam;

					if (!IsBadReadPtr(p2, sizeof(NCCALCSIZE_PARAMS)) && !IsBadReadPtr(p2->lppos, sizeof(WINDOWPOS)))
					{
						cbExtraData = sizeof(PACK_NCCALCSIZE);
					}
				}

				break;

			case MET_GLOBALSTRUCTBOTH:
				if (lParam)
				{
					LPBYTE pb = GlobalLock((HGLOBAL)lParam);

					if (pb)
					{
						if (msg < MAX_MESSAGES)
						{
							if (!IsBadReadPtr(pb, gmet[msg].cbExtraData))
								cbExtraData = gmet[msg].cbExtraData;
						}
						else
						{
							switch (GetWindowClass(hwnd))
							{
								case CLS_DIALOG:
									if (msg >= DM_GETDEFID && msg <= DM_SETDEFID)
										if (!IsBadReadPtr(pb, gmetDlg[msg-WM_USER].cbExtraData))
											cbExtraData = gmetDlg[msg-WM_USER].cbExtraData;
									break;
#ifndef DISABLE_WIN95_MESSAGES
								case CLS_ANIMATE:
									if (msg >= ACM_OPEN && msg <= ACM_STOP)
										if (!IsBadReadPtr(pb, gmetAni[msg-(WM_USER+100)].cbExtraData))
											cbExtraData = gmetAni[msg-(WM_USER+100)].cbExtraData;
									break;

								case CLS_HEADER:
									if (msg >= HDM_GETITEMCOUNT && msg <= HDM_HITTEST)
										if (!IsBadReadPtr(pb, gmetHdr[msg-HDM_FIRST].cbExtraData))
											cbExtraData = gmetHdr[msg-HDM_FIRST].cbExtraData;
									break;

								case CLS_TOOLBAR:
									if (msg >= TB_ENABLEBUTTON && msg <= TB_GETBUTTONTEXT)
										if (!IsBadReadPtr(pb, gmetTB[msg-(WM_USER+1)].cbExtraData))
											cbExtraData = gmetTB[msg-(WM_USER+1)].cbExtraData;
									break;

								case CLS_TOOLTIP:
									if (msg >= TTM_ACTIVATE && msg <= TTM_GETCURRENTTOOL)
										if (!IsBadReadPtr(pb, gmetTT[msg-(WM_USER+1)].cbExtraData))
											cbExtraData = gmetTT[msg-(WM_USER+1)].cbExtraData;
									break;

								case CLS_STATUSBAR:
									if (msg >= SB_SETTEXT && msg <= SB_GETRECT)
										if (!IsBadReadPtr(pb, gmetStat[msg-(WM_USER+1)].cbExtraData))
											cbExtraData = gmetStat[msg-(WM_USER+1)].cbExtraData;
									break;

								case CLS_TRACKBAR:
									if (msg >= TBM_GETPOS && msg <= TBM_GETTHUMBLENGTH)
										if (!IsBadReadPtr(pb, gmetTrk[msg-WM_USER].cbExtraData))
											cbExtraData = gmetTrk[msg-WM_USER].cbExtraData;
									break;

								case CLS_UPDOWN:
									if (msg >= UDM_SETRANGE && msg <= UDM_GETBASE)
										if (!IsBadReadPtr(pb, gmetUpDn[msg-(WM_USER+101)].cbExtraData))
											cbExtraData = gmetUpDn[msg-(WM_USER+101)].cbExtraData;
									break;

								case CLS_PROGRESS:
									if (msg >= PBM_SETRANGE && msg <= PBM_STEPIT)
										if (!IsBadReadPtr(pb, gmetProg[msg-(WM_USER+1)].cbExtraData))
											cbExtraData = gmetProg[msg-(WM_USER+1)].cbExtraData;
									break;

								case CLS_HOTKEY:
									if (msg >= HKM_SETHOTKEY && msg <= HKM_SETRULES)
										if (!IsBadReadPtr(pb, gmetHK[msg-(WM_USER+1)].cbExtraData))
											cbExtraData = gmetHK[msg-(WM_USER+1)].cbExtraData;
									break;

								case CLS_LISTVIEW:
									if (msg >= LVM_GETBKCOLOR && msg <= LVM_GETISEARCHSTRING)
										if (!IsBadReadPtr(pb, gmetLV[msg-LVM_FIRST].cbExtraData))
											cbExtraData = gmetLV[msg-LVM_FIRST].cbExtraData;
									break;

								case CLS_TREEVIEW:
									if (msg >= TVM_INSERTITEM && msg <= TVM_GETISEARCHSTRING)
										if (!IsBadReadPtr(pb, gmetTV[msg-TV_FIRST].cbExtraData))
											cbExtraData = gmetTV[msg-TV_FIRST].cbExtraData;
									break;

								case CLS_TABCTRL:
									if (msg >= TCM_GETBKCOLOR && msg <= TCM_SETCURFOCUS)
										if (!IsBadReadPtr(pb, gmetTab[msg-TCM_FIRST].cbExtraData))
											cbExtraData = gmetTab[msg-TCM_FIRST].cbExtraData;
									break;
#endif	// DISABLE_WIN95_MESSAGES
								default:
									break;
							}
						}
					}

					GlobalUnlock((HGLOBAL)lParam);
				}

				break;

			case MET_CLASSBOTH:
				//
				// Is there an hwndCtl in lParam?
				//
				if (lParam)
				{
					cbExtraData = sizeof(PACK_CLASS);
				}

				break;

			case MET_WPLPDWORDSRET:
				if (fPostType == POSTTYPE_RETURN)
				{
					cbExtraData = sizeof(PACK_WPLPDWORDS);
				}

				break;

			case MET_EM_GETLINE:
				if (fPostType == POSTTYPE_RETURN)
				{
					//
					// On return, the lResult will be the number of
					// characters copied.
					//
					int cch = (INT)lResult;

					if (cch > CCHMAXPARMSTRING)
					{
						cch = CCHMAXPARMSTRING;
					}

					if (cch > 0 && !IsBadReadPtr((LPVOID)lParam, (UINT)cch))
					{
						//
						// Allow size for the characters.
						// Don't forget room for the null.
						//
						cbExtraData = (DWORD)(cch + 1);
					}
				}
				else
				{
					//
					// The string buffer pointed to by lParam should
					// contain a WORD that is the max size of the
					// buffer.
					//
					if (!IsBadReadPtr((LPVOID)lParam, sizeof(WORD)))
					{
						cbExtraData = sizeof(WORD);
					}
				}

				break;

			case MET_INTARRAYBOTH:
				{
					//
					// The wParam has the number of ints in the buffer.
					//
					int cItems = (INT)wParam;

					if (cItems > CMAXINTARRAYITEMS)
					{
						cItems = CMAXINTARRAYITEMS;
					}

					if (cItems > 0 && !IsBadReadPtr((LPVOID)lParam, cItems * sizeof(INT)))
					{
						cbExtraData = (DWORD)(cItems * sizeof(INT));
					}
				}

				break;

			case MET_INTARRAYRET:
				if (fPostType == POSTTYPE_RETURN)
				{
					//
					// On return, the lResult will be the number of
					// items (ints) placed in the buffer, or -1 for
					// an error.
					//
					int cItems = (INT)lResult;

					if (cItems > CMAXINTARRAYITEMS)
					{
						cItems = CMAXINTARRAYITEMS;
					}

					if (cItems > 0 && !IsBadReadPtr((LPVOID)lParam, cItems * sizeof(INT)))
					{
						cbExtraData = (DWORD)(cItems * sizeof(INT));
					}
				}

				break;

			case MET_FONTBOTH:
				//
				// Be sure that the font (in wParam) is not null (which
				// indicates the system font).
				//
				if (wParam)
				{
					//
					// We will be returning a PACK_FONT structure.
					//
					cbExtraData = sizeof(PACK_FONT);
				}

				break;

			case MET_FONTRET:
				//
				// Only try and return the font on a return message
				// and be sure that the return is not null (which
				// indicates the system font).
				//
				if (fPostType == POSTTYPE_RETURN && lResult)
				{
					//
					// We will be returning a PACK_FONT structure.
					//
					cbExtraData = sizeof(PACK_FONT);
				}

				break;
		}
	}

	cbSize = sizeof(MSGSTREAMDATA) + cbExtraData;
	cbSize += (4 - (cbSize & 3)) % 4;
	pmsd = (PMSGSTREAMDATA)GetMsgPacket(cbSize);

	pmsd->cb = cbSize;
	pmsd->fPostType = fPostType;
	pmsd->nLevel = nLevel;
	pmsd->hwnd = hwnd;
	pmsd->msg = msg;
	pmsd->wParam = wParam;
	pmsd->lParam = lParam;
	pmsd->lResult = lResult;
	pmsd->time = time;
	pmsd->ptX = ptX;
	pmsd->ptY = ptY;

	if (cbExtraData)
	{
		switch (fEncoding)
		{
			case MET_STRUCTRET:
			case MET_STRUCTBOTH:
			case MET_INTARRAYBOTH:
			case MET_INTARRAYRET:
				memcpy(pmsd + 1, (BYTE*)lParam, cbExtraData);
				break;

			case MET_STRINGRET:
			case MET_STRINGBOTH:
			case MET_LBODSTRINGBOTH:
			case MET_CBODSTRINGBOTH:
				StringCopy((CHAR*)(pmsd + 1), (LPCSTR)lParam, cbExtraData, fLongString);
				break;

			case MET_LBSTRINGORDRET:
			case MET_CBSTRINGORDRET:
				if (fOrdinal)
				{
					PPACK_STRINGORD pso = (PPACK_STRINGORD)(pmsd + 1);
					pso->dwMarker = 0xFFFFFFFF;
					pso->dwOrdinal = *(PDWORD)lParam;
				}
				else
				{
					StringCopy((CHAR*)(pmsd + 1), (LPCSTR)lParam, cbExtraData, fLongString);
				}

				break;

			case MET_WM_NCCALCSIZEBOTH:
				{
					PPACK_NCCALCSIZE p = (PPACK_NCCALCSIZE)(pmsd + 1);
					LPNCCALCSIZE_PARAMS p2 = (LPNCCALCSIZE_PARAMS)lParam;
					memcpy(&p->nccp, p2, sizeof(NCCALCSIZE_PARAMS));
					memcpy(&p->wp, p2->lppos, sizeof(WINDOWPOS));
				}

				break;

			case MET_GLOBALSTRUCTBOTH:
				{
					LPBYTE pb = GlobalLock((HGLOBAL)lParam);

					if (pb)
					{
						memcpy(pmsd + 1, pb, cbExtraData);
						GlobalUnlock((HGLOBAL)lParam);
					}
				}

				break;

			case MET_CREATESTRUCTBOTH:
				{
					PPACK_CREATESTRUCT p = (PPACK_CREATESTRUCT)(pmsd + 1);
					LPCREATESTRUCT p2 = (LPCREATESTRUCT)lParam;
					DWORD cbString;
					BOOL fLS;

					memcpy(&p->cs, p2, sizeof(CREATESTRUCT));

					if (HIWORD(p2->lpszName) && !IsBadStringPtr(p2->lpszName, (UINT)-1))
					{
						cbString = StringSizeof(p2->lpszName, &fLS);
						StringCopy(p->szName, p2->lpszName, cbString, fLS);
						p->fValidName = TRUE;
					}
					else
					{
						p->fValidName = FALSE;
					}

					if (HIWORD(p2->lpszClass) && !IsBadStringPtr(p2->lpszClass, (UINT)-1))
					{
						cbString = StringSizeof(p2->lpszClass, &fLS);
						StringCopy(p->szClass, p2->lpszClass, cbString, fLS);
						p->fValidClass = TRUE;
					}
					else
					{
						p->fValidClass = FALSE;
					}
				}

				break;

			case MET_MDICREATESTRUCTBOTH:
				{
					PPACK_MDICREATESTRUCT p = (PPACK_MDICREATESTRUCT)(pmsd + 1);
					LPMDICREATESTRUCT p2 = (LPMDICREATESTRUCT)lParam;
					DWORD cbString;
					BOOL fLS;

					memcpy(&p->mdic, p2, sizeof(MDICREATESTRUCT));

					if (HIWORD(p2->szTitle) && !IsBadStringPtr(p2->szTitle, (UINT)-1))
					{
						cbString = StringSizeof(p2->szTitle, &fLS);
						StringCopy(p->szTitle, p2->szTitle, cbString, fLS);
						p->fValidTitle = TRUE;
					}
					else
					{
						p->fValidTitle = FALSE;
					}

					if (HIWORD(p2->szClass) && !IsBadStringPtr(p2->szClass, (UINT)-1))
					{
						cbString = StringSizeof(p2->szClass, &fLS);
						StringCopy(p->szClass, p2->szClass, cbString, fLS);
						p->fValidClass = TRUE;
					}
					else
					{
						p->fValidClass = FALSE;
					}
				}

				break;

			case MET_CLASSBOTH:
				{
					PPACK_CLASS p = (PPACK_CLASS)(pmsd + 1);
					p->nClass = GetWindowClass((HWND)lParam);
				}

				break;

			case MET_WPLPDWORDSRET:
				{
					PPACK_WPLPDWORDS p = (PPACK_WPLPDWORDS)(pmsd + 1);

					if (!IsBadReadPtr((PVOID)wParam, sizeof(DWORD)))
					{
						p->fValidWP = TRUE;
						p->nWP = *(PDWORD)wParam;
					}
					else
					{
						p->fValidWP = FALSE;
					}

					if (!IsBadReadPtr((PVOID)lParam, sizeof(DWORD)))
					{
						p->fValidLP = TRUE;
						p->nLP = *(PDWORD)lParam;
					}
					else
					{
						p->fValidLP = FALSE;
					}
				}

				break;

			case MET_EM_GETLINE:
				if (fPostType == POSTTYPE_RETURN)
				{
					//
					// On return, the lResult will be the number of
					// characters copied.
					//
					int cch = (INT)lResult;

					if (cch > CCHMAXPARMSTRING)
					{
						cch = CCHMAXPARMSTRING;
						fLongString = TRUE;
					}
					else
					{
						fLongString = FALSE;
					}

					//
					// Copy the characters over.  Because the data is
					// not already null terminated, we must explicitly
					// do that here as well.
					//
					StringCopy((CHAR*)(pmsd + 1), (CHAR*)lParam, cch, fLongString);
					*((CHAR*)(pmsd + 1) + cch) = 0;
				}
				else
				{
					*(WORD*)(pmsd + 1) = *(WORD*)lParam;
				}

				break;

			case MET_FONTBOTH:
				CopyFont((PPACK_FONT)(pmsd + 1), (HFONT)wParam);
				break;

			case MET_FONTRET:
				CopyFont((PPACK_FONT)(pmsd + 1), (HFONT)lResult);
				break;
		}
	}

	gcMsgPackets++;
	goffWrite = ((PBYTE)pmsd - (PBYTE)gabMsgBuf) + cbSize;

	SetEvent(ghWrittenEvent);
	ReleaseMutex(ghAccessMutex);
	ReleaseMutex(ghWriterMutex);
#endif
}

//-----------------------------------------------------------------------------
// GetMsgPacket
//
// This routine will grab the writer and access semaphores and find a
// block in the message buffer area large enough for a message packet
// of the specified size.  It will block and allow the reader to read
// some packets to free up space, if necessary.  When it returns, it
// will own both the writer and access mutexes.
//
// Note that the cbSize MUST be rounded up to a DWORD boundary for
// the packet writing mechanism to work properly!
//
// If the buffer write pointer needs to be looped back to the beginning
// of the circular buffer, a DWORD of zero will be written out before
// the loop is done.  This allows the reader to notice a packet that
// starts with a zero size, meaning that it should jump to the
// beginning of the buffer for the real next packet.
//
// Arguments:
//  DWORD cbSize - Size in bytes required for the message packet
//				 (rounded up to a DWORD boundary).
//
// Returns:
//  A pointer to an area to write the message packet.
//
//-----------------------------------------------------------------------------

PRIVATE PBYTE GetMsgPacket(DWORD cbSize)
{
	PBYTE pb;

	WaitForSingleObject(ghWriterMutex, INFINITE);
	WaitForSingleObject(ghAccessMutex, INFINITE);

	pb = gabMsgBuf + goffWrite;

	//
	// Is the packet too big to write without wrapping around?
	//
	if (pb + cbSize >= gabMsgBuf + CBMSGBUFFER)
	{
		//
		// Check if the reader is ahead of the writer
		//
		while (gcMsgPackets && pb <= gabMsgBuf + goffRead)
		{
			//
			// Be sure to allow the reader to wrap around first!
			//
			ResetEvent(ghReadEvent);
			ReleaseMutex(ghAccessMutex);
			WaitForSingleObject(ghReadEvent, INFINITE);
			WaitForSingleObject(ghAccessMutex, INFINITE);
		}

		//
		// Wrap around in the buffer
		//
		*((PDWORD)pb) = 0;
		pb = gabMsgBuf;
	}

	//
	// Loop allowing the reader to read until either there are
	// no more packets left or the reader wraps around (we already
	// guaranteed above that there is enough room up to the end
	// of the buffer, we just need to be sure the reader is out
	// of the way) or until the reader reads enough to allow the
	// new packet to be added.
	//
	while (gcMsgPackets && pb <= gabMsgBuf + goffRead && pb + cbSize > gabMsgBuf + goffRead)
	{
		//
		// Wait until enough is read by the reader
		//
		ResetEvent(ghReadEvent);
		ReleaseMutex(ghAccessMutex);
		WaitForSingleObject(ghReadEvent, INFINITE);
		WaitForSingleObject(ghAccessMutex, INFINITE);
	}

	return pb;
}

//-----------------------------------------------------------------------------
// GetWindowClass
//
//  Returns the window class that a given window has.
//
// Arguments:
//  HWND hwnd - Window to get the class of.
//
// Returns:
//  One of the CLS_* defines.  The value CLS_UNKNOWN will be returned
//  if the window is not one of the known types in the class atom table.
//
//-----------------------------------------------------------------------------

UINT GetWindowClass(HWND hwnd)
{
	UINT Class = CLS_UNKNOWN;
	ATOM aClass;
	INT i;

	aClass = (ATOM)GetClassWord(hwnd, GCW_ATOM);
	if (aClass)
	{
		//
		// Search the array for this atom.
		//
		for (i = 0; i < MAXCLASSATOMS; i++)
		{
			if (aClass == gaaClasses[i])
			{
				Class = i;
				break;
			}
		}
	}

	return Class;
}

//-----------------------------------------------------------------------------
// StringSizeof
//
//  Returns the length of the specified string.
//
// Arguments:
//  LPCSTR psz		  - The string to get the size of.
//  BOOL* pfLongString  - Flag to set to TRUE or FALSE depending on the length.
//
// Returns:
//  The size of the string in bytes, including room for the null
//  terminator.  If the string is longer than CCHMAXPARMSTRING, it
//  will set pfLongString to TRUE and return a size as if the string
//  were truncated at CCHMAXPARMSTRING.  If not, it will set pfLongString
//  to FALSE.
//
//-----------------------------------------------------------------------------

PRIVATE DWORD StringSizeof(LPCSTR psz, BOOL* pfLongString)
{
	DWORD cch = strlen(psz);

	if (cch > CCHMAXPARMSTRING)
	{
		cch = CCHMAXPARMSTRING;
		*pfLongString = TRUE;
	}
	else
	{
		*pfLongString = FALSE;
	}

	return (cch + 1) * sizeof(CHAR);
}

//-----------------------------------------------------------------------------
// StringCopy
//
//  Copies a string.  If the string is too long (specified by the
//  fLongString flag) then the end of the string is set to "..."
//  and it is null terminated.  If fLongString is FALSE, it is
//  assumed that cb bytes should be copied and that this is enough
//  to copy the null.
//
// Arguments:
//  CHAR* pszDest	- The destination buffer.
//  LPCSTR pszSrc	- The source string.
//  DWORD cb		 - The length of the string in bytes.
//  BOOL fLongString - TRUE if the string was too long, FALSE otherwise.
//
//-----------------------------------------------------------------------------

PRIVATE void StringCopy(CHAR* pszDest, LPCSTR pszSrc, DWORD cb, BOOL fLongString)
{
	memcpy(pszDest, pszSrc, cb);

	if (fLongString)
	{
		pszDest[cb - 4] = '.';
		pszDest[cb - 3] = '.';
		pszDest[cb - 2] = '.';
		pszDest[cb - 1] = 0;
	}
}

//-----------------------------------------------------------------------------
// CopyFont
//
// Given a font, gets the facename and pointsize for it and fills
// the specified PACK_FONT structure with the information.  If an
// error occurs, the nHeight field of the PACK_FONT structure
// will be set to -1.
//
// Arguments:
//  PPACK_FONT ppf - Pointer to the PACK_FONT structure to fill.
//  HFONT hfont	- The font handle.
//
//-----------------------------------------------------------------------------

PRIVATE VOID CopyFont(PPACK_FONT ppf, HFONT hfont)
{
	TEXTMETRIC tm;
	HDC hdc;
	HFONT hfontOld;

	//
	// Assume the worst...
	//
	ppf->nHeight = -1;

	//
	// We need a DC for the GetTextxxx calls below.
	//
	if (hdc = GetDC(NULL))
	{
		hfontOld = SelectObject(hdc, hfont);

		//
		// Grab the text face name and put it in the specified buffer.
		//
		if (GetTextFace(hdc, LF_FACESIZE, ppf->szFaceName))
		{
			if (GetTextMetrics(hdc, &tm))
			{
				//
				// Finally, grab the height and set the nHeight field.
				// We are done except for cleanup at this point.
				//
				ppf->nHeight = tm.tmHeight - tm.tmInternalLeading;
			}
		}

		SelectObject(hdc, hfontOld);
		ReleaseDC(NULL, hdc);
	}
}

#ifdef _DEBUG
/****************************************************************************
* dprintf
*
* This debugging function prints out a string to the debug output.
* An optional set of substitutional parameters can be specified,
* and the final output will be the processed result of these combined
* with the format string, just like printf.  A newline is always
* output after every call to this function.
*
* Arguments:
*   LPTSTR fmt - Format string (printf style).
*   ...		- Variable number of arguments.
*
* History:
*  28-Aug-1990  Byron Dazey - Created
****************************************************************************/

#undef dprintf

VOID dprintf(LPTSTR fmt, ...)
{
	va_list marker;
	TCHAR szBuf[256];
	INT len;

	va_start(marker, fmt);
	len = wvsprintf(szBuf, fmt, marker);
	va_end(marker);

	szBuf[len++] = TEXT('\r');
	szBuf[len++] = TEXT('\n');
	szBuf[len] = 0;

	OutputDebugString(szBuf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\spyxxmdi.h ===
// spyxxmdi.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSpyMDIChildWnd frame

class CSpyMDIChildWnd : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CSpyMDIChildWnd)
protected:
	CSpyMDIChildWnd();           // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSpyMDIChildWnd)
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CSpyMDIChildWnd();

	// Generated message map functions
	//{{AFX_MSG(CSpyMDIChildWnd)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\srchdlgs.cpp ===
// srchdlgs.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "findtool.h"
#include "srchdlgs.h"
#include "spytreed.h"
#include "treectl.h"
#include "spytreec.h"
#include "wndnode.h"
#include "wndtreed.h"
#include "prctreed.h"
#include "thdtreed.h"
#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSearchWindowDlg dialog

CSearchWindowDlg::CSearchWindowDlg(CWnd *pParentWnd) : CDialog(CSearchWindowDlg::IDD, pParentWnd)
{
	//{{AFX_DATA_INIT(CSearchWindowDlg)
	//}}AFX_DATA_INIT
}

CSearchWindowDlg::~CSearchWindowDlg()
{
}

void CSearchWindowDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSearchWindowDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSearchWindowDlg, CDialog)
	//{{AFX_MSG_MAP(CSearchWindowDlg)
	ON_BN_CLICKED(IDC_SEARCH_FW_HIDESPY, OnClickedHide)
	ON_EN_KILLFOCUS(IDC_SEARCH_FW_ENTERHWND, VerifyEnteredHwnd)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchWindowDlg message handlers

BOOL CSearchWindowDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	CFont* pFont = GetStdFont(font_Normal);
	ASSERT(pFont);
	HFONT hfont = (HFONT)pFont->m_hObject;

	SendDlgItemMessage(IDC_SEARCH_FW_ENTERHWND, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_SEARCH_FW_ENTERCAPTION, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_SEARCH_FW_ENTERCLASS, WM_SETFONT, (WPARAM)hfont, FALSE);

// begin special font mucking-around
	if (_getmbcp() != 0)
	{
		pFont = GetStdFont(font_Fixed);
		ASSERT(pFont);
		hfont = (HFONT)pFont->m_hObject;

		SendDlgItemMessage(IDC_SEARCH_FW_ENTERCAPTION, WM_SETFONT, (WPARAM)hfont, FALSE);
		SendDlgItemMessage(IDC_SEARCH_FW_ENTERCLASS, WM_SETFONT, (WPARAM)hfont, FALSE);
	}
// end special font mucking-around

	m_FindToolIcon.SubclassDlgItem(IDC_SEARCH_FW_FINDTOOL, this);
	m_FindToolIcon.Initialize(this);

	SetSelectedWindow(m_hwndSelected);
	SetDlgItemText(IDC_SEARCH_FW_ENTERCAPTION, m_strCaption);
	SetDlgItemText(IDC_SEARCH_FW_ENTERCLASS, m_strClass);
	m_wSearchFlags = 0;

	// set default direction of search
	CheckRadioButton(IDC_SEARCH_FW_UPDIRECTION, IDC_SEARCH_FW_DOWNDIRECTION,
		m_fSearchUp ? IDC_SEARCH_FW_UPDIRECTION :IDC_SEARCH_FW_DOWNDIRECTION);

	return TRUE;  // return TRUE unless you set the focus to a control
}


void CSearchWindowDlg::OnOK()
{
	HWND hwndSelected;
	CHAR szHwnd[9];
	CHAR szTemp[256];

	if (GetDlgItemText(IDC_SEARCH_FW_ENTERHWND, szHwnd, sizeof(szHwnd)))
	{
		hwndSelected = (HWND)_tcstoul(szHwnd, NULL, 16);
		m_hwndSelected = hwndSelected;
		m_wSearchFlags = SRCHFLAG_WINDOW_USEHANDLE;

		// Restore the Spy app if necessary.
		if (IsDlgButtonChecked(IDC_SEARCH_FW_HIDESPY))
		{
			theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
			CheckDlgButton(IDC_SEARCH_FW_HIDESPY, 0);
		}

		// check direction of search
		if (IsDlgButtonChecked(IDC_SEARCH_FW_UPDIRECTION))
			m_fSearchUp = TRUE;
		else
			m_fSearchUp = FALSE;

		CDialog::OnOK();

	}
	else if (GetDlgItemText(IDC_SEARCH_FW_ENTERCAPTION, szTemp, sizeof(szTemp)))
	{
		m_strCaption = szTemp;
		m_wSearchFlags = SRCHFLAG_WINDOW_USECAPTION;

		// Restore the Spy app if necessary.
		if (IsDlgButtonChecked(IDC_SEARCH_FW_HIDESPY))
		{
			theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
			CheckDlgButton(IDC_SEARCH_FW_HIDESPY, 0);
		}

		// check direction of search
		if (IsDlgButtonChecked(IDC_SEARCH_FW_UPDIRECTION))
			m_fSearchUp = TRUE;
		else
			m_fSearchUp = FALSE;

		CDialog::OnOK();
	}
	else if (GetDlgItemText(IDC_SEARCH_FW_ENTERCLASS, szTemp, sizeof(szTemp)))
	{
		m_strClass = szTemp;
		m_wSearchFlags = SRCHFLAG_WINDOW_USECLASS;

		// Restore the Spy app if necessary.
		if (IsDlgButtonChecked(IDC_SEARCH_FW_HIDESPY))
		{
			theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
			CheckDlgButton(IDC_SEARCH_FW_HIDESPY, 0);
		}

		// check direction of search
		if (IsDlgButtonChecked(IDC_SEARCH_FW_UPDIRECTION))
			m_fSearchUp = TRUE;
		else
			m_fSearchUp = FALSE;

		CDialog::OnOK();
	}
	else
	{
		SpyMessageBox(IDS_NO_VALID_WND_SRCH);
		GotoDlgCtrl(GetDlgItem(IDC_SEARCH_FW_ENTERHWND));
	}
}


void CSearchWindowDlg::OnCancel()
{
	// Restore the Spy app if necessary.
	if (IsDlgButtonChecked(IDC_SEARCH_FW_HIDESPY))
	{
		theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
		CheckDlgButton(IDC_SEARCH_FW_HIDESPY, 0);
	}

	CDialog::OnCancel();
}


void CSearchWindowDlg::SetSelectedWindow(HWND hwndSelected)
{
	CHAR sz[256];
	LPSTR lpszClass;
	int cch;

	if (::IsWindow(hwndSelected))
	{
		wsprintf(sz, "%08X", hwndSelected);
		SetDlgItemText(IDC_SEARCH_FW_ENTERHWND, sz);

		sz[0] = '"';
		cch = ::GetWindowText(hwndSelected, &sz[1], 256 - 2);
		sz[cch + 1] = '"';
		sz[cch + 2] = 0;
		SetDlgItemText(IDC_SEARCH_FW_ENTERCAPTION, sz);

		::GetClassName(hwndSelected, sz, 256);
		if ((lpszClass = GetExpandedClassName(sz)) != NULL)
			_tcscat(sz, lpszClass);
		SetDlgItemText(IDC_SEARCH_FW_ENTERCLASS, sz);
	}
	else
	{
		SetDlgItemText(IDC_SEARCH_FW_ENTERHWND, "");
		SetDlgItemText(IDC_SEARCH_FW_ENTERCAPTION, "");
		SetDlgItemText(IDC_SEARCH_FW_ENTERCLASS, "");
	}
}


void CSearchWindowDlg::VerifyEnteredHwnd()
{
	HWND hwndSelected;
	CHAR szHwnd[9];
	CHAR sz[256];
	LPSTR lpszClass;
	int cch;

	// if user didn't clear out control, check that the contents are a valid HWND
	if (GetDlgItemText(IDC_SEARCH_FW_ENTERHWND, szHwnd, sizeof(szHwnd)) > 0)
	{
		hwndSelected = (HWND)_tcstoul(szHwnd, NULL, 16);	// assume user entered HWND in hex

		if (::IsWindow(hwndSelected))
		{
			sz[0] = '"';
			cch = ::GetWindowText(hwndSelected, &sz[1], 256 - 2);
			sz[cch + 1] = '"';
			sz[cch + 2] = 0;
			SetDlgItemText(IDC_SEARCH_FW_ENTERCAPTION, sz);

			::GetClassName(hwndSelected, sz, 256);
			if ((lpszClass = GetExpandedClassName(sz)) != NULL)
				_tcscat(sz, lpszClass);
			SetDlgItemText(IDC_SEARCH_FW_ENTERCLASS, sz);
		}
		else
		{
			SetDlgItemText(IDC_SEARCH_FW_ENTERCAPTION, "");
			SetDlgItemText(IDC_SEARCH_FW_ENTERCLASS, "");
		}
	}
}


void CSearchWindowDlg::BeginFindWindowTracking()
{
	SetSelectedWindow((HWND)NULL);
	m_hwndFound = NULL;
}


void CSearchWindowDlg::UpdateFindWindowTracking(HWND hwndFound)
{
	SetSelectedWindow(hwndFound);
	m_hwndFound = hwndFound;
}


void CSearchWindowDlg::EndFindWindowTracking()
{
	if (m_hwndFound)
		m_hwndSelected = m_hwndFound;
}


void CSearchWindowDlg::OnClickedHide()
{
	if (IsDlgButtonChecked(IDC_SEARCH_FW_HIDESPY))
	{
		theApp.m_pMainWnd->ShowWindow(SW_HIDE);
	}
	else
	{
		theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSearchProcessDlg dialog

CSearchProcessDlg::CSearchProcessDlg(CWnd *pParentWnd) : CDialog(CSearchProcessDlg::IDD, pParentWnd)
{
	//{{AFX_DATA_INIT(CSearchProcessDlg)
	//}}AFX_DATA_INIT
}

CSearchProcessDlg::~CSearchProcessDlg()
{
}

void CSearchProcessDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSearchProcessDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSearchProcessDlg, CDialog)
	//{{AFX_MSG_MAP(CSearchProcessDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchProcessDlg message handlers

BOOL CSearchProcessDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	CFont* pFont = GetStdFont(font_Normal);
	ASSERT(pFont);
	HFONT hfont = (HFONT)pFont->m_hObject;

	SendDlgItemMessage(IDC_SEARCH_FP_ENTERPROCESS, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_SEARCH_FP_ENTERMODULE, WM_SETFONT, (WPARAM)hfont, FALSE);

// begin special font mucking-around
	if (_getmbcp() != 0)
	{
		pFont = GetStdFont(font_Fixed);
		ASSERT(pFont);
		hfont = (HFONT)pFont->m_hObject;

		SendDlgItemMessage(IDC_SEARCH_FP_ENTERMODULE, WM_SETFONT, (WPARAM)hfont, FALSE);
	}
// end special font mucking-around

	if (m_dwPrcSelected != -1)
	{
		CHAR sz[10];
		wsprintf(sz, "%08X", m_dwPrcSelected);
		SetDlgItemText(IDC_SEARCH_FP_ENTERPROCESS, sz);
	}
	SetDlgItemText(IDC_SEARCH_FP_ENTERMODULE, m_strModule);
	m_wSearchFlags = 0;

	// set default direction of search
	CheckRadioButton(IDC_SEARCH_FP_UPDIRECTION, IDC_SEARCH_FP_DOWNDIRECTION,
		m_fSearchUp ? IDC_SEARCH_FP_UPDIRECTION :IDC_SEARCH_FP_DOWNDIRECTION);

	return TRUE;  // return TRUE unless you set the focus to a control
}


void CSearchProcessDlg::OnOK()
{
	CHAR szTemp[256];

	if (GetDlgItemText(IDC_SEARCH_FP_ENTERPROCESS, szTemp, sizeof(szTemp)))
	{
		m_wSearchFlags = SRCHFLAG_PROCESS_USEPROCESS;
		m_dwPrcSelected = (DWORD)_tcstoul(szTemp, NULL, 16);
	}
	else if (GetDlgItemText(IDC_SEARCH_FP_ENTERMODULE, szTemp, sizeof(szTemp)))
	{
		m_wSearchFlags = SRCHFLAG_PROCESS_USEMODULE;
		m_strModule = szTemp;
	}
	else
	{
		SpyMessageBox(IDS_NO_VALID_PRC_SRCH);
		GotoDlgCtrl(GetDlgItem(IDC_SEARCH_FP_ENTERPROCESS));
	}

	// check direction of search
	if (IsDlgButtonChecked(IDC_SEARCH_FP_UPDIRECTION))
		m_fSearchUp = TRUE;
	else
		m_fSearchUp = FALSE;

	CDialog::OnOK();
}


void CSearchProcessDlg::OnCancel()
{
	CDialog::OnCancel();
}


/////////////////////////////////////////////////////////////////////////////
// CSearchThreadDlg dialog

CSearchThreadDlg::CSearchThreadDlg(CWnd *pParentWnd) : CDialog(CSearchThreadDlg::IDD, pParentWnd)
{
	//{{AFX_DATA_INIT(CSearchThreadDlg)
	//}}AFX_DATA_INIT
}

CSearchThreadDlg::~CSearchThreadDlg()
{
}

void CSearchThreadDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSearchThreadDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSearchThreadDlg, CDialog)
	//{{AFX_MSG_MAP(CSearchThreadDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchThreadDlg message handlers

BOOL CSearchThreadDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	CFont* pFont = GetStdFont(font_Normal);
	ASSERT(pFont);
	HFONT hfont = (HFONT)pFont->m_hObject;

	SendDlgItemMessage(IDC_SEARCH_FT_ENTERTHREAD, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_SEARCH_FT_ENTERMODULE, WM_SETFONT, (WPARAM)hfont, FALSE);

// begin special font mucking-around
	if (_getmbcp() != 0)
	{
		pFont = GetStdFont(font_Fixed);
		ASSERT(pFont);
		hfont = (HFONT)pFont->m_hObject;

		SendDlgItemMessage(IDC_SEARCH_FT_ENTERMODULE, WM_SETFONT, (WPARAM)hfont, FALSE);
	}
// end special font mucking-around

	if (m_dwThdSelected != -1)
	{
		CHAR sz[10];
		wsprintf(sz, "%08X", m_dwThdSelected);
		SetDlgItemText(IDC_SEARCH_FT_ENTERTHREAD, sz);
	}
	SetDlgItemText(IDC_SEARCH_FT_ENTERMODULE, m_strModule);
	m_wSearchFlags = 0;

	// set default direction of search
	CheckRadioButton(IDC_SEARCH_FT_UPDIRECTION, IDC_SEARCH_FT_DOWNDIRECTION,
		m_fSearchUp ? IDC_SEARCH_FT_UPDIRECTION :IDC_SEARCH_FT_DOWNDIRECTION);

	return TRUE;  // return TRUE unless you set the focus to a control
}


void CSearchThreadDlg::OnOK()
{
	CHAR szTemp[256];

	if (GetDlgItemText(IDC_SEARCH_FT_ENTERTHREAD, szTemp, sizeof(szTemp)))
	{
		m_wSearchFlags = SRCHFLAG_THREAD_USETHREAD;
		m_dwThdSelected = (DWORD)_tcstoul(szTemp, NULL, 16);
	}
	else if (GetDlgItemText(IDC_SEARCH_FT_ENTERMODULE, szTemp, sizeof(szTemp)))
	{
		m_wSearchFlags = SRCHFLAG_THREAD_USEMODULE;
		m_strModule = szTemp;
	}
	else
	{
		SpyMessageBox(IDS_NO_VALID_THD_SRCH);
		GotoDlgCtrl(GetDlgItem(IDC_SEARCH_FT_ENTERTHREAD));
	}

	// check direction of search
	if (IsDlgButtonChecked(IDC_SEARCH_FT_UPDIRECTION))
		m_fSearchUp = TRUE;
	else
		m_fSearchUp = FALSE;

	CDialog::OnOK();
}


void CSearchThreadDlg::OnCancel()
{
	CDialog::OnCancel();
}


/////////////////////////////////////////////////////////////////////////////
// CSearchMessageDlg dialog

CSearchMessageDlg::CSearchMessageDlg(CWnd *pParentWnd) : CDialog(CSearchMessageDlg::IDD, pParentWnd)
{
	//{{AFX_DATA_INIT(CSearchMessageDlg)
	//}}AFX_DATA_INIT
}

CSearchMessageDlg::~CSearchMessageDlg()
{
}

void CSearchMessageDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSearchMessageDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSearchMessageDlg, CDialog)
	//{{AFX_MSG_MAP(CSearchMessageDlg)
	ON_BN_CLICKED(IDC_SEARCH_FM_HIDESPY, OnClickedHide)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchMessageDlg message handlers

BOOL CSearchMessageDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	CFont* pFont = GetStdFont(font_Normal);
	ASSERT(pFont);
	HFONT hfont = (HFONT)pFont->m_hObject;

	SendDlgItemMessage(IDC_SEARCH_FM_ENTERHWND, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_SEARCH_FM_SELECTTYPE, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_SEARCH_FM_SELECTMSG, WM_SETFONT, (WPARAM)hfont, FALSE);

	m_FindToolIcon.SubclassDlgItem(IDC_SEARCH_FM_FINDTOOL, this);
	m_FindToolIcon.Initialize(this);

	SetSelectedWindow(m_hwndSelected);
	m_wSearchFlags = 0;

	CComboBox *pMsgsComboBox = (CComboBox*)GetDlgItem(IDC_SEARCH_FM_SELECTMSG);
	PMSGDESC pmd;
	int i;

	for (i = 0, pmd = CMsgDoc::m_aMsgDesc; i < CMsgDoc::m_cMsgs; i++, pmd++)
	{
		int iSel = pMsgsComboBox->AddString(pmd->pszMsg);
		pMsgsComboBox->SetItemDataPtr(iSel, pmd);

		if (m_wMsgSelected && pmd->msg == m_wMsgSelected)
			pMsgsComboBox->SetCurSel(iSel);
	}

	CComboBox *pTypeComboBox = (CComboBox*)GetDlgItem(IDC_SEARCH_FM_SELECTTYPE);

	// this assumes that ordering of POSTTYPE_* constants do not change!
	for (i = IDS_POSTTYPE_POSTED; i <= IDS_POSTTYPE_RETURN; i++)
	{
		pTypeComboBox->AddString(ids(i));
	}
	pTypeComboBox->SetCurSel(m_uTypeSelected);

	// set default direction of search
	CheckRadioButton(IDC_SEARCH_FM_UPDIRECTION, IDC_SEARCH_FM_DOWNDIRECTION,
		m_fSearchUp ? IDC_SEARCH_FM_UPDIRECTION :IDC_SEARCH_FM_DOWNDIRECTION);

	return TRUE;  // return TRUE unless you set the focus to a control
}


void CSearchMessageDlg::OnOK()
{
	HWND hwndSelected;
	CHAR szHwnd[9];
	CHAR szTmp[32];
	int iSel;

	if (GetDlgItemText(IDC_SEARCH_FM_ENTERHWND, szHwnd, sizeof(szHwnd)))
	{
		hwndSelected = (HWND)_tcstoul(szHwnd, NULL, 16);
		m_hwndSelected = hwndSelected;
		m_wSearchFlags = SRCHFLAG_MESSAGE_USEHANDLE;

		if (GetDlgItemText(IDC_SEARCH_FM_SELECTMSG, szTmp, sizeof(szTmp)))
		{
			CComboBox *pMsgsComboBox = (CComboBox*)GetDlgItem(IDC_SEARCH_FM_SELECTMSG);
			if ((iSel = pMsgsComboBox->GetCurSel()) != CB_ERR)
			{
				PMSGDESC pmd = (PMSGDESC)pMsgsComboBox->GetItemDataPtr(iSel);

				m_wMsgSelected = pmd->msg;
				m_wSearchFlags |= SRCHFLAG_MESSAGE_USEMSG;
			}
		}

		if (GetDlgItemText(IDC_SEARCH_FM_SELECTTYPE, szTmp, sizeof(szTmp)))
		{
			CComboBox *pTypeComboBox = (CComboBox*)GetDlgItem(IDC_SEARCH_FM_SELECTTYPE);
			if ((iSel = pTypeComboBox->GetCurSel()) != CB_ERR)
			{
				// this assumes that ordering of POSTTYPE_* constants do not change!
				m_uTypeSelected = iSel;
				m_wSearchFlags |= SRCHFLAG_MESSAGE_USEPOSTTYPE;
			}
		}

		// Restore the Spy app if necessary.
		if (IsDlgButtonChecked(IDC_SEARCH_FM_HIDESPY))
		{
			theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
			CheckDlgButton(IDC_SEARCH_FM_HIDESPY, 0);
		}

		// check direction of search
		if (IsDlgButtonChecked(IDC_SEARCH_FM_UPDIRECTION))
			m_fSearchUp = TRUE;
		else
			m_fSearchUp = FALSE;

		CDialog::OnOK();
	}
	else if (GetDlgItemText(IDC_SEARCH_FM_SELECTMSG, szTmp, sizeof(szTmp)))
	{
		CComboBox *pMsgsComboBox = (CComboBox*)GetDlgItem(IDC_SEARCH_FM_SELECTMSG);
		if ((iSel = pMsgsComboBox->GetCurSel()) != CB_ERR)
		{
			PMSGDESC pmd = (PMSGDESC)pMsgsComboBox->GetItemDataPtr(iSel);

			m_wMsgSelected = pmd->msg;
			m_wSearchFlags = SRCHFLAG_MESSAGE_USEMSG;

			if (GetDlgItemText(IDC_SEARCH_FM_SELECTTYPE, szTmp, sizeof(szTmp)))
			{
				CComboBox *pTypeComboBox = (CComboBox*)GetDlgItem(IDC_SEARCH_FM_SELECTTYPE);
				if ((iSel = pTypeComboBox->GetCurSel()) != CB_ERR)
				{
					// this assumes that ordering of POSTTYPE_* constants do not change!
					m_uTypeSelected = iSel;
					m_wSearchFlags |= SRCHFLAG_MESSAGE_USEPOSTTYPE;
				}
			}

			// Restore the Spy app if necessary.
			if (IsDlgButtonChecked(IDC_SEARCH_FM_HIDESPY))
			{
				theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
				CheckDlgButton(IDC_SEARCH_FM_HIDESPY, 0);
			}

			// check direction of search
			if (IsDlgButtonChecked(IDC_SEARCH_FM_UPDIRECTION))
				m_fSearchUp = TRUE;
			else
				m_fSearchUp = FALSE;

			CDialog::OnOK();
		}
		else
		{
			SpyMessageBox(IDS_NO_VALID_MSG_SRCH);
			GotoDlgCtrl(GetDlgItem(IDC_SEARCH_FM_ENTERHWND));
		}
	}
	else if (GetDlgItemText(IDC_SEARCH_FM_SELECTTYPE, szTmp, sizeof(szTmp)))
	{
		CComboBox *pTypeComboBox = (CComboBox*)GetDlgItem(IDC_SEARCH_FM_SELECTTYPE);
		if ((iSel = pTypeComboBox->GetCurSel()) != CB_ERR)
		{
			// this assumes that ordering of POSTTYPE_* constants do not change!
			m_uTypeSelected = iSel;
			m_wSearchFlags = SRCHFLAG_MESSAGE_USEPOSTTYPE;

			// Restore the Spy app if necessary.
			if (IsDlgButtonChecked(IDC_SEARCH_FM_HIDESPY))
			{
				theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
				CheckDlgButton(IDC_SEARCH_FM_HIDESPY, 0);
			}

			// check direction of search
			if (IsDlgButtonChecked(IDC_SEARCH_FM_UPDIRECTION))
				m_fSearchUp = TRUE;
			else
				m_fSearchUp = FALSE;

			CDialog::OnOK();
		}
		else
		{
			SpyMessageBox(IDS_NO_VALID_MSG_SRCH);
			GotoDlgCtrl(GetDlgItem(IDC_SEARCH_FM_ENTERHWND));
		}
	}
	else
	{
		SpyMessageBox(IDS_NO_VALID_MSG_SRCH);
		GotoDlgCtrl(GetDlgItem(IDC_SEARCH_FM_ENTERHWND));
	}
}


void CSearchMessageDlg::OnCancel()
{
	// Restore the Spy app if necessary.
	if (IsDlgButtonChecked(IDC_SEARCH_FM_HIDESPY))
	{
		theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
		CheckDlgButton(IDC_SEARCH_FM_HIDESPY, 0);
	}

	CDialog::OnCancel();
}

void CSearchMessageDlg::SetSelectedWindow(HWND hwndSelected)
{
	CHAR sz[256];

	if (::IsWindow(hwndSelected))
	{
		wsprintf(sz, "%08X", hwndSelected);
		SetDlgItemText(IDC_SEARCH_FM_ENTERHWND, sz);
	}
	else
	{
		SetDlgItemText(IDC_SEARCH_FM_ENTERHWND, "");
	}
}


void CSearchMessageDlg::BeginFindWindowTracking()
{
	SetSelectedWindow((HWND)NULL);
	m_hwndTrack = NULL;
}


void CSearchMessageDlg::UpdateFindWindowTracking(HWND hwndFound)
{
	SetSelectedWindow(hwndFound);
	m_hwndTrack = hwndFound;
}


void CSearchMessageDlg::EndFindWindowTracking()
{
	if (m_hwndTrack)
		m_hwndSelected = m_hwndTrack;
}


void CSearchMessageDlg::OnClickedHide()
{
	if (IsDlgButtonChecked(IDC_SEARCH_FM_HIDESPY))
	{
		theApp.m_pMainWnd->ShowWindow(SW_HIDE);
	}
	else
	{
		theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\spyxxhk.h ===
//-----------------------------------------------------------------------------
//  SpyxxHk.h
//
//  Copyright (C) 1993, Microsoft Corporation
//
//  Purpose:
//
//  Spy++ message hook DLL header file.
//
//  Revision History:
//
//  04/26/93 byrond	 Created.
//
//-----------------------------------------------------------------------------

#ifndef __SPYXXHK_H__
#define __SPYXXHK_H__

//
// This header is used by both C and C++ programs.  All interfaces
// must therefore be in C.
//
#ifdef __cplusplus
extern "C" {
#endif


#define PUBLIC
#ifndef _DEBUG
#define PRIVATE static
#else
#define PRIVATE
#endif

#ifdef SPYXXHK_DLL
#define SPYXXHK_API		__declspec(dllexport)
#define SPYXXHK_SHDATA	__declspec(dllexport)
#else
#define SPYXXHK_API		__declspec(dllimport)
#define SPYXXHK_SHDATA	__declspec(dllimport)
#endif


//
// Signature for the main window in Spy++.  This is part of the
// mechanism that ensures there is only one copy of Spy++ running.
// Versions of Spy++ that use the same signature will not allow
// themselves to be run simultaneously.
//
#define SPYXX_WINDOW_SIGNATURE		0x12feeb76

//
// The startup mutex is the other part of the mechanism that ensures
// that only one compatible copy of Spy++ is running.  It should
// be changed if and only if the window signature above is also
// changed.
//
#define STARTUPMUTEXNAME			"SpyxxStartupSyncMutex"


//
// Object names that are in the global namespace and are used
// to communicate between the hook (running in many different
// processes) and the Spy++ application.  These objects should
// be renamed for a different version of Spy++ only if running
// other versions simultaneously with the new version is
// allowed.  Or, to put it another way, these object names
// can remain the same only if the next version of Spy++
// will not be allowed to run at the same time.
//
#define WRITERMUTEXNAME				"Spy++ Writer Mutex"
#define ACCESSMUTEXNAME				"Spy++ Access Mutex"
#define READEVENTNAME				"Spy++ Read Event"
#define WRITTENEVENTNAME			"Spy++ Written Event"
#define OTHERPROCESSDATAEVENTNAME	"Spy++ Other Process Data Event"


#define POSTTYPE_POSTED			0	// Msg was posted
#define POSTTYPE_SENT			1	// Msg was sent
#define POSTTYPE_SENTNORETURN	2	// Msg was sent (no return available)
#define POSTTYPE_RETURN			3	// Return value from a send



//
// Maximum characters of a string that is a parameter that will be
// passed back in the queue.  Strings longer than this will be
// truncated when displayed.  Buffers allocated using this constant
// should add 1 for the null terminator.
//
#define CCHMAXPARMSTRING		50


//
// Maximum number of ints that will be passed back in an int array.
// Some messages (like LB_GETSELITEMS) have lParams that point to
// an array of ints.  We want to limit the max number of these ints
// that will be passed in the queue to Spy++ to display.
//
#define CMAXINTARRAYITEMS		25


//
// Message encoding table structure
//
typedef struct
{
	WORD fEncoding;			// Encoding flags (MET_*)
	WORD cbExtraData;		// Optional size of extra data
} MSGENCODETABLE;


//
// Message encoding table flags.  These describe what extra data needs
// to be grabbed by the hook and where it is located.
//
// Some messages only have valid data after the call (on the return).
// These types of messages will specify "RET" at the end to signify
// this.  The hook will only grab the data on return type messages.
// An example of this is WM_GETTEXT, where the buffer pointed to by
// lParam contains garbage until the callee fills it in with the string
// on the return, for instance.
//
// Unless specified otherwise, all these types access data pointed to
// by lParam.
//
#define MET_NOEXTRADATA			0	// No extra data in wParam/lParam
#define MET_STRUCTRET			1	// Pointer to struct (only valid on ret)
#define MET_STRUCTBOTH			2	// Pointer to struct (valid both ways)
#define MET_STRINGRET			3	// Pointer to string (only valid on ret)
#define MET_STRINGBOTH			4	// Pointer to string (valid both ways)
#define MET_LBODSTRINGBOTH		5	// Listbox owner-draw string message
#define MET_CBODSTRINGBOTH		6	// Combobox owner-draw string message
#define MET_LBSTRINGORDRET		7	// Listbox str or ord (only valid on ret)
#define MET_CBSTRINGORDRET		8	// Combobox str or ord (only valid on ret)
#define MET_WM_NCCALCSIZEBOTH	9	// WM_NCCALCSIZE message
#define MET_GLOBALSTRUCTBOTH	10	// Pointer to struct (use GlobalLock)
#define MET_CREATESTRUCTBOTH	11	// CREATESTRUCT struct (valid both ways)
#define MET_MDICREATESTRUCTBOTH	12	// MDICREATESTRUCT struct (valid both ways)
#define MET_CLASSBOTH			13	// Get class in hook (valid both ways)
#define MET_WPLPDWORDSRET		14	// wp and lp can point to dwords (on ret)
#define MET_EM_GETLINE			15	// EM_GETLINE message
#define MET_INTARRAYBOTH		16	// lParam is ptr to int array (valid both ways)
#define MET_INTARRAYRET			17	// lParam is ptr to int array on return
#define MET_FONTBOTH			18	// lParam is hfont (valid both ways)
#define MET_FONTRET				19	// lResult is hfont (only valid on ret)



//
// Class atom types.  CLS_UNKNOWN is a special value if the class
// is not one of the known types.  The other entries are indices
// into the class atom array.
//
#define CLS_UNKNOWN		999

#define CLS_BUTTON		0
#define CLS_COMBOBOX	1
#define CLS_EDIT		2
#define CLS_LISTBOX		3
#define CLS_MDICLIENT	4
#define CLS_SCROLLBAR	5
#define CLS_STATIC		6
#define CLS_DIALOG		7
#ifndef DISABLE_WIN95_MESSAGES
#define CLS_ANIMATE		8
#define CLS_HEADER		9
#define CLS_TOOLBAR		10
#define CLS_TOOLTIP		11
#define CLS_STATUSBAR	12
#define CLS_TRACKBAR	13
#define CLS_UPDOWN		14
#define CLS_PROGRESS	15
#define CLS_HOTKEY		16
#define CLS_LISTVIEW	17
#define CLS_TREEVIEW	18
#define CLS_TABCTRL		19
#endif	// DISABLE_WIN95_MESSAGES

//
// Number of entries in the class atom array.  This must be
// updated if more CLS_* class atom types are defined!
// Also, the code that initializes this array must be updated
// if new types are defined as well.
//
#ifndef DISABLE_WIN95_MESSAGES
#define MAXCLASSATOMS	20
#else	// DISABLE_WIN95_MESSAGES
#define MAXCLASSATOMS	8
#endif	// DISABLE_WIN95_MESSAGES


//
// Maximum reserved messages in windows.
//
#define MAX_MESSAGES	WM_USER

//
// Maximum messages in windows.
//
#define MAX_DLG_MESSAGES	2
#ifndef DISABLE_WIN95_MESSAGES
#define MAX_ANI_MESSAGES	3
#define MAX_HDR_MESSAGES	7
#define MAX_TB_MESSAGES		45
#define MAX_TT_MESSAGES		15
#define MAX_STAT_MESSAGES	10
#define MAX_TRK_MESSAGES	29
#define MAX_UD_MESSAGES		10
#define MAX_PROG_MESSAGES	5
#define MAX_HK_MESSAGES		3
#define MAX_LV_MESSAGES		53
#define MAX_TV_MESSAGES		24
#define MAX_TAB_MESSAGES	49
#endif	// DISABLE_WIN95_MESSAGES

//
// Message type flags used when classifying a message for printing.
//
enum MSGTYPE
{
	MT_NORMAL,			// A normal message (found in the table).
	MT_DIALOG,			// dialog message (DM_GETDEFID, DM_SETDEFID)
#ifndef DISABLE_WIN95_MESSAGES
	MT_ANIMATE,			// Chicago animation control
	MT_HEADER,			// Chicago header control
	MT_HOTKEY,			// Chicago hotkey control
	MT_LISTVIEW,		// Chicago list-view control
	MT_PROGRESS,		// Chicago progress gauge control
	MT_STATUSBAR,		// Chicago status-bar control
	MT_TOOLBAR,			// Chicago tool-bar control
	MT_TRACKBAR,		// Chicago track-bar control
	MT_TABCTRL,			// Chicago tab control
	MT_TOOLTIP,			// Chicago tool-tip control
	MT_TREEVIEW,		// Chicago tree-view control
	MT_UPDOWN,			// Chicago up-down (spinner) control
#endif	// DISABLE_WIN95_MESSAGES
	MT_USER,			// A WM_USER message.
	MT_UNDOCUMENTED,	// An unknown message (below WM_USER).
	MT_REGISTERED		// A message in the registered msg range.
};

//
// Structure that contains the message data sent from the hook
// to the app to display.  This structure is what is packed into
// the queue by the hook, and the data remains in this form until
// it is actually logged in a message stream view, at which time
// it gets converted to a MSGSTREAMDATA2 structure.  Note that
// this means that all the message and return crackers deal with
// the data in this form (but not the parameter crackers).
//
// The Spy++ app code that receives the hook packets explicitly
// looks for the cb field as the first DWORD in the packet, so
// that field MUST remain as the first DWORD in this structure!
//
typedef struct
{
	DWORD cb;			// Total size, including extra data
	UINT fPostType;
	INT nLevel;
	HWND hwnd;
	UINT msg;
	WPARAM wParam;
	LPARAM lParam;
	LRESULT lResult;
	DWORD time;
	LONG ptX;			// component part of POINT portion of MSG structure
	LONG ptY;			// component part of POINT portion of MSG structure
	//
	// Message specific data may follow.
	//
} MSGSTREAMDATA, *PMSGSTREAMDATA;


//
// Structure that describes a message once the message has been
// logged in a message stream view.  Note that this means that all
// the message parameter crackers deal with the data in this form.
//
typedef struct
{
	UINT fPostType;
	INT nLevel;
	HWND hwnd;
	UINT msg;
	WPARAM wParam;
	LPARAM lParam;
	LRESULT lResult;
	enum MSGTYPE mtMsgType;
	DWORD cbExtraData;	// Size of any extra data (or 0)
	PBYTE pbExtraData;	// Pointer to extra data (or NULL)
} MSGSTREAMDATA2, *PMSGSTREAMDATA2;


//
// Maximum size of a message packet
//
#define CBMSGPACKETMAX	(sizeof(MSGSTREAMDATA) + 260)


//
// Structure used to obtain data from within the context of another
// process
//
typedef struct
{
	HWND hwnd;				// Window we are interested in
	WNDPROC pfnWndProc;		// Window proc for hwnd
	BOOL fValidWC;			// TRUE if the wc data is valid
	WNDCLASS wc;			// WNDCLASS from GetClassInfo
	CHAR szMenuName[128];	// Menu name from GetClassInfo
} OTHERPROCESSDATA, *POTHERPROCESSDATA;



//
// Following are structures used for packing parameters into the
// queue for different messages that have extra data.
//

//
// Used for WM_NCCALCSIZE.  It starts with room for a NCCALCSIZE_PARAMS
// structure. This structure has a pointer to a WINDOWPOS structure in it,
// so we need room to tack that on the end as well.
//
typedef struct
{
	NCCALCSIZE_PARAMS nccp;
	WINDOWPOS wp;
} PACK_NCCALCSIZE, *PPACK_NCCALCSIZE;

//
// Used for strings that can be ordinals as well.  This structure can
// be overlaid on a string.  If the dwMarker field is 0xFFFFFFFF, then
// the dwOrdinal value is the ordinal.  Otherwise, the buffer it was
// overlaid on is really a null-terminated string.
//
typedef struct
{
	DWORD dwMarker;
	DWORD dwOrdinal;
} PACK_STRINGORD, *PPACK_STRINGORD;

//
// Used for WM_CREATE.  It starts with room for a CREATESTRUCT
// structure. This structure has two string pointers in it, to
// the text and the class.  Allow the max string room for these
// as well.
//
typedef struct
{
	CREATESTRUCT cs;
	BOOL fValidName;
	CHAR szName[CCHMAXPARMSTRING + 1];
	BOOL fValidClass;
	CHAR szClass[CCHMAXPARMSTRING + 1];
} PACK_CREATESTRUCT, *PPACK_CREATESTRUCT;

//
// Used for WM_MDICREATE.  It starts with room for a MDICREATESTRUCT
// structure. This structure has two string pointers in it, to
// the text and the class.  Allow the max string room for these
// as well.
//
typedef struct
{
	MDICREATESTRUCT mdic;
	BOOL fValidClass;
	CHAR szClass[CCHMAXPARMSTRING + 1];
	BOOL fValidTitle;
	CHAR szTitle[CCHMAXPARMSTRING + 1];
} PACK_MDICREATESTRUCT, *PPACK_MDICREATESTRUCT;

//
// Used for messages that need to know the class of the window.
// The class needs to be queried in the hook (otherwise the
// window may disappear by the time the Spy++ app decoding
// code gets called).  The nClass field will contain one of
// the CLS_* defines.
//
typedef struct
{
	UINT nClass;
} PACK_CLASS, *PPACK_CLASS;

//
// Used for messages where wParam and lParam can be null or can point
// to dwords.  This includes SBM_GETRANGE and CB_GETEDITSEL.
//
typedef struct
{
	BOOL fValidWP;
	DWORD nWP;
	BOOL fValidLP;
	DWORD nLP;
} PACK_WPLPDWORDS, *PPACK_WPLPDWORDS;

//
// Used for messages that set/get the font.  This includes WM_GETFONT
// and WM_SETFONT.  The nHeight field will be -1 if the structure
// contents are invalid.  The nHeight field is not the actual point
// size, but rather it is the pixel height of the font that can be used
// later to calculate the point size using the following formula:
// nPointSize = MulDiv(nHeight, 72, cyLogPixelsPerInch);
//
typedef struct
{
	INT nHeight;
	CHAR szFaceName[LF_FACESIZE];
} PACK_FONT, *PPACK_FONT;



extern SPYXXHK_SHDATA BOOL gfOnChicago;				// TRUE if the application is running on Chicago
extern SPYXXHK_SHDATA BOOL gfOnDaytona;				// TRUE if the application is running on Daytona
extern SPYXXHK_SHDATA HHOOK ghhkMsgHook;			// hook from SetWindowsHookEx(WH_GETMESSAGE)
extern SPYXXHK_SHDATA HHOOK ghhkCallHook;			// hook from SetWindowsHookEx(WH_CALLWNDPROC)
extern SPYXXHK_SHDATA HHOOK ghhkRetHook;			// hook from SetWindowsHookEx(WH_CALLWNDPROCRET) (Chicago only)
extern SPYXXHK_SHDATA BOOL gfHookEnabled;			// TRUE if the hook is enabled
extern SPYXXHK_SHDATA BOOL gfEnableSubclass;		// TRUE if subclassing is enabled
extern SPYXXHK_SHDATA BOOL gfDecodeStructs;			// TRUE if structs/strings are cracked
extern SPYXXHK_SHDATA UINT gcSubclass;				// Count of subclassed messages
extern SPYXXHK_SHDATA DWORD gpidSpyxx;				// Process ID of the Spy++ app
extern SPYXXHK_SHDATA DWORD gtidSpyxx;				// Thread ID of Spy++'s main thread
extern SPYXXHK_SHDATA DWORD goffRead;				// Read offset
extern SPYXXHK_SHDATA DWORD goffWrite;				// Write offset
extern SPYXXHK_SHDATA UINT gcMsgPackets;			// Count of message packets
extern SPYXXHK_SHDATA ATOM gaaClasses[];			// Class atom array
extern SPYXXHK_SHDATA BYTE gabMsgBuf[];				// Message buffer area
extern SPYXXHK_SHDATA UINT gmsgOtherProcessData;	// Registered message
extern SPYXXHK_SHDATA OTHERPROCESSDATA gopd;		// Structure for other process data
extern SPYXXHK_SHDATA MSGENCODETABLE gmet[];		// Message encoding table
extern SPYXXHK_SHDATA MSGENCODETABLE gmetDlg[];		// Message encoding table
#ifndef DISABLE_WIN95_MESSAGES
extern SPYXXHK_SHDATA MSGENCODETABLE gmetAni[];		// Message encoding table
extern SPYXXHK_SHDATA MSGENCODETABLE gmetBL[];		// Message encoding table
extern SPYXXHK_SHDATA MSGENCODETABLE gmetHdr[];		// Message encoding table
extern SPYXXHK_SHDATA MSGENCODETABLE gmetTB[];		// Message encoding table
extern SPYXXHK_SHDATA MSGENCODETABLE gmetTT[];		// Message encoding table
extern SPYXXHK_SHDATA MSGENCODETABLE gmetStat[];	// Message encoding table
extern SPYXXHK_SHDATA MSGENCODETABLE gmetTrk[];		// Message encoding table
extern SPYXXHK_SHDATA MSGENCODETABLE gmetUpDn[];	// Message encoding table
extern SPYXXHK_SHDATA MSGENCODETABLE gmetProg[];	// Message encoding table
extern SPYXXHK_SHDATA MSGENCODETABLE gmetHK[];		// Message encoding table
extern SPYXXHK_SHDATA MSGENCODETABLE gmetLV[];		// Message encoding table
extern SPYXXHK_SHDATA MSGENCODETABLE gmetTV[];		// Message encoding table
extern SPYXXHK_SHDATA MSGENCODETABLE gmetTab[];		// Message encoding table
#endif	// DISABLE_WIN95_MESSAGES


SPYXXHK_API LRESULT CALLBACK SpyxxGetMsgProc(INT hc, WPARAM wParam, LPARAM lParam);
SPYXXHK_API LRESULT CALLBACK SpyxxCallWndProc(INT hc, WPARAM wParam, LPARAM lParam);
SPYXXHK_API LRESULT CALLBACK SpyxxCallWndRetProc(INT hc, WPARAM wParam, LPARAM lParam);

SPYXXHK_API UINT GetWindowClass(HWND hwnd);

#ifdef __cplusplus
}
#endif

#endif	// __SPYXXHK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\srchdlgs.h ===
// srchdlgs.h : header file
//

class CFindWindowDlg;
class CSearchWindowDlg;
class CSearchProcessDlg;
class CSearchThreadDlg;
class CSearchMessageDlg;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchWindowDlg window

class CSearchWindowDlg : public CDialog
{
// Construction
public:
	CSearchWindowDlg(CWnd *pParentWnd = NULL);

// Dialog Data
	//{{AFX_DATA(CSearchWindowDlg)
	enum { IDD = IDD_SEARCH_FINDWINDOW };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CSearchWindowDlg();
	HWND GetSelectedHwnd()
	{
		return(m_hwndSelected);
	}
	WORD GetSearchFlags()
	{
		return(m_wSearchFlags);
	}
	CString GetCaption()
	{
		return(m_strCaption);
	}
	CString GetClass()
	{
		return(m_strClass);
	}
	BOOL GetDirection()
	{
		return(m_fSearchUp);
	}

	void SetWindow(HWND hwndSet)
	{
		m_hwndSelected = hwndSet;
	}
	void SetCaption(CString strSet)
	{
		m_strCaption = strSet;
	}
	void SetClass(CString strSet)
	{
		m_strClass = strSet;
	}
	void SetDirection(BOOL fSearchUp)
	{
		m_fSearchUp = fSearchUp;
	}

protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	void SetSelectedWindow(HWND hwndSelected);

	void BeginFindWindowTracking();
	void UpdateFindWindowTracking(HWND hwndFound);
	void EndFindWindowTracking();

	HWND m_hwndSelected;
	HWND m_hwndFound;
	CFindToolIcon m_FindToolIcon;

	// data variables use in searching
	WORD 	m_wSearchFlags;
	CString	m_strCaption;
	CString m_strClass;
	BOOL	m_fSearchUp;	// TRUE if searching up, FALSE if searching down (from dialog)

	// Generated message map functions
protected:
	//{{AFX_MSG(CSearchWindowDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnClickedHide();
	afx_msg void VerifyEnteredHwnd();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	friend class CFindToolIcon;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchProcessDlg window

class CSearchProcessDlg : public CDialog
{
// Construction
public:
	CSearchProcessDlg(CWnd *pParentWnd = NULL);

// Dialog Data
	//{{AFX_DATA(CSearchProcessDlg)
	enum { IDD = IDD_SEARCH_FINDPROCESS };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CSearchProcessDlg();
	DWORD GetSelectedProcess()
	{
		return(m_dwPrcSelected);
	}
	WORD GetSearchFlags()
	{
		return(m_wSearchFlags);
	}
	CString GetModule()
	{
		return(m_strModule);
	}
	BOOL GetDirection()
	{
		return(m_fSearchUp);
	}

	void SetSelectedProcess(DWORD dwPrcSelected)
	{
		m_dwPrcSelected = dwPrcSelected;
	}
	void SetModule(CString strSet)
	{
		m_strModule = strSet;
	}
	void SetDirection(BOOL fSearchUp)
	{
		m_fSearchUp = fSearchUp;
	}

protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	DWORD m_dwPrcSelected;

	// data variables use in searching
	WORD 	m_wSearchFlags;
	CString	m_strModule;
	BOOL	m_fSearchUp;	// TRUE if searching up, FALSE if searching down (from dialog)

	// Generated message map functions
protected:
	//{{AFX_MSG(CSearchProcessDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchThreadDlg window

class CSearchThreadDlg : public CDialog
{
// Construction
public:
	CSearchThreadDlg(CWnd *pParentWnd = NULL);

// Dialog Data
	//{{AFX_DATA(CSearchThreadDlg)
	enum { IDD = IDD_SEARCH_FINDTHREAD };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CSearchThreadDlg();
	DWORD GetSelectedThread()
	{
		return(m_dwThdSelected);
	}
	WORD GetSearchFlags()
	{
		return(m_wSearchFlags);
	}
	CString GetModule()
	{
		return(m_strModule);
	}
	BOOL GetDirection()
	{
		return(m_fSearchUp);
	}

	void SetSelectedThread(DWORD dwThdSelected)
	{
		m_dwThdSelected = dwThdSelected;
	}
	void SetModule(CString strSet)
	{
		m_strModule = strSet;
	}
	void SetDirection(BOOL fSearchUp)
	{
		m_fSearchUp = fSearchUp;
	}

protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	DWORD m_dwThdSelected;

	// data variables use in searching
	WORD	m_wSearchFlags;
	CString	m_strModule;
	BOOL	m_fSearchUp;	// TRUE if searching up, FALSE if searching down (from dialog)

	// Generated message map functions
protected:
	//{{AFX_MSG(CSearchThreadDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchMessageDlg window

class CSearchMessageDlg : public CDialog
{
// Construction
public:
	CSearchMessageDlg(CWnd *pParentWnd = NULL);

// Dialog Data
	//{{AFX_DATA(CSearchMessageDlg)
	enum { IDD = IDD_SEARCH_FINDMESSAGE };
	//}}AFX_DATA

// Implementation
public:
	virtual ~CSearchMessageDlg();
	HWND GetWindow()
	{
		return(m_hwndSelected);
	}
	WORD GetMessage()
	{
		return(m_wMsgSelected);
	}
	WORD GetType()
	{
		return(m_uTypeSelected);
	}
	WORD GetSearchFlags()
	{
		return(m_wSearchFlags);
	}
	BOOL GetDirection()
	{
		return(m_fSearchUp);
	}

	void SetWindow(HWND hwndSelected)
	{
		m_hwndSelected = hwndSelected;
	}
	void SetMessage(WORD wMsgSelected)
	{
		m_wMsgSelected = wMsgSelected;
	}
	void SetType(UINT uTypeSelected)
	{
		m_uTypeSelected = uTypeSelected;
	}
	void SetDirection(BOOL fSearchUp)
	{
		m_fSearchUp = fSearchUp;
	}

protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	void SetSelectedWindow(HWND hwndSelected);

	void BeginFindWindowTracking();
	void UpdateFindWindowTracking(HWND hwndFound);
	void EndFindWindowTracking();

	HWND m_hwndTrack;
	HWND m_hwndSelected;
	CFindToolIcon m_FindToolIcon;

	// data variables use in searching
	WORD	m_wSearchFlags;
	WORD	m_wMsgSelected;
	UINT	m_uTypeSelected;
	BOOL	m_fSearchUp;	// TRUE if searching up, FALSE if searching down (from dialog)

	// Generated message map functions
protected:
	//{{AFX_MSG(CSearchMessageDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnClickedHide();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	friend class CFindToolIcon;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\stbmsgs.cpp ===
//-----------------------------------------------------------------------------
//  StbMsgs.cpp
//
//  Status bar (Chicago control) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static VALUETABLE tblSTBGetText[] =
{
	TABLEENTRY(SBT_NOBORDERS),
	TABLEENTRY(SBT_POPOUT),
	TABLEENTRY(SBT_OWNERDRAW),
	TABLEEND
};

#ifndef DISABLE_WIN95_MESSAGES
//////////////////////////////////////////////////////////////////////////////

DECODE(SB_SETTEXT)
{
	PARM(iPart, BYTE, LOWP);
	PARM(uType, BYTE, HIWP);
	PARM(szText, LPSTR, LP);

	POUTC(iPart, BYTE);
	POUTC(uType, BYTE);
	POUTC(szText, DWORD);

	return TRUE;
}

DECODERET(SB_SETTEXT)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(SB_SETTEXT);
	// REVIEW: ownerdraw text returns different value

//////////////////////////////////////////////////////////////////////////////

DECODE(SB_GETTEXT)
{
	PARM(iPart, INT, WP);
	PARM(szText, LPSTR, LP);

	POUT(iPart);
	POUTC(szText, DWORD);

	return TRUE;
}

DECODERET(SB_GETTEXT)
{
	PARM(nLength, INT, LORET);
	PARM(type, INT, HIRET);

	POUT(nLength);
	TABLEORVALUE(tblSTBGetText, type);

	// REVIEW: ownerdraw text returns different value

	return TRUE;
}

NODECODEPARM(SB_GETTEXT);
	// REVIEW: ownerdraw text returns different value

//////////////////////////////////////////////////////////////////////////////

DECODE(SB_GETTEXTLENGTH)
{
	PARM(iPart, INT, WP);
	POUT(iPart);

	return TRUE;
}

DECODERET(SB_GETTEXTLENGTH)
{
	PARM(nLength, INT, LORET);
	PARM(type, INT, HIRET);

	POUT(nLength);
	TABLEORVALUE(tblSTBGetText, type);

	return TRUE;
}

NODECODEPARM(SB_GETTEXTLENGTH);

//////////////////////////////////////////////////////////////////////////////

DECODE(SB_SETPARTS)
{
	PARM(nParts, INT, WP);
	PARM(aWidths, LPINT, LP);

	POUT(nParts);
	POUTC(aWidths, DWORD);

	return TRUE;
}

DECODERET(SB_SETPARTS)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(SB_SETPARTS);

//////////////////////////////////////////////////////////////////////////////

DECODE(SB_GETPARTS)
{
	PARM(nParts, INT, WP);
	PARM(aRightCoord, LPINT, LP);

	POUT(nParts);
	POUTC(aRightCoord, DWORD);

	return TRUE;
}

DECODERET(SB_GETPARTS)
{
	PARM(nParts, INT, RET);
	POUT(nParts);

	return TRUE;
}

NODECODEPARM(SB_GETPARTS);

//////////////////////////////////////////////////////////////////////////////

DECODE(SB_GETBORDERS)
{
	PARM(aBorders, LPINT, LP);
	POUTC(aBorders, DWORD);

	return TRUE;
}

DECODERET(SB_GETBORDERS)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(SB_GETBORDERS);

//////////////////////////////////////////////////////////////////////////////

DECODE(SB_SETMINHEIGHT)
{
	PARM(minHeight, INT, WP);
	POUT(minHeight);

	return TRUE;
}

NODECODERET(SB_SETMINHEIGHT);

NODECODEPARM(SB_SETMINHEIGHT);

//////////////////////////////////////////////////////////////////////////////

DECODE(SB_SIMPLE)
{
	PARM(fSimple, BOOL, WP);
	POUTB(fSimple);

	return TRUE;
}

DECODERET(SB_SIMPLE)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(SB_SIMPLE);

//////////////////////////////////////////////////////////////////////////////

DECODE(SB_GETRECT)
{
	PARM(iPart, INT, WP);
	PARM(lprc, LPRECT, LP);

	POUT(iPart);
	POUTC(lprc, DWORD);

	return TRUE;
}

DECODERET(SB_GETRECT)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(SB_GETRECT)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(lprc, LPRECT, ED2);
		INDENT();
		P2OUT(lprc, left);
		P2OUT(lprc, top);
		P2OUT(lprc, right);
		P2OUT(lprc, bottom);
	}
}

//////////////////////////////////////////////////////////////////////////////
#endif	// DISABLE_WIN95_MESSAGES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\statmsgs.cpp ===
//-----------------------------------------------------------------------------
//  StatMsgs.cpp
//
//  Static control message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////

NODECODE(STM_GETICON);

DECODERET(STM_GETICON)
{
	PARM(hicon, HICON, RET);

	POUTC(hicon, DWORD);

	return TRUE;
}

NODECODEPARM(STM_GETICON);

//////////////////////////////////////////////////////////////////////////////

DECODE(STM_SETICON)
{
	PARM(hicon, HICON, WP);

	POUTC(hicon, DWORD);

	return TRUE;
}

DECODERET(STM_SETICON)
{
	PARM(hiconPrevious, HICON, RET);

	POUTC(hiconPrevious, DWORD);

	return TRUE;
}

NODECODEPARM(STM_SETICON);

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\stdafx.h ===
// stdafx.h : include file for standard system include files,
//		or project specific include files that are used
//		frequently, but are changed infrequently
//

#define VC_EXTRALEAN
#define NO_ANSIUNI_ONLY


#include <afxwin.h>		// MFC core and standard components
#include <afxext.h>		// MFC extensions

//include these two since VC_EXTRALEAN removes then but they are needed.
#include <winreg.h>
#include <winnls.h>

#include <malloc.h>		
#include <afxole.h>
#include <afxpriv.h>	// MFC private definitions (like WM_COMMANDHELP)
#include <mbctype.h>
#include <tchar.h>
#include <ctl3d.h>		// 3-D dialog controls
#include <winperf.h>	// performance registry access defines
#include <commctrl.h>	// comm controls (Windows95 new controls)
#include "tlhelp32.h"	// ToolHelp32 APIs (Windows95 process/thread info)

#include "resource.h"
#include "spyxxhk.h"
#include "ime32.h"		// should get this from a common global project!
#include "mstream.h"
#include "msgcrack.h"
#include "tabdlg.h"
#include "prfdb.h"
#include "procdb.h"
#include "property.h"
#include "propinsp.h"
#include "spyxx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\srchtabs.h ===
// srchtabs.h : header file
//


class CSearchTabbedDialog;
class CSearchGeneralDlgTab;
class CSearchWindowDlgTab;
class CSearchProcessDlgTab;
class CSearchThreadDlgTab;
class CSearchMessageDlgTab;

/////////////////////////////////////////////////////////////////////////////
// CSearchTabbedDialog window

class CSearchTabbedDialog : public CTabbedDialog
{
// Construction
public:
	CSearchTabbedDialog(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectTab = -1)
		: CTabbedDialog(nIDCaption, pParentWnd, iSelectTab) {}

// Implementation
public:
	virtual ~CSearchTabbedDialog();

	// Generated message map functions
protected:
	//{{AFX_MSG(CSearchTabbedDialog)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CSearchGeneralDlgTab;
	friend class CSearchWindowDlgTab;
	friend class CSearchProcessDlgTab;
	friend class CSearchThreadDlgTab;
	friend class CSearchMessageDlgTab;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchObjectDlgTab window

class CSearchObjectDlgTab : public CDlgTab
{
// Construction
public:
	CSearchObjectDlgTab(UINT nIDTemplate, UINT nIDCaption)
		: CDlgTab(nIDTemplate, nIDCaption) {}

// Implementation
public:
	virtual ~CSearchObjectDlgTab();
	DWORD GetSelectedObject()
	{
		return(m_dwObjSelected);
	}

	void SetSelectedObject(DWORD dwObjSelected)
	{
		m_dwObjSelected = dwObjSelected;
	}

protected:
	virtual BOOL ValidateTab();
	virtual void CommitTab();

	DWORD m_dwObjSelected;

	// Generated message map functions
protected:
	//{{AFX_MSG(CSearchObjectDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	friend class CSearchTabbedDialog;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchWindowDlgTab window

class CSearchWindowDlgTab : public CDlgTab
{
// Construction
public:
	CSearchWindowDlgTab(UINT nIDTemplate, UINT nIDCaption)
		: CDlgTab(nIDTemplate, nIDCaption) {}

// Implementation
public:
	virtual ~CSearchWindowDlgTab();
	HWND GetSelectedHwnd()
	{
		return(m_hwndSelected);
	}
	WORD GetSearchFlags()
	{
		return(m_wSearchFlags);
	}
	CString GetCaption()
	{
		return(m_strCaption);
	}
	CString GetClass()
	{
		return(m_strClass);
	}

	void SetWindow(HWND hwndSet)
	{
		m_hwndSelected = hwndSet;
	}
	void SetCaption(CString strSet)
	{
		m_strCaption = strSet;
	}
	void SetClass(CString strSet)
	{
		m_strClass = strSet;
	}

protected:
	virtual BOOL ValidateTab();
	virtual void CommitTab();

	void SetSelectedWindow(HWND hwndSelected);

	void BeginFindWindowTracking();
	void UpdateFindWindowTracking(HWND hwndFound);
	void EndFindWindowTracking();

	HWND m_hwndSelected;
	HWND m_hwndFound;
	CFindToolIcon m_FindToolIcon;

	// data variables use in searching
	WORD 	m_wSearchFlags;
	CString	m_strCaption;
	CString m_strClass;

	// Generated message map functions
protected:
	//{{AFX_MSG(CSearchWindowDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnClickedHide();
	afx_msg void VerifyEnteredHwnd();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	friend class CFindToolIcon;
	friend class CSearchTabbedDialog;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchProcessDlgTab window

class CSearchProcessDlgTab : public CDlgTab
{
// Construction
public:
	CSearchProcessDlgTab(UINT nIDTemplate, UINT nIDCaption)
		: CDlgTab(nIDTemplate, nIDCaption) {}

// Implementation
public:
	virtual ~CSearchProcessDlgTab();
	DWORD GetSelectedProcess()
	{
		return(m_dwPrcSelected);
	}
	WORD GetSearchFlags()
	{
		return(m_wSearchFlags);
	}
	CString GetModule()
	{
		return(m_strModule);
	}

	void SetSelectedProcess(DWORD dwPrcSelected)
	{
		m_dwPrcSelected = dwPrcSelected;
	}
	void SetModule(CString strSet)
	{
		m_strModule = strSet;
	}

protected:
	virtual BOOL ValidateTab();
	virtual void CommitTab();

	DWORD m_dwPrcSelected;

	// data variables use in searching
	WORD 	m_wSearchFlags;
	CString	m_strModule;

	// Generated message map functions
protected:
	//{{AFX_MSG(CSearchProcessDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	friend class CSearchTabbedDialog;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchThreadDlgTab window

class CSearchThreadDlgTab : public CDlgTab
{
// Construction
public:
	CSearchThreadDlgTab(UINT nIDTemplate, UINT nIDCaption)
		: CDlgTab(nIDTemplate, nIDCaption) {}

// Implementation
public:
	virtual ~CSearchThreadDlgTab();
	DWORD GetSelectedThread()
	{
		return(m_dwThdSelected);
	}
	WORD GetSearchFlags()
	{
		return(m_wSearchFlags);
	}
	CString GetModule()
	{
		return(m_strModule);
	}

	void SetSelectedThread(DWORD dwThdSelected)
	{
		m_dwThdSelected = dwThdSelected;
	}
	void SetModule(CString strSet)
	{
		m_strModule = strSet;
	}

protected:
	virtual BOOL ValidateTab();
	virtual void CommitTab();

	DWORD m_dwThdSelected;

	// data variables use in searching
	WORD	m_wSearchFlags;
	CString	m_strModule;

	// Generated message map functions
protected:
	//{{AFX_MSG(CSearchThreadDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	friend class CSearchTabbedDialog;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchMessageDlgTab window

class CSearchMessageDlgTab : public CDlgTab
{
// Construction
public:
	CSearchMessageDlgTab(UINT nIDTemplate, UINT nIDCaption)
		: CDlgTab(nIDTemplate, nIDCaption) {}

// Implementation
public:
	virtual ~CSearchMessageDlgTab();
	HWND GetWindow()
	{
		return(m_hwndSelected);
	}
	WORD GetMessage()
	{
		return(m_wMsgSelected);
	}
	WORD GetSearchFlags()
	{
		return(m_wSearchFlags);
	}

	void SetWindow(HWND hwndSelected)
	{
		m_hwndSelected = hwndSelected;
	}
	void SetMessage(WORD wMsgSelected)
	{
		m_wMsgSelected = wMsgSelected;
	}

protected:
	virtual BOOL ValidateTab();
	virtual void CommitTab();

	void SetSelectedWindow(HWND hwndSelected);

	void BeginFindWindowTracking();
	void UpdateFindWindowTracking(HWND hwndFound);
	void EndFindWindowTracking();

	CFindToolIcon m_FindToolIcon;
	HWND m_hwndTrack;

	HWND m_hwndSelected;
	WORD m_wMsgSelected;

	// data variables use in searching
	WORD	m_wSearchFlags;

	// Generated message map functions
protected:
	//{{AFX_MSG(CSearchMessageDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnClickedHide();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	friend class CFindToolIcon;
	friend class CSearchTabbedDialog;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\srchtabs.cpp ===
// srchtabs.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "findtool.h"
#include "srchtabs.h"
#include "msglog.h"
#include "msgview.h"
#include "msgdoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CFiltersTabbedDialog

CSearchTabbedDialog::~CSearchTabbedDialog()
{
}


BEGIN_MESSAGE_MAP(CSearchTabbedDialog, CTabbedDialog)
	//{{AFX_MSG_MAP(CFiltersTabbedDialog)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchObjectDlgTab dialog

CSearchObjectDlgTab::~CSearchObjectDlgTab()
{
}

BEGIN_MESSAGE_MAP(CSearchObjectDlgTab, CDialog)
	//{{AFX_MSG_MAP(CSearchObjectDlgTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchObjectDlgTab message handlers

BOOL CSearchObjectDlgTab::OnInitDialog()
{
	CDialog::OnInitDialog();

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CSearchObjectDlgTab::CommitTab()
{
	CDlgTab::CommitTab();
}

BOOL CSearchObjectDlgTab::ValidateTab()
{
	return(CDlgTab::ValidateTab());
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchWindowDlgTab dialog

CSearchWindowDlgTab::~CSearchWindowDlgTab()
{
}

BEGIN_MESSAGE_MAP(CSearchWindowDlgTab, CDialog)
	//{{AFX_MSG_MAP(CSearchWindowDlgTab)
	ON_BN_CLICKED(IDC_SEARCH_FW_HIDESPY, OnClickedHide)
	ON_EN_KILLFOCUS(IDC_SEARCH_FW_ENTERHWND, VerifyEnteredHwnd)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchWindowDlgTab message handlers

BOOL CSearchWindowDlgTab::OnInitDialog()
{
	CDialog::OnInitDialog();

	CFont* pFont = GetStdFont(font_Normal);
	ASSERT(pFont);
	HFONT hfont = (HFONT)pFont->m_hObject;

	SendDlgItemMessage(IDC_SEARCH_FW_ENTERHWND, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_SEARCH_FW_ENTERCAPTION, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_SEARCH_FW_ENTERCLASS, WM_SETFONT, (WPARAM)hfont, FALSE);

// begin special font mucking-around
	if (_getmbcp() != 0)
	{
		pFont = GetStdFont(font_Fixed);
		ASSERT(pFont);
		hfont = (HFONT)pFont->m_hObject;

		SendDlgItemMessage(IDC_SEARCH_FW_ENTERCAPTION, WM_SETFONT, (WPARAM)hfont, FALSE);
		SendDlgItemMessage(IDC_SEARCH_FW_ENTERCLASS, WM_SETFONT, (WPARAM)hfont, FALSE);
	}
// end special font mucking-around

	m_FindToolIcon.SubclassDlgItem(IDC_SEARCH_FW_FINDTOOL, this);
	m_FindToolIcon.Initialize(this);

	SetSelectedWindow(m_hwndSelected);
	SetDlgItemText(IDC_SEARCH_FW_ENTERCAPTION, m_strCaption);
	SetDlgItemText(IDC_SEARCH_FW_ENTERCLASS, m_strClass);
	m_wSearchFlags = 0;

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CSearchWindowDlgTab::SetSelectedWindow(HWND hwndSelected)
{
	CHAR sz[256];
	LPSTR lpszClass;
	int cch;

	if (::IsWindow(hwndSelected))
	{
		wsprintf(sz, "%08X", hwndSelected);
		SetDlgItemText(IDC_SEARCH_FW_ENTERHWND, sz);

		sz[0] = '"';
		cch = ::GetWindowText(hwndSelected, &sz[1], 256 - 2);
		sz[cch + 1] = '"';
		sz[cch + 2] = 0;
		SetDlgItemText(IDC_SEARCH_FW_ENTERCAPTION, sz);

		::GetClassName(hwndSelected, sz, 256);
		if ((lpszClass = GetExpandedClassName(sz)) != NULL)
			_tcscat(sz, lpszClass);
		SetDlgItemText(IDC_SEARCH_FW_ENTERCLASS, sz);
	}
	else
	{
		SetDlgItemText(IDC_SEARCH_FW_ENTERHWND, "");
		SetDlgItemText(IDC_SEARCH_FW_ENTERCAPTION, "");
		SetDlgItemText(IDC_SEARCH_FW_ENTERCLASS, "");
	}
}

void CSearchWindowDlgTab::VerifyEnteredHwnd()
{
	HWND hwndSelected;
	CHAR szHwnd[9];
	CHAR sz[256];
	LPSTR lpszClass;
	int cch;

	// if user didn't clear out control, check that the contents are a valid HWND
	if (GetDlgItemText(IDC_SEARCH_FW_ENTERHWND, szHwnd, sizeof(szHwnd)) > 0)
	{
		hwndSelected = (HWND)_tcstoul(szHwnd, NULL, 16);	// assume user entered HWND in hex

		if (::IsWindow(hwndSelected))
		{
			sz[0] = '"';
			cch = ::GetWindowText(hwndSelected, &sz[1], 256 - 2);
			sz[cch + 1] = '"';
			sz[cch + 2] = 0;
			SetDlgItemText(IDC_SEARCH_FW_ENTERCAPTION, sz);

			::GetClassName(hwndSelected, sz, 256);
			if ((lpszClass = GetExpandedClassName(sz)) != NULL)
				_tcscat(sz, lpszClass);
			SetDlgItemText(IDC_SEARCH_FW_ENTERCLASS, sz);
		}
		else
		{
			SetDlgItemText(IDC_SEARCH_FW_ENTERCAPTION, "");
			SetDlgItemText(IDC_SEARCH_FW_ENTERCLASS, "");
		}
	}
}

void CSearchWindowDlgTab::BeginFindWindowTracking()
{
	SetSelectedWindow((HWND)NULL);
	m_hwndFound = NULL;
}

void CSearchWindowDlgTab::UpdateFindWindowTracking(HWND hwndFound)
{
	SetSelectedWindow(hwndFound);
	m_hwndFound = hwndFound;
}

void CSearchWindowDlgTab::EndFindWindowTracking()
{
	if (m_hwndFound)
		m_hwndSelected = m_hwndFound;
}

void CSearchWindowDlgTab::OnClickedHide()
{
	if (IsDlgButtonChecked(IDC_SEARCH_FW_HIDESPY))
	{
		theApp.m_pMainWnd->ShowWindow(SW_HIDE);
	}
	else
	{
		theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
	}
}

void CSearchWindowDlgTab::CommitTab()
{
	CDlgTab::CommitTab();
}

BOOL CSearchWindowDlgTab::ValidateTab()
{
	return(CDlgTab::ValidateTab());
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchProcessDlgTab dialog

CSearchProcessDlgTab::~CSearchProcessDlgTab()
{
}

BEGIN_MESSAGE_MAP(CSearchProcessDlgTab, CDialog)
	//{{AFX_MSG_MAP(CSearchProcessDlgTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchProcessDlgTab message handlers

BOOL CSearchProcessDlgTab::OnInitDialog()
{
	CDialog::OnInitDialog();

	CFont* pFont = GetStdFont(font_Normal);
	ASSERT(pFont);
	HFONT hfont = (HFONT)pFont->m_hObject;

	SendDlgItemMessage(IDC_SEARCH_FP_ENTERPROCESS, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_SEARCH_FP_ENTERMODULE, WM_SETFONT, (WPARAM)hfont, FALSE);

// begin special font mucking-around
	if (_getmbcp() != 0)
	{
		pFont = GetStdFont(font_Fixed);
		ASSERT(pFont);
		hfont = (HFONT)pFont->m_hObject;

		SendDlgItemMessage(IDC_SEARCH_FP_ENTERMODULE, WM_SETFONT, (WPARAM)hfont, FALSE);
	}
// end special font mucking-around

	if (m_dwPrcSelected != -1)
	{
		CHAR sz[10];
		wsprintf(sz, "%08X", m_dwPrcSelected);
		SetDlgItemText(IDC_SEARCH_FP_ENTERPROCESS, sz);
	}
	SetDlgItemText(IDC_SEARCH_FP_ENTERMODULE, m_strModule);
	m_wSearchFlags = 0;

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CSearchProcessDlgTab::CommitTab()
{
	CDlgTab::CommitTab();
}

BOOL CSearchProcessDlgTab::ValidateTab()
{
	return(CDlgTab::ValidateTab());
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchThreadDlgTab dialog

CSearchThreadDlgTab::~CSearchThreadDlgTab()
{
}

BEGIN_MESSAGE_MAP(CSearchThreadDlgTab, CDialog)
	//{{AFX_MSG_MAP(CSearchThreadDlgTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchThreadDlgTab message handlers

BOOL CSearchThreadDlgTab::OnInitDialog()
{
	CDialog::OnInitDialog();

	CFont* pFont = GetStdFont(font_Normal);
	ASSERT(pFont);
	HFONT hfont = (HFONT)pFont->m_hObject;

	SendDlgItemMessage(IDC_SEARCH_FT_ENTERTHREAD, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_SEARCH_FT_ENTERMODULE, WM_SETFONT, (WPARAM)hfont, FALSE);

// begin special font mucking-around
	if (_getmbcp() != 0)
	{
		pFont = GetStdFont(font_Fixed);
		ASSERT(pFont);
		hfont = (HFONT)pFont->m_hObject;

		SendDlgItemMessage(IDC_SEARCH_FT_ENTERMODULE, WM_SETFONT, (WPARAM)hfont, FALSE);
	}
// end special font mucking-around

	if (m_dwThdSelected != -1)
	{
		CHAR sz[10];
		wsprintf(sz, "%08X", m_dwThdSelected);
		SetDlgItemText(IDC_SEARCH_FT_ENTERTHREAD, sz);
	}
	SetDlgItemText(IDC_SEARCH_FT_ENTERMODULE, m_strModule);
	m_wSearchFlags = 0;

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CSearchThreadDlgTab::CommitTab()
{
	CDlgTab::CommitTab();
}

BOOL CSearchThreadDlgTab::ValidateTab()
{
	return(CDlgTab::ValidateTab());
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSearchMessageDlgTab dialog

CSearchMessageDlgTab::~CSearchMessageDlgTab()
{
}

BEGIN_MESSAGE_MAP(CSearchMessageDlgTab, CDialog)
	//{{AFX_MSG_MAP(CSearchMessageDlgTab)
	ON_BN_CLICKED(IDC_SEARCH_FM_HIDESPY, OnClickedHide)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchMessageDlgTab message handlers

BOOL CSearchMessageDlgTab::OnInitDialog()
{
	CDialog::OnInitDialog();

	CFont* pFont = GetStdFont(font_Normal);
	ASSERT(pFont);
	HFONT hfont = (HFONT)pFont->m_hObject;

	SendDlgItemMessage(IDC_SEARCH_FM_ENTERHWND, WM_SETFONT, (WPARAM)hfont, FALSE);
	SendDlgItemMessage(IDC_SEARCH_FM_SELECTMSG, WM_SETFONT, (WPARAM)hfont, FALSE);

	m_FindToolIcon.SubclassDlgItem(IDC_SEARCH_FM_FINDTOOL, this);
	m_FindToolIcon.Initialize(this);

	SetSelectedWindow(m_hwndSelected);
	m_wSearchFlags = 0;

	CComboBox *pMsgsComboBox = (CComboBox*)GetDlgItem(IDC_SEARCH_FM_SELECTMSG);
	PMSGDESC pmd;
	int i;

	for (i = 0, pmd = CMsgDoc::m_aMsgDesc; i < CMsgDoc::m_cMsgs; i++, pmd++)
	{
		int iSel = pMsgsComboBox->AddString(pmd->pszMsg);
		pMsgsComboBox->SetItemDataPtr(iSel, pmd);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CSearchMessageDlgTab::SetSelectedWindow(HWND hwndSelected)
{
	CHAR sz[256];

	if (::IsWindow(hwndSelected))
	{
		wsprintf(sz, "%08X", hwndSelected);
		SetDlgItemText(IDC_SEARCH_FM_ENTERHWND, sz);
	}
	else
	{
		SetDlgItemText(IDC_SEARCH_FM_ENTERHWND, "");
	}
}

void CSearchMessageDlgTab::BeginFindWindowTracking()
{
	SetSelectedWindow((HWND)NULL);
	m_hwndTrack = NULL;
}

void CSearchMessageDlgTab::UpdateFindWindowTracking(HWND hwndFound)
{
	SetSelectedWindow(hwndFound);
	m_hwndTrack = hwndFound;
}

void CSearchMessageDlgTab::EndFindWindowTracking()
{
	if (m_hwndTrack)
		m_hwndSelected = m_hwndTrack;
}

void CSearchMessageDlgTab::OnClickedHide()
{
	if (IsDlgButtonChecked(IDC_SEARCH_FM_HIDESPY))
	{
		theApp.m_pMainWnd->ShowWindow(SW_HIDE);
	}
	else
	{
		theApp.m_pMainWnd->ShowWindow(SW_SHOWNA);
	}
}

void CSearchMessageDlgTab::CommitTab()
{
	CDlgTab::CommitTab();
}

BOOL CSearchMessageDlgTab::ValidateTab()
{
	return(CDlgTab::ValidateTab());
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\tabdlg.cpp ===
// tabdlg.cpp : implementation file
//

//[byrond] Use the Spy++ headers
#include "stdafx.h"
#pragma hdrstop

//[byrond] Don't use 3D (there are some external dependencies below)
#define NOCTL3D

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif


CLastTabMap CTabbedDialog::m_DialogMap;

CLastTabMap::~CLastTabMap()
{
	POSITION pos = GetStartPosition();
	while (pos != (POSITION)NULL)
	{
		WORD wKey; CObject * pStr;
		GetNextAssoc(pos, wKey, pStr);
		delete (CString *)pStr;
	}	
}

////////////////////////////////////////////////////////////////////////////
// CDlgTab -- one page of a tabbed dialog

BEGIN_MESSAGE_MAP(CDlgTab, CDialog)
	//{{AFX_MSG_MAP(CDlgTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNAMIC(CDlgTab, CDialog)

CDlgTab::CDlgTab()
{
	m_nOrder = 0;
}

CDlgTab::CDlgTab(UINT nIDTemplate, UINT nIDCaption)
{
	m_strCaption.LoadString(nIDCaption);
#if _MFC_VER < 0x0400
	m_lpDialogTemplate = MAKEINTRESOURCE(nIDTemplate);
#else
	m_lpszTemplateName = MAKEINTRESOURCE(nIDTemplate);
#endif
	m_nIDHelp = LOWORD(nIDTemplate);

	m_nOrder = 0;
}

CDlgTab::CDlgTab(LPCSTR lpszTemplateName, UINT nIDCaption)
{
	m_strCaption.LoadString(nIDCaption);
#if _MFC_VER < 0x0400
	m_lpDialogTemplate = lpszTemplateName;
#else
	m_lpszTemplateName = lpszTemplateName;
#endif

	m_nOrder = 0;
}

void CDlgTab::OnOK()
{
	// Overide for OK processing, but do NOT call EndDialog!
	
	// NB. don't use SendMessage here
	m_pParentWnd->PostMessage(WM_COMMAND, IDOK);
}

void CDlgTab::OnCancel()
{
	// Overide for Cancel processing, but do NOT call EndDialog!
	
	// NB. don't use SendMessage here
	m_pParentWnd->PostMessage(WM_COMMAND, IDCANCEL);
}

void CDlgTab::CancelTab()
{
}

BOOL CDlgTab::ValidateTab()
{
	return TRUE;
}

void CDlgTab::CommitTab()
{
	ASSERT(GetSafeHwnd() != NULL);

	VERIFY( UpdateData(TRUE) );
}

BOOL CDlgTab::PreTranslateMessage(MSG* pMsg)
{
	if (((CTabbedDialog*)m_pParentWnd)->MessageStolenByTabbedDialog(pMsg))
		return TRUE;

	return CDialog::PreTranslateMessage(pMsg);
}

BOOL CDlgTab::Activate(CTabbedDialog* pParentWnd, CPoint position)
{
	m_pParentWnd = pParentWnd;
	
	if (m_hWnd == NULL)
	{
#ifdef MUNGE_DLG_FONTS
		CDialogTemplate dt;
#if _MFC_VER < 0x0400
		if (dt.Load(m_lpDialogTemplate))
#else
		if (dt.Load(m_lpszTemplateName))
#endif
			dt.SetStdFont();
		if (!CreateIndirect(dt.GetTemplate(), pParentWnd))
			return FALSE; // Create() failed...
#else
#if _MFC_VER < 0x0400
		if (!Create(m_lpDialogTemplate, pParentWnd))
#else
		if (!Create(m_lpszTemplateName, pParentWnd))
#endif
			return FALSE; // Create() failed...
#endif
		// Must be a child for obvious reasons, and must be disabled to prevent
		// it from taking the focus away from the tab area during initialization...	
		ASSERT((GetStyle() & (WS_DISABLED | WS_CHILD)) == (WS_DISABLED | WS_CHILD));
	}

	// DEBUG - Setting the window text allows our sniff tests to determine
	//         which DlgTab is currently active with a simple WM_GETTEXT
	//         message.  This line of code is otherwise unnecessary.
	SetWindowText(m_strCaption);

	SetWindowPos(&wndTop, position.x, position.y, 0, 0,
		SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOCOPYBITS);
	ShowWindow(SW_SHOWNOACTIVATE);
	EnableWindow(TRUE);

	return TRUE;
}

void CDlgTab::Deactivate(CTabbedDialog* pParentWnd)
{
	ASSERT(pParentWnd == m_pParentWnd);
}

#ifdef _DEBUG
void CDlgTab::EndDialog(int nID)
{
	// Do NOT call EndDialog for a tab!  Coordinate with the parent
	// for termination (you can post WM_COMMAND with IDOK or IDCANCEL
	// do handle those cases).
	
	ASSERT(FALSE);
}
#endif

BOOL IsTabNextFocus(CDialog* pDlg, UINT nCmd)
{
	if ((pDlg->SendMessage(WM_GETDLGCODE) &
		(DLGC_WANTALLKEYS | DLGC_WANTMESSAGE | DLGC_WANTTAB)) == 0)
	{
		CWnd* pCtl = CWnd::GetFocus();
		if (pDlg->IsChild(pCtl))
		{
			// Get top level child for controls with children, like combo.
			while (pCtl->GetParent() != pDlg)
			{
				pCtl = pCtl->GetParent();
				ASSERT_VALID(pCtl);
			}

			do
			{
				if ((pCtl = pCtl->GetWindow(nCmd)) == NULL)
					return TRUE;
			}
			while ((pCtl->GetStyle() & (WS_DISABLED | WS_TABSTOP)) != WS_TABSTOP);
		}
	}

	return FALSE;
}

// CTabRecord: an object representing one graphical tab
//
CTabRecord::CTabRecord(const TCHAR* szCaption, int nWidth, int nOrder, DWORD dw)
{
	m_strCaption = szCaption;
	m_nWidth = nWidth;
	m_nOrder = nOrder;
	m_dw = dw;

	m_rect.SetRectEmpty();
}


////////////////////////////////////////////////////////////////////////////
// CTabs -- implementation for a generic row of tabs along the top of dialog

CTabRow::CTabRow()
{
	m_rowRect.SetRectEmpty();
	m_scrollRect.SetRectEmpty();

	m_curTab = m_firstTab = 0;
	m_bHasFocus = FALSE;
	m_nScrollState = SCROLL_NULL;

	m_pWndOwner = NULL;
}

CTabRow::~CTabRow()
{
	for (int i = 0 ; i <= MaxTab() ; i++)
		delete m_tabs[i];
}

void CTabRow::ResetContent()
{
	for (int i = 0 ; i <= MaxTab() ; i++)
		delete m_tabs[i];

	m_curTab = 0;
	m_firstTab = 0;
	m_nScrollState = SCROLL_NULL;

	m_tabs.SetSize(0);
	m_pWndOwner->InvalidateRect(&m_rowRect);
}

void CTabRow::AddTab(CString& strCaption, CDC* pDC, int nOrder, DWORD dw)
{
	ASSERT(pDC);

	// Calculate the required width of the tab based on the text
	CFont* pOldFont = pDC->SelectObject(GetStdFont(font_Normal));

	CSize text = pDC->GetTextExtent(strCaption, strCaption.GetLength());
	int nWidth = text.cx + cxTabTextMargin * 2;

	pDC->SelectObject(pOldFont);

	CTabRecord* pTabRecord = new CTabRecord(strCaption, nWidth, nOrder, dw);
	for (int i = 0; ; i += 1)
	{
		if (i == m_tabs.GetSize())
		{
			m_tabs.Add(pTabRecord);
			break;
		}
		
		if (nOrder < ((CTabRecord*)m_tabs[i])->m_nOrder)
		{
			m_tabs.InsertAt(i, pTabRecord);
			break;
		}
		
		ASSERT(i < m_tabs.GetSize());
	}
			
	SetFirstTab(0);

	if (!m_rowRect.IsRectEmpty())
		m_pWndOwner->InvalidateRect(&m_rowRect);
}

void CTabRow::SetPos(CRect rect)
{
	// rect is in client coordinates of the owning window, of course
	m_rowRect = rect;
	m_scrollRect.SetRect(m_rowRect.right - cxScrollSize, m_rowRect.bottom - 1 - cyScrollSize,
	                     m_rowRect.right, m_rowRect.bottom - 1);
	SetFirstTab(m_firstTab);	// recalc all tab positions
	ScrollIntoView(m_curTab);	// make sure current selection still in view
}

int CTabRow::DesiredHeight(CDC* pDC)
{
	CFont* pOldFont = pDC->SelectObject(GetStdFont(font_NormalBold));

	// Our desired height is the height of a tall character plus the
	// required margin space, plus the amount by which selection
	// increases the height of a tab.
	int height = pDC->GetTextExtent("M", 1).cy + cyTabTextMargin * 2 + cySelectedTab * 2;

	pDC->SelectObject(pOldFont);
	return height;
}

int CTabRow::SetActiveTab(int nTab)
{
	if (nTab < 0 || nTab > MaxTab())
		return -1;
	if (nTab == m_curTab)
		return nTab;

	InvalidateTab(m_curTab);
	InvalidateTab(nTab);

	m_curTab = nTab;

	ScrollIntoView(nTab);

	return nTab;
}

int CTabRow::SetActiveTab(const CString& str)
{
	for (int i = 0 ; i <= MaxTab() ; i++)
	{
		if (str == GetTabString(i))
			return SetActiveTab(i);
	}

	return -1;
}

void CTabRow::PutFocus(BOOL bTabsHaveFocus)
{
	if (m_bHasFocus == bTabsHaveFocus)
		return;

	m_bHasFocus = bTabsHaveFocus;
	if ((m_curTab != -1) && (m_curTab <= MaxTab()))
		InvalidateTab(m_curTab);
}

void CTabRow::DrawTab(CDC* pDC, int nTab, BOOL bCurTab)
{
	CRect rc = GetTab(nTab)->m_rect;
	int  nWidth = GetTab(nTab)->m_nWidth;
	BOOL bClipped = GetTab(nTab)->m_bClipped;

	if (bCurTab)
		rc.InflateRect(cxSelectedTab, cySelectedTab);

	CPen pen;

	// Draw white line along left and top of tab
	COLORREF cr = GetSysColor(COLOR_BTNHIGHLIGHT);
	if (!pen.CreatePen(PS_SOLID, 1, cr))
		return;

	CPen* pOldPen = pDC->SelectObject(&pen);

	pDC->MoveTo(rc.left, rc.bottom - 1);
	pDC->LineTo(rc.left, rc.top + 2);
	pDC->LineTo(rc.left + 2, rc.top);
	pDC->LineTo(rc.right - 1, rc.top);

	pDC->SelectObject(pOldPen);
	pen.DeleteObject();

	// if the tab following this one is the selected tab, or if it is
	// clipped by the right edge, don't draw the right border lines.
	if ((m_curTab != nTab + 1) || !IsTabVisible(m_curTab))
	{
		cr = GetSysColor(COLOR_BTNSHADOW);
		if (!pen.CreatePen(PS_SOLID, 1, cr))
			return;

		pOldPen = pDC->SelectObject(&pen);

		// Depending on whether this tab is clipped or not, we draw either
		// the "torn" dark gray edge, or else the standard gray+black line
		// on the right-side border.
		if (!bClipped)
		{
		//	pDC->MoveTo(rc.right - 1, rc.top);		already there
			pDC->LineTo(rc.right - 1, rc.bottom);

			pDC->SelectObject(pOldPen);
			pen.DeleteObject();

			// Now do the second (black) line down right side
			cr = GetSysColor(COLOR_BTNTEXT);
			if (!pen.CreatePen(PS_SOLID, 1, cr))
				return;

			pOldPen = pDC->SelectObject(&pen);

			pDC->MoveTo(rc.right, rc.top + 2);
			pDC->LineTo(rc.right, rc.bottom);
		}
		else
		{
			// draw dark gray "torn" edge for a clipped tab
			for (int i = rc.top ; i < rc.bottom ; i += 3)
			{
				// This nifty (but obscure-looking) equation will draw
				// a jagged-edged line.
				int j = ((6 - (i - rc.top) % 12) / 3) % 2;
				pDC->MoveTo(rc.right + j, i);
				pDC->LineTo(rc.right + j, min(i + 3, rc.bottom));
			}
		}

		pDC->SelectObject(pOldPen);
		pen.DeleteObject();
	}

	// Finally, draw the tab's text
	CFont* pOldFont = pDC->SelectObject(GetStdFont(font_Normal));
	CString strCaption = GetTabString(nTab);

	CSize text = pDC->GetTextExtent(strCaption,
		strCaption.GetLength());
	pDC->ExtTextOut(rc.left + nWidth / 2 - text.cx / 2,
		rc.top + rc.Height() / 2 - text.cy / 2, ETO_CLIPPED, &rc,
		strCaption, strCaption.GetLength(), NULL);

	pDC->SelectObject(pOldFont);
}

void CTabRow::Draw(CDC* pDC)
{
	// Draw all the tabs that are currently within view
	for (int i = MaxTab() ; i >= 0 ; i--)
		if (IsTabVisible(i))
			DrawTab(pDC, i, i == m_curTab);

	// Draw the line underneath all the tabs
	CPen pen;
	COLORREF cr = GetSysColor(COLOR_BTNHIGHLIGHT);
	if (pen.CreatePen(PS_SOLID, 1, cr))
	{
		CRect rc(0, 0, 0, 0);
		if (m_curTab <= MaxTab())
			rc = GetTab(m_curTab)->m_rect;
		CPen* pOldPen = pDC->SelectObject(&pen);

		pDC->MoveTo(m_rowRect.left, m_rowRect.bottom - 1);
		if (!rc.IsRectNull())
		{
			// this leaves a gap in the line if the currently selected
			// tab is within view.
			pDC->LineTo(rc.left - cxSelectedTab, m_rowRect.bottom - 1);
			pDC->MoveTo(rc.right + cxSelectedTab + 1, m_rowRect.bottom - 1);
		}
		pDC->LineTo(m_rowRect.right, m_rowRect.bottom - 1);

		pDC->SelectObject(pOldPen);
		pen.DeleteObject();
	}

	if (CanScroll())
		DrawScrollers(pDC);

	if (m_bHasFocus && (m_pWndOwner->GetFocus() == m_pWndOwner))
		DrawFocusRect(pDC);
}

void CTabRow::DrawFocusRect(CDC* pDC)
{
	if (MaxTab() < 0)
		return;

	CRect rc;
	rc = GetTab(m_curTab)->m_rect;

	pDC->DrawFocusRect(&rc);
}

void CTabRow::DrawScrollers(CDC* pDC)
{
	int idb;

	// Choose bitmap depending on scroll state
	if (IsTabVisible(0, FALSE))
		idb = IDB_SCROLL_LD;
	else if (IsTabVisible(MaxTab(), FALSE))
		idb = IDB_SCROLL_RD;
	else
		idb = IDB_SCROLL;

	if (!m_bScrollPause)
	{
		if (m_nScrollState == SCROLL_LEFT)
			idb = IDB_SCROLL_L;
		else if (m_nScrollState == SCROLL_RIGHT)
			idb = IDB_SCROLL_R;
	}

	// now load and draw it
	CBitmap bm;
	bm.LoadBitmap(idb);

	CDC dcTemp;
	dcTemp.CreateCompatibleDC(pDC);
	CBitmap* pOldBitmap = dcTemp.SelectObject(&bm);

	pDC->BitBlt(m_scrollRect.left, m_scrollRect.top, m_scrollRect.Width(),
	            m_scrollRect.Height(), &dcTemp, 0, 0, SRCCOPY);

	dcTemp.SelectObject(pOldBitmap);
}

void CTabRow::DrawPageRect(CDC* pDC, const CRect& rectPage)
{
	CRect rect;
	rect.left = min(m_rowRect.left - 1, rectPage.left);
	rect.top = m_rowRect.bottom - 2;
	rect.right = max(m_rowRect.right, rectPage.right);
	rect.bottom = rectPage.bottom;

	// black line along right and bottom side
	COLORREF cr = GetSysColor(COLOR_WINDOWFRAME);
	pDC->FillSolidRect(rect.right - 1, rect.top, 1, rect.Height(), cr);
	pDC->FillSolidRect(rect.left, rect.bottom - 1, rect.Width() - 1, 1, cr);

	rect.InflateRect(-1, -1);
	// draw white line along left of page, and top where not covered by
	// the tabs.
	cr = GetSysColor(COLOR_BTNHIGHLIGHT);

	if (rect.left < m_rowRect.left)
	{
		pDC->FillSolidRect(rect.left, rect.top,
			m_rowRect.left - rect.left, 1, cr);
	}

	if (rect.right > m_rowRect.right)
	{
		pDC->FillSolidRect(m_rowRect.right, rect.top,
			rect.right - m_rowRect.right - 1, 1, cr);
	}

	pDC->FillSolidRect(rect.left, rect.top + 1,	1, rect.Height() - 2, cr);

	// dark gray line along right and bottom side
	cr = GetSysColor(COLOR_BTNSHADOW);
	pDC->FillSolidRect(rect.right - 1, rect.top, 1, rect.Height(), cr);
	pDC->FillSolidRect(rect.left, rect.bottom - 1, rect.Width() - 1, 1, cr);

}

void CTabRow::SetFirstTab(int nTab)
{
	// This function recalcs the positions of all the tabs, assuming the
	// specified tab is the first (leftmost) visible tab.

	if (nTab < 0 || MaxTab() < nTab)
		return;

	int x = m_rowRect.left + cxSelectedTab;

	// everything before the first tab is not visible
	for (int i = 0 ; i < nTab ; i++)
		GetTab(i)->m_rect.SetRectEmpty();

	// calculate locations for all other tabs
	for (i = nTab ; i <= MaxTab() ; i++)
	{
		GetTab(i)->m_rect.SetRect(x, m_rowRect.top + cySelectedTab,
		                          x + GetTab(i)->m_nWidth, m_rowRect.bottom - cySelectedTab);
		x += GetTab(i)->m_nWidth + cxSelectedTab;
		GetTab(i)->m_bClipped = FALSE;
	}

	// do they all fit?
	x = m_rowRect.right - (nTab == 0 ? 0 : (cxScrollMargin + cxScrollSize));
	i = MaxTab();
	while ((i >= 0) && (GetTab(i)->m_rect.right > x))
	{
		x = m_rowRect.right - (cxScrollMargin + cxScrollSize);
		if (GetTab(i)->m_rect.left < x)
		{
			GetTab(i)->m_bClipped = TRUE;
			GetTab(i)->m_rect.right = x;
		}
		else
			GetTab(i--)->m_rect.SetRectEmpty();
	}

	m_firstTab = nTab;
}

BOOL CTabRow::IsTabVisible(int nTab, BOOL bPartials)
{
	if (GetTab(nTab)->m_rect.IsRectNull())
		return FALSE;

	return bPartials || !GetTab(nTab)->m_bClipped;
}

void CTabRow::Scroll(int nDirection)
{
	ASSERT(nDirection == SCROLL_LEFT || nDirection == SCROLL_RIGHT);
	ASSERT(CanScroll());

	BOOL bRepaintScrollers = ((nDirection == SCROLL_LEFT) && IsTabVisible(MaxTab(), FALSE))
			|| ((nDirection == SCROLL_RIGHT) && IsTabVisible(0, FALSE));

	switch(nDirection)
	{
		case SCROLL_LEFT:
			if (m_firstTab == 0)
				return;

			SetFirstTab(m_firstTab - 1);
			break;

		case SCROLL_RIGHT:
			if (IsTabVisible(MaxTab(), FALSE))
				return;

			SetFirstTab(m_firstTab + 1);
			break;
	}

	// repaint all tabs, and (if their enable state has changed) the scroll
	// buttons as well.
	CRect rc = m_rowRect;
	if (!bRepaintScrollers)
		rc.right = m_scrollRect.left - 1;
	m_pWndOwner->InvalidateRect(&rc);
}

void CTabRow::ScrollIntoView(int nTab)
{
	if (nTab < 0 || nTab > MaxTab() || IsTabVisible(nTab, FALSE) ||
			m_rowRect.IsRectEmpty())
		return;

	// do we need to scroll left, or right?
	int increment = (nTab > m_firstTab) ? 1 : -1;

	while (!IsTabVisible(nTab, FALSE))
		SetFirstTab(m_firstTab + increment);

	m_pWndOwner->InvalidateRect(&m_rowRect);
}

BOOL CTabRow::CanScroll()
{
	// if either the first or the last tab is not visible, it's scrollable
	return MaxTab() >= 0 && (!IsTabVisible(0, FALSE) || !IsTabVisible(MaxTab(), FALSE));
}

void CTabRow::OnMouseMove(CPoint pt)
{
	ASSERT((m_nScrollState == SCROLL_LEFT) || (m_nScrollState == SCROLL_RIGHT));

	int nNewState = TabFromPoint(pt);
	BOOL bPause = !(nNewState == m_nScrollState);

	if (bPause == m_bScrollPause)
		return;

	if (bPause)
		m_pWndOwner->KillTimer(TIMER_ID);
	else
	{
		VERIFY( m_pWndOwner->SetTimer(TIMER_ID, TIMER_DELAY, NULL) == TIMER_ID );
		Scroll(m_nScrollState);
	}

	m_bScrollPause = bPause;
	InvalidateTab(m_nScrollState);
}

void CTabRow::OnLButtonUp(CPoint pt)
{
	Capture(SCROLL_NULL);
}

void CTabRow::OnTimer()
{
	ASSERT((m_nScrollState == SCROLL_LEFT) || (m_nScrollState == SCROLL_RIGHT));
	ASSERT(!m_bScrollPause);

	Scroll(m_nScrollState);
}

void CTabRow::Capture(int nDirection)
{
	ASSERT((m_nScrollState == SCROLL_LEFT) || (m_nScrollState == SCROLL_RIGHT) ||
	       (m_nScrollState == SCROLL_NULL));

	switch(nDirection)
	{
		case SCROLL_LEFT:
		case SCROLL_RIGHT:
			m_pWndOwner->SetCapture();
			VERIFY( m_pWndOwner->SetTimer(TIMER_ID, TIMER_DELAY, NULL) == TIMER_ID );
			InvalidateTab(nDirection);
			break;

		case SCROLL_NULL:
			::ReleaseCapture();
			m_pWndOwner->KillTimer(TIMER_ID);
			InvalidateTab(m_nScrollState);
			break;
	}

	m_nScrollState = nDirection;
	m_bScrollPause = FALSE;
}

void CTabRow::InvalidateTab(int nTab, BOOL bInflate)
{
	CRect rc;
	
	switch (nTab)
	{
		case SCROLL_LEFT:
			rc = m_scrollRect;
			rc.right -= (rc.Width() / 2 - 1);
			break;

		case SCROLL_RIGHT:
			rc = m_scrollRect;
			rc.left += (rc.Width() / 2 - 1);
			break;

		default:
			rc = GetTab(nTab)->m_rect;
			if (bInflate)
			{
				rc.left -= cxSelectedTab;
				rc.right += cxSelectedTab + 1;
				rc.top = m_rowRect.top;
				rc.bottom = m_rowRect.bottom;
			}
			if (GetTab(nTab)->m_bClipped)
				rc.right += 1;
	}

	ASSERT(m_pWndOwner);
	m_pWndOwner->InvalidateRect(&rc, nTab >= 0);
}

int CTabRow::TabFromPoint(CPoint pt)
{
	// are we on the scroll buttons?
	if (CanScroll() && m_scrollRect.PtInRect(pt))
	{
		if (pt.x < m_scrollRect.left + (m_scrollRect.Width() / 2))
			return IsTabVisible(0, FALSE) ? -1 : SCROLL_LEFT;
		else
			return IsTabVisible(MaxTab(), FALSE) ? -1 : SCROLL_RIGHT;
	}

	// are we on a tab?
	for (int i = 0 ; i <= MaxTab() ; i++)
		if (GetTab(i)->m_rect.PtInRect(pt))
			return i;

	return -1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabbedDialog -- a tabbed "dialog" (really a popup-window)

IMPLEMENT_DYNAMIC(CTabbedDialog, CWnd)

CTabbedDialog::CTabbedDialog(UINT nIDCaption, CWnd* pParent /*=NULL*/,
                             UINT iSelectTab /*=-1*/, COMMIT_MODEL commitModel /*=commitOnOk*/)
{
	m_pParentWnd = pParent == NULL ? AfxGetApp()->m_pMainWnd : pParent;

	nCaptionID = nIDCaption;
	m_nTabCur = (iSelectTab == -1) ? 0 : iSelectTab;

	m_tabRow.SetParent(this);
	m_tabRow.PutFocus(TRUE);
	m_hFocusWnd = 0;
	m_strCaption.LoadString( nIDCaption );
	m_commitModel = commitModel;
	m_iDefBtnIndex = 0;		// i.e., the first one (usually 'OK')
	m_buttonSize = CSize(0, 0);
}

BOOL CTabbedDialog::PreTranslateMessage(MSG* pMsg)
{
	CWnd* pWnd;

	// If the standard tabbed-dialog pretranslate code knows how to handle
	// this message, let it.
	if (MessageStolenByTabbedDialog(pMsg))
		return TRUE;

	switch (pMsg->message)
	{
	case WM_KEYDOWN:

		switch ((char) pMsg->wParam)
		{
			case VK_ESCAPE:
				PostMessage(WM_COMMAND, IDCANCEL);
				return TRUE;

			case VK_RETURN:
				pWnd = GetFocus();
				if ((pWnd == NULL) || !IsButton(pWnd->GetSafeHwnd()))
					pWnd = GetButtonFromIndex(0);
				PostMessage(WM_COMMAND, pWnd->GetDlgCtrlID());
				return TRUE;

			default:
				::TranslateMessage( pMsg );
				::DispatchMessage( pMsg );
				return TRUE;
		}
	}

	return CWnd::PreTranslateMessage(pMsg);
}

void CTabbedDialog::BuildTabItemList(CObList& list, CMapWordToOb& map, CWnd* pWndCur)
{
	int i;
	CString str;
	char cAccel = 0;

	if (pWndCur == NULL)
	{
		ASSERT(list.IsEmpty());
		ASSERT(map.IsEmpty());
		pWndCur = GetWindow(GW_CHILD);
	}

	while (pWndCur != NULL)
	{
		if (pWndCur->IsKindOf( RUNTIME_CLASS(CDialog) ))
		{
			if (pWndCur->IsWindowVisible())
			{
				// if it's a tabbed dialog, include an entry for the tab row
				if (pWndCur->IsKindOf( RUNTIME_CLASS(CDlgTab) ))
					list.AddTail(this);

				// recursively process all dialogs to get a list of tab stops
				CWnd* pWndChild = pWndCur->GetWindow(GW_CHILD);
				ASSERT(pWndChild);
				BuildTabItemList(list, map, pWndChild);
			}
		}
		else
		{
			DWORD dwStyle = pWndCur->GetStyle();
			if ((dwStyle & (WS_DISABLED | WS_VISIBLE)) == WS_VISIBLE)
			{
				pWndCur->GetWindowText(str);

DoubleAmpersand:
				if ((i = str.Find('&')) != -1)
				{
					ASSERT(str.GetLength() > i+1);	// & can't be last char
					if (str[i + 1] == '&')
					{
						str = str.Right(str.GetLength() - (i + 2));
						goto DoubleAmpersand;
					}
					cAccel = str[i + 1];
				}

				if (dwStyle & WS_TABSTOP)
				{
					list.AddTail(pWndCur);
					if (cAccel != 0)
					{
						map.SetAt(toupper(cAccel), pWndCur);
						cAccel = 0;
					}
				}
			}
		}

		pWndCur = pWndCur->GetWindow(GW_HWNDNEXT);
	}
}

CWnd* CTabbedDialog::FindControl(CWnd* pWndFocus, CObList& list, FC fc)
{
	POSITION pos = list.Find(pWndFocus);
	while (pos == NULL)
	{
		// possibly the current focus window is a child of some window
		// in the list?
		pWndFocus = pWndFocus->GetParent();
		if (pWndFocus == NULL)
		{
			ASSERT(fc == FC_THIS);	// Never happens otherwise?
			return NULL;
		}

		pos = list.Find(pWndFocus);
	}

	// Handle wrapping off the top or bottom of the dialog.
	switch (fc)
	{
		case FC_NEXT:
			list.GetNext(pos);
			if (pos == NULL)
				return (CWnd*) list.GetHead();
			break;

		case FC_PREVIOUS:
			list.GetPrev(pos);
			if (pos == NULL)
				return (CWnd*) list.GetTail();
			break;

		case FC_THIS:
			if (pos == NULL)
				return NULL;
			break;

#ifdef _DEBUG
		default:
			ASSERT(FALSE);
			break;
#endif
	}

	ASSERT(pos != NULL);
	return (CWnd*) list.GetAt(pos);
}

void CTabbedDialog::SetFocusToControl(CWnd* pControl, CObList* pList, BOOL bSetSel)
{
	ASSERT(pControl);
	CWnd* pOldDefault = NULL;
	CObList list;
	CMapWordToOb map;

	if (pList == NULL)
	{
		BuildTabItemList(list, map);
		pList = &list;
	}

	// If it's not in the list, it can't take the focus.  This catches user
	// clicks on subdialogs.
	CWnd* pListItem = FindControl(pControl, *pList, FC_THIS);
	if ((pListItem == NULL) || ((pListItem != pControl) && (pListItem == this)))
		return;

	// Figure out who currently has the default button style
	POSITION pos = pList->GetHeadPosition();
	while (pos != NULL)
	{
		pOldDefault = (CWnd*) pList->GetNext(pos);
		if (pOldDefault->SendMessage(WM_GETDLGCODE) & DLGC_DEFPUSHBUTTON)
			break;
	}

	// Figure out who ought to have the default button style
	CWnd* pNewDefault = (CWnd *)NULL;
	if (m_iDefBtnIndex != -1)
	{
		pNewDefault = GetButtonFromIndex(m_iDefBtnIndex);
		if (pControl->SendMessage(WM_GETDLGCODE) & (DLGC_DEFPUSHBUTTON | DLGC_UNDEFPUSHBUTTON))
			pNewDefault = pControl;
		ASSERT(pNewDefault);
		if (pNewDefault->m_hWnd == NULL)
			return;
	}

	// Now set the focus...
	m_tabRow.PutFocus(pControl == this);
	pControl->SetFocus();

	// if this control handles SETSEL messages, select the entire contents
	if (bSetSel && pControl->SendMessage(WM_GETDLGCODE) & DLGC_HASSETSEL)
		pControl->SendMessage(EM_SETSEL, 0, -1);

	// no new default button if new equals old
	if (pNewDefault == pOldDefault)
		return;

	// ...and, if the default button needs to change, change it.
	if (pOldDefault != NULL)
	{
		::SetWindowLong(pOldDefault->GetSafeHwnd(), GWL_STYLE,
			GetWindowLong(pOldDefault->GetSafeHwnd(), GWL_STYLE) & ~BS_DEFPUSHBUTTON);
		pOldDefault->Invalidate();
	}

	// ...set a new default button?
	if (pNewDefault != NULL)
	{
		::SetWindowLong(pNewDefault->GetSafeHwnd(), GWL_STYLE,
			GetWindowLong(pNewDefault->GetSafeHwnd(), GWL_STYLE) | BS_DEFPUSHBUTTON);
		pNewDefault->Invalidate();
	}
}

void CTabbedDialog::HandleTab(BOOL bShift, BOOL bControl)
{
	if (bControl)
	{
		SetFocusToControl(this);
		SendMessage(WM_KEYDOWN, bShift ? VK_LEFT : VK_RIGHT);
	}
	else
	{
		CObList list;
		CMapWordToOb map;

		BuildTabItemList(list, map);

		CWnd* pWndNext = FindControl(GetFocus(), list, bShift ? FC_PREVIOUS : FC_NEXT);
		ASSERT(pWndNext != NULL);

		if (pWndNext != NULL)
			SetFocusToControl(pWndNext, &list);
	}
}

BOOL CTabbedDialog::HandleAcceleratorKey(char ch)
{
	CObList list;
	CMapWordToOb map;

	BuildTabItemList(list, map);

	CObject* pObject;
	if (!map.Lookup(ch, pObject))
		return FALSE;

	CWnd* pWnd = (CWnd*)pObject;
	ASSERT(pWnd->IsKindOf( RUNTIME_CLASS(CWnd) ));

	SetFocusToControl(pWnd, &list);

	// Automatically push buttons and twiddle checkboxes
	if (pWnd->SendMessage(WM_GETDLGCODE) & DLGC_BUTTON)
	{
		CButton* pButton = (CButton*)pWnd;
		DWORD dwStyle = pButton->GetStyle();

		// [marklam] Dolphin 9492,9488 need to set check and then send button clicked message.
		// Random.
		if ((dwStyle & BS_AUTOCHECKBOX) == BS_AUTOCHECKBOX)
		{
			pButton->SetCheck(1 - pButton->GetCheck());
			pButton->GetParent()->SendMessage(WM_COMMAND, (WPARAM)(pWnd->GetDlgCtrlID() | (BN_CLICKED<<16)), (LPARAM)pWnd->GetSafeHwnd());
		}
		else if ((dwStyle & BS_AUTO3STATE) == BS_AUTO3STATE)
		{
			pButton->SetCheck((pButton->GetCheck() + 1) % 3);
			pButton->GetParent()->SendMessage(WM_COMMAND, (WPARAM)(pWnd->GetDlgCtrlID() | (BN_CLICKED<<16)), (LPARAM)pWnd->GetSafeHwnd());
		}
		else
		{									
			pButton->SendMessage(WM_LBUTTONDOWN, (WPARAM)0, (LPARAM)0);
			pButton->SendMessage(WM_LBUTTONUP, (WPARAM)0, (LPARAM)0);
		}
	}

	return TRUE;
}

BOOL CTabbedDialog::HandleTabRowKey(char ch)
{
	// Starting from current position + 1, cycle through all the dlgtabs
	// looking for one whose caption starts with the requested character.
	CDlgTab* pTab;
	int i = m_nTabCur + 1;

	while (i != m_nTabCur)
	{
		if ((pTab = GetTab(i++)) == NULL)
		{
			i = 0;
			continue;
		}

		if (pTab->m_strCaption.GetLength() < 1)
		{
			ASSERT(FALSE);	// shouldn't have captionless dlgtabs
			continue;
		}

		if (pTab->m_strCaption[0] == ch)
		{
			SelectTab(i - 1);
			return TRUE;
		}
	}

	return FALSE;
}


// MessageStolenByTabbedDialog
//
// This function should be called during PreTranslateMessage by the DlgTab
// or by any subdialog contained within the DlgTab.
//
// If the function returns TRUE, the tabbed dialog has processed the
// message and no further action is required by the DlgTab.
//
BOOL CTabbedDialog::MessageStolenByTabbedDialog(MSG* pMsg)
{
	LRESULT dlgCode;

	switch (pMsg->message)
	{
		case WM_SYSKEYDOWN:

			if ((char) pMsg->wParam == VK_MENU)
				break;

			// Unless there is a current focus item that wants all its own
			// keys, process accelerators here.
			dlgCode = (GetFocus() == NULL) ? (LRESULT)0 : GetFocus()->SendMessage(WM_GETDLGCODE);

			if (! (dlgCode & DLGC_WANTALLKEYS) &&
			    HandleAcceleratorKey((char) pMsg->wParam))
			{
				return TRUE;
			}

			break;

		case WM_KEYDOWN:

			dlgCode = (GetFocus() == NULL) ? (LRESULT)0 : GetFocus()->SendMessage(WM_GETDLGCODE);

			switch(pMsg->wParam)
			{
				case VK_TAB:
					// Note that we do tab handling here even if the control
					// with the current focus has DLGC_WANTALLKEYS set.
					HandleTab(GetKeyState(VK_SHIFT) < 0, GetKeyState(VK_CONTROL) < 0);
					return TRUE;

				case VK_F1:
					if (dlgCode & DLGC_WANTALLKEYS)
						break;

					OnHelp();
					return TRUE;

				default:
					// Hitting keys with the focus on the tab row should go
					// through normal key processing.
					if (m_tabRow.HasFocus())
						break;

					// If the current focus window doesn't respond to character
					// input, then hitting a key should be handled as an
					// accelerator in accordance with Windows standards.
					if (! (dlgCode & (DLGC_WANTCHARS | DLGC_WANTALLKEYS))
						&& HandleAcceleratorKey((char) pMsg->wParam))
					{
						return TRUE;
					}

					break;
			}
			break;
	}

	return FALSE;
}

int CTabbedDialog::DoModal()
{
	int nResult = IDABORT;

	// cannot call DoModal on a dialog already constructed as modeless
	ASSERT(m_hWnd == NULL);

	//[patbr] Remove external dependencies!
	//PreModalWindow();

	// allow OLE servers to disable themselves
	AfxGetApp()->EnableModeless(FALSE);

	// disable parent before creating or MFC will disable us.
	m_pParentWnd->EnableWindow(FALSE);

	if (Create())
	{	
		ASSERT(IsWindowEnabled());	// should not be disabled to start!
		// EnableWindow();
		SetActiveWindow();

		m_nID = -1;
		while (m_hWnd != NULL && AfxGetApp()->PumpMessage() && m_nID == -1)
			;
	
		nResult = m_nID;
	}

	// allow OLE servers to enable themselves
	AfxGetApp()->EnableModeless(TRUE);

	// enable top level parent window again
	m_pParentWnd->EnableWindow(TRUE);

	//[patbr] Remove external dependencies!
	//PostModalWindow();

	return nResult;
}

BOOL CTabbedDialog::Create()
{
	if (!CreateEx(WS_EX_DLGMODALFRAME,
		AfxRegisterWndClass(CS_HREDRAW | CS_VREDRAW, LoadCursor(NULL, IDC_ARROW), (HBRUSH)(COLOR_BTNFACE + 1)),
		m_strCaption, WS_SYSMENU | WS_POPUP | WS_CAPTION | WS_VISIBLE | WS_CAPTION | DS_MODALFRAME,
		50, 50, 400, 200, m_pParentWnd->m_hWnd, NULL))
	{
		return FALSE;
	}

	SetActiveWindow();
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////

BOOL CTabbedDialog::ClearAllTabs()
{
	if (m_tabs.GetSize() != 0)
	{
		// de-select the current
		SelectTab(-1);

		// tab still active?
		if (m_nTabCur != -1)
			return FALSE;	// clear failed

		// delete our existing tabs
		int nTabs = m_tabs.GetSize();
		for (int i = 0; i < nTabs; i++)
			delete m_tabs[i];
		m_tabs.SetSize(0);

		// reset the tab row to reflect this clear
		m_tabRow.ResetContent();
	}

	return TRUE;	// success
}

////////////////////////////////////////////////////////////////////////////

void CTabbedDialog::AddTab(CDlgTab* pDlgTab)
{
	// FUTURE this uses the screen DC rather than the tabbed dialog DC
	// in the normal case, because the tabbed dialog's DC will often be
	// NULL at this point.  This was an oversight in the code, not
	// discovered until shortly before ship -- we should probably calc
	// tab sizes when the dialog is created, like MFC does.
	CDC* pDC = CDC::FromHandle(::GetDC(m_hWnd));

	for (int i = 0; ; i += 1)
	{
		if (i == m_tabs.GetSize())
		{
			m_tabs.Add(pDlgTab);
			break;
		}
		
		if (pDlgTab->m_nOrder < ((CDlgTab*)m_tabs[i])->m_nOrder)
		{
			m_tabs.InsertAt(i, pDlgTab);
			break;
		}
		
		ASSERT(i < m_tabs.GetSize());
	}
	
	m_tabRow.AddTab(pDlgTab->m_strCaption, pDC, pDlgTab->m_nOrder);

	::ReleaseDC(m_hWnd, pDC->m_hDC);
}

BEGIN_MESSAGE_MAP(CTabbedDialog, CWnd)
	//{{AFX_MSG_MAP(CTabbedDialog)
	ON_WM_PAINT()
	ON_WM_NCCREATE()
	ON_WM_CREATE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_TIMER()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_ACTIVATE()
	ON_WM_KEYDOWN()
	ON_WM_CLOSE()
	ON_WM_SIZE()
	ON_WM_PARENTNOTIFY()
	ON_WM_KEYDOWN()
	ON_WM_CTLCOLOR()
	ON_WM_SYSCOLORCHANGE()
	//}}AFX_MSG_MAP
	ON_COMMAND(IDOK, OnOK)
	ON_COMMAND(IDCANCEL, OnCancel)
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabbedDialog message handlers

BOOL CTabbedDialog::OnNcCreate(LPCREATESTRUCT lpcs)
{
	if (theApp.IsChicago())
		ModifyStyle(0, 0x00000004L);	// DS_3DLOOK

	if (!CWnd::OnNcCreate(lpcs))
		return FALSE;

	SubclassDlg3d();	// add CTL3D effects, if loaded
	return TRUE;
}

int CTabbedDialog::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Fix-up the system menu so this looks like a dialog box
	CMenu* pSysMenu = GetSystemMenu(FALSE);
	ASSERT(pSysMenu != NULL);
	pSysMenu->DeleteMenu(7, MF_BYPOSITION);
	pSysMenu->DeleteMenu(5, MF_BYPOSITION);
	pSysMenu->DeleteMenu(SC_SIZE, MF_BYCOMMAND);
	pSysMenu->DeleteMenu(SC_TASKLIST, MF_BYCOMMAND);
	pSysMenu->DeleteMenu(SC_MINIMIZE, MF_BYCOMMAND);
	pSysMenu->DeleteMenu(SC_MAXIMIZE, MF_BYCOMMAND);
	pSysMenu->DeleteMenu(SC_RESTORE, MF_BYCOMMAND);
		
	// do we have a tab ready to select?
	if (m_nTabCur == -1)
	{
		CString strTabCaption;
		if (m_DialogMap.LookupTab( nCaptionID, strTabCaption))
			for (int i = 0 ; i <= m_tabRow.MaxTab() ; i++)
				if (m_tabRow.GetTabString(i) == strTabCaption)
				{
					m_nTabCur = i; break;
				}

		// did we find a remembered tab?
		if (m_nTabCur == -1)
			m_nTabCur = 0;
	}

	if (ActivateTab(m_nTabCur))
		m_tabRow.SetActiveTab(m_nTabCur);
	else
		m_nTabCur = -1;	// no tab selected

	// send notification of this initial tab
	OnSelectTab(m_nTabCur);

	return 0;
}

void CTabbedDialog::OnPaint()
{
	CPaintDC dc(this);
	dc.SetBkMode(TRANSPARENT);

	// the tabs know how to draw themselves
	m_tabRow.Draw(&dc);

	CRect rectPage, margins;
	GetClientRect(rectPage);
	GetMargins(margins);

	rectPage.left += margins.left;
	rectPage.right -= margins.right;
	rectPage.bottom -= margins.bottom;

	m_tabRow.DrawPageRect(&dc, rectPage);
}

void CTabbedDialog::SelectTab(int nTab)
{
	CDlgTab *pTab;

	ASSERT(nTab == -1 || (nTab >= 0 && nTab < m_tabs.GetSize()));

	if (nTab == m_nTabCur)
		return;

	int nPrevTab = m_nTabCur;
	if (m_nTabCur != -1)
	{
		pTab = GetTab(m_nTabCur);
		if (!pTab->ValidateTab())
		{
			TRACE("Tab %s refused deactivation!\n",
				(const char*)GetTab(m_nTabCur)->m_strCaption);
			return;
		}
		pTab->Deactivate(this);
	}

	if (nTab != -1 && !ActivateTab(nTab))
	{
		TRACE("Could not activate tab %s!\n",
			(const char*)GetTab(nTab)->m_strCaption);
		return;
	}

	if (nPrevTab != -1)
		pTab->ShowWindow(SW_HIDE);

	m_nTabCur = nTab;

	if (nTab != -1)
	{
		m_tabRow.SetActiveTab(nTab);

		// send notification of this tab change
		OnSelectTab(nTab);
	}
}

void CTabbedDialog::GetMargins(CRect& rect)
{
	if (m_buttonSize.cx == 0)
	{
		// Calculate the proper size of the buttons, based on average character
		// width and height of the font.  If it's a variable pitch font,
		// calculate the average pitch (code copied from editor.cpp)
		//
		LONG cxChar;
		CDC* pDC = GetDC();
		CFont* pOldFont;
		if (theApp.IsChicago())
		 	pOldFont = pDC->SelectObject(GetStdFont(font_Normal));
		else
		 	pOldFont = pDC->SelectObject(GetStdFont(font_NormalBold));

	    TEXTMETRIC tm;
	    pDC->GetTextMetrics(&tm);

	    if (tm.tmPitchAndFamily & 0x01)
	    {
	        CHAR szAveCharWidth[52];        // array to hold A-Z and a-z

	        for (int i = 0; i < 26; i++)
	        {
	            szAveCharWidth[i] = (CHAR)(i + 'a');
	            szAveCharWidth[i + 26] = (CHAR)(i + 'A');
	        }

			CSize sizeExtent = pDC->GetTextExtent(szAveCharWidth, 52);
			cxChar = ((sizeExtent.cx / 26) + 1) / 2;
	    }
	    else
	    {
	        cxChar = tm.tmAveCharWidth;
	    }

		pDC->SelectObject(pOldFont);
		ReleaseDC(pDC);

		int duWidth = duButtonWidth;
		if (_getmbcp() != 0)
			duWidth += 10;	// Need a little extra space for japanese.

		m_buttonSize.cx = cxChar * duWidth / 4;
		m_buttonSize.cy = tm.tmHeight * duButtonHeight / 8;
		m_cxBetweenButtons = cxChar * duBetweenButtons / 4;
	}

	// Override to specify left, right, top and bottom margins around the tabs
	rect.SetRect(cxTabMargin, cyTabMargin, cxTabMargin, cyTabMargin);

	// If we have any buttons, leave space for them at the bottom
	if (GetButtonFromIndex(0) != NULL)
		rect.bottom += cyBottomMargin + m_buttonSize.cy;
}

void CTabbedDialog::OnLButtonDown(UINT nFlags, CPoint point)
{
	int nTab = m_tabRow.TabFromPoint(point);
	switch(nTab)
	{
		default:
			ASSERT(nTab >= 0);
			SetFocusToControl(this);
			SelectTab(nTab);
			break;

		case CTabRow::SCROLL_LEFT:
		case CTabRow::SCROLL_RIGHT:
			m_tabRow.Scroll(nTab);
			m_tabRow.Capture(nTab);
			break;

		case -1:
			break;
	}
}

void CTabbedDialog::OnTimer(UINT nTimerID)
{
	if (m_tabRow.HasCapture())
	{
		ASSERT(nTimerID == CTabRow::TIMER_ID);
		m_tabRow.OnTimer();
	}
	else
		CWnd::OnTimer(nTimerID);
}

void CTabbedDialog::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_tabRow.HasCapture())
		m_tabRow.OnMouseMove(point);
	else
		CWnd::OnMouseMove(nFlags, point);
}

void CTabbedDialog::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_tabRow.HasCapture())
		m_tabRow.OnLButtonUp(point);
	else
		CWnd::OnLButtonUp(nFlags, point);
}

void CTabbedDialog::DrawFocusRect()
{
	if (!m_tabRow.HasFocus())
		return;		

	CDC* pDC = GetDC();
	m_tabRow.DrawFocusRect(pDC);
	ReleaseDC(pDC);
}

void CTabbedDialog::OnSetFocus(CWnd* pOldWnd)
{
	if (m_tabRow.HasFocus())
		DrawFocusRect();
	else
		(void) ActivateTab(m_nTabCur);
}

void CTabbedDialog::OnKillFocus(CWnd* pNewWnd)
{
	if (IsWindowVisible() && m_tabRow.HasFocus())
		DrawFocusRect();
}

void CTabbedDialog::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized)
{
	// Changed this routine to use m_hFocusWnd instead of m_pFocusWnd
	if (nState == WA_INACTIVE)
	{
		m_hFocusWnd = ::GetFocus();
		m_tabRow.PutFocus(m_hFocusWnd == GetSafeHwnd());
	}
	else
	{
		CWnd* pWnd = CWnd::FromHandle(m_hFocusWnd);

		// Focus is either in the CTabRow or belongs to a control.
		if (m_nTabCur != -1)
		{
			if ((pWnd != NULL) && !m_tabRow.HasFocus())
			{
				SetFocusToControl(pWnd);
			}
			else
			{
				m_tabRow.InvalidateTab(m_nTabCur);
				SetFocusToControl(this);
			}
		}

		return;
	}
	
	CWnd::OnActivate(nState, pWndOther, bMinimized);
}

void CTabbedDialog::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	int nTab = m_nTabCur;

	switch (nChar)
	{
		case VK_ESCAPE:
			PostMessage(WM_COMMAND, IDCANCEL);
			break;

		case VK_LEFT:
			nTab -= 1;
			break;

		case VK_RIGHT:
			nTab += 1;
			break;

#ifdef _DEBUG
		case VK_RETURN:
		case VK_TAB:
			ASSERT(FALSE);
			break;
#endif // _DEBUG

		default:
			HandleTabRowKey(nChar);
			return;
	}

	if (nTab != m_nTabCur)
	{
		// if we have other arrow keys pending, coalesce
		MSG msg;
		while (::PeekMessage(&msg, GetSafeHwnd(), WM_KEYDOWN, WM_KEYDOWN, PM_NOREMOVE)
		       && (msg.wParam == VK_LEFT || msg.wParam == VK_RIGHT))
		{
			// remove the message and increment tab as necessary
			::PeekMessage(&msg, GetSafeHwnd(), WM_KEYDOWN, WM_KEYDOWN, PM_REMOVE);
			nTab += (msg.wParam == VK_RIGHT ? 1 : -1);
		}

		// make sure new tab is in legal range
		while (nTab < 0)
			nTab += max(m_tabs.GetSize(), 1);
		nTab %= m_tabs.GetSize();

		SelectTab(nTab);
	}
}

void CTabbedDialog::EndDialog(int nEndID)
{
	if (m_nTabCur != -1)
	{
		CString strCaption = m_tabRow.GetTabString(m_nTabCur);
		m_DialogMap.RememberTab(nCaptionID, strCaption);
	}

	m_nID = nEndID;
	m_pParentWnd->EnableWindow(TRUE);
	SetWindowPos(NULL, 0, 0, 0, 0,
  		SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOMOVE |
  		SWP_NOSIZE | SWP_NOZORDER);

	// Destroy all the tabs. We do it here, so that the toolbar
	// customiz dialog can reenable the MDIClient before we reset the
	// active window.
	int nTabs = m_tabs.GetSize();
	for (int i = 0; i < nTabs; i++)
	{
		delete m_tabs[i];	// We have delete responsibility.
		m_tabs[i] = NULL;
	}

	m_pParentWnd->SetActiveWindow();	// SetFocus messes up dock workers.
	DestroyWindow();
}

void CTabbedDialog::OnOK()
{
	if (m_nTabCur != -1)
	{
		CDlgTab* pTab = GetTab(m_nTabCur);
		if (!pTab->ValidateTab())
		{
			TRACE("Tab %s refused deactivation!\n",
				(const char*)GetTab(m_nTabCur)->m_strCaption);
			return;
		}

		pTab->Deactivate(this);
	}

	// At this point, all tabs must be valid.  We commit all changes.
	for (int nTab = 0 ; nTab < m_tabs.GetSize() ; nTab++)
		if (GetTab(nTab)->GetSafeHwnd() != NULL)
			GetTab(nTab)->CommitTab();

	EndDialog(IDOK);
}

void CTabbedDialog::OnCancel()
{
	if (m_nTabCur != -1)
	{
		CDlgTab* pTab = GetTab(m_nTabCur);
		pTab->Deactivate(this);
	}

	// Cancel changes on all tabs.
	for (int nTab = 0 ; nTab < m_tabs.GetSize() ; nTab++)
		if (GetTab(nTab)->GetSafeHwnd() != NULL)
			GetTab(nTab)->CancelTab();

	EndDialog(IDCANCEL);
}

void CTabbedDialog::OnHelp()
{
	// If there is a current popup, give it the first chance to handle
	// this help request.
	CWnd* pWnd = GetTopLevelParent();
	HWND hWnd = ::GetLastActivePopup(pWnd->GetSafeHwnd());

	if (::SendMessage(hWnd, WM_COMMANDHELP, 0, 0))
		return;

	// Otherwise, let the current DlgTab process the help request.
	if (m_nTabCur != -1)
		GetTab(m_nTabCur)->OnCommandHelp(0, 0);
}

void CTabbedDialog::OnClose()
{
	// just like cancel
	OnCancel();
}

void CTabbedDialog::OnSize(UINT nType, int cx, int cy)
{
	// We adjust the size a bit in here, so we must block recursion
	static BOOL bInHere;
	if (bInHere)
		return;

	CRect subject; // "page" dialog size
	CRect margins;  // "margin" sizes
	GetTabSize(subject);
	GetMargins(margins);

	CClientDC dc(this);
	int nTabHeight = m_tabRow.DesiredHeight(&dc);
	int nWidth = subject.Width() + margins.left + margins.right + 3;
	int nHeight = subject.Height() + margins.top + margins.bottom + nTabHeight + 3;

	// calculate our required width and height to accom. this tab size
	CRect rectClient(0, 0, nWidth, nHeight);
	CRect dialog = rectClient;
	AdjustWindowRectEx(dialog, GetStyle(), FALSE, GetExStyle());

	bInHere = TRUE;
	SetWindowPos(NULL, 0, 0, dialog.Width(), dialog.Height(),
		SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
	bInHere = FALSE;

	// center the tabbed dialog in the main window
    CenterWindow(AfxGetApp()->m_pMainWnd);

	// set up the size/position of the tab row
	CPoint pt = GetDlgTabPos();
	m_tabRow.SetPos(CRect(pt.x - 1, pt.y - nTabHeight, pt.x + subject.Width() + 2, pt.y));

	// create our buttons and move them into place
	CreateButtons();
	int nBottomBorder = dialog.bottom - rectClient.bottom;
	MoveButtons(margins.left,
		dialog.bottom - (margins.bottom + nBottomBorder) / 2);
}

void CTabbedDialog::GetTabSize(CRect & rect)
{
	// *must* have a tab to do the initial sizing!
	CDlgTab * pTab = GetTab(m_nTabCur);
	ASSERT(pTab != (CDlgTab *)NULL);
	pTab->GetWindowRect(rect);
}

void CTabbedDialog::CreateButtons()
{
	// Create the OK, Cancel, and Help buttons (or Close and Help, if the
	// dialog prefers that commit model).
	//
	// This function also creates the buttons if necessary.  While it might
	// seem preferable to create the buttons in CTabbedDialog::Create, that
	// actually doesn't work, since this function will be called in the
	// middle of the tabbed dialog's creation.

	if (m_btnOk.GetSafeHwnd() != NULL)
		return;

	CString str;
	CRect rcEmpty;
	rcEmpty.SetRectEmpty();

	str.LoadString((m_commitModel == commitOnOk) ? IDS_TABDLG_OK : IDS_TABDLG_CLOSE);
	m_btnOk.Create(str, WS_CHILD | WS_TABSTOP | BS_DEFPUSHBUTTON, rcEmpty, this, IDOK);

	str.LoadString(IDS_TABDLG_CANCEL);
	m_btnCancel.Create(str, WS_CHILD | WS_TABSTOP, rcEmpty, this, IDCANCEL);

	str.LoadString(IDS_TABDLG_HELP);
	m_btnHelp.Create(str, WS_CHILD | WS_TABSTOP, rcEmpty, this, ID_HELP);
}

void CTabbedDialog::MoveButtons(int nLeft, int nCenter)
{
	// Position the buttons along the bottom of the dialog
	// centered in the bottom margin.
	int y = nCenter - m_buttonSize.cy / 2;
	int x = nLeft;
	int index = 0;

	CButton* pButton;
	CButton* pButtonPrev = NULL;

	// Cycle through all the buttons, positioning them along the bottom
	for (pButton = GetButtonFromIndex(index) ; pButton != NULL ;
	     pButton = GetButtonFromIndex(++index) )
	{
		if (theApp.IsChicago())
			pButton->SetFont(GetStdFont(font_Normal));
		else
			pButton->SetFont(GetStdFont(font_NormalBold));

		pButton->SetWindowPos(pButtonPrev == NULL ? &wndBottom : pButtonPrev,
		                      x, y, m_buttonSize.cx, m_buttonSize.cy, SWP_NOACTIVATE);
		pButton->ShowWindow(SW_SHOW);

		x += m_buttonSize.cx + m_cxBetweenButtons;
		pButtonPrev = pButton;
	}
}

void CTabbedDialog::SetDefButtonIndex(int index)
{
	CButton* pbtnDef;
	
	if (m_iDefBtnIndex != -1)
	{
		pbtnDef = GetButtonFromIndex(m_iDefBtnIndex);
		// remove the default style bit
		::SetWindowLong(pbtnDef->GetSafeHwnd(), GWL_STYLE,
						::GetWindowLong(pbtnDef->GetSafeHwnd(), GWL_STYLE) & ~BS_DEFPUSHBUTTON);
		pbtnDef->Invalidate();
	}

	if (index != -1)
	{
		pbtnDef = GetButtonFromIndex(index);
		// add the default style bit
		::SetWindowLong(pbtnDef->GetSafeHwnd(), GWL_STYLE,
						::GetWindowLong(pbtnDef->GetSafeHwnd(), GWL_STYLE) | BS_DEFPUSHBUTTON);
		pbtnDef->Invalidate();
	}
	
	// remember this
	m_iDefBtnIndex = index;
}

BOOL CTabbedDialog::IsButton(HWND hWnd)
{
	int i = 0;
	CButton* pButton;

	while ((pButton = GetButtonFromIndex(i++)) != NULL)
		if (pButton->GetSafeHwnd() == hWnd)
			return TRUE;

	return FALSE;
}

CButton* CTabbedDialog::GetButtonFromIndex(int index)
{
	// Default is either OK/Cancel/Help or Close/Help, depending on
	// commit model.  Derived classes may override this, of course.
	if (m_commitModel != commitOnOk && (index > 0))
		index++;

	switch (index)
	{
		case 0:
			return &m_btnOk;

		case 1:
			return &m_btnCancel;

		case 2:
			return &m_btnHelp;

		default:
			return NULL;
	}
}

BOOL CTabbedDialog::ActivateTab(int nTab)
{
	CDlgTab *pTab;

	// activating no tab (or a tab that doesn't exist) is a no-op
	if (nTab == -1 || (pTab = GetTab(nTab)) == (CDlgTab *)NULL)
		return FALSE;

	if (pTab->Activate(this, GetDlgTabPos()))
	{
		SetFocusToControl(this);
		return TRUE;
	}

	return FALSE;
}

CPoint CTabbedDialog::GetDlgTabPos()
{
	CRect margins;
	GetMargins(margins);

	int nTabHeight;
	CRect rect = m_tabRow.GetRect();
	if (rect.IsRectEmpty())
	{
		CClientDC dc(this);
		nTabHeight = m_tabRow.DesiredHeight(&dc);
	}
	else
	{
		nTabHeight = rect.Height();
	}

	return CPoint(margins.left + 1, margins.top + 1 + nTabHeight);
}

void CTabbedDialog::OnParentNotify(UINT message, LPARAM lParam)
{
	CWnd::OnParentNotify(message, lParam);

	// We have to move the focus and default button state to the
	// proper button whenever focus changes in the dialog.
	if (message == WM_LBUTTONDOWN)
	{
		CPoint pt = CPoint(LOWORD(lParam), HIWORD(lParam));
		ClientToScreen(&pt);
		CWnd* pControl = WindowFromPoint(pt);
		if (pControl != NULL)
			SetFocusToControl(pControl, NULL, FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\tabmsgs.cpp ===
//-----------------------------------------------------------------------------
//  TabMsgs.cpp
//
//  Tab (Chicago control) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static VALUETABLE tblTCRetOK[] =
{
	TABLEENTRY(LB_OKAY),
	TABLEENTRY(LB_ERR),
	TABLEENTRY(LB_ERRSPACE),
	TABLEEND
};

#ifndef DISABLE_WIN95_MESSAGES
//////////////////////////////////////////////////////////////////////////////

NODECODE(TCM_GETBKCOLOR);

DECODERET(TCM_GETBKCOLOR)
{
	PARM(clrBk, COLORREF, RET);
	POUTC(clrBk, DWORD);

	return TRUE;
}

NODECODEPARM(TCM_GETBKCOLOR);

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_SETBKCOLOR)
{
	PARM(clrBk, COLORREF, LP);
	POUTC(clrBk, DWORD);

	return TRUE;
}

DECODERET(TCM_SETBKCOLOR)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TCM_SETBKCOLOR);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TCM_GETIMAGELIST);

DECODERET(TCM_GETIMAGELIST)
{
	PARM(hImageList, HIMAGELIST, RET);
	POUTC(hImageList, DWORD);

	return TRUE;
}

NODECODEPARM(TCM_GETIMAGELIST);

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_SETIMAGELIST)
{
	PARM(hImageList, HIMAGELIST, LP);
	POUTC(hImageList, DWORD);

	return TRUE;
}

DECODERET(TCM_SETIMAGELIST)
{
	PARM(hPrevImageList, HIMAGELIST, RET);
	POUTC(hPrevImageList, DWORD);

	return TRUE;
}

NODECODEPARM(TCM_SETIMAGELIST);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TCM_GETITEMCOUNT);

DECODERET(TCM_GETITEMCOUNT)
{
	PARM(nCount, INT, RET);
	POUT(nCount);

	return TRUE;
}

NODECODEPARM(TCM_GETITEMCOUNT);

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_GETITEM)
{
	PARM(iItem, INT, WP);
	PARM(pitem, TC_ITEM FAR *, LP);

	POUT(iItem);
	POUTC(pitem, DWORD);

	return TRUE;
}

DECODERET(TCM_GETITEM)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(TCM_GETITEM)
{
	P2WPOUT();

	P2LPOUTPTR(TC_ITEM);
	P2IFSIZEOF(TC_ITEM)
	{
		PARM(pitem, TC_ITEM FAR *, ED2);
//		PARM(pszName, LPSTR, pitem->pszText);
		INDENT();
		P2OUTC(pitem, mask, UINT);
		P2OUTC(pitem, lpReserved1, UINT);
		P2OUTC(pitem, lpReserved2, UINT);
		P2OUTPTRSTR(pitem, pszText);
//		INDENT();
//		P2OUTS(pszName);
//		OUTDENT();
		P2OUT(pitem, cchTextMax);
		P2OUT(pitem, iImage);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_SETITEM)
{
	DECODELIKE(TCM_GETITEM);
}

DECODERET(TCM_SETITEM)
{
	DECODERETLIKE(TCM_GETITEM);
}

DECODEPARM(TCM_SETITEM)
{
	DECODEPARMLIKE(TCM_GETITEM);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_INSERTITEM)
{
	DECODELIKE(TCM_GETITEM);
}

DECODERET(TCM_INSERTITEM)
{
	PARM(iIndex, INT, RET);
	POUT(iIndex);

	return TRUE;
}

DECODEPARM(TCM_INSERTITEM)
{
	DECODEPARMLIKE(TCM_GETITEM);
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_DELETEITEM)
{
	PARM(iItem, INT, WP);
	POUT(iItem);

	return TRUE;
}

DECODERET(TCM_DELETEITEM)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TCM_DELETEITEM);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TCM_DELETEALLITEMS);

DECODERET(TCM_DELETEALLITEMS)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TCM_DELETEALLITEMS);

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_GETITEMRECT)
{
	PARM(iItem, INT, WP);
	PARM(prc, LPRECT, LP);

	POUT(iItem);
	POUTC(prc, DWORD);

	return TRUE;
}

DECODERET(TCM_GETITEMRECT)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

DECODEPARM(TCM_GETITEMRECT)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(prc, LPRECT, ED2);
		INDENT();
		P2OUT(prc, left);
		P2OUT(prc, top);
		P2OUT(prc, right);
		P2OUT(prc, bottom);
	}
}

//////////////////////////////////////////////////////////////////////////////

NODECODE(TCM_GETCURSEL);

DECODERET(TCM_GETCURSEL)
{
	PARM(iSelectedTab, INT, RET);
	POUT(iSelectedTab);

	return TRUE;
}

NODECODEPARM(TCM_GETCURSEL);

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_SETCURSEL)
{
	PARM(iItem, INT, WP);
	POUT(iItem);

	return TRUE;
}

DECODERET(TCM_SETCURSEL)
{
	PARM(iPrevIndex, INT, RET);
	POUT(iPrevIndex);

	return TRUE;
}

NODECODEPARM(TCM_SETCURSEL);

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_HITTEST)
{
	PARM(pinfo, TC_HITTESTINFO FAR *, LP);
	POUTC(pinfo, DWORD);

	return TRUE;
}

DECODERET(TCM_HITTEST)
{
	PARM(iIndex, INT, RET);
	POUT(iIndex);

	return TRUE;
}

DECODEPARM(TCM_HITTEST)
{
	P2WPOUT();

	P2LPOUTPTR(TC_HITTESTINFO);
	P2IFSIZEOF(TC_HITTESTINFO)
	{
		PARM(pinfo, TC_HITTESTINFO FAR *, ED2);
		INDENT();
		P2OUTPT(pinfo, pt);
		P2OUTC(pinfo, flags, UINT);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_SETITEMEXTRA)
{
	PARM(cb, INT, WP);
	POUT(cb);

	return TRUE;
}

DECODERET(TCM_SETITEMEXTRA)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TCM_SETITEMEXTRA);

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_ADJUSTRECT)
{
	PARM(fLarger, BOOL, WP);
	PARM(prc, LPRECT, LP);

	POUTB(fLarger);
	POUTC(prc, DWORD);

	return TRUE;
}

NODECODERET(TCM_ADJUSTRECT);

DECODEPARM(TCM_ADJUSTRECT)
{
	P2WPOUT();

	P2LPOUTPTR(RECT);
	P2IFSIZEOF(RECT)
	{
		PARM(prc, LPRECT, ED2);
		INDENT();
		P2OUT(prc, left);
		P2OUT(prc, top);
		P2OUT(prc, right);
		P2OUT(prc, bottom);
	}
}

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_SETITEMSIZE)
{
	PARM(cx, INT, LOLP);
	PARM(cy, INT, HILP);

	POUT(cx);
	POUT(cy);

	return TRUE;
}

DECODERET(TCM_SETITEMSIZE)
{
	PARM(cxPrev, INT, LORET);
	PARM(cyPrev, INT, HIRET);

	POUT(cxPrev);
	POUT(cyPrev);

	return TRUE;
}

NODECODEPARM(TCM_SETITEMSIZE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_REMOVEIMAGE)
{
	PARM(iImage, INT, WP);
	POUT(iImage);

	return TRUE;
}

NODECODERET(TCM_REMOVEIMAGE);

NODECODEPARM(TCM_REMOVEIMAGE);

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_SETPADDING)
{
	PARM(cx, INT, LOLP);
	PARM(cy, INT, HILP);

	POUT(cx);
	POUT(cy);

	return TRUE;
}

NODECODERET(TCM_SETPADDING);

NODECODEPARM(TCM_SETPADDING);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TCM_GETROWCOUNT);

DECODERET(TCM_GETROWCOUNT)
{
	PARM(iCount, INT, RET);
	POUT(iCount);

	return TRUE;
}

NODECODEPARM(TCM_GETROWCOUNT);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TCM_GETTOOLTIPS);

DECODERET(TCM_GETTOOLTIPS)
{
	PARM(hwndTT, HWND, RET);
	POUTC(hwndTT, DWORD);

	return TRUE;
}

NODECODEPARM(TCM_GETTOOLTIPS);

//////////////////////////////////////////////////////////////////////////////

DECODE(TCM_SETTOOLTIPS)
{
	PARM(hwndTT, HWND, WP);
	POUTC(hwndTT, DWORD);

	return TRUE;
}

NODECODERET(TCM_SETTOOLTIPS);

NODECODEPARM(TCM_SETTOOLTIPS);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TCM_GETCURFOCUS);

DECODERET(TCM_GETCURFOCUS)
{
	PARM(iItem, INT, RET);
	POUT(iItem);

	return TRUE;
}

NODECODEPARM(TCM_GETCURFOCUS);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TCM_SETCURFOCUS);

NODECODERET(TCM_SETCURFOCUS);

NODECODEPARM(TCM_SETCURFOCUS);

//////////////////////////////////////////////////////////////////////////////
#endif	// DISABLE_WIN95_MESSAGES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\ProjBld\Edit-n-go\Bin\spyxx.v4\tbmsgs.cpp ===
//-----------------------------------------------------------------------------
//  TBMsgs.cpp
//
//  Toolbar (Chicago control) message crackers.

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifndef DISABLE_WIN95_MESSAGES

static VALUETABLE tblTBStyles[] =
{
	TABLEENTRY(TBSTYLE_CHECKGROUP),
	TABLEENTRY(TBSTYLE_BUTTON),
	TABLEENTRY(TBSTYLE_SEP),
	TABLEENTRY(TBSTYLE_CHECK),
	TABLEENTRY(TBSTYLE_GROUP),
	TABLEENTRY(TBSTYLE_TOOLTIPS),
	TABLEENTRY(TBSTYLE_WRAPABLE),
	TABLEENTRY(TBSTYLE_ALTDRAG),
	TABLEEND
};

static VALUETABLE tblTBStates[] =
{
	TABLEENTRY(TBSTATE_CHECKED),
	TABLEENTRY(TBSTATE_PRESSED),
	TABLEENTRY(TBSTATE_ENABLED),
	TABLEENTRY(TBSTATE_HIDDEN),
	TABLEENTRY(TBSTATE_INDETERMINATE),
	TABLEENTRY(TBSTATE_WRAP),
	TABLEEND
};
#endif // DISABLE_WIN95_MESSAGES
#ifndef DISABLE_WIN95_MESSAGES
//////////////////////////////////////////////////////////////////////////////

DECODE(TB_ENABLEBUTTON)
{
	PARM(idButton, INT, WP);
	PARM(fEnable, BOOL, LOLP);

	POUT(idButton);
	POUTB(fEnable);

	return TRUE;
}

DECODERET(TB_ENABLEBUTTON)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TB_ENABLEBUTTON);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_CHECKBUTTON)
{
	PARM(idButton, INT, WP);
	PARM(fCheck, BOOL, LOLP);

	POUT(idButton);
	POUTB(fCheck);

	return TRUE;
}

DECODERET(TB_CHECKBUTTON)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TB_CHECKBUTTON);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_PRESSBUTTON)
{
	PARM(idButton, INT, WP);
	PARM(fPress, BOOL, LOLP);

	POUT(idButton);
	POUTB(fPress);

	return TRUE;
}

DECODERET(TB_PRESSBUTTON)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TB_PRESSBUTTON);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_HIDEBUTTON)
{
	PARM(idButton, INT, WP);
	PARM(fShow, BOOL, LOLP);

	POUT(idButton);
	POUTB(fShow);

	return TRUE;
}

DECODERET(TB_HIDEBUTTON)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TB_HIDEBUTTON);

//////////////////////////////////////////////////////////////////////////////

DECODE(TB_INDETERMINATE)
{
	PARM(idButton, INT, WP);
	PARM(fIndeterminate, BOOL, LOLP);

	POUT(idButton);
	POUTB(fIndeterminate);

	return TRUE;
}

DECODERET(TB_INDETERMINATE)
{
	PARM(fSuccess, INT, RET);
	TABLEORINT(tblTrueFalse, fSuccess);

	return TRUE;
}

NODECODEPARM(TB_INDETERMINATE);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TB_ISBUTTONENABLED);

DECODERET(TB_ISBUTTONENABLED)
{
	PARM(fIsEnabled, INT, RET);
	TABLEORINT(tblTrueFalse, fIsEnabled);

	return TRUE;
}

NODECODEPARM(TB_ISBUTTONENABLED);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TB_ISBUTTONCHECKED);

DECODERET(TB_ISBUTTONCHECKED)
{
	PARM(fIsChecked, INT, RET);
	TABLEORINT(tblTrueFalse, fIsChecked);

	return TRUE;
}

NODECODEPARM(TB_ISBUTTONCHECKED);

//////////////////////////////////////////////////////////////////////////////

NODECODE(TB_ISBUTTONPRESSED);

DECODERET(TB_ISBUTTONPRESSED)
{
	PARM(fIsPressed, INT, RET);
	TABLEORINT(tblTrueFalse, fIsPressed);

	return TRUE;
}

NODECODEPARM(TB_ISBUTTONPRESSED);

///////////////////////////////////////