utton(GetDlgItem(hDlg,LOWORD(wParam)));
				int bit = iBut->IsChecked() ? 1 : 0;
				int shift = LOWORD(wParam) - IDC_SMOOTH_GRP1;
				ep->SetSelSmoothBits(bit<<shift,1<<shift);
				ReleaseICustButton(iBut);
				break;
			}
			switch ( LOWORD(wParam) ) {				
				// Material
				case IDC_SELECT_BYID: {										
					if (DialogBoxParam(
						hInstance, 
						MAKEINTRESOURCE(IDD_SELECTBYMAT),
						ep->ip->GetMAXHWnd(), 
						SelectByMatDlgProc,
						(LPARAM)sbmParams)) {
					
						ep->SelectByMat(sbmParams[0]-1/*index*/,sbmParams[1]/*clear*/);
						}
					break;
					}
				// Smoothing groups
				case IDC_SELECTBYSMOOTH: {										
					sbsParams[2] = ~ep->GetUsedSmoothBits();
					if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_EM_SELECTBYSMOOTH),
								ep->ip->GetMAXHWnd(), SelectBySmoothDlgProc, (LPARAM)sbsParams)) {
						ep->SelectBySmoothGroup(sbsParams[0],(BOOL)sbsParams[1]);
					}
					break;
					}
				case IDC_SMOOTH_CLEAR:
					ep->SetSelSmoothBits(0,0xffffffff);
					break;
				}
			break;
		}
	
	return FALSE;
	}

BOOL CALLBACK PatchObjSurfDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	EditPatchMod *ep = (EditPatchMod *)GetWindowLong( hDlg, GWL_USERDATA );
	if ( !ep && message != WM_INITDIALOG ) return FALSE;
	
	switch ( message ) {
		case WM_INITDIALOG: {

		 	ep = (EditPatchMod *)lParam;
		 	ep->hSurfPanel = hDlg;
			SetWindowLong( hDlg, GWL_USERDATA, (LONG)ep );		 	
			if (!ep->settingViewportTess  && ep->settingDisp && ep->GetProdTess().type == TESS_SET)
				ep->settingDisp = FALSE;
			TessApprox t;
			if (ep->settingViewportTess) {
				t = ep->GetViewTess();
			} else {
				if (ep->settingDisp)
					t = ep->GetDispTess();
				else
					t = ep->GetProdTess();
			}
			ep->uSpin = SetupIntSpinner( hDlg, IDC_TESS_U_SPINNER, IDC_TESS_U, 1, 100, t.u);
			ep->vSpin = SetupIntSpinner( hDlg, IDC_TESS_V_SPINNER, IDC_TESS_V, 1, 100, t.v);
#define MAX_F 1000.0f
			ep->edgeSpin = SetupFloatSpinner( hDlg, IDC_TESS_EDGE_SPINNER, IDC_TESS_EDGE, 0.0f, MAX_F, t.edge);
			ep->distSpin = SetupFloatSpinner( hDlg, IDC_TESS_DIST_SPINNER, IDC_TESS_DIST, 0.0f, MAX_F, t.dist);
			ep->angSpin =  SetupFloatSpinner( hDlg, IDC_TESS_ANG_SPINNER,  IDC_TESS_ANG, 0.0f, MAX_F, t.ang);
			ep->mergeSpin =  SetupFloatSpinner( hDlg, IDC_MERGE_SPINNER,  IDC_MERGE, 0.000f, MAX_F, t.merge);
			ep->SetTessUI(hDlg, &t);
		 	ep->SetSurfDlgEnables();
			return TRUE;
			}

		case WM_DESTROY:
			if( ep->uSpin ) {
				ReleaseISpinner(ep->uSpin);
				ep->uSpin = NULL;
				}
			if( ep->vSpin ) {
				ReleaseISpinner(ep->vSpin);
				ep->vSpin = NULL;
				}
			if( ep->edgeSpin ) {
				ReleaseISpinner(ep->edgeSpin);
				ep->edgeSpin = NULL;
				}
			if( ep->distSpin ) {
				ReleaseISpinner(ep->distSpin);
				ep->distSpin = NULL;
				}
			if( ep->angSpin ) {
				ReleaseISpinner(ep->angSpin);
				ep->angSpin = NULL;
				}
			if( ep->mergeSpin ) {
				ReleaseISpinner(ep->mergeSpin);
				ep->mergeSpin = NULL;
				}
			return FALSE;
		
		case CC_SPINNER_BUTTONUP: {
			TessApprox tess;
			if (ep->settingViewportTess) {
				tess = ep->GetViewTess();
			} else {
				if (ep->settingDisp)
					tess = ep->GetDispTess();
				else
					tess = ep->GetProdTess();
			}
			ep->SetTessUI(hDlg, &tess);
			}
			break;

		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_TESS_U_SPINNER:
				case IDC_TESS_V_SPINNER:
				case IDC_TESS_EDGE_SPINNER:
				case IDC_TESS_DIST_SPINNER:
				case IDC_TESS_ANG_SPINNER:
				case IDC_MERGE_SPINNER:
					{
					TessApprox tess;
					if (ep->settingViewportTess) {
						tess = ep->GetViewTess();
					} else {
						if (ep->settingDisp)
							tess = ep->GetDispTess();
						else
							tess = ep->GetProdTess();
					}
					switch(LOWORD(wParam) ) {
						case IDC_TESS_U_SPINNER:
							tess.u = ep->uSpin->GetIVal();
							break;
						case IDC_TESS_V_SPINNER:
							tess.v = ep->vSpin->GetIVal();
							break;
						case IDC_TESS_EDGE_SPINNER:
							tess.edge = ep->edgeSpin->GetFVal();
							break;
						case IDC_TESS_DIST_SPINNER:
							tess.dist = ep->distSpin->GetFVal();
							break;
						case IDC_TESS_ANG_SPINNER:
							tess.ang = ep->angSpin->GetFVal();
							break;
						case IDC_MERGE_SPINNER:
							tess.merge = ep->mergeSpin->GetFVal();
							break;
						}
					if (ep->settingViewportTess) {
						ep->SetViewTess(tess);
					} else {
						if (ep->settingDisp)
							ep->SetDispTess(tess);
						else
							ep->SetProdTess(tess);
					}
					if(!HIWORD(wParam))
						ep->SetTessUI(hDlg, &tess);
					break;
					}
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:   			
   			ep->ip->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;		
		
		case WM_COMMAND:			
			switch ( LOWORD(wParam) ) {				
				// Tessellation
				case IDC_TESS_VIEW:	{
					ep->settingViewportTess = TRUE;
					TessApprox t = ep->GetViewTess();
					ep->SetTessUI(hDlg, &t);
					EnableWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), FALSE); // always off here
					break;}
				case IDC_TESS_RENDERER: {
					ep->settingViewportTess = FALSE;
					if (ep->settingDisp) {
						TessApprox t = ep->GetDispTess();
						ep->SetTessUI(hDlg, &t);
					} else {
						TessApprox t = ep->GetProdTess();
						ep->SetTessUI(hDlg, &t);
					}
					break;}
				case IDC_MESH:
					ep->settingDisp = FALSE;
					ep->SetTessUI(hDlg, &ep->GetProdTess());
					break;
				case IDC_DISP:
					ep->settingDisp = TRUE;
					ep->SetTessUI(hDlg, &ep->GetDispTess());
					break;
//watje 12-10-98
				case IDC_SHOW_INTERIOR_FACES:
				case IDC_TESS_SET:
				case IDC_TESS_REGULAR:
				case IDC_TESS_PARAM:
				case IDC_TESS_SPATIAL:
				case IDC_TESS_CURV:
				case IDC_TESS_LDA:
					{
					TessApprox tess;
					if (ep->settingViewportTess) {
						tess = ep->GetViewTess();
					} else {
						if (ep->settingDisp)
							tess = ep->GetDispTess();
						else
							tess = ep->GetProdTess();
					}
					switch (LOWORD(wParam)) {
//watje 12-10-98
					case IDC_SHOW_INTERIOR_FACES:
						tess.showInteriorFaces = IsDlgButtonChecked(hDlg, IDC_SHOW_INTERIOR_FACES);
						break;
					case IDC_TESS_SET:
						tess.type = TESS_SET;
						EnableWindow(GetDlgItem(hDlg, IDC_SHOW_INTERIOR_FACES), TRUE);
						break;
					case IDC_TESS_REGULAR:
						tess.type = TESS_REGULAR;
						EnableWindow(GetDlgItem(hDlg, IDC_SHOW_INTERIOR_FACES), TRUE);
						break;
					case IDC_TESS_PARAM:
						tess.type = TESS_PARAM;
						EnableWindow(GetDlgItem(hDlg, IDC_SHOW_INTERIOR_FACES), TRUE);
						break;
					case IDC_TESS_SPATIAL:
						tess.type = TESS_SPATIAL;
						EnableWindow(GetDlgItem(hDlg, IDC_SHOW_INTERIOR_FACES), TRUE);
						break;
					case IDC_TESS_CURV:
						tess.type = TESS_CURVE;
						EnableWindow(GetDlgItem(hDlg, IDC_SHOW_INTERIOR_FACES), TRUE);
						break;
					case IDC_TESS_LDA:
						tess.type = TESS_LDA;
						EnableWindow(GetDlgItem(hDlg, IDC_SHOW_INTERIOR_FACES), TRUE);
						break;
					}
					if (ep->settingViewportTess) {
						ep->SetViewTess(tess);
					} else {
						if (ep->settingDisp)
							ep->SetDispTess(tess);
						else
							ep->SetProdTess(tess);
					}
					ep->SetTessUI(hDlg, &tess);
					}
					break;
				case IDC_TESS_VIEW_DEP: {
					TessApprox tess;
					tess = ep->GetProdTess();
					tess.view = IsDlgButtonChecked(hDlg, IDC_TESS_VIEW_DEP);
					if (ep->settingDisp)
						ep->SetDispTess(tess);
					else
						ep->SetProdTess(tess);
					}
					break;
				case IDC_TESS_NORMALS:
					if (ep->settingViewportTess) {
						ep->SetViewTessNormals(IsDlgButtonChecked(hDlg, IDC_TESS_NORMALS));
						ep->SetTessUI(hDlg, &ep->GetViewTess());
					} else {
						ep->SetProdTessNormals(IsDlgButtonChecked(hDlg, IDC_TESS_NORMALS));
						if (ep->settingDisp)
							ep->SetTessUI(hDlg, &ep->GetDispTess());
						else
							ep->SetTessUI(hDlg, &ep->GetProdTess());
					}
					break;
				case IDC_WELDTESS:
					if (ep->settingViewportTess) {
						ep->SetViewTessWeld(IsDlgButtonChecked(hDlg, IDC_WELDTESS));
						ep->SetTessUI(hDlg, &ep->GetViewTess());
					} else {
						ep->SetProdTessWeld(IsDlgButtonChecked(hDlg, IDC_WELDTESS));
						if (ep->settingDisp)
							ep->SetTessUI(hDlg, &ep->GetDispTess());
						else
							ep->SetTessUI(hDlg, &ep->GetProdTess());
					}
					break;
				case IDC_ADVANCED_PARAMETERS: {
					TessApprox tess;
					if (ep->settingViewportTess) {
						tess = ep->GetViewTess();
					} else {
						if (ep->settingDisp)
							tess = ep->GetDispTess();
						else
							tess = ep->GetProdTess();
					}
					sParams.mStyle = tess.subdiv;
					sParams.mMin = tess.minSub;
					sParams.mMax = tess.maxSub;
					sParams.mTris = tess.maxTris;
					int retval = DialogBox( hInstance,
								MAKEINTRESOURCE(IDD_SURF_APPROX_ADV),
								ep->ip->GetMAXHWnd(), AdvParametersDialogProc);
					if (retval == 1) {
						BOOL confirm = FALSE;
						if ((sParams.mStyle == SUBDIV_DELAUNAY && sParams.mTris > 200000) ||
							(sParams.mStyle != SUBDIV_DELAUNAY && sParams.mMax > 5)) {
							// warning!
							TSTR title = GetString(IDS_ADV_SURF_APPROX_WARNING_TITLE),
								warning = GetString(IDS_ADV_SURF_APPROX_WARNING);
							if (MessageBox(hDlg, warning, title,
								MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2 ) == IDYES)
								confirm = TRUE;
 
						} else
							confirm = TRUE;
						if (confirm) {
							// do it, they've been warned!
							tess.subdiv = sParams.mStyle;
							tess.minSub = sParams.mMin;
							tess.maxSub = sParams.mMax;
							tess.maxTris = sParams.mTris;
							if (ep->settingViewportTess) {
								ep->SetViewTess(tess);
							} else {
								if (ep->settingDisp)
									ep->SetDispTess(tess);
								else
									ep->SetProdTess(tess);
							}
						}
					}
					break;
					}
				}
			break;
		}
	
	return FALSE;
	}

// Advanced TessApprox settings...

static ISpinnerControl* psMinSpin = NULL;
static ISpinnerControl* psMaxSpin = NULL;
static ISpinnerControl* psMaxTrisSpin = NULL;
// this max matches the MI max.
#define MAX_SUBDIV 7


static BOOL initing = FALSE; // this is a hack but CenterWindow causes bad commands

BOOL CALLBACK
AdvParametersDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch (uMsg) {
    case WM_INITDIALOG: {
		initing = TRUE;
        CenterWindow(hDlg, GetCOREInterface()->GetMAXHWnd());
		initing = FALSE;
		psMinSpin = SetupIntSpinner( hDlg, IDC_TESS_MIN_REC_SPINNER, IDC_TESS_MIN_REC, 0, sParams.mMax, sParams.mMin);
		psMaxSpin = SetupIntSpinner( hDlg, IDC_TESS_MAX_REC_SPINNER, IDC_TESS_MAX_REC, sParams.mMin, MAX_SUBDIV, sParams.mMax);
		psMaxTrisSpin = SetupIntSpinner( hDlg, IDC_TESS_MAX_TRIS_SPINNER, IDC_TESS_MAX_TRIS, 0, 2000000, sParams.mTris);
		switch (sParams.mStyle) {
		case SUBDIV_GRID:
			CheckDlgButton( hDlg, IDC_GRID, TRUE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			break;
		case SUBDIV_TREE:
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, TRUE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			break;
		case SUBDIV_DELAUNAY:
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, TRUE);
			break;
		}
		break; }

    case WM_COMMAND:
		if (initing) return FALSE;
		switch ( LOWORD(wParam) ) {
		case IDOK:
			EndDialog(hDlg, 1);
			break;
		case IDCANCEL:
			EndDialog(hDlg, 0);
			break;
		case IDC_GRID:
			sParams.mStyle = SUBDIV_GRID;
			CheckDlgButton( hDlg, IDC_GRID, TRUE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			break;
		case IDC_TREE:
			sParams.mStyle = SUBDIV_TREE;
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, TRUE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			break;
		case IDC_DELAUNAY:
			sParams.mStyle = SUBDIV_DELAUNAY;
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, TRUE);
			break;
		}
		break;

    case CC_SPINNER_CHANGE:
		switch ( LOWORD(wParam) ) {
		case IDC_TESS_MIN_REC_SPINNER:
			sParams.mMin = psMinSpin->GetIVal();
			psMinSpin->SetLimits(0, sParams.mMax, FALSE);
			psMaxSpin->SetLimits(sParams.mMin, MAX_SUBDIV, FALSE);
			break;
		case IDC_TESS_MAX_REC_SPINNER:
			sParams.mMax = psMaxSpin->GetIVal();
			psMinSpin->SetLimits(0, sParams.mMax, FALSE);
			psMaxSpin->SetLimits(sParams.mMin, MAX_SUBDIV, FALSE);
			break;
		case IDC_TESS_MAX_TRIS_SPINNER:
			sParams.mTris = psMaxTrisSpin->GetIVal();
			break;
		}
		break;

	case WM_DESTROY:
		if( psMinSpin ) {
			ReleaseISpinner(psMinSpin);
			psMinSpin = NULL;
		}
		if( psMaxSpin ) {
			ReleaseISpinner(psMaxSpin);
			psMaxSpin = NULL;
		}
		if( psMaxTrisSpin ) {
			ReleaseISpinner(psMaxTrisSpin);
			psMaxTrisSpin = NULL;
		}
		break;
	}

	return FALSE;
}

#define OLD_SEL_LEVEL_CHUNK 0x1000	// Original backwards ordering
#define SEL_LEVEL_CHUNK 0x1001
#define DISP_LATTICE_CHUNK 0x1010
#define DISP_SURFACE_CHUNK 0x1020
#define DISP_VERTS_CHUNK 0x1030
#define EPM_MESH_ATTRIB_CHUNK	0x1040
#define EPM_VTESS_ATTRIB_CHUNK	0x1090
#define EPM_PTESS_ATTRIB_CHUNK	0x10a0
#define EPM_DTESS_ATTRIB_CHUNK	0x10b0
#define EPM_NORMAL_TESS_ATTRIB_CHUNK	0x10c0
#define EPM_WELD_TESS_ATTRIB_CHUNK	0x10d0
#define EPM_RENDERSTEPS_CHUNK		0x10e0
#define EPM_SHOWINTERIOR_CHUNK		0x10f0
// The following chunk is written on r3 and later files
// If not present, named selection data structures need fixup
#define EPM_SEL_NAMES_OK 0x1100	

// Names of named selection sets
#define NAMEDVSEL_NAMES_CHUNK	0x1050
#define NAMEDESEL_NAMES_CHUNK	0x1060
#define NAMEDPSEL_NAMES_CHUNK	0x1070
#define NAMEDSEL_STRING_CHUNK	0x1080

static int namedSelID[] = {
	NAMEDVSEL_NAMES_CHUNK,
	NAMEDESEL_NAMES_CHUNK,
	NAMEDPSEL_NAMES_CHUNK};


IOResult EditPatchMod::Save(ISave *isave) {
	Modifier::Save(isave);
	Interval valid;
	ULONG nb;
	// In r3 and later, if the named sel names are OK, write this chunk
	if(!namedSelNeedsFixup) {
		isave->BeginChunk(EPM_SEL_NAMES_OK);
		isave->EndChunk();
		}
	isave->BeginChunk(SEL_LEVEL_CHUNK);
	isave->Write(&selLevel,sizeof(int),&nb);
	isave->	EndChunk();
	isave->BeginChunk(DISP_LATTICE_CHUNK);
	isave->Write(&displayLattice,sizeof(BOOL),&nb);
	isave->	EndChunk();
	isave->BeginChunk(DISP_SURFACE_CHUNK);
	isave->Write(&displaySurface,sizeof(BOOL),&nb);
	isave->	EndChunk();
	isave->BeginChunk(EPM_MESH_ATTRIB_CHUNK);
	isave->Write(&meshSteps,sizeof(int),&nb);
// Future use (Not used now)
	BOOL fakeAdaptive = FALSE;
	isave->Write(&fakeAdaptive,sizeof(BOOL),&nb);
//	isave->Write(&meshAdaptive,sizeof(BOOL),&nb);	// Future use (Not used now)
	isave->	EndChunk();

//3-18-99 to suport render steps and removal of the mental tesselator
	isave->BeginChunk(EPM_RENDERSTEPS_CHUNK);
	if ( (meshStepsRender < 0) || (meshStepsRender > 100))
		{
		meshStepsRender = 5;
		DbgAssert(0);
		}
	isave->Write(&meshStepsRender,sizeof(int),&nb);
	isave->	EndChunk();
	isave->BeginChunk(EPM_SHOWINTERIOR_CHUNK);
	isave->Write(&showInterior,sizeof(BOOL),&nb);
	isave->	EndChunk();

	isave->BeginChunk(EPM_VTESS_ATTRIB_CHUNK);
	viewTess.Save(isave);
	isave->	EndChunk();
	isave->BeginChunk(EPM_PTESS_ATTRIB_CHUNK);
	prodTess.Save(isave);
	isave->	EndChunk();
	isave->BeginChunk(EPM_DTESS_ATTRIB_CHUNK);
	dispTess.Save(isave);
	isave->	EndChunk();

	isave->BeginChunk(EPM_NORMAL_TESS_ATTRIB_CHUNK);
	isave->Write(&mViewTessNormals,sizeof(BOOL),&nb);
	isave->Write(&mProdTessNormals,sizeof(BOOL),&nb);
	isave->	EndChunk();
	isave->BeginChunk(EPM_WELD_TESS_ATTRIB_CHUNK);
	isave->Write(&mViewTessWeld,sizeof(BOOL),&nb);
	isave->Write(&mProdTessWeld,sizeof(BOOL),&nb);
	isave->	EndChunk();
	
	// Save names of named selection sets
	for (int j=0; j<3; j++) {
		if (namedSel[j].Count()) {
			isave->BeginChunk(namedSelID[j]);			
			for (int i=0; i<namedSel[j].Count(); i++) {
				isave->BeginChunk(NAMEDSEL_STRING_CHUNK);
				isave->WriteWString(*namedSel[j][i]);
				isave->EndChunk();
				}
			isave->EndChunk();
			}
		}
	return IO_OK;
	}

IOResult EditPatchMod::LoadNamedSelChunk(ILoad *iload,int level)
	{	
	IOResult res;
	
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case NAMEDSEL_STRING_CHUNK: {
				TCHAR *name;
				res = iload->ReadWStringChunk(&name);
				// Set the name in the modifier
				AddSet(TSTR(name),level+1);
				break;
				}
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

IOResult EditPatchMod::Load(ILoad *iload) {
	Modifier::Load(iload);
	IOResult res;
	ULONG nb;
	namedSelNeedsFixup = TRUE;	// Pre-r3 default
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case EPM_SEL_NAMES_OK:
				namedSelNeedsFixup = FALSE;
				break;
			case NAMEDVSEL_NAMES_CHUNK: {				
				res = LoadNamedSelChunk(iload,0);
				break;
				}
			case NAMEDESEL_NAMES_CHUNK: {
				res = LoadNamedSelChunk(iload,1);
				break;
				}
			case NAMEDPSEL_NAMES_CHUNK: {
				res = LoadNamedSelChunk(iload,2);
				break;
				}

			case OLD_SEL_LEVEL_CHUNK:	// Correct backwards ordering
				{
				short sl;
				res = iload->Read(&sl,sizeof(short),&nb);
				selLevel = sl;
				switch(selLevel) {
					case 1:
						selLevel = EP_PATCH;
						break;
					case 3:
						selLevel = EP_VERTEX;
						break;
					}
				}
				break;
			case SEL_LEVEL_CHUNK:
				res = iload->Read(&selLevel,sizeof(int),&nb);
				break;
			case DISP_LATTICE_CHUNK:
				res = iload->Read(&displayLattice,sizeof(BOOL),&nb);
				break;
			case DISP_SURFACE_CHUNK:
				res = iload->Read(&displaySurface,sizeof(BOOL),&nb);
				break;
			case DISP_VERTS_CHUNK:
				iload->SetObsolete();
				break;
			case EPM_MESH_ATTRIB_CHUNK:
				res = iload->Read(&meshSteps,sizeof(int),&nb);
				res = iload->Read(&meshAdaptive,sizeof(BOOL),&nb);
				break;
//3-18-99 to suport render steps and removal of the mental tesselator
			case EPM_RENDERSTEPS_CHUNK:
				res = iload->Read(&meshStepsRender,sizeof(int),&nb);
				if ( (meshStepsRender < 0) || (meshStepsRender > 100))
					{
					meshStepsRender = 5;
					DbgAssert(0);
					}
				break;
			case EPM_SHOWINTERIOR_CHUNK:
				res = iload->Read(&showInterior,sizeof(BOOL),&nb);
				break;

			case EPM_VTESS_ATTRIB_CHUNK:
				viewTess.Load(iload);
				break;
			case EPM_PTESS_ATTRIB_CHUNK:
				prodTess.Load(iload);
				break;
			case EPM_DTESS_ATTRIB_CHUNK:
				dispTess.Load(iload);
				break;
			case EPM_NORMAL_TESS_ATTRIB_CHUNK:
				res = iload->Read(&mViewTessNormals,sizeof(BOOL),&nb);
				res = iload->Read(&mProdTessNormals,sizeof(BOOL),&nb);
				break;
			case EPM_WELD_TESS_ATTRIB_CHUNK:
				res = iload->Read(&mViewTessWeld,sizeof(BOOL),&nb);
				res = iload->Read(&mProdTessWeld,sizeof(BOOL),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}


#define EDITPATCHDATA_CHUNK 0x1000

IOResult EditPatchMod::SaveLocalData(ISave *isave, LocalModData *ld) {
	EditPatchData *ep = (EditPatchData *)ld;

	isave->BeginChunk(EDITPATCHDATA_CHUNK);
	ep->Save(isave);
	isave->EndChunk();

	return IO_OK;
	}

IOResult EditPatchMod::LoadLocalData(ILoad *iload, LocalModData **pld) {
	IOResult res;
	EditPatchData *ep;
	if (*pld==NULL) {
		*pld =(LocalModData *) new EditPatchData(this);
		}
	ep = (EditPatchData *)*pld;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case EDITPATCHDATA_CHUNK:
				res = ep->Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

// ------------------------------------------------------

int EPM_ExtrudeMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m ) {	
	ViewExp *vpt=ip->GetViewport (hwnd);
	Point3 p0, p1;
	ISpinnerControl *spin;
	BOOL ln;
	IPoint2 m2;
	float amount;
	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		if (!point) {
			po->BeginExtrude(ip->GetTime());		
			om = m;
		} else {
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			po->EndExtrude(ip->GetTime(),TRUE);

		}
		break;

	case MOUSE_MOVE:
		p0 = vpt->MapScreenToView(om,float(-200));
		// sca 1999.02.24: Find m's projection in om's vertical axis:
		m2.x = om.x;
		m2.y = m.y;
		p1 = vpt->MapScreenToView(m2,float(-200));
		amount = Length (p1-p0);
		if (m.y > om.y) amount *= -1.0f;

		ln = IsDlgButtonChecked(po->hOpsPanel,IDC_EM_EXTYPE_B);
		po->Extrude (ip->GetTime(), amount, ln);

		spin = GetISpinner(GetDlgItem(po->hOpsPanel,IDC_EP_EXTRUDESPINNER));
		if (spin) {
			spin->SetValue(amount, FALSE);	// sca - use signed value here too.
			ReleaseISpinner(spin);
		}
		ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
		break;

	case MOUSE_ABORT:
		po->EndExtrude(ip->GetTime(),FALSE);			
		ip->RedrawViews(ip->GetTime(),REDRAW_END);
		break;
	}

	if (vpt) ip->ReleaseViewport(vpt);
	return TRUE;
}

HCURSOR EPM_ExtrudeSelectionProcessor::GetTransformCursor() { 
	static HCURSOR hCur = NULL;
	if ( !hCur ) hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_EXTRUDECUR));
	return hCur; 
}

void EPM_ExtrudeCMode::EnterMode() {
	if (!po->hOpsPanel) return;
	ICustButton *but = GetICustButton(GetDlgItem(po->hOpsPanel,IDC_EP_EXTRUDE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void EPM_ExtrudeCMode::ExitMode() {
	if (!po->hOpsPanel) return;
	ICustButton *but = GetICustButton(GetDlgItem(po->hOpsPanel,IDC_EP_EXTRUDE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
	ISpinnerControl *spin;
	spin = GetISpinner(GetDlgItem(po->hOpsPanel,IDC_EP_EXTRUDESPINNER));
	if (spin) {
		spin->SetValue(0.0f,FALSE);
		ReleaseISpinner(spin);
		}

}



// ------------------------------------------------------

int EPM_BevelMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m ) {	
	ViewExp *vpt=ip->GetViewport (hwnd);
	Point3 p0, p1;
	ISpinnerControl *spin;
	int ln,ln2;
	IPoint2 m2;
	float amount;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		if (point==0) {
			po->BeginExtrude(ip->GetTime());		
			om = m;
			} 
		else if (point==1) {
			po->EndExtrude(ip->GetTime(),TRUE);
			po->BeginBevel(ip->GetTime());		
			om = m;
			} 
		else {
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			po->EndBevel(ip->GetTime(),TRUE);
		}
		break;

	case MOUSE_MOVE:
		if (point == 1)
			{
			p0 = vpt->MapScreenToView(om,float(-200));
			// sca 1999.02.24: find worldspace point with om's x value and m's y value
			m2.x = om.x;
			m2.y = m.y;
			p1 = vpt->MapScreenToView(m2, float(-200));
			amount = Length (p1-p0);
			ln = IsDlgButtonChecked(po->hOpsPanel,IDC_EM_EXTYPE_B);					
			if (om.y < m.y) amount *= -1.0f;
			po->Extrude (ip->GetTime(), amount, ln);

			spin = GetISpinner(GetDlgItem(po->hOpsPanel,IDC_EP_EXTRUDESPINNER));
			if (spin) {
				spin->SetValue (amount, FALSE);
				ReleaseISpinner(spin);
				}
			ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
			}
		else if (point == 2)
			{
			p0 = vpt->MapScreenToView(om,float(-200));
			// sca 1999.02.24: find worldspace point with om's x value and m's y value
			m2.x = om.x;
			m2.y = m.y;
			p1 = vpt->MapScreenToView(m2, float(-200));
			if (IsDlgButtonChecked(po->hOpsPanel,IDC_EP_SM_SMOOTH)) ln = 0;					
			else if (IsDlgButtonChecked(po->hOpsPanel,IDC_EP_SM_SMOOTH2)) ln = 1;					
			else if (IsDlgButtonChecked(po->hOpsPanel,IDC_EP_SM_SMOOTH3)) ln = 2;					

			if (IsDlgButtonChecked(po->hOpsPanel,IDC_EP_SM_SMOOTH4)) ln2 = 0;					
			else if (IsDlgButtonChecked(po->hOpsPanel,IDC_EP_SM_SMOOTH5)) ln2 = 1;					
			else if (IsDlgButtonChecked(po->hOpsPanel,IDC_EP_SM_SMOOTH6)) ln2 = 2;					

			amount = Length(p1-p0);
			if (om.y < m.y) amount *= -1.0f;
			po->Bevel (ip->GetTime(), amount, ln, ln2);

			spin = GetISpinner(GetDlgItem(po->hOpsPanel,IDC_EP_OUTLINESPINNER));
			if (spin) {
				spin->SetValue(amount,FALSE);
				ReleaseISpinner(spin);
				}
			ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
			}
		break;

	case MOUSE_ABORT:
		if (point==1)
			po->EndExtrude(ip->GetTime(),FALSE);			
		else if (point>1)
			po->EndBevel(ip->GetTime(),FALSE);			
			

		ip->RedrawViews(ip->GetTime(),REDRAW_END);
		break;
	}

	if (vpt) ip->ReleaseViewport(vpt);
	return TRUE;
}

HCURSOR EPM_BevelSelectionProcessor::GetTransformCursor() { 
	static HCURSOR hCur = NULL;
	if ( !hCur ) hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_BEVEL));
	return hCur; 
}

void EPM_BevelCMode::EnterMode() {
	if (!po->hOpsPanel) return;
	ICustButton *but = GetICustButton(GetDlgItem(po->hOpsPanel,IDC_EP_BEVEL));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void EPM_BevelCMode::ExitMode() {
	if (!po->hOpsPanel) return;
	ICustButton *but = GetICustButton(GetDlgItem(po->hOpsPanel,IDC_EP_BEVEL));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
	ISpinnerControl *spin;
	spin = GetISpinner(GetDlgItem(po->hOpsPanel,IDC_EP_OUTLINESPINNER));
	if (spin) {
		spin->SetValue(0.0f,FALSE);
		ReleaseISpinner(spin);
		}

}

// --------------------------------------------------------------------
// IPatchSelect and IPatchOps interfaces   (JBW 2/2/99)

void* EditPatchMod::GetInterface(ULONG id) 
{
	switch (id)
	{
		case I_PATCHSELECT: return (IPatchSelect*)this;
		case I_PATCHSELECTDATA: return (IPatchSelectData*)this;
		case I_PATCHOPS: return (IPatchOps*)this;
		case I_SUBMTLAPI: return (ISubMtlAPI*)this;
	}
	return Modifier::GetInterface(id);
}

void EditPatchMod::StartCommandMode(patchCommandMode mode)
{
	switch (mode)
	{
		case PcmAttach:
			if (hOpsPanel != NULL)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ATTACH, 0);
			break;
		case PcmExtrude:
			if (hOpsPanel != NULL)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_EP_EXTRUDE, 0);
			break;
		case PcmBevel:
			if (hOpsPanel != NULL)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_EP_BEVEL, 0);
			break;
		case PcmBind:
			if (hOpsPanel != NULL)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_BIND, 0);
			break;
	}
}

void EditPatchMod::ButtonOp(patchButtonOp opcode)
{
	switch (opcode)
	{
		case PopUnbind:
			if (hOpsPanel != NULL)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_UNBIND, 0);
			break;
		case PopHide:
			if (hOpsPanel != NULL)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_HIDE, 0);
			break;
		case PopUnhideAll:
			if (hOpsPanel != NULL)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_UNHIDE, 0);
			break;
		case PopWeld:
			if (hOpsPanel != NULL && GetSubobjectLevel() == PO_VERTEX)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_WELD, 0);
			break;
		case PopDelete:
			if (hOpsPanel != NULL && GetSubobjectLevel() >= PO_VERTEX)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_PATCH_DELETE, 0);
			break;
		case PopSubdivide:
			if (hOpsPanel != NULL && GetSubobjectLevel() >= PO_EDGE)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_SUBDIVIDE, 0);
			break;
		case PopAddTri:
			if (hOpsPanel != NULL && GetSubobjectLevel() == PO_EDGE)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ADDTRI, 0);
			break;
		case PopAddQuad:
			if (hOpsPanel != NULL && GetSubobjectLevel() == PO_EDGE)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ADDQUAD, 0);
			break;
		case PopDetach:
			if (hOpsPanel != NULL && GetSubobjectLevel() == PO_PATCH)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_DETACH, 0);
			break;
	}
}

DWORD EditPatchMod::GetSelLevel()
{
	return GetSubobjectLevel();
}

void EditPatchMod::SetSelLevel(DWORD level)
{
}

void EditPatchMod::LocalDataChanged()
{
}

MtlID EditPatchMod::GetNextAvailMtlID(ModContext* mc) {
	if(!mc)
		return 1;
	EditPatchData *patchData = (EditPatchData*)mc->localData;
	if ( !patchData ) return 1;

	// If the mesh isn't yet cache, this will cause it to get cached.
	PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
	if(!patch) return 1;
	
	int mtlID = GetSelFaceUniqueMtlID(mc);

	if (mtlID == -1) {
		int i;
 		
		MtlID min, max;
		BOOL first = TRUE;

		for(int p = 0; p < patch->numPatches; ++p) {
			MtlID thisID = patch->getPatchMtlIndex(p);
			if(first) {
				min = max = thisID;
				first = FALSE;
				}
			else
			if(thisID < min)
				min = thisID;
			else
			if(thisID > max)
				max = thisID;
			}
		// If room below, return it
		if(min > 0)
			return min - 1;
		// Build a bit array to find any gaps		
		BitArray b;
		int bits = max - min + 1;
		b.SetSize(bits);
		b.ClearAll();
		for(p = 0; p < patch->numPatches; ++p)
			b.Set(patch->getPatchMtlIndex(p) - min);
		for(i = 0; i < bits; ++i) {
			if(!b[i])
				return (MtlID)(i + min);
			}
		// No gaps!  If room above, return it
		if(max < 65535)
			return max + 1;
		}
	return (MtlID)mtlID;
	}

BOOL EditPatchMod::HasFaceSelection(ModContext* mc) {
	// Are we the edited object?
	if (ip == NULL)  return FALSE;

	EditPatchData *patchData = (EditPatchData*)mc->localData;
	if ( !patchData ) return FALSE;

	// If the mesh isn't yet cache, this will cause it to get cached.
	PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
	if(!patch) return FALSE;

	// Is Patch selection active?
	if (selLevel == EP_PATCH && patch->patchSel.NumberSet()) return TRUE;
	
	return FALSE;
	}

void EditPatchMod::SetSelFaceMtlID(ModContext* mc, MtlID id, BOOL bResetUnsel) {
	int altered = 0;
	EditPatchData *patchData = (EditPatchData*)mc->localData;
	if ( !patchData ) return;

	// If the mesh isn't yet cache, this will cause it to get cached.
	PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
	if(!patch) return;
	
	// If this is the first edit, then the delta arrays will be allocated
	patchData->BeginEdit(ip->GetTime());

	if ( theHold.Holding() )
		theHold.Put(new PatchRestore(patchData,this,patch));

	for(int p = 0; p < patch->numPatches; ++p) {
		if(patch->patchSel[p]) {
			altered = TRUE;
			patch->setPatchMtlIndex(p, id);
			}
		}

	if(altered)	{
		patchData->UpdateChanges(patch, FALSE);
		InvalidateSurfaceUI();
		}

	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
	}

int	EditPatchMod::GetSelFaceUniqueMtlID(ModContext* mc) {
	int	mtlID;

	mtlID = GetSelFaceAnyMtlID(mc);
	if (mtlID == -1) return mtlID;

	EditPatchData *patchData = (EditPatchData*)mc->localData;
	if ( !patchData ) return 1;

	// If the mesh isn't yet cache, this will cause it to get cached.
	PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
	if(!patch) return 1;

	for(int p = 0; p < patch->numPatches; ++p) {
		if(patch->patchSel[p])
			continue;
		if(patch->getPatchMtlIndex(p) != mtlID)
			continue;
		mtlID = -1;
		}
	return mtlID;
	}

int	EditPatchMod::GetSelFaceAnyMtlID(ModContext* mc) {
	int				mtlID = -1;
	BOOL			bGotFirst = FALSE;

	EditPatchData *patchData = (EditPatchData*)mc->localData;
	if ( !patchData ) return 1;

	// If the mesh isn't yet cache, this will cause it to get cached.
	PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
	if(!patch) return 1;

	for(int p = 0; p < patch->numPatches; ++p) {
		if(!patch->patchSel[p])
			continue;
		if (bGotFirst) {
			if (mtlID != patch->getPatchMtlIndex(p)) {
				mtlID = -1;
				break;
				}
			}
		else {
			mtlID = patch->getPatchMtlIndex(p);
			bGotFirst = TRUE;
			}
		}
	return mtlID;
	}

int	EditPatchMod::GetMaxMtlID(ModContext* mc) {
	MtlID mtlID = 0;

	EditPatchData *patchData = (EditPatchData*)mc->localData;
	if ( !patchData ) return 1;

	// If the mesh isn't yet cache, this will cause it to get cached.
	PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
	if(!patch) return 1;

	for(int p = 0; p < patch->numPatches; ++p)
		mtlID = max(mtlID, patch->getPatchMtlIndex(p));

	return mtlID;
	}

/*-------------------------------------------------------------------*/

void EPM_BindCMode::EnterMode()
	{
	if ( pobj->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(pobj->hOpsPanel, IDC_BIND));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}
	}

void EPM_BindCMode::ExitMode()
	{
	if ( pobj->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(pobj->hOpsPanel, IDC_BIND));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}
	}
/*
void EditPatchMod::DoAddHook(int vert1, int seg1) {

	// If any bits are set in the selection set, let's DO IT!!
	if ( !ip ) return;
	theHold.Begin();
	POPatchGenRecord *rec = new POPatchGenRecord(this);
	if ( theHold.Holding() )
		theHold.Put(new PatchObjectRestore(this,rec));
		// Call the patch type change function

	patch.AddHook(vert1,seg1);
	patch.computeInteriors();
	patch.InvalidateGeomCache();
	InvalidateMesh();
	theHold.Accept(GetResString(IDS_TH_PATCHCHANGE));

	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);

	}
*./

/*-------------------------------------------------------------------*/

HCURSOR EPM_BindMouseProc::GetTransformCursor() 
	{ 
	static HCURSOR hCur = NULL;

	if ( !hCur ) {
		hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_SEGREFINECUR)); 
		}

	return hCur; 
	}

BOOL EPM_BindMouseProc::HitTest( 
		ViewExp *vpt, IPoint2 *p, int type, int flags, int subType  )
	{
	vpt->ClearSubObjHitList();
	SetPatchHitOverride(subType);

	ip->SubObHitTest(ip->GetTime(),type,ip->GetCrossing(),flags,p,vpt);
	ClearPatchHitOverride();
	if ( vpt->NumSubObjHits() ) {
		return TRUE;
	} else {
		return FALSE;
		}			
	}

BOOL EPM_BindMouseProc::HitAKnot(ViewExp *vpt, IPoint2 *p, int *vert) {
	int first = 1;
	
	if(HitTest(vpt, p, HITTYPE_POINT, 0,1) ) {
		HitLog &hits = vpt->GetSubObjHitList();
		HitRecord *rec = hits.First();
		DWORD best = 9999;
		HitRecord *bestRec;
		while(rec) {
			PatchHitData *hit = ((PatchHitData *)rec->hitData);
			// If there's an exclusion shape, this must be a part of it!
//			if( patch == hit->patch) {
			pMesh = hit->patch;
			if( 1) {
				if (hit->type == PATCH_HIT_VERTEX)
					{

				// If there's an exclusion shape, the vert & poly can't be the same!
					if(first || rec->distance < best) 
						{
						first = 0;
						best = rec->distance;
						bestRec = rec;
						}
					}
				}
			rec = rec->Next();
			}
		if(!first) {
			PatchHitData *hit = ((PatchHitData *)bestRec->hitData);
			*vert = hit->index;
			return TRUE;
			}
		}
	return FALSE;
	}


BOOL EPM_BindMouseProc::HitASegment(ViewExp *vpt, IPoint2 *p, int *seg) {
	int first = 1;
	
	if(HitTest(vpt, p, HITTYPE_POINT, 0,2) ) {
		HitLog &hits = vpt->GetSubObjHitList();
		HitRecord *rec = hits.First();
		DWORD best = 9999;
		HitRecord *bestRec;
		while(rec) {
			PatchHitData *hit = ((PatchHitData *)rec->hitData);
			// If there's an exclusion shape, this must be a part of it!
			if( pMesh == hit->patch) {
				if (hit->type == PATCH_HIT_EDGE)
					{

				// If there's an exclusion shape, the vert & poly can't be the same!
					if(first || rec->distance < best) 
						{
						first = 0;
						best = rec->distance;
						bestRec = rec;
						}
					}
				}
			rec = rec->Next();
			}
		if(!first) {
			PatchHitData *hit = ((PatchHitData *)bestRec->hitData);
			*seg = hit->index;
			return TRUE;
			}
		}
	return FALSE;
	}


static void PatchXORDottedLine( HWND hwnd, IPoint2 p0, IPoint2 p1 )
	{
	HDC hdc;
	hdc = GetDC( hwnd );
	SetROP2( hdc, R2_XORPEN );
	SetBkMode( hdc, TRANSPARENT );
	SelectObject( hdc, CreatePen( PS_DOT, 0, RGB(255,255,255) ) );
	MoveToEx( hdc, p0.x, p0.y, NULL );
	LineTo( hdc, p1.x, p1.y );		
	DeleteObject( SelectObject( hdc, GetStockObject( BLACK_PEN ) ) );
	ReleaseDC( hwnd, hdc );
	}


int EPM_BindMouseProc::proc(
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m )
	{
	ViewExp *vpt = ip->GetViewport(hwnd);	
	int res = TRUE;
	static PatchMesh *shape1 = NULL;
	static int poly1, vert1, seg1;
	static IPoint2 anchor, lastPoint;

	switch ( msg ) {
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:
			switch(point) {
				case 0:
					{
					if(HitAKnot(vpt, &m,  &vert1))
						{
						res = TRUE;
						anchor = lastPoint = m;
						PatchXORDottedLine(hwnd, anchor, m);	// Draw it!
//get valid seg list
						knotList.SetSize(pMesh->numVerts);
						knotList.ClearAll();
						for (int i = 0; i < pMesh->numEdges; i++)
							{
							if (pMesh->edges[i].v1 == vert1) 
								{
								knotList.Set(pMesh->edges[i].v2);

								}
							if (pMesh->edges[i].v2 == vert1) 
								{
								knotList.Set(pMesh->edges[i].v1);
								}
							}
						}
					else res = FALSE;

					break;
					}
				case 1:
					PatchXORDottedLine(hwnd, anchor, lastPoint);	// Erase it!
//					if(HitAnEndpoint(vpt, &m, shape1, poly1, vert1, NULL, &poly2, &vert2))
//						ss->DoVertConnect(vpt, shape1, poly1, vert1, poly2, vert2); 
					if(HitASegment(vpt, &m,  &seg1))
						{
//if a valid segemtn change cursor
						int a = pMesh->edges[seg1].v1;
						int b = pMesh->edges[seg1].v2;
						if (knotList[a] && knotList[b])
							pobj->DoAddHook(pMesh,vert1,seg1);

						}
					res = FALSE;
					break;
				default:
					assert(0);
				}
			break;

		case MOUSE_MOVE:
			// Erase old dotted line
			PatchXORDottedLine(hwnd, anchor, lastPoint);
			// Draw new dotted line
			PatchXORDottedLine(hwnd, anchor, m);
			lastPoint = m;
			if(HitASegment(vpt, &m,  &seg1))
				{
//if a valid segemtn change cursor
				int a = pMesh->edges[seg1].v1;
				int b = pMesh->edges[seg1].v2;
				if (knotList[a] && knotList[b])
					SetCursor(LoadCursor(hInstance,MAKEINTRESOURCE(IDC_TH_SELCURSOR)));
				else SetCursor(LoadCursor(NULL,IDC_ARROW));

				}
			else {
				SetCursor(LoadCursor(NULL,IDC_ARROW));
				}

			break;
					
		case MOUSE_FREEMOVE:
			if(HitAKnot(vpt, &m,  &vert1))
				{
				SetCursor(LoadCursor(hInstance,MAKEINTRESOURCE(IDC_TH_SELCURSOR)));
				}
			else {
				SetCursor(LoadCursor(NULL,IDC_ARROW));
				}
/*
			if ( HitTest(vpt,&m,HITTYPE_POINT,HIT_ABORTONHIT,1) ) {
				HitLog &hits = vpt->GetSubObjHitList();
				HitRecord *rec = hits.First();
				if (rec )
					{
					SetCursor(LoadCursor(hInstance,MAKEINTRESOURCE(IDC_TH_SELCURSOR)));
					}
				}
			SetCursor(LoadCursor(NULL,IDC_ARROW));
*/
			break;
		
		case MOUSE_ABORT:
			// Erase old dotted line
			PatchXORDottedLine(hwnd, anchor, lastPoint);
			break;			
		}

	if ( vpt ) ip->ReleaseViewport(vpt);
	return res;
	}

/*-------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\editpops.cpp ===
/**********************************************************************
 *<
	FILE: editsops.cpp

	DESCRIPTION:  Edit Shape OSM operations

	CREATED BY: Tom Hudson & Rolf Berteig

	HISTORY: created 25 April, 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "editpat.h"

extern CoreExport Class_ID patchClassID; 

// in mods.cpp
extern HINSTANCE hInstance;

/*-------------------------------------------------------------------*/

static void XORDottedLine( HWND hwnd, IPoint2 p0, IPoint2 p1 )
	{
	HDC hdc;
	hdc = GetDC( hwnd );
	SetROP2( hdc, R2_XORPEN );
	SetBkMode( hdc, TRANSPARENT );
	SelectObject( hdc, CreatePen( PS_DOT, 0, RGB(255,255,255) ) );
	MoveToEx( hdc, p0.x, p0.y, NULL );
	LineTo( hdc, p1.x, p1.y );		
	DeleteObject( SelectObject( hdc, GetStockObject( BLACK_PEN ) ) );
	ReleaseDC( hwnd, hdc );
	}

/*-------------------------------------------------------------------*/

EPTempData::~EPTempData()
	{
	if (patch) delete patch;
	}

EPTempData::EPTempData(EditPatchMod *m,EditPatchData *pd)
	{
	patch = NULL;
	patchValid.SetEmpty();
	patchData = pd;
	mod = m;
	}

void EPTempData::Invalidate(DWORD part,BOOL patchValid)
	{
	if ( !patchValid ) {
		delete patch;
		patch = NULL;
		}
	if ( part & PART_TOPO ) {
		}
	if ( part & PART_GEOM ) {
		}
	if ( part & PART_SELECT ) {
		}
	}

PatchMesh *EPTempData::GetPatch(TimeValue t)
	{
	if ( patchValid.InInterval(t) && patch ) {
		return patch;
	} else {
		patchData->SetFlag(EPD_UPDATING_CACHE,TRUE);
		mod->NotifyDependents(Interval(t,t), 
			PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|PART_DISPLAY|PART_TOPO,
		    REFMSG_MOD_EVAL);
		patchData->SetFlag(EPD_UPDATING_CACHE,FALSE);
		return patch;
		}
	}

BOOL EPTempData::PatchCached(TimeValue t)
	{
	return (patchValid.InInterval(t) && patch);
	}

void EPTempData::UpdateCache(PatchObject *patchOb)
	{
	if ( patch ) delete patch;
	patch = new PatchMesh(patchOb->patch);

	patchValid = FOREVER;
	
	// These are the channels we care about.
	patchValid &= patchOb->ChannelValidity(0,GEOM_CHAN_NUM);
	patchValid &= patchOb->ChannelValidity(0,TOPO_CHAN_NUM);
	patchValid &= patchOb->ChannelValidity(0,SELECT_CHAN_NUM);
	patchValid &= patchOb->ChannelValidity(0,SUBSEL_TYPE_CHAN_NUM);
	patchValid &= patchOb->ChannelValidity(0,DISP_ATTRIB_CHAN_NUM);	
	patchValid &= patchOb->ChannelValidity(0,TEXMAP_CHAN_NUM);	
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\editpat.h ===
/**********************************************************************
 *<
	FILE: editpat.h

	DESCRIPTION:  Edit Patch OSM

	CREATED BY: Tom Hudson, Dan Silva & Rolf Berteig

	HISTORY: created 23 June 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/


#ifndef __EDITPATCH_H__
#define __EDITPATCH_H__

#include "namesel.h"
#include "nsclip.h"
#include "sbmtlapi.h"

#define Alert(x) MessageBox(GetActiveWindow(),x,_T("Alert"),MB_OK);

#define EDITPAT_CHANNELS (PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|PART_DISPLAY|PART_TOPO|TEXMAP_CHANNEL)

// These are values for selLevel.
#define EP_OBJECT	0
#define EP_VERTEX	1
#define EP_EDGE		2
#define EP_PATCH	3

// Named selection set levels:
#define EP_NS_VERTEX 0
#define EP_NS_EDGE 1
#define EP_NS_PATCH 2
// Conversion from selLevel to named selection level:
static int namedSetLevel[] = { EP_NS_VERTEX, EP_NS_VERTEX, EP_NS_EDGE, EP_NS_PATCH };
static int namedClipLevel[] = { CLIP_P_VERT, CLIP_P_VERT, CLIP_P_EDGE, CLIP_P_PATCH };

#define MAX_MATID	0xffff

#define UNDEFINED	0xffffffff

#define CID_EPM_BIND	CID_USER + 203
#define CID_EPM_EXTRUDE	CID_USER + 204
#define CID_EPM_BEVEL	CID_USER + 205

class EditPatchMod;

class EPM_BindMouseProc : public MouseCallBack {
	private:
		EditPatchMod *pobj;
		IObjParam *ip;
		IPoint2 om;
		BitArray knotList;
		PatchMesh *pMesh;
	
	protected:
		HCURSOR GetTransformCursor();
		BOOL HitAKnot(ViewExp *vpt, IPoint2 *p, int *vert);
		BOOL HitASegment(ViewExp *vpt, IPoint2 *p, int *Seg);

		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags, int subType );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		

	public:
		EPM_BindMouseProc(EditPatchMod* spl, IObjParam *i) { pobj=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};



class EPM_BindCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		EPM_BindMouseProc eproc;
		EditPatchMod* pobj;
//		int type; // See above

	public:
		EPM_BindCMode(EditPatchMod* spl, IObjParam *i) :
			fgProc((ReferenceTarget*)spl), eproc(spl,i) {pobj=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_EP_BIND; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
//		void SetType(int type) { this->type = type; eproc.SetType(type); }
	};

class EPM_ExtrudeMouseProc : public MouseCallBack {
private:
	MoveTransformer moveTrans;
	EditPatchMod *po;
	Interface *ip;
	IPoint2 om;
	Point3 ndir;
public:
	EPM_ExtrudeMouseProc(EditPatchMod* o, IObjParam *i) : moveTrans(i) {po=o;ip=i;}
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m);
};


class EPM_ExtrudeSelectionProcessor : public GenModSelectionProcessor {
protected:
	HCURSOR GetTransformCursor();
public:
	EPM_ExtrudeSelectionProcessor(EPM_ExtrudeMouseProc *mc, EditPatchMod *o, IObjParam *i) 
		: GenModSelectionProcessor(mc,(BaseObject*) o,i) {}
};


class EPM_ExtrudeCMode : public CommandMode {
private:
	ChangeFGObject fgProc;
	EPM_ExtrudeSelectionProcessor mouseProc;
	EPM_ExtrudeMouseProc eproc;
	EditPatchMod* po;

public:
	EPM_ExtrudeCMode(EditPatchMod* o, IObjParam *i) :
		fgProc((ReferenceTarget *)o), mouseProc(&eproc,o,i), eproc(o,i) {po=o;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_EPM_EXTRUDE; }
	MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
	ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
	BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
	void EnterMode();
	void ExitMode();
};




class EPM_BevelMouseProc : public MouseCallBack {
private:
	MoveTransformer moveTrans;
	EditPatchMod *po;
	Interface *ip;
	IPoint2 om;
	
public:
	EPM_BevelMouseProc(EditPatchMod* o, IObjParam *i) : moveTrans(i) {po=o;ip=i;}
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m);
};


class EPM_BevelSelectionProcessor : public GenModSelectionProcessor {
protected:
	HCURSOR GetTransformCursor();
public:
	EPM_BevelSelectionProcessor(EPM_BevelMouseProc *mc, EditPatchMod *o, IObjParam *i) 
		: GenModSelectionProcessor(mc,(BaseObject*) o,i) {}
};


class EPM_BevelCMode : public CommandMode {
private:
	ChangeFGObject fgProc;
	EPM_BevelSelectionProcessor mouseProc;
	EPM_BevelMouseProc eproc;
	EditPatchMod* po;

public:
	EPM_BevelCMode(EditPatchMod* o, IObjParam *i) :
		fgProc((ReferenceTarget *)o), mouseProc(&eproc,o,i), eproc(o,i) {po=o;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_EPM_BEVEL; }
	MouseCallBack *MouseProc(int *numPoints) { *numPoints=3; return &mouseProc; }
	ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
	BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
	void EnterMode();
	void ExitMode();
};

class VertInsertRecord;
class PickPatchAttach;

class EditPatchMod : public Modifier, IPatchOps, IPatchSelect, ISubMtlAPI, AttachMatDlgUser {
	friend class EPTempData;
	friend class EditPatchData;
	friend class XFormProc;
	friend class PatchRestore;
	friend class PVertexRightMenu;
	friend class PatchRightMenu;
	friend class PickPatchAttach;

	public:
		static HWND hSelectPanel, hOpsPanel, hSurfPanel;
		static BOOL rsSel, rsOps, rsSurf;	// rollup states (FALSE = rolled up)
		static IObjParam *ip;		
		
		static MoveModBoxCMode *moveMode;
		static RotateModBoxCMode *rotMode;
		static UScaleModBoxCMode *uscaleMode;
		static NUScaleModBoxCMode *nuscaleMode;
		static SquashModBoxCMode *squashMode;
		static SelectModBoxCMode *selectMode;
		static ISpinnerControl *weldSpin;
		static ISpinnerControl *stepsSpin;
//3-18-99 to suport render steps and removal of the mental tesselator
		static ISpinnerControl *stepsRenderSpin;
		static PickPatchAttach pickCB;
		static BOOL patchUIValid;

//watje command mode for the extrude and beevl		
		static EPM_ExtrudeCMode *extrudeMode;
		static EPM_BevelCMode *bevelMode;
		static EPM_BindCMode *bindMode;

		// for the tessellation controls
		static BOOL settingViewportTess;  // are we doing viewport or renderer
		static BOOL settingDisp;          // if we're doign renderer is it mesh or displacmenent
		static ISpinnerControl *uSpin;
		static ISpinnerControl *vSpin;
		static ISpinnerControl *edgeSpin;
		static ISpinnerControl *angSpin;
		static ISpinnerControl *distSpin;
		static ISpinnerControl *mergeSpin;
		static ISpinnerControl *matSpin;
		static int attachMat;
		static BOOL condenseMat;

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message ) { return REF_SUCCEED; }
		
		int selLevel;

		// RB:named sel sets
		BOOL namedSelNeedsFixup;	// TRUE for pre-r3 files
		Tab<TSTR*> namedSel[3];
		int FindSet(TSTR &setName,int level);
		void AddSet(TSTR &setName,int level);
		void RemoveSet(TSTR &setName,int level);
		void RemoveAllSets();
		void ClearSetNames();

		// Remembered info
		PatchMesh *rememberedPatch;	// NULL if using all selected patches
		int rememberedIndex;
		int rememberedData;

		BOOL displaySurface;
		BOOL displayLattice;
		int meshSteps;
//3-18-99 to suport render steps and removal of the mental tesselator
		int meshStepsRender;
		BOOL showInterior;

		BOOL meshAdaptive;	// Future use (Not used now)
		TessApprox viewTess; // for GAP tessellation
		TessApprox prodTess;
		TessApprox dispTess;
		BOOL mViewTessNormals;	// use normals from the tesselator
		BOOL mProdTessNormals;	// use normals from the tesselator
		BOOL mViewTessWeld;	// Weld the mesh after tessellation
		BOOL mProdTessWeld;	// Weld the mesh after tessellation
		BOOL propagate;

		BOOL inExtrude;
		BOOL inBevel;


		EditPatchMod();
		~EditPatchMod();

		Interval LocalValidity(TimeValue t);
		ChannelMask ChannelsUsed()  { return EDITPAT_CHANNELS; }
		ChannelMask ChannelsChanged() 	{ return EDITPAT_CHANNELS; }
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		void NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc);
		Class_ID InputType() { return Class_ID(PATCHOBJ_CLASS_ID,0); }
		
		int CompMatrix(TimeValue t, ModContext& mc, Matrix3& tm, Interval& valid);
		
		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= TSTR(_T("EditPatchMod")); }
		Class_ID ClassID() { return Class_ID(EDITPATCH_CLASS_ID,0);}
		void* GetInterface(ULONG id);

		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flagst, ModContext *mc);
		void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);

		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		int SubObjectIndex(HitRecord *hitRec);

 		BOOL DependOnTopology(ModContext &mc);

		// Generic xform procedure.
		void XFormVerts( XFormProc *xproc, TimeValue t, Matrix3& partm, Matrix3& tmAxis );

		// Specialized xform for bezier handles
		void XFormHandles( XFormProc *xproc, TimeValue t, Matrix3& partm, Matrix3& tmAxis, int object, int handleIndex );

		// Affine transform methods		
		void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
		void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE );
		void Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );

		// The following is called before the first Move(), Rotate() or Scale() call
		void TransformStart(TimeValue t);

		// The following is called after the user has completed the Move, Rotate or Scale operation and
		// the undo object has been accepted.
		void TransformFinish(TimeValue t);		

		// The following is called when the transform operation is cancelled by a right-click and the undo
		// has been cancelled.
		void TransformCancel(TimeValue t);		

		BOOL SupportsNamedSubSels() {return TRUE;}
		void ActivateSubSelSet(TSTR &setName);
		void NewSetFromCurSel(TSTR &setName);
		void RemoveSubSelSet(TSTR &setName);
		void SetupNamedSelDropDown();
		int NumNamedSelSets();
		TSTR GetNamedSelSetName(int i);
		void SetNamedSelSetName(int i,TSTR &newName);
		void NewSetByOperator(TSTR &newName,Tab<int> &sets,int op);
		BOOL GetUniqueSetName(TSTR &name);
		int SelectNamedSet();
		void NSCopy();
		void NSPaste();
		void MaybeFixupNamedSels();

//watje 12-10-98
		void DoHide(int type); 
		void DoUnHide(); 
		void DoPatchHide(); 
		void DoVertHide(); 
		void DoEdgeHide(); 

		void DoAddHook(PatchMesh *pMesh, int vert1, int seg1) ;
		void DoRemoveHook(); 

//watje bevel and extrusion stuff
		void DoExtrude() ;
		void BeginExtrude(TimeValue t); 	
		void EndExtrude (TimeValue t, BOOL accept=TRUE);		
		void Extrude( TimeValue t, float amount, BOOL useLocalNorm );

		
		void DoBevel() ;
		void BeginBevel(TimeValue t); 	
		void EndBevel (TimeValue t, BOOL accept=TRUE);		
		void Bevel( TimeValue t, float amount, BOOL smoothStart, BOOL smoothEnd );




		void DoDeleteSelected();
		void DoVertDelete();
		void DoEdgeDelete();
		void DoPatchDelete();
		void DoPatchAdd(int type);
		void DoSubdivide(int type);
		void DoEdgeSubdivide();
		void DoPatchSubdivide();
		void DoVertWeld();
		void DoPatchDetach(int copy, int reorient);

		void ClearPatchDataFlag(ModContextList& mcList,DWORD f);
		void DeletePatchDataTempData();		
		void CreatePatchDataTempData();

		int NumRefs() { return 0; }
		RefTargetHandle GetReference(int i) { return NULL; }
		void SetReference(int i, RefTargetHandle rtarg) {}

		void ChangeRememberedPatch(int type);
		void ChangeSelPatches(int type);
		int RememberPatchThere(HWND hWnd, IPoint2 m);
		void SetRememberedPatchType(int type);
		void ChangeRememberedVert(int type);
		void ChangeSelVerts(int type);
		int RememberVertThere(HWND hWnd, IPoint2 m);
		void SetRememberedVertType(int type);

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		IOResult SaveLocalData(ISave *isave, LocalModData *ld);
		IOResult LoadLocalData(ILoad *iload, LocalModData **pld);
		IOResult LoadNamedSelChunk(ILoad *iload,int level);

		CreateMouseCallBack* GetCreateMouseCallBack() { return NULL; } 
		void BeginEditParams( IObjParam  *ip, ULONG flags, Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags, Animatable *next );
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_TH_EDITPATCH); }
		void ActivateSubobjSel(int level, XFormModes& modes );
		int NeedUseSubselButton() { return 0; }
		void SelectSubComponent( HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert );
		void ClearSelection(int selLevel);
		void SelectAll(int selLevel);
		void InvertSelection(int selLevel);
		
		void SetDisplaySurface(BOOL sw);
		void SetDisplayLattice(BOOL sw);
		void SetPropagate(BOOL sw);		
		BOOL GetPropagate() {return propagate;}		
		void SetMeshSteps(int count);
		int GetMeshSteps() { return meshSteps; }
//3-18-99 to suport render steps and removal of the mental tesselator
		void SetMeshStepsRender(int count);
		int GetMeshStepsRender() { return meshStepsRender; }
		void SetShowInterior(BOOL si);
		BOOL GetShowInterior() { return showInterior; }

// Future use (Not used now)
//		void SetMeshAdaptive(BOOL sw);
		void SetViewTess(TessApprox &tess);
		TessApprox GetViewTess() { return viewTess; }
		void SetProdTess(TessApprox &tess);
		TessApprox GetProdTess() { return prodTess; }
		void SetDispTess(TessApprox &tess);
		TessApprox GetDispTess() { return dispTess; }
		void SetTessUI(HWND hDlg, TessApprox *tess);
		BOOL GetViewTessNormals() { return mViewTessNormals; }
		void SetViewTessNormals(BOOL use);
		BOOL GetProdTessNormals() { return mProdTessNormals; }
		void SetProdTessNormals(BOOL use);
		BOOL GetViewTessWeld() { return mViewTessWeld; }
		void SetViewTessWeld(BOOL weld);
		BOOL GetProdTessWeld() { return mProdTessWeld; }
		void SetProdTessWeld(BOOL weld);

		// Get the commonality of material index for the selection (-1 indicates no commonality)
		int GetSelMatIndex();
		void SetSelMatIndex(int index);
		void SelectByMat(int index,BOOL clear);

		// Smoothing
		DWORD GetSelSmoothBits(DWORD &invalid);
		DWORD GetUsedSmoothBits();
		void SelectBySmoothGroup(DWORD bits,BOOL clear);
		void SetSelSmoothBits(DWORD bits,DWORD which);

		void PatchSelChanged();

		// from AttachMatDlgUser
		int GetAttachMat() { return attachMat; }
		void SetAttachMat(int value) { attachMat = value; }
		BOOL GetCondenseMat() { return condenseMat; }
		void SetCondenseMat(BOOL sw) { condenseMat = sw; }

		int DoAttach(INode *node, PatchMesh *attPatch, bool & canUndo);

		// Store current topology in the PatchObject
		void RecordTopologyTags();

		// Re-match named selection sets, etc. with changed topology (Call RecordTopologyTags
		// before making the changes to the shape, then call this)
		void ResolveTopoChanges();

		void RescaleWorldUnits(float f);

		int GetSubobjectLevel();
		void SetSubobjectLevel(int level);
		void RefreshSelType();
		void UpdateSelectDisplay();
		void SetSelDlgEnables();
		void SetOpsDlgEnables();
		void SetSurfDlgEnables();
		void SelectionChanged();
		void InvalidateSurfaceUI();
		BitArray *GetLevelSelectionSet(PatchMesh *patch);

		// patch select and operations interfaces, JBW 2/2/99
		void StartCommandMode(patchCommandMode mode);
		void ButtonOp(patchButtonOp opcode);

		DWORD GetSelLevel();
		void SetSelLevel(DWORD level);
		void LocalDataChanged();
	
		// ISubMtlAPI methods:
		MtlID	GetNextAvailMtlID(ModContext* mc);
		BOOL	HasFaceSelection(ModContext* mc);
		void	SetSelFaceMtlID(ModContext* mc, MtlID id, BOOL bResetUnsel = FALSE);
		int		GetSelFaceUniqueMtlID(ModContext* mc);
		int		GetSelFaceAnyMtlID(ModContext* mc);
		int		GetMaxMtlID(ModContext* mc);
	};

class PickPatchAttach : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		EditPatchMod *ep;
		
		PickPatchAttach() {ep=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		HCURSOR GetHitCursor(IObjParam *ip);

		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}

		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{return TRUE;}
	};

// Table to convert selLevel values to patch selLevel flags.
const int patchLevel[] = {PATCH_OBJECT,PATCH_VERTEX,PATCH_EDGE,PATCH_PATCH};

// Get display flags based on selLevel.
const DWORD patchLevelDispFlags[] = {0,DISP_VERTTICKS|DISP_SELVERTS,DISP_SELEDGES,DISP_SELPATCHES};

// For hit testing...
static int patchHitLevel[] = {0,SUBHIT_PATCH_VERTS | SUBHIT_PATCH_VECS,SUBHIT_PATCH_EDGES,SUBHIT_PATCH_PATCHES};

class EditPatchClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE ) { return new EditPatchMod; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_EDITPATCH_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(EDITPATCH_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFEDIT);}
	void			ResetClassParams(BOOL fileReset);
	};

typedef Tab<Point3> Point3Tab;

class XFormProc {
	public:
		virtual Point3 proc(Point3& p, Matrix3 &mat, Matrix3 &imat)=0;
		virtual void SetMat( Matrix3& mat ) {}
	};

class MoveXForm : public XFormProc {
	private:
		Point3 delta, tdelta;		
	public:
		Point3 proc(Point3& p, Matrix3 &mat, Matrix3 &imat) 
			{ return p + tdelta; }
		void SetMat( Matrix3& mat ) 
			{ tdelta = VectorTransform(Inverse(mat),delta); }
		MoveXForm(Point3 d) { delta = d; }
	};

class RotateXForm : public XFormProc {
	private:
		Matrix3 rot, trot;
	public:
		Point3 proc(Point3& p, Matrix3 &mat, Matrix3 &imat) 
			{ return (trot*p)*imat; }
		void SetMat( Matrix3& mat ) 
			{ trot = mat * rot; }
		RotateXForm(Quat q) { q.MakeMatrix(rot); }
	};

class ScaleXForm : public XFormProc {
	private:
		Matrix3 scale, tscale;
	public:
		Point3 proc(Point3& p, Matrix3 &mat, Matrix3 &imat) 
			{ return (p*tscale)*imat; }
		void SetMat( Matrix3& mat ) 
			{ tscale = mat*scale; }
		ScaleXForm(Point3 s) { scale = ScaleMatrix(s); }
	};

typedef Tab<int> IntTab;

// General-purpose patch point table -- Maintains point table for each of n polygons
class PatchPointTab {
	public:
		Point3Tab ptab;	// Patch mesh points
		Point3Tab vtab;	// Patch mesh vectors
		IntTab pttab;	// Patch point types
		PatchPointTab();
		~PatchPointTab();
		void Empty();
		void Zero();
		void MakeCompatible(PatchMesh& patch, BOOL clear=TRUE);
		PatchPointTab& operator=(PatchPointTab& from);
		BOOL IsCompatible(PatchMesh &patch);
		void RescaleWorldUnits(float f);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};

class PatchVertexDelta {
	public:
		PatchPointTab dtab;

		void SetSize(PatchMesh &patch, BOOL load=TRUE);
		void Empty() { dtab.Empty(); }
		void Zero() { dtab.Zero(); }
		void SetVert(int i, const Point3& p) { dtab.ptab[i] = p; }
		void SetVertType(int i, int k) { dtab.pttab[i] = k; }
		void SetVec(int i, const Point3& p) { dtab.vtab[i] = p; }
		void MoveVert(int i, const Point3& p) { dtab.ptab[i] += p; }
		void MoveVec(int i, const Point3& p) { dtab.vtab[i] += p; }
		void Apply(PatchMesh& patch);
		void UnApply(PatchMesh& patch);
		PatchVertexDelta& operator=(PatchVertexDelta& from) { dtab = from.dtab; return *this; }
		void ApplyHandlesAndZero(PatchMesh &patch, int handleVert);
		BOOL IsCompatible(PatchMesh &patch) { return dtab.IsCompatible(patch); }
		void RescaleWorldUnits(float f) { dtab.RescaleWorldUnits(f); }
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};

class AdjEdgeList;
class EPTempData;

/*-------------------------------------------------------------------*/

// Class for recording changes -- This is used to reconstruct an object from the original whenever
// the modifier is re-entered or whenever the system needs to reconstruct an object's cache.  This may be
// slow if a lot of changes have been recorded, but it's about the only way to properly reconstruct an object
// because the output of one operation becomes the input of the next.

// These are used as follows:
// When a user makes a modification to an object, a StartChangeGroup call needs to be made to the EditPatchData
// object.  Then a change record needs to be added for each sub-operation that makes up the modification.  These
// records are owned by the EditPatchData object, but they should also be referenced by the undo object for that
// operation.  If an undo is done, ownership of the modification record transfers to the undo/redo object and the
// record is REMOVED (NOT DELETED) from the EditPatchData object.  This keeps the record around for a redo operation
// but removes it from the list of records for the modifier.  If the undo is redone, ownership transfers back to
// the modifier, when it is re-added to the modification record list.

// Note that this class contains load and save methods, necessary because the modifier needs to be able to save
// and load them.  When you subclass off of this, be sure your load and save methods call the base class's first!

class PatchRestore;

class PModRecord {
	public:
		virtual BOOL Redo(PatchMesh *patch,int reRecord)=0;
		virtual IOResult Load(ILoad *iload)=0;
	};

typedef PModRecord* PPModRecord;
typedef Tab<PPModRecord> ModRecordTab;

/*-------------------------------------------------------------------*/

// Here are the types of modification records we use!

#define CLEARVERTSELRECORD_CHUNK	0x2000
#define SETVERTSELRECORD_CHUNK		0x2001
#define INVERTVERTSELRECORD_CHUNK	0x2002
#define CLEAREDGESELRECORD_CHUNK	0x2005
#define SETEDGESELRECORD_CHUNK		0x2006
#define INVERTEDGESELRECORD_CHUNK	0x2007
#define CLEARPATCHSELRECORD_CHUNK	0x2010
#define SETPATCHSELRECORD_CHUNK		0x2011
#define INVERTPATCHSELRECORD_CHUNK	0x2012
#define VERTSELRECORD_CHUNK			0x2020
#define EDGESELRECORD_CHUNK			0x2025
#define PATCHSELRECORD_CHUNK		0x2030
#define VERTMOVERECORD_CHUNK		0x2040
#define PATCHDELETERECORD_CHUNK		0x2050
#define VERTDELETERECORD_CHUNK		0x2060
#define PATCHCHANGERECORD_CHUNK		0x2070
#define VERTCHANGERECORD_CHUNK		0x2080
#define PATCHADDRECORD_CHUNK		0x2090
#define EDGESUBDIVIDERECORD_CHUNK	0x20A0
#define PATCHSUBDIVIDERECORD_CHUNK	0x20B0
#define VERTWELDRECORD_CHUNK		0x20C0
#define PATTACHRECORD_CHUNK			0x20D0
#define PATCHDETACHRECORD_CHUNK		0x20E0
#define PATCHMTLRECORD_CHUNK		0x20F0
										 
class ClearPVertSelRecord : public PModRecord {
	public:
		BitArray sel;	// Old state
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class SetPVertSelRecord : public PModRecord {
	public:
		BitArray sel;	// Old state
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class InvertPVertSelRecord : public PModRecord {
	public:
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class ClearPEdgeSelRecord : public PModRecord {
	public:
		BitArray sel;	// Old state
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class SetPEdgeSelRecord : public PModRecord {
	public:
		BitArray sel;	// Old state
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class InvertPEdgeSelRecord : public PModRecord {
	public:
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class ClearPatchSelRecord : public PModRecord {
	public:
		BitArray sel;	// Old state
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class SetPatchSelRecord : public PModRecord {
	public:
		BitArray sel;	// Old state
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class InvertPatchSelRecord : public PModRecord {
	public:
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PVertSelRecord : public PModRecord {
	public:
		BitArray oldSel;	// Old state
		BitArray newSel;	// New state
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PEdgeSelRecord : public PModRecord {
	public:
		BitArray oldSel;	// Old state
		BitArray newSel;	// New state
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PatchSelRecord : public PModRecord {
	public:
		BitArray oldSel;	// Old state
		BitArray newSel;	// New state
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PVertMoveRecord : public PModRecord {
	public:
		PatchVertexDelta delta;	// Position changes for each vertex (Wasteful!  Change later?)
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PatchDeleteRecord : public PModRecord {
	public:
		PatchMesh oldPatch;		// How the spline looked before the delete
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PVertDeleteRecord : public PModRecord {
	public:
		PatchMesh oldPatch;		// How the patch looked before the delete
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PatchChangeRecord : public PModRecord {
	public:
		PatchMesh oldPatch;		// How the patch mesh looked before the change
		int index;
		int type;
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PVertChangeRecord : public PModRecord {
	public:
		PatchMesh oldPatch;		// How the patch mesh looked before the change
		int index;
		int type;
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PatchAddRecord : public PModRecord {
	public:
		BOOL postWeld;			// Present in MAX 2.0 and up
		int type;				// 3 or 4 sides!
		PatchMesh oldPatch;		// How the patch looked before the addition
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class EdgeSubdivideRecord : public PModRecord {
	public:
		BOOL propagate;			// Carry around entire patch mesh?
		PatchMesh oldPatch;		// How the patch looked before the addition
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PatchSubdivideRecord : public PModRecord {
	public:
		BOOL propagate;			// Carry around entire patch mesh?
		PatchMesh oldPatch;		// How the patch looked before the addition
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PVertWeldRecord : public PModRecord {
	public:
		float thresh;			// Weld threshold
		BOOL propagate;			// Carry around entire patch mesh?
		PatchMesh oldPatch;		// How the patch looked before the addition
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PAttachRecord : public PModRecord {
	public:
		PatchMesh attPatch;			// The patch we're attaching
		int oldPatchCount;		// The number of splines present before attaching
		int mtlOffset;
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PatchDetachRecord : public PModRecord {
	public:
		int copy;
		PatchMesh oldPatch;
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

typedef Tab<MtlID> MtlIDTab;

class PatchMtlRecord : public PModRecord {
	public:
		MtlIDTab materials;		// Materials from selected patches
		MtlID index;				// New material index assigned
		BOOL Redo(PatchMesh *patch,int reRecord);
		IOResult Load(ILoad *iload);
	};

/*-------------------------------------------------------------------*/

// Vertex Mapping class -- Gives mapping from vert in original patch to
// vert in modified patch

class EPMapVert {
	public:
		BOOL originalStored;
		int vert;
		Point3 original;	// Original point location
		Point3 delta;		// The delta we've applied
		EPMapVert() { originalStored = FALSE; vert = 0; original = Point3(0,0,0); delta = Point3(0,0,0); }
		EPMapVert(int v, Point3 &o, Point3 &d) { vert = v; original = o; delta = d; originalStored = TRUE; }
	};

class EPVertMapper {
	public:
		int verts;
		EPMapVert *vertMap;
		int vecs;
		EPMapVert *vecMap;
		EPVertMapper() { verts = vecs = 0; vertMap = vecMap = NULL; }
		~EPVertMapper();
		// Set up remap data structures.
		void Build(PatchMesh &patch);
		// Update the deltas we have stored, if necessary and apply to output patch mesh.
		// This is in response to the original shape changing
		void UpdateAndApplyDeltas(PatchMesh &inPatch, PatchMesh &outPatch);
		// Recompute the deltas we have stored
		// This is done after the modifier's user interaction changes the shape
		void RecomputeDeltas(PatchMesh &patch);
		// Record the topology tags in the specified shape
		void RecordTopologyTags(PatchMesh &patch);
		// Update the topology tag mapping
		void UpdateMapping(PatchMesh &patch);
		EPVertMapper& operator=(EPVertMapper &from);
		void RescaleWorldUnits(float f);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};

/*-------------------------------------------------------------------*/

// EditPatchData flags
#define EPD_BEENDONE			(1<<0)
#define EPD_UPDATING_CACHE		(1<<1)
#define EPD_HASDATA				(1<<2)
#define EMD_HELD				(1<<3) // equivalent to A_HELD

// This is the data that each mod app will have.
class EditPatchData : public LocalModData {
	public:
		BOOL handleFlag;
		int handleVert;

		// Stuff we need to have for the patch's mesh conversion -- These are
		// Here because they're kind of a global change -- not undoable.
		int meshSteps;
//3-18-99 to suport render steps and removal of the mental tesselator
		int meshStepsRender;
		BOOL showInterior;

		BOOL meshAdaptive;	// Future use (Not used now)
		TessApprox viewTess;
		TessApprox prodTess;
		TessApprox dispTess;
		BOOL mViewTessNormals;	// use normals from the tesselator
		BOOL mProdTessNormals;	// use normals from the tesselator
		BOOL mViewTessWeld;	// Weld the mesh after tessellation
		BOOL mProdTessWeld;	// Weld the mesh after tessellation
		BOOL displaySurface;
		BOOL displayLattice;

		DWORD flags;

		// This records the changes to the incoming object.
		ModRecordTab changes;

		// A pointer to the change record's vertex delta object
		PatchVertexDelta vdelta;

		// RB: Named selection set lists
		GenericNamedSelSetList vselSet;  // Vertex
		GenericNamedSelSetList eselSet;  // Edge
		GenericNamedSelSetList pselSet;  // Patch

		// While an object is being edited, this exists.
		EPTempData *tempData;

		// The knot mapping for the edited patch
		EPVertMapper vertMap; 

		// The final edited patch
		PatchMesh finalPatch;

		EditPatchData(EditPatchMod *mod);
		EditPatchData(EditPatchData& emc);
		
		// Applies modifications to a patchObject
		void Apply(TimeValue t,PatchObject *patchOb,int selLevel);

		// Invalidates any caches affected by the change.
		void Invalidate(PartID part,BOOL meshValid=TRUE);
		
		// If this is the first edit, then the delta arrays will be allocated
		void BeginEdit(TimeValue t);

		LocalModData *Clone() { return new EditPatchData(*this); }
		
		void SetFlag(DWORD f,BOOL on) 
			{ 
			if ( on ) {
				flags|=f;
			} else {
				flags&=~f; 
				}
			}
		DWORD GetFlag(DWORD f) { return flags&f; }

		EPTempData *TempData(EditPatchMod *mod);

		// Change recording functions:
		void ClearHandleFlag() { handleFlag = FALSE; }
		void SetHandleFlag(int vert) { handleVert = vert; handleFlag = TRUE; }
		BOOL DoingHandles() { return handleFlag; }
		void ApplyHandlesAndZero(PatchMesh &patch) { vdelta.ApplyHandlesAndZero(patch, handleVert); }
		void RescaleWorldUnits(float f);

		// MAXr3: New recording system
		void RecordTopologyTags(PatchMesh *patch);
		void UpdateChanges(PatchMesh *patch, BOOL checkTopology=TRUE);

		// Named selection set access
		GenericNamedSelSetList &GetSelSet(EditPatchMod *mod);	// Get the one for the current subobject selection level
		GenericNamedSelSetList &GetSelSet(int level);	// Get the one for the specified subobject selection level

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};

// My generic restore class

class PatchRestore : public RestoreObj {
	public:
		PatchMesh oldPatch, newPatch;
		BOOL gotRedo;
		TimeValue t;
		EditPatchData *epd;
		EditPatchMod *mod;
		TSTR where;
		
		PatchRestore(EditPatchData* pd, EditPatchMod* mod, PatchMesh *patch, TCHAR *id=_T(""));

		void Restore(int isUndo);
		void Redo();
		int Size() { return 1; }
		void EndHold() {mod->ClearAFlag(A_HELD);}
		TSTR Description() {
			TSTR string;
			string.printf(_T("Generic patch restore [%s]"),where);
			return string;
			}
	};

// Patch selection restore class

class PatchSelRestore : public RestoreObj {
	public:
		BitArray oldVSel, newVSel;
		BitArray oldESel, newESel;
		BitArray oldPSel, newPSel;
		BOOL gotRedo;
		TimeValue t;
		EditPatchData *epd;
		EditPatchMod *mod;

		PatchSelRestore(EditPatchData* pd, EditPatchMod* mod, PatchMesh *patch);

		void Restore(int isUndo);
		void Redo();
		int Size() { return 1; }
		void EndHold() {mod->ClearAFlag(A_HELD);}
		TSTR Description() { return TSTR(_T("Patch Select restore")); }
	};

/*-------------------------------------------------------------------*/

class EPTempData {
	private:
		PatchMesh		*patch;
		Interval 		patchValid;
		
		EditPatchMod 	*mod;
		EditPatchData 	*patchData;

	public:		
		
		~EPTempData();
		EPTempData(EditPatchMod *m,EditPatchData *md);
		void Invalidate(PartID part,BOOL meshValid=TRUE);
		
		PatchMesh		*GetPatch(TimeValue t);
		
		BOOL PatchCached(TimeValue t);
		void UpdateCache(PatchObject *patchOb);
		EditPatchMod	*GetMod() { return mod; }
	};


// Patch hit override functions

extern void SetPatchHitOverride(int value);
extern void ClearPatchHitOverride();

#endif // __EDITPATCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\editspl.h ===
/**********************************************************************
 *<
	FILE: editspl.h

	DESCRIPTION:  Edit BezierShape OSM

	CREATED BY: Tom Hudson, Dan Silva & Rolf Berteig

	HISTORY: created 25 April 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __EDITSPLINE_H__
#define __EDITSPLINE_H__

#define Alert(x) MessageBox(GetActiveWindow(),x,_T("Alert"),MB_OK);

#include "shape.h"
#include "spline3d.h"
#include "splshape.h"
#include "sbmtlapi.h"

#define MAX_MATID	0xffff

#define EDITSPL_CHANNELS (PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|PART_DISPLAY|PART_TOPO)

// These are values for selLevel.
#define ES_OBJECT	0
#define ES_VERTEX	1
#define ES_SEGMENT	2
#define ES_SPLINE	3

// Named selection set levels:
#define ES_NS_VERTEX 0
#define ES_NS_SEGMENT 1
#define ES_NS_SPLINE 2
// Conversion from selLevel to named selection level:
static int namedSetLevel[] = { ES_NS_VERTEX, ES_NS_VERTEX, ES_NS_SEGMENT, ES_NS_SPLINE };

#define CID_OUTLINE		CID_USER + 201	// Spline only
#define CID_SEGBREAK	CID_USER + 202	// Segment only
#define CID_SEGREFINE	CID_USER + 203	// Spline/Vertex
#define CID_VERTCONNECT	CID_USER + 204	// Vertex only
#define CID_VERTINSERT	CID_USER + 205	// All levels
#define CID_BOOLEAN		CID_USER + 206	// Spline only
#define CID_CREATELINE	CID_USER + 207	// All levels
#define CID_CROSSINSERT	CID_USER + 208	// Spline only
#define CID_FILLET		CID_USER + 209
#define CID_CHAMFER		CID_USER + 210
#define CID_TRIM		CID_USER + 211
#define CID_EXTEND		CID_USER + 212

//watje
#define CID_SPLINEBIND	CID_USER + 213
#define CID_REFINECONNECT	CID_USER + 214

#define UNDEFINED	0xffffffff

class VertInsertRecord;
class PickSplineAttach;

class EditSplineMod : public Modifier, ISplineOps, ISplineSelect, ISubMtlAPI, AttachMatDlgUser {
	friend BOOL CALLBACK SplineSelectDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	friend BOOL CALLBACK SplineOpsDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	friend BOOL CALLBACK SplineSurfDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );

	friend class ESTempData;
	friend class EditSplineData;
	friend class XFormProc;
	friend class OutlineCMode;
	friend class FilletCMode;
	friend class ESChamferCMode;
	friend class SegBreakCMode;
	friend class SegRefineCMode;
	friend class CrossInsertCMode;
	friend class VertConnectCMode;
	friend class VertInsertCMode;
	friend class CreateLineCMode;
	friend class BooleanCMode;
	friend class TrimCMode;
	friend class ExtendCMode;
	friend class OutlineMouseProc;
	friend class FilletMouseProc;
	friend class ESChamferMouseProc;
	friend class SegBreakMouseProc;
	friend class SegRefineMouseProc;
	friend class CrossInsertMouseProc;
	friend class VertConnectMouseProc;
	friend class VertInsertMouseProc;
	friend class CreateLineMouseProc;
	friend class BooleanMouseProc;
	friend class TrimMouseProc;
	friend class ShapeRestore;
	friend class ESRightMenu;
	friend class ESMBackspaceUser;
	friend class ESIBackspaceUser;
	friend class PickSplineAttach;
	friend class AttachHitByName;
//watje
	friend class BindMouseProc;
	friend class BindCMode;
	friend class RefineConnectMouseProc;
	friend class RefineConnectCMode;


	public:
		static IObjParam *ip;		
		static HWND hSelectPanel, hOpsPanel, hSurfPanel;
		static BOOL rsSel, rsOps, rsSurf;	// rollup states (FALSE = rolled up)
		static MoveModBoxCMode *moveMode;
		static RotateModBoxCMode *rotMode;
		static UScaleModBoxCMode *uscaleMode;
		static NUScaleModBoxCMode *nuscaleMode;
		static SquashModBoxCMode *squashMode;
		static SelectModBoxCMode *selectMode;
		static OutlineCMode *outlineMode;
		static FilletCMode *filletMode;
		static ESChamferCMode *chamferMode;
		static SegBreakCMode *segBreakMode;
		static SegRefineCMode *segRefineMode;
		static CrossInsertCMode *crossInsertMode;
		static VertConnectCMode *vertConnectMode;
		static VertInsertCMode *vertInsertMode;
		static CreateLineCMode *createLineMode;
		static BooleanCMode *booleanMode;
		static TrimCMode *trimMode;
		static ExtendCMode *extendMode;
		static ISpinnerControl *outlineSpin;
		static ISpinnerControl *filletSpin;
		static ISpinnerControl *chamferSpin;
		static ISpinnerControl *weldSpin;
		static ISpinnerControl *crossSpin;
		static ISpinnerControl *divSpin;
		static ISpinnerControl *matSpin;

		//2-1-99 watje
		static ISpinnerControl *selectAreaSpin;

		static ICustButton *iUnion;
		static ICustButton *iSubtraction;
		static ICustButton *iIntersection;
		static ICustButton *iMirrorHorizontal;
		static ICustButton *iMirrorVertical;
		static ICustButton *iMirrorBoth;

		static BOOL inOutline;
		static BOOL inFillet;
		static BOOL inChamfer;
		static BOOL inSegBreak;
		static int boolType;
		static int mirrorType;
		static PickSplineAttach pickCB;
		static BOOL segUIValid;
		static int attachMat;
		static BOOL condenseMat;

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message ) { return REF_SUCCEED; }
		
		BOOL showVertNumbers;
		BOOL SVNSelectedOnly;

		int selLevel;

		// Vertex insertion information
		BezierShape *insertShape;
		Spline3D *insertSpline;
		int insertPoly;
		int insertVert;
		INode *insertNode;
		Matrix3 insertTM;	// Transform for the insert node
		EditSplineData *insertShapeData;

		// Create line data
		BezierShape *createShape;
		INode *createNode;
		Matrix3 createTM;	// Transform for the create node
		EditSplineData *createShapeData;

		// Boolean info
		BezierShape* boolShape;
		int boolPoly1;

		// Remembered info
		BezierShape *rememberedShape;	// NULL if using all selected verts
		int rememberedPoly;
		int rememberedIndex;
		int rememberedData;
	
		// Fillet and chamfer upper limit
		float FCLimit;

		// Named selections
		Tab<TSTR*> namedSel[3];
		int FindSet(TSTR &setName,int level);
		void AddSet(TSTR &setName,int level);
		void RemoveSet(TSTR &setName,int level);
		void RemoveAllSets();
		void ClearSetNames();

		EditSplineMod();
		~EditSplineMod();

		Interval LocalValidity(TimeValue t);
		ChannelMask ChannelsUsed()  { return EDITSPL_CHANNELS; }
		ChannelMask ChannelsChanged() { return EDITSPL_CHANNELS; }
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		void NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc);
		Class_ID InputType() { return Class_ID(SPLINESHAPE_CLASS_ID,0); }
		
		int CompMatrix(TimeValue t, ModContext& mc, Matrix3& tm, Interval& valid);
		
		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= TSTR(_T("EditSplineMod")); }
		Class_ID ClassID() { return Class_ID(EDITSPLINE_CLASS_ID,0);}
		void* GetInterface(ULONG id);

		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flagst, ModContext *mc);
		void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);

		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		int SubObjectIndex(HitRecord *hitRec);

 		BOOL DependOnTopology(ModContext &mc);

		// Generic xform procedure.
		void XFormVerts( XFormProc *xproc, TimeValue t, Matrix3& partm, Matrix3& tmAxis );

		// The following is called before the first Move(), Rotate() or Scale() call
		void TransformStart(TimeValue t);

		// The following is called after the user has completed the Move, Rotate or Scale operation and
		// the undo object has been accepted.
		void TransformFinish(TimeValue t);		

		// The following is called when the transform operation is cancelled by a right-click and the undo
		// has been cancelled.
		void TransformCancel(TimeValue t);		

		// Specialized xform for bezier handles
		void XFormHandles( XFormProc *xproc, TimeValue t, Matrix3& partm, Matrix3& tmAxis, int object );

		// Affine transform methods		
		void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
		void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE );
		void Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );

		// Named selection support
		BOOL SupportsNamedSubSels() {return TRUE;}
		void ActivateSubSelSet(TSTR &setName);
		void NewSetFromCurSel(TSTR &setName);
		void RemoveSubSelSet(TSTR &setName);
		void SetupNamedSelDropDown();
		int NumNamedSelSets();
		TSTR GetNamedSelSetName(int i);
		void SetNamedSelSetName(int i,TSTR &newName);
		void NewSetByOperator(TSTR &newName,Tab<int> &sets,int op);
		BOOL GetUniqueSetName(TSTR &name);
		int SelectNamedSet();
		void NSCopy();
		void NSPaste();

		void BeginOutlineMove(TimeValue t);
		void BeginFilletMove(TimeValue t);
		void BeginChamferMove(TimeValue t);
		void OutlineMove( TimeValue t, float amount );
		void FilletMove( TimeValue t, float amount );
		void ChamferMove( TimeValue t, float amount );
		void EndMoveModes(TimeValue t, BOOL accept=TRUE);	// End all Moves (below)
		void EndOutlineMove(TimeValue t,BOOL accept=TRUE);
		void EndFilletMove(TimeValue t,BOOL accept=TRUE);
		void EndChamferMove(TimeValue t,BOOL accept=TRUE);

		void StartOutlineMode();
		void StartFilletMode();
		void StartChamferMode();
		void DoOutline();
		void DoFillet();
		void DoChamfer();
		void StartSegBreakMode();
		void DoSegBreak(ViewExp *vpt, BezierShape *shape, int poly, int seg, IPoint2 p);
		void StartSegRefineMode();
		void DoSegRefine(ViewExp *vpt, BezierShape *shape, int poly, int seg, IPoint2 p);
		void StartCrossInsertMode();
		void DoCrossInsert(ViewExp *vpt, BezierShape *shape, int poly1, int seg1, int poly2, int seg2, IPoint2 p);
		void DoSegDivide(int divisions);
		void DoPolyReverse();
		void DoPolyExplode();
		void DoExplodeToObjects();
		void StartVertConnectMode();
		void DoVertConnect(ViewExp *vpt, BezierShape *shape, int poly1, int vert1, int poly2, int vert2);
		void StartVertInsertMode(int controlID);
		int StartVertInsert(ViewExp *vpt, BezierShape *shape, int poly, int seg, int vert, EditSplineMod **mod);
		void EndVertInsert();
		void StartCreateLineMode();
		BOOL StartCreateLine(BezierShape **shape);
		void EndCreateLine();
		BOOL BooleanStartUp();
		void StartBooleanMode();
		void DoBoolean(int poly2);
		void StartTrimMode();
		void StartExtendMode();
		void HandleTrimExtend(ViewExp *vpt, ShapeHitData *hit, IPoint2 &m, int operation);
		void MultiAttachObject(INodeTab &nodeTab);

		// from AttachMatDlgUser
		int GetAttachMat() { return attachMat; }
		void SetAttachMat(int value) { attachMat = value; }
		BOOL GetCondenseMat() { return condenseMat; }
		void SetCondenseMat(BOOL sw) { condenseMat = sw; }

		int DoAttach(INode *node, bool & canUndo);
		
		void DoVertBreak();
		void DoVertWeld();
		void DoMakeFirst();
		void DoVertDelete();
		void DoSegDelete();
		void DoSegDetach(int sameShape, int copy, int reorient);
		void DoPolyClose();
		void DoPolyDetach(int copy, int reorient);
		void DoPolyMirror(int type, int copy, BOOL aboutPivot);
		void DoPolyDelete();
		void SetBoolOperation(int type) { boolType = type; }
		void SetMirrorOperation(int type) { mirrorType = type; }
		int GetBoolOperation() { return boolType; }
		int GetMirrorOperation() { return mirrorType; }
		int GetBoolCursorID();
		int GetBoolMirrString(int type);
		void SetBooleanButton();
		void SetMirrorButton();
		void ChangeSelVerts(int type);
		void ChangeRememberedVert(int type);
		int RememberVertThere(HWND hWnd, IPoint2 m);
		void SetRememberedVertType(int type);
		void ChangeSelSegs(int type);
		void ChangeRememberedSeg(int type);
		int RememberSegThere(HWND hWnd, IPoint2 m);
		void SetRememberedSegType(int type);
		void ChangeSelPolys(int type);
		void ChangeRememberedPoly(int type);
		int RememberPolyThere(HWND hWnd, IPoint2 m);
		void SetRememberedPolyType(int type);
		
		void RefreshSelType();
		void UpdateSelectDisplay();
		void SetSelDlgEnables();
		void SetOpsDlgEnables();
		void SetSurfDlgEnables();
		void SelectionChanged();
		void InvalidateSurfaceUI();

		// Get the commonality of material index for the selection (-1 indicates no commonality)
		int GetSelMatIndex();
		void SetSelMatIndex(int index);
		void SelectByMat(int index,BOOL clear);

		BOOL SingleObjectMod();		// returns TRUE if just one input object
		BezierShape *SingleObjectShape(INode **node = NULL); // returns the shape for the one input object

		void ClearShapeDataFlag(ModContextList& mcList,DWORD f);
		void DeleteShapeDataTempData();		
		void CreateShapeDataTempData();

		int NumRefs() { return 0; }
		RefTargetHandle GetReference(int i) { return NULL; }
		void SetReference(int i, RefTargetHandle rtarg) {}

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		IOResult SaveLocalData(ISave *isave, LocalModData *ld);
		IOResult LoadLocalData(ILoad *iload, LocalModData **pld);
		IOResult LoadNamedSelChunk(ILoad *iload,int level);

		CreateMouseCallBack* GetCreateMouseCallBack() { return NULL; } 
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_TH_EDITSPLINE); }
		int GetSubobjectLevel();
		void SetSubobjectLevel(int level);
		void ActivateSubobjSel(int level, XFormModes& modes );
		int NeedUseSubselButton() { return 0; }
		void SelectSubComponent( HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert );
		void ClearSelection(int selLevel);		
		void SelectAll(int selLevel);
		void InvertSelection(int selLevel);
		void MaybeSelectSingleSpline(BOOL makeUndo = FALSE);
		BOOL AnyPolysSelected();
		void SetFCLimit();

		void RescaleWorldUnits(float f);

//watje
		
		BOOL showVerts;
		BOOL smoothRefineConnect;
		BOOL closedRefineConnect;
		BOOL bindFirst, bindLast;

//2-1-99 watje
		BOOL rConnect;
		BOOL useAreaSelect;
		float areaSelect;

		int startSegRC, startSegSplineRC;
		int startSplineRC;
		int endSegRC, endSegSplineRC;
		int endSplineRC;
		Tab<Point3> pointList;

//2-21-99 watje 
		SplineKnot knotPoint1, knotPoint2;

		static BindCMode *bindMode;
		static RefineConnectCMode *refineConnectMode;
		void StartBindMode();
		void DoBind(int poly1, int vert1, int poly2, int vert2);
		void DoUnBind();
		void DoHide();
		void DoUnhide();
		void DoCycleVerts();

		void StartRefineConnectMode();
		void EndRefineConnectMode();
		void DoRefineConnect(ViewExp *vpt, BezierShape *shape, int poly, int seg, IPoint2 p);

//2-1-99 watje
		void DoVertFuse();


		// spline select and operations interfaces, JBW 2/1/99
		void StartCommandMode(splineCommandMode mode);
		void ButtonOp(splineButtonOp opcode);

		DWORD GetSelLevel();
		void SetSelLevel(DWORD level);
		void LocalDataChanged();

		// ISubMtlAPI methods:
		MtlID	GetNextAvailMtlID(ModContext* mc);
		BOOL	HasFaceSelection(ModContext* mc);
		void	SetSelFaceMtlID(ModContext* mc, MtlID id, BOOL bResetUnsel = FALSE);
		int		GetSelFaceUniqueMtlID(ModContext* mc);
		int		GetSelFaceAnyMtlID(ModContext* mc);
		int		GetMaxMtlID(ModContext* mc);
	};

class PickSplineAttach : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		EditSplineMod *es;
		
		PickSplineAttach() {es=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		HCURSOR GetHitCursor(IObjParam *ip);

		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}

		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{return TRUE;}
	};

// Table to convert selLevel values to shape selLevel flags.
const int shapeLevel[] = {SHAPE_OBJECT,SHAPE_VERTEX,SHAPE_SEGMENT,SHAPE_SPLINE};

// Get display flags based on selLevel.
const DWORD shapeLevelDispFlags[] = {0,DISP_VERTTICKS|DISP_SELVERTS,DISP_VERTTICKS|DISP_SELSEGMENTS,DISP_VERTTICKS|DISP_SELPOLYS};

// For hit testing...
const int shapeHitLevel[] = {0,SUBHIT_SHAPE_VERTS,SUBHIT_SHAPE_SEGMENTS,SUBHIT_SHAPE_POLYS};

class EditSplineClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE ) { return new EditSplineMod; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_EDITSPLINE_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(EDITSPLINE_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFEDIT);}
	void			ResetClassParams(BOOL fileReset);
	};

typedef Tab<Point3> Point3Tab;
typedef Tab<int> SegTab;

class XFormProc {
	public:
		virtual Point3 proc(Point3& p, Matrix3 &mat, Matrix3 &imat)=0;
		virtual void SetMat( Matrix3& mat ) {}
	};

class MoveXForm : public XFormProc {
	private:
		Point3 delta, tdelta;		
	public:
		Point3 proc(Point3& p, Matrix3 &mat, Matrix3 &imat) 
			{ return p + tdelta; }
		void SetMat( Matrix3& mat ) 
			{ tdelta = VectorTransform(Inverse(mat),delta); }
		MoveXForm(Point3 d) { delta = d; }
	};

class RotateXForm : public XFormProc {
	private:
		Matrix3 rot, trot;
	public:
		Point3 proc(Point3& p, Matrix3 &mat, Matrix3 &imat) 
			{ return (trot*p)*imat; }
		void SetMat( Matrix3& mat ) 
			{ trot = mat * rot; }
		RotateXForm(Quat q) { q.MakeMatrix(rot); }
	};

class ScaleXForm : public XFormProc {
	private:
		Matrix3 scale, tscale;
	public:
		Point3 proc(Point3& p, Matrix3 &mat, Matrix3 &imat) 
			{ return (p*tscale)*imat; }
		void SetMat( Matrix3& mat ) 
			{ tscale = mat*scale; }
		ScaleXForm(Point3 s) { scale = ScaleMatrix(s); }
	};

typedef Tab<int> IntTab;

// General-purpose shape point table -- Maintains point table for each of n polygons
class ShapePointTab {
	public:
		int polys;
		int *pUsed;	// Tells whether polygon is affected
		Point3Tab *ptab;
		IntTab *ktab;
		IntTab *ltab;
		ShapePointTab();
		~ShapePointTab();
		void Empty();
		void Zero();
		void MakeCompatible(BezierShape& shape, BOOL clear=TRUE);
		ShapePointTab& operator=(ShapePointTab& from);
		BOOL IsCompatible(BezierShape &shape);
		void RescaleWorldUnits(float f);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};

class ShapeVertexDelta {
	public:
		ShapePointTab dtab;

		void SetSize(BezierShape& shape, BOOL load=TRUE);
		void Empty() { dtab.Empty(); }
		void Zero() { dtab.Zero(); }
		void SetPoint(int poly, int i, const Point3& p) { dtab.pUsed[poly] = 1; dtab.ptab[poly][i] = p; }
		void SetKType(int poly, int i, int k) { dtab.pUsed[poly] = 1; dtab.ktab[poly][i] = k; }
		void SetLType(int poly, int i, int l) { dtab.pUsed[poly] = 1; dtab.ltab[poly][i] = l; }
		void Move(int poly, int i, const Point3& p) { dtab.pUsed[poly] = 1; dtab.ptab[poly][i] += p; }
		void Apply(BezierShape& shape);
		void UnApply(BezierShape& shape);
		void ClearUsed(int poly) { dtab.pUsed[poly] = 0; }
		void SetUsed(int poly) { dtab.pUsed[poly] = 1; }
		int IsUsed(int poly) { return dtab.pUsed[poly] ? 1 : 0; }
		ShapeVertexDelta& operator=(ShapeVertexDelta& from) { dtab = from.dtab; return *this; }
		void ApplyHandlesAndZero(BezierShape &shape, int handlePoly, int handleVert);
		BOOL IsCompatible(BezierShape &shape) { return dtab.IsCompatible(shape); }
		void RescaleWorldUnits(float f) { dtab.RescaleWorldUnits(f); }
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};

// Vertex Mapping class -- Gives mapping from poly/vert in original shape to
// poly/vert in modified shape

class ESPolyVert {
	public:
		BOOL originalStored;
		int poly;
		int vert;
		Point3 original;	// Original point location
		Point3 delta;		// The delta we've applied
		ESPolyVert() { originalStored = FALSE; poly = vert = 0; original = Point3(0,0,0); delta = Point3(0,0,0); }
		ESPolyVert(int p, int v, Point3 &o, Point3 &d) { poly = p; vert = v; original = o; delta = d; originalStored = TRUE; }
	};

class ESPolysPV {
	public:
		int count;
		ESPolyVert *map;
		ESPolysPV() { map = NULL; }
		ESPolysPV(ESPolysPV &from) { map = NULL; *this=from; }
		~ESPolysPV();
		void Build(Spline3D &spline, int poly);
		void Reset();	// Empty all mappings
		void UpdateDeltas(Spline3D &spline, int poly);
		void RecordTopologyTags(BezierShape &shape, int poly);
		ESPolysPV& operator=(ESPolysPV &from);
		void RescaleWorldUnits(float f);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};

class ESVertMapper {
	public:
		int polys;
		ESPolysPV *polyMap;
		ESVertMapper() { polys = 0; polyMap = NULL; }
		~ESVertMapper();
		// Set up remap data structures.
		void Build(BezierShape &shape);
		// Update the deltas we have stored, if necessary, and also apply to output shape.
		// This is in response to the original shape changing
		void UpdateAndApplyDeltas(BezierShape &inShape, BezierShape &outShape);
		// Recompute the deltas we have stored
		// This is done after the modifier's user interaction changes the shape
		void RecomputeDeltas(BezierShape &shape);
		// Record the topology tags in the specified shape
		void RecordTopologyTags(BezierShape &shape);
		// Update the topology tag mapping
		void UpdateMapping(BezierShape &shape);
		ESVertMapper& operator=(ESVertMapper &from);
		void RescaleWorldUnits(float f);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};

class AdjEdgeList;
class ESTempData;

/*-------------------------------------------------------------------*/

// Class for recording shape changes -- This is used to reconstruct an object from the original whenever
// the modifier is re-entered or whenever the system needs to reconstruct an object's cache.  This may be
// slow if a lot of changes have been recorded, but it's about the only way to properly reconstruct an object
// because the output of one operation becomes the input of the next.

// These are used as follows:
// When a user makes a modification to an object, a StartChangeGroup call needs to be made to the EditSplineData
// object.  Then a change record needs to be added for each sub-operation that makes up the modification.  These
// records are owned by the EditSplineData object, but they should also be referenced by the undo object for that
// operation.  If an undo is done, ownership of the modification record transfers to the undo/redo object and the
// record is REMOVED (NOT DELETED) from the EditSplineData object.  This keeps the record around for a redo operation
// but removes it from the list of records for the modifier.  If the undo is redone, ownership transfers back to
// the modifier, when it is re-added to the modification record list.

// Note that this class contains load and save methods, necessary because the modifier needs to be able to save
// and load them.  When you subclass off of this, be sure your load and save methods call the base class's first!

class ShapeRestore;

class ModRecord {
	public:
		virtual ~ModRecord();
		virtual BOOL Redo(BezierShape *shape,int reRecord)=0;
		virtual IOResult Load(ILoad *iload)=0;
	};

typedef ModRecord* PModRecord;
typedef Tab<PModRecord> ModRecordTab;

/*-------------------------------------------------------------------*/

// Here are the types of modification records we use!

#define CLEARVERTSELRECORD_CHUNK	0x2000
#define SETVERTSELRECORD_CHUNK		0x2001
#define INVERTVERTSELRECORD_CHUNK	0x2002
#define CLEARSEGSELRECORD_CHUNK		0x2010
#define SETSEGSELRECORD_CHUNK		0x2011
#define INVERTSEGSELRECORD_CHUNK	0x2012
#define CLEARPOLYSELRECORD_CHUNK	0x2020
#define SETPOLYSELRECORD_CHUNK		0x2021
#define INVERTPOLYSELRECORD_CHUNK	0x2022
#define VERTSELRECORD_CHUNK			0x2030
#define SEGSELRECORD_CHUNK			0x2040
#define POLYSELRECORD_CHUNK			0x2050
#define POLYCLOSERECORD_CHUNK		0x2060
#define POLYREVERSERECORD_CHUNK		0x2068
#define OUTLINERECORD_CHUNK			0x2070
#define POLYDETACHRECORD_CHUNK		0x2080
#define POLYDELETERECORD_CHUNK		0x2090
#define VERTMOVERECORD_CHUNK		0x20A0
#define SEGDELETERECORD_CHUNK		0x20B0
#define SEGDETACHRECORD_CHUNK		0x20C0
#define POLYFIRSTRECORD_CHUNK		0x20C8
#define SEGBREAKRECORD_CHUNK		0x20D0
#define SEGREFINERECORD_CHUNK		0x20E0
#define VERTBREAKRECORD_CHUNK		0x20F0
#define VERTCONNECTRECORD_CHUNK		0x2100
#define VERTINSERTRECORD_CHUNK		0x2110
#define VERTWELDRECORD_CHUNK		0x2120
#define BOOLEANRECORD_CHUNK			0x2130
#define ATTACHRECORD_CHUNK			0x2140
#define VERTCHANGERECORD_CHUNK		0x2150
#define SEGCHANGERECORD_CHUNK		0x2160
#define POLYCHANGERECORD_CHUNK		0x2165
#define VERTDELETERECORD_CHUNK		0x2170
#define CREATELINERECORD_CHUNK		0x2180
#define POLYMIRRORRECORD_CHUNK		0x2190
#define POLYENDATTACHRECORD_CHUNK	0x21A0
#define POLYCOPYRECORD_CHUNK		0x21B0
#define SEGCOPYRECORD_CHUNK			0x21C0
										 
class ClearVertSelRecord : public ModRecord {
	public:
		ShapeVSel sel;	// Old state
		ClearVertSelRecord() : ModRecord() { }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class SetVertSelRecord : public ModRecord {
	public:
		ShapeVSel sel;	// Old state
		SetVertSelRecord() : ModRecord() { }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class InvertVertSelRecord : public ModRecord {
	public:
		InvertVertSelRecord() : ModRecord() { }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class ClearSegSelRecord : public ModRecord {
	public:
		ShapeSSel sel;	// Old state
		ClearSegSelRecord() : ModRecord() { }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class SetSegSelRecord : public ModRecord {
	public:
		ShapeSSel sel;	// Old state
		SetSegSelRecord() : ModRecord() { }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class InvertSegSelRecord : public ModRecord {
	public:
		InvertSegSelRecord() : ModRecord() { }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class ClearPolySelRecord : public ModRecord {
	public:
		ShapePSel sel;	// Old state
		ClearPolySelRecord() : ModRecord() { }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class SetPolySelRecord : public ModRecord {
	public:
		ShapePSel sel;	// Old state
		SetPolySelRecord() : ModRecord() { }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class InvertPolySelRecord : public ModRecord {
	public:
		InvertPolySelRecord() : ModRecord() { }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class VertSelRecord : public ModRecord {
	public:
		ShapeVSel oldSel;	// Old state
		ShapeVSel newSel;	// New state
		VertSelRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class SegSelRecord : public ModRecord {
	public:
		ShapeSSel oldSel;	// Old state
		ShapeSSel newSel;	// New state
		SegSelRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PolySelRecord : public ModRecord {
	public:
		ShapePSel oldSel;	// Old state
		ShapePSel newSel;	// New state
		PolySelRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PolyCloseRecord : public ModRecord {
	public:
		int poly;
		PolyCloseRecord() : ModRecord() { }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PolyReverseRecord : public ModRecord {
	public:
		int poly;
		PolyReverseRecord() : ModRecord() { }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PolyMirrorRecord : public ModRecord {
	public:
		int poly;
		int type;
		BOOL copy;
		PolyMirrorRecord() : ModRecord() { }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class PolyEndAttachRecord : public ModRecord {
	public:
		int poly1;				// First poly
		int vert1;				// Vertex on first poly
		int poly2;				// Second poly (may be same as first)
		int vert2;				// Vertex on second poly
		Spline3D oldSpline1;	// How the first spline looked before connect
		Spline3D oldSpline2;	// How the first spline looked before connect
		BitArray oldVSel1;		// Vertex selections before op
		BitArray oldVSel2;		// Vertex selections before op
		BitArray oldSSel1;		// Segment selections before op
		BitArray oldSSel2;		// Segment selections before op
		int selected2;			// TRUE if spline #2 was selected before op
		PolyEndAttachRecord() : ModRecord() { }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline1.Transform(&stm);
			oldSpline2.Transform(&stm);
			}
	};

class OutlineRecord : public ModRecord {
	public:
		BOOL newType;			// Present in MAX 2.0 and up
		int poly;
		int centered;
		float size;
		int oldSplineCount;		// The number of splines present before it was outlined
		BitArray oldVSel;		// Vertex selections before op
		BitArray oldSSel;		// Segment selections before op
		Spline3D oldSpline;		// The original spline
		OutlineRecord() : ModRecord() { newType = TRUE; }
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline.Transform(&stm);
			}
	};

class PolyDetachRecord : public ModRecord {
	public:
		int poly;
		int copy;
		BitArray oldVSel;		// Vertex selections before op
		BitArray oldSSel;		// Segment selections before op
		Spline3D spline;
		PolyDetachRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			spline.Transform(&stm);
			}
	};

class PolyDeleteRecord : public ModRecord {
	public:
		int poly;
		BitArray oldVSel;		// Vertex selections before op
		BitArray oldSSel;		// Segment selections before op
		Spline3D spline;
		PolyDeleteRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			spline.Transform(&stm);
			}
	};

class VertMoveRecord : public ModRecord {
	public:
		ShapeVertexDelta delta;	// Position changes for each vertex (Wasteful!  Change later?)
		VertMoveRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { delta.RescaleWorldUnits(f); }
	};

class SegDeleteRecord : public ModRecord {
	public:
		int poly;
		Spline3D oldSpline;		// How the spline looked before the delete
		BitArray oldVSel;		// Vertex selections before op
		BitArray oldSSel;		// Segment selections before op
		int selected;			// TRUE if spline was selected before op
		int deleted;			// TRUE if segment delete results in this polygon being deleted
		int oldSplineCount;		// The number of splines present before it was broken up
		SegDeleteRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline.Transform(&stm);
			}
	};

class SegDetachRecord : public ModRecord {
	public:
		int poly;
		int copy;				// TRUE if copying segments
		Spline3D oldSpline;		// How the spline looked before the delete
		BitArray oldVSel;		// Vertex selections before op
		BitArray oldSSel;		// Segment selections before op
		int selected;			// TRUE if spline was selected before op
		int deleted;			// TRUE if segment delete results in this polygon being deleted
		int oldSplineCount;		// The number of splines present before it was broken up
		SegDetachRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline.Transform(&stm);
			}
	};

class PolyFirstRecord : public ModRecord {
	public:
		int poly;
		int vertex;				// The new first vertex
		Spline3D oldSpline;		// How the spline looked before the new first vertex
		BitArray oldVSel;		// Vertex selections before op
		BitArray oldSSel;		// Segment selections before op
		PolyFirstRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline.Transform(&stm);
			}
	};

class SegBreakRecord : public ModRecord {
	public:
		int poly;				// The polygon being refined
		int segment;			// The segment being refined
		float param;			// The point on the segment (0-1) where the new point is inserted
		Spline3D oldSpline;		// The spline before we refined it
		BitArray oldVSel;		// Vertex selections before op
		BitArray oldSSel;		// Segment selections before op
		int selected;			// TRUE if spline was selected before op
		int oldSplineCount;		// The number of splines present before it was broken up
		SegBreakRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline.Transform(&stm);
			}
	};

class SegRefineRecord : public ModRecord {
	public:
		int poly;				// The polygon being refined
		int segment;			// The segment being refined
		float param;			// The point on the segment (0-1) where the new point is inserted
		Spline3D oldSpline;		// The spline before we refined it
		BitArray oldVSel;		// Vertex selections before op
		BitArray oldSSel;		// Segment selections before op
		SegRefineRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline.Transform(&stm);
			}
	};

class VertBreakRecord : public ModRecord {
	public:
		int poly;
		Spline3D oldSpline;		// How the spline looked before the break
		BitArray oldVSel;		// Vertex selections before op
		BitArray oldSSel;		// Segment selections before op
		int selected;			// TRUE if spline was selected before op
		int oldSplineCount;		// The number of splines present before it was broken up
		VertBreakRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline.Transform(&stm);
			}
	};

class VertConnectRecord : public ModRecord {
	public:
		int poly1;				// First poly
		int vert1;				// Vertex on first poly
		int poly2;				// Second poly (may be same as first)
		int vert2;				// Vertex on second poly
		Spline3D oldSpline1;	// How the first spline looked before connect
		Spline3D oldSpline2;	// How the first spline looked before connect
		BitArray oldVSel1;		// Vertex selections before op
		BitArray oldVSel2;		// Vertex selections before op
		BitArray oldSSel1;		// Segment selections before op
		BitArray oldSSel2;		// Segment selections before op
		int selected2;			// TRUE if spline #2 was selected before op
		VertConnectRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline1.Transform(&stm);
			oldSpline2.Transform(&stm);
			}
	};

class VertInsertRecord : public ModRecord {
	public:
		int poly;				// Poly	being inserted
		Spline3D oldSpline;		// How the spline looked before insert
		Spline3D newSpline;		// How the spline looked after insert
		BitArray oldVSel;		// Vertex selections before op
		BitArray oldSSel;		// Segment selections before op
		BitArray newVSel;		// Vertex selections after op
		BitArray newSSel;		// Segment selections after op
		VertInsertRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline.Transform(&stm);
			newSpline.Transform(&stm);
			}
	};

class VertWeldRecord : public ModRecord {
	public:
		int poly;
		float thresh;			// Weld threshold
		Spline3D oldSpline;		// How the spline looked before the break
		BitArray oldVSel;		// Vertex selections before op
		BitArray oldSSel;		// Segment selections before op
		int selected;			// TRUE if spline was selected before op
		BOOL deleted;			// TRUE if spline was deleted as a result of the weld
		VertWeldRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline.Transform(&stm);
			}
	};

// The boolean operations
#define BOOL_UNION 0
#define BOOL_SUBTRACTION 1
#define BOOL_INTERSECTION 2

// The mirror operations
#define MIRROR_HORIZONTAL 3
#define MIRROR_VERTICAL 4
#define MIRROR_BOTH 5

// Flags used for boolean polygons
#define POLYBOOL (1 << 0)
#define POLYOUTSIDE (1 << 1)
#define POLYINSIDE (1 << 2)

class BooleanRecord : public ModRecord {
	public:
		int poly1;				// Poly 1 of boolean pair
		int poly2;				// Poly 2 of boolean pair
		int operation;			// Boolean operation (see above)
		int oldSplineCount;		// The number of splines present before it was broken up
		Spline3D oldSpline1;	// How spline 1 looked before boolean
		BitArray oldVSel1;		// Vertex selections before op
		BitArray oldSSel1;		// Segment selections before op
		Spline3D oldSpline2;	// How spline 2 looked before boolean
		BitArray oldVSel2;		// Vertex selections before op
		BitArray oldSSel2;		// Segment selections before op
		BooleanRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline1.Transform(&stm);
			oldSpline2.Transform(&stm);
			}
	};
 
class AttachRecord : public ModRecord {
	public:
		BezierShape attShape;			// The shape we're attaching
		int oldSplineCount;		// The number of splines present before attaching
		AttachRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			attShape.Transform(stm);
			}
	};

class VertChangeRecord : public ModRecord {
	public:
		Spline3D oldSpline;		// How the spline looked before the change
		int poly;
		int vertex;
		int type;
		VertChangeRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline.Transform(&stm);
			}
	};

class SegChangeRecord : public ModRecord {
	public:
		Spline3D oldSpline;		// How the spline looked before the change
		int poly;
		int segment;
		int type;
		SegChangeRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline.Transform(&stm);
			}
	};

class PolyChangeRecord : public ModRecord {
	public:
		Spline3D oldSpline;		// How the spline looked before the change
		int poly;
		int type;
		PolyChangeRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline.Transform(&stm);
			}
	};

class VertDeleteRecord : public ModRecord {
	public:
		int poly;
		Spline3D oldSpline;		// How the spline looked before the delete
		BitArray oldVSel;		// Vertex selections before op
		BitArray oldSSel;		// Segment selections before op
		int selected;			// TRUE if spline was selected before op
		int deleted;			// TRUE if segment delete results in this polygon being deleted
		int oldSplineCount;		// The number of splines present before it was broken up
		VertDeleteRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			oldSpline.Transform(&stm);
			}
	};

class CreateLineRecord : public ModRecord {
	public:
		Spline3D spline;		// The spline we created that will be added
		CreateLineRecord() : ModRecord() {}
		CreateLineRecord(Spline3D *s);
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
		void RescaleWorldUnits(float f) { 
			Matrix3 stm = ScaleMatrix(Point3(f, f, f));
			spline.Transform(&stm);
			}
	};

class PolyCopyRecord : public ModRecord {
	public:
		int poly;
		BOOL selOrig;
		BOOL selCopy;
		PolyCopyRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

class SegCopyRecord : public ModRecord {
	public:
		int oldSplineCount;
		ShapeSSel oldSSel;	// Old segment selection sets
		BOOL selCopy;
		SegCopyRecord() : ModRecord() {}
		BOOL Redo(BezierShape *shape,int reRecord);
		IOResult Load(ILoad *iload);
	};

/*-------------------------------------------------------------------*/

// EditSplineData flags
#define ESD_BEENDONE			(1<<0)
#define ESD_UPDATING_CACHE		(1<<1)
#define ESD_HASDATA				(1<<2)

// This is the data that each mod app will have.
class EditSplineData : public LocalModData {
	public:
		BOOL handleFlag;
		int handlePoly, handleVert;

		DWORD flags;

		// This records the changes to the incoming object.
		// (OLD SYSTEM, used only when loading old files)
		ModRecordTab changes;

		// Vertex delta object
		ShapeVertexDelta vdelta;

		// RB: Named selection set lists
		NamedVertSelSetList vselSet;
		NamedSegSelSetList sselSet;
		NamedPolySelSetList pselSet;		

		// While an object is being edited, this exists.
		ESTempData *tempData;

		// The knot mapping for the edited shape
		ESVertMapper vertMap; 

		// The final edited shape
		BezierShape finalShape;
		
		EditSplineData();
		EditSplineData(EditSplineData& esc);
		
		// Applies modifications to a triOb
		void Apply(TimeValue t,SplineShape *splShape,int selLevel,BOOL showVertNumbers,BOOL SVNSelectedOnly);

		// Invalidates any caches affected by the change.
		void Invalidate(PartID part,BOOL meshValid=TRUE);
		
		// If this is the first edit, then the delta arrays will be allocated
		void BeginEdit(TimeValue t);

		LocalModData *Clone() { return new EditSplineData(*this); }
		
		void SetFlag(DWORD f,BOOL on) 
			{ 
			if ( on ) {
				flags|=f;
			} else {
				flags&=~f; 
				}
			}
		DWORD GetFlag(DWORD f) { return flags&f; }

		ESTempData *TempData(EditSplineMod *mod);

		// Change recording functions:
		void ClearHandleFlag() { handleFlag = FALSE; }
		void SetHandleFlag(int poly, int vert) { handlePoly = poly; handleVert = vert; handleFlag = TRUE; }
		BOOL DoingHandles() { return handleFlag; }
		void ApplyHandlesAndZero(BezierShape &shape) { vdelta.ApplyHandlesAndZero(shape, handlePoly, handleVert); }
		void RescaleWorldUnits(float f);
		
		// MAXr3: New recording system
		void RecordTopologyTags(BezierShape *shape);
		void UpdateChanges(BezierShape *shape, BOOL checkTopology=TRUE);	// Also updates named selection sets

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};

// My generic restore class

class ShapeRestore : public RestoreObj {
	public:
		BezierShape oldShape, newShape;
		BOOL gotRedo;
		TimeValue t;
		EditSplineData *esd;
		EditSplineMod *mod;
//2-22-99 watje need to add points for refine connect
		Tab<Point3> undoPointList;
		Tab<Point3> redoPointList;

		ShapeRestore(EditSplineData* md, EditSplineMod* mod, BezierShape *shape);

		void Restore(int isUndo);
		void Redo();
		int Size() { return 1; }
		void EndHold() {mod->ClearAFlag(A_HELD);}
		TSTR Description() { return TSTR(_T("Generic shape restore")); }
	};

class MEdge {
	public:
		DWORD f[2];
		DWORD v[2];
	};

class AdjEdgeList {
	public:
		DWORDTab *list;
		Tab<MEdge> edges;
		int nverts;

		AdjEdgeList( BezierShape& ashape );
		~AdjEdgeList() { if (list) delete [] list; }
		AdjEdgeList& operator=(AdjEdgeList& a) {assert(0);return *this;}
		void AddEdge( DWORD fi, DWORD v1, DWORD v2 );
		DWORDTab& operator[](int i) { return list[i]; }
	};

class OutlineTransformer : public Transformer {
 	public:
 		CoreExport Point3 Eval(ViewExp *vpt);
		OutlineTransformer(IObjParam *i) : Transformer(i) {}
 		};	

class OutlineMouseProc : public MouseCallBack {
	private:
		OutlineTransformer outlineTrans;
		EditSplineMod *es;
		IObjParam *ip;
		Point3 p0, p1;
		IPoint2 sp0;
	public:
		OutlineMouseProc(EditSplineMod* mod, IObjParam *i)
			: outlineTrans(i) {es=mod;ip=i;}
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

class OutlineSelectionProcessor : public GenModSelectionProcessor {
	protected:
		HCURSOR GetTransformCursor();
		
	public:
		OutlineSelectionProcessor(OutlineMouseProc *mc, Modifier *m, IObjParam *i) 
			: GenModSelectionProcessor(mc,m,i) {}
	};


class OutlineCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		OutlineSelectionProcessor mouseProc;
		OutlineMouseProc eproc;
		EditSplineMod* es;

	public:
		OutlineCMode(EditSplineMod* mod, IObjParam *i) :
			fgProc(mod), mouseProc(&eproc,mod,i), eproc(mod,i) {es=mod;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_OUTLINE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class FilletTransformer : public Transformer {
 	public:
 		CoreExport Point3 Eval(ViewExp *vpt);
		FilletTransformer(IObjParam *i) : Transformer(i) {}
 		};	

class FilletMouseProc : public MouseCallBack {
	private:
		FilletTransformer filletTrans;
		EditSplineMod *es;
		IObjParam *ip;
		Point3 p0, p1;
		IPoint2 sp0;

	public:
		FilletMouseProc(EditSplineMod* mod, IObjParam *i)
			: filletTrans(i) {es=mod;ip=i;}
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

class FilletSelectionProcessor : public GenModSelectionProcessor {
	protected:
		HCURSOR GetTransformCursor();
		
	public:
		FilletSelectionProcessor(FilletMouseProc *mc, Modifier *m, IObjParam *i) 
			: GenModSelectionProcessor(mc,m,i) {}
	};


class FilletCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		FilletSelectionProcessor mouseProc;
		FilletMouseProc eproc;
		EditSplineMod* es;

	public:
		FilletCMode(EditSplineMod* mod, IObjParam *i) :
			fgProc(mod), mouseProc(&eproc,mod,i), eproc(mod,i) {es=mod;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_OUTLINE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class ESChamferTransformer : public Transformer {
 	public:
 		CoreExport Point3 Eval(ViewExp *vpt);
		ESChamferTransformer(IObjParam *i) : Transformer(i) {}
 		};	

class ESChamferMouseProc : public MouseCallBack {
	private:
		ESChamferTransformer chamferTrans;
		EditSplineMod *es;
		IObjParam *ip;
		Point3 p0, p1;
		IPoint2 sp0;

	public:
		ESChamferMouseProc(EditSplineMod* mod, IObjParam *i)
			: chamferTrans(i) {es=mod;ip=i;}
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

class ESChamferSelectionProcessor : public GenModSelectionProcessor {
	protected:
		HCURSOR GetTransformCursor();
		
	public:
		ESChamferSelectionProcessor(ESChamferMouseProc *mc, Modifier *m, IObjParam *i) 
			: GenModSelectionProcessor(mc,m,i) {}
	};


class ESChamferCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		ESChamferSelectionProcessor mouseProc;
		ESChamferMouseProc eproc;
		EditSplineMod* es;

	public:
		ESChamferCMode(EditSplineMod* mod, IObjParam *i) :
			fgProc(mod), mouseProc(&eproc,mod,i), eproc(mod,i) {es=mod;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_OUTLINE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class SegBreakTransformer : public Transformer {
 	public:
 		CoreExport Point3 Eval(ViewExp *vpt);
		SegBreakTransformer(IObjParam *i) : Transformer(i) {}
 		};	

class SegBreakMouseProc : public MouseCallBack {
	private:
		EditSplineMod *es;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		

	public:
		SegBreakMouseProc(EditSplineMod* mod, IObjParam *i) { es=mod; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
//		int override(int mode) { return CLICK_DOWN_POINT; }
	};

class SegBreakCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SegBreakMouseProc eproc;
		EditSplineMod* es;

	public:
		SegBreakCMode(EditSplineMod* mod, IObjParam *i) :
			fgProc(mod), eproc(mod,i) {es=mod;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_SEGBREAK; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=1; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

#define REFINE_VERT 0
#define REFINE_SEG 1

class SegRefineMouseProc : public MouseCallBack {
	private:
		EditSplineMod *es;
		IObjParam *ip;
		IPoint2 om;
		int type; // See above
	
	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		

	public:
		SegRefineMouseProc(EditSplineMod* mod, IObjParam *i) { es=mod; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		void SetType(int type) { this->type = type; }
	};

class SegRefineCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SegRefineMouseProc eproc;
		EditSplineMod* es;
		int type; // See above

	public:
		SegRefineCMode(EditSplineMod* mod, IObjParam *i) :
			fgProc(mod), eproc(mod,i) {es=mod;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_SEGREFINE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=1; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
		void SetType(int type) { this->type = type; eproc.SetType(type); }
	};

/*-------------------------------------------------------------------*/

class CrossInsertMouseProc : public MouseCallBack {
	private:
		EditSplineMod* es;
		IObjParam *ip;
		IPoint2 om;
	
	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		

	public:
		CrossInsertMouseProc(EditSplineMod* mod, IObjParam *i) { es=mod; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

class CrossInsertCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		CrossInsertMouseProc eproc;
		EditSplineMod* es;

	public:
		CrossInsertCMode(EditSplineMod* mod, IObjParam *i) :
			fgProc(mod), eproc(mod,i) {es = mod;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_CROSSINSERT; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=1; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class VertConnectMouseProc : public MouseCallBack {
	private:
		EditSplineMod *es;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
		BOOL HitAnEndpoint(ViewExp *vpt, IPoint2 *p, BezierShape *shape, int poly, int vert,
			BezierShape **shapeOut, int *polyOut, int *vertOut);
	public:
		VertConnectMouseProc(EditSplineMod* mod, IObjParam *i) { es=mod; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
//		int override(int mode) { return CLICK_DOWN_POINT; }
	};

class VertConnectCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		VertConnectMouseProc eproc;
		EditSplineMod* es;

	public:
		VertConnectCMode(EditSplineMod* mod, IObjParam *i) :
			fgProc(mod), eproc(mod,i) {es=mod;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_VERTCONNECT; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class VertInsertMouseProc : public MouseCallBack {
	private:
		EditSplineMod *es;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags, int hitType );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
		BOOL InsertWhere(ViewExp *vpt, IPoint2 *p, BezierShape **shapeOut, int *polyOut,int *segOut, int *vertOut);
	public:
		VertInsertMouseProc(EditSplineMod* mod, IObjParam *i) { es=mod; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		int override(int mode) { return CLICK_DOWN_POINT; }
	};

class VertInsertCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		VertInsertMouseProc eproc;
		EditSplineMod* es;
		int control;	// ID of the resource button
	public:
		VertInsertCMode(EditSplineMod* mod, IObjParam *i) :
			fgProc(mod), eproc(mod,i) {es=mod; control= -1;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_VERTINSERT; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=999999; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
		void SetControl(int id) { control = id; }
	};

/*-------------------------------------------------------------------*/

class CreateLineMouseProc : public MouseCallBack {
	private:
		EditSplineMod *es;
		IObjParam *ip;
		IPoint2 om;

	protected:
	public:
		CreateLineMouseProc(EditSplineMod* mod, IObjParam *i) { es=mod; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		int override(int mode) { return CLICK_DOWN_POINT; }
	};

class CreateLineCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		CreateLineMouseProc eproc;
		EditSplineMod* es;

	public:
		CreateLineCMode(EditSplineMod* mod, IObjParam *i) :
			fgProc(mod), eproc(mod,i) {es=mod;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_CREATELINE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=999999; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class BooleanMouseProc : public MouseCallBack {
	private:
		EditSplineMod *es;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
	public:
		BooleanMouseProc(EditSplineMod* mod, IObjParam *i) { es=mod; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		int override(int mode) { return CLICK_DOWN_POINT; }
	};

class BooleanCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		BooleanMouseProc eproc;
		EditSplineMod* es;

	public:
		BooleanCMode(EditSplineMod* mod, IObjParam *i) :
			fgProc(mod), eproc(mod,i) {es=mod;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_BOOLEAN; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=9999; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class TrimMouseProc : public MouseCallBack {
	private:
		EditSplineMod* es;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
	public:
		TrimMouseProc(EditSplineMod* mod, IObjParam *i) { es=mod; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		int override(int mode) { return CLICK_DOWN_POINT; }
	};

class TrimCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		TrimMouseProc eproc;
		EditSplineMod* es;

	public:
		TrimCMode(EditSplineMod* mod, IObjParam *i) :
			fgProc(mod), eproc(mod,i) {es=mod;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_TRIM; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=9999; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class ExtendMouseProc : public MouseCallBack {
	private:
		EditSplineMod* es;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
	public:
		ExtendMouseProc(EditSplineMod* mod, IObjParam *i) { es=mod; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		int override(int mode) { return CLICK_DOWN_POINT; }
	};

class ExtendCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		ExtendMouseProc eproc;
		EditSplineMod* es;

	public:
		ExtendCMode(EditSplineMod* mod, IObjParam *i) :
			fgProc(mod), eproc(mod,i) {es=mod;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_EXTEND; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=9999; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

//watje
/*-------------------------------------------------------------------*/

class BindMouseProc : public MouseCallBack {
	private:
		EditSplineMod *ss;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL HitTestSeg( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
		BOOL HitAnEndpoint(ViewExp *vpt, IPoint2 *p, BezierShape *shape, int poly, int vert,
			BezierShape **shapeOut, int *polyOut, int *vertOut);
		BOOL HitASegment(ViewExp *vpt, IPoint2 *p, BezierShape *shape, int poly, int vert,
			BezierShape **shapeOut, int *polyOut, int *vertOut);

	public:
		BindMouseProc(EditSplineMod* spl, IObjParam *i) { ss=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

class BindCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		BindMouseProc eproc;
		EditSplineMod* ss;

	public:
		BindCMode(EditSplineMod* spl, IObjParam *i) :
			fgProc(spl), eproc(spl,i) {ss=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_VERTCONNECT; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};



class RefineConnectMouseProc : public MouseCallBack {
	private:
		EditSplineMod *ss;
		IObjParam *ip;
		IPoint2 om;
		int type; // See above
	
	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		

	public:
		RefineConnectMouseProc(EditSplineMod* spl, IObjParam *i) { ss=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		void SetType(int type) { this->type = type; }
	};

class RefineConnectCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		RefineConnectMouseProc eproc;
		EditSplineMod* ss;
		int type; // See above

	public:
		RefineConnectCMode(EditSplineMod* spl, IObjParam *i) :
			fgProc(spl), eproc(spl,i) {ss=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_REFINECONNECT; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=1; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
		void SetType(int type) { this->type = type; eproc.SetType(type); }
	};

/*-------------------------------------------------------------------*/

class ESTempData {
	private:
		BezierShape		*shape;
		Interval 		shapeValid;
		
		EditSplineMod 	*mod;
		EditSplineData 	*shapeData;

	public:		
		
		~ESTempData();
		ESTempData(EditSplineMod *m,EditSplineData *md);
		void Invalidate(PartID part,BOOL meshValid=TRUE);
		
		BezierShape		*GetShape(TimeValue t);
		
		BOOL ShapeCached(TimeValue t);
		void UpdateCache(SplineShape *splShape);
	};


// Spline hit override functions

extern void SetSplineHitOverride(int value);
extern void ClearSplineHitOverride();

extern BOOL ValidBooleanPolygon(IObjParam *ip, Spline3D *spline);

#endif // __EDITSPLINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\edmdata.cpp ===
/**********************************************************************
 *<
	FILE: edmdata.cpp

	DESCRIPTION:  Edit Mesh temporary data structures

	CREATED BY: Rolf Berteig

	HISTORY: created 1 September, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "MeshDLib.h"
#include "editmesh.h"

MeshTempData *EditMeshData::TempData (TimeValue t) {
	if (!mod) return NULL;
	if (!tempData) tempData = new MeshTempData();
	tempData->SetMesh (GetMesh (t));
	return tempData;
}

void EditMeshData::Invalidate(PartID part,BOOL meshValid) {
	if (lockInvalidate) return;
	if (!meshValid && mesh) {
		delete mesh;
		mesh = NULL;
		mValid.SetEmpty ();
	}
	if (part & PART_TOPO) topoValid.SetEmpty();
	if (part & PART_GEOM) geomValid.SetEmpty();
	if (tempData) tempData->Invalidate (part);
	if (mod && (part & PART_SELECT)) mod->InvalidateNumberSelected();
	if (mod && (part & (PART_TOPO|PART_SELECT|PART_VERTCOLOR))) mod->InvalidateSurfaceUI ();
}

BOOL EditMeshData::MeshCached(TimeValue t) {
	return (mValid.InInterval(t) && mesh);
}

void EditMeshData::UpdateCache (TimeValue t, TriObject *triOb) {
	if (tempData) {
		DWORD invalidators = 0;
		if (!geomValid.InInterval (t)) invalidators |= PART_GEOM;
		if (!topoValid.InInterval (t)) invalidators |= PART_TOPO;
		if (invalidators) tempData->Invalidate (invalidators);
	}

	if ( mesh ) delete mesh;
	mesh = new Mesh(triOb->GetMesh());

	mValid = FOREVER;

	// These are the channels we care about.
	geomValid = triOb->ChannelValidity (t, GEOM_CHAN_NUM);
	topoValid = triOb->ChannelValidity (t, TOPO_CHAN_NUM);
	mValid &= geomValid;
	mValid &= topoValid;
	mValid &= triOb->ChannelValidity(t,TEXMAP_CHAN_NUM);
	mValid &= triOb->ChannelValidity(t,VERT_COLOR_CHAN_NUM);
}

Mesh *EditMeshData::GetMesh (TimeValue t) {
	if (mValid.InInterval(t) && mesh) return mesh;
	if (!mod) return NULL;

	SetFlag(EMD_UPDATING_CACHE,TRUE);
	lockInvalidate = TRUE;
	mod->NotifyDependents(Interval(t,t), 
		PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|
		PART_DISPLAY|PART_TOPO,
		REFMSG_MOD_EVAL);
	lockInvalidate = FALSE;
	MaxAssert (mValid.InInterval(t) && mesh);
	SetFlag(EMD_UPDATING_CACHE,FALSE);
	//Invalidate (PART_GEOM, TRUE);	// Necessary to make the undo's in scrolling or dragging ops (move, extrude) work.
	return mesh;
}


//----------------------------------------------------------
// MeshDeltaUserData methods  (see also triedui.cpp for ui-related MeshDeltaUser stuff

void EditMeshData::MoveSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin)
{
}

void EditMeshData::RotateSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin)
{
}

void EditMeshData::ScaleSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin)
{
}

void EditMeshData::ExtrudeSelection(int level, BitArray* sel, float amount, float bevel, BOOL groupNormal, Point3* direction)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\edmrest.cpp ===
/**********************************************************************
 *<
	FILE: edmrest.cpp

	DESCRIPTION:  Edit Mesh OSM	Restore objects

	CREATED BY: Rolf Berteig

	HISTORY: created 1 September, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "MeshDLib.h"
#include "editmesh.h"

VertexEditRestore::VertexEditRestore (EditMeshData* md, EditMeshMod* mod) {
	meshData  = md;
	this->mod = mod;

	int num;
	if (num=md->mdelta.vMove.Count()) {
		oMove.SetCount (num);
		memcpy (oMove.Addr(0), md->mdelta.vMove.Addr(0), num*sizeof(VertMove));
	}
	if (num=md->mdelta.vCreate.Count()) {
		oCreate.SetCount (num);
		memcpy (oCreate.Addr(0), md->mdelta.vCreate.Addr(0), num*sizeof(Point3));
	}
	if (num=md->mdelta.vClone.Count()) {
		oClone.SetCount (md->mdelta.vClone.Count());
		memcpy (oClone.Addr(0), md->mdelta.vClone.Addr(0), num*sizeof(VertMove));
	}
}

void VertexEditRestore::Restore(int isUndo) {
	int num;
	nMove.SetCount (num=meshData->mdelta.vMove.Count());
	if (num) memcpy (nMove.Addr(0), meshData->mdelta.vMove.Addr(0), num*sizeof(VertMove));
	nCreate.SetCount (num=meshData->mdelta.vCreate.Count());
	if (num) memcpy (nCreate.Addr(0), meshData->mdelta.vCreate.Addr(0), num*sizeof(Point3));
	nClone.SetCount (num=meshData->mdelta.vClone.Count());
	if (num) memcpy (nClone.Addr(0), meshData->mdelta.vClone.Addr(0), num*sizeof(VertMove));

	meshData->mdelta.vMove.SetCount (num=oMove.Count());
	if (num) memcpy (meshData->mdelta.vMove.Addr(0), oMove.Addr(0), num*sizeof(VertMove));
	meshData->mdelta.vCreate.SetCount (num=oCreate.Count());
	if (num) memcpy (meshData->mdelta.vCreate.Addr(0), oCreate.Addr(0), num*sizeof(Point3));
	meshData->mdelta.vClone.SetCount (num=oClone.Count());
	if (num) memcpy (meshData->mdelta.vClone.Addr(0), oClone.Addr(0), num*sizeof(VertMove));

	meshData->Invalidate(PART_GEOM,FALSE);
	if (isUndo) mod->NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
}

void VertexEditRestore::Redo() {
	int num;
	meshData->mdelta.vMove.SetCount (num=nMove.Count());
	if (num) memcpy (meshData->mdelta.vMove.Addr(0), nMove.Addr(0), num*sizeof(VertMove));
	meshData->mdelta.vCreate.SetCount (num=nCreate.Count());
	if (num) memcpy (meshData->mdelta.vCreate.Addr(0), nCreate.Addr(0), num*sizeof(Point3));
	meshData->mdelta.vClone.SetCount (num=nClone.Count());
	if (num) memcpy (meshData->mdelta.vClone.Addr(0), nClone.Addr(0), num*sizeof(VertMove));

	meshData->Invalidate (PART_GEOM,FALSE);
	mod->NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
}

/*-------------------------------------------------------------------*/

MeshEditRestore::MeshEditRestore (EditMeshData* md, EditMeshMod *mod, MeshDelta & changer) {
	meshData = md;
	this->mod = mod;
	mapChanges.SetCount (changer.GetMapNum());
	changeFlags = changer.ChangeFlags (&mapChanges);
	updateMD = md->updateMD;
	if (updateMD) changeFlags = MDELTA_ALL;
	omdelta.CopyMDChannels (meshData->mdelta, changeFlags, &mapChanges);
}

MeshEditRestore::MeshEditRestore (EditMeshData* md, EditMeshMod *mod, DWORD cF) {
	meshData = md;
	this->mod = mod;
	changeFlags = cF;
	mapChanges.SetCount (md->mdelta.GetMapNum());
	for (int i=0; i<mapChanges.Count(); i++) mapChanges[i] = 0;
	updateMD = md->updateMD;
	omdelta.CopyMDChannels (meshData->mdelta, changeFlags, &mapChanges);
}

MeshEditRestore::MeshEditRestore (EditMeshData* md, EditMeshMod *mod) {
	meshData = md;
	this->mod = mod;
	mapChanges.SetCount (md->mdelta.GetMapNum());
	for (int i=0; i<mapChanges.Count(); i++) mapChanges[i] = MDELTA_ALL;
	changeFlags = MDELTA_ALL;
	updateMD = md->updateMD;
	omdelta.CopyMDChannels (meshData->mdelta, changeFlags, &mapChanges);
}

void MeshEditRestore::Restore(int isUndo) {
	nmdelta.CopyMDChannels (meshData->mdelta, changeFlags, &mapChanges);
	meshData->mdelta.CopyMDChannels (omdelta, changeFlags, &mapChanges);
	meshData->Invalidate (PART_TOPO|PART_GEOM|PART_SELECT, FALSE);	
	meshData->updateMD = updateMD;
	mod->NotifyDependents (FOREVER, PART_TOPO|PART_GEOM|PART_SELECT, REFMSG_CHANGE);
}

void MeshEditRestore::Redo () {
	meshData->mdelta.CopyMDChannels (nmdelta, changeFlags, &mapChanges);
	meshData->Invalidate (PART_TOPO|PART_GEOM|PART_SELECT, FALSE);	
	meshData->updateMD = FALSE;
	mod->NotifyDependents (FOREVER, PART_TOPO|PART_GEOM|PART_SELECT, REFMSG_CHANGE);
}

/*-------------------------------------------------------------------*/

MeshSelectRestore::MeshSelectRestore (EditMeshData * md, EditMeshMod * mm) {
	meshData = md;
	mod = mm;
	t = mod->ip->GetTime();
	selLevel = mm->selLevel;
	switch (selLevel) {
	case SL_VERTEX: undo = md->mdelta.vsel; break;
	case SL_EDGE: undo = md->mdelta.esel; break;
	default: undo = md->mdelta.fsel; break;
	}
}

MeshSelectRestore::MeshSelectRestore (EditMeshData * md, EditMeshMod * mm, DWORD selLev) {
	meshData = md;
	mod = mm;
	t = mod->ip->GetTime();
	selLevel = selLev;
	switch (selLev) {
	case SL_VERTEX: undo = md->mdelta.vsel; break;
	case SL_EDGE: undo = md->mdelta.esel; break;
	default: undo = md->mdelta.fsel; break;
	}
}

void MeshSelectRestore::Restore(int isUndo) {
	switch (selLevel) {
	case SL_VERTEX:
		redo = meshData->mdelta.vsel; 
		meshData->mdelta.vsel = undo;
		break;
	case SL_EDGE:
		redo = meshData->mdelta.esel;
		meshData->mdelta.esel = undo;
		break;
	default:
		redo = meshData->mdelta.fsel; 
		meshData->mdelta.fsel = undo;
		break;
	}
	if (meshData->MeshCached(t)) {
		Mesh *mesh = meshData->GetMesh(t);
		switch (selLevel) {
		case SL_VERTEX: mesh->vertSel = undo; break;
		case SL_EDGE: mesh->edgeSel = undo; break;
		default: mesh->faceSel = undo; break;
		}
		meshData->Invalidate(PART_SELECT);
	}
	mod->LocalDataChanged();
}

void MeshSelectRestore::Redo() {
	switch (selLevel) {
	case SL_VERTEX:
		meshData->mdelta.vsel = redo;
		break;
	case SL_EDGE:   			
		meshData->mdelta.esel = redo;
		break;
	default:
		meshData->mdelta.fsel = redo;
		break;
	}
	if (meshData->MeshCached(t)) {
		Mesh *mesh = meshData->GetMesh(t);
		switch (selLevel) {
		case SL_VERTEX: mesh->vertSel = redo; break;
		case SL_EDGE: mesh->edgeSel = redo; break;
		default: mesh->faceSel = redo; break;
		}
		meshData->Invalidate(PART_SELECT);
	}
	mod->LocalDataChanged();
}

/*-------------------------------------------------------------------*/

VertexHideRestore::VertexHideRestore (EditMeshData* md, EditMeshMod* mod) {
	hide = md->mdelta.vhide;
	meshData = md;
	this->mod = mod;
	t = mod->ip->GetTime();
}

void VertexHideRestore::Restore(int isUndo) {
	rhide = meshData->mdelta.vhide;
	meshData->mdelta.vhide = hide;
	if (meshData->MeshCached(t)) {
		Mesh *mesh = meshData->GetMesh(t);
		mesh->vertHide = hide;		
	}
	mod->NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	if (mod->ip) mod->ip->RedrawViews (mod->ip->GetTime());
}

void VertexHideRestore::Redo() {
	meshData->mdelta.vhide = rhide;
	if (meshData->MeshCached(t)) {
		Mesh *mesh = meshData->GetMesh(t);
		mesh->vertHide = rhide;
	}
	mod->NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	if (mod->ip) mod->ip->RedrawViews (mod->ip->GetTime());
}

/*-------------------------------------------------------------------*/

FaceChangeRestore::FaceChangeRestore(EditMeshData* md, EditMeshMod* mod) {
	attribs = md->mdelta.fChange;
	meshData = md;
	this->mod = mod;
}

void FaceChangeRestore::Restore(int isUndo) {
	if (isUndo) rattribs = meshData->mdelta.fChange;

	meshData->mdelta.fChange = attribs;
	meshData->Invalidate(PART_TOPO,FALSE);

	mod->InvalidateSurfaceUI();
	mod->NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
}

void FaceChangeRestore::Redo() {
	meshData->mdelta.fChange = rattribs;
	meshData->Invalidate(PART_TOPO,FALSE);
	mod->InvalidateSurfaceUI();
	mod->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
}

TransformPlaneRestore::TransformPlaneRestore (EditMeshMod *emm) {
	em = emm;
	oldSliceCenter = em->sliceCenter;
	oldSliceRot = em->sliceRot;
	oldSliceSize = em->sliceSize;
}

void TransformPlaneRestore::Restore (int isUndo) {
	newSliceCenter = em->sliceCenter;
	newSliceRot = em->sliceRot;
	newSliceSize = em->sliceSize;
	em->sliceCenter = oldSliceCenter;
	em->sliceRot = oldSliceRot;
	em->sliceSize = oldSliceSize;
	em->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
}

void TransformPlaneRestore::Redo () {
	em->sliceCenter = newSliceCenter;
	em->sliceRot = newSliceRot;
	em->sliceSize = newSliceSize;
	em->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\edmui.cpp ===
/**********************************************************************
 *<
	FILE: edmui.cpp

	DESCRIPTION:  Edit Mesh OSM	UI code

	CREATED BY: Rolf Berteig

	HISTORY: created 1 September, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "MeshDLib.h"
#include "editmesh.h"

static BOOL CALLBACK SelectDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static BOOL CALLBACK AffectRegionDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static BOOL CALLBACK SurfaceDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static BOOL CALLBACK GeomDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

static float weldThresh = 0.1f;
static float planarFaceThresh = 45.0f;
static float explodeThresh  = 24.0f;
static float autoEdgeThresh  = 24.0f;
static float autoSmoothThresh  = 45.0f;
static int autoEdgeType = 0;	// set&clear
static float tessTens       = 25.0f;
static BOOL expObj          = TRUE;
static BOOL edgeTes         = TRUE;
static int sbmParams[2]     = {1,1};
static DWORD sbsParams[3]   = {1,1,0};
static float lastEdgeThresh = 30.0f;
static int selDeltaR		= 10;
static int selDeltaG		= 10;
static int selDeltaB		= 10;
static Point3 selByColor    = Point3(1,1,1);
static int cloneTo = IDC_EM_CLONE_ELEM;

void ResetEditMeshUI() {
	weldThresh     = 0.1f;
	planarFaceThresh = 45.0f;
	explodeThresh  = 24.0f;
	autoEdgeThresh = 24.0f;
	autoSmoothThresh = 45.0f;
	autoEdgeType = 0;
	tessTens       = 25.0f;
	expObj         = TRUE;
	edgeTes        = TRUE;
	sbmParams[0]   = 1;
	sbmParams[1]   = 1;
	sbsParams[0]   = 1;
	sbsParams[1]   = 1;
	sbsParams[2]   = 0;
	lastEdgeThresh = 30.0f;
	selDeltaR		= 10;
	selDeltaG		= 10;
	selDeltaB		= 10;
	selByColor    = Point3(1,1,1);
	cloneTo = IDC_EM_CLONE_ELEM;
}

// MeshSelImageHandler methods.
// Note: these are also used by meshsel.cpp (and declared in mods.h).
HIMAGELIST MeshSelImageHandler::LoadImages () {
	if (images ) return images;

	HBITMAP hBitmap, hMask;
	images = ImageList_Create(24, 23, ILC_COLOR|ILC_MASK, 10, 0);
	hBitmap = LoadBitmap (hInstance, MAKEINTRESOURCE(IDB_EM_SELTYPES));
	hMask = LoadBitmap (hInstance, MAKEINTRESOURCE(IDB_EM_SELMASK));
	ImageList_Add (images, hBitmap, hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
	return images;
}

// Local static instance.
static MeshSelImageHandler theMeshSelImageHandler;

static int SurfDlgs[] = { 0, IDD_EM_SURF_VERT, IDD_EM_SURF_EDGE,
	IDD_EM_SURF_FACE, IDD_EM_SURF_FACE, IDD_EM_SURF_FACE };

void EditMeshMod::UpdateSurfType () {
	if (!hGeom) return;
	if (!hSurf) {
		if (selLevel == SL_OBJECT) return;
		HWND hKeyFocus = GetFocus ();
		hSurf = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(SurfDlgs[selLevel]),
			SurfaceDlgProc, GetString(IDS_RB_EDITSURFACE), (LPARAM)this, rsSurf ? 0 : APPENDROLL_CLOSED);
		SetFocus (hKeyFocus);
		return;
	}
	bool wasFace = GetDlgItem (hSurf, IDC_SMOOTH_GRP1) ? TRUE : FALSE;
	bool wasEdge = GetDlgItem (hSurf, IDC_EM_EDGE_VIS) ? TRUE : FALSE;
	bool wasVert = GetDlgItem (hSurf, IDC_EM_VERT_SELCOLOR) ? TRUE : FALSE;
	if (wasVert && (selLevel == SL_VERTEX)) return;
	if (wasEdge && (selLevel == SL_EDGE)) return;
	if (wasFace && (selLevel >= SL_FACE)) return;

	rsSurf = IsRollupPanelOpen (hSurf);
	ip->DeleteRollupPage (hSurf);
	if (selLevel == SL_OBJECT) hSurf = NULL;
	else {
		HWND hKeyFocus = GetFocus ();
		hSurf = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(SurfDlgs[selLevel]),
			SurfaceDlgProc, GetString(IDS_RB_EDITSURFACE), (LPARAM)this, rsSurf ? 0 : APPENDROLL_CLOSED);
		SetFocus (hKeyFocus);
	}
}

static int butIDs[] = { 0, IDC_SELVERTEX, IDC_SELEDGE, IDC_SELFACE, IDC_SELPOLY, IDC_SELELEMENT };
void EditMeshMod::RefreshSelType () {
	ICustToolbar *iToolbar = GetICustToolbar(GetDlgItem(hSel,IDC_EM_SELTYPE));
	ICustButton *but;
	for (int i=1; i<6; i++) {
		but = iToolbar->GetICustButton (butIDs[i]);
		but->SetCheck (selLevel==i);
		ReleaseICustButton (but);
	}
	ReleaseICustToolbar(iToolbar);
	SetSelDlgEnables ();
	SetARDlgEnables ();
	SetGeomDlgEnables ();
	UpdateSurfType ();
}

static updateNumSel = TRUE;
void EditMeshMod::InvalidateNumberSelected () {
	if (!hSel) return;
	InvalidateRect (hSel, NULL, FALSE);
	updateNumSel = TRUE;
}

void EditMeshMod::SetNumSelLabel() {
	static TSTR buf;
	if (!hSel) return;
	if (!updateNumSel) {
		SetDlgItemText (hSel, IDC_EM_NUMBER_SEL, buf);
		return;
	}
	updateNumSel = FALSE;

	if (selLevel == SL_OBJECT) {
		buf.printf (GetString (IDS_EM_OBJECT_SEL));
		SetDlgItemText(hSel, IDC_EM_NUMBER_SEL, buf);
		return;
	}
	ModContextList mcList;	
	INodeTab nodes;	
	ip->GetModContexts(mcList,nodes);
	int i, num=0, where=0, thissel;
	for (i=0; i<mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;

		switch (selLevel) {
		case SL_VERTEX:
			thissel = meshData->mdelta.vsel.NumberSet();
			break;
		case SL_FACE:
		case SL_POLY:
		case SL_ELEMENT:
			thissel = meshData->mdelta.fsel.NumberSet();
			break;
		case SL_EDGE:
			thissel= meshData->mdelta.esel.NumberSet();
			break;
		}
		if (thissel) {
			where = i;
			num += thissel;
		}
	}

	// If we have only one element selected, which one is it?
	int which;
	if (num==1) {
		EditMeshData *meshData = (EditMeshData*) mcList[where]->localData;
		switch (selLevel) {
		case SL_VERTEX:
			for (which=0; which<meshData->mdelta.vsel.GetSize(); which++) if (meshData->mdelta.vsel[which]) break;
			break;
		case SL_FACE:
		case SL_POLY:
		case SL_ELEMENT:
			for (which=0; which<meshData->mdelta.fsel.GetSize(); which++) if (meshData->mdelta.fsel[which]) break;
			break;
		case SL_EDGE:
			for (which=0; which<meshData->mdelta.esel.GetSize(); which++) if (meshData->mdelta.esel[which]) break;
			break;
		}
	}

	switch (selLevel) {
	case SL_VERTEX:			
		if (num==1) buf.printf (GetString(IDS_EM_WHICHVERTSEL), which+1);
		else buf.printf(GetString(IDS_RB_NUMVERTSELP),num);
		break;

	case SL_FACE:
	case SL_POLY:
	case SL_ELEMENT:
		if (num==1) buf.printf (GetString(IDS_EM_WHICHFACESEL), which+1);
		else buf.printf(GetString(IDS_RB_NUMFACESELP),num);
		break;

	case SL_EDGE:
		if (num==1) buf.printf (GetString(IDS_EM_WHICHEDGESEL), which+1);
		else buf.printf(GetString(IDS_RB_NUMEDGESELP),num);
		break;
	}

	SetDlgItemText(hSel, IDC_EM_NUMBER_SEL, buf);
}

float EditMeshMod::GetPolyFaceThresh() {
	return DegToRad(planarFaceThresh);
}

// --- Begin/End Edit Params ---------------------------------

const ShortcutTableId kEMeshShortcuts = EM_SHORTCUT_ID;
static BOOL oldShowEnd;
static EMeshShortcutCB *accel=NULL;

void EditMeshMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev ) {
	if (!GetSystemSetting(SYSSET_ENABLE_EDITMESHMOD)) return;
	this->ip = ip;
	CreateMeshDataTempData();
	UpdateSetNames ();

	if ( !hGeom ) {
		hSel = ip->AddRollupPage (hInstance, MAKEINTRESOURCE(IDD_EM_SELECT),
			SelectDlgProc, GetString (IDS_EM_SELECTION), (LPARAM)this, rsSel ? 0 : APPENDROLL_CLOSED);
		hAR = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(IDD_EM_AFFECTREGION),
			AffectRegionDlgProc, GetString(IDS_MS_AFFECTREGION), (LPARAM)this, rsAR ? 0 : APPENDROLL_CLOSED);
		hGeom = ip->AddRollupPage (hInstance, MAKEINTRESOURCE(IDD_EM_GEOM),
			GeomDlgProc, GetString(IDS_EM_EDIT_GEOM), (LPARAM)this, rsGeom ? 0 : APPENDROLL_CLOSED);
		if (selLevel == SL_OBJECT) {
			hSurf = NULL;
		} else {
			hSurf = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(SurfDlgs[selLevel]),
				SurfaceDlgProc, GetString(IDS_RB_EDITSURFACE), (LPARAM)this, rsSurf ? 0 : APPENDROLL_CLOSED);
		}
		InvalidateNumberSelected ();
		accel = new EMeshShortcutCB(this);
		ip->ActivateShortcutTable (accel, kEMeshShortcuts);
	} else {
		SetWindowLong( hGeom, GWL_USERDATA, (LONG)this );
		SetWindowLong (hSel, GWL_USERDATA, (LONG) this);
	}
	SetFlag (EM_EDITING);

	// Create sub object editing modes.
	moveMode       = new MoveModBoxCMode(this,ip);
	rotMode        = new RotateModBoxCMode(this,ip);
	uscaleMode     = new UScaleModBoxCMode(this,ip);
	nuscaleMode    = new NUScaleModBoxCMode(this,ip);
	squashMode     = new SquashModBoxCMode(this,ip);
	selectMode     = new SelectModBoxCMode(this,ip);
	weldVertMode   = new WeldVertCMode(this,ip);
	createVertMode = new CreateVertCMode(this,ip);
	createFaceMode  = new CreateFaceCMode(this,ip);
	divideEdgeMode = new DivideEdgeCMode (this, ip);
	turnEdgeMode   = new TurnEdgeCMode (this, ip);
	attachPickMode = new AttachPickMode(this,ip);
	extrudeMode    = new ExtrudeCMode(this,ip);
	bevelMode = new BevelCMode (this, ip);
	chamferMode = new ChamferCMode (this, ip);
	divideFaceMode = new DivideFaceCMode (this, ip);
	flipMode = new FlipNormCMode (this, ip);
	cutEdgeMode = new CutEdgeCMode (this, ip);

	// Add our sub object type
	TSTR type1( GetString(IDS_RB_VERTEX) );
	TSTR type2( GetString(IDS_RB_EDGE) );
	TSTR type3( GetString(IDS_RB_FACE) );
	TSTR type4(GetString (IDS_EM_POLY));
	TSTR type5 (GetString (IDS_EM_ELEMENT));
	const TCHAR *ptype[] = { type1, type2, type3, type4, type5 };
	ip->RegisterSubObjectTypes( ptype, 5 );

	// Restore the selection level.
	ip->SetSubObjectLevel(selLevel);

	// We want del key input if in sub object selection
	if (selLevel!=SL_OBJECT) {
		delEvent.SetEditMeshMod(this);
		ip->RegisterDeleteUser(&delEvent);
	}

	// Set show end result.
	oldShowEnd = ip->GetShowEndResult();
	ip->SetShowEndResult (GetFlag (EM_DISP_RESULT));

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);	
}

void EditMeshMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next ) {
	if (!GetSystemSetting(SYSSET_ENABLE_EDITMESHMOD)) return;
	// STEVE: are the following lines necessary?  Test.
	EndExtrude (ip->GetTime());
	EndBevel (ip->GetTime());

	if (flags&END_EDIT_REMOVEUI ) {
		if (hSurf) {
			rsSurf = IsRollupPanelOpen (hSurf);
			ip->DeleteRollupPage(hSurf);
			hSurf = NULL;
		}
		if (hGeom) {
			rsGeom = IsRollupPanelOpen (hGeom);
			ip->DeleteRollupPage (hGeom);
			hGeom = NULL;
		}
		if (hAR) {
			rsAR = IsRollupPanelOpen (hAR);
			ip->DeleteRollupPage (hAR);
			hAR = NULL;
		}
		if (hSel) {
			rsSel = IsRollupPanelOpen (hSel);
			ip->DeleteRollupPage (hSel);
			hSel = NULL;
		}
		if (accel) {
			ip->DeactivateShortcutTable (accel, kEMeshShortcuts);
			delete accel;
			accel = NULL;
		}
	} else {
		SetWindowLong( hGeom, GWL_USERDATA, 0 );
		SetWindowLong (hSel, GWL_USERDATA, 0);
	}

	// Unregister del key notification
	if (selLevel!=SL_OBJECT) ip->UnRegisterDeleteUser(&delEvent);

	// STEVE: are following lines needed?
	if ( ip->GetCommandMode()->ID() == CID_EXTRUDE ) ip->SetStdCommandMode( CID_OBJMOVE );
	if ( ip->GetCommandMode()->ID() == CID_BEVEL ) ip->SetStdCommandMode( CID_OBJMOVE );

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);
	ClearAFlag(A_MOD_BEING_EDITED);
	
	DeleteMeshDataTempData();

	ExitAllCommandModes ();
	if ( moveMode ) delete moveMode;
	moveMode = NULL;
	if ( rotMode ) delete rotMode;
	rotMode = NULL;
	if ( uscaleMode ) delete uscaleMode;
	uscaleMode = NULL;
	if ( nuscaleMode ) delete nuscaleMode;
	nuscaleMode = NULL;
	if ( squashMode ) delete squashMode;
	squashMode = NULL;
	if ( selectMode ) delete selectMode;
	selectMode = NULL;
	if (weldVertMode) delete weldVertMode;
	weldVertMode = NULL;
	if (createVertMode) delete createVertMode;
	createVertMode = NULL;
	if (createFaceMode) delete createFaceMode;
	createFaceMode = NULL;
	if (divideFaceMode) delete divideFaceMode;
	divideFaceMode = NULL;
	if (divideEdgeMode) delete divideEdgeMode;
	divideEdgeMode = NULL;
	if (turnEdgeMode) delete turnEdgeMode;
	turnEdgeMode = NULL;
	if (attachPickMode) delete attachPickMode;
	attachPickMode = NULL;
	if( extrudeMode ) delete extrudeMode;
	extrudeMode = NULL;
	if( bevelMode ) delete bevelMode;
	bevelMode = NULL;
	if (chamferMode) delete chamferMode;
	chamferMode = NULL;
	if (flipMode) delete flipMode;
	flipMode = NULL;
	if (cutEdgeMode) delete cutEdgeMode;
	cutEdgeMode = NULL;

	this->ip = NULL;
	ClearFlag (EM_EDITING);

	// Reset show end result
	SetFlag (EM_DISP_RESULT, ip->GetShowEndResult());
	ip->SetShowEndResult(oldShowEnd);
}

void EditMeshMod::ExitAllCommandModes (bool exSlice) {
	ip->DeleteMode (moveMode);
	ip->DeleteMode (rotMode);
	ip->DeleteMode (uscaleMode);
	ip->DeleteMode (nuscaleMode);
	ip->DeleteMode (squashMode);
	ip->DeleteMode (selectMode);
	ip->DeleteMode (weldVertMode);	
	ip->DeleteMode (createVertMode);	
	ip->DeleteMode (createFaceMode);
	ip->DeleteMode (divideFaceMode);
	ip->DeleteMode (divideEdgeMode);	
	ip->DeleteMode (turnEdgeMode);
	ip->DeleteMode (extrudeMode);
	ip->DeleteMode (bevelMode);
	ip->DeleteMode (chamferMode);
	ip->DeleteMode (flipMode);
	ip->DeleteMode (cutEdgeMode);
	ip->ClearPickMode();
	if (exSlice && sliceMode) ExitSliceMode ();
}


// -- Misc. Window procs ----------------------------------------

static int createCurveType   = IDC_EMCURVE_SMOOTH;
static int curveIgnoreHiddenEdges = TRUE;

static BOOL CALLBACK CurveNameDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static TSTR *name = NULL;

	switch (msg) {
	case WM_INITDIALOG:
		name = (TSTR*)lParam;
		SetWindowText (GetDlgItem(hWnd,IDC_EMCURVE_NAME), name->data());
		CenterWindow(hWnd,GetParent(hWnd));
		SendMessage(GetDlgItem(hWnd,IDC_EMCURVE_NAME), EM_SETSEL,0,-1);			
		CheckDlgButton(hWnd,createCurveType,TRUE);
		CheckDlgButton(hWnd,IDC_EMCURVE_IGNOREHIDDEN,curveIgnoreHiddenEdges);
		return FALSE;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			name->Resize(GetWindowTextLength(GetDlgItem(hWnd,IDC_EMCURVE_NAME))+1);
			GetWindowText(GetDlgItem(hWnd,IDC_EMCURVE_NAME), name->data(), name->length()+1);
			if (IsDlgButtonChecked(hWnd,IDC_EMCURVE_SMOOTH)) createCurveType = IDC_EMCURVE_SMOOTH;
			else createCurveType = IDC_EMCURVE_LINEAR;
			curveIgnoreHiddenEdges = IsDlgButtonChecked(hWnd,IDC_EMCURVE_IGNOREHIDDEN);
			EndDialog(hWnd,1);
			break;
		
		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return 0;
	}
	return 1;
}

static BOOL detachToElem = FALSE;
static BOOL detachAsClone = FALSE;

static void SetDetachNameState(HWND hWnd) {
	if (detachToElem) {
		EnableWindow(GetDlgItem(hWnd,IDC_EM_DETACH_NAMELABEL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_EM_DETACH_NAME),FALSE);
	} else {
		EnableWindow(GetDlgItem(hWnd,IDC_EM_DETACH_NAMELABEL),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_EM_DETACH_NAME),TRUE);
	}
}

static BOOL CALLBACK DetachDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static TSTR *name = NULL;

	switch (msg) {
	case WM_INITDIALOG:
		name = (TSTR*)lParam;
		SetWindowText(GetDlgItem(hWnd,IDC_EM_DETACH_NAME), name->data());
		CenterWindow(hWnd,GetParent(hWnd));
		SendMessage(GetDlgItem(hWnd,IDC_EM_DETACH_NAME), EM_SETSEL,0,-1);
		CheckDlgButton(hWnd,IDC_EM_DETACH_ELEM,detachToElem);
		CheckDlgButton (hWnd, IDC_EM_DETACH_CLONE, detachAsClone);
		if (detachToElem) SetFocus (GetDlgItem (hWnd, IDOK));
		else SetFocus (GetDlgItem (hWnd, IDC_EM_DETACH_NAME));
		SetDetachNameState(hWnd);
		return FALSE;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			name->Resize (GetWindowTextLength(GetDlgItem(hWnd,IDC_EM_DETACH_NAME))+1);
			GetWindowText (GetDlgItem(hWnd,IDC_EM_DETACH_NAME),
				name->data(), name->length()+1);
			EndDialog(hWnd,1);
			break;

		case IDC_EM_DETACH_ELEM:
			detachToElem = IsDlgButtonChecked (hWnd, IDC_EM_DETACH_ELEM);
			SetDetachNameState(hWnd);
			break;

		case IDC_EM_DETACH_CLONE:
			detachAsClone = IsDlgButtonChecked (hWnd, IDC_EM_DETACH_CLONE);
			break;

		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return 0;
	}
	return 1;
}

BOOL GetDetachObjectName(Interface *ip,TSTR &name, BOOL &elem, BOOL &asClone) {
	HWND hCore = ip->GetMAXHWnd();
	name = GetString (IDS_EM_NEWOBJECTNAME);
	ip->MakeNameUnique (name);
	if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_EM_DETACH),
			hCore, DetachDlgProc, (LPARAM)&name)) {
		elem = detachToElem;
		asClone = detachAsClone;
		return TRUE;
	} else {
		return FALSE;
	}
}

static void SetCloneNameState(HWND hWnd) {
	switch (cloneTo) {
	case IDC_EM_CLONE_ELEM:
		EnableWindow(GetDlgItem(hWnd,IDC_EM_CLONE_NAME),FALSE);
		break;
	case IDC_EM_CLONE_OBJ:
		EnableWindow(GetDlgItem(hWnd,IDC_EM_CLONE_NAME),TRUE);
		break;
	}
}

static BOOL CALLBACK CloneDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static TSTR *name = NULL;

	switch (msg) {
	case WM_INITDIALOG:
		name = (TSTR*)lParam;
		SetWindowText(GetDlgItem(hWnd,IDC_EM_CLONE_NAME), name->data());
		CenterWindow(hWnd, GetParent(hWnd));
		CheckRadioButton (hWnd, IDC_EM_CLONE_OBJ, IDC_EM_CLONE_ELEM, cloneTo);
		if (cloneTo == IDC_EM_CLONE_OBJ) {
			SetFocus(GetDlgItem(hWnd,IDC_EM_CLONE_NAME));
			SendMessage(GetDlgItem(hWnd,IDC_EM_CLONE_NAME), EM_SETSEL,0,-1);
		} else SetFocus (GetDlgItem (hWnd, IDOK));
		SetCloneNameState(hWnd);
		return FALSE;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			name->Resize (GetWindowTextLength(GetDlgItem(hWnd,IDC_EM_CLONE_NAME))+1);
			GetWindowText (GetDlgItem(hWnd,IDC_EM_CLONE_NAME),
				name->data(), name->length()+1);
			EndDialog(hWnd,1);
			break;

		case IDCANCEL:
			EndDialog (hWnd, 0);
			break;

		case IDC_EM_CLONE_ELEM:
		case IDC_EM_CLONE_OBJ:
			cloneTo = LOWORD(wParam);
			SetCloneNameState(hWnd);
			break;
		}
		break;

	default:
		return 0;
	}
	return 1;
}

BOOL GetCloneObjectName (Interface *ip, TSTR &name) {
	HWND hCore = ip->GetMAXHWnd();
	name = GetString(IDS_EM_NEWOBJECTNAME);
	ip->MakeNameUnique (name);
	DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_EM_CLONE), hCore,
		CloneDlgProc, (LPARAM)&name);
	return (cloneTo==IDC_EM_CLONE_OBJ);
}

static BOOL CALLBACK ExplodeDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static TSTR *name = NULL;

	switch (msg) {
	case WM_INITDIALOG:
		name = (TSTR*)lParam;
		SetWindowText(GetDlgItem(hWnd,IDC_EM_EXPLODE_NAME), name->data());
		CenterWindow(hWnd, GetParent(hWnd));
		SetFocus(GetDlgItem(hWnd,IDC_EM_EXPLODE_NAME));
		SendMessage(GetDlgItem(hWnd,IDC_EM_EXPLODE_NAME), EM_SETSEL,0,-1);
		return FALSE;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			name->Resize (GetWindowTextLength(GetDlgItem(hWnd,IDC_EM_EXPLODE_NAME))+1);
			GetWindowText (GetDlgItem(hWnd,IDC_EM_EXPLODE_NAME),
				name->data(), name->length()+1);
			EndDialog(hWnd,1);
			break;

		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return 0;
	}
	return 1;
}

BOOL GetExplodeObjectName (HWND hCore, TSTR &name) {
	name = GetString(IDS_EM_NEWOBJECTNAME);
	if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_EM_EXPLODE),
			hCore, ExplodeDlgProc, (LPARAM)&name)) {
		return TRUE;
	} else {
		return FALSE;
	}
}

void EditMeshMod::SetSelDlgEnables() {
	if (!hSel) return;
	BOOL fac = (selLevel >= SL_FACE);
	BOOL poly = (selLevel == SL_POLY);
	BOOL edg = (selLevel == SL_EDGE);
	BOOL obj = (selLevel == SL_OBJECT);
	BOOL vtx = (selLevel == SL_VERTEX);

	EnableWindow (GetDlgItem (hSel, IDC_EM_SEL_BYVERT), fac||edg);
	EnableWindow (GetDlgItem (hSel, IDC_EM_IGNORE_BACKFACES), !obj);
	EnableWindow (GetDlgItem (hSel,IDC_EM_IGNORE_VISEDGE), poly);
	EnableWindow (GetDlgItem (hSel, IDC_EM_SEL_PT_TEXT), poly);
	ISpinnerControl *spin = GetISpinner(GetDlgItem(hSel,IDC_EM_PLANARSPINNER));
	spin->Enable(poly);
	ReleaseISpinner(spin);
	ICustButton *but;
	but = GetICustButton (GetDlgItem (hSel, IDC_EM_HIDE));
	but->Enable (vtx||fac);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hSel, IDC_EM_UNHIDEALL));
	but->Enable (vtx||fac);
	ReleaseICustButton (but);

	but = GetICustButton (GetDlgItem (hSel, IDC_EM_COPYNS));
	but->Enable (!obj);
	ReleaseICustButton(but);
	but = GetICustButton (GetDlgItem (hSel, IDC_EM_PASTENS));
	but->Enable (!obj && (GetMeshNamedSelClip (namedClipLevel[selLevel]) ? TRUE : FALSE));
	ReleaseICustButton(but);
}

static BOOL CALLBACK SelectDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	EditMeshMod *em = (EditMeshMod *) GetWindowLong (hWnd, GWL_USERDATA);
	ICustToolbar *iToolbar;
	ISpinnerControl *spin;

	switch (msg) {
	case WM_INITDIALOG:
		em = (EditMeshMod*) lParam;
		em->hSel = hWnd;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);			

		spin = GetISpinner(GetDlgItem(hWnd,IDC_EM_PLANARSPINNER));
		spin->SetLimits(0, 180, FALSE);
		spin->SetScale(0.1f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_EM_PLANAR), EDITTYPE_FLOAT);
		spin->SetValue (planarFaceThresh, FALSE);
		ReleaseISpinner(spin);

		iToolbar = GetICustToolbar(GetDlgItem(hWnd,IDC_EM_SELTYPE));
		iToolbar->SetImage (theMeshSelImageHandler.LoadImages());
		iToolbar->AddTool (ToolButtonItem(CTB_CHECKBUTTON,0,5,0,5,24,23,24,23,IDC_SELVERTEX));
		iToolbar->AddTool (ToolButtonItem(CTB_CHECKBUTTON,1,6,1,6,24,23,24,23,IDC_SELEDGE));
		iToolbar->AddTool (ToolButtonItem(CTB_CHECKBUTTON,2,7,2,7,24,23,24,23,IDC_SELFACE));
		iToolbar->AddTool (ToolButtonItem(CTB_CHECKBUTTON,3,8,3,8,24,23,24,23,IDC_SELPOLY));
		iToolbar->AddTool (ToolButtonItem(CTB_CHECKBUTTON,4,9,4,9,24,23,24,23,IDC_SELELEMENT));
		ReleaseICustToolbar(iToolbar);
		em->RefreshSelType();

		CheckDlgButton (hWnd, IDC_EM_SEL_BYVERT, em->selByVert);
		CheckDlgButton (hWnd, IDC_EM_IGNORE_BACKFACES, em->ignoreBackfaces);
		CheckDlgButton (hWnd, IDC_EM_IGNORE_VISEDGE, em->ignoreVisEdge);
		break;

	case CC_SPINNER_CHANGE:
		spin = (ISpinnerControl*)lParam;
		switch (LOWORD(wParam)) {
		case IDC_EM_PLANARSPINNER:
			planarFaceThresh = spin->GetFVal();
			break;
		}
		break;

	case WM_COMMAND:
		if (HIWORD(wParam)==1) return FALSE;	// not handling keyboard accelerators here.

		switch (LOWORD(wParam)) {
		case IDC_SELVERTEX:
			if (em->selLevel == SL_VERTEX) em->ip->SetSubObjectLevel (SL_OBJECT);
			else em->ip->SetSubObjectLevel (SL_VERTEX);
			break;

		case IDC_SELEDGE:
			if (em->selLevel == SL_EDGE) em->ip->SetSubObjectLevel (SL_OBJECT);
			else em->ip->SetSubObjectLevel (SL_EDGE);
			break;

		case IDC_SELFACE:
			if (em->selLevel == SL_FACE) em->ip->SetSubObjectLevel (SL_OBJECT);
			else em->ip->SetSubObjectLevel (SL_FACE);
			break;

		case IDC_SELPOLY:
			if (em->selLevel == SL_POLY) em->ip->SetSubObjectLevel (SL_OBJECT);
			else em->ip->SetSubObjectLevel (SL_POLY);
			break;

		case IDC_SELELEMENT:
			if (em->selLevel == SL_ELEMENT) em->ip->SetSubObjectLevel (SL_OBJECT);
			else em->ip->SetSubObjectLevel (SL_ELEMENT);
			break;

		case IDC_EM_SEL_BYVERT:
			em->selByVert = IsDlgButtonChecked(hWnd,IDC_EM_SEL_BYVERT);
			break;

		case IDC_EM_IGNORE_BACKFACES:
			em->ignoreBackfaces = IsDlgButtonChecked(hWnd,IDC_EM_IGNORE_BACKFACES);
			break;

		case IDC_EM_IGNORE_VISEDGE:
			em->ignoreVisEdge = IsDlgButtonChecked(hWnd,IDC_EM_IGNORE_VISEDGE);
			break;

		case IDC_EM_HIDE: em->ButtonOp (MopHide); break;
		case IDC_EM_UNHIDEALL: em->ButtonOp (MopUnhideAll); break;
		case IDC_EM_COPYNS: em->NSCopy(); break;
		case IDC_EM_PASTENS: em->NSPaste(); break;
		}
		break;

	case WM_PAINT:
		if (updateNumSel) em->SetNumSelLabel ();
		return FALSE;

	case WM_NOTIFY:
		if (((LPNMHDR)lParam)->code != TTN_NEEDTEXT) break;
		LPTOOLTIPTEXT lpttt;
		lpttt = (LPTOOLTIPTEXT)lParam;				
		switch (lpttt->hdr.idFrom) {
		case IDC_SELVERTEX:
			lpttt->lpszText = GetString (IDS_RB_VERTEX);
			break;
		case IDC_SELEDGE:
			lpttt->lpszText = GetString (IDS_RB_EDGE);
			break;
		case IDC_SELFACE:
			lpttt->lpszText = GetString(IDS_RB_FACE);
			break;
		case IDC_SELPOLY:
			lpttt->lpszText = GetString(IDS_EM_POLY);
			break;
		case IDC_SELELEMENT:
			lpttt->lpszText = GetString(IDS_EM_ELEMENT);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

#define GRAPHSTEPS 20

static void DrawCurve(HWND hWnd,HDC hdc, EditMeshMod *mod) {
	TSTR label = FormatUniverseValue(mod->falloff);
	TSTR zero = FormatUniverseValue(0.0f);
	SetWindowText (GetDlgItem (hWnd, IDC_FARLEFTLABEL), label);
	SetWindowText (GetDlgItem (hWnd, IDC_NEARLABEL), zero);
	SetWindowText (GetDlgItem (hWnd, IDC_FARRIGHTLABEL), label);

	Rect rect, orect;
	GetClientRectP(GetDlgItem(hWnd,IDC_AR_GRAPH),&rect);
	orect = rect;

	SelectObject(hdc,GetStockObject(NULL_PEN));
	SelectObject(hdc,GetStockObject(WHITE_BRUSH));
	Rectangle(hdc,rect.left,rect.top,rect.right,rect.bottom);	
	SelectObject(hdc,GetStockObject(NULL_BRUSH));
	
	rect.left   += 3;
	rect.right  -= 3;
	rect.top    += 20;
	rect.bottom -= 20;
	
	SelectObject(hdc,CreatePen(PS_DOT,0,GetSysColor(COLOR_BTNFACE)));
	MoveToEx(hdc,orect.left,rect.top,NULL);
	LineTo(hdc,orect.right,rect.top);
	MoveToEx(hdc,orect.left,rect.bottom,NULL);
	LineTo(hdc,orect.right,rect.bottom);
	MoveToEx(hdc,(rect.left+rect.right)/2,orect.top,NULL);
	LineTo(hdc,(rect.left+rect.right)/2,orect.bottom);
	DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));
	
	MoveToEx(hdc,rect.left,rect.bottom,NULL);
	for (int i=0; i<=GRAPHSTEPS; i++) {
		float dist = mod->falloff * float(abs(i-GRAPHSTEPS/2))/float(GRAPHSTEPS/2);		
		float y = AffectRegionFunction (dist, mod->falloff, mod->pinch, mod->bubble);
		int ix = rect.left + int(float(rect.w()-1) * float(i)/float(GRAPHSTEPS));
		int	iy = rect.bottom - int(y*float(rect.h()-2)) - 1;
		if (iy<orect.top) iy = orect.top;
		if (iy>orect.bottom-1) iy = orect.bottom-1;
		LineTo(hdc, ix, iy);
	}
	
	WhiteRect3D(hdc,orect,TRUE);
}

void EditMeshMod::SetARDlgEnables () {
	if (!hAR) return;
	ISpinnerControl *spin;
	EnableWindow (GetDlgItem (hAR, IDC_EM_AFFECT_REGION), selLevel);
	bool enable = (selLevel && affectRegion) ? TRUE : FALSE;
	EnableWindow (GetDlgItem (hAR, IDC_EM_E_DIST), enable);
	EnableWindow (GetDlgItem (hAR, IDC_EM_AR_BACK), enable);
	spin = GetISpinner (GetDlgItem (hAR, IDC_EM_E_ITER_SPIN));
	spin->Enable (enable && useEdgeDist);
	ReleaseISpinner (spin);
	spin = GetISpinner (GetDlgItem (hAR, IDC_FALLOFFSPIN));
	spin->Enable (enable);
	ReleaseISpinner (spin);
	spin = GetISpinner (GetDlgItem (hAR, IDC_PINCHSPIN));
	spin->Enable (enable);
	ReleaseISpinner (spin);
	spin = GetISpinner (GetDlgItem (hAR, IDC_BUBBLESPIN));
	spin->Enable (enable);
	ReleaseISpinner (spin);
	EnableWindow (GetDlgItem (hAR, IDC_FALLOFF_LABEL), enable);
	EnableWindow (GetDlgItem (hAR, IDC_PINCH_LABEL), enable);
	EnableWindow (GetDlgItem (hAR, IDC_BUBBLE_LABEL), enable);
}

BOOL CALLBACK AffectRegionDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	EditMeshMod *em = (EditMeshMod*)GetWindowLong(hWnd,GWL_USERDATA);
	ISpinnerControl *spin;
	Rect rect;

	switch (msg) {
	case WM_INITDIALOG:
		em = (EditMeshMod*)lParam;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);

		// Set spinners:
		spin = GetISpinner(GetDlgItem(hWnd,IDC_FALLOFFSPIN));
		spin->SetLimits(0.001f,9999999.0f, FALSE);
		spin->SetAutoScale();
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_FALLOFF), EDITTYPE_POS_UNIVERSE);
		spin->SetValue(em->falloff,FALSE);
		spin->SetResetValue (20.0f);
		ReleaseISpinner(spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_PINCHSPIN));
		spin->SetLimits(-10.0f,10.0f, FALSE);
		spin->SetScale(0.01f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_PINCH), EDITTYPE_FLOAT);
		spin->SetValue(em->pinch,FALSE);
		spin->SetResetValue (0.0f);
		ReleaseISpinner(spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_BUBBLESPIN));
		spin->SetLimits(-10.0f,10.0f, FALSE);
		spin->SetScale(0.01f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_BUBBLE), EDITTYPE_FLOAT);
		spin->SetValue(em->bubble,FALSE);
		spin->SetResetValue (0.0f);
		ReleaseISpinner(spin);
					
		spin = GetISpinner(GetDlgItem(hWnd,IDC_EM_E_ITER_SPIN));
		spin->SetLimits(1,8, FALSE);
		spin->SetScale(0.01f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_EM_E_ITER), EDITTYPE_INT);
		spin->SetValue(em->edgeIts,FALSE);
		spin->SetResetValue (1);
		if (!em->affectRegion || !em->useEdgeDist) spin->Disable();
		ReleaseISpinner(spin);

		// Check Checkboxes:
		CheckDlgButton (hWnd, IDC_EM_AFFECT_REGION, em->affectRegion);
		CheckDlgButton(hWnd, IDC_EM_E_DIST, em->useEdgeDist);
		CheckDlgButton (hWnd, IDC_EM_AR_BACK, !em->arIgBack);

		ShowWindow(GetDlgItem(hWnd,IDC_AR_GRAPH),SW_HIDE);
		CenterWindow(hWnd,GetParent(hWnd));
		em->hAR = hWnd;
		em->SetARDlgEnables ();
		break;
		
	case WM_PAINT: {
		PAINTSTRUCT ps;
		HDC hdc = BeginPaint(hWnd,&ps);
		DrawCurve (hWnd, hdc, em);
		EndPaint(hWnd,&ps);
		break;
		}
		
	case CC_SPINNER_CHANGE:
		if (LOWORD(wParam) != IDC_EM_E_ITER_SPIN) {
			GetClientRectP(GetDlgItem(hWnd,IDC_AR_GRAPH),&rect);
			InvalidateRect(hWnd,&rect,FALSE);
		}
		spin = (ISpinnerControl*)lParam;
		switch (LOWORD(wParam)) {
		case IDC_FALLOFFSPIN:
			em->falloff = spin->GetFVal();
			em->InvalidateAffectRegion();
			break;
		case IDC_PINCHSPIN:
			em->pinch = spin->GetFVal();
			em->InvalidateAffectRegion();
			break;
		case IDC_BUBBLESPIN:
			em->bubble = spin->GetFVal();
			em->InvalidateAffectRegion();
			break;
		case IDC_EM_E_ITER_SPIN:
			em->edgeIts = spin->GetIVal ();
			em->InvalidateDistances ();
		}
		em->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
		em->ip->RedrawViews (em->ip->GetTime(),REDRAW_INTERACTIVE);
		break;

	case WM_COMMAND:
		if (HIWORD(wParam)==1) return FALSE;	// not handling keyboard accelerators here.
		switch (LOWORD(wParam)) {
		case IDC_EM_AFFECT_REGION:
			em->affectRegion = IsDlgButtonChecked (hWnd,IDC_EM_AFFECT_REGION);
			em->SetARDlgEnables ();
			em->InvalidateDistances ();
			em->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
			em->ip->RedrawViews(em->ip->GetTime());
			break;

		case IDC_EM_E_DIST:
			em->useEdgeDist = IsDlgButtonChecked (hWnd, IDC_EM_E_DIST);
			spin = GetISpinner (GetDlgItem (hWnd, IDC_EM_E_ITER_SPIN));
			spin->Enable (em->useEdgeDist && em->affectRegion);
			ReleaseISpinner(spin);
			em->InvalidateDistances ();
			em->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
			em->ip->RedrawViews(em->ip->GetTime());
			break;

		case IDC_EM_AR_BACK:
			em->arIgBack = !IsDlgButtonChecked (hWnd, IDC_EM_AR_BACK);
			em->InvalidateAffectRegion ();
			em->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
			em->ip->RedrawViews(em->ip->GetTime());
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

void EditMeshMod::SetGeomDlgEnables () {
	if (!hGeom) return;
	BOOL edg = (selLevel == SL_EDGE);
	BOOL vtx = (selLevel == SL_VERTEX);
	BOOL fac = (selLevel >= SL_FACE);
	BOOL obj = (selLevel == SL_OBJECT);
	ISpinnerControl *spin;
	ICustButton *but;

	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_CREATE));
	but->Enable (vtx||fac);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_DETACH));
	but->Enable (!edg);
	if (obj) but->SetText (GetString (IDS_EM_ATTACH_LIST));
	else but->SetText (GetString (IDS_EM_DETACH));
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_DIVIDE));
	but->Enable (!obj);
	if (edg||fac) {
		but->SetText (GetString (IDS_EM_DIVIDE));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
	} else {
		but->SetText (GetString (IDS_EM_BREAK));
		but->SetType(CBT_PUSH);
	}
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_TURN));
	but->Enable (edg);
	ReleaseICustButton (but);
	// Align buttons always active.
	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_MAKEPLANAR));
	but->Enable (!obj);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_DELETE));
	but->Enable (!obj);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_EXTRUDE));
	but->Enable (edg||fac);
	ReleaseICustButton (but);
	spin = GetISpinner (GetDlgItem (hGeom, IDC_EM_EXTRUDESPINNER));
	spin->Enable (edg||fac);
	ReleaseISpinner (spin);
	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_BEVEL));
	but->Enable (!obj);
	if (vtx||edg) but->SetText (GetString (IDS_EM_CHAMFER));
	else but->SetText (GetString (IDS_EM_BEVEL));
	ReleaseICustButton (but);
	spin = GetISpinner (GetDlgItem (hGeom, IDC_EM_OUTLINESPINNER));
	spin->Enable (!obj);
	if (vtx||edg) spin->SetLimits(0.0f, 9999999.0f, FALSE);
	else spin->SetLimits(-9999999.0f, 9999999.0f, FALSE);
	ReleaseISpinner (spin);
	EnableWindow (GetDlgItem (hGeom, IDC_EM_EXTYPE_A), fac||edg);
	EnableWindow (GetDlgItem (hGeom, IDC_EM_EXTYPE_B), fac||edg);
	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_COLLAPSE));
	but->Enable (!obj);
	ReleaseICustButton (but);
	// It would be nice if Slice Plane were always active, but we can't make it available
	// at the object level, since the transforms won't work.
	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_SLICEPLANE));
	but->Enable (!obj);
	ReleaseICustButton (but);
	EnableWindow (GetDlgItem (hGeom, IDC_EM_SPLIT), !obj);
	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_CUT));
	but->Enable (edg|fac);
	ReleaseICustButton (but);
	EnableWindow (GetDlgItem (hGeom, IDC_EM_REFINE), (edg||fac) && !sliceMode);

	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_TESSELLATE));
	but->Enable (fac);
	ReleaseICustButton (but);
	spin = GetISpinner (GetDlgItem (hGeom, IDC_EM_TENSIONSPINNER));
	spin->Enable (fac && edgeTes);
	ReleaseISpinner (spin);
	EnableWindow (GetDlgItem (hGeom, IDC_EM_TES_TEXT), fac);
	EnableWindow (GetDlgItem (hGeom, IDC_EM_TES_EDGE), fac);
	EnableWindow (GetDlgItem (hGeom, IDC_EM_TES_CENTER), fac);

	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_EXPLODE));
	but->Enable (fac || obj);
	ReleaseICustButton (but);
	spin = GetISpinner (GetDlgItem (hGeom, IDC_EM_ANGLETHRESHSPIN));
	spin->Enable (fac || obj);
	ReleaseISpinner (spin);
	EnableWindow (GetDlgItem (hGeom, IDC_EM_EXP_TEXT), fac||obj);
	EnableWindow (GetDlgItem (hGeom, IDC_EM_EXP_ELEMENTS), fac||obj);
	EnableWindow (GetDlgItem (hGeom, IDC_EM_EXP_OBJECTS), fac||obj);

	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_WELD));
	but->Enable (vtx);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_WELDTOVERT));
	but->Enable (vtx);
	ReleaseICustButton (but);
	EnableWindow (GetDlgItem (hGeom, IDC_EM_PIXELS_TEXT), vtx);
	spin = GetISpinner (GetDlgItem (hGeom, IDC_EM_W_THR_SPIN));
	spin->Enable (vtx);
	ReleaseISpinner (spin);
	spin = GetISpinner (GetDlgItem (hGeom, IDC_EM_T_THR_SPIN));
	spin->Enable (vtx);
	ReleaseISpinner (spin);

	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_SELECT_OPEN));
	but->Enable (edg);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_EM_CREATE_CURVE));
	but->Enable (edg);
	ReleaseICustButton (but);
}

static BOOL CALLBACK GeomDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	EditMeshMod *em = (EditMeshMod*)GetWindowLong(hWnd,GWL_USERDATA);
	ISpinnerControl *spin;
	ICustButton *but;
	TSTR name;

	switch (msg) {
	case WM_INITDIALOG:
		// Record the EM * in the window's long.
		em = (EditMeshMod*)lParam;
		em->hGeom = hWnd;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);

		// Set up the "depressed" color for the command-mode buttons
		but = GetICustButton(GetDlgItem(hWnd,IDC_EM_CREATE));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_EM_DIVIDE));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_EM_TURN));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_EM_EXTRUDE));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_EM_BEVEL));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_EM_OBJ_ATTACH));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);					

		but = GetICustButton(GetDlgItem(hWnd,IDC_EM_SLICEPLANE));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		but->SetCheck (em->sliceMode);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_EM_CUT));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_EM_WELDTOVERT));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		// Set up spinners
		spin = GetISpinner(GetDlgItem(hWnd,IDC_EM_EXTRUDESPINNER));
		spin->SetLimits(-9999999.0f, 9999999.0f, FALSE);
		spin->LinkToEdit (GetDlgItem (hWnd,IDC_EM_EXTRUDEAMOUNT), EDITTYPE_UNIVERSE);
		spin->SetScale (.1f);
		ReleaseISpinner (spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_EM_OUTLINESPINNER));
		spin->SetLimits(-9999999.0f, 9999999.0f, FALSE);
		spin->LinkToEdit (GetDlgItem (hWnd,IDC_EM_OUTLINEAMOUNT), EDITTYPE_UNIVERSE);
		spin->SetScale (.1f);
		ReleaseISpinner (spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_EM_TENSIONSPINNER));
		spin->SetLimits(-100,100, FALSE);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_EM_TENSION), EDITTYPE_FLOAT);
		spin->SetValue(tessTens,FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner (GetDlgItem (hWnd,IDC_EM_ANGLETHRESHSPIN));
		spin->SetLimits(0, 180, FALSE);
		spin->SetScale(0.1f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_EM_ANGLETHRESH), EDITTYPE_FLOAT);
		spin->SetValue(explodeThresh,FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner (GetDlgItem(hWnd, IDC_EM_W_THR_SPIN));
		spin->SetLimits(0,9999999, FALSE);
		spin->SetAutoScale();
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_EM_W_THR), EDITTYPE_POS_UNIVERSE);
		spin->SetValue(weldThresh,FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_EM_T_THR_SPIN));
		spin->SetLimits(1,1000, FALSE);
		spin->SetScale(0.1f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_EM_T_THR), EDITTYPE_INT);
		spin->SetValue(em->weldBoxSize,FALSE);
		ReleaseISpinner(spin);

		// Take care of Explode and Tessellation radios:
		if (expObj) {
			CheckDlgButton(hWnd,IDC_EM_EXP_OBJECTS,TRUE);
			CheckDlgButton(hWnd,IDC_EM_EXP_ELEMENTS,FALSE);
		} else {
			CheckDlgButton(hWnd,IDC_EM_EXP_OBJECTS,FALSE);
			CheckDlgButton(hWnd,IDC_EM_EXP_ELEMENTS,TRUE);
		}

		if (edgeTes) {
			CheckDlgButton(hWnd,IDC_EM_TES_EDGE,TRUE);
			CheckDlgButton(hWnd,IDC_EM_TES_CENTER,FALSE);
		} else {
			CheckDlgButton(hWnd,IDC_EM_TES_EDGE,FALSE);
			CheckDlgButton(hWnd,IDC_EM_TES_CENTER,TRUE);				
		}

		if (em->extType == MESH_EXTRUDE_CLUSTER) {
			CheckRadioButton (hWnd, IDC_EM_EXTYPE_A, IDC_EM_EXTYPE_B, IDC_EM_EXTYPE_A);
		} else {
			CheckRadioButton (hWnd, IDC_EM_EXTYPE_A, IDC_EM_EXTYPE_B, IDC_EM_EXTYPE_B);
		}

		// Set Slice button to be grey if not in Slice Plane mode.
		but = GetICustButton (GetDlgItem (hWnd, IDC_EM_SLICE));
		but->Enable (em->sliceMode);
		ReleaseICustButton (but);

		// Check boxes as appropriate
		CheckDlgButton(hWnd, IDC_EM_SPLIT, em->sliceSplit);
		CheckDlgButton(hWnd, IDC_EM_REFINE, em->cutRefine);
		em->SetGeomDlgEnables();
		break;

	case CC_SPINNER_BUTTONDOWN:
		switch (LOWORD(wParam)) {
		case IDC_EM_EXTRUDESPINNER:
			em->BeginExtrude (em->ip->GetTime());
			break;

		case IDC_EM_OUTLINESPINNER:
			switch (em->selLevel) {
			case SL_VERTEX:
			case SL_EDGE:
				em->BeginChamfer (em->ip->GetTime ());
				break;
			case SL_FACE:
			case SL_POLY:
			case SL_ELEMENT:
				em->BeginBevel (em->ip->GetTime (), FALSE);
				break;
			}
			break;
		}
		break;

	case CC_SPINNER_BUTTONUP:
		switch (LOWORD(wParam)) {
		case IDC_EM_EXTRUDESPINNER:
			em->EndExtrude (em->ip->GetTime(), HIWORD(wParam));
			em->ip->RedrawViews (em->ip->GetTime(),REDRAW_END);
			break;

		case IDC_EM_OUTLINESPINNER:
			switch (em->selLevel) {
			case SL_VERTEX:
			case SL_EDGE:
				em->EndChamfer (em->ip->GetTime (), HIWORD(wParam));
				break;
			case SL_FACE:
			case SL_POLY:
			case SL_ELEMENT:
				em->EndBevel (em->ip->GetTime(), HIWORD(wParam));
				break;
			}
			em->ip->RedrawViews (em->ip->GetTime(),REDRAW_END);
			break;
		}
		break;

	case CC_SPINNER_CHANGE:
		spin = (ISpinnerControl*)lParam;

		switch (LOWORD(wParam)) {
		case IDC_EM_T_THR_SPIN: em->weldBoxSize = spin->GetIVal(); break;
		case IDC_EM_W_THR_SPIN: weldThresh = spin->GetFVal (); break;
		case IDC_EM_ANGLETHRESHSPIN: explodeThresh = spin->GetFVal (); break;
		case IDC_EM_TENSIONSPINNER: tessTens = spin->GetFVal (); break;

		case IDC_EM_EXTRUDESPINNER:
			bool enterKey;
			enterKey = FALSE;
			if (!HIWORD(wParam) && !em->inExtrude) {
				enterKey = TRUE;
				em->BeginExtrude(em->ip->GetTime());
			}
			em->Extrude (em->ip->GetTime(),spin->GetFVal());
			if (enterKey) {
				em->EndExtrude (em->ip->GetTime(),TRUE);
				em->ip->RedrawViews (em->ip->GetTime(), REDRAW_END);
			} else {
				em->ip->RedrawViews (em->ip->GetTime(),REDRAW_INTERACTIVE);
			}
			break;

		case IDC_EM_OUTLINESPINNER:
			enterKey = FALSE;
			switch (em->selLevel) {
			case SL_VERTEX:
			case SL_EDGE:
				if (!HIWORD(wParam) && !em->inChamfer) {
					enterKey = TRUE;
					em->BeginChamfer (em->ip->GetTime ());
				}
				em->Chamfer (em->ip->GetTime (), spin->GetFVal ());
				if (enterKey) em->EndChamfer (em->ip->GetTime (), TRUE);
				break;

			default:
				if (!HIWORD(wParam) && !em->inBevel) {
					enterKey = TRUE;
					em->BeginBevel (em->ip->GetTime ());
				}
				em->Bevel (em->ip->GetTime (), spin->GetFVal ());
				if (enterKey) em->EndBevel (em->ip->GetTime (), TRUE);
				break;
			}
			if (enterKey) em->ip->RedrawViews (em->ip->GetTime(), REDRAW_END);
			else em->ip->RedrawViews (em->ip->GetTime(),REDRAW_INTERACTIVE);
			break;
		}
		break;

	case WM_COMMAND:
		if (HIWORD(wParam)==1) return FALSE;	// not handling keyboard accelerators here.

		switch (LOWORD(wParam)) {
		case IDC_EM_CREATE: em->ToggleCommandMode (McmCreate); break;

		case IDC_EM_DETACH:
			if (em->selLevel == SL_OBJECT) {
				// Really an attach multiple button.
				MAttachHitByName proc(em);
				em->ip->DoHitByNameDialog(&proc);
			} else em->ButtonOp (MopDetach);
			break;

		case IDC_EM_DIVIDE:
			switch (em->selLevel) {
			case SL_OBJECT: break;
			case SL_VERTEX: em->ButtonOp (MopBreak); break;
			default: em->ToggleCommandMode (McmDivide); break;
			}
			break;

		case IDC_EM_TURN: em->ToggleCommandMode (McmTurnEdge); break;
		case IDC_EM_ALIGNVIEW: em->ButtonOp (MopViewAlign); break;
		case IDC_EM_ALIGNCONST: em->ButtonOp (MopGridAlign); break;
		case IDC_EM_MAKEPLANAR: em->ButtonOp (MopMakePlanar); break;
		case IDC_EM_DELETE: em->ButtonOp (MopDelete); break;
		case IDC_EM_EXTRUDE: em->ToggleCommandMode (McmExtrude); break;

		case IDC_EM_BEVEL:
			switch (em->selLevel) {
			case SL_VERTEX:
			case SL_EDGE:
				em->ToggleCommandMode (McmChamfer);
				break;
			case SL_FACE:
			case SL_POLY:
			case SL_ELEMENT:
				em->ToggleCommandMode (McmBevel);
				break;
			}
			break;

		case IDC_EM_EXTYPE_A:
			em->extType = MESH_EXTRUDE_CLUSTER;
			break;

		case IDC_EM_EXTYPE_B:
			em->extType = MESH_EXTRUDE_LOCAL;
			break;

		case IDC_EM_COLLAPSE: em->ButtonOp (MopCollapse); break;
		case IDC_EM_OBJ_ATTACH: em->ToggleCommandMode (McmAttach); break;
		case IDC_EM_SLICEPLANE: em->ToggleCommandMode (McmSlicePlane); break;
		case IDC_EM_CUT: em->ToggleCommandMode (McmCut); break;
		case IDC_EM_SLICE: em->ButtonOp (MopSlice); break;

		case IDC_EM_REFINE:
			em->cutRefine = IsDlgButtonChecked(hWnd,IDC_EM_REFINE) ? TRUE : FALSE;
			break;

		case IDC_EM_SPLIT:
			em->sliceSplit = IsDlgButtonChecked(hWnd,IDC_EM_SPLIT) ? TRUE : FALSE;
			break;

		case IDC_EM_TESSELLATE: em->ButtonOp (MopTessellate); break;

		case IDC_EM_TES_EDGE:
			edgeTes = TRUE;
			spin = GetISpinner (GetDlgItem (hWnd,IDC_EM_TENSIONSPINNER));
			spin->Enable();
			ReleaseISpinner(spin);
			break;

		case IDC_EM_TES_CENTER:
			edgeTes = FALSE;
			spin = GetISpinner (GetDlgItem (hWnd,IDC_EM_TENSIONSPINNER));
			spin->Disable();
			ReleaseISpinner(spin);
			break;

		case IDC_EM_EXPLODE: em->ButtonOp (MopExplode); break;

		case IDC_EM_EXP_OBJECTS:
			expObj = TRUE;
			break;

		case IDC_EM_EXP_ELEMENTS:
			expObj = FALSE;
			break;

		case IDC_EM_WELD: em->ButtonOp (MopWeld); break;
		case IDC_EM_WELDTOVERT: em->ToggleCommandMode (McmWeldTarget); break;
		case IDC_EM_REMOVE_ISO_VERTS: em->ButtonOp (MopRemoveIsolatedVerts); break;
		case IDC_EM_SELECT_OPEN: em->ButtonOp (MopSelectOpenEdges); break;
		case IDC_EM_CREATE_CURVE: em->ButtonOp (MopCreateShapeFromEdges); break;
		}
		break;

	default:
		return FALSE;
	}
	
	return TRUE;
}

static void SetSmoothButtonState(HWND hWnd,DWORD bits,DWORD invalid,DWORD unused=0) {
	for (int i=IDC_SMOOTH_GRP1; i<IDC_SMOOTH_GRP1+32; i++) {
		if ( (unused&(1<<(i-IDC_SMOOTH_GRP1))) ) {
			ShowWindow(GetDlgItem(hWnd,i),SW_HIDE);
			continue;
		}

		if ( (invalid&(1<<(i-IDC_SMOOTH_GRP1))) ) {
			SetWindowText(GetDlgItem(hWnd,i),NULL);
			SendMessage(GetDlgItem(hWnd,i),CC_COMMAND,CC_CMD_SET_STATE,FALSE);
		} else {
			TSTR buf;
			buf.printf(_T("%d"),i-IDC_SMOOTH_GRP1+1);
			SetWindowText(GetDlgItem(hWnd,i),buf);
			SendMessage(GetDlgItem(hWnd,i),CC_COMMAND,CC_CMD_SET_STATE,
				(bits&(1<<(i-IDC_SMOOTH_GRP1)))?TRUE:FALSE);
		}
		InvalidateRect(GetDlgItem(hWnd,i),NULL,TRUE);
	}
}

static BOOL CALLBACK SelectBySmoothDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static DWORD *param;
	int i;
	ICustButton *iBut;

	switch (msg) {
	case WM_INITDIALOG:
		param = (DWORD*)lParam;
		for (i=IDC_SMOOTH_GRP1; i<IDC_SMOOTH_GRP1+32; i++)
			SendMessage(GetDlgItem(hWnd,i),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
		SetSmoothButtonState(hWnd,param[0],0,param[2]);
		CheckDlgButton(hWnd,IDC_CLEARSELECTION,param[1]);
		CenterWindow(hWnd,GetParent(hWnd));
		break;

	case WM_COMMAND: 
		if (LOWORD(wParam)>=IDC_SMOOTH_GRP1 &&
			LOWORD(wParam)<=IDC_SMOOTH_GRP32) {
			iBut = GetICustButton(GetDlgItem(hWnd,LOWORD(wParam)));				
			int shift = LOWORD(wParam) - IDC_SMOOTH_GRP1;				
			if (iBut->IsChecked()) param[0] |= 1<<shift;
			else param[0] &= ~(1<<shift);
			ReleaseICustButton(iBut);
			break;
		}

		switch (LOWORD(wParam)) {
		case IDOK:
			param[1] = IsDlgButtonChecked(hWnd,IDC_CLEARSELECTION);
			EndDialog(hWnd,1);
			break;

		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;			

	default: return FALSE;
	}
	return TRUE;
}

static BOOL CALLBACK SelectByMatDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static int *param;
	ISpinnerControl *spin;

	switch (msg) {
	case WM_INITDIALOG:
		param = (int*)lParam;
		SetupIntSpinner(hWnd,IDC_MAT_IDSPIN,IDC_MAT_ID,1,MAX_MATID,param[0]);			
		CheckDlgButton(hWnd,IDC_CLEARSELECTION,param[1]);
		CenterWindow(hWnd,GetParent(hWnd));
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			spin = GetISpinner(GetDlgItem(hWnd,IDC_MAT_IDSPIN));
			param[0] = spin->GetIVal();
			param[1] = IsDlgButtonChecked(hWnd,IDC_CLEARSELECTION);
			ReleaseISpinner(spin);
			EndDialog(hWnd,1);					
			break;

		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

void EditMeshMod::InvalidateSurfaceUI() {
	if (!hSurf) return;
	faceUIValid = FALSE;
	InvalidateRect(hSurf,NULL,FALSE);
}

class WeightSpinRestore : public RestoreObj {
public:
	EditMeshMod *eto;

	WeightSpinRestore () { eto = NULL; }
	WeightSpinRestore (EditMeshMod *eo) { eto = eo; }
	void Restore (int isUndo);
	void Redo () { Restore (TRUE); }
	int Size () { return sizeof(eto); }
	TSTR Description() { return _T("Weight Spin Restore"); }
};

void WeightSpinRestore::Restore (int isUndo) {
	if (!eto) return;
	if (!eto->hSurf) return;
	if (!GetDlgItem (eto->hSurf, IDC_EM_WEIGHT_LABEL)) return;
	eto->UpdateWeightDisplay (eto->ip ? eto->ip->GetTime() : 0, eto->hSurf);
}

static int autoEdgeTypeIDs [] = { IDC_EM_AE_SETCLEAR, IDC_EM_AE_SET, IDC_EM_AE_CLEAR };

static BOOL CALLBACK SurfaceDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	EditMeshMod *em = (EditMeshMod*)GetWindowLong(hWnd,GWL_USERDATA);
	ISpinnerControl *spin;
	ICustButton *but;
	IColorSwatch *iCol;
	COLORREF rgb;
	int i;
	bool isFace, isVert;

	switch (msg) {
	case WM_INITDIALOG:
		em = (EditMeshMod*)lParam;
		em->hSurf = hWnd;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);

		if (GetDlgItem (hWnd, IDC_SMOOTH_GRP1)) {	// Face stuff:
			// NOTE: the following requires that the smoothing group ID's be sequential!
			isFace = TRUE;
			for (i=IDC_SMOOTH_GRP1; i<IDC_SMOOTH_GRP1+32; i++)
				SendMessage(GetDlgItem(hWnd,i),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
			SetupIntSpinner(hWnd,IDC_EM_MAT_IDSPIN,IDC_EM_MAT_ID,1,MAX_MATID,0);
			SetupFloatSpinner(hWnd, IDC_EM_SMOOTH_THRESHSPIN,
				IDC_EM_SMOOTH_THRESH, 0.0f, 180.0f, autoSmoothThresh, 0.1f);

			but = GetICustButton(GetDlgItem(hWnd,IDC_EM_NORMAL_FLIPMODE));
			but->SetType(CBT_CHECK);
			but->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(but);

			em->faceUIValid = FALSE;

			CheckDlgButton(hWnd,IDC_EM_NORMAL_SHOW,em->normScale>0.0f);
			if (em->normScale>0.0f) em->ShowNormals();
			SetupFloatSpinner(hWnd,IDC_EM_NORMAL_SCALESPIN,IDC_EM_NORMAL_SCALE,0.0f,999999999.0f,10.0f,0.1f);

			iCol = GetIColorSwatch (GetDlgItem (hWnd, IDC_EM_VERT_COLOR),
				em->GetFaceColor(), GetString (IDS_EM_VERTEXCOLOR));
			ReleaseIColorSwatch (iCol);
		} else {
			isFace = FALSE;
		}

		if (GetDlgItem (hWnd, IDC_EM_VERT_SELRSPIN)) {	// Vertex stuff:
			isVert = TRUE;
			spin = SetupFloatSpinner (hWnd, IDC_EM_WEIGHTSPIN, IDC_EM_WEIGHT, 0.0f, 9999999.0f, 1.0f, .1f);
			spin->SetAutoScale(TRUE);
			em->UpdateWeightDisplay (em->ip->GetTime(), hWnd);
			SetupIntSpinner (hWnd, IDC_EM_VERT_SELRSPIN, IDC_EM_VERT_SELR, 0, 255, selDeltaR);
			SetupIntSpinner (hWnd, IDC_EM_VERT_SELGSPIN, IDC_EM_VERT_SELG, 0, 255, selDeltaG);
			SetupIntSpinner (hWnd, IDC_EM_VERT_SELBSPIN, IDC_EM_VERT_SELB, 0, 255, selDeltaB);
			rgb = RGB(int(selByColor.x*255.0),int(selByColor.y*255.0),int(selByColor.z*255.0));
			iCol = GetIColorSwatch (GetDlgItem(hWnd,IDC_EM_VERT_SELCOLOR), rgb, GetString(IDS_EM_SELBYCOLOR));
			ReleaseIColorSwatch(iCol);
			iCol = GetIColorSwatch (GetDlgItem (hWnd, IDC_EM_VERT_COLOR),
				em->GetVertColor(), GetString (IDS_EM_VERTEXCOLOR));
			ReleaseIColorSwatch (iCol);
		} else {
			isVert = FALSE;
		}

		if (GetDlgItem (hWnd, IDC_EM_ANGLETHRESH)) {	// Edge stuff:
			SetupFloatSpinner (hWnd, IDC_EM_ANGLETHRESHSPIN, IDC_EM_ANGLETHRESH,
				0.f, 180.f, autoEdgeThresh, 0.1f);
			for (i=0; i<3; i++) CheckDlgButton (hWnd, autoEdgeTypeIDs[i], (autoEdgeType == i));
		}
		break;

	case WM_DESTROY:
		em->ShowNormals();
		break;

	case WM_PAINT:
		if (em->faceUIValid) return FALSE;
		if (GetDlgItem (hWnd, IDC_SMOOTH_GRP1)) {
			DWORD invalid, bits;
			bits = em->GetSelSmoothBits(invalid);
			invalid -= bits;
			DWORD mat;
			mat = em->GetMatIndex();
			SetSmoothButtonState(hWnd,bits,invalid);
			spin = GetISpinner(GetDlgItem(hWnd,IDC_EM_MAT_IDSPIN));
			if (mat==UNDEFINED) {
				spin->SetIndeterminate(TRUE);
			} else {
				spin->SetIndeterminate(FALSE);
				spin->SetValue (int(mat+1),FALSE);
			}
			ReleaseISpinner(spin);
		}

		if (iCol = GetIColorSwatch (GetDlgItem(hWnd,IDC_EM_VERT_COLOR),
			(em->selLevel==SL_VERTEX)?em->GetVertColor():em->GetFaceColor(),
			GetString(IDS_EM_VERTEXCOLOR))) {
			ReleaseIColorSwatch(iCol);
			em->UpdateWeightDisplay (em->ip->GetTime (), hWnd);
		}

		em->faceUIValid = TRUE;
		return FALSE;

	case CC_COLOR_BUTTONDOWN:
		theHold.Begin();
		break;

	case CC_COLOR_BUTTONUP:
		if (HIWORD(wParam)) theHold.Accept (GetString (IDS_EM_SETVERTCOLOR));
		else theHold.Cancel();
		break;

	case CC_COLOR_CHANGE:
		iCol = (IColorSwatch*)lParam;
		switch (LOWORD(wParam)) {
		case IDC_EM_VERT_COLOR:
			if (em->selLevel == SL_VERTEX) em->SetVertColor (iCol->GetColor());
			else em->SetFaceColor (iCol->GetColor());
			break;
		case IDC_EM_VERT_SELCOLOR:
			COLORREF rgb = iCol->GetColor();
			selByColor.x = float(GetRValue(rgb))/255.0f;
			selByColor.y = float(GetGValue(rgb))/255.0f;
			selByColor.z = float(GetBValue(rgb))/255.0f;
			break;
		}
		break;

	case CC_SPINNER_BUTTONDOWN:
		switch (LOWORD(wParam)) {
		case IDC_EM_MAT_IDSPIN:
			theHold.Begin();
			break;
		case IDC_EM_WEIGHTSPIN:
			theHold.Begin ();
			break;
		}
		break;

	case WM_CUSTEDIT_ENTER:
	case CC_SPINNER_BUTTONUP:
		switch (LOWORD(wParam)) {
		case IDC_EM_MAT_ID:
		case IDC_EM_MAT_IDSPIN:
			em->ip->RedrawViews(em->ip->GetTime(),REDRAW_END);
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				 theHold.Accept(GetString(IDS_RB_ASSIGNMATID));
			else theHold.Cancel();
			break;

		case IDC_EM_NORMAL_SCALESPIN:
			if (!IsDlgButtonChecked(hWnd,IDC_EM_NORMAL_SHOW)) break;
			em->ip->RedrawViews(em->ip->GetTime(),REDRAW_END);
			break;

		case IDC_EM_WEIGHT:
		case IDC_EM_WEIGHTSPIN:
			em->ip->RedrawViews (em->ip->GetTime(),REDRAW_END);
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				theHold.Accept (GetString(IDS_CHANGEWEIGHT));
			else theHold.Cancel();
			break;
		}
		break;

	case CC_SPINNER_CHANGE:
		spin = (ISpinnerControl*)lParam;
		switch (LOWORD(wParam)) {
		case IDC_EM_MAT_IDSPIN:
			if (!theHold.Holding()) theHold.Begin();
			em->SetMatIndex(spin->GetIVal()-1);
			break;

		case IDC_EM_NORMAL_SCALESPIN: 
			if (!IsDlgButtonChecked(hWnd,IDC_EM_NORMAL_SHOW)) break;
			em->normScale = spin->GetFVal();
			em->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
			em->ip->RedrawViews (em->ip->GetTime(),REDRAW_INTERACTIVE);
			break;

		case IDC_EM_VERT_SELRSPIN: selDeltaR = spin->GetIVal(); break;
		case IDC_EM_VERT_SELGSPIN: selDeltaG = spin->GetIVal(); break;
		case IDC_EM_VERT_SELBSPIN: selDeltaB = spin->GetIVal(); break;
		case IDC_EM_ANGLETHRESHSPIN: autoEdgeThresh = spin->GetFVal(); break;
		case IDC_EM_SMOOTH_THRESHSPIN: autoSmoothThresh = spin->GetFVal(); break;

		case IDC_EM_WEIGHTSPIN:
			if (!theHold.Holding()) theHold.Begin();
			theHold.Put (new WeightSpinRestore (em));
			em->SetWeight (em->ip->GetTime(), spin->GetFVal());
			break;
		}
		break;

	case WM_COMMAND:
		if (HIWORD(wParam)==1) return FALSE;	// not handling keyboard accelerators here.
		if (LOWORD(wParam)>=IDC_SMOOTH_GRP1 &&
			LOWORD(wParam)<=IDC_SMOOTH_GRP32) {
			ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,LOWORD(wParam)));
			int bit = iBut->IsChecked() ? 1 : 0;
			int shift = LOWORD(wParam) - IDC_SMOOTH_GRP1;
			em->SetSelSmoothBits(bit<<shift,1<<shift);
			ReleaseICustButton(iBut);
			break;
		}
		switch (LOWORD(wParam)) {
		case IDC_EM_EDGE_VIS: em->ButtonOp (MopVisibleEdge); break;
		case IDC_EM_EDGE_INVIS: em->ButtonOp (MopInvisibleEdge); break;
		case IDC_EM_EDGE_AUTO: em->ButtonOp (MopAutoEdge); break;

		case IDC_EM_AE_SETCLEAR:
			autoEdgeType = 0;
			break;

		case IDC_EM_AE_SET:
			autoEdgeType = 1;
			break;

		case IDC_EM_AE_CLEAR:
			autoEdgeType = 2;
			break;

		case IDC_EM_NORMAL_SHOW:
			spin = GetISpinner(GetDlgItem(hWnd,IDC_EM_NORMAL_SCALESPIN));
			if (IsDlgButtonChecked(hWnd,IDC_EM_NORMAL_SHOW)) {						
				em->normScale = spin->GetFVal();
				em->ShowNormals();
			} else {
				em->normScale = -1.0f;
				em->ShowNormals();
			}
			ReleaseISpinner(spin);
			break;

		case IDC_EM_NORMAL_FLIP: em->ButtonOp (MopFlipNormal); break;
		case IDC_EM_NORMAL_UNIFY: em->ButtonOp (MopUnifyNormal); break;
		case IDC_EM_NORMAL_FLIPMODE: em->ToggleCommandMode (McmFlipNormalMode); break;

		case IDC_EM_SELECT_BYID:
			if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_EM_SELECTBYMAT),
						em->ip->GetMAXHWnd (), SelectByMatDlgProc, (LPARAM)sbmParams)) {
				if (em->ip) em->SelectByMat(sbmParams[0]-1,sbmParams[1]);
			}
			break;

		case IDC_EM_SELECTBYSMOOTH:
			sbsParams[2] = ~em->GetUsedSmoothBits();
			if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_EM_SELECTBYSMOOTH),
						em->ip->GetMAXHWnd (), SelectBySmoothDlgProc, (LPARAM)sbsParams)) {
				if (em->ip) em->SelectBySmoothGroup(sbsParams[0],(BOOL)sbsParams[1]);
			}
			break;

		case IDC_EM_SMOOTH_CLEAR:
			em->SetSelSmoothBits(0,0xffffffff);
			break;

		case IDC_EM_SMOOTH_AUTO: em->ButtonOp (MopAutoSmooth); break;

		case IDC_EM_VERT_SELBYCOLOR:
			BOOL add, sub;
			add = GetKeyState(VK_CONTROL)<0;
			sub = GetKeyState(VK_MENU)<0;
			em->SelectVertByColor (selByColor,selDeltaR,selDeltaG,selDeltaB,add,sub);
			break;
		}
		break;

	default:
		return FALSE;
	}

	return TRUE;
}

// Following should be _identical_ to that in triedui.cpp; the whole class should be in some core location.
// -sca/1999.03.12
BOOL EMeshShortcutCB::KeyboardShortcut (int id) {
	if (!em) return FALSE;
	if (!em->Editing()) return FALSE;
	int val;

	switch (id) {
	case MDUID_EM_SELTYPE:
		int type;
		switch (em->GetEMeshSelLevel()) {
			case EM_SL_FACE:  type = EM_SL_POLYGON;    break;
			case EM_SL_POLYGON:   type = EM_SL_ELEMENT; break;
			case EM_SL_ELEMENT: type = EM_SL_OBJECT;  break;
			case EM_SL_OBJECT: type = EM_SL_VERTEX; break;
			case EM_SL_VERTEX: type = EM_SL_EDGE; break;
			case EM_SL_EDGE: type = EM_SL_FACE; break;
		}
		em->SetEMeshSelLevel (type);
		break;

	case MDUID_EM_SELTYPE_BACK:
		switch (em->GetEMeshSelLevel()) {
			case EM_SL_FACE:  type = EM_SL_EDGE;    break;
			case EM_SL_POLYGON:   type = EM_SL_FACE; break;
			case EM_SL_ELEMENT: type = EM_SL_POLYGON;  break;
			case EM_SL_VERTEX: type = EM_SL_OBJECT; break;
			case EM_SL_OBJECT: type = EM_SL_ELEMENT; break;
			case EM_SL_EDGE: type = EM_SL_VERTEX; break;
		}
		em->SetEMeshSelLevel (type);
		break;

	case MDUID_EM_SELTYPE_VERTEX:
		em->SetEMeshSelLevel (EM_SL_VERTEX);
		break;

	case MDUID_EM_SELTYPE_EDGE:
		em->SetEMeshSelLevel (EM_SL_EDGE);
		break;

	case MDUID_EM_SELTYPE_FACE:
		em->SetEMeshSelLevel (EM_SL_FACE);
		break;

	case MDUID_EM_SELTYPE_POLYGON:
		em->SetEMeshSelLevel (EM_SL_POLYGON);
		break;

	case MDUID_EM_SELTYPE_ELEMENT:
		em->SetEMeshSelLevel (EM_SL_ELEMENT);
		break;

	case MDUID_EM_SELTYPE_OBJ:
		em->SetEMeshSelLevel (EM_SL_OBJECT);
		break;

	case MDUID_EM_AUTOSMOOTH:
		em->ButtonOp (MopAutoSmooth);
		break;

	case MDUID_EM_ATTACH:
		em->ToggleCommandMode (McmAttach);
		break;

	case MDUID_EM_BREAK:
		em->ButtonOp (MopBreak);
		break;

	case MDUID_EM_IGBACK:
		em->GetUIParam (MuiIgBack, val);
		em->SetUIParam (MuiIgBack, !val);
		break;

	case MDUID_EM_BEVEL:
		if (em->GetEMeshSelLevel() >= EM_SL_FACE) em->ToggleCommandMode (McmBevel);
		else em->ToggleCommandMode (McmChamfer);
		break;

	case MDUID_EM_CREATE:
		em->ToggleCommandMode (McmCreate);
		break;

	case MDUID_EM_CUT:
		em->ToggleCommandMode (McmCut);
		break;

	case MDUID_EM_DIVIDE:
		em->ToggleCommandMode (McmDivide);
		break;

	case MDUID_EM_EXTRUDE:
		em->ToggleCommandMode (McmExtrude);
		break;

	case MDUID_EM_FLIPNORM:
		em->ButtonOp (MopFlipNormal);
		break;

	case MDUID_EM_SS_BACKFACE:
		em->GetUIParam (MuiSSBack, val);
		em->SetUIParam (MuiSSBack, !val);
		break;

	case MDUID_EM_UNIFY_NORMALS:
		em->ButtonOp (MopUnifyNormal);
		break;

	case MDUID_EM_HIDE:
		em->ButtonOp (MopHide);
		break;

	case MDUID_EM_EDGE_INVIS:
		em->ButtonOp (MopInvisibleEdge);
		break;

	case MDUID_EM_IGNORE_INVIS:
		em->GetUIParam (MuiIgnoreVis, val);
		em->SetUIParam (MuiIgnoreVis, !val);
		break;

	case MDUID_EM_COLLAPSE:
		em->ButtonOp (MopCollapse);
		break;

	case MDUID_EM_SHOWNORMAL:
		em->ButtonOp (MopShowNormal);
		break;

	case MDUID_EM_SELOPEN:
		em->ButtonOp (MopSelectOpenEdges);
		break;

	case MDUID_EM_REMOVE_ISO:
		em->ButtonOp (MopRemoveIsolatedVerts);
		break;

	case MDUID_EM_SLICEPLANE:
		em->ToggleCommandMode (McmSlicePlane);
		break;

	case MDUID_EM_SOFTSEL:
		em->GetUIParam (MuiSoftSel, val);
		em->SetUIParam (MuiSoftSel, !val);
		break;

	case MDUID_EM_SLICE:
		em->ButtonOp (MopSlice);
		break;

	case MDUID_EM_DETACH:
		em->ButtonOp (MopDetach);
		break;

	case MDUID_EM_TURNEDGE:
		em->ToggleCommandMode (McmTurnEdge);
		break;

	case MDUID_EM_UNHIDE:
		em->ButtonOp (MopUnhideAll);
		break;

	case MDUID_EM_EDGE_VIS:
		em->ButtonOp (MopVisibleEdge);
		break;

	case MDUID_EM_SELBYVERT:
		em->GetUIParam (MuiSelByVert, val);
		em->SetUIParam (MuiSelByVert, !val);
		break;

	case MDUID_EM_AUTOEDGE:
		em->ButtonOp (MopAutoEdge);
		break;

	case MDUID_EM_WELD:
		em->ButtonOp (MopWeld);
		break;

	case MDUID_EM_EXPLODE:
		em->ButtonOp (MopExplode);
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

//---------------------------------------------------------
//  MeshDeltaUser UI-related methods

void EditMeshMod::GetUIParam (meshUIParam uiCode, float & ret) {
	if (!ip) return;
	if (!Editing()) return;

	switch (uiCode) {
	case MuiPolyThresh:
		ret = planarFaceThresh;
		break;
	case MuiFalloff:
		ret = falloff;
		break;
	case MuiPinch:
		ret = pinch;
		break;
	case MuiBubble:
		ret = bubble;
		break;
	case MuiWeldDist:
		ret = weldThresh;
		break;
	}
}

void EditMeshMod::SetUIParam (meshUIParam uiCode, float val) {
	if (!ip) return;
	if (!Editing()) return;
	ISpinnerControl *spin;

	switch (uiCode) {
	case MuiPolyThresh:
		planarFaceThresh = val;
		if (hSel) {
			spin = GetISpinner (GetDlgItem (hSel, IDC_EM_PLANARSPINNER));
			spin->SetValue (val, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	case MuiFalloff:
		falloff = val;
		InvalidateAffectRegion ();
		if (hAR) {
			spin = GetISpinner (GetDlgItem (hAR, IDC_FALLOFFSPIN));
			spin->SetValue (val, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	case MuiPinch:
		pinch = val;
		InvalidateAffectRegion ();
		if (hAR) {
			spin = GetISpinner (GetDlgItem (hAR, IDC_PINCHSPIN));
			spin->SetValue (val, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	case MuiBubble:
		bubble = val;
		InvalidateAffectRegion ();
		if (hAR) {
			spin = GetISpinner (GetDlgItem (hAR, IDC_BUBBLESPIN));
			spin->SetValue (val, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	case MuiWeldDist:
		weldThresh = val;
		if (hGeom) {
			spin = GetISpinner (GetDlgItem (hGeom, IDC_EM_W_THR_SPIN));
			spin->SetValue (val, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	}
}

void EditMeshMod::GetUIParam (meshUIParam uiCode, int & ret) {
	if (!ip) return;
	if (!Editing()) return;

	switch (uiCode) {
	case MuiSelByVert:
		ret = selByVert;
		break;
	case MuiIgBack:
		ret = ignoreBackfaces;
		break;
	case MuiIgnoreVis:
		ret = ignoreVisEdge;
		break;
	case MuiSoftSel:
		ret = affectRegion;
		break;
	case MuiSSUseEDist:
		ret = useEdgeDist;
		break;
	case MuiSSEDist:
		ret = edgeIts;
		break;
	case MuiSSBack:
		ret = arIgBack;
		break;
	case MuiWeldBoxSize:
		ret = weldBoxSize;
		break;
	case MuiExtrudeType:
		ret = extType;
		break;
	}
}

void EditMeshMod::SetUIParam (meshUIParam uiCode, int val) {
	if (!ip) return;
	if (!Editing()) return;
	ISpinnerControl *spin;

	switch (uiCode) {
	case MuiSelByVert:
		selByVert = val ? TRUE : FALSE;
		if (hSel) CheckDlgButton (hSel, IDC_EM_SEL_BYVERT, selByVert);
		break;
	case MuiIgBack:
		ignoreBackfaces = val ? TRUE : FALSE;
		if (hSel) CheckDlgButton (hSel, IDC_EM_IGNORE_BACKFACES, ignoreBackfaces);
		break;
	case MuiIgnoreVis:
		ignoreVisEdge = val ? TRUE : FALSE;
		if (hSel) CheckDlgButton (hSel, IDC_EM_IGNORE_VISEDGE, ignoreVisEdge);
		break;
	case MuiSoftSel:
		affectRegion = val ? TRUE : FALSE;
		if (hAR) {
			CheckDlgButton (hAR, IDC_EM_AFFECT_REGION, affectRegion);
			SetARDlgEnables ();
		}
		break;
	case MuiSSUseEDist:
		useEdgeDist = val ? TRUE : FALSE;
		if (hAR) {
			CheckDlgButton (hAR, IDC_EM_E_DIST, useEdgeDist);
			spin = GetISpinner (GetDlgItem (hAR, IDC_EM_E_ITER_SPIN));
			spin->Enable (useEdgeDist);
			ReleaseISpinner (spin);
		}
		break;
	case MuiSSEDist:
		edgeIts = val;
		if (hAR) {
			spin = GetISpinner (GetDlgItem (hAR, IDC_EM_E_ITER_SPIN));
			spin->SetValue (edgeIts, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	case MuiSSBack:
		arIgBack = val ? TRUE : FALSE;
		if (hAR) CheckDlgButton (hAR, IDC_EM_AR_BACK, arIgBack);
		break;
	case MuiWeldBoxSize:
		weldBoxSize = val;
		if (hGeom) {
			spin = GetISpinner (GetDlgItem (hGeom, IDC_EM_T_THR_SPIN));
			spin->SetValue (val, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	case MuiExtrudeType:
		extType = val;
		if (hGeom) {
			if (extType == MESH_EXTRUDE_CLUSTER) {
				CheckRadioButton (hGeom, IDC_EM_EXTYPE_A, IDC_EM_EXTYPE_B, IDC_EM_EXTYPE_A);
			} else {
				CheckRadioButton (hGeom, IDC_EM_EXTYPE_A, IDC_EM_EXTYPE_B, IDC_EM_EXTYPE_B);
			}
		}
		break;
	}
}

void EditMeshMod::ToggleCommandMode(meshCommandMode mode) {
	if (!ip) return;
	if (sliceMode && (mode != McmSlicePlane)) ExitSliceMode ();

	switch (mode) {
	case McmCreate:
		switch (selLevel) {
		case SL_EDGE:
		case SL_OBJECT:
			break;
		case SL_VERTEX:
			if (ip->GetCommandMode()==createVertMode)
				ip->SetStdCommandMode(CID_OBJMOVE);
			else ip->SetCommandMode(createVertMode);
			break;
		default:
			if (ip->GetCommandMode()==createFaceMode)
				ip->SetStdCommandMode(CID_OBJMOVE);
			else ip->SetCommandMode (createFaceMode);
			break;
		}
		break;

	case McmAttach:
		ip->SetPickMode (attachPickMode);
		break;

	case McmExtrude:
		if (selLevel < SL_EDGE) break;
		if (ip->GetCommandMode()==extrudeMode) ip->SetStdCommandMode(CID_OBJMOVE);
		else ip->SetCommandMode (extrudeMode);
		break;

	case McmBevel:
		if (selLevel < SL_FACE) break;
		if (ip->GetCommandMode()==bevelMode)
			ip->SetStdCommandMode (CID_OBJMOVE);
		else ip->SetCommandMode (bevelMode);
		break;

	case McmChamfer:
		if ((selLevel == SL_OBJECT) || (selLevel > SL_EDGE)) break;
		if (ip->GetCommandMode()==chamferMode)
			ip->SetStdCommandMode (CID_OBJMOVE);
		else ip->SetCommandMode (chamferMode);
		break;

	case McmSlicePlane:
		if (!selLevel) break;
		if (sliceMode) ExitSliceMode();
		else EnterSliceMode ();
		break;

	case McmCut:
		if (selLevel < SL_EDGE) break;
		if (ip->GetCommandMode()==cutEdgeMode)
			ip->SetStdCommandMode(CID_OBJMOVE);
		else ip->SetCommandMode(cutEdgeMode);
		break;

	case McmWeldTarget:
		if (selLevel != SL_VERTEX) break;
		if (ip->GetCommandMode()==weldVertMode)
			ip->SetStdCommandMode(CID_OBJMOVE);
		else ip->SetCommandMode(weldVertMode);
		break;

	case McmFlipNormalMode:
		if (selLevel < SL_FACE) break;
		if (ip->GetCommandMode()==flipMode)
			ip->SetStdCommandMode(CID_OBJMOVE);
		else ip->SetCommandMode(flipMode);
		break;

	case McmDivide:
		if (selLevel < SL_EDGE) break;
		if (selLevel == SL_EDGE) {
			if (ip->GetCommandMode()==divideEdgeMode)
				ip->SetStdCommandMode(CID_OBJMOVE);
			else ip->SetCommandMode (divideEdgeMode);
		} else {
			if (ip->GetCommandMode()==divideFaceMode)
				ip->SetStdCommandMode(CID_OBJMOVE);
			else ip->SetCommandMode (divideFaceMode);
		}
		break;

	case McmTurnEdge:
		if (selLevel != SL_EDGE) break;
		if (ip->GetCommandMode()==turnEdgeMode)
			ip->SetStdCommandMode(CID_OBJMOVE);
		else ip->SetCommandMode (turnEdgeMode);
		break;
	}
}

void EditMeshMod::ButtonOp (meshButtonOp opcode) {
	ISpinnerControl *spin;
	TSTR name;

	switch (opcode) {
	case MopHide:
		if (selLevel == SL_VERTEX) HideSelectedVerts ();
		else if (selLevel >= SL_FACE) HideSelectedFaces ();
		break;

	case MopUnhideAll:
		if (selLevel == SL_VERTEX) UnhideAllVerts();
		else if (selLevel >= SL_FACE) UnhideAllFaces ();
		break;

	case MopDelete:
		DeleteSelected ();
		break;

	case MopDetach:
		if (selLevel == SL_VERTEX) {
			BOOL elem, asClone;
			TSTR name;
			if (GetDetachObjectName (ip, name, elem, asClone)) {
				Detach (name, FALSE, !asClone, elem);
			}
		}
		if (selLevel >= SL_FACE) {
			BOOL elem, asClone;
			TSTR name;
			if (GetDetachObjectName (ip, name, elem, asClone)) {
				Detach (name, TRUE, !asClone, elem);
			}
		}
		break;

	case MopBreak:
		BreakVerts ();
		break;

	case MopViewAlign:
		AlignTo(ALIGN_VIEW);
		break;

	case MopGridAlign:
		AlignTo(ALIGN_CONST);
		break;

	case MopMakePlanar:
		if (selLevel > SL_OBJECT) MakePlanar ();
		break;

	case MopCollapse:
		if (selLevel > SL_OBJECT) Collapse ();
		break;

	case MopTessellate:
		if (selLevel > SL_EDGE) Tessellate (tessTens/400.0f, edgeTes);
		break;

	case MopExplode:
		if ((selLevel > SL_EDGE) || (selLevel == SL_OBJECT)) {
			if (expObj) {
				name = GetString(IDS_EM_NEWOBJECTNAME);
				if (GetExplodeObjectName (ip->GetMAXHWnd(), name)) {
					Explode (DegToRad(explodeThresh), TRUE, name);
				}
			} else {
				Explode (DegToRad (explodeThresh), FALSE, name);
			}
		}
		break;

	case MopSlice:
		if (sliceMode && selLevel) Slice ();
		break;

	case MopWeld:
		if (selLevel == SL_VERTEX) {
			if (!WeldVerts(weldThresh)) {
				TSTR buf1 = GetString(IDS_RB_NOVERTSTOWELD);
				TSTR buf2 = GetString(IDS_RB_WELDVERTS);
				MessageBox (ip->GetMAXHWnd(), buf1, buf2, MB_OK|MB_TASKMODAL);
			}
		}
		break;

	case MopRemoveIsolatedVerts:
		RemoveIsoVerts ();
		break;

	case MopSelectOpenEdges:
		if (selLevel == SL_EDGE) SelectOpenEdges ();
		break;

	case MopCreateShapeFromEdges:
		if (selLevel != SL_EDGE) break;
		name = GetString(IDS_EM_SHAPE);
		ip->MakeNameUnique (name);
		if (DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_EM_CREATECURVE),
			ip->GetMAXHWnd (), CurveNameDlgProc, (LPARAM)&name)) {
			ModContextList mcList;
			INodeTab nodes;
			ip->GetModContexts (mcList, nodes);
			ClearMeshDataFlag (mcList, EMD_BEENDONE);

			BOOL didSomething = FALSE;
			theHold.Begin();
			for (int nd=0; nd<mcList.Count(); nd++) {
				EditMeshData *emd = (EditMeshData *) mcList[nd]->localData;
				if (!emd || (emd->GetFlag (EMD_BEENDONE))) continue;
				Mesh *m = emd->GetMesh(ip->GetTime());
				AdjEdgeList *ae = emd->TempData(ip->GetTime())->AdjEList();
				if (CreateCurveFromMeshEdges (*m, nodes[nd], ip, ae, name,
					(createCurveType==IDC_EMCURVE_SMOOTH), curveIgnoreHiddenEdges)) didSomething = TRUE;
				emd->SetFlag (EMD_BEENDONE, TRUE);
			}
			theHold.Accept (GetString(IDS_EM_CREATECURVE));
			nodes.DisposeTemporary ();
			if (!didSomething) {
				TSTR buf1 = GetString(IDS_EM_CREATECURVE);
				TSTR buf2 = GetString(IDS_EM_NOEDGESSELECTED);
				MessageBox(ip->GetMAXHWnd(),buf2,buf1,MB_ICONEXCLAMATION|MB_OK);
				break;
			}
		}
		break;

	case MopShowNormal:
		if (!hSurf) break;
		spin = GetISpinner(GetDlgItem(hSurf,IDC_EM_NORMAL_SCALESPIN));
		if (!spin) break;
		if (IsDlgButtonChecked(hSurf, IDC_EM_NORMAL_SHOW)) {
			normScale = -1.0f;
			ShowNormals();
			CheckDlgButton (hSurf, IDC_EM_NORMAL_SHOW, FALSE);
		} else {
			normScale = spin->GetFVal();
			ShowNormals();
			CheckDlgButton (hSurf, IDC_EM_NORMAL_SHOW, TRUE);
		}
		ReleaseISpinner(spin);
		break;

	case MopFlipNormal:
		if (selLevel > SL_EDGE) FlipNormals ();
		break;

	case MopUnifyNormal:
		if (selLevel > SL_EDGE) UnifyNormals ();
		break;

	case MopAutoSmooth:
		if (selLevel > SL_EDGE) AutoSmooth (DegToRad (autoSmoothThresh));
		break;

	case MopVisibleEdge:
		if (selLevel == SL_EDGE) SetEdgeVis (TRUE);
		break;

	case MopInvisibleEdge:
		if (selLevel == SL_EDGE) SetEdgeVis (FALSE);
		break;

	case MopAutoEdge:
		if (selLevel == SL_EDGE) AutoEdge (DegToRad (autoEdgeThresh), autoEdgeType);
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\mapmod.cpp ===
/**********************************************************************
 *<
	FILE: mapmod.cpp

	DESCRIPTION:  A UVW mapping modifier

	CREATED BY: Rolf Berteig

	HISTORY: 10/21/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"
#include "texutil.h"
#include "bmmlib.h"
#include "simpobj.h"
#include "simpmod.h"
#include "decomp.h"
#include "mapping.h"
#include "buildver.h"
#include "surf_api.h"

// mjm - begin - 4.21.99
#define SEL_NONE		 0
#define SEL_NURBS		(1<<0)
#define SEL_OTHERS		(1<<1)
// mjm - end

#define MAP_XYZTOUVW	6

class MapMod : public MappingMod {	
	public:
		IParamBlock *pblock;
				
		static IParamMap *pmapParam;
		static MoveModBoxCMode *moveMode;
		static RotateModBoxCMode *rotMode;
		static UScaleModBoxCMode *uscaleMode;
		static NUScaleModBoxCMode *nuscaleMode;
		static SquashModBoxCMode *squashMode;		
		static FaceAlignMode *faceAlignMode;
		static RegionFitMode *regionFitMode;
		static PickAcquire pickAcquire;
		static MapMod *editMod;

		MapMod(BOOL create);

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) {s=GetString(IDS_RB_MAPMOD);}
		virtual Class_ID ClassID() {return Class_ID(UVWMAPOSM_CLASS_ID,0);}
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);		
		TCHAR *GetObjectName() { return GetString(IDS_RB_UVWMAPPING); }
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		BOOL AssignController(Animatable *control,int subAnim);
		int SubNumToRefNum(int subNum);

		ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO|PART_SELECT|PART_SUBSEL_TYPE|PART_VERTCOLOR;}
		ChannelMask ChannelsChanged() {return TEXMAP_CHANNEL|PART_VERTCOLOR; }		
		Class_ID InputType() {return mapObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);

		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);

		int NumRefs() {return 2;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		int NumSubs() {return 2;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
		
		void ActivateSubobjSel(int level, XFormModes& modes);

        UINT GetModObjTypes(); // mjm - 4.21.99

		// From MappingMod
		void EnterNormalAlign();
		void ExitNormalAlign();
		void EnterRegionFit();
		void ExitRegionFit();
		int GetMapType();
		void SetMapType(int type);
		float GetTile(TimeValue t,int which);
		void SetTile(TimeValue t,int which, float tile);
		BOOL GetFlip(int which);
		void SetFlip(int which,BOOL flip);
		void EnterAcquire();
		void ExitAcquire();
		float GetLength(TimeValue t);
		float GetWidth(TimeValue t);
		float GetHeight(TimeValue t);
		int GetAxis();
		void SetLength(TimeValue t,float v);
		void SetWidth(TimeValue t,float v);
		void SetHeight(TimeValue t,float v);
		void SetAxis(int v);
		int GetFirstParamVer() {return 3;}
		int GetPBlockVersion() {return pblock->GetVersion();}
	};


//--- ClassDescriptor and class vars ---------------------------------

IObjParam*          MappingMod::ip        = NULL;

IParamMap*          MapMod::pmapParam     = NULL;
MoveModBoxCMode*    MapMod::moveMode      = NULL;
RotateModBoxCMode*  MapMod::rotMode       = NULL;
UScaleModBoxCMode*  MapMod::uscaleMode    = NULL;
NUScaleModBoxCMode* MapMod::nuscaleMode   = NULL;
SquashModBoxCMode*  MapMod::squashMode    = NULL;
FaceAlignMode*      MapMod::faceAlignMode = NULL;
RegionFitMode*      MapMod::regionFitMode = NULL;
PickAcquire         MapMod::pickAcquire;
MapMod*             MapMod::editMod       = NULL;

class UVWMapClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) {return new MapMod(!loading);}
	const TCHAR *	ClassName() { return GetString(IDS_RB_UVWMAP_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(UVWMAPOSM_CLASS_ID,0); }
	const TCHAR* 	Category() {return GetString(IDS_RB_DEFSURFACE);}
	};

static UVWMapClassDesc mapDesc;
extern ClassDesc* GetUVWMapModDesc() {return &mapDesc;}

static void DoBoxIcon(BOOL sel,float length, PolyLineProc& lp);

//--- Parameter map/block descriptors -------------------------------

#define PB_MAPTYPE		0
#define PB_UTILE		1
#define PB_VTILE		2
#define PB_WTILE		3
#define PB_UFLIP		4
#define PB_VFLIP		5
#define PB_WFLIP		6
#define PB_CAP			7
#define PB_CHANNEL		8
#define PB_LENGTH		9
#define PB_WIDTH		10
#define PB_HEIGHT		11
#define PB_AXIS			12
#define PB_MAPCHANNEL   13
#define PB_NURBS_SRF    14

//
//
// Parameters



static int mapIDs[]  = {IDC_MAP_PLANAR,IDC_MAP_CYL,IDC_MAP_SPHERE,IDC_MAP_BALL,IDC_MAP_BOX,IDC_MAP_FACE, IDC_MAP_XYZTOUVW};
static int chanIDs[] = {IDC_MAP_TEXMAP, IDC_MAP_VERTCOL};
static int axisIDs[] = {IDC_MAP_X,IDC_MAP_Y,IDC_MAP_Z};

static ParamUIDesc descParam[] = {
	// Map type
	ParamUIDesc(PB_MAPTYPE,TYPE_RADIO,mapIDs,7),
	
	// U Tile
	ParamUIDesc (PB_UTILE, EDITTYPE_FLOAT,
	IDC_MAP_UTILE,IDC_MAP_UTILESPIN,
		-999999999.0f,999999999.0f, 0.01f),

	// V Tile
	ParamUIDesc (PB_VTILE, EDITTYPE_FLOAT,
		IDC_MAP_VTILE,IDC_MAP_VTILESPIN,
		-999999999.0f,999999999.0f, 0.01f),

	// W Tile
	ParamUIDesc (PB_WTILE, EDITTYPE_FLOAT,
		IDC_MAP_WTILE,IDC_MAP_WTILESPIN,
		-999999999.0f,999999999.0f, 0.01f),

	// U Flip
	ParamUIDesc(PB_UFLIP,TYPE_SINGLECHEKBOX,IDC_MAP_UFLIP),

	// V Flip
	ParamUIDesc(PB_VFLIP,TYPE_SINGLECHEKBOX,IDC_MAP_VFLIP),

	// W Flip
	ParamUIDesc(PB_WFLIP,TYPE_SINGLECHEKBOX,IDC_MAP_WFLIP),

	// Cap
	ParamUIDesc(PB_CAP,TYPE_SINGLECHEKBOX,IDC_MAP_CAP),

	// Channel
	ParamUIDesc(PB_CHANNEL,TYPE_RADIO,chanIDs,2),

	// Length
	ParamUIDesc (PB_LENGTH, EDITTYPE_UNIVERSE,
		IDC_MAP_LENGTH,IDC_MAP_LENGTHSPIN,
		-999999999.0f,999999999.0f, SPIN_AUTOSCALE),

	// Width
	ParamUIDesc (PB_WIDTH, EDITTYPE_UNIVERSE,
		IDC_MAP_WIDTH,IDC_MAP_WIDTHSPIN,
		-999999999.0f,999999999.0f, SPIN_AUTOSCALE),

	// Height
	ParamUIDesc (PB_HEIGHT, EDITTYPE_UNIVERSE,
		IDC_MAP_HEIGHT,IDC_MAP_HEIGHTSPIN,
		-999999999.0f, 999999999.0f, SPIN_AUTOSCALE),

	// Axis
	ParamUIDesc(PB_AXIS,TYPE_RADIO,axisIDs,3),

	// Map channel
	ParamUIDesc (PB_MAPCHANNEL, EDITTYPE_POS_INT,
		IDC_MAP_CHAN, IDC_MAP_CHAN_SPIN,
		1, MAX_MESHMAPS-1, SPIN_AUTOSCALE),

	// NURBS Texture Surface
	ParamUIDesc(PB_NURBS_SRF,TYPE_SINGLECHEKBOX, IDC_NURBS_TXT_SRF),

};
#define PARAMDESC_LENGH 15

static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, FALSE, PB_MAPTYPE },
	{ TYPE_FLOAT, NULL, TRUE, PB_UTILE },
	{ TYPE_FLOAT, NULL, TRUE, PB_VTILE },
	{ TYPE_FLOAT, NULL, TRUE, PB_WTILE },
	{ TYPE_INT, NULL, TRUE, PB_UFLIP },
	{ TYPE_INT, NULL, TRUE, PB_VFLIP },
	{ TYPE_INT, NULL, TRUE, PB_WFLIP }
};

static ParamBlockDescID descVer1[] = {
	{ TYPE_INT, NULL, FALSE, PB_MAPTYPE },
	{ TYPE_FLOAT, NULL, TRUE, PB_UTILE },
	{ TYPE_FLOAT, NULL, TRUE, PB_VTILE },
	{ TYPE_FLOAT, NULL, TRUE, PB_WTILE },
	{ TYPE_INT, NULL, FALSE, PB_UFLIP },
	{ TYPE_INT, NULL, FALSE, PB_VFLIP },
	{ TYPE_INT, NULL, FALSE, PB_WFLIP },
	{ TYPE_INT, NULL, FALSE, PB_CAP }
};

static ParamBlockDescID descVer2[] = {
	{ TYPE_INT, NULL, FALSE, PB_MAPTYPE },
	{ TYPE_FLOAT, NULL, TRUE, PB_UTILE },
	{ TYPE_FLOAT, NULL, TRUE, PB_VTILE },
	{ TYPE_FLOAT, NULL, TRUE, PB_WTILE },
	{ TYPE_INT, NULL, FALSE, PB_UFLIP },
	{ TYPE_INT, NULL, FALSE, PB_VFLIP },
	{ TYPE_INT, NULL, FALSE, PB_WFLIP },
	{ TYPE_INT, NULL, FALSE, PB_CAP },
	{ TYPE_INT, NULL, FALSE, PB_CHANNEL }
};

static ParamBlockDescID descVer3[] = {
	{ TYPE_INT, NULL, FALSE, PB_MAPTYPE },
	{ TYPE_FLOAT, NULL, TRUE, PB_UTILE },
	{ TYPE_FLOAT, NULL, TRUE, PB_VTILE },
	{ TYPE_FLOAT, NULL, TRUE, PB_WTILE },
	{ TYPE_INT, NULL, FALSE, PB_UFLIP },
	{ TYPE_INT, NULL, FALSE, PB_VFLIP },
	{ TYPE_INT, NULL, FALSE, PB_WFLIP },
	{ TYPE_INT, NULL, FALSE, PB_CAP },
	{ TYPE_INT, NULL, FALSE, PB_CHANNEL },
	{ TYPE_FLOAT, NULL, TRUE, PB_LENGTH },
	{ TYPE_FLOAT, NULL, TRUE, PB_WIDTH },
	{ TYPE_FLOAT, NULL, TRUE, PB_HEIGHT },
	{ TYPE_INT, NULL, FALSE, PB_AXIS },
};

static ParamBlockDescID descVer4[] = {
	{ TYPE_INT, NULL, FALSE, PB_MAPTYPE },
	{ TYPE_FLOAT, NULL, TRUE, PB_UTILE },
	{ TYPE_FLOAT, NULL, TRUE, PB_VTILE },
	{ TYPE_FLOAT, NULL, TRUE, PB_WTILE },
	{ TYPE_INT, NULL, FALSE, PB_UFLIP },
	{ TYPE_INT, NULL, FALSE, PB_VFLIP },
	{ TYPE_INT, NULL, FALSE, PB_WFLIP },
	{ TYPE_INT, NULL, FALSE, PB_CAP },
	{ TYPE_INT, NULL, FALSE, PB_CHANNEL },
	{ TYPE_FLOAT, NULL, TRUE, PB_LENGTH },
	{ TYPE_FLOAT, NULL, TRUE, PB_WIDTH },
	{ TYPE_FLOAT, NULL, TRUE, PB_HEIGHT },
	{ TYPE_INT, NULL, FALSE, PB_AXIS },
	{ TYPE_INT, NULL, FALSE, PB_MAPCHANNEL },
};

static ParamBlockDescID descVer5[] = {
	{ TYPE_INT, NULL, FALSE, PB_MAPTYPE },
	{ TYPE_FLOAT, NULL, TRUE, PB_UTILE },
	{ TYPE_FLOAT, NULL, TRUE, PB_VTILE },
	{ TYPE_FLOAT, NULL, TRUE, PB_WTILE },
	{ TYPE_INT, NULL, FALSE, PB_UFLIP },
	{ TYPE_INT, NULL, FALSE, PB_VFLIP },
	{ TYPE_INT, NULL, FALSE, PB_WFLIP },
	{ TYPE_INT, NULL, FALSE, PB_CAP },
	{ TYPE_INT, NULL, FALSE, PB_CHANNEL },
	{ TYPE_FLOAT, NULL, TRUE, PB_LENGTH },
	{ TYPE_FLOAT, NULL, TRUE, PB_WIDTH },
	{ TYPE_FLOAT, NULL, TRUE, PB_HEIGHT },
	{ TYPE_INT, NULL, FALSE, PB_AXIS },
	{ TYPE_INT, NULL, FALSE, PB_MAPCHANNEL },
	{ TYPE_INT, NULL, TRUE, PB_NURBS_SRF }
};

#define PBLOCK_LENGTH	15


// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,7,0),
	ParamVersionDesc(descVer1,8,1),	
	ParamVersionDesc(descVer2,9,2),	
	ParamVersionDesc (descVer3, 13, 3),
	ParamVersionDesc (descVer4, 14, 4),
};

#define NUM_OLDVERSIONS	5

// Current version
#define CURRENT_VERSION	5
static ParamVersionDesc curVersion(descVer5,PBLOCK_LENGTH,CURRENT_VERSION);


class mMyEnumProc : public DependentEnumProc 
	{
      public :
      virtual int proc(ReferenceMaker *rmaker); 
      INodeTab Nodes;              
	};

int mMyEnumProc::proc(ReferenceMaker *rmaker) 
	{ 
	if (rmaker->SuperClassID()==BASENODE_CLASS_ID)    
			{
            Nodes.Append(1, (INode **)&rmaker);                 
			}
     return 0;              
	}



//--- MapDlgProc -------------------------------------------------------

void MappingMod::ViewportAlign() {
	ViewExp *vpt = ip->GetActiveViewport();
	if (!vpt) return;

	// Get mod contexts and nodes for this modifier
	ModContextList mcList;
	INodeTab nodeList;
	ip->GetModContexts(mcList,nodeList);

	// Viewport tm
	Matrix3 vtm;
	vpt->GetAffineTM(vtm);
	vtm = Inverse(vtm);

	// Node tm
	Matrix3 ntm = nodeList[0]->GetObjectTM(ip->GetTime());	
	ntm.NoScale();

	// MC tm
	Matrix3 mctm(1);
	if (mcList[0]->tm) mctm = *mcList[0]->tm;

	// Compute the new destination transform for tmCont
	Matrix3 destTM = vtm * Inverse(ntm) * mctm;
	destTM.PreRotateZ(PI);
	switch (GetAxis()) {
		case 0:
			destTM.PreRotateY(-HALFPI);
			break;
		case 1:
			destTM.PreRotateX(HALFPI);
			break;
		}

	// Current val of tmCont
	Matrix3 curTM(1);
	tmControl->GetValue(ip->GetTime(),&curTM,FOREVER,CTRL_RELATIVE);
	Point3 s;
	for (int i=0; i<3; i++) s[i] = Length(curTM.GetRow(i));

	// These types are aligned differently
	if (GetMapType()==MAP_CYLINDRICAL ||
		GetMapType()==MAP_SPHERICAL ||
		GetMapType()==MAP_BALL) {
		destTM.PreRotateX(-HALFPI);
		}

	// Keep position and scale the same	
	destTM.SetTrans(curTM.GetTrans());
	destTM.PreScale(s);	

	// Plug-in the new value
	SetXFormPacket pckt(destTM);
	tmControl->SetValue(ip->GetTime(), &pckt);

	nodeList.DisposeTemporary();
	ip->ReleaseViewport(vpt);
	ip->RedrawViews(ip->GetTime());
	}

static void MatrixFromNormal(Point3& normal, Matrix3& mat)
	{
	Point3 vx;
	vx.z = .0f;
	vx.x = -normal.y;
	vx.y = normal.x;	
	if ( vx.x == .0f && vx.y == .0f ) {
		vx.x = 1.0f;
		}
	mat.SetRow(0,vx);
	mat.SetRow(1,normal^vx);
	mat.SetRow(2,normal);
	mat.SetTrans(Point3(0,0,0));
	mat.NoScale();
	}

void FaceAlignMouseProc::FaceAlignMap(HWND hWnd,IPoint2 m)
	{
	ViewExp *vpt = ip->GetViewport(hWnd);
	if (!vpt) return;

	Ray ray, wray;
	float at;
	TimeValue t = ip->GetTime();	
	GeomObject *obj;
	Point3 norm, pt;
	Interval valid;

	// Get mod contexts and nodes for this modifier
	ModContextList mcList;
	INodeTab nodeList;
	ip->GetModContexts(mcList,nodeList);

	// Calculate a ray from the mouse point
	vpt->MapScreenToWorldRay(float(m.x), float(m.y),wray);

	for (int i=0; i<nodeList.Count(); i++) {
		INode *node = nodeList[i];

		// Get the object from the node
		ObjectState os = node->EvalWorldState(t);
		if (os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID) {
			obj = (GeomObject*)os.obj;
		} else {
			continue;
			}

		// Back transform the ray into object space.		
		Matrix3 obtm  = node->GetObjectTM(t);
		Matrix3 iobtm = Inverse(obtm);
		ray.p   = iobtm * wray.p;
		ray.dir = VectorTransform(iobtm, wray.dir);
	
		// See if we hit the object
		if (obj->IntersectRay(t,ray,at,norm)) {
			// Calculate the hit point
			pt = ray.p + ray.dir * at;
					
			// Get the mod context tm
			Matrix3 tm(1);
			if (mcList[0]->tm) tm = tm * *mcList[0]->tm;
		
			// Transform the point and ray into mod context space
			pt = pt * tm;
			norm = Normalize(VectorTransform(tm,norm));
		
			// Construct the target transformation in mod context space
			Matrix3 destTM;
			MatrixFromNormal(norm,destTM);
			destTM.SetTrans(pt);
			destTM.PreRotateZ(PI);
			switch (mod->GetAxis())
			{
				case 0:
					destTM.PreRotateY(-HALFPI);
					break;
				case 1:
					destTM.PreRotateX(HALFPI);
					break;
			}
			// Our current transformation... gives relative TM
			Matrix3 curTM(1), relTM, id(1);
			mod->tmControl->GetValue(t,&curTM,valid,CTRL_RELATIVE);
			relTM = Inverse(curTM) * destTM;
		
			// Here's the modifications we need to make to get there
			tm.IdentityMatrix();
			tm.SetTrans(curTM.GetTrans());
			AffineParts parts;			
			decomp_affine(relTM,&parts);
			Point3 delta = destTM.GetTrans()-curTM.GetTrans();
			mod->Rotate(t,id,tm,parts.q);
			mod->Move(t,id,id,delta);
			break;
			}
		}

	nodeList.DisposeTemporary();
	ip->ReleaseViewport(vpt);
	}

int FaceAlignMouseProc::proc(HWND hWnd, int msg, int point, int flags, IPoint2 m)
{
	switch (msg)
	{
		case MOUSE_POINT:
			if (point==0) {				
				theHold.Begin();
				ip->RedrawViews(ip->GetTime(),REDRAW_BEGIN);
			} else {
				theHold.Accept(0);
				ip->RedrawViews(ip->GetTime(),REDRAW_END);
				}
			break;

		case MOUSE_MOVE: {
			theHold.Restore();
			FaceAlignMap(hWnd,m);
			ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);			
			break;
			}

		case MOUSE_FREEMOVE:			
			SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
			break;

	// mjm - begin - 5.5.99
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;
	// mjm - end

		case MOUSE_ABORT:
			theHold.Cancel();
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			break;
	}
	return TRUE;
}

void FaceAlignMode::EnterMode()
	{
	mod->EnterNormalAlign();	
	}

void FaceAlignMode::ExitMode()
	{
	mod->ExitNormalAlign();	
	}


void RegionFitMouseProc::RegionFitMap(HWND hWnd,IPoint2 m)
	{
	ViewExp *vpt = ip->GetViewport(hWnd);
	if (!vpt) return;

	// Get mod contexts and nodes for this modifier
	ModContextList mcList;
	INodeTab nodeList;
	ip->GetModContexts(mcList,nodeList);

	// Viewport tm
	Matrix3 vtm;
	vpt->GetAffineTM(vtm);
	vtm = Inverse(vtm);

	// Node tm
	Matrix3 ntm = nodeList[0]->GetObjectTM(ip->GetTime());	
	
	// MC tm
	Matrix3 mctm(1);
	if (mcList[0]->tm) mctm = *mcList[0]->tm;

	// Current val of tmCont.. remove any scale
	Matrix3 ctm(1);
	mod->tmControl->GetValue(ip->GetTime(),&ctm,FOREVER,CTRL_RELATIVE);
	AffineParts parts;
	decomp_affine(ctm, &parts);
	parts.q.MakeMatrix(ctm);
	ctm.Translate(parts.t);
	
	// Compute the inverse world space tm for the gizmo
	Matrix3 iwtm = Inverse(ctm * Inverse(mctm) * ntm);
	
	// Calculate a ray from the two mouse points
	Ray mray, omray;
	float at;
	Point3 p1, p2;
	vpt->MapScreenToWorldRay(float(m.x), float(m.y),mray);
	vpt->MapScreenToWorldRay(float(om.x), float(om.y),omray);
	
	// Back transform the rays into gizmo space
	mray.p    = iwtm * mray.p;
	mray.dir  = VectorTransform(iwtm, mray.dir);
	omray.p   = iwtm * omray.p;
	omray.dir = VectorTransform(iwtm, omray.dir);

	float dir, pnt, odir, opnt;
	switch (mod->GetAxis()) {
		case 0:
			dir = mray.dir.x; odir = omray.dir.x;
			pnt = mray.p.x; opnt = omray.p.x;
			break;
		case 1:
			dir = mray.dir.y; odir = omray.dir.y;
			pnt = mray.p.y; opnt = omray.p.y;
			break;
		case 2:
			dir = mray.dir.z; odir = omray.dir.z;
			pnt = mray.p.z; opnt = omray.p.z;
			break;
		}
#define EPSILON	0.001
	// Make sure we're going to hit
	if (fabs(dir)>EPSILON && fabs(odir)>EPSILON) {
	
		// Compute the point of intersection
		at = -pnt/dir;
		p1 = mray.p + at*mray.dir;
		at = -opnt/odir;
		p2 = omray.p + at*omray.dir;
		
		// Center the map in the region
		ctm.PreTranslate((p1+p2)/2.0f);

		// Compute scale factors and scale
		float sx;
		float sy;
		switch (mod->GetAxis()) {
			case 0:
				sx = (float)fabs(p1.z-p2.z);
				sy = (float)fabs(p1.y-p2.y);
				break;
			case 1:
				sx = (float)fabs(p1.x-p2.x);
				sy = (float)fabs(p1.z-p2.z);
				break;
			case 2:
				sx = (float)fabs(p1.x-p2.x);
				sy = (float)fabs(p1.y-p2.y);
				break;
			}
		
		// Scale params instead of the matrix
		TimeValue t = ip->GetTime();		
		mod->SetWidth(t,sx);
		mod->SetLength(t,sy);		
		/*
		if (sx>0.0f && sy>0.0f) {
			ctm.PreScale(Point3(sx,sy,1.0f));
			}
		*/

		// Plug-in the new value		
		SetXFormPacket pckt(ctm);
		mod->tmControl->SetValue(ip->GetTime(), &pckt);		
		}

	nodeList.DisposeTemporary();
	ip->ReleaseViewport(vpt);
	ip->RedrawViews(ip->GetTime());
	}

int RegionFitMouseProc::proc(HWND hWnd, int msg, int point, int flags, IPoint2 m)
{
	switch (msg)
	{
		case MOUSE_POINT:
			if (point==0) {				
				om = m;
				theHold.Begin();
				ip->RedrawViews(ip->GetTime(),REDRAW_BEGIN);
			} else {
				theHold.Accept(0);
				ip->RedrawViews(ip->GetTime(),REDRAW_END);
				}
			break;

		case MOUSE_MOVE: {
			theHold.Restore();
			RegionFitMap(hWnd,m);
			ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);			
			break;
			}

		case MOUSE_FREEMOVE:			
			SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
			break;

		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_ABORT:
			theHold.Cancel();
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			break;
	}
	return TRUE;
}

void RegionFitMode::EnterMode()
{
	mod->EnterRegionFit();
}

void RegionFitMode::ExitMode()
{
	mod->ExitRegionFit();	
}


//--- PickAcquire -------------------------------------------------------


static BOOL CALLBACK AcquireTypeDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	static int type = IDC_ACQUIRE_REL;

	switch (msg) {
		case WM_INITDIALOG:
			CheckRadioButton(hWnd,IDC_ACQUIRE_REL,IDC_ACQUIRE_ABS,type);
			CenterWindow(hWnd,GetParent(hWnd));
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					if (IsDlgButtonChecked(hWnd,IDC_ACQUIRE_REL)) 
						 type = IDC_ACQUIRE_REL;
					else type = IDC_ACQUIRE_ABS;
					EndDialog(hWnd,type);
					break;

				case IDCANCEL:
					EndDialog(hWnd,-1);
					break;
				}
			break;

		default:
			return FALSE;
		}
	
	return TRUE;
	}

static BOOL GetAcquireType(HWND hWnd,int &type)
	{
	type = DialogBox(
		hInstance,
		MAKEINTRESOURCE(IDD_MAP_ACQUIRE),
		hWnd,
		AcquireTypeDlgProc);
	if (type<0) return FALSE;
	else return TRUE;
	}

MappingMod *PickAcquire::FindFirstMap(ReferenceTarget *ref)
	{
	MappingMod *mod;
	if (mod = GetMappingInterface(ref)) {
		if (!mod->TestAFlag(A_MOD_DISABLED)) return mod;
		}
	
	for (int i=ref->NumRefs()-1; i>=0; i--) {
		ReferenceTarget *cref = ref->GetReference(i);
		if (cref) {
			if (mod = FindFirstMap(cref)) return mod;			
			}
		}
	return NULL;
	}

BOOL PickAcquire::Filter(INode *node)
	{
	MappingMod *amod = FindFirstMap(node->GetObjectRef());
	if (amod!=mod && amod) return TRUE;
	else return FALSE;
	}

BOOL PickAcquire::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{
	INode *node = 
		ip->PickNode(hWnd,m,this);
	return node ? TRUE : FALSE;
	}
	
class PickAcquireSourceMC : public ModContextEnumProc {
	public:
		ModContext *mc;
		PickAcquireSourceMC() {mc = NULL;}
		BOOL proc(ModContext *mc) {
			this->mc = mc;
			return FALSE;
			}
	};

BOOL PickAcquire::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	assert(node);
	MappingMod *amod = FindFirstMap(node->GetObjectRef());
	if (amod) {
		
		// Check for unsupported map types
		if (mod->ClassID()==Class_ID(DISPLACEOSM_CLASS_ID,0) &&
			(amod->GetMapType()!=MAP_PLANAR &&
			 amod->GetMapType()!=MAP_CYLINDRICAL &&
			 amod->GetMapType()!=MAP_SPHERICAL &&
			 amod->GetMapType()!=MAP_BALL)) {

			TSTR buf1 = GetString(IDS_RB_DISPLACE);
			TSTR buf2 = GetString(IDS_RB_UNSUPPORTED_MAP_TYPE);
			MessageBox(ip->GetMAXHWnd(),buf2,buf1,MB_ICONEXCLAMATION|MB_OK);
			
			return TRUE;
			}
		
		int type;
		if (!GetAcquireType(ip->GetMAXHWnd(),type)) return TRUE;

		// Get our node and mod context
		ModContextList mcList;
		INodeTab nodes;
		ip->GetModContexts(mcList,nodes);
		assert(nodes.Count());
		
		// Get the source mod's mod context
		PickAcquireSourceMC pasmc;
		amod->EnumModContexts(&pasmc);
		assert(pasmc.mc);

		// Do it!
		theHold.Begin();
		AcquireMapping(mod,mcList[0],nodes[0],amod,pasmc.mc,node,type);
		
		theHold.Accept(GetString (IDS_MM_ACQ_MAPPING));

		nodes.DisposeTemporary();
		}
	return TRUE;
	}

void PickAcquire::EnterMode(IObjParam *ip)
	{
	mod->EnterAcquire();
	}

void PickAcquire::ExitMode(IObjParam *ip)
	{
	mod->ExitAcquire();
	}

void PickAcquire::AcquireMapping(
		MappingMod *toMod, ModContext *toMC, INode *toNode,
		MappingMod *fromMod, ModContext *fromMC, INode *fromNode,
		int type)
	{
	// Build the mats
	Matrix3 fromNTM(1);
	Matrix3 toNTM(1);
	if (type==IDC_ACQUIRE_ABS) {
		fromNTM = fromNode->GetObjectTM(ip->GetTime());	
		toNTM   = toNode->GetObjectTM(ip->GetTime());	
		}
	Matrix3 fromTM  = fromMod->CompMatrix(ip->GetTime(),fromMC,&fromNTM,FALSE,type==IDC_ACQUIRE_ABS);
	Matrix3 destTM  = fromTM * Inverse(toNTM);
	if (toMC->tm) destTM = destTM * (*toMC->tm);
	
	if (type==IDC_ACQUIRE_ABS && toMod->TestAFlag(A_PLUGIN1)) {
		switch (toMod->GetMapType()) {
			case MAP_BOX:
			case MAP_PLANAR:
				destTM.PreRotateZ(-PI);
				break;
			
			case MAP_BALL:
			case MAP_SPHERICAL:
			case MAP_CYLINDRICAL:
				destTM.PreRotateZ(-HALFPI);
				break;
			}		
		}

	// Set the TM
	SetXFormPacket pckt(destTM);
	toMod->tmControl->SetValue(ip->GetTime(),&pckt);
	toMod->SetMapType(fromMod->GetMapType());
	TimeValue t = ip->GetTime();
	for (int i=0; i<3; i++) {
		toMod->SetTile(t, i, fromMod->GetTile(t,i));
		toMod->SetFlip(i, fromMod->GetFlip(i));
		}	
	
	// Copy length/width/height
	toMod->SetLength(t,fromMod->GetLength(t));
	toMod->SetWidth(t,fromMod->GetWidth(t));
	toMod->SetHeight(t,fromMod->GetHeight(t));
	if (type!=IDC_ACQUIRE_ABS) {
		toMod->SetAxis(fromMod->GetAxis());
	} else {
		toMod->SetAxis(2);
		}

	ip->RedrawViews(ip->GetTime());
	}


//--- MapDlgProc -----------------------------------------------------

class MapDlgProc : public ParamMapUserDlgProc {
	public:
		ISpinnerControl *iLengthSpin, *iWidthSpin, *iHeightSpin, *iMapChanSpin;	// mjm - 2.12.99
		MapMod *mod;
		UINT modObjTypes;
		
		MapDlgProc(MapMod *m) { mod = m; modObjTypes = SEL_NONE; }		
		void EnableMappingSubCtrls(HWND hWnd);	// mjm - 2.12.99
		void EnableChannelSubCtrls(HWND hWnd);	// mjm - 2.12.99
		void EnableNURBSButton(HWND hWnd, UINT modObjTypes);	// mjm - 4.21.99
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
		void DoBitmapFit(HWND hWnd);
	};

void MapDlgProc::DoBitmapFit(HWND hWnd)
	{
	BitmapInfo bi;
	TheManager->SelectFileInputEx(
		&bi, hWnd, GetString(IDS_RB_SELECTIMAGE));
	if (bi.Name()[0]) {		
		TheManager->GetImageInfo(&bi);
		mod->aspect = bi.Aspect() * float(bi.Width())/float(bi.Height());
		mod->flags |= CONTROL_ASPECT|CONTROL_HOLD;
		mod->NotifyDependents(FOREVER,PART_TEXMAP,REFMSG_CHANGE);
		}
	}

// mjm - begin - 2.12.99
void MapDlgProc::EnableMappingSubCtrls(HWND hWnd)
{
	BOOL lengthState(TRUE), widthState(TRUE), heightState(TRUE), flipState(TRUE), capState(FALSE);
	int type = mod->GetMapType();
	switch (type)
	{
		case MAP_CYLINDRICAL:
			capState = TRUE;
			break;
		case MAP_XYZTOUVW:
			flipState = FALSE;
		case MAP_FACE:
			lengthState = widthState = FALSE;
			// fall through
		case MAP_PLANAR:
			heightState = FALSE;
			break;
		case MAP_SPHERICAL:
		case MAP_BALL:
		case MAP_BOX:
			break;
	}
	iLengthSpin->Enable(lengthState);
	iWidthSpin->Enable(widthState);
	iHeightSpin->Enable(heightState);
    EnableWindow(GetDlgItem(hWnd, IDC_MAP_CAP),   capState);
    EnableWindow(GetDlgItem(hWnd, IDC_MAP_UFLIP), flipState);
    EnableWindow(GetDlgItem(hWnd, IDC_MAP_VFLIP), flipState);
    EnableWindow(GetDlgItem(hWnd, IDC_MAP_WFLIP), flipState);
}

void MapDlgProc::EnableNURBSButton(HWND hWnd, UINT modObjTypes)
{
    BOOL isPlanar = IsDlgButtonChecked(hWnd, IDC_MAP_PLANAR);
    EnableWindow(GetDlgItem(hWnd, IDC_NURBS_TXT_SRF), isPlanar && !(modObjTypes & SEL_OTHERS));

    BOOL useTexSurf = IsDlgButtonChecked(hWnd, IDC_NURBS_TXT_SRF);
    EnableWindow(GetDlgItem(hWnd, IDC_MAP_SPHERE),   !useTexSurf);
    EnableWindow(GetDlgItem(hWnd, IDC_MAP_BALL),     !useTexSurf);
    EnableWindow(GetDlgItem(hWnd, IDC_MAP_CYL),      !useTexSurf);
    EnableWindow(GetDlgItem(hWnd, IDC_MAP_BOX),      !useTexSurf);
    EnableWindow(GetDlgItem(hWnd, IDC_MAP_FACE),     !useTexSurf);
}

void MapDlgProc::EnableChannelSubCtrls(HWND hWnd)
{
	BOOL mapChanState = ( IsDlgButtonChecked(hWnd, IDC_MAP_TEXMAP) == BST_CHECKED );
	iMapChanSpin->Enable(mapChanState);
}
// mjm - end

BOOL MapDlgProc::DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{
	switch (msg) {
		case WM_INITDIALOG:

// mjm - begin - 2.12.99
			iLengthSpin = GetISpinner( GetDlgItem(hWnd, IDC_MAP_LENGTHSPIN) );
			iWidthSpin = GetISpinner( GetDlgItem(hWnd, IDC_MAP_WIDTHSPIN) );
			iHeightSpin = GetISpinner( GetDlgItem(hWnd, IDC_MAP_HEIGHTSPIN) );
			iMapChanSpin = GetISpinner( GetDlgItem(hWnd, IDC_MAP_CHAN_SPIN) );
// mjm - end
			SendMessage(GetDlgItem(hWnd,IDC_MAP_FITREGION),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
			SendMessage(GetDlgItem(hWnd,IDC_MAP_FITREGION),CC_COMMAND,CC_CMD_HILITE_COLOR,GREEN_WASH);
			SendMessage(GetDlgItem(hWnd,IDC_MAP_NORMALALIGN),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
			SendMessage(GetDlgItem(hWnd,IDC_MAP_NORMALALIGN),CC_COMMAND,CC_CMD_HILITE_COLOR,GREEN_WASH);
			SendMessage(GetDlgItem(hWnd,IDC_MAP_ACQUIRE),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
			SendMessage(GetDlgItem(hWnd,IDC_MAP_ACQUIRE),CC_COMMAND,CC_CMD_HILITE_COLOR,GREEN_WASH);

// mjm - begin - 4.21.99
			// if an instance of this modifier is applied to both nurbs and non-nurbs objects,
			// then neither XYZtoYVW nor the Use Texture Surface options will be available
			// (kind of a least common denominator type thing)
			modObjTypes = mod->GetModObjTypes();
            EnableWindow(GetDlgItem(hWnd, IDC_MAP_XYZTOUVW), !(modObjTypes & SEL_NURBS));
            EnableNURBSButton(hWnd, modObjTypes);
// mjm - end
			EnableMappingSubCtrls(hWnd); // mjm - 2.12.99
			EnableChannelSubCtrls(hWnd); // mjm - 2.12.99
			break;

// mjm - begin - 2.12.99
		case WM_DESTROY:
			ReleaseISpinner(iLengthSpin);
			ReleaseISpinner(iWidthSpin);
			ReleaseISpinner(iHeightSpin);
			ReleaseISpinner(iMapChanSpin);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {

				case IDC_MAP_SPHERE:
				case IDC_MAP_BALL:
					mod->flags |= CONTROL_UNIFORM|CONTROL_HOLD;
					mod->NotifyDependents(FOREVER,PART_TEXMAP,REFMSG_CHANGE);
					// fall through

				case IDC_MAP_PLANAR:
				case IDC_MAP_CYL:
				case IDC_MAP_BOX:
				case IDC_MAP_FACE:
				case IDC_MAP_XYZTOUVW:
				case IDC_NURBS_TXT_SRF:
					// moved handling to NotifyRefChanged() to support changes via MaxScript // mjm - 6.1.99
//					EnableMappingSubCtrls(hWnd);
//					EnableNURBSButton(hWnd, modObjTypes); // mjm - 4.21.99
					break;

				case IDC_MAP_TEXMAP:
				case IDC_MAP_VERTCOL:
					// moved handling to NotifyRefChanged() to support changes via MaxScript // mjm - 6.1.99
//					EnableChannelSubCtrls(hWnd);
					break;
// mjm - end

				case IDC_MAP_FIT:
					mod->flags |= CONTROL_FIT|CONTROL_HOLD;
					mod->NotifyDependents(FOREVER,PART_TEXMAP,REFMSG_CHANGE);
					break;

				case IDC_MAP_CENTER:
					mod->flags |= CONTROL_CENTER|CONTROL_HOLD;
					mod->NotifyDependents(FOREVER,PART_TEXMAP,REFMSG_CHANGE);
					break;

				case IDC_MAP_BITMAPFIT:
					DoBitmapFit(hWnd);
					break;
				
				case IDC_MAP_ACQUIRE:
					mod->ip->SetPickMode(&mod->pickAcquire);					
					break;

				case IDC_MAP_NORMALALIGN:
					if (mod->ip->GetCommandMode()->ID()==CID_FACEALIGNMAP) {
						mod->ip->SetStdCommandMode(CID_OBJMOVE);
					} else {
						mod->ip->SetCommandMode(mod->faceAlignMode);
						}
					break;

				case IDC_MAP_RESET:
					theHold.Begin();
					mod->ReplaceReference(TM_REF,NULL);
					mod->flags |= CONTROL_FIT|CONTROL_CENTER|CONTROL_INIT;					
					mod->NotifyDependents(FOREVER,PART_TEXMAP,REFMSG_CHANGE);
					mod->ip->RedrawViews(mod->ip->GetTime());
					theHold.Accept(0);
					break;

				case IDC_MAP_VIEWALIGN:
					theHold.Begin();
					mod->ViewportAlign();
					theHold.Accept(0);
					break;

				case IDC_MAP_FITREGION:
					if (mod->ip->GetCommandMode()->ID()==CID_REGIONFIT) {
						mod->ip->SetStdCommandMode(CID_OBJMOVE);
					} else {
						mod->ip->SetCommandMode(mod->regionFitMode);
						}
					break;
				}
			break;
		}
	return FALSE;
	}



//--- MapMod methods ---------------------------------------------------


MapMod::MapMod(BOOL create)
	{
	SetAFlag(A_PLUGIN1);
	if (create) flags = CONTROL_CENTER|CONTROL_FIT|CONTROL_INIT;
	else flags = 0;

	MakeRefByID(FOREVER, PBLOCK_REF, 
		CreateParameterBlock(descVer5, PBLOCK_LENGTH, CURRENT_VERSION));	
	tmControl = NULL;
	mLocalSetValue = true; // mjm - 6.7.99
	pblock->SetValue(PB_UTILE,0,1.0f);
	pblock->SetValue(PB_VTILE,0,1.0f);
	pblock->SetValue(PB_WTILE,0,1.0f);
	pblock->SetValue(PB_WIDTH,0,1.0f);
	pblock->SetValue(PB_LENGTH,0,1.0f);
	pblock->SetValue(PB_HEIGHT,0,1.0f);
	pblock->SetValue(PB_AXIS,0,2);
	pblock->SetValue (PB_MAPCHANNEL, 0, 1);
	mLocalSetValue = false; // mjm - 6.7.99
}

#define NEWMAP_CHUNKID	0x0100

// Following is necessary to make sure mapchannel doesn't come in as zero;
// this happens when loading up an old scene -- the pblock with the defaults
// is overwritten.
class SetChannelToOne : public PostLoadCallback {
public:
	MapMod *mm;
	SetChannelToOne (MapMod *mapMod) { mm = mapMod; }
	void proc (ILoad *iload) {
		if (mm && mm->pblock) {
			int mapChan;
			mm->pblock->GetValue (PB_MAPCHANNEL, 0, mapChan, FOREVER);
			if (!mapChan) mm->pblock->SetValue (PB_MAPCHANNEL, 0, 1);
		}
		delete this;
	}
};

IOResult MapMod::Load(ILoad *iload) {
	Modifier::Load(iload);

	ClearAFlag(A_PLUGIN1);

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {	
			case NEWMAP_CHUNKID:
				SetAFlag(A_PLUGIN1);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	iload->RegisterPostLoadCallback(
		new FixDimsPLCB(this));

	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,PBLOCK_REF));
	iload->RegisterPostLoadCallback (new SetChannelToOne(this));
		
	return IO_OK;
	}

IOResult MapMod::Save(ISave *isave)
	{
	Modifier::Save(isave);
	if (TestAFlag(A_PLUGIN1)) {
		isave->BeginChunk(NEWMAP_CHUNKID);
		isave->EndChunk();
		}
 	return IO_OK;
	}

void MapMod::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev)
{
	this->ip = ip;
	editMod  = this;

	// Add our sub object type
	TSTR type1( GetString(IDS_RB_APPARATUS));
	const TCHAR *ptype[] = {type1};
	ip->RegisterSubObjectTypes(ptype, 1);

	// Create sub object editing modes.
	moveMode      = new MoveModBoxCMode(this,ip);
	rotMode       = new RotateModBoxCMode(this,ip);
	uscaleMode    = new UScaleModBoxCMode(this,ip);
	nuscaleMode   = new NUScaleModBoxCMode(this,ip);
	squashMode    = new SquashModBoxCMode(this,ip);	
	faceAlignMode = new FaceAlignMode(this,ip);
	regionFitMode = new RegionFitMode(this,ip);

	pickAcquire.mod = this;
	pickAcquire.ip  = ip;

	pmapParam = CreateCPParamMap (descParam,PARAMDESC_LENGH,
		pblock, ip, hInstance, MAKEINTRESOURCE(IDD_UVWMAPPARAM),
		GetString(IDS_RB_PARAMETERS), 0);		 	
	pmapParam->SetUserDlgProc(new MapDlgProc(this));

 	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);
}

void MapMod::EndEditParams(IObjParam *ip, ULONG flags,Animatable *next)
	{	
	this->ip = NULL;
	editMod  = NULL;

	TimeValue t = ip->GetTime();
	ClearAFlag(A_MOD_BEING_EDITED);
 	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);

	ip->ClearPickMode();
	pickAcquire.mod = NULL;
	pickAcquire.ip  = NULL;	

	ip->DeleteMode(moveMode);
	ip->DeleteMode(rotMode);
	ip->DeleteMode(uscaleMode);
	ip->DeleteMode(nuscaleMode);
	ip->DeleteMode(squashMode);	
	ip->DeleteMode(faceAlignMode);
	ip->DeleteMode(regionFitMode);
	delete moveMode; moveMode = NULL;
	delete rotMode; rotMode = NULL;
	delete uscaleMode; uscaleMode = NULL;
	delete nuscaleMode; nuscaleMode = NULL;
	delete squashMode; squashMode = NULL;
	delete faceAlignMode; faceAlignMode = NULL;
	delete regionFitMode; regionFitMode = NULL;

	DestroyCPParamMap(pmapParam);
	pmapParam = NULL; // mjm - 6.6.99
	}

void MapMod::EnterNormalAlign()
	{	
	SendMessage(GetDlgItem(pmapParam->GetHWnd(),IDC_MAP_NORMALALIGN),CC_COMMAND,CC_CMD_SET_STATE,1);
	}

void MapMod::ExitNormalAlign()
	{	
	SendMessage(GetDlgItem(pmapParam->GetHWnd(),IDC_MAP_NORMALALIGN),CC_COMMAND,CC_CMD_SET_STATE,0);
	}

void MapMod::EnterRegionFit()
	{
	SendMessage(GetDlgItem(pmapParam->GetHWnd(),IDC_MAP_FITREGION),CC_COMMAND,CC_CMD_SET_STATE,1);
	}

void MapMod::ExitRegionFit()
	{
	SendMessage(GetDlgItem(pmapParam->GetHWnd(),IDC_MAP_FITREGION),CC_COMMAND,CC_CMD_SET_STATE,0);
	}

void MapMod::EnterAcquire()
	{
	SendMessage(GetDlgItem(pmapParam->GetHWnd(),IDC_MAP_ACQUIRE),CC_COMMAND,CC_CMD_SET_STATE,1);
	}

void MapMod::ExitAcquire()
	{
	SendMessage(GetDlgItem(pmapParam->GetHWnd(),IDC_MAP_ACQUIRE),CC_COMMAND,CC_CMD_SET_STATE,0);
	}

float MapMod::GetLength(TimeValue t)
	{
	float f;
	pblock->GetValue(PB_LENGTH,t,f,FOREVER);
	return f;
	}

float MapMod::GetWidth(TimeValue t)
	{
	float f;
	pblock->GetValue(PB_WIDTH,t,f,FOREVER);
	return f;
	}

float MapMod::GetHeight(TimeValue t)
	{
	float f;
	pblock->GetValue(PB_HEIGHT,t,f,FOREVER);
	return f;
	}

int MapMod::GetAxis()
	{
	int a;
	pblock->GetValue(PB_AXIS,0,a,FOREVER);
	return a;
	}

void MapMod::SetLength(TimeValue t,float v)
	{
	pblock->SetValue(PB_LENGTH,t,v);
	}

void MapMod::SetWidth(TimeValue t,float v)
	{
	pblock->SetValue(PB_WIDTH,t,v);
	}

void MapMod::SetHeight(TimeValue t,float v)
	{
	pblock->SetValue(PB_HEIGHT,t,v);
	}

void MapMod::SetAxis(int v)
	{
	pblock->SetValue(PB_AXIS,0,v);
	}

int MapMod::GetMapType()
	{
	int type;
	pblock->GetValue(PB_MAPTYPE,0,type,FOREVER);
	return type;
	}

void MapMod::SetMapType(int type)
	{
	pblock->SetValue(PB_MAPTYPE,0,type);
	if (pmapParam) pmapParam->Invalidate();
	}

float MapMod::GetTile(TimeValue t,int which)
	{
	float tile;
	pblock->GetValue(PB_UTILE+which,t,tile,FOREVER);
	return tile;
	}

void MapMod::SetTile(TimeValue t,int which, float tile)
	{
	pblock->SetValue(PB_UTILE+which,t,tile);
	if (pmapParam) pmapParam->Invalidate();
	}

BOOL MapMod::GetFlip(int which)
	{
	int flip;
	pblock->GetValue(PB_UFLIP+which,0,flip,FOREVER);
	return flip;
	}

void MapMod::SetFlip(int which,BOOL flip)
	{
	pblock->SetValue(PB_UFLIP+which,0,flip);
	if (pmapParam) pmapParam->Invalidate();
	}

Interval MapMod::LocalValidity(TimeValue t)
	{	
	int i;
	float f;
	Interval valid = FOREVER;
	pblock->GetValue(PB_MAPTYPE,t,i,valid);		
	pblock->GetValue(PB_UTILE,t,f,valid);
	pblock->GetValue(PB_VTILE,t,f,valid);
	pblock->GetValue(PB_WTILE,t,f,valid);
	pblock->GetValue(PB_UFLIP,t,i,valid);
	pblock->GetValue(PB_VFLIP,t,i,valid);
	pblock->GetValue(PB_WFLIP,t,i,valid);
	pblock->GetValue(PB_LENGTH,t,f,valid);
	pblock->GetValue(PB_WIDTH,t,f,valid);
	pblock->GetValue(PB_HEIGHT,t,f,valid);
	pblock->GetValue(PB_AXIS,t,i,valid);
	if (tmControl) {
		Matrix3 tm(1);
		tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);
		}
	return valid;
	}

// mjm - begin - 4.21.99
class ModObjEnumProc : public DependentEnumProc
{
private:
	INodeTab m_nodes;

public:
	const INodeTab& GetNodes() { return m_nodes; }
	virtual int proc(ReferenceMaker *rmaker);
};

int ModObjEnumProc::proc(ReferenceMaker *rmaker)
{ 
	if (rmaker->SuperClassID()==BASENODE_CLASS_ID)
		m_nodes.Append(1, (INode **)&rmaker);
	return 0;
}

UINT MapMod::GetModObjTypes()
{
	ModObjEnumProc dep;
	EnumDependents(&dep);

	UINT type = SEL_NONE;
	for (int i = 0; i < dep.GetNodes().Count(); i++)
	{
        ObjectState os = dep.GetNodes()[i]->EvalWorldState(ip->GetTime());
        if (os.obj->ClassID() == EDITABLE_SURF_CLASS_ID)
            type |= SEL_NURBS;
		else
            type |= SEL_OTHERS;
    }

    return type;
}
// mjm - end

RefTargetHandle MapMod::Clone(RemapDir& remap) 
	{
	MapMod* newmod = new MapMod(FALSE);	
	if (TestAFlag(A_PLUGIN1)) 
		 newmod->SetAFlag(A_PLUGIN1);
	else newmod->ClearAFlag(A_PLUGIN1); 
	newmod->ReplaceReference(PBLOCK_REF,pblock->Clone(remap));	
	if (tmControl) {
		newmod->ReplaceReference(TM_REF,tmControl->Clone(remap));
		}
	return newmod;
	}

BOOL MapMod::AssignController(Animatable *control,int subAnim)
	{
	if (subAnim==TM_REF) {
		ReplaceReference(TM_REF,(ReferenceTarget*)control);
		NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
		NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		return TRUE;
	} else {
		return FALSE;
		}
	}

int MapMod::SubNumToRefNum(int subNum)
	{
	if (subNum==TM_REF)
		 return TM_REF;
	else return -1;
	}

RefTargetHandle MapMod::GetReference(int i)
	{
	switch (i) {
		case TM_REF: 		return tmControl;
		case PBLOCK_REF:	return pblock;
		default: 			return NULL;
		}
	}

void MapMod::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case TM_REF: 		tmControl = (Control*)rtarg; break;
		case PBLOCK_REF:	pblock = (IParamBlock*)rtarg; break;
		}
	}

Animatable* MapMod::SubAnim(int i)
	{
	switch (i) {
		case TM_REF: 		return tmControl;
		case PBLOCK_REF:	return pblock;
		default: 			return NULL;   
		}
	}

TSTR MapMod::SubAnimName(int i)
	{
	switch (i) {
		case TM_REF: 		return GetString(IDS_RB_GIZMO);
		case PBLOCK_REF:	return GetString(IDS_RB_PARAMETERS);
		default: 			return TSTR(_T(""));
		}
	}

RefResult MapMod::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) 
{
	switch (message)
	{
		case REFMSG_CHANGE:
		{
// mjm - begin - 6.1.99 - accomodating maxscript
			if (hTarget == pblock) // mjm - 6.6.99 - duh ...
			{
				int pid = pblock->LastNotifyParamNum();
				if (editMod==this && pmapParam)
				{
					// if ui is up, adjust related ui controls
					// moved here from dlgproc to accomodate maxscript
					switch ( pid )
					{
						MapDlgProc *proc;
						case PB_CHANNEL:
							if ( proc = (MapDlgProc*)pmapParam->GetUserDlgProc() )
								proc->EnableChannelSubCtrls( pmapParam->GetHWnd() );
							break;
						case PB_MAPTYPE:
						case PB_NURBS_SRF:
							if ( proc = (MapDlgProc*)pmapParam->GetUserDlgProc() )
							{
								proc->EnableMappingSubCtrls( pmapParam->GetHWnd() );
								proc->EnableNURBSButton( pmapParam->GetHWnd(), GetModObjTypes() );
							}
							break;
					}
					pmapParam->Invalidate();
				}
				else if (
					( flags == (CONTROL_CENTER|CONTROL_FIT|CONTROL_INIT) ) &&
					( pid == PB_LENGTH || pid == PB_WIDTH || pid == PB_HEIGHT ) &&
					( !mLocalSetValue ) // mjm - 6.7.99
					)
				{
					// temp fix for maxscript ... overrides default fitting of gizmo on first instance of modifier evaluation
					// flags are set to CONTROL_CENTER|CONTROL_FIT|CONTROL_INIT in constructor and evaluated in InitControl(). If CONTROL_FIT is set
					// the gizmo is sized to the bounding box and will overwrite values l,w,h previously set through maxscript. This code sees if
					// a l,w, or h has been explicitly set outside of modify panel. If so, it disables default bounding box fitting.
					flags &= ~CONTROL_FIT;
				}
			}
			break;
// mjm - end
		}

		case REFMSG_GET_PARAM_DIM:
		{
			GetParamDim *gpd = (GetParamDim*)partID;			
			switch (gpd->index)
			{
				case PB_LENGTH:
				case PB_WIDTH:
				case PB_HEIGHT:
					gpd->dim = stdWorldDim;
					break;
				default:
					gpd->dim = defaultDim;
					break;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME:
		{
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index)
			{				
				case PB_UTILE:
					gpn->name = GetString(IDS_RB_UTILE);
					break;
				case PB_VTILE:
					gpn->name = GetString(IDS_RB_VTILE);
					break;
				case PB_WTILE:
					gpn->name = GetString(IDS_RB_WTILE);
					break;
				case PB_LENGTH:
					gpn->name = GetString(IDS_RB_LENGTH);
					break;
				case PB_WIDTH:
					gpn->name = GetString(IDS_RB_WIDTH);
					break;
				case PB_HEIGHT:
					gpn->name = GetString(IDS_RB_HEIGHT);
					break;
				default:
					gpn->name = TSTR(_T(""));
					break;
			}
			return REF_STOP;
		}
	}
	return REF_SUCCEED;
}
	

void MapMod::ActivateSubobjSel(int level, XFormModes& modes )
{
	switch (level)
	{
		case 1: // Modifier box
			modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,NULL);
			break;
	}
	NotifyDependents(FOREVER,PART_DISPLAY,REFMSG_CHANGE);
}


// --- Modify Object ---------------------------------------------------


void MapMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	// If it's not a mappable object then we can't help
	Object *obj = os->obj;
	if (!obj->IsMappable()) return;

	// Get pblock values	
	int type, uflip, vflip, wflip, cap, channel, mapChannel;
	float utile, vtile, wtile;
    int nurbsTxtSrf;
	pblock->GetValue(PB_MAPTYPE,t,type,FOREVER);
	pblock->GetValue(PB_UTILE,t,utile,FOREVER);
	pblock->GetValue(PB_VTILE,t,vtile,FOREVER);
	pblock->GetValue(PB_WTILE,t,wtile,FOREVER);
	pblock->GetValue(PB_UFLIP,t,uflip,FOREVER);
	pblock->GetValue(PB_VFLIP,t,vflip,FOREVER);
	pblock->GetValue(PB_WFLIP,t,wflip,FOREVER);
	pblock->GetValue(PB_CAP,t,cap,FOREVER);
	pblock->GetValue(PB_CHANNEL,t,channel,FOREVER);
	pblock->GetValue (PB_MAPCHANNEL, t, mapChannel, FOREVER);
	pblock->GetValue (PB_NURBS_SRF, t, nurbsTxtSrf, FOREVER);
	
	mapChannel = channel ? 0 : mapChannel;

	// If object can't handle this map channel, we're done:
	if (obj->NumMapChannels() <= mapChannel) return;

	// Prepare the controller and set up mats
	if (!tmControl || (flags&CONTROL_OP) || (flags&CONTROL_INITPARAMS)) 
		InitControl(mc,obj,type,t);
	Matrix3 tm;	
	tm = Inverse(CompMatrix(t,&mc,NULL));

	if (type !=MAP_XYZTOUVW){  //UVW to XYZ
        obj->ApplyUVWMap(type,utile,vtile,wtile,uflip,vflip,wflip,cap,tm, mapChannel);
        
	} else
		{
//copies th xyz pos int the uvw channel

		
//Looks like NURBS don't support the W in UVW space so it is no good to copy the data over sense it would be meaningless
		if (os->obj->ClassID() == EDITABLE_SURF_CLASS_ID) 
			{
/*			NURBSSet getSet;
			BOOL okay = GetNURBSSet(os->obj, t, getSet, TRUE);
			if (mapChannel<2) mapChannel = 1-mapChannel;
			if (okay) {
				int ncount = getSet->GetNumObjects();

				NURBSObject *nObj;
				nObj = getSet.GetNURBSObject(0), ip->GetTime());
				SetTextureUVs()
				if (nObj->GetKind() == kNURBSSurface) {
					if (nObj->IsSelected() || ())
					// It's a blend, adjust the tension
					NURBSSurface *Surf = (NURBSSurface *)nObj;
	
					Surf->SetTextureUVs(t, 0, Point2 pt, mapChannel);
					}		
				}
*/
			}
		if (os->obj->IsSubClassOf(patchObjectClassID)) {


			PatchObject *patOb = (PatchObject *)os->obj;
			PatchMesh &mesh  = patOb->patch;
		
			int ct = 0;
			//if (mapChannel<2) mapChannel = 1-mapChannel;

			int fct = mesh.getNumPatches();
			int vct = mesh.getNumVerts();

//create TVface list
//create TVVert list
			if (mesh.selLevel != PATCH_PATCH)
				{
				mesh.setNumMapVerts (mapChannel,vct);
				mesh.setNumMapPatches (mapChannel,fct);
				ct = vct;

				for (int i = 0; i < mesh.getNumPatches(); i++)
			
					{
					int a,b,c,d;
					a  = mesh.patches[i].v[0];
					b  = mesh.patches[i].v[1];
					c  = mesh.patches[i].v[2];
					d  = mesh.patches[i].v[3];
					mesh.getMapPatch(mapChannel,i).setTVerts(a,b,c,d);
					}
//look for texture verts if not there create them
				for (i=0; i<ct; i++) {

// get point
					PatchVert pv = mesh.getVert(i);
					Point3 uvw = pv.p;
					uvw.x *= utile;
					uvw.y *= vtile;
					uvw.z *= wtile;
					if (uflip) uvw.x *= -1.0f;
					if (vflip) uvw.y *= -1.0f;
					if (wflip) uvw.z *= -1.0f;
					mesh.setMapVert(mapChannel,i,uvw);
					}
				}
			else
//else copy to just selected patches
				{
				vct = mesh.getNumMapVerts (mapChannel);
				int offset = vct;
				Tab<Point3> Points;
				Tab<int> VIndex;
				Tab<TVPatch> Faces;
				for (int i = 0; i < mesh.getNumPatches(); i++)
					{
					if (mesh.patchSel[i] == 1)
						{
						TVPatch tv;
						int pcount = 3;
						if (mesh.patches[i].type == PATCH_QUAD) pcount =4;
						for (int k = 0; k < pcount; k++)
							{
							int found = -1;
//loop through vindex see if they already exist
							for (int j = 0; j < VIndex.Count(); j++)
								{
								int index = mesh.patches[i].v[k];
								if (index == VIndex[j])
									{
									found = j;
									j = VIndex.Count();
									}
								}
							if (found == -1)
								{
								VIndex.Append(1,&i,1);
								tv.tv[k] = VIndex.Count()-1; 
								Point3  p = mesh.verts[mesh.patches[i].v[k]].p;
								Points.Append(1,&p,1);
								}
							else
								{
								tv.tv[k] = found; 
								}
							}
//append face
						Faces.Append(1,&tv,1);
						}

					}

				mesh.setNumMapVerts (mapChannel,vct+VIndex.Count());
				if (mesh.tvPatches[mapChannel] == NULL)
					mesh.setNumMapPatches (mapChannel,fct);

				ct = vct;

				int f = 0;
				TVPatch *tvf = mesh.tvPatches[mapChannel];
				for (i = 0; i < mesh.getNumPatches(); i++)
			
					{
					if (mesh.patchSel[i] == 1)
						{
						Faces[f].tv[0] += vct;
						Faces[f].tv[1] += vct;
						Faces[f].tv[2] += vct;
						Faces[f].tv[3] += vct;
						tvf[i] = Faces[f++];
						}
					}
//look for texture verts if not there create them
				UVVert *tvp = mesh.tVerts[mapChannel];

				for (i=0; i<Points.Count(); i++) {
// get point
					Point3 uvw = Points[i];
					uvw.x *= utile;
					uvw.y *= vtile;
					uvw.z *= wtile;
					if (uflip) uvw.x *= -1.0f;
					if (vflip) uvw.y *= -1.0f;
					if (wflip) uvw.z *= -1.0f;

					tvp[i+vct] = uvw;
					}
				}

			}


		else if (os->obj->IsSubClassOf(triObjectClassID)) {
			TriObject *tobj = (TriObject*)os->obj;
			Mesh &mesh = tobj->GetMesh();
		
			int ct = 0;


			if (!mesh.mapSupport(mapChannel)) {
		// allocate texture verts. Setup tv faces into a parallel
		// topology as the regular faces
				TVFace *tvFace2;
//				int numTVerts2;
				if (mapChannel >= mesh.getNumMaps ()) mesh.setNumMaps (mapChannel+1, TRUE);
				mesh.setMapSupport (mapChannel, TRUE);
				mesh.setNumMapVerts (mapChannel, mesh.getNumVerts ());
				tvFace2 = mesh.mapFaces(mapChannel);
				for (int i=0; i<mesh.getNumFaces(); i++) {
					tvFace2[i].setTVerts(mesh.faces[i].getAllVerts());
					}
				} 

			if (mapChannel == 0)
			    ct = mesh.numCVerts;
			else ct = mesh.getNumMapVerts (mapChannel);
				//ct = mesh.numTVerts;


			int fct = mesh.getNumFaces();
			int vct = mesh.getNumVerts();


//else copy to all mesh
			if (mesh.selLevel != MESH_FACE)
				{
				mesh.setNumMapVerts(mapChannel, vct);
//					mesh.setNumMapFaces(fct);

				ct = vct;
				TVFace *tvFace = NULL;
				tvFace = mesh.mapFaces(mapChannel);
				for (int i = 0; i < mesh.getNumFaces(); i++)
					{
					tvFace[i].setTVerts(mesh.faces[i].getAllVerts());
					}
//look for texture verts if not there create them
				UVVert *tVerts = mesh.mapVerts(mapChannel);
				for (i=0; i<ct; i++) {
// get point
					Point3 uvw = mesh.getVert(i);
					uvw.x *= utile;
					uvw.y *= vtile;
					uvw.z *= wtile;
					if (uflip) uvw.x *= -1.0f;
					if (vflip) uvw.y *= -1.0f;
					if (wflip) uvw.z *= -1.0f;
					tVerts[i] = uvw;
					}

				}
//else copy to just selected faces
			else
				{
				vct = mesh.getNumMapVerts (mapChannel);
				int offset = vct;
				Tab<Point3> Points;
				Tab<int> VIndex;
				Tab<TVFace> Faces;
				for (int i = 0; i < mesh.getNumFaces(); i++)
					{
					if (mesh.faceSel[i] == 1)
						{
						TVFace tv;
						for (int k = 0; k < 3; k++)
							{
							int found = -1;
//loop through vindex see if they already exist
							for (int j = 0; j < VIndex.Count(); j++)
								{
								int index = mesh.faces[i].v[k];
								if (index == VIndex[j])
									{
									found = j;
									j = VIndex.Count();
									}
								}
							if (found == -1)
								{
								VIndex.Append(1,&i,1);
								tv.t[k] = VIndex.Count()-1; 
								Point3  p = mesh.verts[mesh.faces[i].v[k]];
								Points.Append(1,&p,1);
								}
							else
								{
								tv.t[k] = found; 
								}
							}
//append face
						Faces.Append(1,&tv,1);
						}

					}
				mesh.setNumMapVerts (mapChannel, vct+VIndex.Count(), TRUE);

				int f = 0;
				TVFace *tvFace = NULL;
				tvFace = mesh.mapFaces(mapChannel);
				for (i = 0; i < mesh.getNumFaces(); i++)
			
					{
					if (mesh.faceSel[i] == 1)
						{
						Faces[f].t[0] += vct;
						Faces[f].t[1] += vct;
						Faces[f].t[2] += vct;
						tvFace[i] = Faces[f++];
						}
					}
//look for texture verts if not there create them
				UVVert *tVerts = mesh.mapVerts(mapChannel);
				for (i=0; i<Points.Count(); i++) {
// get point
					Point3 uvw = Points[i];
					uvw.x *= utile;
					uvw.y *= vtile;
					uvw.z *= wtile;
					if (uflip) uvw.x *= -1.0f;
					if (vflip) uvw.y *= -1.0f;
					if (wflip) uvw.z *= -1.0f;

					tVerts[i+vct] = uvw;
					}
				}

			}

		}

	// The tex mapping depends on the geom and topo so make sure the validity interval reflects this.
	Interval iv = LocalValidity(t);
	iv = iv & os->obj->ChannelValidity(t,GEOM_CHAN_NUM);
	iv = iv & os->obj->ChannelValidity(t,TOPO_CHAN_NUM);
	os->obj->UpdateValidity(TEXMAP_CHAN_NUM,iv);	
}


static int lStart[12] = {0,1,3,2,4,5,7,6,0,1,2,3};
static int lEnd[12]   = {1,3,2,0,5,7,6,4,4,5,6,7};

static void DoBoxIcon(BOOL sel,float length, PolyLineProc& lp)
	{
	Point3 pt[3];
	
	length *= 0.5f;
	Box3 box;
	box.pmin = Point3(-length,-length,-length);
	box.pmax = Point3( length, length, length);

	if (sel) //lp.SetLineColor(1.0f,1.0f,0.0f);
		 lp.SetLineColor(GetUIColor(COLOR_SEL_GIZMOS));
	else //lp.SetLineColor(0.85f,0.5f,0.0f);		
		 lp.SetLineColor(GetUIColor(COLOR_GIZMOS));

	for (int i=0; i<12; i++) {
		pt[0] = box[lStart[i]];
		pt[1] = box[lEnd[i]];
		lp.proc(pt,2);
		}
	}





//--- MappingMod methods -----------------------------------------------

void* MappingMod::GetInterface(ULONG id)
	{	
	if (id==I_MAPPINGINTERFACE) return this;
	else return Modifier::GetInterface(id);
	}


void MappingMod::InitControl(
		ModContext &mc,Object *obj,int type,TimeValue t)
	{
	Box3 box;
	Matrix3 tm;
	mLocalSetValue = true; // mjm - 6.7.99

	if (tmControl==NULL) {
		MakeRefByID(FOREVER,0,NewDefaultMatrix3Controller()); 
		NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
		}		
	
	if (flags&CONTROL_INIT) {
		SuspendAnimate();
		AnimateOff();		
		// Rotate the seem to the back
		SetXFormPacket pckt(Quat(RotateZMatrix(PI)),TRUE);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		ResumeAnimate();
		}

	if (flags&CONTROL_INITPARAMS) {
		SetLength(0,2.0f);
		SetWidth(0,2.0f);
		if (type==MAP_BALL ||
			type==MAP_SPHERICAL ||
			type==MAP_BOX) {			
			SetHeight(0,2.0f);
		} else {
			SetHeight(0,1.0f);
			}
		SetAxis(2);
		}

	if (!(flags&CONTROL_OP)) {
		flags = 0;
		return;
		}

	if (flags&CONTROL_HOLD) 
		{
		theHold.Begin();
		}


	Matrix3 oldtm = tm = Inverse(CompMatrix(t,&mc,NULL,FALSE));	
	AffineParts parts;
	decomp_affine(tm, &parts);
	parts.q.MakeMatrix(tm);
	tm.Translate(parts.t);
	
	Matrix3 mctm(1);
	if (mc.tm) mctm = *mc.tm;
	tm.Scale(Point3(
		Length(mctm.GetRow(0)),
		Length(mctm.GetRow(1)),
		Length(mctm.GetRow(2))
		));

	Point3 s;
	s.x = GetWidth(t);
	s.y = GetLength(t);
	s.z = GetHeight(t);	

	mMyEnumProc dep;              
	EnumDependents(&dep);

	if (dep.Nodes.Count() == 1)
		obj->GetDeformBBox(t,box,&tm,TRUE);
	else
		{
		box = *(mc.box);
		if (box.IsEmpty()) box.MakeCube(Point3(0,0,0),10.0f);	// SCA 990621: fixes problem with empty selection sets.
		if (mc.tm) { // RB 10/5/99: Need to handle NULL mc.tm.
			box = box * (*(mc.tm)) * tm;
		} else {
			box = box * tm;
			}
		}

	box.Scale(1.001f);  // prevent wrap-around on sides of boxes

	if (flags&CONTROL_ASPECT &&
		(type==MAP_PLANAR ||
		 type==MAP_BOX ||
		 type==MAP_CYLINDRICAL)) {

		if (type==MAP_PLANAR || type==MAP_BOX) {			
			float w = aspect*s.y;
			s.x *= w / s.x;			
			s.z *= s.y / s.z;				
		} else
		if (type==MAP_CYLINDRICAL) {
			float w = (s.x+s.y)*PI;			
			s.z *= w/(aspect*s.z);
			}
		}

	if (flags&CONTROL_UNIFORM) {
		float av = (s.x + s.y + s.z)/3.0f;
		s.x = s.y = s.z = av;
		}

	if (flags&CONTROL_FIT) {
		Point3 w = box.Width();
		if (box.IsEmpty()) w = Point3(10.0f,10.0f,10.0f);

		if (type==MAP_PLANAR) {
			s.x = w.x==0.0f ? 1.0f : w.x;
			s.y = w.y==0.0f ? 1.0f : w.y;
			s.z = w.z==0.0f ? 1.0f : w.z;
		} else
		if (type==MAP_BOX) {
			s.x = w.x==0.0f ? 1.0f : w.x;
			s.y = w.y==0.0f ? 1.0f : w.y;
			s.z = w.z==0.0f ? 1.0f : w.z;
		} else
		if (type==MAP_SPHERICAL || type==MAP_BALL) {
			float max = w.x;
			if (w.y>max) max = w.y;
			if (w.z>max) max = w.z;
			if (max==0.0f) max = 1.0f;
			s.x = s.y = s.z = max;
		} else {
			if (w.x>w.y) s.x = s.y = w.x;
			else s.x = s.y = w.y;
			s.z = w.z;
			if (s.x==0.0f) s.x = 1.0f;
			if (s.y==0.0f) s.y = 1.0f;
			if (s.z==0.0f) s.z = 1.0f;			
			}
		}

	if (flags&(CONTROL_CENTER|CONTROL_FIT)) {		
//		Matrix3 tm(1);
//		Interval valid;
//		tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);		
//		SetXFormPacket pckt(mc.box->Center()-(mc.box->Center()*tm));
//			tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		
//get current center
//get vector
		Point3 cent;
		Point3 Zero(0.0f,0.0f,0.0f);
//if the translation is zero only assigned to one object thus use the obj bbox
		if (dep.Nodes.Count() == 1)

			{
			Box3 sbox;		
			obj->GetDeformBBox(t,sbox,&oldtm,TRUE);
		
			cent = sbox.Center();
			cent = VectorTransform(Inverse(oldtm),cent);
			cent = VectorTransform(mctm,cent);
			}

		else 
			{
			if (flags&CONTROL_INIT) 
				{
				cent.x = 0.0f;
				cent.y = 0.0f;
				cent.z = 0.0f;

				}
			else
				{
				Matrix3 tm(1);
				Interval valid;
				tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);		

				cent = -tm.GetTrans();

				}
			}
		SetXFormPacket pckt(
			cent, //sbox.Center(),
			Matrix3(1),
			Matrix3(1));
		
		SuspendAnimate();
		AnimateOff();
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		ResumeAnimate();
		}

	if (flags&(CONTROL_FIT|CONTROL_ASPECT|CONTROL_INITPARAMS|CONTROL_UNIFORM)) {
		SuspendAnimate();
		AnimateOff();

		// Clear out any scale in the transform
		tm = Matrix3(1);	
		tmControl->GetValue(t,&tm,FOREVER,CTRL_RELATIVE);	
		decomp_affine(tm, &parts);
		parts.q.MakeMatrix(tm);
		tm.Translate(parts.t);	
		SetXFormPacket pckt(tm);		
		tmControl->SetValue(t,&pckt,TRUE,CTRL_ABSOLUTE);

		// Set the new dimensions
		SetLength(t,s.y);
		SetWidth(t,s.x);
		SetHeight(t,s.z);
		
		ResumeAnimate();
		}

	if (flags&CONTROL_HOLD) 
		{
		if (flags&CONTROL_FIT)
			theHold.Accept(GetString(IDS_PW_UNDO_FIT));	
		else theHold.Accept(GetString(IDS_RB_CENTER));	
			


		}


	mLocalSetValue = false; // mjm - 6.7.99
	flags = 0;
	}


#if 0
void MappingMod::InitControl(ModContext &mc,Object *obj,int type,TimeValue t)
	{
	Box3 box;
	Matrix3 tm;

	if (tmControl==NULL) {
		MakeRefByID(FOREVER,0,NewDefaultMatrix3Controller()); 
		NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
		}		

	if (flags&CONTROL_HOLD) theHold.Begin();
	if (flags&CONTROL_INIT) {
		SuspendAnimate();
		AnimateOff();		
		// Rotate the seem to the back
		SetXFormPacket pckt(Quat(RotateZMatrix(PI)),TRUE);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}

	tm = Inverse(CompMatrix(t,&mc,NULL));
	obj->GetDeformBBox(t,box,&tm,TRUE);
	box.Scale(1.001f);  // prevent wrap-around on sides of boxes

	if (flags&CONTROL_ASPECT &&
		(type==MAP_PLANAR ||
		 type==MAP_BOX ||
		 type==MAP_CYLINDRICAL)) {
		Matrix3 tm(1), id(1);
		Interval valid;
		tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);
		Point3 s;

		if (type==MAP_PLANAR || type==MAP_BOX) {			
			float w = aspect*Length(tm.GetRow(1));
			s.x = w / Length(tm.GetRow(0));
			s.y = 1.0f;
			s.z = Length(tm.GetRow(1)) / Length(tm.GetRow(2));	
			/*
			float a = (Length(tm.GetRow(0))+Length(tm.GetRow(1))+Length(tm.GetRow(2)))/3.0f;
			s.x = aspect*a / Length(tm.GetRow(0));
			s.y = a / Length(tm.GetRow(1));
			s.z = a / Length(tm.GetRow(2));
			*/
		} else
		if (type==MAP_CYLINDRICAL) {			
			// Old way where we sized the radius
			/*
			float lz = Length(tm.GetRow(2));
			float rad = lz*aspect/(TWOPI);
			s.x = rad / Length(tm.GetRow(0));
			s.y = rad / Length(tm.GetRow(1));
			s.z = 1.0f;
			*/
			// Now we size the height
			float w = (Length(tm.GetRow(0))+Length(tm.GetRow(1)))*PI;
			s.x = 1.0f;
			s.y = 1.0f;
			s.z = w/(aspect*Length(tm.GetRow(2)));
			}
		
		SetXFormPacket pckt(s,TRUE,id,tm);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}

	if (flags&CONTROL_UNIFORM) {
		Matrix3 tm(1), id(1);
		Interval valid;
		tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);
		float av = 0.0f;
		Point3 s;
		av += Length(tm.GetRow(0));
		av += Length(tm.GetRow(1));
		av += Length(tm.GetRow(2));
		av /= 3.0f;
		s.x = av/Length(tm.GetRow(0));
		s.y = av/Length(tm.GetRow(1));
		s.z = av/Length(tm.GetRow(2));

		SetXFormPacket pckt(s,TRUE,id,tm);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}

	if (flags&CONTROL_FIT) {
		
		// Get the box of the object in mod context space but unscaled
		Matrix3 mat = tm;
		mat.NoScale();
		obj->GetDeformBBox(t,box,&mat,TRUE);
		box.Scale(1.001f);  // prevent wrap-around on sides of boxes

		Point3 s, w  = box.Width();
		if (box.IsEmpty()) w = Point3(10.0f,10.0f,10.0f);
		Matrix3 tm(1), id(1);
		Interval valid;
		tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);

		if (type==MAP_PLANAR) {
			s.x = w.x==0.0f ? 1.0f : w.x/2.0f;
			s.y = w.y==0.0f ? 1.0f : w.y/2.0f;
			s.z = w.z==0.0f ? 1.0f : w.z;
		} else
		if (type==MAP_BOX) {
			s.x = w.x==0.0f ? 1.0f : w.x/2.0f;
			s.y = w.y==0.0f ? 1.0f : w.y/2.0f;
			s.z = w.z==0.0f ? 1.0f : w.z/2.0f;
		} else
		if (type==MAP_SPHERICAL || type==MAP_BALL) {
			float max = w.x;
			if (w.y>max) max = w.y;
			if (w.z>max) max = w.z;
			if (max==0.0f) max = 1.0f;
			s.x = s.y = s.z = max/2.0f;
		} else {
			if (w.x>w.y) s.x = s.y = w.x/2.0f;
			else s.x = s.y = w.y/2.0f;
			s.z = w.z;
			if (s.x==0.0f) s.x = 1.0f;
			if (s.y==0.0f) s.y = 1.0f;
			if (s.z==0.0f) s.z = 1.0f;			
			}
		
		s.x /= Length(tm.GetRow(0));
		s.y /= Length(tm.GetRow(1));
		s.z /= Length(tm.GetRow(2));
		
		SetXFormPacket pckt(s,TRUE,id,tm);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		
		// redo the box so our center op works
		tm = Inverse(CompMatrix(t,&mc,NULL));
		obj->GetDeformBBox(t,box,&tm,TRUE);
		box.Scale(1.001f);  // prevent wrap-around on sides of boxes
		}		

	if (flags&(CONTROL_CENTER|CONTROL_FIT)) {
		Matrix3 tm(1);
		Interval valid;
		tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);		
		SetXFormPacket pckt(VectorTransform(tm,box.Center()));		
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}

	if (flags&CONTROL_HOLD) theHold.Accept(0);	
	if (flags&CONTROL_INIT) {
		ResumeAnimate();
		}

	flags = 0;
	}
#endif


// --- Gizmo transformations ------------------------------------------

void MappingMod::Move(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin) 
	{	
#ifdef DESIGN_VER
	t=0;
#endif
	assert(tmControl);	
	SetXFormPacket pckt(val,partm,tmAxis);
	tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
	}


void MappingMod::Rotate(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Quat& val, BOOL localOrigin) 
	{
#ifdef DESIGN_VER
	t=0;
#endif
	assert(tmControl);
	SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
	tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	}

void MappingMod::Scale(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin) 
	{
#ifdef DESIGN_VER
	t=0;
#endif
	assert(tmControl);
	SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
	tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	}


Matrix3 MappingMod::CompMatrix(
		TimeValue t,ModContext *mc, Matrix3 *ntm,BOOL applySize, BOOL applyAxis)
	{
	Matrix3 tm(1);
	Interval valid;
	
	int type = GetMapType();

	if (tmControl) {
		tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);
		}
	
	// Rotate icon	
	if (applyAxis && TestAFlag(A_PLUGIN1)) {
		switch (type) {
			case MAP_BOX:
			case MAP_PLANAR:
				tm.PreRotateZ(PI);
				break;
			
			case MAP_BALL:
			case MAP_SPHERICAL:
			case MAP_CYLINDRICAL:
				tm.PreRotateZ(HALFPI);
				break;
			}
		}
	
	if (applyAxis) {
		switch (GetAxis()) {
			case 0:
				tm.PreRotateY(-HALFPI);
				break;
			case 1:			
				tm.PreRotateX(HALFPI);
				break;
			}
		}

	if (applySize) {
		Point3 s;
		s.x = GetWidth(t);
		s.y = GetLength(t);
		s.z = GetHeight(t);
		switch (type) {
			case MAP_CYLINDRICAL:			
			case MAP_PLANAR:
				s.x *= 0.5f;
				s.y *= 0.5f;
				break;
			
			case MAP_BALL:
			case MAP_SPHERICAL:
			case MAP_BOX:
				s *= 0.5f;				
				break;
			}
		tm.PreScale(s);
		}

	if (mc && mc->tm) {
		tm = tm * Inverse(*mc->tm);
		}
	if (ntm) {
		tm = tm * *ntm;
		}
	return tm;
	}

void MappingMod::DoIcon(PolyLineProc& lp,BOOL sel)
	{
	int type = GetMapType();	
	switch (type) {
		case MAP_BOX: DoBoxIcon(sel,2.0f,lp); break;
		case MAP_PLANAR: DoPlanarMapIcon(sel,2.0f,2.0f,lp); break;
		case MAP_BALL:
		case MAP_SPHERICAL: DoSphericalMapIcon(sel,1.0f,lp); break;
		case MAP_CYLINDRICAL: DoCylindricalMapIcon(sel,1.0f,1.0f,lp); break;
		}
	}
 
int MappingMod::HitTest(
		TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc) 
	{	
	int savedLimits;	
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);
	Matrix3 modmat, ntm = inode->GetObjectTM(t);
	DrawLineProc lp(gw);
		
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->clearHitCode();
	
	if (ip && ip->GetSubObjectLevel() == 1) {		
		modmat = CompMatrix(t,mc,&ntm);
		gw->setTransform(modmat);
		DoIcon(lp,FALSE);
		}
	
	gw->setRndLimits(savedLimits);	
	if (gw->checkHitCode()) {
		vpt->LogHit(inode, mc, gw->getHitDistance(), 0, NULL); 
		return 1;
		}
	return 0;
	}

int MappingMod::Display(
		TimeValue t, INode* inode, ViewExp *vpt, int flags, 
		ModContext *mc) 
	{	
	GraphicsWindow *gw = vpt->getGW();
	#ifdef DESIGN_VER
		TimeValue rt = GetCOREInterface()->GetTime();
		Matrix3 modmat, ntm = inode->GetObjectTM(rt);
	#else
		Matrix3 modmat, ntm = inode->GetObjectTM(t);
	#endif

	DrawLineProc lp(gw);

	modmat = CompMatrix(t,mc,&ntm);	
	gw->setTransform(modmat);	
	DoIcon(lp, ip&&ip->GetSubObjectLevel()==1);

	return 0;	
	}

void MappingMod::GetWorldBoundBox(
		TimeValue t,INode* inode, ViewExp *vpt, Box3& box, 
		ModContext *mc) 
	{
#ifdef DESIGN_VER
		TimeValue rt = GetCOREInterface()->GetTime();
		Matrix3 modmat, ntm = inode->GetObjTMBeforeWSM(rt);
#else
	Matrix3 modmat, ntm = inode->GetObjTMBeforeWSM(t);	
#endif
	modmat = CompMatrix(t,mc,&ntm);		
	BoxLineProc bproc(&modmat);
	DoIcon(bproc,FALSE);
	box = bproc.Box();	
	}

void MappingMod::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{	
	Matrix3 modmat, ntm = node->GetObjectTM(t);	
	modmat = CompMatrix(t,mc,&ntm);
	cb->Center(modmat.GetTrans(),0);	
	}

void MappingMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Matrix3 ntm = node->GetObjectTM(t), modmat;
	modmat = CompMatrix(t,mc,&ntm);
	cb->TM(modmat,0);
	}

void FixDimsPLCB::proc(ILoad *iload)
	{
	if (mod->GetPBlockVersion()<mod->GetFirstParamVer()) {
		mod->flags |= CONTROL_INITPARAMS;
		}
	delete this;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\extrude.cpp ===
/**********************************************************************
 *<
	FILE: extrude.cpp

	DESCRIPTION:  Shape->patch extruder

	CREATED BY: Tom Hudson, Dan Silva & Rolf Berteig

	HISTORY: created 10 November, 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm.h"
#include "shape.h"
#include "spline3d.h"
#include "splshape.h"
#include "linshape.h"
#include "surf_api.h"
#ifdef DESIGN_VER
#include "igeomimp.h"
//bool BuildSolidFromShape(TimeValue t,ModContext &mc, ObjectState * os, IGeomImp* igeom);
#endif
//--- ExtrudeMod -----------------------------------------------------------

#define MIN_AMOUNT		float(-1.0E30)
#define MAX_AMOUNT		float(1.0E30)

#define DEF_AMOUNT 0.0f
#define DEF_SEGS 1
#define DEF_CAPSTART 1
#define DEF_CAPEND 1
#define DEF_CAPTYPE CAPTYPE_MORPH
#define DEF_MAPPING FALSE
#define DEF_GEN_MATIDS TRUE
#define DEF_USE_SHAPEIDS FALSE
#define DEF_SMOOTH TRUE

#define PATCH_OUTPUT 0
#define MESH_OUTPUT 1
#define NURBS_OUTPUT 2
#define AMSOLID_OUTPUT 3
#define DEF_OUTPUT MESH_OUTPUT //PATCH_OUTPUT

class ExtrudeMod;

// Special dialog handling
class ExtrudeDlgProc : public ParamMapUserDlgProc {
	private:
		ExtrudeMod *mod;
	public:
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void SetMod(ExtrudeMod *m) { mod = m; }
		void DeleteThis() {}
	};

class ExtrudeMod: public Modifier {
	
	protected:
		static IObjParam *ip;
		
	public:
		IParamBlock *pblock;

		static IParamMap *pmapParam;
		static ExtrudeMod *editMod;

		ExtrudeDlgProc dlgProc;

		static float dlgAmount;
		static int dlgSegs;
		static int dlgCapStart;
		static int dlgCapEnd;
		static int dlgCapType;
		static int dlgOutput;
		static int dlgMapping;
		static int dlgGenMatIDs;
		static int dlgUseShapeIDs;
		static int dlgSmooth;

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= TSTR(_T("ExtrudeMod")); }  
		virtual Class_ID ClassID() { return Class_ID(EXTRUDEOSM_CLASS_ID,0);}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_DB_EXTRUDE); }
		IOResult Load(ILoad *iload);

		ExtrudeMod();
		virtual ~ExtrudeMod();

		ChannelMask ChannelsUsed()  { return PART_GEOM|PART_TOPO; }
		// Possible GOTCHA -- Modifiers like this one, which completely change the type of
		// object (shape -> Mesh or Patch) change ALL channels!  Be sure to tell the system!
		ChannelMask ChannelsChanged() { return PART_ALL; }
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Class_ID InputType() {return genericShapeClassID;}
		Interval LocalValidity(TimeValue t);

		// From BaseObject
		BOOL ChangeTopology() {return TRUE;}
		IParamArray *GetParamBlock() {return pblock;}
		int GetParamBlockIndex(int id) {return id;}

		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}

 		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i) { return pblock; }
		TSTR SubAnimName(int i) { return TSTR(GetString(IDS_RB_PARAMETERS));}		

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 

		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);

		void BuildMeshFromShape(TimeValue t,ModContext &mc, ObjectState * os, Mesh &mesh, BOOL simple=FALSE);
		void BuildPatchFromShape(TimeValue t,ModContext &mc, ObjectState * os, PatchMesh &pmesh);
#ifdef DESIGN_VER
		bool BuildAMSolidFromShape(TimeValue t,ModContext &mc, ObjectState * os, IGeomImp* igeom);
#endif

		void UpdateUI(TimeValue t) {}
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		// Automatic texture support
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);

		// Parameter access
		BOOL GetGenMatIDs();
	};

BOOL ExtrudeDlgProc::DlgProc(
		TimeValue t,IParamMap *map,
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			EnableWindow(GetDlgItem(hWnd,IDC_USE_SHAPE_IDS),mod->GetGenMatIDs());
#ifdef DESIGN_VER
			//JH 6/24/99
			//In the design version we may be outputting a solid
			//If so we don't allow changing output types
			int output;
			mod->pblock->GetValue(5/*PB_OUTPUT*/, TimeValue(0), output, FOREVER);
			if(output == AMSOLID_OUTPUT)
			{
			EnableWindow(GetDlgItem(hWnd,IDC_PATCH),FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_MESH), FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_NURBS),FALSE);
			}
#endif
			break;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_GEN_MATIDS:
					EnableWindow(GetDlgItem(hWnd,IDC_USE_SHAPE_IDS),mod->GetGenMatIDs());
					break;
				}
			break;
		}
	return FALSE;
	}

class ExtrudeClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new ExtrudeMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_EXTRUDE_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return  Class_ID(EXTRUDEOSM_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	void			ResetClassParams(BOOL fileReset);
	};

static ExtrudeClassDesc extrudeDesc;
extern ClassDesc* GetExtrudeModDesc() { return &extrudeDesc; }

IObjParam*		ExtrudeMod::ip          = NULL;
IParamMap *		ExtrudeMod::pmapParam = NULL;
ExtrudeMod *	ExtrudeMod::editMod = NULL;
float			ExtrudeMod::dlgAmount = DEF_AMOUNT;
int				ExtrudeMod::dlgSegs = DEF_SEGS;
int				ExtrudeMod::dlgCapStart = DEF_CAPSTART;
int				ExtrudeMod::dlgCapEnd = DEF_CAPEND;
int				ExtrudeMod::dlgCapType = DEF_CAPTYPE;
int				ExtrudeMod::dlgOutput = DEF_OUTPUT;
int				ExtrudeMod::dlgMapping = DEF_MAPPING;
int				ExtrudeMod::dlgGenMatIDs = DEF_GEN_MATIDS;
int				ExtrudeMod::dlgUseShapeIDs = DEF_USE_SHAPEIDS;
int				ExtrudeMod::dlgSmooth = DEF_SMOOTH;

void ExtrudeClassDesc::ResetClassParams(BOOL fileReset)
	{
	ExtrudeMod::dlgAmount       = DEF_AMOUNT;
	ExtrudeMod::dlgSegs		    = DEF_SEGS;
	ExtrudeMod::dlgCapStart     = DEF_CAPSTART;
	ExtrudeMod::dlgCapEnd       = DEF_CAPEND;
	ExtrudeMod::dlgCapType      = DEF_CAPTYPE;
	ExtrudeMod::dlgOutput       = DEF_OUTPUT;
	ExtrudeMod::dlgMapping      = DEF_MAPPING;
	ExtrudeMod::dlgGenMatIDs    = DEF_GEN_MATIDS;
	ExtrudeMod::dlgUseShapeIDs  = DEF_USE_SHAPEIDS;
	ExtrudeMod::dlgSmooth		= DEF_SMOOTH;
	}

//--- Parameter map/block descriptors -------------------------------

#define PB_AMOUNT		0
#define PB_SEGS			1
#define PB_CAPSTART		2
#define PB_CAPEND		3
#define PB_CAPTYPE		4
#define PB_OUTPUT		5
#define PB_MAPPING		6
#define PB_GEN_MATIDS	7
#define PB_USE_SHAPEIDS	8
#define PB_SMOOTH		9

//
//
// Parameters

static int captypeIDs[] = {IDC_MORPHCAP,IDC_GRIDCAP};
static int outputIDs[] = {IDC_PATCH,IDC_MESH,IDC_NURBS};

static ParamUIDesc descParam[] = {
	// Amount
	ParamUIDesc(
		PB_AMOUNT,
		EDITTYPE_UNIVERSE,
		IDC_AMOUNT,IDC_AMOUNTSPINNER,
		MIN_AMOUNT,MAX_AMOUNT,
		0.5f),

	// Segments
	ParamUIDesc(
		PB_SEGS,
		EDITTYPE_INT,
		IDC_SEGMENTS,IDC_SEGMENTSPINNER,
		1.0f,100.0f,
		0.5f),

	// Capping start
	ParamUIDesc(PB_CAPSTART,TYPE_SINGLECHEKBOX,IDC_CAPSTART),

	// Capping end
	ParamUIDesc(PB_CAPEND,TYPE_SINGLECHEKBOX,IDC_CAPEND),

	// Cap type
	ParamUIDesc(PB_CAPTYPE,TYPE_RADIO,captypeIDs,2),

	// Output type
	ParamUIDesc(PB_OUTPUT,TYPE_RADIO,outputIDs,3),

	// Texture coords
	ParamUIDesc(PB_MAPPING,TYPE_SINGLECHEKBOX,IDC_GENMAPPING),

	// Multi material IDs
	ParamUIDesc(PB_GEN_MATIDS,TYPE_SINGLECHEKBOX,IDC_GEN_MATIDS),

	// Shape material IDs
	ParamUIDesc(PB_USE_SHAPEIDS,TYPE_SINGLECHEKBOX,IDC_USE_SHAPE_IDS),

	// Smoothing
	ParamUIDesc(PB_SMOOTH,TYPE_SINGLECHEKBOX,IDC_SMOOTH)
	};
#define PARAMDESC_LENGTH 10


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 } };

static ParamBlockDescID descVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 } };

static ParamBlockDescID descVer3[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 } };

static ParamBlockDescID descVer4[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 } };

static ParamBlockDescID descVer5[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 },
	{ TYPE_INT, NULL, FALSE, 8 } };

static ParamBlockDescID descVer6[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 },
	{ TYPE_INT, NULL, FALSE, 8 },
	{ TYPE_INT, NULL, FALSE, 9 } };

#define PBLOCK_LENGTH	10

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,4,0),
	ParamVersionDesc(descVer1,5,1),	
	ParamVersionDesc(descVer2,6,2),	
	ParamVersionDesc(descVer3,7,3),	
	ParamVersionDesc(descVer4,8,4),
	ParamVersionDesc(descVer5,9,5)	
	};
#define NUM_OLDVERSIONS	6

// Current version
#define CURRENT_VERSION	6
static ParamVersionDesc curVersion(descVer6,PBLOCK_LENGTH,CURRENT_VERSION);

ExtrudeMod::ExtrudeMod()
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descVer6, PBLOCK_LENGTH, CURRENT_VERSION));
	pblock->SetValue(PB_AMOUNT, TimeValue(0), dlgAmount);
	pblock->SetValue(PB_SEGS, TimeValue(0), dlgSegs);
	pblock->SetValue(PB_CAPSTART, TimeValue(0), dlgCapStart);
	pblock->SetValue(PB_CAPEND, TimeValue(0), dlgCapEnd);
	pblock->SetValue(PB_CAPTYPE, TimeValue(0), dlgCapType);
	pblock->SetValue(PB_OUTPUT, TimeValue(0), dlgOutput);
	pblock->SetValue(PB_MAPPING, TimeValue(0), dlgMapping);
	pblock->SetValue(PB_GEN_MATIDS, TimeValue(0), dlgGenMatIDs);
	pblock->SetValue(PB_USE_SHAPEIDS, TimeValue(0), dlgUseShapeIDs);
	pblock->SetValue(PB_SMOOTH, TimeValue(0), dlgSmooth);
	dlgProc.SetMod(this);
	}

ExtrudeMod::~ExtrudeMod()
	{	
	}

Interval ExtrudeMod::LocalValidity(TimeValue t)
	{
	// if being edited, return NEVER forces a cache to be built 
	// after previous modifier.
	if (TestAFlag(A_MOD_BEING_EDITED))
		return NEVER;  
	Interval valid = GetValidity(t);	
	return valid;
	}

RefTargetHandle ExtrudeMod::Clone(RemapDir& remap)
	{
	ExtrudeMod* newmod = new ExtrudeMod();	
	newmod->ReplaceReference(0,pblock->Clone(remap));
	return(newmod);
	}

void ExtrudeMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState * os, INode *node) 
	{	
//DebugPrint("Extrude modifying object\n");

	// Get our personal validity interval...
	Interval valid = GetValidity(t);
	// and intersect it with the channels we use as input (see ChannelsUsed)
	valid &= os->obj->ChannelValidity(t,TOPO_CHAN_NUM);
	valid &= os->obj->ChannelValidity(t,GEOM_CHAN_NUM);
	
	int output;
	pblock->GetValue(PB_OUTPUT, TimeValue(0), output, FOREVER);

	switch (output) {
	case NURBS_OUTPUT:
#ifndef NO_NURBS
		{
		// Here is where all the fun stuff happens -- GenerateExtrudeSurface fills in the EM,
		// then we stuff the EditableSurface into the pipeline.
		ShapeObject *shape = (ShapeObject *)os->obj;
			float amount;

		BOOL texturing, genMatIds, useShapeIDs;
		pblock->GetValue(PB_MAPPING, TimeValue(0), texturing, FOREVER);
		pblock->GetValue(PB_GEN_MATIDS, TimeValue(0), genMatIds, FOREVER);
		pblock->GetValue(PB_USE_SHAPEIDS, TimeValue(0), useShapeIDs, FOREVER);

		int levels,capStart,capEnd,capType;

		pblock->GetValue(PB_SEGS,t,levels,FOREVER);
		if (levels<1) levels = 1;
		pblock->GetValue(PB_CAPSTART,t,capStart,FOREVER);
		pblock->GetValue(PB_CAPEND,t,capEnd,FOREVER);
		pblock->GetValue(PB_CAPTYPE,t,capType,FOREVER);

		pblock->GetValue(PB_AMOUNT,t,amount,FOREVER);
		LimitValue(amount, -1000000.0f, 1000000.0f);


		BOOL suspended = FALSE;
		if (theHold.Holding()) {
			theHold.Suspend();
			suspended = TRUE;
		}
		Object *nobj = CreateNURBSExtrudeShape(ip, GetString(IDS_RB_EXTRUDE), t, shape, amount,
								capStart, capEnd, capType, texturing, genMatIds, useShapeIDs);
		if (suspended) {
			theHold.Resume();
		}

        // We only set geom validity because we preserve animation on clone
        // and copying other cahnnels causes problems -- SCM 9/2/97
		nobj->SetChannelValidity(GEOM_CHAN_NUM, valid);

		os->obj = nobj;
		break;}
#endif
	case PATCH_OUTPUT: {
		// Here is where all the fun stuff happens -- BuildPatchFromShape fills in the PatchObject's patch mesh,
		// then we stuff the PatchObject into the pipeline.
		PatchObject *pat = new PatchObject;
		BuildPatchFromShape(t, mc, os, pat->patch);

		pat->SetChannelValidity(TOPO_CHAN_NUM, valid);
		pat->SetChannelValidity(GEOM_CHAN_NUM, valid);
		pat->SetChannelValidity(TEXMAP_CHAN_NUM, valid);
		pat->SetChannelValidity(MTL_CHAN_NUM, valid);
		pat->SetChannelValidity(SELECT_CHAN_NUM, valid);
		pat->SetChannelValidity(SUBSEL_TYPE_CHAN_NUM, valid);
		pat->SetChannelValidity(DISP_ATTRIB_CHAN_NUM, valid);

		os->obj = pat;
		break;}
	case MESH_OUTPUT: {
		// Here is where all the fun stuff happens -- BuildMeshFromShape fills in the TriObject's mesh,
		// then we stuff the TriObj into the pipeline.
		TriObject *tri = CreateNewTriObject();
		BuildMeshFromShape(t, mc, os, tri->GetMesh());

		tri->SetChannelValidity(TOPO_CHAN_NUM, valid);
		tri->SetChannelValidity(GEOM_CHAN_NUM, valid);
		tri->SetChannelValidity(TEXMAP_CHAN_NUM, valid);
		tri->SetChannelValidity(MTL_CHAN_NUM, valid);
		tri->SetChannelValidity(SELECT_CHAN_NUM, valid);
		tri->SetChannelValidity(SUBSEL_TYPE_CHAN_NUM, valid);
		tri->SetChannelValidity(DISP_ATTRIB_CHAN_NUM, valid);

		os->obj = tri;
		break; }
#ifdef DESIGN_VER
	case AMSOLID_OUTPUT: {
		//Create an extrusion solid using Facet Modeler
		Object* solid = (Object*)CreateInstance(GEOMOBJECT_CLASS_ID, GENERIC_AMSOLID_CLASS_ID);
		assert(solid);
		if(solid)
		{
			IGeomImp* cacheptr = (IGeomImp*)(solid->GetInterface(I_GEOMIMP));
			assert(cacheptr);
			if(cacheptr)
			{
				bool res = BuildAMSolidFromShape(t, mc, os, cacheptr);
				solid->ReleaseInterface(I_GEOMIMP, cacheptr);
				if(res)
				{
					solid->SetChannelValidity(TOPO_CHAN_NUM, valid);
					solid->SetChannelValidity(GEOM_CHAN_NUM, valid);
					solid->SetChannelValidity(TEXMAP_CHAN_NUM, valid);
					solid->SetChannelValidity(MTL_CHAN_NUM, valid);
					solid->SetChannelValidity(SELECT_CHAN_NUM, valid);
					solid->SetChannelValidity(SUBSEL_TYPE_CHAN_NUM, valid);
					solid->SetChannelValidity(DISP_ATTRIB_CHAN_NUM, valid);

					os->obj = solid;
				}
			}

		}

		break; }
#endif
	}

	os->obj->UnlockObject();
	}


void ExtrudeMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	this->ip = ip;
	editMod = this;

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);

	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGTH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_EXTRUDEPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);	
	pmapParam->SetUserDlgProc(&dlgProc);
	}

void ExtrudeMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next)
	{
	this->ip = NULL;
	editMod = NULL;
	
	TimeValue t = ip->GetTime();

	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);
	ClearAFlag(A_MOD_BEING_EDITED);

	DestroyCPParamMap(pmapParam);

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_AMOUNT,ip->GetTime(),dlgAmount,FOREVER);
	pblock->GetValue(PB_SEGS,ip->GetTime(),dlgSegs,FOREVER);
	if (dlgSegs<1) dlgSegs = 1;
	pblock->GetValue(PB_CAPSTART,ip->GetTime(),dlgCapStart,FOREVER);
	pblock->GetValue(PB_CAPEND,ip->GetTime(),dlgCapEnd,FOREVER);
	pblock->GetValue(PB_CAPTYPE,ip->GetTime(),dlgCapType,FOREVER);
	pblock->GetValue(PB_OUTPUT,ip->GetTime(),dlgOutput,FOREVER);
	pblock->GetValue(PB_MAPPING,ip->GetTime(),dlgMapping,FOREVER);
	pblock->GetValue(PB_GEN_MATIDS,ip->GetTime(),dlgGenMatIDs,FOREVER);
	pblock->GetValue(PB_USE_SHAPEIDS,ip->GetTime(),dlgUseShapeIDs,FOREVER);
	pblock->GetValue(PB_SMOOTH,ip->GetTime(),dlgSmooth,FOREVER);
	}

Interval ExtrudeMod::GetValidity(TimeValue t)
	{
	float f;
	int i;
	Interval valid = FOREVER;
	pblock->GetValue(PB_AMOUNT,t,f,valid);
	pblock->GetValue(PB_SEGS,t,i,valid);	
	pblock->GetValue(PB_CAPSTART,t,i,valid);
	pblock->GetValue(PB_CAPEND,t,i,valid);
	pblock->GetValue(PB_CAPTYPE,t,i,valid);
	return valid;
	}

RefResult ExtrudeMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message ) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
			if ((editMod==this) && pmapParam) pmapParam->Invalidate();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}

ParamDimension *ExtrudeMod::GetParameterDim(int pbIndex)
	{
	switch (pbIndex) {
		case PB_AMOUNT: 	return stdWorldDim;
		case PB_SEGS:		return defaultDim;
		case PB_CAPSTART:	return defaultDim;
		case PB_CAPEND:		return defaultDim;
		case PB_CAPTYPE:	return defaultDim;
		default:			return defaultDim;
		}
	}

TSTR ExtrudeMod::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_AMOUNT:		return TSTR(GetString(IDS_TH_AMOUNT));
		case PB_SEGS:		return TSTR(GetString(IDS_TH_SEGMENTS));
		default:			return TSTR(_T(""));
		}
	}

BOOL ExtrudeMod::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_MAPPING, 0, genUVs, v);
	return genUVs; 
	}

void ExtrudeMod::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_MAPPING,0, sw);				
	}

BOOL ExtrudeMod::GetGenMatIDs() {
	int sw;
	Interval v;
	pblock->GetValue(PB_GEN_MATIDS, 0, sw, v);
	return sw;
	}

class ExtrudePostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		ExtrudePostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload);
	};

void ExtrudePostLoadCallback::proc(ILoad *iload) {
	DWORD oldVer = ((ExtrudeMod*)(cb->targ))->pblock->GetVersion();
	ReferenceTarget *targ = cb->targ;
	cb->proc(iload);
	if (oldVer<4)
		((ExtrudeMod*)targ)->pblock->SetValue(PB_GEN_MATIDS,0,FALSE);
	if (oldVer<5)
		((ExtrudeMod*)targ)->pblock->SetValue(PB_USE_SHAPEIDS,0,FALSE);
	if (oldVer<6)
		((ExtrudeMod*)targ)->pblock->SetValue(PB_SMOOTH,0,TRUE);
	delete this;
	}

IOResult ExtrudeMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	iload->RegisterPostLoadCallback(
		new ExtrudePostLoadCallback(
			new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0)));
	return IO_OK;
	}

static void MakeMeshCapTexture(Mesh &mesh, Matrix3 &itm, int fstart, int fend) {
	if(fstart == fend)
		return;
	// Find out which verts are used by the cap
	BitArray capVerts(mesh.numVerts);
	capVerts.ClearAll();
	for(int i = fstart; i < fend; ++i) {
		Face &f = mesh.faces[i];
		capVerts.Set(f.v[0]);
		capVerts.Set(f.v[1]);
		capVerts.Set(f.v[2]);
		}
	// Minmax the verts involved in X/Y axis and total them
	Box3 bounds;
	int numCapVerts = 0;
	int numCapFaces = fend - fstart;
	IntTab capIndexes;
	capIndexes.SetCount(mesh.numVerts);
	int baseTVert = mesh.getNumTVerts();
	for(i = 0; i < mesh.numVerts; ++i) {
		if(capVerts[i]) {
			capIndexes[i] = baseTVert + numCapVerts++;
			bounds += mesh.verts[i] * itm;
			}
		}
	mesh.setNumTVerts(baseTVert + numCapVerts, TRUE);
	Point3 s(1.0f / bounds.Width().x, 1.0f / bounds.Width().y, 0.0f);
	Point3 t(-bounds.Min().x, -bounds.Min().y, 0.0f);
	// Do the TVerts
	for(i = 0; i < mesh.numVerts; ++i) {
		if(capVerts[i])
			mesh.setTVert(baseTVert++, ((mesh.verts[i] * itm) + t) * s);
		}
	// Do the TVFaces
	for(i = fstart; i < fend; ++i) {
		Face &f = mesh.faces[i];
		mesh.tvFace[i] = TVFace(capIndexes[f.v[0]], capIndexes[f.v[1]], capIndexes[f.v[2]]);
		}
	}

void ExtrudeMod::BuildMeshFromShape(TimeValue t,ModContext &mc, ObjectState * os, Mesh &mesh, BOOL simple) {
	BOOL texturing;
	pblock->GetValue(PB_MAPPING, TimeValue(0), texturing, FOREVER);
	BOOL genMatIDs;
	pblock->GetValue(PB_GEN_MATIDS, TimeValue(0), genMatIDs, FOREVER);
	BOOL useShapeIDs;
	pblock->GetValue(PB_USE_SHAPEIDS, TimeValue(0), useShapeIDs, FOREVER);
	BOOL smooth;
	pblock->GetValue(PB_SMOOTH, TimeValue(0), smooth, FOREVER);

	ShapeObject *shape = (ShapeObject *)os->obj;

	float amount;
	int levels,capStart,capEnd,capType;

	pblock->GetValue(PB_AMOUNT,t,amount,FOREVER);
	if(simple) {
		levels = 1;
		capStart = capEnd = FALSE;
		}
	else {
		pblock->GetValue(PB_SEGS,t,levels,FOREVER);
		if (levels<1) levels = 1;
		pblock->GetValue(PB_CAPSTART,t,capStart,FOREVER);
		pblock->GetValue(PB_CAPEND,t,capEnd,FOREVER);
		}
	pblock->GetValue(PB_CAPTYPE,t,capType,FOREVER);

	LimitValue(amount, -1000000.0f, 1000000.0f);

	// Get the basic dimension stuff
	float zSize = (float)fabs(amount);
	float baseZ = 0.0f;
	if(amount < 0.0f)
		baseZ = amount;

	// Make the shape convert itself to a PolyShape -- This makes our mesh conversion MUCH easier!
	
	PolyShape pShape;
	shape->MakePolyShape(t, pShape);
	ShapeHierarchy hier;
	pShape.OrganizeCurves(t, &hier);
	// Need to flip the reversed curves in the shape!
	pShape.Reverse(hier.reverse);

	int polys = pShape.numLines;
	int levelVerts = 0, levelFaces = 0, levelTVerts = 0;
	int verts = 0, faces = 0, tVerts = 0;
	int poly, piece;

	BOOL anyClosed = FALSE;
	for(poly = 0; poly < polys; ++poly) {
		PolyLine &line = pShape.lines[poly];
		if(!line.numPts)
			continue;
		if(line.IsClosed()) {
			anyClosed = TRUE;
			levelTVerts++;
			}
		levelVerts += line.numPts;
		levelTVerts += line.numPts;
		levelFaces += (line.Segments() * 2);
		}

	int vertsPerLevel = levelVerts;
	int numLevels = levels;

	verts = levelVerts * (levels + 1);
	tVerts = levelTVerts * (levels + 1);
	faces = levelFaces * levels;

	mesh.setNumVerts(verts);
	mesh.setNumFaces(faces);
	if(texturing) {
		mesh.setNumTVerts(tVerts);
		mesh.setNumTVFaces(faces);
		}

	// Create the vertices!
	int vert = 0;
	int tvertex = 0;
	int level;
	Point3 offset1, offset2;
	for(poly = 0; poly < polys; ++poly) {
		PolyLine &line = pShape.lines[poly];
		if(!line.numPts)
			continue;
		if(texturing) {
//DebugPrint("Texture Verts:\n");
			int tp;
			int texPts = line.numPts + (line.IsClosed() ? 1 : 0);
			float *texPt = new float [texPts];
			float lastPt = (float)(texPts - 1);
			float cumLen = 0.0f;
			float totLen = line.CurveLength();
			Point3 prevPt = line.pts[0].p;
			for(tp = 0; tp < texPts; ++tp) {
				int ltp = tp % line.numPts;
				if(tp == (texPts - 1))
					texPt[tp] = 1.0f;
				else {
					Point3 &pt = line.pts[ltp].p;
					cumLen += Length(pt - prevPt);
					texPt[tp] = cumLen / totLen;
					prevPt = pt;
					}
				}
			float flevels = (float)levels;
			for(level = 0; level <= levels; ++level) {
				float tV = (float)level / flevels;
				for(tp = 0; tp < texPts; ++tp) {
					mesh.setTVert(tvertex++, UVVert(texPt[tp], tV, 0.0f));
					}
				}
			delete [] texPt;
			}
		int lverts = line.numPts;
		for(level = 0; level <= levels; ++level) {
			Point3 offset = Point3(0.0f, 0.0f, baseZ + (float)level / (float)levels * zSize);
			if(level == 0)
				offset1 = offset;
			else
			if(level == levels)
				offset2 = offset;
			for(int v = 0; v < lverts; ++v) {
				line.pts[v].aux = vert;			// Gives the capper this vert's location in the mesh!
				mesh.setVert(vert++, line.pts[v].p + offset);
				}
			}
		}
	assert(vert == verts);

	// If capping, do it!
	if(anyClosed && (capStart || capEnd)) {
		MeshCapInfo capInfo;
		pShape.MakeCap(t, capInfo, capType);
		// Build information for capping
		MeshCapper capper(pShape);
		if(capStart) {
			vert = 0;
			for(poly = 0; poly < polys; ++poly) {
				PolyLine &line = pShape.lines[poly];
				if(!line.numPts)
					continue;
				MeshCapPoly &capline = capper[poly];
				int lverts = line.numPts;
				for(int v = 0; v < lverts; ++v)
					capline.SetVert(v, vert++);			// Gives this vert's location in the mesh!
				vert += lverts * levels;
				}
			// Create a work matrix for grid capping
			Matrix3 gridMat = TransMatrix(offset1);
			int oldFaces = mesh.numFaces;
			capper.CapMesh(mesh, capInfo, TRUE, 16, &gridMat, genMatIDs ? -1 : 0);
			// If texturing, create the texture faces and vertices
			if(texturing)
				MakeMeshCapTexture(mesh, Inverse(gridMat), oldFaces, mesh.numFaces);
			}
		if(capEnd) {
			int baseVert = 0;
			for(poly = 0; poly < polys; ++poly) {
				PolyLine &line = pShape.lines[poly];
				if(!line.numPts)
					continue;
				MeshCapPoly &capline = capper[poly];
				int lverts = line.numPts;
				vert = baseVert + lverts * levels;
				for(int v = 0; v < lverts; ++v)
					capline.SetVert(v, vert++);			// Gives this vert's location in the mesh!
				baseVert += lverts * (levels + 1);
				}
			// Create a work matrix for grid capping
			Matrix3 gridMat = TransMatrix(offset2);
			int oldFaces = mesh.numFaces;
			capper.CapMesh(mesh, capInfo, FALSE, 16, &gridMat, genMatIDs ? -1 : 0);
			// If texturing, create the texture faces and vertices
			if(texturing)
				MakeMeshCapTexture(mesh, Inverse(gridMat), oldFaces, mesh.numFaces);
			}
		}

	// Create the faces!
	int face = 0;
	int TVface = 0;
	int baseVert = 0;
	int baseTVert = 0;
	for(poly = 0; poly < polys; ++poly) {
		PolyLine &line = pShape.lines[poly];
		if(!line.numPts)
			continue;
		int pieces = line.Segments();
		int closed = line.IsClosed();
		int segVerts = pieces + ((closed) ? 0 : 1);
		int segTVerts = pieces + 1;
		for(level = 0; level < levels; ++level) {
			int sm = 0;		// Initial smoothing group
			BOOL firstSmooth = (line.pts[0].flags & POLYPT_SMOOTH) ? TRUE : FALSE;
			for(piece = 0; piece < pieces; ++piece) {
				int v1 = baseVert + piece;
				int v2 = baseVert + ((piece + 1) % segVerts);
				int v3 = v1 + segVerts;
				int v4 = v2 + segVerts;
				// If the vertex is not smooth, go to the next group!
				BOOL thisSmooth = line.pts[piece].flags & POLYPT_SMOOTH;
				MtlID mtl = useShapeIDs ? line.pts[piece].GetMatID() : 2;
				if(piece > 0 && !thisSmooth) {
					sm++;
					if(sm > 2)
						sm = 1;
					}
				DWORD smoothGroup = 1 << sm;
				// Advance to the next smoothing group right away
				if(sm == 0)
					sm++;
				// Special case for smoothing from first segment
				if(piece == 1 && thisSmooth)
					smoothGroup |= 1;
				// Special case for smoothing from last segment
				if((piece == pieces - 1) && firstSmooth)
					smoothGroup |= 1;
				mesh.faces[face].setEdgeVisFlags(1,1,0);
				mesh.faces[face].setSmGroup(smooth ? smoothGroup : 0);
				mesh.faces[face].setMatID(genMatIDs ? mtl : 0);
				mesh.faces[face++].setVerts(v1, v2, v4);
				mesh.faces[face].setEdgeVisFlags(0,1,1);
				mesh.faces[face].setSmGroup(smooth ? smoothGroup : 0);
				mesh.faces[face].setMatID(genMatIDs ? mtl : 0);
				mesh.faces[face++].setVerts(v1, v4, v3);
//DebugPrint("BV:%d V:%d v1:%d v2:%d v3:%d v4:%d\n",baseVert, vert, v1, v2, v3, v4);
				if(texturing) {
					int tv1 = baseTVert + piece;
					int tv2 = tv1 + 1;
					int tv3 = tv1 + segTVerts;
					int tv4 = tv2 + segTVerts;
					mesh.tvFace[TVface++].setTVerts(tv1, tv2, tv4);
					mesh.tvFace[TVface++].setTVerts(tv1, tv4, tv3);
					}
				}
			baseVert += segVerts;
			baseTVert += segTVerts;
			}
		baseVert += segVerts;	// Increment to next poly start (skips last verts of this poly)
		baseTVert += segTVerts;
		}
	assert(face == faces);

	mesh.InvalidateGeomCache();
	}

static void MakePatchCapTexture(PatchMesh &pmesh, Matrix3 &itm, int pstart, int pend) {
	if(pstart == pend)
		return;

	// Find out which verts are used by the cap
	BitArray capVerts(pmesh.numVerts);
	capVerts.ClearAll();
	for(int i = pstart; i < pend; ++i) {
		Patch &p = pmesh.patches[i];
		capVerts.Set(p.v[0]);
		capVerts.Set(p.v[1]);
		capVerts.Set(p.v[2]);
		if(p.type == PATCH_QUAD)
			capVerts.Set(p.v[3]);
		}
	// Minmax the verts involved in X/Y axis and total them
	Box3 bounds;
	int numCapVerts = 0;
	int numCapPatches = pend - pstart;
	IntTab capIndexes;
	capIndexes.SetCount(pmesh.numVerts);
	int baseTVert = pmesh.getNumTVerts();
	for(i = 0; i < pmesh.numVerts; ++i) {
		if(capVerts[i]) {
			capIndexes[i] = baseTVert + numCapVerts++;
			bounds += pmesh.verts[i].p * itm;
			}
		}
	pmesh.setNumTVerts(baseTVert + numCapVerts, TRUE);
	Point3 s(1.0f / bounds.Width().x, 1.0f / bounds.Width().y, 0.0f);
	Point3 t(-bounds.Min().x, -bounds.Min().y, 0.0f);
	// Do the TVerts
	for(i = 0; i < pmesh.numVerts; ++i) {
		if(capVerts[i])
			pmesh.setTVert(baseTVert++, ((pmesh.verts[i].p * itm) + t) * s);
		}
	// Do the TVPatches
	for(i = pstart; i < pend; ++i) {
		Patch &p = pmesh.patches[i];
		TVPatch &tp = pmesh.getTVPatch(i);
		if(p.type == PATCH_TRI)
			tp.setTVerts(capIndexes[p.v[0]], capIndexes[p.v[1]], capIndexes[p.v[2]]);
		else
			tp.setTVerts(capIndexes[p.v[0]], capIndexes[p.v[1]], capIndexes[p.v[2]], capIndexes[p.v[3]]);
		}
	}

// Quad patch layout
//
//   A---> ad ----- da <---D
//   |                     |
//   |                     |
//   v                     v
//   ab    i1       i4     dc
//
//   |                     |
//   |                     |
// 
//   ba    i2       i3     cd
//   ^					   ^
//   |                     |
//   |                     |
//   B---> bc ----- cb <---C
//
// vertices ( a b c d ) are in counter clockwise order when viewed from 
// outside the surface

void ExtrudeMod::BuildPatchFromShape(TimeValue t,ModContext &mc, ObjectState * os, PatchMesh &pmesh) {
	ShapeObject *shape = (ShapeObject *)os->obj;

	float amount;
	int levels,capStart,capEnd,capType;

	pblock->GetValue(PB_AMOUNT,t,amount,FOREVER);
	pblock->GetValue(PB_SEGS,t,levels,FOREVER);
	if (levels<1) levels = 1;
	pblock->GetValue(PB_CAPSTART,t,capStart,FOREVER);
	pblock->GetValue(PB_CAPEND,t,capEnd,FOREVER);
	pblock->GetValue(PB_CAPTYPE,t,capType,FOREVER);

	BOOL texturing;
	pblock->GetValue(PB_MAPPING, TimeValue(0), texturing, FOREVER);
	BOOL genMatIDs;
	pblock->GetValue(PB_GEN_MATIDS, TimeValue(0), genMatIDs, FOREVER);
	BOOL useShapeIDs;
	pblock->GetValue(PB_USE_SHAPEIDS, TimeValue(0), useShapeIDs, FOREVER);
	BOOL smooth;
	pblock->GetValue(PB_SMOOTH, TimeValue(0), smooth, FOREVER);

	LimitValue(amount, -1000000.0f, 1000000.0f);

	// Get the basic dimension stuff
	float zSize = (float)fabs(amount);
	float baseZ = 0.0f;
	if(amount < 0.0f)
		baseZ = amount;

	// If the shape can convert itself to a BezierShape, have it do so!
	BezierShape bShape;
	if(shape->CanMakeBezier())
		shape->MakeBezier(t, bShape);
	else {
		PolyShape pShape;
		shape->MakePolyShape(t, pShape);
		bShape = pShape;	// UGH -- Convert it from a PolyShape -- not good!
		}
	
//DebugPrint("Extrude organizing shape\n");
	ShapeHierarchy hier;
	bShape.OrganizeCurves(t, &hier);
	// Need to flip the reversed polys...
	bShape.Reverse(hier.reverse);
	// ...and tell the hierarchy they're no longer reversed!
	hier.reverse.ClearAll();

	// Our shapes are now organized for patch-making -- Let's do the sides!
	int polys = bShape.splineCount;
	int poly, knot;
	int levelVerts = 0, levelVecs = 0, levelPatches = 0, nverts = 0, nvecs = 0, npatches = 0;
	int TVlevels = levels + 1, levelTVerts = 0, ntverts = 0, ntpatches = 0;
	BOOL anyClosed = FALSE;
	for(poly = 0; poly < polys; ++poly) {
		Spline3D *spline = bShape.splines[poly];
		if(!spline->KnotCount())
			continue;
		if(spline->Closed())
			anyClosed = TRUE;
		levelVerts += spline->KnotCount();
		levelTVerts += (spline->Segments() + 1);
		levelVecs += (spline->Segments() * 2);
		levelPatches += spline->Segments();
		}
	nverts = levelVerts * (levels + 1);
	npatches = levelPatches * levels;
	nvecs = (levelVecs * (levels + 1)) + levels * levelVerts * 2 + npatches * 4;
	if(texturing) {
		ntverts = levelTVerts * TVlevels;
		ntpatches = npatches;
		}

	pmesh.setNumVerts(nverts);
	pmesh.setNumVecs(nvecs);
	pmesh.setNumPatches(npatches);
	pmesh.setNumTVerts(ntverts);
	pmesh.setNumTVPatches(ntpatches);

	// Create the vertices!
	int vert = 0;
	int level;
	Point3 offset1, offset2;
	for(poly = 0; poly < polys; ++poly) {
		Spline3D *spline = bShape.splines[poly];
		if(!spline->KnotCount())
			continue;
		int knots = spline->KnotCount();
		for(level = 0; level <= levels; ++level) {
			Point3 offset = Point3(0.0f, 0.0f, baseZ + (float)level / (float)levels * zSize);
			if(level == 0)
				offset1 = offset;
			else
			if(level == levels)
				offset2 = offset;
			for(knot = 0; knot < knots; ++knot) {
				Point3 p = spline->GetKnotPoint(knot);
				pmesh.setVert(vert++, p + offset);
				}
			}
		}
	assert(vert == nverts);

	// Maybe create the texture vertices
	if(texturing) {
		int tvert = 0;
		int level;
		for(poly = 0; poly < polys; ++poly) {
			Spline3D *spline = bShape.splines[poly];
			if(!spline->KnotCount())
				continue;
			// Make it a polyline
			PolyLine pline;
			spline->MakePolyLine(pline, 10);
			int knots = spline->KnotCount();
			for(level = 0; level < TVlevels; ++level) {
				float tV = (float)level / (float)(TVlevels - 1);
				int lverts = pline.numPts;
				int tp = 0;
				int texPts = spline->Segments() + 1;
				float cumLen = 0.0f;
				float totLen = pline.CurveLength();
				Point3 prevPt = pline.pts[0].p;
				int plix = 0;
				while(tp < texPts) {
					Point3 &pt = pline[plix].p;
					cumLen += Length(pt - prevPt);
					prevPt = pt;
					if(pline[plix].flags & POLYPT_KNOT) {
						float tU;
						if(tp == (texPts - 1))
							tU = 1.0f;
						else
							tU = cumLen / totLen;
						pmesh.setTVert(tvert++, UVVert(tU, tV, 0.0f));
						tp++;
						}
					plix = (plix + 1) % pline.numPts;
					}
				}
			}
		assert(tvert == ntverts);
		}

	// Create the vectors!
	int seg;
	int vec = 0;
	for(poly = 0; poly < polys; ++poly) {
		Spline3D *spline = bShape.splines[poly];
		if(!spline->KnotCount())
			continue;
		int segs = spline->Segments();
		int knots = spline->KnotCount();
		// First, the vectors on each level
		for(level = 0; level <= levels; ++level) {
			Point3 offset = Point3(0.0f, 0.0f, baseZ + (float)level / (float)levels * zSize);
			for(seg = 0; seg < segs; ++seg) {
				int seg2 = (seg + 1) % knots;
				if(spline->GetLineType(seg) == LTYPE_CURVE) {
					Point3 p = spline->GetOutVec(seg);
					pmesh.setVec(vec++, p + offset);
					p = spline->GetInVec(seg2);
					pmesh.setVec(vec++, p + offset);
					}
				else {
					Point3 p = spline->InterpBezier3D(seg, 0.333333f);
					pmesh.setVec(vec++, p + offset);
					p = spline->InterpBezier3D(seg, 0.666666f);
					pmesh.setVec(vec++, p + offset);
					}
				}
			}
		// Now, the vectors between the levels
		int baseVec = vec;
		for(level = 0; level < levels; ++level) {
			Point3 offsetA = Point3(0.0f, 0.0f, baseZ + (float)level / (float)levels * zSize);
			Point3 offsetB = Point3(0.0f, 0.0f, baseZ + (float)(level + 1) / (float)levels * zSize);
			Point3 offset1 = offsetA + (offsetB - offsetA) * 0.333333333f;
			Point3 offset2 = offsetA + (offsetB - offsetA) * 0.666666666f;
			for(knot = 0; knot < knots; ++knot) {
				Point3 p = spline->GetKnotPoint(knot);
				pmesh.setVec(vec++, p + offset1);
				pmesh.setVec(vec++, p + offset2);
				}
			}
		}

	// Create the patches!
	int np = 0;
	int baseVert = 0;
	int baseVec = 0;
	for(poly = 0; poly < polys; ++poly) {
		Spline3D *spline = bShape.splines[poly];
		if(!spline->KnotCount())
			continue;
		int knots = spline->KnotCount();
		int segs = spline->Segments();
		int baseVec1 = baseVec;	// Base vector index for this level
		int baseVec2 = baseVec + segs * 2 * (levels + 1);	// Base vector index for between levels
		for(level = 0; level < levels; ++level) {
			int sm = 0;
			BOOL firstSmooth = (spline->GetLineType(0) == LTYPE_CURVE && spline->GetLineType(segs-1) == LTYPE_CURVE && (spline->GetKnotType(0) == KTYPE_AUTO || spline->GetKnotType(0) == KTYPE_BEZIER)) ? TRUE : FALSE;
			for(seg = 0; seg < segs; ++seg, vec += 4) {
				int prevseg = (seg + segs - 1) % segs;
				int seg2 = (seg + 1) % knots;
				int a,b,c,d,ab,ba,bc,cb,cd,dc,da,ad;
				MtlID mtl = useShapeIDs ? spline->GetMatID(seg) : 2;
				a = baseVert + seg;
				b = baseVert + seg2;
				c = b + knots;
				d = a + knots;
				ab = baseVec1 + seg * 2;
				ba = ab + 1;
				bc = baseVec2 + seg2 * 2;
				cb = bc + 1;
				cd = ba + (segs * 2);
				dc = ab + (segs * 2);
				da = baseVec2 + seg * 2 + 1;
				ad = da - 1;
//DebugPrint("Making patch %d: %d (%d %d) %d (%d %d) %d (%d %d) %d (%d %d)\n",np, a, ab, ba, b, bc, cb, c, cd, dc, d, da, ad);
				// If the vertex is not smooth, go to the next group!
				if(seg > 0 && !(spline->GetLineType(prevseg) == LTYPE_CURVE && spline->GetLineType(seg) == LTYPE_CURVE && (spline->GetKnotType(seg) == KTYPE_AUTO || spline->GetKnotType(seg) == KTYPE_BEZIER))) {
					sm++;
					if(sm > 2)
						sm = 1;
					}
				DWORD smoothGroup = 1 << sm;
				if(seg == segs - 1 && firstSmooth) {
					smoothGroup |= 1;
					}
				pmesh.MakeQuadPatch(np, a, ab, ba, b, bc, cb, c, cd, dc, d, da, ad, vec, vec+1, vec+2, vec+3, smooth ? smoothGroup : 0);
				pmesh.setPatchMtlIndex(np++, genMatIDs ? mtl : 0);
				}
			baseVert += knots;
			baseVec1 += (segs * 2);
			baseVec2 += (knots * 2);
			}
		baseVert += knots;
		baseVec += (segs * 2 * (levels + 1) + knots * 2 * levels);
		}
	assert(vec == nvecs);
	assert(np == npatches);

 	// Maybe create the texture patches!
	if(texturing) {
		int ntp = 0;
		int baseTVert = 0;
		for(poly = 0; poly < polys; ++poly) {
			Spline3D *spline = bShape.splines[poly];
			if(!spline->KnotCount())
				continue;
			int pknots = spline->Segments() + 1;
			int pverts = pknots * TVlevels;
			int segs = spline->Segments();
			for(level = 0; level < levels; ++level) {
				for(seg = 0; seg < segs; ++seg) {
					int prevseg = (seg + segs - 1) % segs;
					int seg2 = seg + 1;
					int a,b,c,d;
					a = baseTVert + seg;
					b = baseTVert + seg2;
					c = b + pknots;
					d = a + pknots;
					TVPatch &tp = pmesh.getTVPatch(ntp++);
					tp.setTVerts(a, b, c, d);
					}
				baseTVert += pknots;
				}
			baseTVert += pknots;
			}
		assert(ntp == ntpatches);
		}

	// If capping, do it!
	if(anyClosed && (capStart || capEnd)) {
		PatchCapInfo capInfo;
		bShape.MakeCap(t, capInfo);

		// Build information for capping
		PatchCapper capper(bShape);
		if(capStart) {
			vert = 0;
			int baseVec = 0;
			for(poly = 0; poly < polys; ++poly) {
				Spline3D *spline = bShape.splines[poly];
				if(!spline->KnotCount())
					continue;
				PatchCapPoly &capline = capper[poly];
				int lverts = spline->KnotCount();
				for(int v = 0; v < lverts; ++v)
					capline.SetVert(v, vert++);			// Gives this vert's location in the mesh!
				vert += lverts * levels;
				vec = baseVec;
				int lvecs = spline->Segments() * 2;
				for(v = 0; v < lvecs; ++v)
					capline.SetVec(v, vec++);			// Gives this vec's location in the mesh!
				baseVec += lvecs * (levels + 1) + spline->KnotCount() * levels * 2;
				}
			// Create a work matrix for capping
			Matrix3 mat = TransMatrix(offset1);
			int oldPatches = pmesh.numPatches;
			capper.CapPatchMesh(pmesh, capInfo, TRUE, 16, &mat, genMatIDs ? -1 : 0);
			// If texturing, create the texture patches and vertices
			if(texturing)
				MakePatchCapTexture(pmesh, Inverse(mat), oldPatches, pmesh.numPatches);
			}
		if(capEnd) {
			int baseVert = 0;
			int baseVec = 0;
			for(poly = 0; poly < polys; ++poly) {
				Spline3D *spline = bShape.splines[poly];
				if(!spline->KnotCount())
					continue;
				PatchCapPoly &capline = capper[poly];
				int lverts = spline->KnotCount();
				int vert = baseVert + lverts * levels;
				for(int v = 0; v < lverts; ++v)
					capline.SetVert(v, vert++);			// Gives this vert's location in the mesh!
				baseVert += lverts * (levels + 1);
				int lvecs = spline->Segments()*2;
				int vec = baseVec + lvecs * levels;
				for(v = 0; v < lvecs; ++v)
					capline.SetVec(v, vec++);			// Gives this vec's location in the mesh!
				baseVec += lvecs * (levels + 1) + spline->KnotCount() * levels * 2;
				}
			// Create a work matrix for grid capping
			Matrix3 mat = TransMatrix(offset2);
			int oldPatches = pmesh.numPatches;
			capper.CapPatchMesh(pmesh, capInfo, FALSE, 16, &mat, genMatIDs ? -1 : 0);
			// If texturing, create the texture patches and vertices
			if(texturing)
				MakePatchCapTexture(pmesh, Inverse(mat), oldPatches, pmesh.numPatches);
			}
		}

	// Ready the patch representation!
	assert(pmesh.buildLinkages());
	pmesh.computeInteriors();
	}

#ifdef DESIGN_VER
bool ExtrudeMod::BuildAMSolidFromShape(TimeValue t,ModContext &mc, ObjectState * os, IGeomImp* igeom) 
{
	ShapeObject *shape = (ShapeObject *)os->obj;

	float amount;

	pblock->GetValue(PB_AMOUNT,t,amount,FOREVER);

	BOOL texturing;
	pblock->GetValue(PB_MAPPING, TimeValue(0), texturing, FOREVER);
	BOOL genMatIDs;
	pblock->GetValue(PB_GEN_MATIDS, TimeValue(0), genMatIDs, FOREVER);
	BOOL useShapeIDs;
	pblock->GetValue(PB_USE_SHAPEIDS, TimeValue(0), useShapeIDs, FOREVER);
	BOOL smooth;
	pblock->GetValue(PB_SMOOTH, TimeValue(0), smooth, FOREVER);

	LimitValue(amount, -1000000.0f, 1000000.0f);
	if(fabs(amount)<1.0E-3)
		amount = (float)1.0E-3;

	// Get the basic dimension stuff
	float zSize = (float)fabs(amount);
	float baseZ = 0.0f;
	if(amount < 0.0f)
		baseZ = amount;

	// If the shape can convert itself to a BezierShape, have it do so!
	BezierShape bShape;
	PolyShape pShape;
	shape->MakePolyShape(t, pShape, PSHAPE_BUILTIN_STEPS, true);

	//Now add the extrusion for each polygon
	bool res;

	//make a solid to hold our work
	Object* solid = (Object*)CreateInstance(GEOMOBJECT_CLASS_ID, GENERIC_AMSOLID_CLASS_ID);
	IGeomImp* workgeom = NULL;
	assert(solid);
	if(solid)
	{
		workgeom = (IGeomImp*)(solid->GetInterface(I_GEOMIMP));
		assert(workgeom);
	}

	for(int i=0;i<pShape.numLines; i++)
	{
		PolyLine poly = pShape.lines[i];
		res |= workgeom->createExtrusion(poly.pts, poly.numPts, amount, smooth, genMatIDs, useShapeIDs);
		igeom->operator+=(*workgeom);
	}

	//do some cleanup
	if(workgeom)
	{
		assert(solid);
		solid->ReleaseInterface(I_GEOMIMP, workgeom);
		solid->DeleteMe();
	}
	return res;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\gravity.cpp ===
/**********************************************************************
 *<
	FILE: gravity.cpp

	DESCRIPTION:  Gravity World Space Modifier

	CREATED BY: Rolf Berteig

	Separated out from Wind, add range hoops by Eric Peterson

	HISTORY: 10-30-95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

#define FORCE_PLANAR	0
#define FORCE_SPHERICAL	1

class GravityMtl: public Material {
	public:
	GravityMtl();
	};
static GravityMtl swMtl;

#define GRAVITY_R	float(.7)
#define GRAVITY_G	float(0)
#define GRAVITY_B	float(0)
const Point3 HOOPCOLOR(0.0f,0.0f,0.0f);

GravityMtl::GravityMtl():Material() 
{	Kd[0] = GRAVITY_R;
	Kd[1] = GRAVITY_G;
	Kd[2] = GRAVITY_B;
	Ks[0] = GRAVITY_R;
	Ks[1] = GRAVITY_G;
	Ks[2] = GRAVITY_B;
	shininess = (float)0.0;
	shadeLimit = GW_WIREFRAME|GW_BACKCULL;
	selfIllum = (float)1.0;
}

class ForceObject : public SimpleWSMObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
					
		ForceObject() {}
		BOOL SupportsDynamics() {return TRUE;}

		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack();		
		
		// From SimpleWSMObject		
		void InvalidateUI();		
		void BuildMesh(TimeValue t);

		virtual int DialogID()=0;
		virtual ParamUIDesc *UIDesc()=0;
		virtual int UIDescLength()=0;
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		void GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
	};
IObjParam *ForceObject::ip        = NULL;
IParamMap *ForceObject::pmapParam = NULL;
HWND       ForceObject::hSot      = NULL;

class GravityObject : public ForceObject {	
	public:									
		GravityObject();		

		// From Animatable		
		void DeleteThis() {delete this;}		
		Class_ID ClassID() {return Class_ID(GRAVITYOBJECT_CLASS_ID,0);}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_GRAVITY);}
						
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);
		ForceField *GetForceField(INode *node);

		// From SimpleWSMObject				
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		int DialogID() {return IDD_GRAVITYPARAM;}
		ParamUIDesc *UIDesc();
		int UIDescLength();

		// from ref
		IOResult Load(ILoad *iload);


	};

//--- ClassDescriptor and class vars ---------------------------------

class GravityClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new GravityObject;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_GRAVITY_CLASS);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return Class_ID(GRAVITYOBJECT_CLASS_ID,0);}
	const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_BOTH);}
	};

static GravityClassDesc gravityDesc;
ClassDesc* GetGravityObjDesc() {return &gravityDesc;}


//--- GravityMod -----------------------------------------------------

class GravityMod;

class GravityField : public ForceField {
	public:
		GravityObject *obj;
		INode *node;
		Matrix3 tm;
		Interval tmValid;
		Point3 force;
		Interval fValid;
		int type;
		Point3 Force(TimeValue t,const Point3 &pos, const Point3 &vel,int index);
		void DeleteThis() {delete this;} // RB 5/12/99
	};

class GravityMod : public SimpleWSMMod {
	public:				
		GravityField force;

		GravityMod() {}
		GravityMod(INode *node,GravityObject *obj);		

		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_RB_GRAVITYMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return Class_ID(GRAVITYMOD_CLASS_ID,0);}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_GRAVITYBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};

//--- ClassDescriptor and class vars ---------------------------------

class GravityModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) {return new GravityMod;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_GRAVITYMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(GRAVITYMOD_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};

static GravityModClassDesc gravityModDesc;
ClassDesc* GetGravityModDesc() {return &gravityModDesc;}

//--- GravityObject Parameter map/block descriptors ------------------

#define PB_STRENGTH		0
#define PB_DECAY		1
#define PB_TYPE			2
#define PB_DISPLENGTH	3
#define PB_HOOPSON		4

//
//
// Parameters

static int typeIDs[] = {IDC_FORCE_PLANAR,IDC_FORCE_SPHERICAL};

static ParamUIDesc descParamGrav[] = {
	// Strength
	ParamUIDesc(
		PB_STRENGTH,
		EDITTYPE_FLOAT,
		IDC_GRAV_STRENGTH,IDC_GRAV_STRENGTHSPIN,
		-9999999.0f, 9999999.0f,
		0.01f),

	// Decay
	ParamUIDesc(
		PB_DECAY,
		EDITTYPE_FLOAT,
		IDC_GRAV_DECAY,IDC_GRAV_DECAYSPIN,
		0.0f, 9999999.0f,
		0.001f),

	// Force type
	ParamUIDesc(PB_TYPE,TYPE_RADIO,typeIDs,2),

	// Display length
	ParamUIDesc(
		PB_DISPLENGTH,
		EDITTYPE_UNIVERSE,
		IDC_DISPLENGTH,IDC_DISPLENGTHSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Use  Range Hoops Checkbox
	ParamUIDesc(PB_HOOPSON,TYPE_SINGLECHEKBOX,IDC_EP_HOOPSON),

	};

#define GRAVPARAMDESC_LENGTH	5

// parameter block for version zero
ParamBlockDescID descGravVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_FLOAT, NULL, FALSE, 3 },
};

//parameter block for version 1
ParamBlockDescID descGravVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_FLOAT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
};

#define GRAVPBLOCK_LENGTH	5

static ParamVersionDesc gravversions[] = {
	ParamVersionDesc(descGravVer0,4,0),
	};

#define CURRENT_GRAVVERSION	1
#define NUM_OLDVERSIONS		1

static ParamVersionDesc gravcurVersion(descGravVer1,GRAVPBLOCK_LENGTH,CURRENT_GRAVVERSION);

//--- ForceObject Methods ---------------------------------------------

void ForceObject::BeginEditParams(
		IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapParam) {		
		// Left over from last SinWave ceated
		pmapParam->SetParamBlock(pblock);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_WINDGRAV_SOT),
			DefaultSOTProc,
			GetString(IDS_RB_SOT), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			UIDesc(),UIDescLength(),
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(DialogID()),
			GetString(IDS_RB_PARAMETERS),
			0);
		}
	}

void ForceObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	}
class ModDrawLineProc:public PolyLineProc {
	GraphicsWindow *gw;
	public:
		ModDrawLineProc() { gw = NULL; }
		ModDrawLineProc(GraphicsWindow *g) { gw = g; }
		int proc(Point3 *p, int n) { gw->polyline(n, p, NULL, NULL, 0, NULL); return 0; }
		int Closed(Point3 *p, int n) { gw->polyline(n, p, NULL, NULL, TRUE, NULL); return 0; }
		void SetLineColor(float r, float g, float b) {gw->setColor(LINE_COLOR,r,g,b);}
		void SetLineColor(Point3 c) {gw->setColor(LINE_COLOR,c);}
		void Marker(Point3 *p,MarkerType type) {gw->marker(p,type);}
	};

static void DrawPlaneRangeHoops(float range,float len3, ModDrawLineProc& lp)
{	Point3 pt[5];
	lp.SetLineColor(GetUIColor(COLOR_END_RANGE));		
	pt[0] = Point3(len3, len3, range); 
	pt[1] = Point3(-len3, len3, range); 
	pt[2] = Point3(-len3,-len3, range); 
	pt[3] = Point3(len3,-len3, range); 
 	lp.Closed(pt,4);
	pt[0].z =-range; 
	pt[1].z =-range;
	pt[2].z =-range;
	pt[3].z =-range;
 	lp.Closed(pt,4);
}

#define NUM_SEGS	16

static void DrawFalloffSphere(float range, ModDrawLineProc& lp)
{	float u;
	Point3 pt[3],pty[3],ptz[3],first,firsty;
	
	lp.SetLineColor(GetUIColor(COLOR_END_RANGE));	
	pt[0]=(first= Point3(range,0.0f,0.0f));
	pty[0] =(firsty=Point3(0.0f,range,0.0f));
	ptz[0] = pt[0];
	for (int i=0; i<NUM_SEGS; i++)
	{	u = float(i)/float(NUM_SEGS) * TWOPI;
		float crange=(float)cos(u)*range,srange=(float)sin(u)*range;
		pt[1]=Point3(crange, srange, 0.0f);
		lp.proc(pt,2); pt[0]=pt[1];
		pty[1]=Point3(0.0f, crange, srange);
		lp.proc(pty,2); pty[0]=pty[1];
		ptz[1]=Point3(crange, 0.0f, srange);
		lp.proc(ptz,2); ptz[0]=ptz[1];
	}
	pt[1]=first;lp.proc(pt,2); 
	pty[1]=firsty;lp.proc(pty,2); 
	ptz[1]=first;lp.proc(ptz,2); 
}

int ForceObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{	GraphicsWindow *gw = vpt->getGW();
	Material *mtl = &swMtl;
	Matrix3 mat = inode->GetObjectTM(t);
 	DWORD rlim = gw->getRndLimits();
	gw->setRndLimits(GW_WIREFRAME|/*GW_BACKCULL|*/ (rlim&GW_Z_BUFFER?GW_Z_BUFFER:0) );//removed BC 2/16/99 DB

	gw->setTransform(mat);
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SPACE_WARPS));
	mesh.render(gw, mtl, NULL, COMP_ALL);
	int hoopson;float decay;
	pblock->GetValue(PB_HOOPSON,t,hoopson,FOREVER);
	pblock->GetValue(PB_DECAY,t,decay,FOREVER);
	if (hoopson && (decay > 0.0f))
	{ int type;pblock->GetValue(PB_TYPE,t,type,FOREVER);
	  float range;
	  range=(decay > 0.0f?0.6931472f / decay:0.0f);
	  ModDrawLineProc lp(gw);
	  if (type==FORCE_PLANAR)
	  { float length;
	    pblock->GetValue(PB_DISPLENGTH,t,length,FOREVER);
	    DrawPlaneRangeHoops(range,3.0f*length,lp);
	  }
	  else DrawFalloffSphere(range,lp);
	}
/*	if (hParam && GetWindowLong(hParam,GWL_USERDATA)==(LONG)this &&
		GetFalloffOn(t)) {
		DrawLineProc lp(gw);
		DrawFalloffSphere(GetFalloff(t),lp);
		}*/

	gw->setRndLimits(rlim);
	return(0);
}
void ForceObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
{   Box3 meshBox;
    Matrix3 mat = inode->GetObjectTM(t);
	box.Init();
	int hoopson;
	pblock->GetValue(PB_HOOPSON,t,hoopson,FOREVER);
	if (hoopson)
	{ float decay; pblock->GetValue(PB_DECAY,t,decay,FOREVER);
	  if (decay>0.0f)
	  {	float range,xy; range=2.0f*(decay > 0.0f?0.6931472f / decay:0.0f);
		int type;pblock->GetValue(PB_TYPE,t,type,ivalid);
		if (type==FORCE_PLANAR)	{pblock->GetValue(PB_DISPLENGTH,t,xy,FOREVER);xy*=3.0f;}	else xy=range;
	    Box3 rangeBox(Point3(-xy,-xy,-range),Point3(xy,xy,range)); 
		for(int i = 0; i < 8; i++)	box += mat * rangeBox[i];
	  }
	}
	GetLocalBoundBox(t,inode,vpt,meshBox);	
	for(int i = 0; i < 8; i++)
		box += mat * meshBox[i];
}

void ForceObject::BuildMesh(TimeValue t)
{	ivalid = FOREVER;
	float length;
	int type;	
	pblock->GetValue(PB_DISPLENGTH,t,length,ivalid);
	pblock->GetValue(PB_TYPE,t,type,ivalid);

	int norvs,norfs,extraverts,extrafaces;
	float decay,range;
	pblock->GetValue(PB_DECAY,t,decay,ivalid);

	if (decay > 0.0f)
		range = 0.6931472f / decay;
	else
		range = 0.0f;

	if (type==FORCE_PLANAR)
	{	extrafaces = 0;
		extraverts = 0;
		mesh.setNumVerts((norvs=15) + extraverts);
		mesh.setNumFaces((norfs=5) + extrafaces);
		mesh.setVert(0, Point3(-length,-length, 0.0f));
		mesh.setVert(1, Point3( length,-length, 0.0f));
		mesh.setVert(2, Point3( length, length, 0.0f));
		mesh.setVert(3, Point3(-length, length, 0.0f));
		mesh.setVert(4, Point3(   0.0f,   0.0f, 0.0f));
		mesh.setVert(5, Point3(   0.0f,   0.0f, 3*length));
		mesh.setVert(6, Point3(   0.0f,   0.0f, 0.0f));
		length *= 0.3f;
		mesh.setVert(7, Point3(-length,-length, 7.0f*length));
		mesh.setVert(8, Point3( length,-length, 7.0f*length));
		mesh.setVert(9, Point3( length, length, 7.0f*length));
		mesh.setVert(10, Point3(-length, length, 7.0f*length));

		mesh.setVert(11, Point3(-length,-length, range));
		mesh.setVert(12, Point3( length,-length, range));
		mesh.setVert(13, Point3( length, length, range));
		mesh.setVert(14, Point3(-length, length, range));

		mesh.faces[0].setEdgeVisFlags(1,0,1);
		mesh.faces[0].setSmGroup(0);
		mesh.faces[0].setVerts(0,1,3);

		mesh.faces[1].setEdgeVisFlags(1,1,0);
		mesh.faces[1].setSmGroup(0);
		mesh.faces[1].setVerts(1,2,3);

		mesh.faces[2].setEdgeVisFlags(1,1,0);
		mesh.faces[2].setSmGroup(0);
		mesh.faces[2].setVerts(4,5,6);

		mesh.faces[3].setEdgeVisFlags(0,1,1);
		mesh.faces[3].setSmGroup(0);
		mesh.faces[3].setVerts(7,9,5);

		mesh.faces[4].setEdgeVisFlags(0,1,1);
		mesh.faces[4].setSmGroup(0);
		mesh.faces[4].setVerts(10,8,5);
	}
	else
	{	extrafaces = 0;
		extraverts = 0;
		float u;

		mesh.setNumVerts((norvs = 3*NUM_SEGS + 1) + extraverts);
		mesh.setNumFaces((norfs = 3*NUM_SEGS) + extrafaces);

		for (int i=0; i<NUM_SEGS; i++)
		{	u = float(i)/float(NUM_SEGS) * TWOPI;
			mesh.setVert(i           , Point3((float)cos(u) * length, (float)sin(u) * length, 0.0f));
			mesh.setVert(i + NUM_SEGS, Point3(0.0f, (float)cos(u) * length, (float)sin(u) * length));
			mesh.setVert(i+2*NUM_SEGS, Point3((float)cos(u) * length, 0.0f, (float)sin(u) * length));
		}
		mesh.setVert(3*NUM_SEGS, Point3(0.0f, 0.0f, 0.0f));
		
		int i1,lastvertex = 3*NUM_SEGS;
		for (i=0; i<lastvertex; i++)
		{	i1 = i + 1;
			if (i1%NUM_SEGS == 0) 
				i1 -= NUM_SEGS;
			mesh.faces[i].setEdgeVisFlags(1,0,0);
			mesh.faces[i].setSmGroup(0);
			mesh.faces[i].setVerts(i,i1,lastvertex);
		}
	}
	mesh.InvalidateGeomCache();
}

class ForceObjCreateCallback : public CreateMouseCallBack {
	public:
		ForceObject *ob;	
		Point3 p0, p1;
		IPoint2 sp0;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int ForceObjCreateCallback::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:								
				sp0 = m;
				p0  = vpt->GetPointOnCP(m);
				mat.SetTrans(p0);
				break;
			case 1:
				if (ob->ClassID()==Class_ID(GRAVITYOBJECT_CLASS_ID,0)) {
					mat.IdentityMatrix();
					mat.RotateX(PI);
					mat.SetTrans(p0);
					}
				p1  = vpt->GetPointOnCP(m);
				ob->pblock->SetValue(PB_DISPLENGTH,0,Length(p1-p0)/2.0f);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3) return CREATE_ABORT;
					else return CREATE_STOP;
					}
				break;
			}
	} else {
		if (msg == MOUSE_ABORT) {
			return CREATE_ABORT;
			}
		else
		if (msg == MOUSE_FREEMOVE) {
			vpt->SnapPreview(m,m);
			}
		}
	
	return TRUE;
	}
static ForceObjCreateCallback forceCreateCB;

CreateMouseCallBack* ForceObject::GetCreateMouseCallBack()
	{
	forceCreateCB.ob = this;
	return &forceCreateCB;
	}

void ForceObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}




//--- GravityObject methods ---------------------------------------


GravityObject::GravityObject()
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descGravVer1, GRAVPBLOCK_LENGTH, CURRENT_GRAVVERSION));
	assert(pblock);	

	pblock->SetValue(PB_STRENGTH,0,1.0f);
	pblock->SetValue(PB_HOOPSON,0,0);
	}

Modifier *GravityObject::CreateWSMMod(INode *node)
	{
	return new GravityMod(node,this);
	}

ForceField *GravityObject::GetForceField(INode *node)
	{
	GravityField *gf = new GravityField;	
	gf->obj  = this;
	gf->node = node;
	gf->tmValid.SetEmpty();
	gf->fValid.SetEmpty();
	gf->obj->pblock->GetValue(PB_TYPE,0,gf->type,FOREVER);
	return gf;
	}

RefTargetHandle GravityObject::Clone(RemapDir& remap) 
	{
	GravityObject* newob = new GravityObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	return newob;
	}

ParamDimension *GravityObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case 0:
		default: return defaultDim;
		}
	}


TSTR GravityObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {				
		case PB_STRENGTH: 	return GetString(IDS_RB_STRENGTH2);
		case PB_DECAY:		return GetString(IDS_RB_DECAY);
		default: 			return TSTR(_T(""));
		}
	}

ParamUIDesc *GravityObject::UIDesc()
	{
	return descParamGrav;
	}

int GravityObject::UIDescLength()
	{
	return GRAVPARAMDESC_LENGTH;
	}

//--- GravityMod methods -----------------------------------------


GravityMod::GravityMod(INode *node,GravityObject *obj)
	{	
	//MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
	pblock = NULL;
	obRef = NULL;
	}

Interval GravityMod::GetValidity(TimeValue t) 
	{
	if (nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		((GravityObject*)GetWSMObject(t))->pblock->GetValue(PB_STRENGTH,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {
		return FOREVER;
		}
	}

class GravityDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static GravityDeformer gdeformer;

Deformer& GravityMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return gdeformer;
	}

RefTargetHandle GravityMod::Clone(RemapDir& remap) 
	{
	GravityMod *newob = new GravityMod(nodeRef,(GravityObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
	}

void GravityMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj) {
		force.obj  = (GravityObject*)GetWSMObject(t);
		force.node = nodeRef;
		force.tmValid.SetEmpty();
		force.fValid.SetEmpty();
		force.obj->pblock->GetValue(PB_TYPE,t,force.type,FOREVER);
		
		obj->ApplyForceField(&force);
		}
	}

// This is an adjustment to forces to make the independent of time scale.
// They were previously dependent on the old 1200 ticks per second constant.
// Note that the constants are being squared because we are dealing with acceleration not velocity.
static float forceScaleFactor = float(1200*1200)/float(TIME_TICKSPERSEC*TIME_TICKSPERSEC);

Point3 GravityField::Force(
		TimeValue t,const Point3 &pos, const Point3 &vel,int index)
	{	
	float strength, decay;
	obj->pblock->GetValue(PB_DECAY,t,decay,fValid);
	if (decay <0.0f) decay = 0.0f;

	if (!fValid.InInterval(t) || type==FORCE_SPHERICAL || decay!=0.0f) {
		fValid = FOREVER;		
		if (!tmValid.InInterval(t)) {
			tmValid = FOREVER;
			tm = node->GetObjectTM(t,&tmValid);
			}
		fValid &= tmValid;
		obj->pblock->GetValue(PB_STRENGTH,t,strength,fValid);
		
		if (type==FORCE_PLANAR) {
			force = Normalize(tm.GetRow(2));
			if (decay!=0.0f) {
				float dist = DotProd(force,pos-tm.GetTrans());
				strength *= (float)exp(-decay*dist);
				}			
			force *= strength * 0.0001f * forceScaleFactor;
		} else {
			float dist;
			force = tm.GetTrans()-pos;
			dist  = Length(force);
			if (dist!=0.0f) force /= dist;
			if (decay!=0.0f) {				
				strength *= (float)exp(-decay*dist);
				}			
			force *= strength * 0.0001f * forceScaleFactor;
			}
		}	
	return force;
	}

class GravityPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		GravityPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((GravityObject*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer<1) {	
 				((GravityObject*)targ)->pblock->SetValue(PB_HOOPSON,0,0);
				}
			delete this;
			}
	};

IOResult GravityObject::Load(ILoad *iload) 
{	iload->RegisterPostLoadCallback(
	new GravityPostLoadCallback(
	new ParamBlockPLCB(gravversions,NUM_OLDVERSIONS,&gravcurVersion,this,0)));
	return IO_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\fextrude.cpp ===
/**********************************************************************
 *<
	FILE: fextrude.cpp

	DESCRIPTION: Face Extrude Modifier

	CREATED BY: Rolf Berteig

	HISTORY: 10/25/96

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm.h"
#include "meshadj.h"

#define PBLOCK_REF	0
#define POINT_REF	1

class FExtrudeMod : public Modifier {	
	public:
		IParamBlock *pblock;
		Control *base;		

		static IObjParam *ip;
		static IParamMap *pmapParam;
		static FExtrudeMod *editMod;
		static MoveModBoxCMode *moveMode;
		
		FExtrudeMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_FACEEXTRUDEMOD);}  
		virtual Class_ID ClassID() { return Class_ID(SUB_EXTRUDE_CLASS_ID,0);}
		void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_FACEEXTRUDEMOD);}
		BOOL AssignController(Animatable *control,int subAnim);
		int SubNumToRefNum(int subNum);

		// From modifier
		ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO|PART_TEXMAP|PART_SELECT|PART_SUBSEL_TYPE|PART_VERTCOLOR;}
		ChannelMask ChannelsChanged() {return PART_GEOM|PART_TOPO|PART_SELECT|PART_TEXMAP|PART_VERTCOLOR;}
		Class_ID InputType() {return triObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);

		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flagst, ModContext *mc);
		void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);		
		void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void ActivateSubobjSel(int level, XFormModes& modes);		

		int NumRefs() {return 2;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		int NumSubs() {return 2;}
		Animatable* SubAnim(int i) {return GetReference(i);}
		TSTR SubAnimName(int i);

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		Matrix3 CompMatrix(TimeValue t,INode *inode,ModContext *mc);
	};



//--- ClassDescriptor and class vars ---------------------------------

IParamMap       *FExtrudeMod::pmapParam = NULL;
IObjParam       *FExtrudeMod::ip        = NULL;
FExtrudeMod     *FExtrudeMod::editMod   = NULL;
MoveModBoxCMode *FExtrudeMod::moveMode  = NULL;
		

class FaceExtrudeClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new FExtrudeMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_FACEEXTRUDEMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(SUB_EXTRUDE_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static FaceExtrudeClassDesc fextrudeDesc;
extern ClassDesc* GetFaceExtrudeModDesc() {return &fextrudeDesc;}


//--- Parameter map/block descriptors -------------------------------

#define PB_AMOUNT	0
#define PB_SCALE	1
#define PB_CENTER	2

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Amount
	ParamUIDesc(
		PB_AMOUNT,
		EDITTYPE_FLOAT,
		IDC_EXT_AMOUNT,IDC_EXT_AMOUNTSPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),

	// Scale
	ParamUIDesc(
		PB_SCALE,
		EDITTYPE_FLOAT,
		IDC_EXT_SCALE,IDC_EXT_SCALESPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),

	// Backface
	ParamUIDesc(PB_CENTER,TYPE_SINGLECHEKBOX,IDC_EXT_CENTER),
	};
#define PARAMDESC_LENGTH	3

static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE,  0 },		// Amount
	{ TYPE_FLOAT, NULL, TRUE,  1 },		// Scale
	{ TYPE_INT,   NULL, FALSE, 2 },		// Center
	};
#define PBLOCK_LENGTH	3

#define CURRENT_VERSION	0



//--- Face extude mod methods -------------------------------


FExtrudeMod::FExtrudeMod()
	{
	base   = NULL;
	pblock = NULL;
	MakeRefByID(
		FOREVER, PBLOCK_REF, 
		CreateParameterBlock(
			descVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	MakeRefByID(FOREVER,POINT_REF,NewDefaultPoint3Controller()); 
	pblock->SetValue(PB_SCALE,0,100.0f);
	} 

void FExtrudeMod::BeginEditParams(
		IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	this->ip = ip;
	editMod  = this;

	// Add our sub object type
	TSTR type1(GetString(IDS_RB_EXTRUDECENT));
	const TCHAR *ptype[] = {type1};
	ip->RegisterSubObjectTypes(ptype, 1);

	// Create sub object editing modes.
	moveMode    = new MoveModBoxCMode(this,ip);
	
	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);

	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGTH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_FACEEXTRUDEPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);	
	}

void FExtrudeMod::EndEditParams(
		IObjParam *ip,ULONG flags,Animatable *next)
	{
	this->ip = NULL;
	editMod  = NULL;

	TimeValue t = ip->GetTime();

	// NOTE: This flag must be cleared before sending the REFMSG_END_EDIT
	ClearAFlag(A_MOD_BEING_EDITED);

	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);

	ip->DeleteMode(moveMode);	
	if (moveMode) delete moveMode;
	moveMode = NULL;	

	DestroyCPParamMap(pmapParam);
	}

RefTargetHandle FExtrudeMod::Clone(RemapDir& remap)
	{
	FExtrudeMod *mod = new FExtrudeMod();
	mod->ReplaceReference(PBLOCK_REF,pblock->Clone(remap));
	mod->ReplaceReference(POINT_REF,base->Clone(remap));	
	return mod;
	}

void FExtrudeMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	if (os->obj->IsSubClassOf(triObjectClassID)) {
		TriObject *tobj = (TriObject*)os->obj;
		Mesh &mesh = tobj->GetMesh();
		Interval iv = FOREVER;
		float a, s;
		Point3 pt, center;
		int c;
		
		pblock->GetValue(PB_AMOUNT,t,a,iv);
		pblock->GetValue(PB_SCALE,t,s,iv);
		pblock->GetValue(PB_CENTER,t,c,iv);
		base->GetValue(t,&pt,iv,CTRL_ABSOLUTE);		

		// Extrude the faces -- this just creates the new faces
		mesh.ExtrudeFaces();

		// Build normals of selected faces only		
		Tab<Point3> normals;
		if (!c) {
			normals.SetCount(mesh.getNumVerts());
			for (int i=0; i<mesh.getNumVerts(); i++) {
				normals[i] = Point3(0,0,0);
				}
			for (i=0; i<mesh.getNumFaces(); i++) {
				if (mesh.faceSel[i]) {
					Point3 norm = 
						(mesh.verts[mesh.faces[i].v[1]]-mesh.verts[mesh.faces[i].v[0]]) ^
						(mesh.verts[mesh.faces[i].v[2]]-mesh.verts[mesh.faces[i].v[1]]);
					for (int j=0; j<3; j++) {				
						normals[mesh.faces[i].v[j]] += norm;
						}
					}
				}			
			for (i=0; i<mesh.getNumVerts(); i++) {
				normals[i] = Normalize(normals[i]);
				}
		} else {
			// Compute the center point			
			base->GetValue(t,&center,iv,CTRL_ABSOLUTE);			
			}

		// Mark vertices used by selected faces
		BitArray sel;
		sel.SetSize(mesh.getNumVerts());
		for (int i=0; i<mesh.getNumFaces(); i++) {
			if (mesh.faceSel[i]) {
				for (int j=0; j<3; j++) sel.Set(mesh.faces[i].v[j],TRUE);
				}
			}

		// Move selected verts
		for (i=0; i<mesh.getNumVerts(); i++) {
			if (sel[i]) {
				if (!c) {
					mesh.verts[i] += normals[i]*a;
				} else {
					Point3 vect = Normalize((mesh.verts[i] * (*mc.tm))
						- center);
					mesh.verts[i] += vect*a;
					}
				}
			}
		
		// Scale verts
		if (s!=100.0f) {
			s /= 100.0f;

			AdjEdgeList ae(mesh);
			AdjFaceList af(mesh,ae);
			FaceClusterList clust(mesh.faceSel,af);
			
			// Make sure each vertex is only scaled once.
			BitArray done;
			done.SetSize(mesh.getNumVerts());

			// scale each cluster independently
			for (int i=0; (DWORD)i<clust.count; i++) {
				// First determine cluster center
				Point3 cent(0,0,0);
				int ct=0;
				for (int j=0; j<mesh.getNumFaces(); j++) {
					if (clust[j]==(DWORD)i) {
						for (int k=0; k<3; k++) {
							cent += mesh.verts[mesh.faces[j].v[k]];
							ct++;
							}
						}
					}
				if (ct) cent /= float(ct);

				// Now scale the cluster about its center
				for (j=0; j<mesh.getNumFaces(); j++) {
					if (clust[j]==(DWORD)i) {
						for (int k=0; k<3; k++) {
							int index = mesh.faces[j].v[k]; 
							if (done[index]) continue;
							done.Set(index);
							mesh.verts[index] = 
								(mesh.verts[index]-cent)*s + cent;							
							}
						}
					}
				}
			}
		
		mesh.InvalidateTopologyCache ();
		os->obj->UpdateValidity(GEOM_CHAN_NUM,iv);		
		}
	}

Interval FExtrudeMod::LocalValidity(TimeValue t)
	{
	Interval iv = FOREVER;
	float v;
	Point3 pt;
	pblock->GetValue(PB_AMOUNT,t,v,iv);
	pblock->GetValue(PB_SCALE,t,v,iv);
	base->GetValue(t,&pt,iv,CTRL_ABSOLUTE);
	return iv;
	}

int FExtrudeMod::HitTest(
		TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc)
	{	
	GraphicsWindow *gw = vpt->getGW();
	Point3 pt;
	HitRegion hr;
	int savedLimits, res = 0;
	Matrix3 tm = CompMatrix(t,inode,mc);

	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);	
	gw->setTransform(tm);

	gw->clearHitCode();
	base->GetValue(t,&pt,FOREVER,CTRL_ABSOLUTE);
	gw->marker(&pt,HOLLOW_BOX_MRKR);
	if (gw->checkHitCode()) {
		vpt->LogHit(inode, mc, gw->getHitDistance(), 0, NULL); 
		res = 1;
		}			

	gw->setRndLimits(savedLimits);
	return res;
	}

int FExtrudeMod::Display(
		TimeValue t, INode* inode, ViewExp *vpt, 
		int flagst, ModContext *mc)
	{
	GraphicsWindow *gw = vpt->getGW();
	Point3 pt;
	Matrix3 tm = CompMatrix(t,inode,mc);
	int savedLimits;

	gw->setRndLimits((savedLimits = gw->getRndLimits()) & ~GW_ILLUM);
	gw->setTransform(tm);
	
	// Draw start point
	if (ip && ip->GetSubObjectLevel() == 1) {
		//gw->setColor(LINE_COLOR, (float)1.0, (float)1.0, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
	} else {
		//gw->setColor(LINE_COLOR, (float).85, (float).5, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
		}	
	base->GetValue(t,&pt,FOREVER,CTRL_ABSOLUTE);
	gw->marker(&pt,HOLLOW_BOX_MRKR);
	
	gw->setRndLimits(savedLimits);
	return 0;
	}

void FExtrudeMod::GetWorldBoundBox(
		TimeValue t,INode* inode, ViewExp *vpt, 
		Box3& box, ModContext *mc)
	{
	Matrix3 tm = CompMatrix(t,inode,mc);
	Point3 pt;
	box.Init();
	base->GetValue(t,&pt,FOREVER,CTRL_ABSOLUTE);
	box += pt * tm;		
	}

void FExtrudeMod::Move(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin)
	{
	base->SetValue(
		t,VectorTransform(tmAxis*Inverse(partm),val),
		TRUE,CTRL_RELATIVE);
	}

void FExtrudeMod::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,
		INode *node,ModContext *mc)
	{
	Matrix3 tm = CompMatrix(t,node,mc);
	Point3 p;
	base->GetValue(t,&p,FOREVER,CTRL_ABSOLUTE);
	tm.PreTranslate(p);
	cb->Center(tm.GetTrans(),0);
	}

void FExtrudeMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,
		INode *node,ModContext *mc)
	{
	Matrix3 tm = CompMatrix(t,node,mc);
	cb->TM(tm,0);
	}

void FExtrudeMod::ActivateSubobjSel(int level, XFormModes& modes)
	{
	switch (level) {
		case 1: // Points
			modes = XFormModes(moveMode,NULL,NULL,NULL,NULL,NULL);
			break;		
		}
	NotifyDependents(FOREVER,PART_DISPLAY,REFMSG_CHANGE);
	}

BOOL FExtrudeMod::AssignController(Animatable *control,int subAnim)
	{
	if (subAnim==POINT_REF) {
		ReplaceReference(POINT_REF,(ReferenceTarget*)control);
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);		
		return TRUE;
	} else {
		return FALSE;
		}
	}

int FExtrudeMod::SubNumToRefNum(int subNum)
	{
	if (subNum==POINT_REF) return subNum;
	else return -1;
	}

RefTargetHandle FExtrudeMod::GetReference(int i)
	{
	switch (i) {
		case PBLOCK_REF: return pblock;
		case POINT_REF:  return base;
		default: return NULL;
		}
	}

void FExtrudeMod::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case PBLOCK_REF: pblock = (IParamBlock*)rtarg; break;
		case POINT_REF : base   = (Control*)rtarg; break;
		}
	}

TSTR FExtrudeMod::SubAnimName(int i)
	{
	switch (i) {		
		case POINT_REF:  return GetString(IDS_RB_EXTRUDECENT);
		default:         return _T("");
		}
	}

RefResult FExtrudeMod::NotifyRefChanged( 
		Interval changeInt,RefTargetHandle hTarget, 
		PartID& partID, RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			if (editMod==this && pmapParam) pmapParam->Invalidate();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_AMOUNT:  gpd->dim = stdWorldDim;   break;
				case PB_SCALE:   gpd->dim = defaultDim; break;				
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;			
			switch (gpn->index) {
				case PB_AMOUNT:  gpn->name = GetString(IDS_EXT_AMOUNT); break;
				case PB_SCALE:   gpn->name = GetString(IDS_EXT_SCALE);  break;
				}
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}

Matrix3 FExtrudeMod::CompMatrix(
		TimeValue t,INode *inode,ModContext *mc)
	{
	Interval iv;
	Matrix3 tm(1);	
	if (mc && mc->tm) tm = Inverse(*(mc->tm));
	if (inode) tm = tm * inode->GetObjTMBeforeWSM(t,&iv);
	return tm;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\mapping.h ===
/**********************************************************************
 *<
	FILE: mapping.h

	DESCRIPTION:  

	CREATED BY: Rolf Berteig

	HISTORY: 10/21/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __MAPPING__
#define __MAPPING__

class MappingMod : public Modifier {
	public:
		DWORD flags;
		float aspect;
		Control *tmControl;
		
		static IObjParam *ip;
		
		MappingMod() : mLocalSetValue(false), flags(0), aspect(1), tmControl(NULL) { } // mjm - 6.7.99
		void* GetInterface(ULONG id);
		void InitControl(ModContext &mc,Object *obj,int type,TimeValue t);
		void Move(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
		void Rotate(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE);
		void Scale(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
		Matrix3 CompMatrix(TimeValue t,ModContext *mc, Matrix3 *ntm,BOOL applySize=TRUE, BOOL applyAxis=TRUE);
		void DoIcon(PolyLineProc& lp,BOOL sel);
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext *mc);
		void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);
		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void ViewportAlign();

		virtual void EnterNormalAlign()=0;
		virtual void ExitNormalAlign()=0;
		virtual void EnterRegionFit()=0;
		virtual void ExitRegionFit()=0;
		virtual int GetMapType()=0;
		virtual void SetMapType(int type)=0;
		virtual float GetTile(TimeValue t,int which)=0;
		virtual void SetTile(TimeValue t,int which, float tile)=0;
		virtual BOOL GetFlip(int which)=0;
		virtual void SetFlip(int which,BOOL flip)=0;
		
		virtual float GetLength(TimeValue t)=0;
		virtual float GetWidth(TimeValue t)=0;
		virtual float GetHeight(TimeValue t)=0;
		virtual int GetAxis()=0;
		virtual void SetLength(TimeValue t,float v)=0;
		virtual void SetWidth(TimeValue t,float v)=0;
		virtual void SetHeight(TimeValue t,float v)=0;
		virtual void SetAxis(int v)=0;
		virtual int GetFirstParamVer()=0;
		virtual int GetPBlockVersion()=0;

		virtual void EnterAcquire()=0;
		virtual void ExitAcquire()=0;
		
	protected:
		bool mLocalSetValue; // mjm - 6.7.99
	};

#define I_MAPPINGINTERFACE	0x9836d7f1
#define GetMappingInterface(anim) ((MappingMod*)anim->GetInterface(I_MAPPINGINTERFACE))

#define TM_REF		0
#define PBLOCK_REF	1

// Flags
#define CONTROL_FIT			(1<<0)
#define CONTROL_CENTER		(1<<1)
#define CONTROL_ASPECT		(1<<2)
#define CONTROL_UNIFORM		(1<<3)
#define CONTROL_HOLD		(1<<4)
#define CONTROL_INIT		(1<<5)
#define CONTROL_OP			(CONTROL_FIT|CONTROL_CENTER|CONTROL_ASPECT|CONTROL_UNIFORM)
#define CONTROL_INITPARAMS	(1<<10)


#define CID_FACEALIGNMAP 	0x4f298c7a
#define CID_REGIONFIT 		0x4f298c7b

class FaceAlignMouseProc : public MouseCallBack {
	public:
		MappingMod *mod;
		IObjParam *ip;
		FaceAlignMouseProc(MappingMod *m,IObjParam *i) {mod=m;ip=i;}
		int proc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
		void FaceAlignMap(HWND hWnd,IPoint2 m);
	};

class FaceAlignMode : public CommandMode {
	public:
		ChangeFGObject fgProc;
		FaceAlignMouseProc proc;
		IObjParam *ip;
		MappingMod *mod;

		FaceAlignMode(MappingMod *m,IObjParam *i) 
			: fgProc(m), proc(m,i) {ip=i;mod=m;}

		int Class() {return MOVE_COMMAND;}		
		int ID() {return CID_FACEALIGNMAP;}
		MouseCallBack *MouseProc(int *numPoints) {*numPoints=2;return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
		BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc() != &fgProc;}
		void EnterMode();
		void ExitMode();
	};

class RegionFitMouseProc : public MouseCallBack {
	public:
		MappingMod *mod;
		IObjParam *ip;
		IPoint2 om;
		RegionFitMouseProc(MappingMod *m,IObjParam *i) {mod=m;ip=i;}
		int proc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
		void RegionFitMap(HWND hWnd,IPoint2 m);
	};

class RegionFitMode : public CommandMode {
	public:
		ChangeFGObject fgProc;
		RegionFitMouseProc proc;
		IObjParam *ip;
		MappingMod *mod;

		RegionFitMode(MappingMod *m,IObjParam *i) 
			: fgProc(m), proc(m,i) {ip=i;mod=m;}

		int Class() {return MOVE_COMMAND;}		
		int ID() {return CID_REGIONFIT;}
		MouseCallBack *MouseProc(int *numPoints) {*numPoints=2;return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
		BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc() != &fgProc;}
		void EnterMode();
		void ExitMode();
	};

class PickAcquire : 
			public PickModeCallback,
			public PickNodeCallback {
	public:		
		MappingMod *mod;
		IObjParam *ip;

		PickAcquire() {mod = NULL; ip = NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);		
		BOOL Pick(IObjParam *ip,ViewExp *vpt);		
		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);		
		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{return TRUE;}

		BOOL Filter(INode *node);

		MappingMod *FindFirstMap(ReferenceTarget *ref);
		void AcquireMapping(
			MappingMod *toMod, ModContext *toMC, INode *toNode,
			MappingMod *fromMod, ModContext *fromMC, INode *fromNode,
			int type);
	};

class FixDimsPLCB : public PostLoadCallback {
	public:
		MappingMod *mod;
		FixDimsPLCB(MappingMod *m) {mod=m;}
		void proc(ILoad *iload);
		int Priority() { return 0; } // mjm - 3.29.99 - update for R3
	};


#endif //__MAPPING__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\meshsel.cpp ===
/**********************************************************************
 *<
	FILE: meshsel.cpp

	DESCRIPTION:  A selection modifier for meshes

	CREATED BY: Rolf Berteig

	HISTORY: 10/23/96

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm.h"
#include "meshadj.h"
#include "namesel.h"
#include "nsclip.h"
#include "istdplug.h"
#include "iparamm.h"

#define DEF_FALLOFF 20.0f

// Named selection set levels:
#define NS_VERTEX 0
#define NS_EDGE 1
#define NS_FACE 2
static int namedSetLevel[] = { NS_VERTEX, NS_VERTEX, NS_EDGE, NS_FACE, NS_FACE, NS_FACE };
static int namedClipLevel[] = { CLIP_VERT, CLIP_VERT, CLIP_EDGE, CLIP_FACE, CLIP_FACE, CLIP_FACE };

#define WM_UPDATE_CACHE		(WM_USER+0x287)

#define REF_PBLOCK 0

// flags:
#define MS_DISP_END_RESULT 0x01

class MeshSelMod : public Modifier, public IMeshSelect {	
public:
	DWORD selLevel;
	Tab<TSTR*> namedSel[3];		
	Tab<DWORD> ids[3];
	IParamBlock *pblock;
	DWORD flags;
	void SetFlag (DWORD fl) { flags |= fl; }
	void ClearFlag (DWORD fl) { flags &= ~fl; }
	void SetFlag (DWORD fl, bool set) { if (set) SetFlag (fl); else ClearFlag (fl); }
	bool GetFlag (DWORD fl) { return (fl&flags) ? TRUE : FALSE; }

	static IObjParam *ip;
	static IParamMap *pmapParam;
	static MeshSelMod *editMod;
	static BOOL selByVert;
	static BOOL ignoreBackfaces;
	static BOOL ignoreVisEdge;
	static HWND hParams;
	static BOOL arRollup;
	static SelectModBoxCMode *selectMode;
	static BOOL updateCachePosted;

	MeshSelMod();

	// From Animatable
	void DeleteThis() { delete this; }
	void GetClassName(TSTR& s) {s = GetString(IDS_RB_MESHSELMOD);}  
	virtual Class_ID ClassID() { return Class_ID(MESHSELECT_CLASS_ID,0);}		
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	TCHAR *GetObjectName() {return GetString(IDS_RB_MESHSELMOD);}

	// From modifier
	ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO;}
	ChannelMask ChannelsChanged() {return PART_SELECT|PART_SUBSEL_TYPE|PART_TOPO;} // RB 5/27/97: Had to include topo channel because in edge select mode this modifier turns on hidden edges -- which may cause the edge list to be rebuilt, which is effectively a change in topology since the edge list is now part of the topo channel.
	Class_ID InputType() {return triObjectClassID;}
	void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
	Interval LocalValidity(TimeValue t) { return GetValidity(t); }
	Interval GetValidity (TimeValue t);
	BOOL DependOnTopology(ModContext &mc) {return TRUE;}

	// From BaseObject
	CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
	void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
	void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);		
	int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
	int Display(TimeValue t, INode* inode, ViewExp *vpt, int flagst, ModContext *mc);
	void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);
	void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
	void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);

	void ActivateSubobjSel(int level, XFormModes& modes);
	void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE);
	void ClearSelection(int selLevel);
	void SelectAll(int selLevel);
	void InvertSelection(int selLevel);
	void NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc);

	void ShowEndResultChanged (BOOL showEndResult) { NotifyDependents (FOREVER, PART_DISPLAY, REFMSG_CHANGE); }

	BOOL SupportsNamedSubSels() {return TRUE;}
	void ActivateSubSelSet(TSTR &setName);
	void NewSetFromCurSel(TSTR &setName);
	void RemoveSubSelSet(TSTR &setName);
	void SetupNamedSelDropDown();
	int NumNamedSelSets();
	TSTR GetNamedSelSetName(int i);
	void SetNamedSelSetName(int i,TSTR &newName);
	void NewSetByOperator(TSTR &newName,Tab<int> &sets,int op);
	void UpdateNamedSelDropDown ();

	// From IMeshSelect
	DWORD GetSelLevel();
	void SetSelLevel(DWORD level);
	void LocalDataChanged();
	BOOL HasWeightedVertSel ();

	// IO
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);
	IOResult LoadNamedSelChunk(ILoad *iload,int level);
	IOResult SaveLocalData(ISave *isave, LocalModData *ld);
	IOResult LoadLocalData(ILoad *iload, LocalModData **pld);

	IParamArray *GetParamBlock() {return pblock;}
	int GetParamBlockIndex(int id) {return id;}

	int NumRefs() { return 1; }
	RefTargetHandle GetReference(int i) { return pblock; }
	void SetReference(int i, RefTargetHandle rtarg) { pblock = (IParamBlock *) rtarg; }

	int NumSubs() {return 1;}
	Animatable* SubAnim(int i) { return GetReference(i); }
	TSTR SubAnimName(int i) {return GetString (IDS_RB_PARAMETERS);}

	RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
	   PartID& partID, RefMessage message);

	void UpdateSelLevelDisplay ();
	float GetPolyFaceThresh();
	HitRecord *VertHitsToFaceHits(HitRecord *hitRec,BOOL all);
	void SelectFrom(int from);
	void SetEnableStates();
	void SelectOpenEdges();
	void SelectByMatID(int id);
	void SetNumSelLabel();		
	void UpdateCache(TimeValue t);
	void InvalidateVDistances ();

	// Local methods for handling named selection sets
	int FindSet(TSTR &setName,int level);		
	DWORD AddSet(TSTR &setName,int level);
	void RemoveSet(TSTR &setName,int level);
	void UpdateSetNames ();	// Reconciles names with MeshSelData.
	void ClearSetNames();
	void NSCopy();
	void NSPaste();
	BOOL GetUniqueSetName(TSTR &name);
	int SelectNamedSet();

	ParamDimension *GetParameterDim (int paramID);
	TSTR GetParameterName (int paramID);
};

class MeshSelData : public LocalModData, public IMeshSelectData {
public:
	// LocalModData
	void* GetInterface(ULONG id) { if (id == I_MESHSELECTDATA) return(IMeshSelectData*)this; else return LocalModData::GetInterface(id); }

	// Selection sets
	BitArray vertSel;
	BitArray faceSel;
	BitArray edgeSel;

	// Lists of named selection sets
	GenericNamedSelSetList vselSet;
	GenericNamedSelSetList fselSet;
	GenericNamedSelSetList eselSet;

	BOOL held;
	Mesh *mesh;
	AdjEdgeList *ae;

	// Cache of distances to nearest selected vert, plus cache of selections based on that.
	Tab<float> vd, vs;
	Interval vdValid;

	MeshSelData(Mesh &mesh);
	MeshSelData() { held=0;mesh=NULL; ae=NULL; vdValid=NEVER; }
	~MeshSelData() { FreeCache(); }
	LocalModData *Clone();
	Mesh *GetMesh() {return mesh;}
	AdjEdgeList *GetAdjEdgeList ();
	void SetCache(Mesh &mesh);
	void FreeCache();
	void SynchBitArrays();

	BitArray SelVertByFace();
	BitArray SelVertByEdge();
	BitArray SelFaceByVert();
	BitArray SelFaceByEdge();
	BitArray SelPolygonByVert (float thresh, int igVis);
	BitArray SelPolygonByEdge (float thresh, int igVis);
	BitArray SelElementByVert ();
	BitArray SelElementByEdge ();
	BitArray SelEdgeByVert();
	BitArray SelEdgeByFace();

	BitArray TempVSel (Mesh & m, DWORD slevel);
	void UpdateVDistances (TimeValue t, TriObject *tobj, DWORD slevel);
	void InvalidateVDistances ();
	void UpdateWeightedVSel (float falloff, float pinch, float bubble);
	BitArray GetSel (int nsl) { if (nsl==NS_VERTEX) return vertSel; else if (nsl==NS_EDGE) return edgeSel; else return faceSel; }

	// From IMeshSelectData:
	BitArray GetVertSel() { return vertSel; }
	BitArray GetFaceSel() { return faceSel; }
	BitArray GetEdgeSel() { return edgeSel; }

	void SetVertSel(BitArray &set, IMeshSelect *imod, TimeValue t);
	void SetFaceSel(BitArray &set, IMeshSelect *imod, TimeValue t);
	void SetEdgeSel(BitArray &set, IMeshSelect *imod, TimeValue t);

	GenericNamedSelSetList & GetNamedVertSelList () { return vselSet; }
	GenericNamedSelSetList & GetNamedEdgeSelList () { return eselSet; }
	GenericNamedSelSetList & GetNamedFaceSelList () { return fselSet; }
	GenericNamedSelSetList & GetNamedSel (int nsl) {
		if (nsl==NS_VERTEX) return vselSet;
		if (nsl==NS_EDGE) return eselSet;
		return fselSet;
	}

	void GetWeightedVertSel (int nv, float *sel);
};

class MeshSelRestore : public RestoreObj {
public:
	BitArray usel, rsel;
	BitArray *sel;
	MeshSelMod *mod;
	MeshSelData *d;
	int level;

	MeshSelRestore(MeshSelMod *m, MeshSelData *d);
	MeshSelRestore(MeshSelMod *m, MeshSelData *d, int level);
	void Restore(int isUndo);
	void Redo();
	int Size() { return 1; }
	void EndHold() {d->held=FALSE;}
	TSTR Description() { return TSTR(_T("SelectRestore")); }
};

class AppendSetRestore : public RestoreObj {
public:
	BitArray set;		
	DWORD id;
	GenericNamedSelSetList *setList;
	TSTR name;

	AppendSetRestore(GenericNamedSelSetList *sl, DWORD i, TSTR & n) {setList = sl; id = i; name = n; }
	void Restore(int isUndo) {
		set  = *setList->GetSet (id);		
		setList->RemoveSet(id);			
	}
	void Redo() { setList->InsertSet (set, id, name); }

	TSTR Description() {return TSTR(_T("Append Set"));}
};

class AppendSetNameRestore : public RestoreObj {
	public:		
		TSTR name;
		DWORD id;
		MeshSelMod *et;
		Tab<TSTR*> *sets;
		Tab<DWORD> *ids;

		AppendSetNameRestore(MeshSelMod *e,Tab<TSTR*> *s,Tab<DWORD> *i) 
			{et = e; sets = s; ids = i;}
		void Restore(int isUndo) {			
			name = *(*sets)[sets->Count()-1];
			id   = (*ids)[sets->Count()-1];
			delete (*sets)[sets->Count()-1];
			sets->Delete(sets->Count()-1,1);			
			if (et->ip) et->ip->NamedSelSetListChanged();
			}
		void Redo() {
			TSTR *nm = new TSTR(name);
			sets->Append(1,&nm);
			ids->Append(1,&id);
			if (et->ip) et->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Append Set Name"));}
	};

class DeleteSetRestore : public RestoreObj {
public:
	BitArray set;
	DWORD id;
	TSTR name;
	//int index;
	GenericNamedSelSetList *setList;		

	DeleteSetRestore(GenericNamedSelSetList *sl,DWORD i, TSTR & n) {
		setList = sl; 
		id = i;
		BitArray *ptr = setList->GetSet(id);
		if (ptr) set = *ptr;
		name = n;
	}   		
	void Restore(int isUndo) {
		setList->InsertSet(set,id,name);
	}
	void Redo() {
		setList->RemoveSet(id);
	}
			
	TSTR Description() {return TSTR(_T("Delete Set"));}
};

class DeleteSetNameRestore : public RestoreObj {
public:		
	TSTR name;
	//int index;		
	DWORD id;
	MeshSelMod *et;
	Tab<TSTR*> *sets;
	Tab<DWORD> *ids;

	DeleteSetNameRestore(Tab<TSTR*> *s,MeshSelMod *e,Tab<DWORD> *i, DWORD id) {
		sets = s; et = e; //index = i;			
		this->id = id;
		ids = i;
		int index = -1;
		for (int j=0; j<sets->Count(); j++) {
			if ((*ids)[j]==id) {
				index = j;
				break;
				}
			}
		if (index>=0) {
			name = *(*sets)[index];
			}
		}   		
	void Restore(int isUndo) {			
		TSTR *nm = new TSTR(name);			
		//sets->Insert(index,1,&nm);
		sets->Append(1,&nm);
		ids->Append(1,&id);
		if (et->ip) et->ip->NamedSelSetListChanged();
		}
	void Redo() {
		int index = -1;
		for (int j=0; j<sets->Count(); j++) {
			if ((*ids)[j]==id) {
				index = j;
				break;
				}
			}
		if (index>=0) {
			sets->Delete(index,1);
			ids->Delete(index,1);
			}
		//sets->Delete(index,1);
		if (et->ip) et->ip->NamedSelSetListChanged();
		}
			
	TSTR Description() {return TSTR(_T("Delete Set Name"));}
};

class SetNameRestore : public RestoreObj {
public:
	TSTR undo, redo;
	//int index;
	DWORD id;
	Tab<TSTR*> *sets;
	Tab<DWORD> *ids;
	MeshSelMod *et;
	SetNameRestore(Tab<TSTR*> *s,MeshSelMod *e,Tab<DWORD> *i,DWORD id) {
		//index = i; 
		this->id = id;
		ids = i;
		sets = s; et = e;
		int index = -1;
		for (int j=0; j<sets->Count(); j++) {
			if ((*ids)[j]==id) {
				index = j;
				break;
				}
			}
		if (index>=0) {
			undo = *(*sets)[index];
			}			
		}

	void Restore(int isUndo) {
		int index = -1;
		for (int j=0; j<sets->Count(); j++) {
			if ((*ids)[j]==id) {
				index = j;
				break;
				}
			}
		if (index>=0) {
			redo = *(*sets)[index];
			*(*sets)[index] = undo;
			}			
		if (et->ip) et->ip->NamedSelSetListChanged();
		}
	void Redo() {
		int index = -1;
		for (int j=0; j<sets->Count(); j++) {
			if ((*ids)[j]==id) {
				index = j;
				break;
			}
		}
		if (index>=0) {
			*(*sets)[index] = redo;
		}
		if (et->ip) et->ip->NamedSelSetListChanged();
	}
			
	TSTR Description() {return TSTR(_T("Set Name"));}
};


//--- ClassDescriptor and class vars ---------------------------------

#define SELTYPE_SINGLE	1
#define SELTYPE_POLY	2
#define SELTYPE_ELEMENT	3

#define SEL_OBJECT	0
#define SEL_VERTEX	1
#define SEL_EDGE	2
#define SEL_FACE	3
#define SEL_POLY	4
#define SEL_ELEMENT 5

IObjParam *MeshSelMod::ip              = NULL;
IParamMap *MeshSelMod::pmapParam       = NULL;
MeshSelMod *MeshSelMod::editMod         = NULL;
HWND MeshSelMod::hParams         = NULL;
BOOL MeshSelMod::arRollup = TRUE;
BOOL MeshSelMod::selByVert       = FALSE;
BOOL MeshSelMod::ignoreBackfaces = FALSE;
BOOL MeshSelMod::ignoreVisEdge   = FALSE;
SelectModBoxCMode *MeshSelMod::selectMode      = NULL;
BOOL MeshSelMod::updateCachePosted = FALSE;

static float lastFaceThresh = 45.0f;
static int lastMatID = 1;

class MeshSelClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new MeshSelMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_MESHSELMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(MESHSELECT_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
};

static MeshSelClassDesc meshSelDesc;
ClassDesc* GetMeshSelModDesc() {return &meshSelDesc;}

static BOOL CALLBACK MeshSelectProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

class AffectRegionProc : public ParamMapUserDlgProc {
public:
	MeshSelMod *em;
	AffectRegionProc () { em = NULL; }
	BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
	void DeleteThis() { }
};

static AffectRegionProc theAffectRegionProc;

// Table to convert selLevel values to mesh selLevel flags.
const int meshLevel[] = {MESH_OBJECT, MESH_VERTEX, MESH_EDGE, MESH_FACE, MESH_FACE, MESH_FACE};

// Get display flags based on selLevel.
const DWORD levelDispFlags[] = {0,DISP_VERTTICKS|DISP_SELVERTS,DISP_SELEDGES,DISP_SELFACES,DISP_SELPOLYS,DISP_SELPOLYS};

// For hit testing...
const int hitLevel[] = {0,SUBHIT_VERTS,SUBHIT_EDGES,SUBHIT_FACES,SUBHIT_FACES,SUBHIT_FACES};

// Parameter block:
#define PB_USE_AR 0
#define PB_FALLOFF 1
#define PB_PINCH 2
#define PB_BUBBLE 3

static ParamUIDesc descParam[] = {
	// Use affect region?
	ParamUIDesc (PB_USE_AR, TYPE_SINGLECHEKBOX, IDC_MS_AR_USE),

	ParamUIDesc (PB_FALLOFF, EDITTYPE_POS_UNIVERSE,
		IDC_FALLOFF, IDC_FALLOFFSPIN,
		0.0001f, 9999999999.f, SPIN_AUTOSCALE),

	ParamUIDesc (PB_PINCH, EDITTYPE_UNIVERSE,
		IDC_PINCH, IDC_PINCHSPIN,
		-10.0f, 10.0f, 0.01f),

	ParamUIDesc (PB_BUBBLE, EDITTYPE_UNIVERSE,
		IDC_BUBBLE, IDC_BUBBLESPIN,
		-10.0f, 10.0f, 0.01f),
};
#define PARAMDESC_LENGTH 4

static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, TRUE, PB_USE_AR },
	{ TYPE_FLOAT, NULL, TRUE, PB_FALLOFF },
	{ TYPE_FLOAT, NULL, TRUE, PB_PINCH },
	{ TYPE_FLOAT, NULL, TRUE, PB_BUBBLE }
};
#define PBLOCK_LENGTH	4

/*
// Array of old versions - not used yet
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,4,0)
};
#define NUM_OLDVERSIONS	1
*/

// Current version
#define CURRENT_VERSION	0
static ParamVersionDesc curVersion (descVer0, PBLOCK_LENGTH, CURRENT_VERSION);

//--- MeshSel mod methods -------------------------------

MeshSelMod::MeshSelMod() {
	selLevel = SEL_OBJECT;
	pblock = NULL;
	flags = 0x0;

	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	pblock->SetValue (PB_USE_AR, TimeValue(0), 0);
	pblock->SetValue (PB_FALLOFF, TimeValue(0), DEF_FALLOFF);
	pblock->SetValue (PB_PINCH, TimeValue(0), 0.0f);
	pblock->SetValue (PB_BUBBLE, TimeValue(0), 0.0f);
}

RefTargetHandle MeshSelMod::Clone(RemapDir& remap) {
	MeshSelMod *mod = new MeshSelMod();
	mod->selLevel = selLevel;
	mod->ReplaceReference (0, pblock->Clone(remap));
	return mod;
}

Interval MeshSelMod::GetValidity (TimeValue t) {
	Interval ret = FOREVER;
	int useAR;
	pblock->GetValue (PB_USE_AR, t, useAR, ret);
	if (!useAR) return ret;
	float f, p, b;
	pblock->GetValue (PB_FALLOFF, t, f, ret);
	pblock->GetValue (PB_PINCH, t, p, ret);
	pblock->GetValue (PB_BUBBLE, t, b, ret);
	return ret;
}

BOOL MeshSelMod::HasWeightedVertSel() {
	BOOL useAR;
	pblock->GetValue (PB_USE_AR, 0, useAR, FOREVER);
	return useAR;
}

float AffectRegionFunct(float dist,float falloff,float pinch,float bubble) {
	float u = ((falloff - dist)/falloff);
	float u2 = u*u, s = 1.0f-u;	
	return (3*u*bubble*s + 3*u2*(1.0f-pinch))*s + u*u2;
}

BitArray MeshSelData::TempVSel (Mesh & m, DWORD selLevel) {
	BitArray vsel;
	vsel.SetSize (m.numVerts);

	int i, j;
	switch (selLevel) {
	case SEL_OBJECT:
		vsel.SetAll ();
		break;
	case SEL_VERTEX:
		vsel = vertSel;
		break;

	case SEL_EDGE:
		vsel.ClearAll ();
		for (i=0; i<m.numFaces; i++) {
			for (j=0; j<3; j++) {
				if (edgeSel[i*3+j]) {
					vsel.Set (m.faces[i].v[j]);
					vsel.Set (m.faces[i].v[(j+1)%3]);
				}
			}
		}
		break;

	default:
		vsel.ClearAll ();
		for (i=0; i<m.numFaces; i++) {
			if (!faceSel[i]) continue;
			for (j=0; j<3; j++) vsel.Set (m.faces[i].v[j]);
		}
		break;
	}
	return vsel;
}

void MeshSelData::InvalidateVDistances () {
	vdValid.SetEmpty ();
}

void MeshSelData::UpdateVDistances (TimeValue t, TriObject *tobj, DWORD selLevel) {
	if (vdValid.InInterval(t)) return;

	Point3 *v = tobj->GetMesh().verts;
	vdValid = tobj->ChannelValidity (t, GEOM_CHAN_NUM);
	vdValid &= tobj->ChannelValidity (t, TOPO_CHAN_NUM);

	int i, vnum=tobj->GetMesh().numVerts;
	BitArray vsel = TempVSel (tobj->GetMesh(), selLevel);
	vd.SetCount (vnum);

	Tab<int> sverts;
	sverts.Resize (vnum);
	for (i=0; i<vnum; i++) {
		if (!vsel[i]) continue;
		sverts.Append (1, &i);
		vd[i] = 0.0f;
	}
	if (sverts.Count() == 0) {
		for (i=0; i<vnum; i++) vd[i] = -1.0f;
		return;
	}
	for (i=0; i<vnum; i++) {
		if (vsel[i]) continue;
		float mindist = LengthSquared (v[i] - v[sverts[0]]);
		int best = 0;
		for (int j=1; j<sverts.Count(); j++) {
			float dist = LengthSquared (v[i] - v[sverts[j]]);
			if (dist<mindist) {
				best = j;
				mindist = dist;
			}
		}
		vd[i] = Sqrt (mindist);
	}
}

void MeshSelData::UpdateWeightedVSel (float falloff, float pinch, float bubble) {
	int i, nv = vd.Count();
	vs.SetCount (nv);
	for (i=0; i<nv; i++) {
		if (vd[i]<0) {
			vs[i] = 0.0f;
			continue;
		}
		if (vd[i]==0) vs[i] = 1.0f;
		else {
			if (vd[i] > falloff) vs[i] = 0.0f;
			else vs[i] = AffectRegionFunct (vd[i], falloff, pinch, bubble);
		}
	}
}

void MeshSelData::GetWeightedVertSel (int nv, float *wvs) {
	int min = (nv<vertSel.GetSize()) ? nv : vertSel.GetSize ();
	for (int i=0; i<min; i++) wvs[i] = vs[i];
	for (i=min; i<nv; i++) wvs[i] = 0.0f;
}

void MeshSelMod::ModifyObject (TimeValue t, ModContext &mc, ObjectState *os, INode *node) {
	if (!os->obj->IsSubClassOf(triObjectClassID)) return;
	TriObject *tobj = (TriObject*)os->obj;
	MeshSelData *d  = (MeshSelData*)mc.localData;
	if (!d) mc.localData = d = new MeshSelData(tobj->GetMesh());
	if ((editMod==this) && (!d->GetMesh())) d->SetCache(tobj->GetMesh());

	BitArray vertSel = d->vertSel;
	BitArray faceSel = d->faceSel;
	BitArray edgeSel = d->edgeSel;
	vertSel.SetSize(tobj->GetMesh().getNumVerts(),TRUE);
	faceSel.SetSize(tobj->GetMesh().getNumFaces(),TRUE);
	edgeSel.SetSize(tobj->GetMesh().getNumFaces()*3,TRUE);
	tobj->GetMesh().vertSel = vertSel;
	tobj->GetMesh().faceSel = faceSel;
	tobj->GetMesh().edgeSel = edgeSel;

	int useAR;
	Interval outValid;
	outValid = tobj->ChannelValidity (t, SELECT_CHAN_NUM);
	pblock->GetValue (PB_USE_AR, t, useAR, outValid);

	if (useAR) {
		float bubble, pinch, falloff;
		pblock->GetValue (PB_FALLOFF, t, falloff, outValid);
		pblock->GetValue (PB_PINCH, t, pinch, outValid);
		pblock->GetValue (PB_BUBBLE, t, bubble, outValid);

		tobj->GetMesh().SupportVSelectionWeights ();
		float *vs = tobj->GetMesh().getVSelectionWeights ();
		int nv = tobj->GetMesh().getNumVerts();
		d->UpdateVDistances (t, tobj, selLevel);
		d->UpdateWeightedVSel (falloff, pinch, bubble);
		d->GetWeightedVertSel (nv, vs);

		if (pmapParam) pmapParam->Invalidate();
	} else {
		tobj->GetMesh().ClearVSelectionWeights ();
	}

	if (d->GetMesh()) {
		// Keep the cache up to date if it exists.
		d->GetMesh()->vertSel = vertSel;
		d->GetMesh()->faceSel = faceSel;
		d->GetMesh()->edgeSel = edgeSel;
	}

	tobj->GetMesh().dispFlags = 0;
	tobj->GetMesh().SetDispFlag (levelDispFlags[selLevel]);
	tobj->GetMesh().selLevel = meshLevel[selLevel];
	tobj->SetChannelValidity (SELECT_CHAN_NUM, outValid);
}

void MeshSelMod::NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc) {
	if (!mc->localData) return;
	if (partID == PART_SELECT) return;
	((MeshSelData*)mc->localData)->FreeCache();
	if (ip && hParams && editMod==this && !updateCachePosted) {
		TimeValue t = ip->GetTime();
		PostMessage(hParams,WM_UPDATE_CACHE,(WPARAM)t,0);
		updateCachePosted = TRUE;
	}
}

void MeshSelMod::UpdateCache(TimeValue t) {
	NotifyDependents(Interval(t,t), PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|
		PART_DISPLAY|PART_TOPO, REFMSG_MOD_EVAL);
	updateCachePosted = FALSE;
}

void MeshSelMod::InvalidateVDistances () {
	if (!ip) return;
	INodeTab nds;
	ModContextList mcList;
	ip->GetModContexts (mcList, nds);
	int i;
	for (i=0; i<mcList.Count(); i++) {
		MeshSelData *d = (MeshSelData *) mcList[i]->localData;
		if (!d) continue;
		d->InvalidateVDistances ();
	}
}

static int butIDs[] = { 0, IDC_SELVERTEX, IDC_SELEDGE, IDC_SELFACE, IDC_SELPOLY, IDC_SELELEMENT };
void MeshSelMod::UpdateSelLevelDisplay () {
	ICustToolbar *iToolbar = GetICustToolbar(GetDlgItem(hParams,IDC_MS_SELTYPE));
	ICustButton *but;
	for (int i=1; i<6; i++) {
		but = iToolbar->GetICustButton (butIDs[i]);
		but->SetCheck ((DWORD)i==selLevel);
		ReleaseICustButton (but);
	}
	ReleaseICustToolbar (iToolbar);
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	UpdateWindow(hParams);
	ip->RedrawViews(ip->GetTime());
}

static bool oldShowEnd;

void MeshSelMod::BeginEditParams (IObjParam  *ip, ULONG flags,Animatable *prev) {
	this->ip = ip;	
	editMod  = this;
	UpdateSetNames ();

	hParams = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(IDD_MESH_SELECT),
		MeshSelectProc, GetString(IDS_MS_PARAMS), (LPARAM)this);
	pmapParam = CreateCPParamMap (descParam, PARAMDESC_LENGTH, pblock,
		ip, hInstance, MAKEINTRESOURCE(IDD_MESHSEL_AFFECTREGION),
		GetString(IDS_MS_AFFECTREGION), arRollup ? APPENDROLL_CLOSED : 0);
	theAffectRegionProc.em = this;
	pmapParam->SetUserDlgProc (&theAffectRegionProc);

	selectMode = new SelectModBoxCMode(this,ip);

	// Add our sub object type
	TSTR type1(GetString(IDS_RB_VERTEX));
	TSTR type2(GetString(IDS_RB_EDGE));
	TSTR type3(GetString(IDS_RB_FACE));
	TSTR type4(GetString(IDS_EM_POLY));
	TSTR type5(GetString(IDS_EM_ELEMENT));
	const TCHAR *ptype[] = {type1, type2, type3, type4, type5};
	ip->RegisterSubObjectTypes(ptype, 5);

	// Restore the selection level.
	ip->SetSubObjectLevel(selLevel);

	SetEnableStates ();
	UpdateSelLevelDisplay ();
	SetNumSelLabel();

	// Set show end result.
	oldShowEnd = ip->GetShowEndResult() ? TRUE : FALSE;
	ip->SetShowEndResult (GetFlag (MS_DISP_END_RESULT));

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);	
}

void MeshSelMod::EndEditParams (IObjParam *ip,ULONG flags,Animatable *next) {
	if (hParams) ip->DeleteRollupPage(hParams);
	hParams = NULL;
	if (pmapParam) {
		arRollup = IsRollupPanelOpen (pmapParam->GetHWnd ());
		DestroyCPParamMap(pmapParam);
		pmapParam = NULL;
	}
	theAffectRegionProc.em = NULL;

	ip->DeleteMode(selectMode);
	if (selectMode) delete selectMode;
	selectMode = NULL;

	// Reset show end result
	SetFlag (MS_DISP_END_RESULT, ip->GetShowEndResult() ? TRUE : FALSE);
	ip->SetShowEndResult(oldShowEnd);

	this->ip = NULL;
	editMod  = NULL;

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);
	ClearAFlag(A_MOD_BEING_EDITED);
}

int MeshSelMod::HitTest (TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc) {
	Interval valid;
	int savedLimits, res = 0;
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	
	// Setup GW
	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);
	Matrix3 mat = inode->GetObjectTM(t);
	gw->setTransform(mat);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	if (ignoreBackfaces) 
		 gw->setRndLimits(gw->getRndLimits() |  GW_BACKCULL);
	else gw->setRndLimits(gw->getRndLimits() & ~GW_BACKCULL);
	gw->clearHitCode();
		
	SubObjHitList hitList;
	MeshSubHitRec *rec;	

	if (!mc->localData || !((MeshSelData*)mc->localData)->GetMesh()) return 0;

	Mesh &mesh = *((MeshSelData*)mc->localData)->GetMesh();
	if (selLevel>=SEL_FACE && selByVert) {
		res = mesh.SubObjectHitTest(gw, gw->getMaterial(), &hr,
			flags|hitLevel[SEL_VERTEX]|SUBHIT_USEFACESEL, hitList);
	} else {
		res = mesh.SubObjectHitTest(gw, gw->getMaterial(), &hr,
				flags|hitLevel[selLevel], hitList);
		}

	rec = hitList.First();
	while (rec) {
		vpt->LogHit(inode,mc,rec->dist,rec->index,NULL);
		rec = rec->Next();
		}

	gw->setRndLimits(savedLimits);	
	return res;	
	}

int MeshSelMod::Display (TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext *mc) {
	if (!ip->GetShowEndResult ()) return 0;
	if (!selLevel) return 0;
	if (!mc->localData) return 0;

	MeshSelData *modData = (MeshSelData *) mc->localData;
	Mesh *mesh = modData->GetMesh();
	if (!mesh) return 0;

	// Set up GW
	GraphicsWindow *gw = vpt->getGW();
	Matrix3 tm = inode->GetObjectTM(t);
	int savedLimits;
	gw->setRndLimits((savedLimits = gw->getRndLimits()) & ~GW_ILLUM);
	gw->setTransform(tm);

	// We need to draw a "gizmo" version of the mesh:
	Point3 colSel=GetSubSelColor();
	Point3 colTicks=GetUIColor (COLOR_VERT_TICKS);
	Point3 colGiz=GetUIColor(COLOR_GIZMOS);
	Point3 colGizSel=GetUIColor(COLOR_SEL_GIZMOS);
	gw->setColor (LINE_COLOR, colGiz);

	AdjEdgeList *ae = modData->GetAdjEdgeList ();
	Point3 rp[3];
	int i, ect = ae->edges.Count();
	int es[3];
	for (i=0; i<ect; i++) {
		MEdge & me = ae->edges[i];
		if (me.Hidden (mesh->faces)) continue;
		if (me.Visible (mesh->faces)) {
			es[0] = GW_EDGE_VIS;
		} else {
			if (selLevel < SEL_EDGE) continue;
			if (selLevel > SEL_FACE) continue;
			es[0] = GW_EDGE_INVIS;
		}
		if (selLevel == SEL_EDGE) {
			if (ae->edges[i].Selected (mesh->faces, modData->GetEdgeSel())) gw->setColor (LINE_COLOR, colGizSel);
			else gw->setColor (LINE_COLOR, colGiz);
		}
		if (selLevel >= SEL_FACE) {
			if (ae->edges[i].AFaceSelected (modData->GetFaceSel())) gw->setColor (LINE_COLOR, colGizSel);
			else gw->setColor (LINE_COLOR, colGiz);
		}
		rp[0] = mesh->verts[me.v[0]];
		rp[1] = mesh->verts[me.v[1]];
		gw->polyline (2, rp, NULL, NULL, FALSE, es);
	}
	if (selLevel == SEL_VERTEX) {
		float *ourvw = NULL;
		int affectRegion=FALSE;
		if (pblock) pblock->GetValue (PB_USE_AR, t, affectRegion, FOREVER);
		if (affectRegion && modData->vs.Count()) ourvw = modData->vs.Addr(0);
		for (i=0; i<mesh->numVerts; i++) {
			if (mesh->vertHide[i]) continue;

			if (modData->GetVertSel()[i]) gw->setColor (LINE_COLOR, colSel);
			else {
				if (ourvw) gw->setColor (LINE_COLOR, SoftSelectionColor (ourvw[i]));
				else gw->setColor (LINE_COLOR, colTicks);
			}

			if(getUseVertexDots()) gw->marker (&(mesh->verts[i]), getVertexDotType() ? DOT_MRKR : SM_DOT_MRKR);
			else gw->marker (&(mesh->verts[i]), PLUS_SIGN_MRKR);
		}
	}
	gw->setRndLimits(savedLimits);
	return 0;	
}

void MeshSelMod::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp *vpt, Box3& box, ModContext *mc) {
	if (!ip->GetShowEndResult() || !mc->localData) return;
	if (!selLevel) return;
	MeshSelData *modData = (MeshSelData *) mc->localData;
	Mesh *mesh = modData->GetMesh();
	if (!mesh) return;
	Matrix3 tm = inode->GetObjectTM(t);
	box = mesh->getBoundingBox (&tm);
}

void MeshSelMod::GetSubObjectCenters (SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc) {
	if (!mc->localData) return;
	if (selLevel == SEL_OBJECT) return;	// shouldn't happen.
	MeshSelData *modData = (MeshSelData *) mc->localData;
	Mesh *mesh = modData->GetMesh();
	if (!mesh) return;
	Matrix3 tm = node->GetObjectTM(t);

	// For Mesh Select, we merely return the center of the bounding box of the current selection.
	BitArray sel = modData->TempVSel(*mesh, selLevel);
	if (!sel.NumberSet()) return;
	Box3 box;
	for (int i=0; i<mesh->numVerts; i++) if (sel[i]) box += mesh->verts[i] * tm;
	cb->Center (box.Center(),0);
}

void MeshSelMod::GetSubObjectTMs (SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc) {
	if (!mc->localData) return;
	if (selLevel == SEL_OBJECT) return;	// shouldn't happen.
	MeshSelData *modData = (MeshSelData *) mc->localData;
	Mesh *mesh = modData->GetMesh();
	if (!mesh) return;
	Matrix3 tm = node->GetObjectTM(t);

	// For Mesh Select, we merely return the center of the bounding box of the current selection.
	BitArray sel = modData->TempVSel(*mesh, selLevel);
	if (!sel.NumberSet()) return;
	Box3 box;
	for (int i=0; i<mesh->numVerts; i++) if (sel[i]) box += mesh->verts[i] * tm;
	Matrix3 ctm(1);
	ctm.SetTrans (box.Center());
	cb->TM (ctm,0);
}

void MeshSelMod::ActivateSubobjSel(int level, XFormModes& modes) {
	// Set the meshes level
	selLevel = level;

	// Fill in modes with our sub-object modes
	if (level!=SEL_OBJECT) {
		modes = XFormModes(NULL,NULL,NULL,NULL,NULL,selectMode);
	}

	// Update UI
	UpdateSelLevelDisplay ();
	SetEnableStates ();
	SetNumSelLabel ();

	// Setup named selection sets	
	SetupNamedSelDropDown();
	UpdateNamedSelDropDown ();

	// Invalidate the weighted vertex caches
	InvalidateVDistances ();

	NotifyDependents(FOREVER, PART_SUBSEL_TYPE|PART_DISPLAY, REFMSG_CHANGE);
	ip->PipeSelLevelChanged();
	NotifyDependents(FOREVER, SELECT_CHANNEL|DISP_ATTRIB_CHANNEL|SUBSEL_TYPE_CHANNEL, REFMSG_CHANGE);
}

DWORD MeshSelMod::GetSelLevel () {
	switch (selLevel) {
	case SEL_OBJECT: return IMESHSEL_OBJECT;
	case SEL_VERTEX: return IMESHSEL_VERTEX;
	case SEL_EDGE: return IMESHSEL_EDGE;
	}
	return IMESHSEL_FACE;
}

void MeshSelMod::SetSelLevel(DWORD sl) {
	switch (sl) {
	case IMESHSEL_OBJECT:
		selLevel = SEL_OBJECT;
		break;
	case IMESHSEL_VERTEX:
		selLevel = SEL_VERTEX;
		break;
	case IMESHSEL_EDGE:
		selLevel = SEL_EDGE;
		break;
	case IMESHSEL_FACE:
		if (selLevel < SEL_FACE) selLevel = SEL_POLY;	// don't change if we're already in a face mode.
		break;
	}
	if (ip && editMod==this) ip->SetSubObjectLevel(selLevel);
}

void MeshSelMod::LocalDataChanged() {
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	if (ip && editMod==this) {
		SetNumSelLabel();
		UpdateNamedSelDropDown ();
	}
}

void MeshSelMod::UpdateNamedSelDropDown () {
	if (!ip) return;
	if (selLevel == SEL_OBJECT) {
		ip->ClearCurNamedSelSet ();
		return;
	}
	// See if this selection matches a named set
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts (mcList, nodes);
	BitArray nselmatch;
	nselmatch.SetSize (namedSel[namedSetLevel[selLevel]].Count());
	nselmatch.SetAll ();
	int nd, i, foundone=FALSE;
	for (nd=0; nd<mcList.Count(); nd++) {
		MeshSelData *d = (MeshSelData *) mcList[nd]->localData;
		if (!d) continue;
		foundone = TRUE;
		switch (selLevel) {
		case SEL_VERTEX:
			for (i=0; i<nselmatch.GetSize(); i++) {
				if (!nselmatch[i]) continue;
				if (!(*(d->vselSet.sets[i]) == d->vertSel)) nselmatch.Clear(i);
			}
			break;
		case SEL_EDGE:
			for (i=0; i<nselmatch.GetSize(); i++) {
				if (!nselmatch[i]) continue;
				if (!(*(d->eselSet.sets[i]) == d->edgeSel)) nselmatch.Clear(i);
			}
			break;
		default:
			for (i=0; i<nselmatch.GetSize(); i++) {
				if (!nselmatch[i]) continue;
				if (!(*(d->fselSet.sets[i]) == d->faceSel)) nselmatch.Clear(i);
			}
			break;
		}
		if (nselmatch.NumberSet () == 0) break;
	}
	if (foundone && nselmatch.NumberSet ()) {
		for (i=0; i<nselmatch.GetSize(); i++) if (nselmatch[i]) break;
		ip->SetCurNamedSelSet (*(namedSel[namedSetLevel[selLevel]][i]));
	} else ip->ClearCurNamedSelSet ();
}

HitRecord *MeshSelMod::VertHitsToFaceHits(HitRecord *hitRec,BOOL all) {	
	HitRecord *ptr = NULL;
	TimeValue t = ip->GetTime();

	while (hitRec) {
		Mesh &mesh = *(((MeshSelData*)hitRec->modContext->localData)->GetMesh());
		AdjEdgeList el(mesh);		
		
		// Add faces adjacent to this vertex
		DWORDTab &list = el[hitRec->hitInfo];
		for (int i=0; i<list.Count(); i++) {
			if (el.edges[list[i]].f[0]!=UNDEFINED) {
				ptr = new HitRecord(			
					ptr,
					hitRec->nodeRef,
					hitRec->modContext,
					hitRec->distance,
					el.edges[list[i]].f[0],
					NULL);
				}
			if (el.edges[list[i]].f[1]!=UNDEFINED) {
				ptr = new HitRecord(				
					ptr,
					hitRec->nodeRef,
					hitRec->modContext,
					hitRec->distance,
					el.edges[list[i]].f[1],
					NULL);
				}
			}
		
		if (!all) break;
		hitRec = hitRec->Next();
		}
	return ptr;
	}

static AdjFaceList *BuildAdjFaceList(Mesh &mesh)
	{
	AdjEdgeList ae(mesh);
	return new AdjFaceList(mesh,ae);
	}

void MeshSelMod::SelectSubComponent (HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert) {
	MeshSelData *d = NULL, *od = NULL;

	ip->ClearCurNamedSelSet();

	HitRecord *faceHitRec = NULL;
	if ((selLevel >= SEL_FACE) && selByVert) faceHitRec = VertHitsToFaceHits(hitRec,all);

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	TimeValue t = ip->GetTime();
	int nd;
	BitArray nsel;
	AdjFaceList *al = NULL;
	Mesh *mesh;

	for (nd=0; nd<mcList.Count(); nd++) {
		d = (MeshSelData*) mcList[nd]->localData;
		if (d==NULL) continue;
		HitRecord *hr = faceHitRec ? faceHitRec : hitRec;
		if (!all && (hr->modContext->localData != d)) continue;
		for (; hr!=NULL; hr=hr->Next()) if (hr->modContext->localData == d) break;
		if (hr==NULL) continue;

		switch (selLevel) {
		case SEL_VERTEX:
			nsel = d->vertSel;
			for (; hr != NULL; hr = hr->Next()) {
				if (d != hr->modContext->localData) continue;
				nsel.Set (hr->hitInfo, invert ? !nsel[hr->hitInfo] : selected);
				if (!all) break;
			}
			d->SetVertSel (nsel, this, t);
			break;

		case SEL_EDGE:
			nsel = d->edgeSel;
			for (; hr != NULL; hr = hr->Next()) {
				if (d != hr->modContext->localData) continue;
				nsel.Set (hr->hitInfo, invert ? !nsel[hr->hitInfo] : selected);
				if (!all) break;
			}
			d->SetEdgeSel (nsel, this, t);
			break;

		case SEL_FACE:
			mesh = d->GetMesh();
			if (!mesh) break;
			nsel = d->faceSel;
			for (; hr != NULL; hr=hr->Next()) {
				if (d != hr->modContext->localData) continue;
				nsel.Set (hr->hitInfo, invert ? !mesh->faceSel[hr->hitInfo] : selected);
				if (!all) break;
			}
			d->SetFaceSel (nsel, this, t);
			break;

		case SEL_POLY:
		case SEL_ELEMENT:
			mesh = d->GetMesh();
			if (!mesh) break;
			al = BuildAdjFaceList(*mesh);
			nsel.SetSize (mesh->numFaces);
			nsel.ClearAll ();
			for (; hr != NULL; hr=hr->Next()) {
				if (hr->modContext->localData != d) continue;
				if (selLevel == SEL_POLY)
					mesh->PolyFromFace (hr->hitInfo, nsel, GetPolyFaceThresh(), ignoreVisEdge, al);
				else
					mesh->ElementFromFace (hr->hitInfo, nsel, al);
				if (!all) break;
			}
			delete al;

			if (invert) nsel ^= d->faceSel;
			else if (selected) nsel |= d->faceSel;
			else nsel = d->faceSel & ~nsel;

			d->SetFaceSel (nsel, this, t);
			break;
		}
	}

	if (faceHitRec) {
		// Delete the hits:
		HitRecord *ptr = faceHitRec;
		while (ptr) {
			faceHitRec = ptr;
			ptr = ptr->Next();
			delete faceHitRec;
		}
	}

	nodes.DisposeTemporary ();
	LocalDataChanged ();
}

void MeshSelMod::ClearSelection(int selLevel) {
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	MeshSelData *d;
	BitArray nsel;
	for (int i=0; i<list.Count(); i++) {
		d = (MeshSelData*)list[i]->localData;
		if (!d) continue;

		switch (selLevel) {
		case SEL_VERTEX:
			if (!d->vertSel.NumberSet()) break;
			nsel.SetSize (d->vertSel.GetSize());
			nsel.ClearAll ();
			d->SetVertSel (nsel, this, ip->GetTime());
			break;

		case SEL_FACE:
		case SEL_POLY:
		case SEL_ELEMENT:
			if (!d->faceSel.NumberSet()) break;
			nsel.SetSize (d->faceSel.GetSize());
			nsel.ClearAll ();
			d->SetFaceSel (nsel, this, ip->GetTime());
			break;

		case SEL_EDGE:
			if (!d->edgeSel.NumberSet()) break;
			nsel.SetSize (d->edgeSel.GetSize());
			nsel.ClearAll ();
			d->SetEdgeSel (nsel, this, ip->GetTime());
			break;
		}
	}
	nodes.DisposeTemporary();
	LocalDataChanged ();
}

void MeshSelMod::SelectAll(int selLevel) {
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	MeshSelData *d;
	BitArray nsel;
	for (int i=0; i<list.Count(); i++) {
		d = (MeshSelData*)list[i]->localData;		
		if (!d) continue;
		switch (selLevel) {
		case SEL_VERTEX:
			nsel.SetSize (d->vertSel.GetSize());
			nsel.SetAll();
			d->SetVertSel (nsel, this, ip->GetTime());
			break;
		case SEL_FACE:
		case SEL_POLY:
		case SEL_ELEMENT:
			nsel.SetSize (d->faceSel.GetSize());
			nsel.SetAll();
			d->SetFaceSel (nsel, this, ip->GetTime());
			break;
		case SEL_EDGE:
			nsel.SetSize (d->edgeSel.GetSize());
			nsel.SetAll();
			d->SetEdgeSel (nsel, this, ip->GetTime());
			break;
		}
	}
	nodes.DisposeTemporary();
	LocalDataChanged ();
}

void MeshSelMod::InvertSelection(int selLevel) {
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	MeshSelData *d;
	for (int i=0; i<list.Count(); i++) {
		d = (MeshSelData*)list[i]->localData;
		if (!d) continue;
		switch (selLevel) {
		case SEL_VERTEX:
			d->SetVertSel (~d->vertSel, this, ip->GetTime());
			break;
		case SEL_FACE:
		case SEL_POLY:
		case SEL_ELEMENT:
			d->SetFaceSel (~d->faceSel, this, ip->GetTime());
			break;
		case SEL_EDGE:
			d->SetEdgeSel (~d->edgeSel, this, ip->GetTime());
			break;
		}
	}
	nodes.DisposeTemporary();
	LocalDataChanged ();
}

void MeshSelMod::SelectByMatID(int id) {
	BOOL add = GetKeyState(VK_CONTROL)<0 ? TRUE : FALSE;
	BOOL sub = GetKeyState(VK_MENU)<0 ? TRUE : FALSE;
	theHold.Begin();
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	MeshSelData *d;
	BitArray nsel;
	for (int i=0; i<list.Count(); i++) {
		d = (MeshSelData*)list[i]->localData;		
		if (!d) continue;
		nsel = d->faceSel;
		if (!add && !sub) nsel.ClearAll();
		Mesh *mesh = d->GetMesh();
		if (!mesh) continue;
		for (int i=0; i<mesh->numFaces; i++) {
			if (mesh->faces[i].getMatID()==(MtlID)id) {
				if (sub) nsel.Clear(i);
				else nsel.Set(i);
			}
		}
		d->SetFaceSel (nsel, this, ip->GetTime ());
	}
	nodes.DisposeTemporary();
	theHold.Accept(GetString (IDS_RB_SELECTBYMATID));
	LocalDataChanged ();
	ip->RedrawViews(ip->GetTime());
}

void MeshSelMod::SelectOpenEdges() {
	theHold.Begin();
	ModContextList list;
	INodeTab nodes;
	ip->GetModContexts(list,nodes);
	MeshSelData *d;
	BitArray nsel;
	for (int i=0; i<list.Count(); i++) {
		d = (MeshSelData*)list[i]->localData;		
		if (!d) continue;
		if (!d->mesh) continue;

		nsel.SetSize (d->mesh->numFaces*3);
		nsel.ClearAll ();

		AdjEdgeList adj(*d->mesh);
		for (int j=0; j<adj.edges.Count(); j++) {
			MEdge & me = adj.edges[j];
			if (me.f[0]==UNDEFINED) {
				int wh = d->mesh->faces[me.f[1]].GetEdgeIndex (me.v[0], me.v[1]);
				nsel.Set (me.f[1]*3+wh);
			}
			if (me.f[1]==UNDEFINED) {
				int wh = d->mesh->faces[me.f[0]].GetEdgeIndex (me.v[0], me.v[1]);
				nsel.Set (me.f[0]*3+wh);
			}
		}
		d->SetEdgeSel (nsel, this, ip->GetTime());
	}
	nodes.DisposeTemporary();
	theHold.Accept(GetString (IDS_EM_SELECT_OPEN));
	LocalDataChanged ();
	ip->RedrawViews(ip->GetTime());
}

void MeshSelMod::SelectFrom(int from) {
	ModContextList list;
	INodeTab nodes;
	ip->GetModContexts(list,nodes);
	MeshSelData *d;
	theHold.Begin();
	for (int i=0; i<list.Count(); i++) {
		d = (MeshSelData*)list[i]->localData;
		if (!d) continue;

		switch (selLevel) {
		case SEL_VERTEX: 
			if (from>=SEL_FACE) d->SetVertSel (d->SelVertByFace(), this, ip->GetTime());
			else d->SetVertSel (d->SelVertByEdge(), this, ip->GetTime());
			break;
		case SEL_FACE:
			if (from==SEL_VERTEX) d->SetFaceSel (d->SelFaceByVert(), this, ip->GetTime());
			else d->SetFaceSel (d->SelFaceByEdge(), this, ip->GetTime());
			break;
		case SEL_POLY:
			if (from==SEL_VERTEX) d->SetFaceSel (d->SelPolygonByVert(GetPolyFaceThresh(), ignoreVisEdge), this, ip->GetTime());
			else d->SetFaceSel (d->SelPolygonByEdge(GetPolyFaceThresh(), ignoreVisEdge), this, ip->GetTime());
			break;
		case SEL_ELEMENT:
			if (from==SEL_VERTEX) d->SetFaceSel (d->SelElementByVert(), this, ip->GetTime());
			else d->SetFaceSel (d->SelElementByEdge(), this, ip->GetTime());
			break;
		case SEL_EDGE:
			if (from==SEL_VERTEX) d->SetEdgeSel (d->SelEdgeByVert(), this, ip->GetTime());
			else d->SetEdgeSel (d->SelEdgeByFace(), this, ip->GetTime());
			break;
		}
	}
	theHold.Accept(GetString(IDS_DS_SELECT));
	nodes.DisposeTemporary();
	LocalDataChanged ();
	ip->RedrawViews(ip->GetTime());
}

float MeshSelMod::GetPolyFaceThresh() {
	ISpinnerControl *spin = GetISpinner(GetDlgItem(hParams,IDC_MS_PLANARSPINNER));
	float thresh = spin->GetFVal();
	ReleaseISpinner(spin);
	return DegToRad(thresh);
}

#define SELLEVEL_CHUNKID		0x0100
#define VERTSEL_CHUNKID			0x0200
#define FACESEL_CHUNKID			0x0210
#define EDGESEL_CHUNKID			0x0220
#define VERSION_CHUNKID        0x0230
#define FLAGS_CHUNKID 0x0240
static int currentVersion = 3;

#define NAMEDVSEL_NAMES_CHUNK	0x2805
#define NAMEDFSEL_NAMES_CHUNK	0x2806
#define NAMEDESEL_NAMES_CHUNK	0x2807
#define NAMEDSEL_STRING_CHUNK	0x2809
#define NAMEDSEL_ID_CHUNK		0x2810

#define VSELSET_CHUNK			0x2845
#define FSELSET_CHUNK			0x2846
#define ESELSET_CHUNK			0x2847

static int namedSelID[] = {NAMEDVSEL_NAMES_CHUNK,NAMEDESEL_NAMES_CHUNK,NAMEDFSEL_NAMES_CHUNK, NAMEDFSEL_NAMES_CHUNK, NAMEDFSEL_NAMES_CHUNK};

IOResult MeshSelMod::Save(ISave *isave) {
	IOResult res;
	ULONG nb;
	Modifier::Save(isave);
	isave->BeginChunk(SELLEVEL_CHUNKID);
	res = isave->Write(&selLevel, sizeof(selLevel), &nb);
	isave->EndChunk();
	isave->BeginChunk (VERSION_CHUNKID);
	res = isave->Write (&currentVersion, sizeof(int), &nb);
	isave->EndChunk();

	isave->BeginChunk (FLAGS_CHUNKID);
	res = isave->Write (&flags, sizeof(DWORD), &nb);
	isave->EndChunk();

	for (int j=0; j<3; j++) {
		if (namedSel[j].Count()) {
			isave->BeginChunk(namedSelID[j]);			
			for (int i=0; i<namedSel[j].Count(); i++) {
				isave->BeginChunk(NAMEDSEL_STRING_CHUNK);
				isave->WriteWString(*namedSel[j][i]);
				isave->EndChunk();

				isave->BeginChunk(NAMEDSEL_ID_CHUNK);
				isave->Write(&ids[j][i],sizeof(DWORD),&nb);
				isave->EndChunk();
				}
			isave->EndChunk();
			}
		}

	return res;
	}

IOResult MeshSelMod::LoadNamedSelChunk(ILoad *iload,int level) {	
	IOResult res;
	DWORD ix=0;
	ULONG nb;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
		case NAMEDSEL_STRING_CHUNK: {
			TCHAR *name;
			res = iload->ReadWStringChunk(&name);
			//AddSet(TSTR(name),level+1);
			TSTR *newName = new TSTR(name);
			namedSel[level].Append(1,&newName);				
			ids[level].Append(1,&ix);
			ix++;
			break;
			}
		case NAMEDSEL_ID_CHUNK:
			iload->Read(&ids[level][ids[level].Count()-1],sizeof(DWORD), &nb);
			break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) return res;
	}
	return IO_OK;
}

IOResult MeshSelMod::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	int version = 2;
	Modifier::Load(iload);
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
		case SELLEVEL_CHUNKID:
			iload->Read(&selLevel, sizeof(selLevel), &nb);
			break;

		case VERSION_CHUNKID:
			iload->Read (&version, sizeof(selLevel), &nb);
			break;

		case FLAGS_CHUNKID:
			iload->Read (&flags, sizeof(DWORD), &nb);
			break;

		case NAMEDVSEL_NAMES_CHUNK:
			res = LoadNamedSelChunk(iload,0);
			break;

		case NAMEDESEL_NAMES_CHUNK:
			res = LoadNamedSelChunk(iload,1);
			break;

		case NAMEDFSEL_NAMES_CHUNK:
			res = LoadNamedSelChunk(iload,2);
			break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) return res;
	}
	if (version<3) {
		if ((selLevel>1) && (selLevel<4)) selLevel = 5-selLevel;	// switched faces, edges in 3.0
	}
	return IO_OK;
}

IOResult MeshSelMod::SaveLocalData(ISave *isave, LocalModData *ld) {	
	MeshSelData *d = (MeshSelData*)ld;

	isave->BeginChunk(VERTSEL_CHUNKID);
	d->vertSel.Save(isave);
	isave->EndChunk();

	isave->BeginChunk(FACESEL_CHUNKID);
	d->faceSel.Save(isave);
	isave->EndChunk();

	isave->BeginChunk(EDGESEL_CHUNKID);
	d->edgeSel.Save(isave);
	isave->EndChunk();
	
	if (d->vselSet.Count()) {
		isave->BeginChunk(VSELSET_CHUNK);
		d->vselSet.Save(isave);
		isave->EndChunk();
		}
	if (d->eselSet.Count()) {
		isave->BeginChunk(ESELSET_CHUNK);
		d->eselSet.Save(isave);
		isave->EndChunk();
		}
	if (d->fselSet.Count()) {
		isave->BeginChunk(FSELSET_CHUNK);
		d->fselSet.Save(isave);
		isave->EndChunk();
		}

	return IO_OK;
	}

IOResult MeshSelMod::LoadLocalData(ILoad *iload, LocalModData **pld) {
	MeshSelData *d = new MeshSelData;
	*pld = d;
	IOResult res;	
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VERTSEL_CHUNKID:
				d->vertSel.Load(iload);
				break;
			case FACESEL_CHUNKID:
				d->faceSel.Load(iload);
				break;
			case EDGESEL_CHUNKID:
				d->edgeSel.Load(iload);
				break;

			case VSELSET_CHUNK:
				res = d->vselSet.Load(iload);
				break;
			case FSELSET_CHUNK:
				res = d->fselSet.Load(iload);
				break;
			case ESELSET_CHUNK:
				res = d->eselSet.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) return res;
	}
	return IO_OK;
}



// Window Procs ------------------------------------------------------

void MeshSelMod::SetEnableStates() {
	ICustButton *but;
	ISpinnerControl *spin;
	EnableWindow (GetDlgItem (hParams, IDC_MS_SEL_BYVERT), selLevel && (selLevel != SEL_VERTEX));
	EnableWindow (GetDlgItem (hParams, IDC_MS_IGNORE_BACKFACES), selLevel>SEL_VERTEX);
	EnableWindow (GetDlgItem (hParams, IDC_MS_IGNORE_VISEDGE), selLevel == SEL_POLY);
	EnableWindow (GetDlgItem (hParams, IDC_MS_PLANAR_TEXT), selLevel == SEL_POLY);
	spin = GetISpinner (GetDlgItem (hParams, IDC_MS_PLANARSPINNER));
	spin->Enable (selLevel==SEL_POLY);
	ReleaseISpinner (spin);

	but = GetICustButton (GetDlgItem (hParams, IDC_MS_GETVERT));
	but->Enable (selLevel && (selLevel != SEL_VERTEX));
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hParams, IDC_MS_GETEDGE));
	but->Enable (selLevel && (selLevel != SEL_EDGE));
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hParams, IDC_MS_GETFACE));
	but->Enable (selLevel && (selLevel < SEL_FACE));
	ReleaseICustButton (but);

	EnableWindow (GetDlgItem (hParams, IDC_MS_SELBYMAT_BOX), selLevel >= SEL_FACE);
	EnableWindow (GetDlgItem (hParams, IDC_MS_SELBYMAT_TEXT), selLevel >= SEL_FACE);
	but = GetICustButton (GetDlgItem (hParams, IDC_MS_SELBYMAT));
	but->Enable (selLevel >= SEL_FACE);
	ReleaseICustButton (but);
	spin = GetISpinner (GetDlgItem (hParams, IDC_MS_MATIDSPIN));
	spin->Enable (selLevel >= SEL_FACE);
	ReleaseISpinner (spin);

	but = GetICustButton (GetDlgItem (hParams, IDC_MS_COPYNS));
	but->Enable (selLevel);
	ReleaseICustButton(but);
	but = GetICustButton (GetDlgItem (hParams,IDC_MS_PASTENS));
	but->Enable (selLevel && (GetMeshNamedSelClip (namedClipLevel[selLevel]) ? TRUE : FALSE));
	ReleaseICustButton(but);
	but = GetICustButton (GetDlgItem (hParams, IDC_MS_SELOPEN));
	but->Enable (selLevel==SEL_EDGE);
	ReleaseICustButton(but);
}

static MeshSelImageHandler theMeshSelImageHandler;

static BOOL CALLBACK MeshSelectProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {	
	MeshSelMod *mod = (MeshSelMod*)GetWindowLong(hWnd,GWL_USERDATA);
	ICustToolbar *iToolbar;
	ISpinnerControl *spin;

	switch (msg) {
	case WM_INITDIALOG:
		mod = (MeshSelMod*)lParam;
		mod->hParams = hWnd;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);

		iToolbar = GetICustToolbar(GetDlgItem(hWnd,IDC_MS_SELTYPE));
		iToolbar->SetImage (theMeshSelImageHandler.LoadImages());
		iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,0,5,0,5,24,23,24,23,IDC_SELVERTEX));
		iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,1,6,1,6,24,23,24,23,IDC_SELEDGE));
		iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,2,7,2,7,24,23,24,23,IDC_SELFACE));
		iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,3,8,3,8,24,23,24,23,IDC_SELPOLY));
		iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,4,9,4,9,24,23,24,23,IDC_SELELEMENT));
		ReleaseICustToolbar(iToolbar);
		mod->UpdateSelLevelDisplay ();

		spin = GetISpinner(GetDlgItem(hWnd,IDC_MS_PLANARSPINNER));
		spin->SetLimits (0, 180, FALSE);
		spin->SetScale (0.1f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_MS_PLANAR), EDITTYPE_FLOAT);
		spin->SetValue(lastFaceThresh,FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_MS_MATIDSPIN));
		spin->SetLimits(1, 65535, FALSE);
		spin->SetScale(0.1f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_MS_MATID), EDITTYPE_INT);
		spin->SetValue(lastMatID,FALSE);
		ReleaseISpinner(spin);

		CheckDlgButton(hWnd,IDC_MS_SEL_BYVERT,mod->selByVert);
		CheckDlgButton(hWnd,IDC_MS_IGNORE_BACKFACES,mod->ignoreBackfaces);
		CheckDlgButton(hWnd,IDC_MS_IGNORE_VISEDGE,mod->ignoreVisEdge);
		mod->SetEnableStates();
		break;

	case WM_UPDATE_CACHE:
		mod->UpdateCache((TimeValue)wParam);
 		break;

	case WM_DESTROY:
		spin = GetISpinner(GetDlgItem(hWnd,IDC_MS_PLANARSPINNER));
		lastFaceThresh = spin->GetFVal();
		ReleaseISpinner(spin);
		spin = GetISpinner(GetDlgItem(hWnd,IDC_MS_MATIDSPIN));
		lastMatID = spin->GetIVal();
		ReleaseISpinner(spin);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDC_MS_SELBYMAT:
			spin = GetISpinner(GetDlgItem(hWnd,IDC_MS_MATIDSPIN));
			mod->SelectByMatID(spin->GetIVal()-1);
			ReleaseISpinner(spin);
			break;

		case IDC_SELVERTEX:
			if (mod->selLevel == SEL_VERTEX) mod->ip->SetSubObjectLevel (SEL_OBJECT);
			else mod->ip->SetSubObjectLevel (SEL_VERTEX);
			break;

		case IDC_SELEDGE:
			if (mod->selLevel == SEL_EDGE) mod->ip->SetSubObjectLevel (SEL_OBJECT);
			else mod->ip->SetSubObjectLevel (SEL_EDGE);
			break;

		case IDC_SELFACE:
			if (mod->selLevel == SEL_FACE) mod->ip->SetSubObjectLevel (SEL_OBJECT);
			else mod->ip->SetSubObjectLevel (SEL_FACE);
			break;

		case IDC_SELPOLY:
			if (mod->selLevel == SEL_POLY) mod->ip->SetSubObjectLevel (SEL_OBJECT);
			else mod->ip->SetSubObjectLevel (SEL_POLY);
			break;

		case IDC_SELELEMENT:
			if (mod->selLevel == SEL_ELEMENT) mod->ip->SetSubObjectLevel (SEL_OBJECT);
			else mod->ip->SetSubObjectLevel (SEL_ELEMENT);
			break;

		case IDC_MS_SEL_BYVERT:
			mod->selByVert = IsDlgButtonChecked(hWnd,IDC_MS_SEL_BYVERT);
			break;

		case IDC_MS_IGNORE_BACKFACES:
			mod->ignoreBackfaces = IsDlgButtonChecked(hWnd,IDC_MS_IGNORE_BACKFACES);
			break;

		case IDC_MS_IGNORE_VISEDGE:
			mod->ignoreVisEdge = IsDlgButtonChecked(hWnd,IDC_MS_IGNORE_VISEDGE);
			break;

		case IDC_MS_SELOPEN: mod->SelectOpenEdges(); break;

		case IDC_MS_GETVERT: mod->SelectFrom(SEL_VERTEX); break;
		case IDC_MS_GETEDGE: mod->SelectFrom(SEL_EDGE); break;
		case IDC_MS_GETFACE: mod->SelectFrom(SEL_FACE); break;

		case IDC_MS_COPYNS:  mod->NSCopy();  break;
		case IDC_MS_PASTENS: mod->NSPaste(); break;
		}
		break;

	case WM_NOTIFY:
		if (((LPNMHDR)lParam)->code != TTN_NEEDTEXT) break;
		LPTOOLTIPTEXT lpttt;
		lpttt = (LPTOOLTIPTEXT)lParam;				
		switch (lpttt->hdr.idFrom) {
		case IDC_SELVERTEX:
			lpttt->lpszText = GetString (IDS_RB_VERTEX);
			break;
		case IDC_SELEDGE:
			lpttt->lpszText = GetString (IDS_RB_EDGE);
			break;
		case IDC_SELFACE:
			lpttt->lpszText = GetString(IDS_RB_FACE);
			break;
		case IDC_SELPOLY:
			lpttt->lpszText = GetString(IDS_EM_POLY);
			break;
		case IDC_SELELEMENT:
			lpttt->lpszText = GetString(IDS_EM_ELEMENT);
			break;
		}
		break;
	
	default: return FALSE;
	}
	return TRUE;
}

#define GRAPHSTEPS 20

static void DrawCurve (HWND hWnd,HDC hdc) {
	float pinch, falloff, bubble;
	ISpinnerControl *spin = GetISpinner(GetDlgItem(hWnd,IDC_FALLOFFSPIN));
	falloff = spin->GetFVal();
	ReleaseISpinner(spin);	

	spin = GetISpinner(GetDlgItem(hWnd,IDC_PINCHSPIN));
	pinch = spin->GetFVal();
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_BUBBLESPIN));
	bubble = spin->GetFVal();
	ReleaseISpinner(spin);	

	TSTR label = FormatUniverseValue(falloff);
	SetWindowText(GetDlgItem(hWnd,IDC_FARLEFTLABEL),label);
	SetWindowText(GetDlgItem(hWnd,IDC_FARRIGHTLABEL),label);

	Rect rect, orect;
	GetClientRectP(GetDlgItem(hWnd,IDC_AR_GRAPH),&rect);
	orect = rect;

	SelectObject(hdc,GetStockObject(NULL_PEN));
	SelectObject(hdc,GetStockObject(WHITE_BRUSH));
	Rectangle(hdc,rect.left,rect.top,rect.right,rect.bottom);	
	SelectObject(hdc,GetStockObject(NULL_BRUSH));
	
	rect.left   += 3;
	rect.right  -= 3;
	rect.top    += 20;
	rect.bottom -= 20;
	
	SelectObject(hdc,CreatePen(PS_DOT,0,GetSysColor(COLOR_BTNFACE)));
	MoveToEx(hdc,orect.left,rect.top,NULL);
	LineTo(hdc,orect.right,rect.top);
	MoveToEx(hdc,orect.left,rect.bottom,NULL);
	LineTo(hdc,orect.right,rect.bottom);
	MoveToEx(hdc,(rect.left+rect.right)/2,orect.top,NULL);
	LineTo(hdc,(rect.left+rect.right)/2,orect.bottom);
	DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));
	
	MoveToEx(hdc,rect.left,rect.bottom,NULL);
	for (int i=0; i<=GRAPHSTEPS; i++) {
		float dist = falloff * float(abs(i-GRAPHSTEPS/2))/float(GRAPHSTEPS/2);		
		float y = AffectRegionFunct(dist,falloff,pinch,bubble);
		int ix = rect.left + int(float(rect.w()-1) * float(i)/float(GRAPHSTEPS));
		int	iy = rect.bottom - int(y*float(rect.h()-2)) - 1;
		if (iy<orect.top) iy = orect.top;
		if (iy>orect.bottom-1) iy = orect.bottom-1;
		LineTo(hdc, ix, iy);
	}
	
	WhiteRect3D(hdc,orect,TRUE);
}

BOOL AffectRegionProc::DlgProc (TimeValue t, IParamMap *map,
										HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	if (!em) return FALSE;
	Rect rect;
	TSTR zero;
	ISpinnerControl *spin;

	switch (msg) {
	case WM_INITDIALOG:
		spin = GetISpinner (GetDlgItem(hWnd,IDC_FALLOFFSPIN));
		spin->SetResetValue (DEF_FALLOFF);
		ReleaseISpinner (spin);
		zero = FormatUniverseValue(0.0f);
		SetWindowText(GetDlgItem(hWnd,IDC_NEARLABEL),zero);
		ShowWindow(GetDlgItem(hWnd,IDC_AR_GRAPH),SW_HIDE);
		break;
		
	case WM_PAINT: {
		PAINTSTRUCT ps;
		HDC hdc = BeginPaint(hWnd,&ps);
		DrawCurve(hWnd,hdc);
		EndPaint(hWnd,&ps);
		return FALSE;
		}

	case CC_SPINNER_CHANGE:
		GetClientRectP(GetDlgItem(hWnd,IDC_AR_GRAPH),&rect);
		InvalidateRect(hWnd,&rect,FALSE);
		return FALSE;
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

static BOOL CALLBACK PickSetNameDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static TSTR *name;

	switch (msg) {
		case WM_INITDIALOG: {
			name = (TSTR*)lParam;
			ICustEdit *edit =GetICustEdit(GetDlgItem(hWnd,IDC_SET_NAME));
			edit->SetText(*name);
			ReleaseICustEdit(edit);
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK: {
					ICustEdit *edit =GetICustEdit(GetDlgItem(hWnd,IDC_SET_NAME));
					TCHAR buf[256];
					edit->GetText(buf,256);
					*name = TSTR(buf);
					ReleaseICustEdit(edit);
					EndDialog(hWnd,1);
					break;
					}

				case IDCANCEL:
					EndDialog(hWnd,0);
					break;
				}
			break;

		default:
			return FALSE;
		};
	return TRUE;
	}

BOOL MeshSelMod::GetUniqueSetName(TSTR &name) {
	while (1) {				
		Tab<TSTR*> &setList = namedSel[namedSetLevel[selLevel]];

		BOOL unique = TRUE;
		for (int i=0; i<setList.Count(); i++) {
			if (name==*setList[i]) {
				unique = FALSE;
				break;
			}
		}
		if (unique) break;

		if (!ip) return FALSE;
		if (!DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_PASTE_NAMEDSET),
			ip->GetMAXHWnd(), PickSetNameDlgProc, (LPARAM)&name)) return FALSE;
		if (!ip) return FALSE;
	}
	return TRUE;
}

static BOOL CALLBACK PickSetDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
	case WM_INITDIALOG:	{
		Tab<TSTR*> *setList = (Tab<TSTR*>*)lParam;
		for (int i=0; i<setList->Count(); i++) {
			int pos  = SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_ADDSTRING,0,
				(LPARAM)(TCHAR*)*(*setList)[i]);
			SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_SETITEMDATA,pos,i);
		}
		break;
	}

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDC_NS_LIST:
			if (HIWORD(wParam)!=LBN_DBLCLK) break;
			// fall through

		case IDOK:
			int sel;
			sel = SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_GETCURSEL,0,0);
			if (sel!=LB_ERR) {
				int res =SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_GETITEMDATA,sel,0);
				EndDialog(hWnd,res);
				break;
			}
			// fall through

		case IDCANCEL:
			EndDialog(hWnd,-1);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

// MeshSelData -----------------------------------------------------

LocalModData *MeshSelData::Clone() {
	MeshSelData *d = new MeshSelData;
	d->vertSel = vertSel;
	d->faceSel = faceSel;
	d->edgeSel = edgeSel;
	held = FALSE;
	mesh = NULL;
	return d;
	}

MeshSelData::MeshSelData(Mesh &mesh) {
	vertSel = mesh.vertSel;
	faceSel = mesh.faceSel;
	edgeSel = mesh.edgeSel;
	held = FALSE;
	this->mesh = NULL;
	ae = NULL;
	vdValid = NEVER;
}

void MeshSelData::SynchBitArrays()
{
	if (mesh) {
		vertSel.SetSize(mesh->vertSel.GetSize(),TRUE);
		faceSel.SetSize(mesh->faceSel.GetSize(),TRUE);
		edgeSel.SetSize(mesh->edgeSel.GetSize(),TRUE);
	}
}

AdjEdgeList *MeshSelData::GetAdjEdgeList () {
	if (!mesh) return NULL;
	if (!ae) ae = new AdjEdgeList (*mesh);
	return ae;
}

void MeshSelData::SetCache(Mesh &mesh) {
	if (this->mesh) delete this->mesh;
	if (ae) delete ae;
	ae = NULL;
	this->mesh = new Mesh(mesh);
	SynchBitArrays ();
}

void MeshSelData::FreeCache() {
	if (mesh) delete mesh;
	mesh = NULL;
	if (ae) delete ae;
	ae = NULL;
	InvalidateVDistances ();
}

void MeshSelData::SetVertSel(BitArray &set, IMeshSelect *imod, TimeValue t) {
	MeshSelMod *mod = (MeshSelMod *) imod;
	if (theHold.Holding()) theHold.Put (new MeshSelRestore (mod, this, SEL_VERTEX));
	vertSel = set;
	if (mesh) mesh->vertSel = set;
	InvalidateVDistances ();
}

void MeshSelData::SetFaceSel(BitArray &set, IMeshSelect *imod, TimeValue t) {
	MeshSelMod *mod = (MeshSelMod *) imod;
	if (theHold.Holding()) theHold.Put (new MeshSelRestore (mod, this, SEL_FACE));
	faceSel = set;
	if (mesh) mesh->faceSel = set;
}

void MeshSelData::SetEdgeSel(BitArray &set, IMeshSelect *imod, TimeValue t) {
	MeshSelMod *mod = (MeshSelMod *) imod;
	if (theHold.Holding()) theHold.Put (new MeshSelRestore (mod, this, SEL_EDGE));
	edgeSel = set;
	if (mesh) mesh->edgeSel = set;
}

BitArray MeshSelData::SelVertByFace() {
	BitArray nsel = vertSel;
	DbgAssert (mesh);
	if (!mesh) return nsel;
	for (int i=0; i<mesh->getNumFaces(); i++) {
		if (faceSel[i]) {
			for (int j=0; j<3; j++) {
				nsel.Set (mesh->faces[i].v[j]);
			}
		}
	}
	return nsel;
}

BitArray MeshSelData::SelVertByEdge() {
	BitArray nsel = vertSel;
	DbgAssert (mesh);
	if (!mesh) return nsel;
	for (int i=0; i<mesh->getNumFaces(); i++) {		
		for (int j=0; j<3; j++) {
			if (edgeSel[i*3+j]) {
				nsel.Set(mesh->faces[i].v[j],TRUE);
				nsel.Set(mesh->faces[i].v[(j+1)%3],TRUE);
			}
		}
	}
	return nsel;
}

BitArray MeshSelData::SelFaceByVert() {
	BitArray nsel = faceSel;
	DbgAssert (mesh);
	if (!mesh) return nsel;
	for (int i=0; i<mesh->getNumFaces(); i++) {
		for (int j=0; j<3; j++) {
			if (vertSel[mesh->faces[i].v[j]]) {
				nsel.Set(i);
				break;
			}
		}
	}
	return nsel;
}

BitArray MeshSelData::SelFaceByEdge() {
	BitArray nsel = faceSel;
	DbgAssert (mesh);
	if (!mesh) return nsel;
	for (int i=0; i<mesh->getNumFaces(); i++) {
		for (int j=0; j<3; j++) {
			if (edgeSel[i*3+j]) {
				nsel.Set(i);
				break;
			}
		}
	}
	return nsel;
}

BitArray MeshSelData::SelPolygonByVert (float thresh, int igVis) {
	BitArray nsel = faceSel;
	DbgAssert (mesh);
	if (!mesh) return nsel;
	AdjEdgeList al(*mesh);
	AdjFaceList af(*mesh, al);
	for (int i=0; i<mesh->getNumFaces(); i++) {
		for (int j=0; j<3; j++) if (vertSel[mesh->faces[i].v[j]]) break;
		if (j==3) continue;
		mesh->PolyFromFace (i, nsel, thresh, igVis, &af);
	}
	return nsel;
}

BitArray MeshSelData::SelPolygonByEdge (float thresh, int igVis) {
	BitArray nsel = faceSel;
	DbgAssert (mesh);
	if (!mesh) return nsel;
	AdjEdgeList al(*mesh);
	AdjFaceList af(*mesh, al);
	for (int i=0; i<mesh->getNumFaces(); i++) {
		for (int j=0; j<3; j++) if (edgeSel[i*3+j]) break;
		if (j==3) continue;
		mesh->PolyFromFace (i, nsel, thresh, igVis, &af);
	}
	return nsel;
}

BitArray MeshSelData::SelElementByVert () {
	BitArray nsel = faceSel;
	DbgAssert (mesh);
	if (!mesh) return nsel;
	AdjEdgeList al(*mesh);
	AdjFaceList af(*mesh, al);
	for (int i=0; i<mesh->getNumFaces(); i++) {
		for (int j=0; j<3; j++) if (vertSel[mesh->faces[i].v[j]]) break;
		if (j==3) continue;
		mesh->ElementFromFace (i, nsel, &af);
	}
	return nsel;
}

BitArray MeshSelData::SelElementByEdge () {
	BitArray nsel = faceSel;
	DbgAssert (mesh);
	if (!mesh) return nsel;
	AdjEdgeList al(*mesh);
	AdjFaceList af(*mesh, al);
	for (int i=0; i<mesh->getNumFaces(); i++) {
		for (int j=0; j<3; j++) if (edgeSel[i*3+j]) break;
		if (j==3) continue;
		mesh->ElementFromFace (i, nsel, &af);
	}
	return nsel;
}

BitArray MeshSelData::SelEdgeByVert() {
	BitArray nsel = edgeSel;
	DbgAssert (mesh);
	if (!mesh) return nsel;
	for (int i=0; i<mesh->getNumFaces(); i++) {
		for (int j=0; j<3; j++) {
			if (vertSel[mesh->faces[i].v[j]]) nsel.Set(i*3+j);
			if (vertSel[mesh->faces[i].v[(j+1)%3]]) nsel.Set(i*3+j);
		}
	}
	return nsel;
}

BitArray MeshSelData::SelEdgeByFace() {
	BitArray nsel = edgeSel;
	DbgAssert (mesh);
	if (!mesh) return nsel;
	for (int i=0; i<mesh->getNumFaces(); i++) {
		if (faceSel[i]) {
			for (int j=0; j<3; j++) nsel.Set(i*3+j);
		}
	}
	return nsel;
}


// MeshSelRestore --------------------------------------------------

MeshSelRestore::MeshSelRestore(MeshSelMod *m, MeshSelData *data) {
	mod     = m;
	level   = mod->selLevel;
	d       = data;
	d->held = TRUE;
	switch (level) {
	case SEL_OBJECT: MaxAssert(0); break;
	case SEL_VERTEX: usel = d->vertSel; break;
	case SEL_EDGE: usel = d->edgeSel; break;
	default: usel = d->faceSel; break;
	}
}

MeshSelRestore::MeshSelRestore(MeshSelMod *m, MeshSelData *data, int sLevel) {
	mod     = m;
	level   = sLevel;
	d       = data;
	d->held = TRUE;
	switch (level) {
	case SEL_OBJECT: MaxAssert(0); break;
	case SEL_VERTEX: usel = d->vertSel; break;
	case SEL_EDGE: usel = d->edgeSel; break;
	default: usel = d->faceSel; break;
	}
}

void MeshSelRestore::Restore(int isUndo) {
	if (isUndo) {
		switch (level) {			
		case SEL_VERTEX: rsel = d->vertSel; break;
		case SEL_FACE: 
		case SEL_POLY:
		case SEL_ELEMENT:
			rsel = d->faceSel; break;
		case SEL_EDGE:   rsel = d->edgeSel; break;
		}
	}
	switch (level) {		
	case SEL_VERTEX: d->vertSel = usel; break;
	case SEL_FACE:
	case SEL_POLY:
	case SEL_ELEMENT:
		d->faceSel = usel; break;
	case SEL_EDGE:   d->edgeSel = usel; break;
	}
	mod->InvalidateVDistances ();
	mod->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	mod->SetNumSelLabel();
	mod->UpdateNamedSelDropDown ();
}

void MeshSelRestore::Redo() {
	switch (level) {		
	case SEL_VERTEX:
		d->vertSel = rsel; break;
	case SEL_FACE:
	case SEL_POLY:
	case SEL_ELEMENT:
		d->faceSel = rsel; break;
	case SEL_EDGE:
		d->edgeSel = rsel; break;
	}
	mod->InvalidateVDistances ();
	mod->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	mod->SetNumSelLabel();
	mod->UpdateNamedSelDropDown ();
	}


//--- Named selection sets -----------------------------------------

int MeshSelMod::FindSet(TSTR &setName, int level) {
	for (int i=0; i<namedSel[level].Count(); i++) {
		if (setName == *namedSel[level][i]) return i;
	}
	return -1;
}

DWORD MeshSelMod::AddSet(TSTR &setName,int level) {
	DWORD id = 0;
	TSTR *name = new TSTR(setName);
	namedSel[level].Append(1,&name);
	BOOL found = FALSE;
	while (!found) {
		found = TRUE;
		for (int i=0; i<ids[level].Count(); i++) {
			if (ids[level][i]!=id) continue;
			id++;
			found = FALSE;
			break;
		}
	}
	ids[level].Append(1,&id);
	return id;
}

void MeshSelMod::RemoveSet(TSTR &setName,int level) {
	int i = FindSet(setName,level);
	if (i<0) return;
	delete namedSel[level][i];
	namedSel[level].Delete(i,1);
	ids[level].Delete(i,1);
}

void MeshSelMod::UpdateSetNames () {
	if (!ip) return;
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	for (int i=0; i<mcList.Count(); i++) {
		MeshSelData *meshData = (MeshSelData*)mcList[i]->localData;
		if ( !meshData ) continue;
		for (int nsl=0; nsl<3; nsl++) {
			// Make sure the namedSel array is in alpha order.
			// (Crude bubble sort since we expect that it will be.)
			int j, k, kmax = namedSel[nsl].Count();
			for (k=1; k<kmax; k++) {
				if (*(namedSel[nsl][k-1]) < *(namedSel[nsl][k])) continue;
				for (j=0; j<k-1; j++) {
					if (*(namedSel[nsl][j]) > *(namedSel[nsl][k])) break;
				}
				// j now represents the point at which k should be inserted.
				TSTR *hold = namedSel[nsl][k];
				DWORD dhold = ids[nsl][k];
				int j2;
				for (j2=k; j2>j; j2--) {
					namedSel[nsl][j2] = namedSel[nsl][j2-1];
					ids[nsl][j2] = ids[nsl][j2-1];
				}
				namedSel[nsl][j] = hold;
				ids[nsl][j] = dhold;
			}

			GenericNamedSelSetList & gnsl = meshData->GetNamedSel(nsl);
			// Check for old, unnamed sets with ids.
			for (k=0; k<gnsl.Count(); k++) {
				if (gnsl.names[k]) continue;
				for (j=0; j<ids[nsl].Count(); j++) if (ids[nsl][j] == gnsl.ids[k]) break;
				if (j == ids[nsl].Count()) continue;
				gnsl.names[j] = new TSTR(*(namedSel[nsl][j]));
			}
			gnsl.Alphabetize ();

			// Now check lists against each other, adding any missing elements.
			for (j=0; j<gnsl.Count(); j++) {
				if (*(gnsl.names[j]) == *(namedSel[nsl][j])) continue;
				if (j>= namedSel[nsl].Count()) {
					TSTR *nname = new TSTR(*gnsl.names[j]);
					DWORD nid = gnsl.ids[j];
					namedSel[nsl].Append (1, &nname);
					ids[nsl].Append (1, &nid);
					continue;
				}
				if (*(gnsl.names[j]) > *(namedSel[nsl][j])) {
					BitArray baTemp;
					gnsl.InsertSet (j, baTemp, ids[nsl][j], *(namedSel[nsl][j]));
					continue;
				}
				// Otherwise:
				TSTR *nname = new TSTR(*gnsl.names[j]);
				DWORD nid = gnsl.ids[j];
				namedSel[nsl].Insert (j, 1, &nname);
				ids[nsl].Insert (j, 1, &nid);
			}
			for (; j<namedSel[nsl].Count(); j++) {
				BitArray baTemp;
				gnsl.AppendSet (baTemp, ids[nsl][j], *(namedSel[nsl][j]));
			}
		}
	}

	nodes.DisposeTemporary();
}

void MeshSelMod::ClearSetNames() {
	for (int i=0; i<3; i++) {
		for (int j=0; j<namedSel[i].Count(); j++) {
			delete namedSel[i][j];
			namedSel[i][j] = NULL;
		}
	}
}

void MeshSelMod::ActivateSubSelSet(TSTR &setName) {
	ModContextList mcList;
	INodeTab nodes;
	int nsl = namedSetLevel[selLevel];
	int index = FindSet (setName, nsl);	
	if (index<0 || !ip) return;

	theHold.Begin ();
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		MeshSelData *meshData = (MeshSelData*)mcList[i]->localData;
		if (!meshData) continue;
		if (theHold.Holding() && !meshData->held) theHold.Put(new MeshSelRestore(this,meshData));

		BitArray *set = NULL;

		switch (nsl) {
		case NS_VERTEX:
			set = meshData->vselSet.GetSet(ids[nsl][index]);
			if (set) {
				if (set->GetSize()!=meshData->vertSel.GetSize()) {
					set->SetSize(meshData->vertSel.GetSize(),TRUE);
				}
				meshData->SetVertSel (*set, this, ip->GetTime());
			}
			break;

		case NS_FACE:
			set = meshData->fselSet.GetSet(ids[nsl][index]);
			if (set) {
				if (set->GetSize()!=meshData->faceSel.GetSize()) {
					set->SetSize(meshData->faceSel.GetSize(),TRUE);
				}
				meshData->SetFaceSel (*set, this, ip->GetTime());
			}
			break;

		case NS_EDGE:
			set = meshData->eselSet.GetSet(ids[nsl][index]);
			if (set) {
				if (set->GetSize()!=meshData->edgeSel.GetSize()) {
					set->SetSize(meshData->edgeSel.GetSize(),TRUE);
				}
				meshData->SetEdgeSel (*set, this, ip->GetTime());
			}
			break;
		}
	}
	
	nodes.DisposeTemporary();
	LocalDataChanged ();
	theHold.Accept (GetString (IDS_DS_SELECT));
	ip->RedrawViews(ip->GetTime());
}

void MeshSelMod::NewSetFromCurSel(TSTR &setName) {
	ModContextList mcList;
	INodeTab nodes;
	DWORD id = -1;
	int nsl = namedSetLevel[selLevel];
	int index = FindSet(setName, nsl);
	if (index<0) id = AddSet(setName, nsl);
	else id = ids[nsl][index];

	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		MeshSelData *meshData = (MeshSelData*)mcList[i]->localData;
		if (!meshData) continue;
		
		BitArray *set = NULL;

		switch (nsl) {
		case NS_VERTEX:	
			if (index>=0 && (set = meshData->vselSet.GetSet(id))) {
				*set = meshData->vertSel;
			} else meshData->vselSet.InsertSet(meshData->vertSel,id, setName);
			break;

		case NS_FACE:
			if (index>=0 && (set = meshData->fselSet.GetSet(id))) {
				*set = meshData->faceSel;
			} else meshData->fselSet.InsertSet(meshData->faceSel,id, setName);
			break;

		case NS_EDGE:
			if (index>=0 && (set = meshData->eselSet.GetSet(id))) {
				*set = meshData->edgeSel;
			} else meshData->eselSet.InsertSet(meshData->edgeSel,id, setName);
			break;
		}
	}	
	nodes.DisposeTemporary();
}

void MeshSelMod::RemoveSubSelSet(TSTR &setName) {
	int nsl = namedSetLevel[selLevel];
	int index = FindSet (setName, nsl);
	if (index<0 || !ip) return;		

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	DWORD id = ids[nsl][index];

	for (int i = 0; i < mcList.Count(); i++) {
		MeshSelData *meshData = (MeshSelData*)mcList[i]->localData;
		if (!meshData) continue;		

		switch (nsl) {
			case NS_VERTEX:	
				if (theHold.Holding()) theHold.Put(new DeleteSetRestore(&meshData->vselSet,id,setName));
				meshData->vselSet.RemoveSet(id);
				break;

			case NS_FACE:
				if (theHold.Holding()) theHold.Put(new DeleteSetRestore(&meshData->fselSet,id,setName));
				meshData->fselSet.RemoveSet(id);
				break;

			case NS_EDGE:
				if (theHold.Holding()) theHold.Put(new DeleteSetRestore(&meshData->eselSet,id,setName));
				meshData->eselSet.RemoveSet(id);
				break;
			}		
		}
	
	if (theHold.Holding()) theHold.Put(new DeleteSetNameRestore(&(namedSel[nsl]),this,&(ids[nsl]),id));
	RemoveSet (setName, nsl);
	ip->ClearCurNamedSelSet();
	nodes.DisposeTemporary();
}

void MeshSelMod::SetupNamedSelDropDown() {
	if (selLevel == SEL_OBJECT) return;
	ip->ClearSubObjectNamedSelSets();
	int nsl = namedSetLevel[selLevel];
	for (int i=0; i<namedSel[nsl].Count(); i++)
		ip->AppendSubObjectNamedSelSet(*namedSel[nsl][i]);
}

int MeshSelMod::NumNamedSelSets() {
	int nsl = namedSetLevel[selLevel];
	return namedSel[nsl].Count();
}

TSTR MeshSelMod::GetNamedSelSetName(int i) {
	int nsl = namedSetLevel[selLevel];
	return *namedSel[nsl][i];
}

void MeshSelMod::SetNamedSelSetName(int i,TSTR &newName) {
	int nsl = namedSetLevel[selLevel];
	if (theHold.Holding()) theHold.Put(new SetNameRestore(&namedSel[nsl],this,&ids[nsl],ids[nsl][i]));
	*namedSel[nsl][i] = newName;
}

void MeshSelMod::NewSetByOperator(TSTR &newName,Tab<int> &sets,int op) {
	ModContextList mcList;
	INodeTab nodes;
	
	int nsl = namedSetLevel[selLevel];
	DWORD id = AddSet(newName, nsl);
	if (theHold.Holding()) theHold.Put(new AppendSetNameRestore(this,&namedSel[nsl],&ids[nsl]));

	BOOL delSet = TRUE;
	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		MeshSelData *meshData = (MeshSelData*)mcList[i]->localData;
		if (!meshData) continue;
	
		BitArray bits;
		GenericNamedSelSetList *setList;

		switch (nsl) {
		case NS_VERTEX: setList = &meshData->vselSet; break;
		case NS_FACE: setList = &meshData->fselSet; break;			
		case NS_EDGE:   setList = &meshData->eselSet; break;			
		}		

		bits = (*setList)[sets[0]];

		for (int i=1; i<sets.Count(); i++) {
			switch (op) {
			case NEWSET_MERGE:
				bits |= (*setList)[sets[i]];
				break;

			case NEWSET_INTERSECTION:
				bits &= (*setList)[sets[i]];
				break;

			case NEWSET_SUBTRACT:
				bits &= ~((*setList)[sets[i]]);
				break;
			}
		}
		if (bits.NumberSet()) delSet = FALSE;

		if (!delSet) setList->InsertSet (bits, id, newName);
		if (theHold.Holding()) theHold.Put(new AppendSetRestore(setList, id, newName));
	}
	if (delSet) RemoveSubSelSet(newName);
}

void MeshSelMod::NSCopy() {
	int index = SelectNamedSet();
	if (index<0) return;
	if (!ip) return;

	int nsl = namedSetLevel[selLevel];
	MeshNamedSelClip *clip = new MeshNamedSelClip(*namedSel[nsl][index]);

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		MeshSelData *meshData = (MeshSelData*)mcList[i]->localData;
		if (!meshData) continue;

		GenericNamedSelSetList *setList;
		switch (nsl) {
		case NS_VERTEX: setList = &meshData->vselSet; break;				
		case NS_FACE: setList = &meshData->fselSet; break;			
		case NS_EDGE: setList = &meshData->eselSet; break;			
		}		

		BitArray *bits = new BitArray(*setList->sets[index]);
		clip->sets.Append(1,&bits);
	}
	SetMeshNamedSelClip(clip, namedClipLevel[selLevel]);
	
	// Enable the paste button
	ICustButton *but;
	but = GetICustButton(GetDlgItem(hParams,IDC_MS_PASTENS));
	but->Enable();
	ReleaseICustButton(but);
}

void MeshSelMod::NSPaste() {
	int nsl = namedSetLevel[selLevel];
	MeshNamedSelClip *clip = GetMeshNamedSelClip(namedClipLevel[selLevel]);
	if (!clip) return;	
	TSTR name = clip->name;
	if (!GetUniqueSetName(name)) return;

	ModContextList mcList;
	INodeTab nodes;
	theHold.Begin();

	DWORD id = AddSet (name, nsl);	
	if (theHold.Holding()) theHold.Put(new AppendSetNameRestore(this, &namedSel[nsl], &ids[nsl]));	

	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		MeshSelData *meshData = (MeshSelData*)mcList[i]->localData;
		if (!meshData) continue;

		GenericNamedSelSetList *setList;
		switch (nsl) {
		case NS_VERTEX: setList = &meshData->vselSet; break;
		case NS_EDGE: setList = &meshData->eselSet; break;
		case NS_FACE: setList = &meshData->fselSet; break;
		}
				
		if (i>=clip->sets.Count()) {
			BitArray bits;
			setList->InsertSet(bits,id,name);
		} else setList->InsertSet(*clip->sets[i],id,name);
		if (theHold.Holding()) theHold.Put (new AppendSetRestore (setList, id, name));		
	}	
	
	ActivateSubSelSet(name);
	ip->SetCurNamedSelSet(name);
	theHold.Accept(GetString (IDS_TH_PASTE_NAMED_SEL));
	SetupNamedSelDropDown();
}

int MeshSelMod::SelectNamedSet() {
	Tab<TSTR*> &setList = namedSel[namedSetLevel[selLevel]];
	if (!ip) return FALSE;
	return DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_SEL_NAMEDSET),
		ip->GetMAXHWnd(), PickSetDlgProc, (LPARAM)&setList);
}

void MeshSelMod::SetNumSelLabel() {	
	TSTR buf;
	int num = 0, which;

	if (!hParams) return;

	ModContextList mcList;
	INodeTab nodes;

	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		MeshSelData *meshData = (MeshSelData*)mcList[i]->localData;
		if (!meshData) continue;

		switch (selLevel) {
		case SEL_VERTEX:
			num += meshData->vertSel.NumberSet();
			if (meshData->vertSel.NumberSet() == 1) {
				for (which=0; which<meshData->vertSel.GetSize(); which++) if (meshData->vertSel[which]) break;
			}
			break;
		case SEL_FACE:
		case SEL_POLY:
		case SEL_ELEMENT:
			num += meshData->faceSel.NumberSet();
			if (meshData->faceSel.NumberSet() == 1) {
				for (which=0; which<meshData->faceSel.GetSize(); which++) if (meshData->faceSel[which]) break;
			}
			break;
		case SEL_EDGE:
			num += meshData->edgeSel.NumberSet();
			if (meshData->edgeSel.NumberSet() == 1) {
				for (which=0; which<meshData->edgeSel.GetSize(); which++) if (meshData->edgeSel[which]) break;
			}
			break;
		}
	}

	switch (selLevel) {
	case SEL_VERTEX:			
		if (num==1) buf.printf (GetString(IDS_EM_WHICHVERTSEL), which+1);
		else buf.printf(GetString(IDS_RB_NUMVERTSELP),num);
		break;

	case SEL_FACE:
	case SEL_POLY:
	case SEL_ELEMENT:
		if (num==1) buf.printf (GetString(IDS_EM_WHICHFACESEL), which+1);
		else buf.printf(GetString(IDS_RB_NUMFACESELP),num);
		break;

	case SEL_EDGE:
		if (num==1) buf.printf (GetString(IDS_EM_WHICHEDGESEL), which+1);
		else buf.printf(GetString(IDS_RB_NUMEDGESELP),num);
		break;

	case SEL_OBJECT:
		buf = GetString (IDS_EM_OBJECT_SEL);
		break;
	}

	SetDlgItemText(hParams,IDC_MS_NUMBER_SEL,buf);
}

RefResult MeshSelMod::NotifyRefChanged (Interval changeInt, RefTargetHandle hTarget, 
   		PartID& partID, RefMessage message) {
	GetParamDim *gpd;
	GetParamName *gpn;

	switch (message) {
	case REFMSG_CHANGE:
		if ((editMod==this) && pmapParam) pmapParam->Invalidate();
		break;

	case REFMSG_GET_PARAM_DIM:
		gpd = (GetParamDim*)partID;
		gpd->dim = GetParameterDim(gpd->index);
		return REF_STOP;

	case REFMSG_GET_PARAM_NAME:
		gpn = (GetParamName*)partID;
		gpn->name = GetParameterName(gpn->index);
		return REF_STOP;
	}
	return(REF_SUCCEED);
}

ParamDimension *MeshSelMod::GetParameterDim(int pbIndex) {
	switch (pbIndex) {
		case PB_USE_AR: 	return defaultDim;
		default: return stdWorldDim;
	}
}

TSTR MeshSelMod::GetParameterName(int pbIndex)
{
	switch (pbIndex) {
		case PB_USE_AR: return TSTR(GetString(IDS_MS_USE_AR));
		case PB_FALLOFF: return TSTR(GetString(IDS_AFR_FALLOFF));
		case PB_PINCH: return TSTR(GetString(IDS_AFR_PINCH));
		case PB_BUBBLE: return TSTR(GetString(IDS_AFR_BUBBLE));
		default:			return TSTR(_T(""));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\mirror.cpp ===
/**********************************************************************
 *<
	FILE: mirror.cpp

	DESCRIPTION: Mirror modifier

	CREATED BY: Rolf Berteig

	HISTORY: 12/06/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm.h"
#include "splshape.h"

#define TM_REF		0
#define PBLOCK_REF	1

#define MIRRORMOD_CLASS_ID Class_ID(0xef92aa7c,0x511bbe75);

class MirrorMod : public Modifier {	
	public:		
		IParamBlock *pblock;
		Control *tmControl;
		Control *p1, *p2;
		BYTE sel[2];
		BOOL splineMethod;	// TRUE if using old spline mirroring method (which was wrong)

		static IObjParam *ip;
		static IParamMap *pmapParam;
		static MirrorMod *editMod;
		static MoveModBoxCMode *moveMode;
		static RotateModBoxCMode *rotMode;
		static UScaleModBoxCMode *uscaleMode;
		static NUScaleModBoxCMode *nuscaleMode;
		static SquashModBoxCMode *squashMode;				
		
		MirrorMod();
						
		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_MIRRORMOD);}  
		virtual Class_ID ClassID() {return MIRRORMOD_CLASS_ID;}
		void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_MIRRORMOD);}
		BOOL AssignController(Animatable *control,int subAnim);
		int SubNumToRefNum(int subNum);
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);

		// From modifier
		ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO|PART_SELECT|PART_SUBSEL_TYPE;}
		ChannelMask ChannelsChanged() {return PART_GEOM|PART_TOPO|PART_SELECT|PART_TEXMAP;}
		Class_ID InputType() {return defObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);

		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flagst, ModContext *mc);
		void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);		
		void Move(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin);
		void Rotate(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin);
		void Scale(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin);		
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void ActivateSubobjSel(int level, XFormModes& modes);
				
		int NumRefs() {return 2;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		int NumSubs() {return 2;}
		Animatable* SubAnim(int i) {return GetReference(i);}
		TSTR SubAnimName(int i);

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		Matrix3 CompMatrix(TimeValue t,INode *inode,ModContext *mc);
		void DrawGizmo(float size,PolyLineProc& lp);
	};


class MirrorDeformer : public Deformer {
	public:		
		Matrix3 tm, itm;
		MirrorDeformer(int axis, float offset, Matrix3 &tm, Matrix3 &itm);			
		Point3 Map(int i, Point3 p) {return (tm*p)*itm;}
	};


//--- ClassDescriptor and class vars ---------------------------------

IParamMap          *MirrorMod::pmapParam   = NULL;
IObjParam          *MirrorMod::ip          = NULL;
MirrorMod          *MirrorMod::editMod     = NULL;
MoveModBoxCMode    *MirrorMod::moveMode    = NULL;
RotateModBoxCMode  *MirrorMod::rotMode 	   = NULL;
UScaleModBoxCMode  *MirrorMod::uscaleMode  = NULL;
NUScaleModBoxCMode *MirrorMod::nuscaleMode = NULL;
SquashModBoxCMode  *MirrorMod::squashMode  = NULL;
		

class MirrorModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new MirrorMod;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_MIRRORMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return MIRRORMOD_CLASS_ID;}
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static MirrorModClassDesc mirrorDesc;
extern ClassDesc* GetMirrorModDesc() {return &mirrorDesc;}


//--- Parameter map/block descriptors -------------------------------

#define PB_AXIS				0
#define PB_COPY				1
#define PB_OFFSET			2

// Spline methods
#define SPLINE_REVERSE 0	// Pre-r3 method
#define SPLINE_NOREVERSE 1	// r3 method

//
//
// Parameters

static int axisIDs[] = {IDS_MIRROR_X,IDS_MIRROR_Y,IDS_MIRROR_Z,IDS_MIRROR_XY,IDS_MIRROR_YZ,IDS_MIRROR_ZX};

static ParamUIDesc descParam[] = {	
	// Axis
	ParamUIDesc(PB_AXIS,TYPE_RADIO,axisIDs,6),

	// Copy
	ParamUIDesc(PB_COPY,TYPE_SINGLECHEKBOX,IDC_MIRROR_COPY),	

	// Offset
	ParamUIDesc(
		PB_OFFSET,
		EDITTYPE_UNIVERSE,
		IDC_MIRROR_OFFSET,IDC_MIRROR_OFFSETSPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),
	};
#define PARAMDESC_LENGTH	3

// TH 5/14/99 -- We're faking a different parameter block version to fix a problem in
// previously-saved files (<r3).  We key off the version to set the 'splineMethod' variable.

static ParamBlockDescID descVer0[] = {
	{ TYPE_INT,   NULL, FALSE, 0 },		// Axis
	{ TYPE_INT,   NULL, FALSE, 1 },		// Copy
	{ TYPE_FLOAT, NULL, TRUE, 2 },		// Offset
	};

static ParamBlockDescID descVer1[] = {
	{ TYPE_INT,   NULL, FALSE, 0 },		// Axis
	{ TYPE_INT,   NULL, FALSE, 1 },		// Copy
	{ TYPE_FLOAT, NULL, TRUE, 2 },		// Offset
	};
#define PBLOCK_LENGTH	3

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,0),
	};
#define NUM_OLDVERSIONS	1

#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);

//--- Affect region mod methods -------------------------------

MirrorMod::MirrorMod() 
	{
	tmControl  = NULL; 	
	pblock     = NULL;
	MakeRefByID(
		FOREVER, PBLOCK_REF, 
		CreateParameterBlock(
			descVer1, PBLOCK_LENGTH, CURRENT_VERSION));	
	MakeRefByID(FOREVER,TM_REF,NewDefaultMatrix3Controller()); 
	splineMethod = SPLINE_NOREVERSE;
	}

void MirrorMod::BeginEditParams(
		IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	this->ip = ip;
	editMod  = this;

	// Add our sub object type
	TSTR type1(GetString(IDS_RB_MIRRORCENTER));
	const TCHAR *ptype[] = {type1};
	ip->RegisterSubObjectTypes(ptype, 1);

	// Create sub object editing modes.
	moveMode    = new MoveModBoxCMode(this,ip);
	rotMode     = new RotateModBoxCMode(this,ip);
	uscaleMode  = new UScaleModBoxCMode(this,ip);
	nuscaleMode = new NUScaleModBoxCMode(this,ip);
	squashMode  = new SquashModBoxCMode(this,ip);	

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);

	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGTH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_MIRRORPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);	
	}

void MirrorMod::EndEditParams(
		IObjParam *ip,ULONG flags,Animatable *next)
	{
	this->ip = NULL;
	editMod  = NULL;

	TimeValue t = ip->GetTime();

	// NOTE: This flag must be cleared before sending the REFMSG_END_EDIT
	ClearAFlag(A_MOD_BEING_EDITED);

	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);

	ip->DeleteMode(moveMode);
	ip->DeleteMode(rotMode);
	ip->DeleteMode(uscaleMode);
	ip->DeleteMode(nuscaleMode);
	ip->DeleteMode(squashMode);	
	if ( moveMode ) delete moveMode;
	moveMode = NULL;
	if ( rotMode ) delete rotMode;
	rotMode = NULL;
	if ( uscaleMode ) delete uscaleMode;
	uscaleMode = NULL;
	if ( nuscaleMode ) delete nuscaleMode;
	nuscaleMode = NULL;
	if ( squashMode ) delete squashMode;
	squashMode = NULL;

	DestroyCPParamMap(pmapParam);
	}

RefTargetHandle MirrorMod::Clone(RemapDir& remap)
	{
	MirrorMod *mod = new MirrorMod();
	mod->ReplaceReference(PBLOCK_REF,pblock->Clone(remap));	
	mod->ReplaceReference(TM_REF,remap.CloneRef(tmControl));
	mod->splineMethod = splineMethod;
	return mod;
	}

MirrorDeformer::MirrorDeformer(
		int axis, float offset, Matrix3 &tm, Matrix3 &itm) 
	{	
	this->tm   = tm;
	this->itm  = itm;
	Point3 scale(1,1,1), off(0,0,0);
	switch (axis) {
		case 0:
		case 1:
		case 2:
			scale[axis] = -1.0f;
			off[axis]   = offset;
			break;
		case 3:
		case 4:
		case 5:
			scale[(axis)%3]   = -1.0f;
			scale[(axis+1)%3] = -1.0f;
			off[(axis)%3]     = offset;
			off[(axis+1)%3]   = offset;
			break;
		}
	this->tm.Scale(scale,TRUE);
	this->tm.Translate(off);
	}

void MirrorMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{	
	Matrix3 itm = CompMatrix(t,NULL,&mc);
	Matrix3 tm  = Inverse(itm);
	Interval iv = FOREVER;
	int axis, copy;
	float offset;
	pblock->GetValue(PB_AXIS,t,axis,iv);
	pblock->GetValue(PB_COPY,t,copy,iv);
	pblock->GetValue(PB_OFFSET,t,offset,iv);
	DWORD oldLevel;
	BOOL convertedShape = FALSE;

	if (os->obj->IsSubClassOf(triObjectClassID)) {
		TriObject *tobj = (TriObject*)os->obj;
		Mesh &mesh = tobj->GetMesh();		
		switch (mesh.selLevel) {
			case MESH_OBJECT: mesh.faceSel.SetAll(); break;			
			case MESH_VERTEX: {
				for (int i=0; i<mesh.getNumFaces(); i++) {
					for (int j=0; j<3; j++) {
						if (mesh.vertSel[mesh.faces[i].v[j]]) {
							mesh.faceSel.Set(i);
							}
						}
					}
				break;
				}
			
			case MESH_EDGE:	{
				for (int i=0; i<mesh.getNumFaces(); i++) {
					for (int j=0; j<3; j++) {
						if (mesh.edgeSel[i*3+j]) {
							mesh.faceSel.Set(i);
							}
						}
					}
				break;
				}		
			}		
		oldLevel = mesh.selLevel;
		mesh.selLevel = MESH_FACE;
		if (copy) mesh.CloneFaces(mesh.faceSel);
		if (axis<3) {
			for (int i=0; i<mesh.getNumFaces(); i++) {
				if (mesh.faceSel[i]) mesh.FlipNormal(i);
				}
			}
		}
	else
	if (os->obj->IsSubClassOf(splineShapeClassID)) {
		SplineShape *ss = (SplineShape*)os->obj;
		BezierShape &shape = ss->shape;		
		oldLevel = shape.selLevel;
		switch (shape.selLevel) {
			case SHAPE_OBJECT:			
			case SHAPE_VERTEX:
				shape.selLevel = SHAPE_SPLINE;
				shape.polySel.SetAll();
				break;
				 
			case SHAPE_SPLINE:
			case SHAPE_SEGMENT:
				break;
			}		
		if (copy)
			shape.CloneSelectedParts((axis < 3 && splineMethod == SPLINE_REVERSE) ? TRUE : FALSE);
		}
	else
	if(os->obj->SuperClassID() == SHAPE_CLASS_ID) {
		ShapeObject *so = (ShapeObject *)os->obj;
		if(so->CanMakeBezier()) {
			SplineShape *ss = new SplineShape();
			so->MakeBezier(t, ss->shape);
			ss->SetChannelValidity(GEOM_CHAN_NUM, LocalValidity(t) & so->ObjectValidity(t));
			os->obj = ss;
			os->obj->UnlockObject();
			convertedShape = TRUE;
			BezierShape &shape = ss->shape;		
			oldLevel = shape.selLevel;
			switch (shape.selLevel) {
				case SHAPE_OBJECT:			
				case SHAPE_VERTEX:
					shape.selLevel = SHAPE_SPLINE;
					shape.polySel.SetAll();
					break;
					 
				case SHAPE_SPLINE:
				case SHAPE_SEGMENT:
					break;
				}		
			if (copy)
				shape.CloneSelectedParts((axis < 3 && splineMethod == SPLINE_REVERSE) ? TRUE : FALSE);
			}
		}

	MirrorDeformer deformer(axis,offset,tm,itm);


	os->obj->Deform(&deformer, TRUE);	

//	if (axis < 3 && splineMethod == SPLINE_REVERSE)
		{
		if (os->obj->IsSubClassOf(splineShapeClassID)) {
			SplineShape *ss = (SplineShape*)os->obj;
			BezierShape &shape = ss->shape;		
			for (int i = 0; i < shape.bindList.Count(); i++)
				{
				int index = 0;
				int spindex = shape.bindList[i].pointSplineIndex;
//			Point3 p=shape.splines[spindex]->GetKnot(index).Knot();
				if (shape.bindList[i].isEnd)
					index = shape.splines[spindex]->KnotCount()-1;
				shape.bindList[i].bindPoint = shape.splines[spindex]->GetKnotPoint(index);
				shape.bindList[i].segPoint = shape.splines[spindex]->GetKnotPoint(index);
				}
			shape.UpdateBindList();
	
			}
		else
		if(os->obj->SuperClassID() == SHAPE_CLASS_ID) {
			ShapeObject *so = (ShapeObject *)os->obj;
			if(so->CanMakeBezier()) {
				SplineShape *ss = new SplineShape();
				so->MakeBezier(t, ss->shape);
				ss->SetChannelValidity(GEOM_CHAN_NUM, LocalValidity(t) & so->ObjectValidity(t));
				os->obj = ss;
				os->obj->UnlockObject();
				convertedShape = TRUE;
				BezierShape &shape = ss->shape;		
				for (int i = 0; i < shape.bindList.Count(); i++)
					{
					int index = 0;
					int spindex = shape.bindList[i].pointSplineIndex;
//				Point3 p;
					if (shape.bindList[i].isEnd)
						index = shape.splines[spindex]->KnotCount()-1;
					shape.bindList[i].bindPoint = shape.splines[spindex]->GetKnotPoint(index);
					shape.bindList[i].segPoint = shape.splines[spindex]->GetKnotPoint(index);
					}
				shape.UpdateBindList();

				}

			}
		}

	os->obj->UpdateValidity(GEOM_CHAN_NUM,LocalValidity(t));	
	
	if (os->obj->IsSubClassOf(triObjectClassID)) {
		TriObject *tobj = (TriObject*)os->obj;
		tobj->GetMesh().selLevel = oldLevel;
		}
	else
	if(os->obj->IsSubClassOf(splineShapeClassID) || convertedShape) {
		SplineShape *ss = (SplineShape*)os->obj;
		ss->shape.selLevel = oldLevel;
		}
	}

Interval MirrorMod::LocalValidity(TimeValue t)
	{
	Interval iv = FOREVER;
	Matrix3 mat(1);		
	tmControl->GetValue(t,&mat,iv,CTRL_RELATIVE);
	float o;
	pblock->GetValue(PB_OFFSET,t,o,iv);
	return iv;
	}


Matrix3 MirrorMod::CompMatrix(
		TimeValue t,INode *inode,ModContext *mc)
	{
	Interval iv;
	Matrix3 tm(1);		
	tmControl->GetValue(t,&tm,iv,CTRL_RELATIVE);
	if (mc && mc->tm) tm = tm * Inverse(*(mc->tm));
	if (inode) tm = tm * inode->GetObjTMBeforeWSM(t,&iv);
	return tm;
	}


#define AXIS_SIZE		2.0f
#define SCREEN_SCALE	0.1f

static void SetupAxisPoints(
		Point3 &v, Point3 &vp, float size,Point3 *pts) 
	{
	pts[0] = (vp)*size;
	pts[2] = (-vp)*size;
	pts[1] = (v^vp)*size;
	pts[3] = (v^(-vp))*size;
	pts[4] = pts[0];

	pts[5] = -v*size*AXIS_SIZE;
	pts[6] = v*size*AXIS_SIZE;
	
	Point3 v2 = v*0.9f*size*AXIS_SIZE;

	pts[7] = v2+pts[0]*0.1f;
	pts[8] = pts[6];
	pts[9] = v2+pts[2]*0.1f;

	pts[10] = v2+pts[1]*0.1f;
	pts[11] = pts[6];
	pts[12] = v2+pts[3]*0.1f;
	
	pts[13] = -v2+pts[0]*0.1f;
	pts[14] = -pts[6];
	pts[15] = -v2+pts[2]*0.1f;

	pts[16] = -v2+pts[1]*0.1f;
	pts[17] = -pts[6];
	pts[18] = -v2+pts[3]*0.1f;
	}

void MirrorMod::DrawGizmo(float size,PolyLineProc& lp)
	{
	Point3 v0(0,0,0), pv0(0,0,0), v1(0,0,0), pv1(0,0,0);
	int ct=0;
	int axis;
	pblock->GetValue(PB_AXIS,0,axis,FOREVER);

	switch (axis) {
		case 0:
		case 1:
		case 2:
			v0[axis]        = -1.0f;
			pv0[(axis+1)%3]	= 1.0f;
			pv0[(axis+2)%3]	= 1.0f;
			ct=1;
			break;
		
		case 3:
		case 4:
		case 5:
			v0[(axis)%3]    = -1.0f;
			pv0[(axis+1)%3]	= 1.0f;
			pv0[(axis+2)%3]	= 1.0f;
			v1[(axis+1)%3]  = -1.0f;
			pv1[(axis+2)%3]	= 1.0f;
			pv1[(axis+3)%3]	= 1.0f;
			ct=2;
			break;
		}
	
	Point3 pts[20];
	SetupAxisPoints(v0, pv0, size, pts);
	lp.proc(pts,5);
	lp.proc(pts+5,2);
	lp.proc(pts+7,3);
	lp.proc(pts+10,3);
	lp.proc(pts+13,3);
	lp.proc(pts+16,3);

	if (ct==2) {
		SetupAxisPoints(v1, pv1, size, pts);
		lp.proc(pts,5);
		lp.proc(pts+5,2);
		lp.proc(pts+7,3);
		lp.proc(pts+10,3);
		lp.proc(pts+13,3);
		lp.proc(pts+16,3);
		}
	}

int MirrorMod::HitTest(
		TimeValue t, INode* inode, 
		int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt, ModContext* mc)
	{
	GraphicsWindow *gw = vpt->getGW();
	Point3 pt;
	HitRegion hr;
	int savedLimits, res = 0;
	Matrix3 tm = CompMatrix(t,inode,mc);

	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);	
	gw->setTransform(tm);
	gw->clearHitCode();
	DrawLineProc lp(gw);
	DrawGizmo(
		vpt->GetScreenScaleFactor(tm.GetTrans())*SCREEN_SCALE,lp);
	gw->setRndLimits(savedLimits);
	if (gw->checkHitCode()) {
		vpt->LogHit(inode, mc, gw->getHitDistance(), 0, NULL); 
		return 1;
		}
	return 0;
	}

int MirrorMod::Display(
		TimeValue t, INode* inode, ViewExp *vpt, 
		int flagst, ModContext *mc)
	{
	GraphicsWindow *gw = vpt->getGW();
	Point3 pt[4];
	Matrix3 tm = CompMatrix(t,inode,mc);
	int savedLimits;

	gw->setRndLimits((savedLimits = gw->getRndLimits()) & ~GW_ILLUM);
	gw->setTransform(tm);
	if (ip && ip->GetSubObjectLevel() == 1) {
		//gw->setColor(LINE_COLOR, (float)1.0, (float)1.0, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
	} else {
		//gw->setColor(LINE_COLOR, (float).85, (float).5, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
		}
	
	DrawLineProc lp(gw);
	DrawGizmo(
		vpt->GetScreenScaleFactor(tm.GetTrans())*SCREEN_SCALE,lp);
	
	gw->setRndLimits(savedLimits);
	return 0;
	}

void MirrorMod::GetWorldBoundBox(
		TimeValue t,INode* inode, ViewExp *vpt, 
		Box3& box, ModContext *mc)
	{	
	GraphicsWindow *gw = vpt->getGW();
	Matrix3 tm = CompMatrix(t,inode,mc);
	BoxLineProc bproc(&tm);
	DrawGizmo(
		vpt->GetScreenScaleFactor(tm.GetTrans())*SCREEN_SCALE,bproc);
	box = bproc.Box();	
	}

void MirrorMod::Move(TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin)
	{
	SetXFormPacket pckt(val,partm,tmAxis);
	tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
	}

void MirrorMod::Rotate(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin)
	{
	SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
	tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
	}

void MirrorMod::Scale(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin)
	{
	SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
	tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
	}

void MirrorMod::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,
		INode *node,ModContext *mc)
	{
	Matrix3 tm = CompMatrix(t,node,mc);	
	cb->Center(tm.GetTrans(),0);
	}

void MirrorMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,
		INode *node,ModContext *mc)
	{
	Matrix3 tm = CompMatrix(t,node,mc);
	cb->TM(tm,0);
	}

void MirrorMod::ActivateSubobjSel(int level, XFormModes& modes)
	{
	switch (level) {
		case 1: // Mirror center
			modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,NULL);
			break;		
		}
	NotifyDependents(FOREVER,PART_DISPLAY,REFMSG_CHANGE);
	}


BOOL MirrorMod::AssignController(Animatable *control,int subAnim)
	{
	if (subAnim==TM_REF) {
		ReplaceReference(TM_REF,(ReferenceTarget*)control);
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);		
		return TRUE;
	} else {
		return FALSE;
		}
	}

int MirrorMod::SubNumToRefNum(int subNum)
	{
	if (subNum==TM_REF) return subNum;
	else return -1;
	}

RefTargetHandle MirrorMod::GetReference(int i)
	{
	switch (i) {
		case PBLOCK_REF: return pblock;
		case TM_REF:     return tmControl;		
		default: return NULL;
		}
	}

void MirrorMod::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case PBLOCK_REF: pblock    = (IParamBlock*)rtarg; break;
		case TM_REF:     tmControl = (Control*)rtarg; break;		
		}
	}

TSTR MirrorMod::SubAnimName(int i)
	{
	switch (i) {
		case TM_REF: return GetString(IDS_RB_MIRRORCENTER); break;		
		default: return _T(""); break;
		}
	}

RefResult MirrorMod::NotifyRefChanged(
		Interval changeInt,RefTargetHandle hTarget, 
		PartID& partID, RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			if (editMod==this && pmapParam) pmapParam->Invalidate();
			break;		

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_OFFSET: gpd->dim = stdWorldDim; break;				
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;			
			switch (gpn->index) {
				case PB_OFFSET: gpn->name = GetString(IDS_RB_OFFSET); break;				
				}
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}

class MirrorPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		MirrorPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload);
	};

void MirrorPostLoadCallback::proc(ILoad *iload) {
	DWORD oldVer = ((MirrorMod*)(cb->targ))->pblock->GetVersion();
	ReferenceTarget *targ = cb->targ;
	cb->proc(iload);
	if (oldVer<1)
		((MirrorMod*)targ)->splineMethod = SPLINE_REVERSE;
	delete this;
	}

#define SPLINE_METHOD_CHUNK 0x1000

IOResult MirrorMod::Save(ISave *isave) {	
	ULONG nb;
	Modifier::Save(isave);
	isave->BeginChunk(SPLINE_METHOD_CHUNK);
	isave->Write(&splineMethod,sizeof(int),&nb);
	isave->EndChunk();
	return IO_OK;
	}

IOResult MirrorMod::Load(ILoad *iload)
	{
	IOResult res;
	ULONG nb;
	Modifier::Load(iload);
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SPLINE_METHOD_CHUNK:
				iload->Read(&splineMethod,sizeof(int),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	iload->RegisterPostLoadCallback(
		new MirrorPostLoadCallback(
			new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,PBLOCK_REF)));
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\mods.cpp ===
/**********************************************************************
 *<
	FILE: mods.cpp

	DESCRIPTION:   DLL implementation of modifiers

	CREATED BY: Rolf Berteig (based on prim.cpp)

	HISTORY: created 30 January 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "buildver.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

#ifdef OLD3DCONTROLS
		// initialize 3D controls
		Ctl3dRegister(hinstDLL);
		Ctl3dAutoSubclass(hinstDLL);
#endif
		
		// initialize Chicago controls
		InitCommonControls();
		}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return
 GetString(IDS_RB_DEFMODS); }


#ifndef DESIGN_VER

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 53;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetBendModDesc();
		case 1: return GetTaperModDesc();
		case 2: return GetSinWaveObjDesc();
		case 3: return GetSinWaveModDesc();
		case 4: return GetEditMeshModDesc();
		case 5: return GetEditSplineModDesc();
		case 6: return GetEditPatchModDesc();
		case 7: return GetTwistModDesc();
		case 8: return GetExtrudeModDesc();
		case 9: return GetBombObjDesc();
		case 10: return GetBombModDesc();		
		case 11: return GetClustModDesc();
		case 12: return GetSkewModDesc();
		case 13: return GetNoiseModDesc();
		case 14: return GetSinWaveOModDesc();
		case 15: return GetLinWaveObjDesc();
		case 16: return GetLinWaveModDesc();
		case 17: return GetLinWaveOModDesc();
		case 18: return GetOptModDesc();
		case 19: return GetDispModDesc();
		case 20: return GetClustNodeModDesc();
		case 21: return GetGravityObjDesc();
		case 22: return GetGravityModDesc();
		case 23: return GetWindObjDesc();
		case 24: return GetWindModDesc();
		case 25: return GetDispObjDesc();
		case 26: return GetDispWSModDesc();
		case 27: return GetDeflectObjDesc();
		case 28: return GetDeflectModDesc();
		case 29: return GetUVWMapModDesc();
		case 30: return GetSelModDesc();
		case 31: return GetSmoothModDesc();
		case 32: return GetMatModDesc();
		case 33: return GetNormalModDesc();
		case 34: return GetSurfrevModDesc();
		case 35: return GetResetXFormDesc();
		case 36: return GetAFRModDesc();
		case 37: return GetTessModDesc();
		case 38: return GetDeleteModDesc();
		case 39: return GetMeshSelModDesc();
		case 40: return GetFaceExtrudeModDesc();
		case 41: return GetUVWXFormModDesc();
		case 42: return GetMirrorModDesc();
		case 43: return GetUnwrapModDesc();
		case 44: return GetBendWSMDesc();
		case 45: return GetTwistWSMDesc();
		case 46: return GetTaperWSMDesc();
		case 47: return GetSkewWSMDesc();
		case 48: return GetNoiseWSMDesc();
		case 49: return GetSDeleteModDesc();
		case 50: return GetDispApproxModDesc();
		case 51: return GetMeshMesherWSMDesc();
		case 52: return GetNormalizeSplineDesc();
		default: return 0;
		}

	}

#else

//
// DESIGN VERSION EXCLUDES SOME PLUG_INS
//

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 38;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetBendModDesc();
		case 1: return GetTaperModDesc();
		//case 2: return GetSinWaveObjDesc();
		//case 3: return GetSinWaveModDesc();
		case 2: return GetEditMeshModDesc();
		case 3: return GetEditSplineModDesc();
		case 4: return GetEditPatchModDesc();
		case 5: return GetTwistModDesc();
		case 6: return GetExtrudeModDesc();
		//case 9: return GetBombObjDesc();
		//case 10: return GetBombModDesc();		
		case 7: return GetClustModDesc();
		case 8: return GetSkewModDesc();
		case 9: return GetNoiseModDesc();
		case 10: return GetSinWaveOModDesc();
		//case 15: return GetLinWaveObjDesc();
		//case 16: return GetLinWaveModDesc();
		case 11: return GetLinWaveOModDesc();
		case 12: return GetOptModDesc();
		case 13: return GetDispModDesc();
		case 14: return GetClustNodeModDesc();
		//case 21: return GetGravityObjDesc();
		//case 22: return GetGravityModDesc();
		//case 23: return GetWindObjDesc();
		//case 24: return GetWindModDesc();
		//case 25: return GetDispObjDesc();
		//case 26: return GetDispWSModDesc();
		//case 27: return GetDeflectObjDesc();
		//case 28: return GetDeflectModDesc();
		case 15: return GetUVWMapModDesc();
		case 16: return GetSelModDesc();
		case 17: return GetSmoothModDesc();
		case 18: return GetMatModDesc();
		case 19: return GetNormalModDesc();
		case 20: return GetSurfrevModDesc();
		case 21: return GetResetXFormDesc();
		case 22: return GetAFRModDesc();
		case 23: return GetTessModDesc();
		case 24: return GetDeleteModDesc();
		case 25: return GetMeshSelModDesc();
		case 26: return GetFaceExtrudeModDesc();
		case 27: return GetUVWXFormModDesc();
		case 28: return GetMirrorModDesc();
//		case 29: return GetUnwrapModDesc();
		case 29: return GetBendWSMDesc();
		case 30: return GetTwistWSMDesc();
		case 31: return GetTaperWSMDesc();
		case 32: return GetSkewWSMDesc();
		case 33: return GetNoiseWSMDesc();
		case 34: return GetSDeleteModDesc();
		case 35: return GetDispApproxModDesc();
		case 36: return GetMeshMesherWSMDesc();
		case 37: return GetNormalizeSplineDesc();

		default: return 0;
		}

	}

#endif



// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

BOOL CALLBACK DefaultSOTProc(
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	IObjParam *ip = (IObjParam*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			if (ip) ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			return FALSE;

		default:
			return FALSE;
		}
	return TRUE;
	}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\mods.h ===
/**********************************************************************
 *<
	FILE: mods.h

	DESCRIPTION:

	CREATED BY: Rolf Berteig (based on prim.h)

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __MODS__H
#define __MODS__H

#include "Max.h"
//#include "reslib.h"
#include "modsres.h"


TCHAR *GetString(int id);

#define EDITMESH_CLASS_ID			0x00050
#define EDITSPLINE_CLASS_ID			0x00060
#define EDITPATCH_CLASS_ID			0x00070
#define EDITLOFT_CLASS_ID			0x00080

#define CLUSTOSM_CLASS_ID			0x25215824

#define RESET_XFORM_CLASS_ID		0x8d562b81
#define CLUSTNODEOSM_CLASS_ID		0xc4d33


extern ClassDesc* GetBombObjDesc();
extern ClassDesc* GetBombModDesc();

extern ClassDesc* GetBendModDesc();
extern ClassDesc* GetTaperModDesc();
extern ClassDesc* GetSinWaveObjDesc();
extern ClassDesc* GetSinWaveModDesc();
extern ClassDesc* GetLinWaveObjDesc();
extern ClassDesc* GetLinWaveModDesc();
extern ClassDesc* GetEditMeshModDesc();
extern ClassDesc* GetEditSplineModDesc();
extern ClassDesc* GetEditPatchModDesc();
extern ClassDesc* GetTwistModDesc();
extern ClassDesc* GetTwistModDesc2();
extern ClassDesc* GetExtrudeModDesc();
extern ClassDesc* GetClustModDesc();
extern ClassDesc* GetSkewModDesc();
extern ClassDesc* GetNoiseModDesc();
extern ClassDesc* GetSinWaveOModDesc();
extern ClassDesc* GetLinWaveOModDesc();
extern ClassDesc* GetOptModDesc();
extern ClassDesc* GetDispModDesc();
extern ClassDesc* GetClustNodeModDesc();
extern ClassDesc* GetGravityObjDesc();
extern ClassDesc* GetGravityModDesc();
extern ClassDesc* GetWindObjDesc();
extern ClassDesc* GetWindModDesc();
extern ClassDesc* GetDispObjDesc();
extern ClassDesc* GetDispWSModDesc();
extern ClassDesc* GetDeflectObjDesc();
extern ClassDesc* GetDeflectModDesc();
extern ClassDesc* GetUVWMapModDesc();
extern ClassDesc* GetSelModDesc();
extern ClassDesc* GetSmoothModDesc();
extern ClassDesc* GetMatModDesc();
extern ClassDesc* GetNormalModDesc();
extern ClassDesc* GetSurfrevModDesc();
extern ClassDesc* GetResetXFormDesc();
extern ClassDesc* GetAFRModDesc();
extern ClassDesc* GetTessModDesc();
extern ClassDesc* GetDeleteModDesc();
extern ClassDesc* GetMeshSelModDesc();
extern ClassDesc* GetFaceExtrudeModDesc();
extern ClassDesc* GetUVWXFormModDesc();
extern ClassDesc* GetMirrorModDesc();
extern ClassDesc* GetUnwrapModDesc();
extern ClassDesc* GetBendWSMDesc();
extern ClassDesc* GetTwistWSMDesc();
extern ClassDesc* GetTaperWSMDesc();
extern ClassDesc* GetSkewWSMDesc();
extern ClassDesc* GetNoiseWSMDesc();
extern ClassDesc* GetDispApproxModDesc();
extern ClassDesc* GetMeshMesherWSMDesc();
extern ClassDesc* GetNormalizeSplineDesc();


// This is just temporary to make some extra mods so I can
// implement the 'more' system in the modify panel.
extern ClassDesc* GetBendModDesc2();
extern ClassDesc* GetBendModDesc3();
extern ClassDesc* GetBendModDesc4();
extern ClassDesc* GetBendModDesc5();
extern ClassDesc* GetSDeleteModDesc();
// in mods.cpp
extern HINSTANCE hInstance;

// For 'Supports Object of Type' rollups
extern BOOL CALLBACK DefaultSOTProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

#define BIGFLOAT	float(999999)

#define NEWSWMCAT	_T("Modifiers")

// Image list used for mesh sub-object toolbar in Edit Mesh, Mesh Select:
class MeshSelImageHandler {
public:
	HIMAGELIST images;
	MeshSelImageHandler () { images = NULL; }
	~MeshSelImageHandler () { if (images) ImageList_Destroy (images); }
	HIMAGELIST LoadImages ();
};
#define IDC_SELVERTEX 0x3260
#define IDC_SELEDGE 0x3261
#define IDC_SELFACE 0x3262
#define IDC_SELPOLY 0x3263
#define IDC_SELELEMENT 0x3264
extern int *meshSubTypeToolbarIDs;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\noisemod.cpp ===
/**********************************************************************
 *<
	FILE: noisemod.cpp

	DESCRIPTION:  A Noise Modifier

	CREATED BY: Rolf Berteig

	HISTORY: created 18 October 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

// in mods.cpp
extern HINSTANCE hInstance;

#define BIGFLOAT	float(999999)
#define NOISEOSM_CLASS_ID	0xf997b124

class NoiseMod : public SimpleMod {	
	public:
		static IParamMap *pmapParam;

		NoiseMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_NOISEMOD); }  
		virtual Class_ID ClassID() {return Class_ID(NOISEOSM_CLASS_ID,0);}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_RB_NOISE); }
		IOResult Load(ILoad *iload);

		// From simple mod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void InvalidateUI() {if (pmapParam) pmapParam->Invalidate();}
	};

class NoiseDeformer: public Deformer {
	public:
		Matrix3 tm,invtm;
		int fractal;
		float scale, rough, iterations;
		Point3 strength;
		float time;

		NoiseDeformer();			
		NoiseDeformer(
			ModContext &mc,
			TimeValue t,
			int seed, float scale, int fractal, float iterations,
			float rough, int anim, float freq,			
			Point3 strength,
			TimeValue phase,
			Matrix3& modmat, Matrix3& modinv);
		Point3 Map(int i, Point3 p); 
	};

#define NOISEWSM_CLASSID	Class_ID(NOISEOSM_CLASS_ID,1)

class NoiseWSM : public SimpleOSMToWSMObject {
	public:
		NoiseWSM() {}
		NoiseWSM(NoiseMod *m) : SimpleOSMToWSMObject(m) {}
		void DeleteThis() { delete this; }
		SClass_ID SuperClassID() {return WSM_OBJECT_CLASS_ID;}
		Class_ID ClassID() {return NOISEWSM_CLASSID;} 
		TCHAR *GetObjectName() {return GetString(IDS_RB_NOISE);}
		RefTargetHandle Clone(RemapDir& remap)
			{return (new NoiseWSM((NoiseMod*)mod->Clone(remap)))->SimpleOSMToWSMClone(this,remap);}
	};


//--- ClassDescriptor and class vars ---------------------------------

IParamMap *NoiseMod::pmapParam = NULL;



class NoiseClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new NoiseMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_NOISE_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(NOISEOSM_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static NoiseClassDesc noiseDesc;
extern ClassDesc* GetNoiseModDesc() { return &noiseDesc; }

class NoiseWSMClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) 
		{if (loading) return new NoiseWSM; else return new NoiseWSM(new NoiseMod);}
	const TCHAR *	ClassName() { return GetString(IDS_RB_NOISE_CLASS); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return NOISEWSM_CLASSID; }
	const TCHAR* 	Category() {return GetSpaceWarpCatString(SPACEWARP_CAT_MODBASED);}
	};

static NoiseWSMClassDesc noiseWSMDesc;
extern ClassDesc* GetNoiseWSMDesc() { return &noiseWSMDesc; }


//--- Parameter map/block descriptors -------------------------------

#define PB_SEED			0
#define PB_SCALE		1
#define PB_FRACTAL		2
#define PB_ROUGH		3
#define PB_ITERATIONS	4
#define PB_ANIMATE		5
#define PB_FREQ			6
#define PB_PHASE		7
#define PB_STRENGTH		8


//
//
// Parameters


static ParamUIDesc descParam[] = {
	// Seed
	ParamUIDesc(
		PB_SEED,
		EDITTYPE_INT,
		IDC_MODNOISE_SEED,IDC_MODNOISE_SEEDSPIN,
		0.0f,99999999.0f,
		0.1f),

	// Scale
	ParamUIDesc(
		PB_SCALE,
		EDITTYPE_FLOAT,
		IDC_MODNOISE_SCALE,IDC_MODNOISE_SCALESPIN,
		0.0f,BIGFLOAT,
		SPIN_AUTOSCALE),
	
	// Fractal
	ParamUIDesc(PB_FRACTAL,TYPE_SINGLECHEKBOX,IDC_MODNOISE_FRACTAL),
	
	// Roughness
	ParamUIDesc(
		PB_ROUGH,
		EDITTYPE_FLOAT,
		IDC_MODNOISE_ROUGHNESS,IDC_MODNOISE_ROUGHNESSSPIN,
		0.0f,1.0f,
		0.005f),	

	// Iterations
	ParamUIDesc(
		PB_ITERATIONS,
		EDITTYPE_FLOAT,
		IDC_MODNOISE_ITERATIONS,IDC_MODNOISE_ITERATIONSSPIN,
		1.0f,10.0f,
		0.01f),	

	// Animate
	ParamUIDesc(PB_ANIMATE,TYPE_SINGLECHEKBOX,IDC_MODNOISE_ANIMATE),

	// Frequency
	ParamUIDesc(
		PB_FREQ,
		EDITTYPE_FLOAT,
		IDC_MODNOISE_FREQ,IDC_MODNOISE_FREQSPIN,
		0.00001f,BIGFLOAT,
		0.01f),
	
	// Phase
	ParamUIDesc(
		PB_PHASE,
		EDITTYPE_TIME,
		IDC_MODNOISE_PHASE,IDC_MODNOISE_PHASESPIN,
		(float)-999999999,(float)999999999,
		10.0f),

	// Strength
	ParamUIDesc(			  
		PB_STRENGTH,
		EDITTYPE_UNIVERSE,		                       
		IDC_MODNOISE_XSTRENGTH,IDC_MODNOISE_XSTRENGTHSPIN,
		IDC_MODNOISE_YSTRENGTH,IDC_MODNOISE_YSTRENGTHSPIN,
		IDC_MODNOISE_ZSTRENGTH,IDC_MODNOISE_ZSTRENGTHSPIN,
		-BIGFLOAT,BIGFLOAT,		
		SPIN_AUTOSCALE),	
	};
#define PARAMDESC_LENGH 9

static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },	
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_FLOAT, NULL, FALSE, 5 },
	{ TYPE_POINT3, NULL, TRUE, 6 } };


static ParamBlockDescID descVer1[] = {
	{ TYPE_INT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_FLOAT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, TRUE, 8 },
	{ TYPE_POINT3, NULL, TRUE, 6 } };
#define PBLOCK_LENGTH	9

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,7,0)
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);


//--- NoiseDlgProc -------------------------------


class NoiseDlgProc : public ParamMapUserDlgProc {
	public:
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void SetState(HWND hWnd);
		void DeleteThis() {}
	};
static NoiseDlgProc theNoiseProc;

void NoiseDlgProc::SetState(HWND hWnd)
	{
	ISpinnerControl *spin1 = GetISpinner(GetDlgItem(hWnd,IDC_MODNOISE_ROUGHNESSSPIN));
	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_MODNOISE_ITERATIONSSPIN));
	if (IsDlgButtonChecked(hWnd,IDC_MODNOISE_FRACTAL)) {
		spin1->Enable();
		spin2->Enable();
		EnableWindow(GetDlgItem(hWnd,IDC_MODNOISE_ROUGHNESSLABEL),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_MODNOISE_ITERATIONSLABEL),TRUE);
	} else {
		spin1->Disable();
		spin2->Disable();
		EnableWindow(GetDlgItem(hWnd,IDC_MODNOISE_ROUGHNESSLABEL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_MODNOISE_ITERATIONSLABEL),FALSE);
		}
	ReleaseISpinner(spin1);
	ReleaseISpinner(spin2);
	}

BOOL NoiseDlgProc::DlgProc(
		TimeValue t,IParamMap *map,
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			SetState(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_MODNOISE_FRACTAL:
					SetState(hWnd);
					break;
				}
			break;
		}
	return FALSE;
	}

//--- Noise methods -------------------------------


NoiseMod::NoiseMod() : SimpleMod()
	{	
	MakeRefByID(FOREVER, SIMPMOD_PBLOCKREF, 
		CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_SCALE,0,100.0f);
	pblock->SetValue(PB_FRACTAL,0,0);	
	pblock->SetValue(PB_FREQ,0,0.25f);
	pblock->SetValue(PB_ITERATIONS,0,6.0f);

#ifdef DESIGN_VER
		pblock->SetValue(PB_ANIMATE,0,1);
		pblock->SetValue(PB_PHASE,GetAnimStart(),GetAnimStart());
#else
		SuspendAnimate();
		AnimateOn();
		pblock->SetValue(PB_PHASE,GetAnimStart(),GetAnimStart());
		pblock->SetValue(PB_PHASE,GetAnimEnd(),GetAnimEnd());
		ResumeAnimate();
#endif
	}

IOResult NoiseMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,SIMPMOD_PBLOCKREF));
	return IO_OK;
	}

void NoiseMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleMod::BeginEditParams(ip,flags,prev);
		
	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
#ifdef DESIGN_VER
		MAKEINTRESOURCE(IDD_NOISEPARAM_VIZ),
#else
		MAKEINTRESOURCE(IDD_NOISEPARAM),
#endif
		GetString(IDS_RB_PARAMETERS),
		0);	
	pmapParam->SetUserDlgProc(&theNoiseProc);
	}
		
void NoiseMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleMod::EndEditParams(ip,flags,next);
	DestroyCPParamMap(pmapParam);
	}

Interval NoiseMod::GetValidity(TimeValue t)
	{
	float f;	
	int i, animate;
	Point3 p;
	Interval valid = FOREVER;
	pblock->GetValue(PB_SEED,t,i,valid);
	pblock->GetValue(PB_SCALE,t,f,valid);
	pblock->GetValue(PB_FRACTAL,t,i,valid);
	pblock->GetValue(PB_ROUGH,t,f,valid);
	pblock->GetValue(PB_ITERATIONS,t,f,valid);
	pblock->GetValue(PB_ANIMATE,t,animate,valid);
	pblock->GetValue(PB_FREQ,t,f,valid);		
	pblock->GetValue(PB_STRENGTH,t,p,valid);
	if (animate) pblock->GetValue(PB_PHASE,t,i,valid);
	if (animate) valid.SetInstant(t);
	return valid;
	}

RefTargetHandle NoiseMod::Clone(RemapDir& remap) 
	{	
	NoiseMod* newmod = new NoiseMod();	
	newmod->ReplaceReference(SIMPMOD_PBLOCKREF,pblock->Clone(remap));
	newmod->SimpleModClone(this);
	return(newmod);
	}

NoiseDeformer::NoiseDeformer() 
	{ 
	tm.IdentityMatrix();
	invtm.IdentityMatrix();
	}

Point3 NoiseDeformer::Map(int i, Point3 p)
	{	
	Point3 d, sp;
	p = p * tm;
	sp = p * scale + Point3(0.5f,0.5f,0.5f);
	if (fractal) {
		d.x = fBm1(Point3(sp.y,sp.z,time),rough,2.0f,iterations);
		d.y = fBm1(Point3(sp.x,sp.z,time),rough,2.0f,iterations);
		d.z = fBm1(Point3(sp.x,sp.y,time),rough,2.0f,iterations);
	} else {
		d.x = noise3(Point3(sp.y,sp.z,time));
		d.y = noise3(Point3(sp.x,sp.z,time));
		d.z = noise3(Point3(sp.x,sp.y,time));
		}	
	return (p+(d*strength)) * invtm;	
	}

NoiseDeformer::NoiseDeformer(
		ModContext &mc,
		TimeValue t,
		int seed, float scale, int fractal, float iterations,
		float rough, int anim, float freq,
		Point3 strength,
		TimeValue phase,
		Matrix3& modmat, Matrix3& modinv)
	{
	tm    = modmat;
	invtm = modinv;	
	this->scale      = (scale==0.0f) ? 0.00001f : (1.0f/scale);
	this->fractal    = fractal;
	this->rough      = 1.0f-rough;
	this->strength   = strength;
	this->iterations = iterations;
	if (anim) {
		time = float(phase) * float(0.005) * freq * 
			1200.0f/float(TIME_TICKSPERSEC) + Perm(seed);
	} else {
		time = (float)Perm(seed);
		}
	} 


Deformer& NoiseMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	int fractal, seed, anim;
	float scale, rough, freq, iterations;
	TimeValue phase;
	Point3 strength;

	pblock->GetValue(PB_SEED,t,seed,FOREVER);
	pblock->GetValue(PB_SCALE,t,scale,FOREVER);
	pblock->GetValue(PB_FRACTAL,t,fractal,FOREVER);
	pblock->GetValue(PB_ITERATIONS,t,iterations,FOREVER);
	pblock->GetValue(PB_ROUGH,t,rough,FOREVER);
	pblock->GetValue(PB_ANIMATE,t,anim,FOREVER);
	pblock->GetValue(PB_FREQ,t,freq,FOREVER);
	pblock->GetValue(PB_PHASE,t,phase,FOREVER);
	pblock->GetValue(PB_STRENGTH,t,strength,FOREVER);
	if (iterations<1.0f) iterations = 1.0f;
	if (scale<0.00001f) scale = 0.00001f;

	static NoiseDeformer deformer;
	deformer = NoiseDeformer(mc,t,seed,scale,fractal,iterations,rough,anim,freq,strength,phase,mat,invmat);
	return deformer;
	}


ParamDimension *NoiseMod::GetParameterDim(int pbIndex)
	{
	switch (pbIndex) {
		case PB_SEED:		return defaultDim;
		case PB_SCALE:		return defaultDim;
		case PB_FRACTAL:	return defaultDim;
		case PB_ROUGH:		return defaultDim;
		case PB_STRENGTH:	return stdWorldDim;
		case PB_PHASE:		return stdTimeDim;
		case PB_ITERATIONS:	return defaultDim;
		default:			return defaultDim;
		}
	}

TSTR NoiseMod::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_SEED:		return GetString(IDS_RB_SEED);
		case PB_SCALE:		return GetString(IDS_RB_SCALE);
		case PB_FRACTAL:	return GetString(IDS_RB_FRACTAL);
		case PB_ROUGH:		return GetString(IDS_RB_ROUGH);
		case PB_STRENGTH:	return GetString(IDS_RB_STRENGTH2);
		case PB_PHASE:		return GetString(IDS_RB_PHASE);
		case PB_ITERATIONS:	return GetString(IDS_RB_ITERATIONS);
		default:			return TSTR(_T(""));
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\optmod.cpp ===
/**********************************************************************
 *<
	FILE: optmod.cpp

	DESCRIPTION:  Optimize modifier

	CREATED BY: Rolf Berteig

	HISTORY: 10/20/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"


class OptMod : public Modifier, public MeshOpProgress {	
	public:
		IParamBlock *pblock;
		static IParamMap *pmapParam;
		BOOL forceUpdate;

		OptMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_OPTMOD); }  
		virtual Class_ID ClassID() { return Class_ID(OPTIMIZEOSM_CLASS_ID,0);}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);		
		TCHAR *GetObjectName() { return GetString(IDS_RB_OPTIMIZE); }
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		int RenderBegin(TimeValue t, ULONG flags);		
		int RenderEnd(TimeValue t);
		IOResult Load(ILoad *iload);

		ChannelMask ChannelsUsed()  {return OBJ_CHANNELS;}
		ChannelMask ChannelsChanged() {return OBJ_CHANNELS;}
		Class_ID InputType() {return triObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);

		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock = (IParamBlock*)rtarg;}

		int NumSubs() {return 1;}
		Animatable* SubAnim(int i) {return pblock;}
		TSTR SubAnimName(int i) {return GetString(IDS_RB_PARAMETERS);}

		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);

		// From MeshOpProgress
		void Init(int total);
		BOOL Progress(int p);
	};



//--- ClassDescriptor and class vars ---------------------------------

IParamMap *OptMod::pmapParam = NULL;



class OptClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new OptMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_OPTIMIZE_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(OPTIMIZEOSM_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static OptClassDesc optDesc;
extern ClassDesc* GetOptModDesc() { return &optDesc; }


//--- Parameter map/block descriptors -------------------------------

#define A_RENDER			A_PLUGIN1

#define PB_RENDER			0
#define PB_VIEWS			1

#define PB_FACETHRESH1		2
#define PB_EDGETHRESH1		3
#define PB_BIAS1			4
#define PB_PRESERVEMAT1		5
#define PB_PRESERVESMOOTH1	6
#define PB_MAXEDGE1			7

#define PB_FACETHRESH2		8
#define PB_EDGETHRESH2		9
#define PB_BIAS2			10
#define PB_PRESERVEMAT2		11
#define PB_PRESERVESMOOTH2	12
#define PB_MAXEDGE2			13

#define PB_AUTOEDGE			14
#define PB_MANUPDATE		15

// Map indices
#define MAP_FACETHRESH		2
#define MAP_EDGETHRESH		3
#define MAP_BIAS			4
#define MAP_PRESERVEMAT		5
#define MAP_PRESERVESMOOTH	6
#define MAP_MAXEDGE			7

//
//
// Parameters

static int renderIDs[] = {IDC_OPT_RENDERL1,IDC_OPT_RENDERL2};
static int viewsIDs[] = {IDC_OPT_VIEWSL1,IDC_OPT_VIEWSL2};

static ParamUIDesc descParam[] = {
	// Renderer
	ParamUIDesc(PB_RENDER,TYPE_RADIO,renderIDs,2),
	
	// Viewports
	ParamUIDesc(PB_VIEWS,TYPE_RADIO,viewsIDs,2),

	// Face thresh
	ParamUIDesc(
		PB_FACETHRESH1,
		EDITTYPE_FLOAT,
		IDC_OPT_FACETHRESH,IDC_OPT_FACETHRESHSPIN,
		0.0f,90.0f,
		0.1f,
		stdAngleDim),

	// Edge thresh
	ParamUIDesc(
		PB_EDGETHRESH1,
		EDITTYPE_FLOAT,
		IDC_OPT_EDGETHRESH,IDC_OPT_EDGETHRESHSPIN,
		0.0f,90.0f,
		0.1f,
		stdAngleDim),

	// Bias
	ParamUIDesc(
		PB_BIAS1,
		EDITTYPE_FLOAT,
		IDC_OPT_BIAS,IDC_OPT_BIASSPIN,
		0.0f,1.0f,
		0.01f),	

	// Preserve mat boundries
	ParamUIDesc(PB_PRESERVEMAT1,TYPE_SINGLECHEKBOX,IDC_OPT_PRESERVEMAT),	

	// Preserve smooth boundries
	ParamUIDesc(PB_PRESERVESMOOTH1,TYPE_SINGLECHEKBOX,IDC_OPT_PRESERVESMOOTH),

	// Max Edge
	ParamUIDesc(
		PB_MAXEDGE1,
		EDITTYPE_FLOAT,
		IDC_OPT_MAXEDGE,IDC_OPT_MAXEDGESPIN,
		0.0f,BIGFLOAT,
		SPIN_AUTOSCALE),

	// Auto edge
	ParamUIDesc(PB_AUTOEDGE,TYPE_SINGLECHEKBOX,IDC_OPT_AUTOEDGE),

	// Manual update
	ParamUIDesc(PB_MANUPDATE,TYPE_SINGLECHEKBOX,IDC_OPT_MANUPDATE),	
	};
#define PARAMDESC_LENGH 10


static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_INT, NULL, FALSE, 1 },
	
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },

	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_INT, NULL, FALSE, 10 },
	{ TYPE_INT, NULL, FALSE, 11 },
	
	{ TYPE_INT, NULL, FALSE, 12 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_INT, NULL, FALSE, 1 },
	
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 13 }, // max edge1

	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_INT, NULL, FALSE, 10 },
	{ TYPE_INT, NULL, FALSE, 11 },
	{ TYPE_FLOAT, NULL, TRUE, 14 },	// max edge2

	{ TYPE_INT, NULL, FALSE, 12 },	
	};

static ParamBlockDescID descVer2[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_INT, NULL, FALSE, 1 },
	
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 13 }, // max edge1

	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_INT, NULL, FALSE, 10 },
	{ TYPE_INT, NULL, FALSE, 11 },
	{ TYPE_FLOAT, NULL, TRUE, 14 },	// max edge2

	{ TYPE_INT, NULL, FALSE, 12 },	
	{ TYPE_INT, NULL, FALSE, 15 },
	};

#define PBLOCK_LENGTH	16


// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,13,0),
	ParamVersionDesc(descVer1,15,0)
	};
#define NUM_OLDVERSIONS	2

// Current version
#define CURRENT_VERSION	2
static ParamVersionDesc curVersion(descVer2,PBLOCK_LENGTH,CURRENT_VERSION);



//--- OptDlgProc -------------------------------

class OptDlgProc : public ParamMapUserDlgProc {
	public:
		Interface *ip;
		OptMod *mod;
		OptDlgProc() {ip=NULL;mod=NULL;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void SetupLevels(IParamMap *map);
		void SetupManButton(HWND hWnd,IParamMap *map);
		void DeleteThis() {}
	};
static OptDlgProc theOptProc;

void OptDlgProc::SetupLevels(IParamMap *map)
	{
	int l;
	map->GetParamBlock()->GetValue(PB_VIEWS,0,l,FOREVER);
	if (l==0) {
		map->SetPBlockIndex(MAP_FACETHRESH,PB_FACETHRESH1);
		map->SetPBlockIndex(MAP_EDGETHRESH,PB_EDGETHRESH1);
		map->SetPBlockIndex(MAP_BIAS,PB_BIAS1);
		map->SetPBlockIndex(MAP_PRESERVEMAT,PB_PRESERVEMAT1);
		map->SetPBlockIndex(MAP_PRESERVESMOOTH,PB_PRESERVESMOOTH1);
		map->SetPBlockIndex(MAP_MAXEDGE,PB_MAXEDGE1);
	} else {
		map->SetPBlockIndex(MAP_FACETHRESH,PB_FACETHRESH2);
		map->SetPBlockIndex(MAP_EDGETHRESH,PB_EDGETHRESH2);
		map->SetPBlockIndex(MAP_BIAS,PB_BIAS2);
		map->SetPBlockIndex(MAP_PRESERVEMAT,PB_PRESERVEMAT2);
		map->SetPBlockIndex(MAP_PRESERVESMOOTH,PB_PRESERVESMOOTH2);
		map->SetPBlockIndex(MAP_MAXEDGE,PB_MAXEDGE2);
		}
	}

void OptDlgProc::SetupManButton(HWND hWnd,IParamMap *map)
	{
	int man;
	map->GetParamBlock()->GetValue(PB_MANUPDATE,0,man,FOREVER);
	EnableWindow(GetDlgItem(hWnd,IDC_OPT_UPDATE),man);
	}

BOOL OptDlgProc::DlgProc(
		TimeValue t,IParamMap *map,
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			SetupLevels(map);
			SetWindowText(GetDlgItem(hWnd,IDC_OPT_VERTCOUNT),NULL);		
			SetWindowText(GetDlgItem(hWnd,IDC_OPT_FACECOUNT),NULL);
			SetupManButton(hWnd,map);
			break;
		
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_OPT_VIEWSL1: 
				case IDC_OPT_VIEWSL2:
					SetupLevels(map);
					break;

				case IDC_OPT_MANUPDATE:					
					SetupManButton(hWnd,map);
					break;

				case IDC_OPT_UPDATE:
					mod->forceUpdate = TRUE;
					mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					ip->RedrawViews(ip->GetTime());
					break;
				}
			break;
		}
	return FALSE;
	}


//--- Opt methods -------------------------------


OptMod::OptMod()
	{	
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descVer2, PBLOCK_LENGTH, CURRENT_VERSION));	
	pblock->SetValue(PB_FACETHRESH1,0,DegToRad(4.0f));
	pblock->SetValue(PB_EDGETHRESH1,0,DegToRad(1.0f));
	pblock->SetValue(PB_BIAS1,0,0.1f);
	pblock->SetValue(PB_FACETHRESH2,0,DegToRad(4.0f));
	pblock->SetValue(PB_EDGETHRESH2,0,DegToRad(1.0f));
	pblock->SetValue(PB_BIAS2,0,0.1f);
	pblock->SetValue(PB_MANUPDATE,0,0);
	forceUpdate = FALSE;
	}

IOResult OptMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}

void OptMod::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev)
	{
	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_OPTIMIZEPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);	
	theOptProc.ip  = ip;
	theOptProc.mod = this;
	pmapParam->SetUserDlgProc(&theOptProc);
	}
		
void OptMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{	
	DestroyCPParamMap(pmapParam);
	pmapParam = NULL;
	theOptProc.ip  = NULL;
	theOptProc.mod = NULL;
	}

Interval OptMod::LocalValidity(TimeValue t)
	{
	float f;		
	Interval valid = FOREVER;
	int man;
	pblock->GetValue(PB_MANUPDATE,t,man,valid);
	if (!man) {
		pblock->GetValue(PB_FACETHRESH1,t,f,valid);
		pblock->GetValue(PB_EDGETHRESH1,t,f,valid);	
		pblock->GetValue(PB_BIAS1,t,f,valid);	
		pblock->GetValue(PB_MAXEDGE1,t,f,valid);
			
		pblock->GetValue(PB_FACETHRESH2,t,f,valid);
		pblock->GetValue(PB_EDGETHRESH2,t,f,valid);	
		pblock->GetValue(PB_BIAS2,t,f,valid);	
		pblock->GetValue(PB_MAXEDGE2,t,f,valid);
		}
	return valid;
	}

RefTargetHandle OptMod::Clone(RemapDir& remap) 
	{
	OptMod* newmod = new OptMod();	
	newmod->ReplaceReference(0,pblock->Clone(remap));	
	return newmod;
	}

int OptMod::RenderBegin(TimeValue t, ULONG flags)
	{
	int views, render, man;
	pblock->GetValue(PB_VIEWS,0,views,FOREVER);
	pblock->GetValue(PB_RENDER,0,render,FOREVER);	
	pblock->GetValue(PB_MANUPDATE,0,man,FOREVER);
	SetAFlag(A_RENDER);
	if (views!=render || man) {
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		}
	return 0;
	}

int OptMod::RenderEnd(TimeValue t)
	{
	int views, render;
	pblock->GetValue(PB_VIEWS,0,views,FOREVER);
	pblock->GetValue(PB_RENDER,0,render,FOREVER);
	ClearAFlag(A_RENDER);
	if (views!=render) {
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		}
	return 0;
	}

void OptMod::Init(int total)
	{
	}

BOOL OptMod::Progress(int p)
	{
	SHORT res = GetAsyncKeyState(VK_ESCAPE);
	if (res&1) return FALSE;
	else return TRUE;
	}

void OptMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	float faceThresh, edgeThresh, bias, maxEdge;
	int preserveMat, preserveSmooth, which, render=0, autoEdge;
	DWORD flags = 0;
	Interval valid = FOREVER;
	int nv,nf;

	int man;
	pblock->GetValue(PB_MANUPDATE,t,man,valid);
	if (man && !forceUpdate && !TestAFlag(A_RENDER)) return;
	forceUpdate = FALSE;

	if (TestAFlag(A_RENDER)) {
		pblock->GetValue(PB_RENDER,t,which,valid);
	} else {
		pblock->GetValue(PB_VIEWS,t,which,valid);
		}	
	
	pblock->GetValue(PB_AUTOEDGE,t,autoEdge,valid);

	if (which==0) {
		pblock->GetValue(PB_FACETHRESH1,t,faceThresh,valid);
		pblock->GetValue(PB_EDGETHRESH1,t,edgeThresh,valid);	
		pblock->GetValue(PB_BIAS1,t,bias,valid);
		pblock->GetValue(PB_PRESERVEMAT1,t,preserveMat,valid);
		pblock->GetValue(PB_PRESERVESMOOTH1,t,preserveSmooth,valid);
		pblock->GetValue(PB_MAXEDGE1,t,maxEdge,valid);
	} else {
		pblock->GetValue(PB_FACETHRESH2,t,faceThresh,valid);
		pblock->GetValue(PB_EDGETHRESH2,t,edgeThresh,valid);	
		pblock->GetValue(PB_BIAS2,t,bias,valid);
		pblock->GetValue(PB_PRESERVEMAT2,t,preserveMat,valid);
		pblock->GetValue(PB_PRESERVESMOOTH2,t,preserveSmooth,valid);
		pblock->GetValue(PB_MAXEDGE2,t,maxEdge,valid);
		}		
	
	assert(os->obj->IsSubClassOf(triObjectClassID));
	TriObject *triOb = (TriObject *)os->obj;
	nv = triOb->GetMesh().getNumVerts();
	nf = triOb->GetMesh().getNumFaces();

	if (preserveMat) flags |= OPTIMIZE_SAVEMATBOUNDRIES;
	if (preserveSmooth) flags |= OPTIMIZE_SAVESMOOTHBOUNDRIES;
	if (autoEdge) flags |= OPTIMIZE_AUTOEDGE;

	if (faceThresh!=0.0f) {
		GetAsyncKeyState(VK_ESCAPE); // clear the state
		HCURSOR hCur;
		if (nf > 2000) hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));

		triOb->GetMesh().Optimize(
			faceThresh,edgeThresh, bias*0.5f, maxEdge, flags,this);

		if (nf > 200) SetCursor(hCur);
		}

	triOb->GetMesh().InvalidateTopologyCache ();
	triOb->PointsWereChanged();
	triOb->UpdateValidity(GEOM_CHAN_NUM,valid);
	triOb->UpdateValidity(TOPO_CHAN_NUM,valid);	

	if (pmapParam && pmapParam->GetParamBlock()==pblock && !TestAFlag(A_RENDER)) {
		TSTR buf;
		buf.printf("%d / %d",nv,triOb->GetMesh().getNumVerts());
		SetWindowText(GetDlgItem(pmapParam->GetHWnd(),IDC_OPT_VERTCOUNT),buf);
		buf.printf("%d / %d",nf,triOb->GetMesh().getNumFaces());
		SetWindowText(GetDlgItem(pmapParam->GetHWnd(),IDC_OPT_FACECOUNT),buf);
		}
	}

RefResult OptMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message) 
   	{
	switch (message) {
		case REFMSG_CHANGE: {			
			if (pmapParam && pmapParam->GetParamBlock()==pblock) {
				pmapParam->Invalidate();
				}			
			int man = FALSE;
			if (pblock) pblock->GetValue(PB_MANUPDATE,0,man,FOREVER);
			if (man) return REF_STOP;
			break;
			}

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_FACETHRESH1:
				case PB_FACETHRESH2:
				case PB_EDGETHRESH1:
				case PB_EDGETHRESH2:	gpd->dim = stdAngleDim; break;				
				case PB_MAXEDGE1:
				case PB_MAXEDGE2:		gpd->dim = stdWorldDim; break;
				default:				gpd->dim = defaultDim; break;
				}			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_FACETHRESH1:	gpn->name = GetString(IDS_RB_FACETHRESHL1); break;
				case PB_FACETHRESH2:	gpn->name = GetString(IDS_RB_FACETHRESHL2); break;
				case PB_EDGETHRESH1:	gpn->name = GetString(IDS_RB_EDGETHRESHL1); break;
				case PB_EDGETHRESH2:	gpn->name = GetString(IDS_RB_EDGETHRESHL2); break;
				case PB_BIAS1:			gpn->name = GetString(IDS_RB_BIASL1); break;
				case PB_BIAS2:			gpn->name = GetString(IDS_RB_BIASL2); break;
				case PB_MAXEDGE1:		gpn->name = GetString(IDS_RB_MAXEDGE1); break;
				case PB_MAXEDGE2:		gpn->name = GetString(IDS_RB_MAXEDGE2); break;
				default:				gpn->name = TSTR(_T("")); break;
				}
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\sctex.cpp ===
/**********************************************************************
 *<
	FILE: sctex.cpp

	DESCRIPTION: A ShadeContext for rendering texture maps

	CREATED BY: Rolf Berteig (took code from mtlrend.cpp

	HISTORY: 2/02/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "sctex.h"
#include "gamma.h"

SCTex::SCTex() {
	tiling = 1.0f;
	mtlNum = 0; 
	doMaps = TRUE;
	filterMaps = TRUE;
	shadow = FALSE;
	backFace = FALSE;
	curTime = 0;
	norm = Point3(0,0,1);
	view = Point3(0,0,-1);
	ResetOutput();
	}

Box3 SCTex::ObjectBox() {
	return Box3(Point3(0,0,0),Point3(scale,scale,scale));
	}

Point3 SCTex::PObjRelBox() {
	Point3 q;
	Point3 p = PObj();
	Box3 b = ObjectBox();
	q.x = 2.0f*(p.x-b.pmin.x)/(b.pmax.x-b.pmin.x) - 1.0f;
	q.y = 2.0f*(p.y-b.pmin.y)/(b.pmax.y-b.pmin.y) - 1.0f;
	q.z = 2.0f*(p.z-b.pmin.z)/(b.pmax.z-b.pmin.z) - 1.0f;
	return q;
	}

void SCTex::ScreenUV(Point2& uv, Point2 &duv) {
	uv.x = uvw.x;
	uv.y = uvw.x;
	duv.x = duvw.x;
	duv.y = duvw.y;
	}

Point3 SCTex::DPObjRelBox() {
	return Point3(0,0,0);
	}

// Bump vectors for UVW: in Camera space
void SCTex::DPdUVW(Point3 dP[3],int chan) { 
	dP[0] = dP[1] = dP[2] = Point3(0,0,0);
	}

Point3 SCTex::P() { 
	return pt; 
	}

Point3 SCTex::DP() { 
	return dpt; 
	}

Point3 SCTex::PObj() { 
	return pt; 
	}

Point3 SCTex::DPObj() { 
	return dpt; 
	}

UBYTE *RenderTexMap(Texmap *tex,int w, int h)
	{
	float du = 1.0f/float(w);
	float dv = 1.0f/float(h);
	AColor col;
	SCTex sc;
//watje 3-4-99	int scanw = ByteWidth(w*3);
	int scanw = ByteWidth(w);
//	UBYTE *image = new UBYTE[ByteWidth(w*3)*h];
	UBYTE *image = new UBYTE[ByteWidth(w)*h];
	UBYTE *p1;
		
	sc.scale = 1.0f;
	sc.duvw = Point3(du,dv,0.0f);
	sc.dpt  = sc.duvw;
	sc.uvw.y = 1.0f-0.5f*dv;
	for (int j=0; j<h; j++) {
		sc.scrPos.y = j;
		sc.uvw.x = 0.5f*du;				
		p1 = image + (h-j-1)*scanw;
		for (int i=0; i<w; i++) {
			sc.scrPos.x = i;
			sc.pt = sc.uvw;
			col = tex->EvalColor(sc);
			*p1++ = gammaCorrect((UBYTE)(col.b*255.0f));
			*p1++ = gammaCorrect((UBYTE)(col.g*255.0f));
			*p1++ = gammaCorrect((UBYTE)(col.r*255.0f));	
			sc.uvw.x +=du;
			}		
		sc.uvw.y -= dv;
		}
	return image;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\nspline.cpp ===
/**********************************************************************
 *<
	FILE: nspline.cpp

	DESCRIPTION:  Normalize Spline

	CREATED BY: Peter Watje

	HISTORY: created Jan 20, 1997

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm2.h"
#include "shape.h"
#include "spline3d.h"
#include "splshape.h"
#include "linshape.h"

//--- NormalizeSpline -----------------------------------------------------------

#define EDITSPL_CHANNELS (PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|PART_DISPLAY|PART_TOPO)

#define MIN_AMOUNT		float(-1.0E30)
#define MAX_AMOUNT		float(1.0E30)

#define SPLINETYPE 0
#define CIRCULAR 0


#define PW_PATCH_TO_SPLINE1 0x1c450e5c
#define PW_PATCH_TO_SPLINE2 0x2e0e0902

//#define DEBUG 1



class NormalizeSpline: public Modifier {
	
	protected:
		IParamBlock2 *pblock;

		static IObjParam *ip;
		
	public:
		static IParamMap *pmapParam;
		
		static float nlength;



		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_PW_NSPLINE); }  
		virtual Class_ID ClassID() { return Class_ID(PW_PATCH_TO_SPLINE1,PW_PATCH_TO_SPLINE2);}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_PW_NSPLINE); }
		IOResult Load(ILoad *iload);

		NormalizeSpline();
		virtual ~NormalizeSpline();

		ChannelMask ChannelsUsed()  { return EDITSPL_CHANNELS; }
		ChannelMask ChannelsChanged() { return EDITSPL_CHANNELS; }


		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		Class_ID InputType() { return Class_ID(SPLINESHAPE_CLASS_ID,0); }
		
		Interval LocalValidity(TimeValue t);

		// From BaseObject
		BOOL ChangeTopology() {return TRUE;}
//		IParamArray *GetParamBlock() {return pblock;}
//		int GetParamBlockIndex(int id) {return id;}

		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock2*)rtarg;}

 		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i) { return pblock; }
		TSTR SubAnimName(int i) { return TSTR(GetString(IDS_RB_PARAMETERS));}		

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 

		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);

		void BuildSkin(TimeValue t,ModContext &mc, ObjectState * os);

		void UpdateUI(TimeValue t) {}
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { if (i == 0) return pblock; 
											else return NULL;
												} // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) {if (pblock->ID() == id) return pblock ;
													else return  NULL; } // return id'd ParamBlock

	};

class NormalizeSplineClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new NormalizeSpline; }
	const TCHAR *	ClassName() { return GetString(IDS_PW_NSPLINE); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return  Class_ID(PW_PATCH_TO_SPLINE1,PW_PATCH_TO_SPLINE2); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("NormalizeSpline"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static NormalizeSplineClassDesc normalizeSplineDesc;
extern ClassDesc* GetNormalizeSplineDesc() { return &normalizeSplineDesc; }

IObjParam*		NormalizeSpline::ip        = NULL;
IParamMap *		NormalizeSpline::pmapParam = NULL;
float			NormalizeSpline::nlength = 20.0f;
 

//--- Parameter map/block descriptors -------------------------------

static int outputIDs[] = {IDC_RADIO1,IDC_RADIO2,IDC_RADIO3,IDC_RADIO4};


//#define PB_SPLINETYPE	0
//#define PB_CIRCULAR		0
//#define PB_NLENGTH		1

#define PBLOCK_REF		0

enum { nspline_params};

enum { nspline_length};



// per instance geosphere block
static ParamBlockDesc2 nspline_param_blk ( nspline_params, _T("Parameters"),  0, &normalizeSplineDesc, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//rollout
	IDD_NSPLINE, IDS_RB_PARAMETERS, 0, 0, NULL,
	// params

	nspline_length,  _T("Length"),	TYPE_FLOAT, 	0, 	IDS_RB_LENGTH, 
		p_default, 		20.0f,	
		p_range, 		1.0f,999999999.0f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_LENGTH_EDIT,IDC_LENGTH_SPIN,  1.0f,
		end, 

	end
	);


//
//
// Parameters
/*

static ParamUIDesc descParam[] = {
	// Spline type
//	ParamUIDesc(PB_SPLINETYPE,TYPE_RADIO,outputIDs,4)
//															 Length
	// Circular
   ParamUIDesc(PB_CIRCULAR,TYPE_SINGLECHEKBOX,IDC_TEST_CHECK),
	// NLnegth
	ParamUIDesc(
		PB_NLENGTH,
		EDITTYPE_FLOAT,
		IDC_LENGTH_EDIT,IDC_LENGTH_SPIN,
		0.01f,999999999.0f,
		0.01f)


	};
*/
#define PARAMDESC_LENGTH 2



static ParamBlockDescID descVer3[] = {
	{ TYPE_INT, NULL, FALSE, -1 },
	{ TYPE_FLOAT, NULL, TRUE, nspline_length }
	 };

#define PBLOCK_LENGTH	2

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer3,2,5),	
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	5
//   static ParamVersionDesc curVersion(descVer3,PBLOCK_LENGTH,CURRENT_VERSION);

NormalizeSpline::NormalizeSpline()
	{
/*
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descVer3, PBLOCK_LENGTH, CURRENT_VERSION));
	pblock->SetValue(PB_NLENGTH, TimeValue(0), nlength);
*/

	GetNormalizeSplineDesc()->MakeAutoParamBlocks(this);

	
	}

NormalizeSpline::~NormalizeSpline()
	{	
	}

Interval NormalizeSpline::LocalValidity(TimeValue t)
	{
	// if being edited, return NEVER forces a cache to be built 
	// after previous modifier.
	if (TestAFlag(A_MOD_BEING_EDITED))
		return NEVER;  
	Interval valid = GetValidity(t);	
	return valid;
	}

RefTargetHandle NormalizeSpline::Clone(RemapDir& remap)
	{
	NormalizeSpline* newmod = new NormalizeSpline();	
	newmod->ReplaceReference(0,pblock->Clone(remap));
	return(newmod);
	}

void NormalizeSpline::ModifyObject(TimeValue t, ModContext &mc, ObjectState * os, INode *node) 
	{	
//DebugPrint("Extrude modifying object\n");

	// Get our personal validity interval...
	Interval valid = GetValidity(t);
	// and intersect it with the channels we use as input (see ChannelsUsed)
	valid &= os->obj->ChannelValidity(t,TOPO_CHAN_NUM);
	valid &= os->obj->ChannelValidity(t,GEOM_CHAN_NUM);
	Matrix3 modmat,minv;
	
//	int output;


//	pblock->GetValue(PB_NLENGTH,t,nlength,valid);
	pblock->GetValue(nspline_length,t,nlength,valid);

	if (nlength < 0.0001f) nlength = 0.0001f;
	
	

	BuildSkin(t, mc, os);

	


	os->obj->SetChannelValidity(TOPO_CHAN_NUM, valid);
	os->obj->SetChannelValidity(GEOM_CHAN_NUM, valid);
	os->obj->SetChannelValidity(TEXMAP_CHAN_NUM, valid);
	os->obj->SetChannelValidity(MTL_CHAN_NUM, valid);
	os->obj->SetChannelValidity(SELECT_CHAN_NUM, valid);
	os->obj->SetChannelValidity(SUBSEL_TYPE_CHAN_NUM, valid);
	os->obj->SetChannelValidity(DISP_ATTRIB_CHAN_NUM, valid);

//	os->obj = pat;

	os->obj->UnlockObject();
//	os->obj->InvalidateGeomCache();

	}


void NormalizeSpline::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	this->ip = ip;

	TimeValue t = ip->GetTime();

	// Disable show end result.
	ip->EnableShowEndResult(FALSE);



	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);

	SetAFlag(A_MOD_BEING_EDITED);

	normalizeSplineDesc.BeginEditParams(ip, this, flags, prev);
/*
	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGTH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_WELD),
		GetString(IDS_RB_PARAMETERS),
		0);	
*/
	}

void NormalizeSpline::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next)
	{
	this->ip = NULL;
//reanable show end result
	ip->EnableShowEndResult(TRUE);
	
	TimeValue t = ip->GetTime();

	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);
	ClearAFlag(A_MOD_BEING_EDITED);

	normalizeSplineDesc.EndEditParams(ip, this, flags, next);

//	DestroyCPParamMap(pmapParam);


	}

Interval NormalizeSpline::GetValidity(TimeValue t)
	{
	float f;
	Interval valid = FOREVER;

	// Start our interval at forever...
	// Intersect each parameters interval to narrow it down.
	pblock->GetValue(nspline_length,t,f,valid);

	return valid;
	}

RefResult NormalizeSpline::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message ) 
   	{
/*	switch (message) {

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}

		}
*/
	return(REF_SUCCEED);
	}

ParamDimension *NormalizeSpline::GetParameterDim(int pbIndex)
	{
	return defaultDim;
	}

TSTR NormalizeSpline::GetParameterName(int pbIndex)
	{
	return TSTR(_T(""));
//	switch (pbIndex) {
//		case PB_NLENGTH:	return TSTR(_T("Normal Length"));
//		default:		
//		}
	}

IOResult NormalizeSpline::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, NUM_OLDVERSIONS, &nspline_param_blk, this, PBLOCK_REF);
	iload->RegisterPostLoadCallback(plcb);

//	iload->RegisterPostLoadCallback(
//		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}




void NormalizeSpline::BuildSkin(TimeValue t,ModContext &mc, ObjectState * os) {


SplineShape *shape = (SplineShape *)os->obj->ConvertToType(t,splineShapeClassID);


int polys = shape->shape.splineCount;
int poly;


float cinc = 0.0f;
float TotalLength = 0.0f;

for(poly = 0; poly < polys; ++poly) 
	{
	shape->shape.splines[poly]->ComputeBezPoints();

	TotalLength += shape->shape.splines[poly]->SplineLength();
	}

cinc = 	nlength/TotalLength;

cinc = cinc/10.0f;
if (cinc>0.001f) cinc = 0.001f;

for(poly = 0; poly < polys; ++poly) 
	{
//get spline
//get number segs

//get points
	float SegLength;

	SegLength = nlength*nlength;

	float inc = 0.001f;
	float CurrentPercent = 0.0f;

	inc = cinc;
	Point3 CurrentPoint,NextPoint;
	Tab<Point3> PointList;
	PointList.ZeroCount();

	while (CurrentPercent < 1.0)
		{
		CurrentPoint = shape->shape.splines[poly]->InterpCurve3D(CurrentPercent);
		PointList.Append(1,&CurrentPoint,1);
		NextPoint = CurrentPoint;
		while ((LengthSquared(CurrentPoint-NextPoint)<SegLength) && (CurrentPercent <1.0f))
			{
			CurrentPercent += inc;
			NextPoint = shape->shape.splines[poly]->InterpCurve3D(CurrentPercent);
			}
		}
   int i,closed;
   closed = shape->shape.splines[poly]->Closed();
   if (!shape->shape.splines[poly]->Closed())
		{
		NextPoint = shape->shape.splines[poly]->GetKnotPoint(shape->shape.splines[poly]->KnotCount()-1);
		PointList.Append(1,&NextPoint,1);
		}
	shape->shape.splines[poly]->NewSpline();
//add new points
	if (closed)
		shape->shape.splines[poly]->SetClosed();
		else shape->shape.splines[poly]->SetOpen();

	for (i=0;i<PointList.Count();i++)
		{
		shape->shape.splines[poly]->AddKnot(SplineKnot(KTYPE_AUTO,LTYPE_CURVE,
					PointList[i],PointList[i],PointList[i]));
		}

	if (shape->shape.splines[poly]->KnotCount() == 1)
		shape->shape.splines[poly]->AddKnot(SplineKnot(KTYPE_AUTO,LTYPE_CURVE,
					PointList[PointList.Count()-1],PointList[PointList.Count()-1],PointList[PointList.Count()-1]));

	shape->shape.splines[poly]->ComputeBezPoints();
	for (i=0;i<shape->shape.splines[poly]->KnotCount();i++)
		shape->shape.splines[poly]->SetKnotType(i,KTYPE_AUTO);


	shape->shape.splines[poly]->ComputeBezPoints();


	}

shape->shape.UpdateSels();	// Make sure it readies the selection set info
shape->shape.InvalidateGeomCache();

			


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\sctex.h ===
/**********************************************************************
 *<
	FILE: sctex.h

	DESCRIPTION: A ShadeContext for rendering texture maps

	CREATED BY: Rolf Berteig (took code from mtlrend.cpp

	HISTORY: 2/02/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#ifndef __SCTEXT_H__
#define __SCTEXT_H__

class LightDescImp: public LightDesc {
	public:
	Point3 pos;
	Color col;
    BOOL Illuminate(ShadeContext& sc, Point3& normal, Color& color, Point3 &dir, float &dot_nl) {
		dir = Normalize(pos-sc.P());
		dot_nl = DotProd(normal,dir);
		color = col;
		return 1;		
		}
	};
class SCTex: public ShadeContext {
	public:
	float tiling;
	float scale;
	Color ambientLight;
	LightDescImp* lights[2];
	Point3 uvw,duvw,norm,view,pt,dpt;
	IPoint2 scrPos;
	TimeValue curTime;
	Renderer *GetRenderer() { return NULL; }
	BOOL 	  InMtlEditor() { return TRUE; }
	LightDesc* Light(int n) { return lights[n]; }
	int ProjType() { return 1;} // returns: 0: perspective, 1: parallel
	int FaceNumber() { return 0; }
	TimeValue CurTime() { return curTime; }
	Point3 Normal() { return norm; }  	// interpolated normal
	void SetNormal(Point3 p) { norm = p;} 	// for perturbing normal
	Point3 GNormal() { return norm;} 	// geometric (face) normal
	Point3 ReflectVector() { return Point3(0,0,1); }
	Point3 RefractVector(float ior) {return Point3(0,0,1);	}
    Point3 CamPos() { return Point3(0,0,0); }			// camera position
	Point3 V() { return view; }       	// Unit view vector: from camera towards P 
	void SetView(Point3 v) { view =v; }
	Point3 P();			// point to be shaded in camera space;
	Point3 DP();   		// deriv of P, relative to pixel, for AA
	Point3 PObj();					  	// point in obj coords
	Point3 DPObj();   	// deriv of PObj, rel to pixel, for AA
	Box3 ObjectBox(); 	 			 	// Object extents box in obj coords
	Point3 PObjRelBox();   				// Point rel to obj box [-1 .. +1 ] 
	Point3 DPObjRelBox();  				// Point rel to obj box [-1 .. +1 ] 
	Point3 UVW(int chan) { return uvw;	};
   	Point3 DUVW(int chan) {	return duvw;	}
	void DPdUVW(Point3 dP[3],int chan); 			// Bump vectors for UVW: in Camera space
	AColor EvalEnvironMap(Texmap *map, Point3 viewd) {
		AColor rcol;
        rcol.Black();
		return rcol;
		}

	void ScreenUV(Point2& uv, Point2 &duv); // screen coordinate
	IPoint2 SCTex::ScreenCoord() {return scrPos;}

	Point3 PointTo(const Point3& p, RefFrame ito) { return p; }
	Point3 PointFrom(const Point3& p, RefFrame ifrom) { return p; } 
	Point3 VectorTo(const Point3& p, RefFrame ito) { return p; } 
	Point3 VectorFrom(const Point3& p, RefFrame ifrom){ return p; } 
	void GetBGColor(Color &bgcol, Color& transp, BOOL fogBG=TRUE) {	}
	SCTex();
	void SetTiling(float t) { tiling = t; }
	};

// Allocates and renders a 3 byte per pixel image
UBYTE *RenderTexMap(Texmap *tex,int w, int h);

#endif //__SCTEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\modsres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mods.rc
//
#define IDD_BENDPARAM                   101
#define IDC_TH_SELCURSOR                101
#define IDD_TAPERPARAM                  102
#define IDC_EXTRUDECUR                  102
#define IDD_SINWAVEPARAM1               103
#define IDB_FACESELTYPES                103
#define IDC_OUTLINECUR                  103
#define IDB_MASK_FACESELTYPES           104
#define IDC_SEGBREAKCUR                 104
#define IDD_SINWAVEMODPARAM             105
#define IDC_SEGREFINECUR                105
#define IDC_VERTCONNECTCUR              106
#define IDC_VERTINSERTCUR               107
#define IDD_DETACH                      109
#define IDB_BOOLEANTYPES                110
#define IDD_EM_ATTACH_MATS              110
#define IDB_MASK_BOOLEANTYPES           111
#define IDD_AUTHMSG                     116
#define IDD_AUTHORIZE                   117
#define IDB_MASK_BULBS                  117
#define IDD_TWISTPARAM                  118
#define IDB_BULBS                       118
#define IDC_ADDVERTCUR                  119
#define IDB_MASK_MIRRORTYPES            119
#define IDD_EXTRUDEPARAM                120
#define IDB_MIRRORTYPES                 120
#define IDB_EM_SELTYPES                 123
#define IDD_BOMBPARAMS                  124
#define IDB_EM_SELMASK                  124
#define IDD_ELPARAM_OBJECT              125
#define IDD_ELPARAM_PATH                126
#define IDB_PATCHSELTYPES               126
#define IDD_ELPARAM_SECTION             127
#define IDB_SPLINESELTYPES              127
#define IDD_SKEWPARAM                   129
#define IDD_NOISEPARAM                  130
#define IDD_SINWAVEOMODPARAM            131
#define IDD_LINWAVEPARAM1               132
#define IDD_LINWAVEOMODPARAM            133
#define IDD_OPTIMIZEPARAM               134
#define IDD_DISPLACEPARAM               135
#define IDD_CLUSTNODEPARAM              136
#define IDD_EM_SELECTBYMAT              137
#define IDD_WINDPARAM                   138
#define IDD_GRAVITYPARAM                139
#define IDD_DEFLECTORPARAM              140
#define IDD_UVWMAPPARAM                 141
#define IDD_EM_SELECTBYSMOOTH           143
#define IDD_DISPLACE_SOT                144
#define IDD_WINDRAIN_SOT                145
#define IDD_SINWAVE_SOT                 146
#define IDD_BOMB_SOT                    147
#define IDD_SELECTPARAM                 148
#define IDD_MATERIALPARAM               149
#define IDD_SMOOTHPARAM                 150
#define IDD_NORMALPARAM                 151
#define IDC_CUR_TRIM                    151
#define IDD_SURFREVPARAM                152
#define IDD_DISPLACEPARAM_WS            154
#define IDD_UNWRAP_FLOATER              155
#define IDB_UNWRAPTOOL                  156
#define IDC_ES_CROSS_HAIR               156
#define IDB_MASK_UNWRAPTOOL             157
#define IDD_UNWRAP_PROP                 157
#define IDB_UNWRAP_VIEW_MASK            160
#define IDB_UNWRAP_OPTION_MASK          161
#define IDB_UNWRAP_TRANSFORM            162
#define IDB_UNWRAP_TRANSFORM_MASK       163
#define IDB_UNWRAP_VERT                 164
#define IDB_UNWRAP_VERT_MASK            165
#define IDB_UNWRAP_VIEW                 166
#define IDB_UNWRAP_OPTION               167
#define IDB_SPLINESELMASK               168
#define IDB_PATCHSELMASK                169
#define IDC_BEVEL                       170
#define IDR_UNWRAP_RIGHT_MENU           171
#define IDC_ECHAMFERCUR                 172
#define IDC_VCHAMFERCUR                 173
#define IDC_SCALEY                      176
#define IDC_MOVEY                       177
#define IDC_SCALEX                      178
#define IDC_MOVEX                       179
#define IDC_ZOOMREG                     180
#define IDC_PANHAND                     181
#define IDC_ZOOM                        182
#define IDD_MAP_ACQUIRE                 201
#define IDD_RESETXFORM_PANEL            202
#define IDD_AFRPARAM                    203
#define IDD_TESSPARAM                   204
#define IDD_FACEEXTRUDEPARAM            209
#define IDD_UVWXFORMPARAM               210
#define IDD_MIRRORPARAM                 211
#define IDD_UNWRAP_PARAMS               212
#define IDD_PASTE_NAMEDSET              213
#define IDD_SEL_NAMEDSET                214
#define IDD_WINDGRAV_SOT                215
#define IDS_ADV_SURF_APPROX_WARNING_TITLE 322
#define IDS_ADV_SURF_APPROX_WARNING     323
#define IDS_PW_PICK                     324
#define IDS_PW_SNAP                     325
#define IDS_PW_WELD                     326
#define IDS_PW_FACEMAP                  327
#define IDS_PW_SELECTFACE               328
#define IDS_PW_UVWFILES                 329
#define IDS_PW_SAVEOBJECT               330
#define IDS_PW_FILEEXISTS               331
#define IDS_PW_LOADOBJECT               332
#define IDS_PW_MIRRORH                  333
#define IDS_PW_EXPANDSELECTION          334
#define IDS_PW_FALLOFF                  335
#define IDS_PW_FALLOFFSPACE             336
#define IDS_PW_BREAK                    337
#define IDS_PW_LOCKSELECTED             338
#define IDS_PW_HIDE                     339
#define IDS_PW_FREEZE                   340
#define IDS_PW_FACEFILTER               341
#define IDS_PW_LEVEL                    342
#define IDS_PW_USE_AR                   343
#define IDS_PW_PINCH                    344
#define IDS_PW_BUBBLE                   345
#define IDS_PW_METHOD                   346
#define IDS_PW_TYPE                     347
#define IDS_PW_VOLUME                   348
#define IDS_PW_INVERT                   349
#define IDS_PW_NODE                     350
#define IDS_PW_TEXMAP                   351
#define IDS_PW_CHANNEL                  352
#define IDS_PW_MAP                      353
#define IDS_PW_MIRRORV                  354
#define IDS_PW_CONTRACTSELECTION        355
#define IDS_PW_FALLOFFSPACEUVW          356
#define IDS_PW_UNHIDE                   357
#define IDS_PW_UNFREEZE                 358
#define IDS_PW_FALLOFF2                 359
#define IDD_SURF_APPROX_ADV             413
#define IDD_EM_SELECT                   414
#define IDD_EM_GEOM                     415
#define IDD_EM_SURF_VERT                416
#define IDD_EM_SURF_FACE                417
#define IDD_EM_SURF_EDGE                418
#define IDD_EM_CREATECURVE              419
#define IDD_EM_DETACH                   420
#define IDD_MESH_SELECT                 421
#define IDD_MESHSEL_AFFECTREGION        422
#define IDC_ANGLE                       1000
#define IDC_X                           1001
#define IDC_PHASE                       1001
#define IDC_Y                           1002
#define IDC_Z                           1003
#define IDC_DIR                         1004
#define IDC_TWIST_BIAS                  1004
#define IDC_EM_IGNORE_VISEDGE           1004
#define IDC_ANGLESPINNER                1005
#define IDC_MODNOISE_SEED               1005
#define IDC_EM_IGNORE_BACKFACES         1005
#define IDC_DIRSPINNER                  1006
#define IDC_TWIST_BIASSPIN              1006
#define IDC_CRV                         1007
#define IDC_PHASESPINNER                1007
#define IDC_MODNOISE_SEEDSPIN           1007
#define IDC_OPT_BIAS                    1007
#define IDC_DISP_UTILE                  1007
#define IDC_NS_LIST                     1007
#define IDC_AMT                         1008
#define IDC_DECAYSPINNER                1008
#define IDC_MODNOISE_ROUGHNESS          1008
#define IDC_OPT_BIASSPIN                1008
#define IDC_DISP_UTILESPIN              1008
#define IDC_SET_NAME                    1008
#define IDC_AMTSPINNER                  1009
#define IDC_DECAY                       1009
#define IDC_MODNOISE_ROUGHNESSSPIN      1009
#define IDC_DISP_VTILE                  1009
#define IDC_OPT_MAXEDGE                 1009
#define IDC_CRVSPINNER                  1010
#define IDC_MODNOISE_ITERATIONS         1010
#define IDC_DISP_VTILESPIN              1010
#define IDC_OPT_MAXEDGESPIN             1010
#define IDC_AMPLITUDE                   1011
#define IDC_TAPER_FROM                  1011
#define IDC_MODNOISE_ITERATIONSSPIN     1011
#define IDC_DISP_STRENGTH               1011
#define IDC_EM_DETACH_ELEM              1011
#define IDC_AMPSPINNER                  1012
#define IDC_TAPER_TO                    1012
#define IDC_DISP_STRENGTHSPIN           1012
#define IDC_WAVELEN                     1013
#define IDC_TAPER_FROMSPIN              1013
#define IDC_DISP_DECAY                  1013
#define IDC_EM_NUMBER_SEL               1013
#define IDC_NUMSEL_LABEL                1013
#define IDC_EM_DETACH_CLONE             1013
#define IDC_WAVELENSPINNER              1014
#define IDC_TAPER_TOSPIN                1014
#define IDC_DISP_DECAYSPIN              1014
#define IDC_CIRCLES                     1015
#define IDC_DISP_BLUR                   1015
#define IDC_CIRCLESSPINNER              1016
#define IDC_DISP_BLURSPIN               1016
#define IDC_EMCURVE_NAME                1016
#define IDC_SEGS                        1017
#define IDC_DISP_CENTERL                1017
#define IDC_EMCURVE_SMOOTH              1017
#define IDC_SVN_SELECTED                1017
#define IDC_WELDTESS                    1017
#define IDC_SEGSPINNER                  1018
#define IDC_DISP_CENTERLSPIN            1018
#define IDC_EMCURVE_LINEAR              1018
#define IDC_DIVISIONS                   1019
#define IDC_EMCURVE_IGNOREHIDDEN        1019
#define IDC_DIVSPINNER                  1020
#define IDC_FLEX                        1021
#define IDC_STRENGTH                    1021
#define IDC_AMPSPINNER2                 1021
#define IDC_FLEXSPINNER                 1022
#define IDC_STRENGTHSPIN                1022
#define IDC_AMPLITUDE2                  1022
#define IDC_AUTHORIZE                   1023
#define IDC_GRAVITYSPIN                 1023
#define IDC_LOCKID                      1024
#define IDC_GRAVITY                     1024
#define IDC_EDIT2                       1025
#define IDC_DETONATIONSPIN              1025
#define IDC_DETACH                      1026
#define IDC_DETONATION                  1026
#define IDC_BOMB_CHAOSSPIN              1027
#define IDC_BOMB_CHAOS                  1028
#define IDC_WELDTHRESH                  1030
#define IDC_THRESHSPINNER               1031
#define IDC_LENGTH_EDIT                 1031
#define IDC_SMOOTH_THRESHSPIN           1035
#define IDC_EM_VERT_SELG                1035
#define IDC_TES_EDGE                    1036
#define IDC_SMOOTH_THRESH               1036
#define IDC_TES_CENTER                  1037
#define IDC_TENSION                     1039
#define IDC_MAT_IDSPIN                  1039
#define IDC_MAT_ID                      1040
#define IDC_WELD                        1041
#define IDC_WELDCUR                     1041
#define IDC_ES_INSERT                   1042
#define IDC_LEVEL                       1043
#define IDC_ES_BREAK                    1043
#define IDC_LEVELSPINNER                1044
#define IDC_ES_MAKEFIRST                1044
#define IDC_TES_FACE_TRI                1045
#define IDC_SELTYPE                     1045
#define IDC_ES_FUSE                     1045
#define IDC_ES_CLOSE                    1046
#define IDC_TES_FACE_POLY               1047
#define IDC_ES_OUTLINE                  1047
#define IDC_ES_BOOLEAN                  1048
#define IDC_ES_OUTCENTER                1049
#define IDC_DETACHCOPY                  1050
#define IDC_LENGTH_SPIN                 1050
#define IDC_ES_FILLET                   1050
#define IDC_EM_ALIGNCONST               1051
#define IDC_ES_EXPLODE                  1051
#define IDC_ATTACH                      1052
#define IDC_ATTACHCUR                   1052
#define IDC_EM_ANGLETHRESH              1052
#define IDC_ES_CHAMFER                  1052
#define IDC_EM_REMOVE_ISO_VERTS         1053
#define IDC_ES_CREATELINE               1053
#define IDC_EM_CREATE_CURVE             1054
#define IDC_ES_ATTACH_MULTIPLE          1054
#define IDC_DETACH_NAME                 1055
#define IDC_ALIGNMIN                    1055
#define IDC_ES_CROSS_INSERT             1055
#define IDD_EDSPLINE_OPS                1055
#define IDC_GETSHAPE                    1056
#define IDC_EM_SPLIT                    1056
#define IDD_EDSPLINE_SELECT             1056
#define IDC_LOCK_HANDLES                1057
#define IDC_EM_REFINE                   1057
#define IDD_EDPATCH_SELECT              1057
#define IDC_LOCKALIKE                   1058
#define IDC_ALIGNCENTER                 1058
#define IDC_EM_CUT                      1058
#define IDC_ES_SEGDIVIDE                1058
#define IDD_EDPATCH_OPS                 1058
#define IDC_LOCKALL                     1059
#define IDC_ALIGNMAX                    1059
#define IDC_EM_SLICEPLANE               1059
#define IDD_SELECTBYMAT                 1059
#define IDC_ATTACHREORIENT              1060
#define IDC_EM_SLICE                    1060
#define IDC_SHOW_VERTEX_NUMBERS         1060
#define IDC_DETACHREORIENT              1061
#define IDC_EM_TES_TEXT                 1061
#define IDD_EM_CLONE                    1061
#define IDC_AREA_SELECTION              1061
#define IDC_EM_EXP_TEXT                 1062
#define IDC_ES_SAMESHAPE                1062
#define IDD_EM_EXPLODE                  1062
#define IDC_AMOUNT                      1063
#define IDC_EM_PIXELS_TEXT              1063
#define IDC_ES_OUTLINESPINNER           1063
#define IDD_DISP_APPROX_ADV             1063
#define IDC_AMOUNTSPINNER               1064
#define IDC_ES_OUTLINEWIDTH             1064
#define IDC_SEGMENTSPINNER              1065
#define IDC_ADDTRI                      1065
#define IDC_ES_BOOL_TYPE                1065
#define IDC_SEGMENTS                    1066
#define IDC_ADDQUAD                     1066
#define IDC_ES_FILLETWIDTH              1066
#define IDC_CAPSTART                    1067
#define IDC_ES_MIRROR                   1067
#define IDC_CAPEND                      1068
#define IDC_ES_MIRROR_TYPE              1068
#define IDC_ES_COPY_MIRROR              1069
#define IDC_HIDE                        1069
#define IDC_SECDELETE                   1070
#define IDC_ES_REVERSE                  1070
#define IDC_UNHIDE                      1070
#define IDC_GETPATH                     1071
#define IDC_SECALIGN                    1071
#define IDC_BIND                        1071
#define IDC_ES_FILLETSPINNER            1071
#define IDC_SECCENTER                   1072
#define IDC_UNBIND                      1072
#define IDC_ES_CHAMFERWIDTH             1072
#define IDC_ALIGNTYPES                  1073
#define IDC_ES_CHAMFERSPINNER           1073
#define IDC_ES_ABOUT_PIVOT              1074
#define IDC_ES_RCLINEAR                 1075
#define IDC_ES_SHOW_SELECTED            1076
#define IDC_ES_TRIM                     1077
#define IDC_ES_RCCLOSED                 1078
#define IDC_ES_BINDFIRST                1079
#define IDC_ES_BINDLAST                 1080
#define IDC_ES_EXTEND                   1081
#define IDC_ES_TRIM_INFINITE            1082
#define IDC_ES_RCONNECT                 1083
#define IDC_FALLOFF                     1086
#define IDC_EM_DELETE                   1086
#define IDC_FALLOFFSPIN                 1087
#define IDC_PINCHSPIN                   1088
#define IDC_SPIN                        1088
#define IDC_EM_T_THR_SPIN               1088
#define IDC_PINCH                       1089
#define IDC_SPINSPIN                    1089
#define IDC_BUBBLESPIN                  1090
#define IDC_MINFRAG                     1090
#define IDC_BUBBLE                      1091
#define IDC_MINFRAGSPIN                 1091
#define IDC_NEARLABEL                   1092
#define IDC_MAXFRAG                     1092
#define IDC_FARLEFTLABEL                1093
#define IDC_MAXFRAGSPIN                 1093
#define IDC_FARRIGHTLABEL               1094
#define IDC_SEED                        1094
#define IDC_AR_GRAPH                    1095
#define IDC_SEEDSPIN                    1095
#define IDC_TENSTEXT                    1096
#define IDC_EM_VERT_SELRSPIN            1096
#define IDC_EM_E_ITER_SPIN              1096
#define IDC_EM_VERT_SELGSPIN            1097
#define IDC_TAPER_AFFECTREGION          1098
#define IDC_EM_VERT_SELBSPIN            1098
#define IDC_EFFECT_X                    1104
#define IDC_EFFECT_Y                    1105
#define IDC_EFFECT_BOTH                 1106
#define IDC_TAPER_SYMMETRY              1107
#define IDC_BEND_AFFECTREGION           1108
#define IDC_BEND_TO                     1109
#define IDC_BEND_TOSPIN                 1110
#define IDC_BEND_FROM                   1111
#define IDC_BEND_FROMSPIN               1112
#define IDC_TWIST_AFFECTREGION          1113
#define IDC_MODNOISE_FRACTAL            1113
#define IDC_MERGE_SPINNER               1113
#define IDC_TWIST_TO                    1114
#define IDC_MODNOISE_ANIMATE            1114
#define IDC_TWIST_TOSPIN                1115
#define IDC_EM_EXTYPE_A                 1115
#define IDC_TWIST_FROM                  1116
#define IDC_EM_EXTYPE_B                 1116
#define IDC_TWIST_FROMSPIN              1117
#define IDC_MERGE                       1117
#define IDC_SKEW_AMOUNT                 1118
#define IDC_EP_SM_SMOOTH                1118
#define IDC_SKEW_AMOUNTSPIN             1119
#define IDC_EP_SM_SMOOTH2               1119
#define IDC_SKEW_AFFECTREGION           1120
#define IDC_EP_SM_SMOOTH3               1120
#define IDC_SKEW_TO                     1121
#define IDC_EM_CLONE_OBJ                1121
#define IDC_EP_SM_SMOOTH4               1121
#define IDC_SKEW_TOSPIN                 1122
#define IDC_EM_CLONE_ELEM               1122
#define IDC_EP_SM_SMOOTH5               1122
#define IDC_SKEW_FROM                   1123
#define IDC_DO_SUBDIV                   1123
#define IDC_EP_SM_SMOOTH6               1123
#define IDC_SKEW_FROMSPIN               1124
#define IDC_MODNOISE_XSTRENGTH          1127
#define IDC_MODNOISE_XSTRENGTHSPIN      1128
#define IDC_MODNOISE_YSTRENGTH          1129
#define IDC_MODNOISE_YSTRENGTHSPIN      1130
#define IDC_MODNOISE_ZSTRENGTH          1131
#define IDC_TESS_MIN_REC_SPINNER        1131
#define IDC_MODNOISE_ZSTRENGTHSPIN      1132
#define IDC_TESS_MAX_REC_SPINNER        1132
#define IDC_MODNOISE_SCALE              1133
#define IDC_TESS_MAX_TRIS_SPINNER       1133
#define IDC_MODNOISE_SCALESPIN          1134
#define IDC_MODNOISE_ROUGHNESSLABEL     1135
#define IDC_TESS_MIN_REC                1135
#define IDC_MODNOISE_FREQ               1136
#define IDC_OPT_PRESERVEMAT             1136
#define IDC_TESS_MAX_REC                1136
#define IDC_MODNOISE_FREQSPIN           1137
#define IDC_OPT_RENDERL1                1137
#define IDC_TESS_MAX_TRIS               1137
#define IDC_OPT_RENDERL2                1138
#define IDC_MODNOISE_PHASE              1138
#define IDC_OPT_VIEWSL1                 1139
#define IDC_MODNOISE_PHASESPIN          1139
#define IDC_OPT_VIEWSL2                 1140
#define IDC_MODNOISE_ITERATIONSLABEL    1140
#define IDC_OPT_FACETHRESH              1141
#define IDC_OPT_FACETHRESHSPIN          1142
#define IDD_DISP_APPROX                 1142
#define IDC_OPT_EDGETHRESH              1143
#define IDD_MESHER_DISP_APPROX          1143
#define IDC_OPT_EDGETHRESHSPIN          1144
#define IDD_NSPLINE                     1144
#define IDC_OPT_PRESERVESMOOTH          1145
#define IDD_EM_AFFECTREGION             1145
#define IDC_OPT_AUTOEDGE                1146
#define IDD_ES_EXPLODE                  1146
#define IDC_OPT_VERTCOUNT               1147
#define IDC_TESS_LDA                    1147
#define IDC_OPT_FACECOUNT               1148
#define IDD_EDSPLINE_SURF               1148
#define IDC_DISP_PLANAR                 1149
#define IDD_EDPATCH_SURF                1149
#define IDC_DISP_CYL                    1150
#define IDD_EDPATCH_SURF_OBJ            1150
#define IDC_DISP_SPHERE                 1151
#define IDD_NOISEPARAM_VIZ              1151
#define IDC_DISP_USEMAP                 1152
#define IDC_DISP_APPLYMAP               1153
#define IDC_DISP_CENTERLUM              1154
#define IDC_DISP_PICKIMAGE              1155
#define IDC_DISP_REMOVEIMAGE            1156
#define IDC_CLUST_PICKNODE              1157
#define IDC_DISP_PICKMAP                1157
#define IDC_CLUST_NODENAME              1158
#define IDC_DISP_REMOVEMAP              1158
#define IDC_DISPLENGTH                  1161
#define IDC_DISPLENGTHSPIN              1162
#define IDC_WIND_STRENGTH               1163
#define IDC_WIND_STRENGTHSPIN           1164
#define IDC_FORCE_PLANAR                1165
#define IDC_FORCE_SPHERICAL             1166
#define IDC_WIND_DECAYSPIN              1167
#define IDC_WIND_DECAY                  1168
#define IDC_WIND_TURBSPIN               1169
#define IDC_WIND_TURB                   1170
#define IDC_GRAV_STRENGTH               1171
#define IDC_WIND_FREQSPIN               1171
#define IDC_GRAV_STRENGTHSPIN           1172
#define IDC_WIND_FREQ                   1172
#define IDC_GRAV_DECAY                  1173
#define IDC_WIND_SCALESPIN              1173
#define IDC_GRAV_DECAYSPIN              1174
#define IDC_WIND_SCALE                  1174
#define IDC_DEFLECT_BOUNCE              1175
#define IDC_DEFLECT_BOUNCESPIN          1176
#define IDC_DEFLECT_WIDTH               1177
#define IDC_DEFLECT_WIDTHSPIN           1178
#define IDC_DEFLECT_HEIGHTSPIN          1179
#define IDC_MAP_PLANAR                  1179
#define IDC_DEFLECT_HEIGHT              1180
#define IDC_MAP_CYL                     1180
#define IDC_ES_DIVISIONS                1180
#define IDC_MAP_SPHERE                  1181
#define IDC_ES_DIVSSPINNER              1181
#define IDC_MAP_BALL                    1182
#define IDC_MAP_FIT                     1183
#define IDC_MAP_CENTER                  1184
#define IDC_MAP_VIEWALIGN               1185
#define IDC_MAP_NORMALALIGN             1186
#define IDC_MAP_BOX                     1187
#define IDC_MAP_FITREGION               1188
#define IDC_PATCH_DELETE                1188
#define IDC_MAP_BITMAPFIT               1189
#define IDC_MAP_UFLIP                   1190
#define IDC_MAP_VFLIP                   1191
#define IDC_MAP_UTILESPIN               1192
#define IDC_MAP_VTILESPIN               1193
#define IDC_MAP_VTILE                   1194
#define IDC_MAP_UTILE                   1195
#define IDC_MAP_WTILE                   1196
#define IDC_SMOOTH_AUTO                 1196
#define IDC_MAP_WTILESPIN               1197
#define IDC_SMOOTH_PREVENTINDIRECT      1197
#define IDC_MAP_WFLIP                   1198
#define IDC_MAP_UOFFSET                 1199
#define IDC_MAP_RESET                   1199
#define IDC_SELECT_BYID                 1200
#define IDC_CLEARSELECTION              1200
#define IDC_MAP_VOFFSET                 1200
#define IDC_MAP_ACQUIRE                 1200
#define IDC_SEL_OBJECT                  1201
#define IDC_MAP_WOFFSET                 1201
#define IDC_MAP_FACE                    1201
#define IDC_SELECTBYSMOOTH              1201
#define IDC_SEL_VERTEX                  1202
#define IDC_MAP_UOFFSETSPIN             1202
#define IDC_MAP_LENGTH                  1202
#define IDC_EM_SMOOTH_CLEAR             1202
#define IDC_SMOOTH_CLEAR                1202
#define IDC_SEL_FACE                    1203
#define IDC_MAP_VOFFSETSPIN             1203
#define IDC_MAP_WIDTH                   1203
#define IDC_SEL_ADD                     1204
#define IDC_MAP_WOFFSETSPIN             1204
#define IDC_MAP_HEIGHT                  1204
#define IDC_EM_NORMAL_FLIPMODE          1204
#define IDC_SEL_SUBTRACT                1205
#define IDC_MAP_LENGTHSPIN              1205
#define IDC_SEL_REPLACE                 1206
#define IDC_MAP_WIDTHSPIN               1206
#define IDC_SEL_WINDOW                  1207
#define IDC_MAP_HEIGHTSPIN              1207
#define IDC_SEL_CROSSING                1208
#define IDC_MAP_XYZTOUVW                1208
#define IDC_SEL_FIT                     1212
#define IDC_SEL_CENTER                  1213
#define IDC_SEL_RESET                   1214
#define IDC_MATID                       1215
#define IDC_MATIDSPIN                   1216
#define IDC_SEL_OBJECT_BUTTON           1217
#define IDC_SEL_INVERT                  1218
#define IDC_NORM_UNIFY                  1219
#define IDC_SEL_TEXTURE_BUTTON          1219
#define IDC_NORM_FLIP                   1220
#define IDC_MAP_CAP                     1220
#define IDC_SEL_BOXB                    1220
#define IDC_DEGREES                     1221
#define IDC_SEL_SPHEREB                 1221
#define IDC_DEGREESSPINNER              1222
#define IDC_SEL_CYLINDERB               1222
#define IDC_MORPHCAP                    1223
#define IDC_SEL_MESH_OBJECTB            1223
#define IDC_GRIDCAP                     1224
#define IDC_SEL_AUTOFIT                 1224
#define IDC_SEL_MATB                    1225
#define IDC_WELDCORE                    1226
#define IDC_SEL_SMGROUPB                1226
#define IDC_SEL_TEXTURE_MAPB            1227
#define IDC_DISPLATTICE                 1229
#define IDC_DISPSURFACE                 1230
#define IDC_SUBDIVIDE                   1233
#define IDC_PROPAGATE                   1235
#define IDC_STEPS                       1237
#define IDC_STEPSSPINNER                1238
#define IDC_DISP_BALL                   1239
#define IDC_TESS_U_SPINNER              1239
#define IDC_STEPS_RENDER                1239
#define IDC_TESS_U                      1240
#define IDC_STEPSRENDERSPINNER          1240
#define IDC_TESS_V_SPINNER              1241
#define IDC_DISP_WTILE                  1242
#define IDC_TESS_V                      1242
#define IDC_DISP_WTILESPIN              1243
#define IDC_TESS_DIST_SPINNER           1243
#define IDC_DISP_WFLIP                  1244
#define IDC_TESS_DIST                   1244
#define IDC_DISP_VFLIP                  1245
#define IDC_TESS_ANG_SPINNER            1245
#define IDC_DISP_UFLIP                  1246
#define IDC_TESS_ANG                    1246
#define IDC_DISP_FIT                    1247
#define IDC_TESS_EDGE_SPINNER           1247
#define IDC_DISP_CENTER                 1248
#define IDC_TESS_EDGE                   1248
#define IDC_DISP_BITMAPFIT              1249
#define IDC_DISP_NORMALALIGN            1250
#define IDC_DISP_RESET                  1251
#define IDC_DISP_ACQUIRE                1252
#define IDC_PATCH                       1254
#define IDC_MESH                        1255
#define IDC_FILTVERTS                   1255
#define IDC_FILTVECS                    1256
#define IDC_GENMAPPING                  1257
#define IDC_EM_VERT_SELBYCOLOR          1257
#define IDC_FLIPNORMALS                 1258
#define IDC_SPLINE_VERT_COUNT           1259
#define IDC_GEN_MATIDS                  1259
#define IDC_USE_SHAPE_IDS               1260
#define IDC_RESETTM_SELECTED            1261
#define IDC_SMOOTH                      1261
#define IDC_AFR_FALLOFF                 1262
#define IDC_AFR_FALLOFFSPIN             1263
#define IDC_AFR_BACKFACE                1264
#define IDC_EXT_SCALE                   1264
#define IDC_EXT_SCALESPIN               1265
#define IDC_AFR_PINCH                   1266
#define IDC_TENSIONSPIN                 1266
#define IDC_AFR_PINCHSPIN               1267
#define IDC_ITERATIONS1                 1267
#define IDC_AFR_BUBBLE                  1268
#define IDC_ITERATIONS2                 1268
#define IDC_AFR_BUBBLESPIN              1269
#define IDC_ITERATIONS3                 1269
#define IDC_ITERATIONS4                 1270
#define IDC_EXT_CENTER                  1271
#define IDC_EXT_AMOUNT                  1272
#define IDC_EXT_AMOUNTSPIN              1273
#define IDC_DISP_VIEWALIGN              1274
#define IDC_DISP_FITREGION              1275
#define IDS_MIRROR_X                    1277
#define IDS_MIRROR_Y                    1278
#define IDS_MIRROR_Z                    1279
#define IDS_MIRROR_XY                   1280
#define IDS_MIRROR_YZ                   1281
#define IDS_MIRROR_ZX                   1282
#define IDC_MIRROR_COPY                 1283
#define IDC_MIRROR_OFFSET               1284
#define IDC_MIRROR_OFFSETSPIN           1285
#define IDC_UNWRAP_EDIT                 1287
#define IDC_UNWARP_TOOLBAR              1288
#define IDC_UNWRAP_RESET                1288
#define IDC_GRID                        1288
#define IDC_TREE                        1289
#define IDC_UNWRAP_VERTS_TOOLBAR        1289
#define IDC_UNWRAP_SAVE                 1289
#define IDC_UNWRAP_VIEW                 1290
#define IDC_UNWRAP_LOAD                 1290
#define IDC_UNWRAP_LINECOLOR            1291
#define IDC_UNWRAP_OPTION_TOOLBAR       1291
#define IDC_UNWARP_VIEW_TOOLBAR         1292
#define IDC_UNWRAP_SELCOLOR             1293
#define IDC_UNWRAP_FILTER_TOOLBAR       1293
#define IDC_UNWRAP_CONSTANTUPDATE       1294
#define IDC_UNWRAP_WIDTH                1295
#define IDC_UNWRAP_WIDTHSPIN            1296
#define IDC_UNWRAP_HEIGHT               1297
#define IDC_UNWRAP_HEIGHTSPIN           1298
#define IDC_UNWRAP_DEFAULTS             1299
#define IDC_UNWRAP_SELECT_VERTS         1300
#define IDC_TESS_VIEW                   1301
#define IDC_UNWRAP_MIDPIXEL_SNAP        1301
#define IDC_TESS_RENDERER               1302
#define IDC_UNWRAP_WELDTHRESH           1302
#define IDC_TESS_SET                    1303
#define IDC_UNWRAP_WELDTHRESHSPIN       1303
#define IDC_UNWRAP_USEBITMAPRES         1304
#define IDC_OPT_UPDATE                  1305
#define IDC_TESS_PARAM                  1305
#define IDC_OPT_MANUPDATE               1306
#define IDC_TESS_SPATIAL                1306
#define IDC_TESS_CURV                   1307
#define IDC_DISP_CAP                    1307
#define IDC_TESS_VIEW_DEP               1308
#define IDC_SHOW_INTERIOR_FACES         1309
#define IDC_MAP_CHAN1                   1310
#define IDC_LENGTH_LABEL                1311
#define IDC_MAP_CHAN2                   1312
#define IDC_WIDTH_LABEL                 1313
#define IDC_HEIGHT_LABEL                1314
#define IDC_MAP_X                       1315
#define IDC_MAP_Y                       1316
#define IDC_EM_VERT_SELCOLOR            1316
#define IDC_MAP_Z                       1317
#define IDC_DISP_LENGTH                 1318
#define IDC_DISP_LENGTHSPIN             1319
#define IDC_DISP_WIDTH                  1320
#define IDC_DISP_WIDTHSPIN              1321
#define IDC_DISP_HEIGHT                 1322
#define IDC_DISP_HEIGHTSPIN             1323
#define IDC_DISP_X                      1324
#define IDC_DISP_Y                      1325
#define IDC_DISP_Z                      1326
#define IDC_NURBS                       1327
#define IDC_UNWRAP_U                    1328
#define IDC_ADVANCED                    1328
#define IDC_EM_EXPLODE                  1328
#define IDC_ADVANCED_PARAMETERS         1328
#define IDC_UNWRAP_USPIN                1329
#define IDC_EM_CREATE                   1329
#define IDC_UNWRAP_ULABEL               1330
#define IDC_EM_DETACH                   1330
#define IDC_UNWRAP_V                    1331
#define IDC_FALLOFF_ON                  1331
#define IDC_UNWRAP_VSPIN                1332
#define IDC_TESS_REGULAR                1332
#define IDC_EM_WELDTOVERT               1332
#define IDC_UNWRAP_VLABEL               1333
#define IDC_EM_SELTYPE                  1333
#define IDC_UNWRAP_W                    1334
#define IDC_EM_SEL_BYVERT               1334
#define IDC_EM_VERT_SELR                1334
#define IDC_UNWRAP_WSPIN                1335
#define IDC_EM_PLANAR                   1335
#define IDC_EM_SMOOTH_THRESHSPIN        1335
#define IDC_UNWRAP_WLABEL               1336
#define IDC_EM_PLANARSPINNER            1336
#define IDC_EM_SMOOTH_THRESH            1336
#define IDC_EM_MAKEPLANAR               1337
#define IDC_EM_NORMAL_SCALESPIN         1337
#define IDC_UNWRAP_STR                  1337
#define IDC_EM_EXTRUDE                  1338
#define IDC_EM_NORMAL_SCALE             1338
#define IDC_UNWRAP_STRSPIN              1338
#define IDC_EP_EXTRUDE                  1338
#define IDC_EM_EXTRUDEAMOUNT            1339
#define IDC_EM_MAT_IDSPIN               1339
#define IDC_EP_EXTRUDEAMOUNT            1339
#define IDC_EM_EXTRUDESPINNER           1340
#define IDC_EM_MAT_ID                   1340
#define IDC_EP_EXTRUDESPINNER           1340
#define IDC_EM_AFFECT_REGION            1341
#define IDC_EM_TESSELLATE               1342
#define IDC_EM_TENSION                  1343
#define IDC_EM_E_DIST                   1345
#define IDC_EM_TENSIONSPINNER           1346
#define IDC_EM_COLLAPSE                 1347
#define IDC_EM_E_ITER                   1348
#define IDC_EM_HIDE                     1349
#define IDC_EM_TES_EDGE                 1349
#define IDC_EM_UNHIDEALL                1350
#define IDC_EM_TES_CENTER               1350
#define IDC_EM_ANGLETHRESHSPIN          1351
#define IDC_EM_COPYNS                   1351
#define IDC_EM_NORMAL_SHOW              1352
#define IDC_EM_PASTENS                  1352
#define IDC_EM_OUTLINEAMOUNT            1352
#define IDC_EP_OUTLINEAMOUNT            1352
#define IDC_EM_NORMAL_FLIP              1353
#define IDC_EM_OUTLINESPINNER           1353
#define IDC_EP_OUTLINESPINNER           1353
#define IDC_EM_NORMAL_UNIFY             1354
#define IDC_EM_SELECT_OPEN              1355
#define IDC_EM_VERT_COLOR               1355
#define IDC_EM_SELECT_BYID              1356
#define IDC_EM_SELECTBYSMOOTH           1357
#define IDC_EM_SMOOTH_AUTO              1358
#define IDC_EM_DETACH_NAME              1359
#define IDC_EM_DETACH_NAMELABEL         1360
#define IDC_MS_IGNORE_BACKFACES         1361
#define IDC_MS_IGNORE_VISEDGE           1362
#define IDC_MS_SEL_BYVERT               1363
#define IDC_MS_PLANAR_TEXT              1364
#define IDC_MS_PLANAR                   1365
#define IDC_MS_PLANARSPINNER            1366
#define IDC_MS_GETVERT                  1367
#define IDC_MS_GETFACE                  1368
#define IDC_MS_GETEDGE                  1369
#define IDC_MS_COPYNS                   1370
#define IDC_MS_PASTENS                  1371
#define IDC_MS_NUMBER_SEL               1372
#define IDC_MS_SELTYPE                  1373
#define IDC_MS_MATID                    1374
#define IDC_MS_MATIDSPIN                1375
#define IDC_MS_SELBYMAT                 1376
#define IDC_EM_EXP_OBJECTS              1377
#define IDC_MS_SELBYMAT_BOX             1377
#define IDC_EM_EXP_ELEMENTS             1378
#define IDC_MS_SELBYMAT_TEXT            1378
#define IDC_EM_OBJ_ATTACH               1379
#define IDC_MS_SELOPEN                  1379
#define IDC_MS_AR_USE                   1380
#define IDC_FALLOFF_LABEL               1381
#define IDC_PINCH_LABEL                 1382
#define IDC_BUBBLE_LABEL                1383
#define IDC_DISP                        1386
#define IDC_UNWRAP_APPLY                1390
#define IDC_FOO                         1391
#define IDC_UNWRAP_ALIGN_TO_NORMAL      1391
#define IDC_MAP_TEXMAP                  1392
#define IDC_UNWRAP_FIT                  1392
#define IDC_MAP_VERTCOL                 1393
#define IDC_MAP_CHAN                    1394
#define IDC_MAP_CHAN_SPIN               1395
#define IDC_VS_MATID                    1396
#define IDC_VS_MATIDSPIN                1397
#define IDC_VS_SMG                      1398
#define IDC_VS_SMGSPIN                  1399
#define IDC_DELAUNAY                    1416
#define IDC_PRESET3                     1425
#define IDC_PRESET2                     1427
#define IDC_PRESET1                     1429
#define IDC_EM_W_THR                    1431
#define IDC_ES_DELETE                   1434
#define IDC_EM_T_THR                    1435
#define IDC_NS_COPY                     1435
#define IDC_EM_VERT_SELB                1436
#define IDC_NS_PASTE                    1436
#define IDC_ES_BIND                     1436
#define IDC_ES_REFINE                   1437
#define IDC_ES_DETACH                   1438
#define IDC_ES_CONNECT                  1439
#define IDC_ES_ATTACH                   1440
#define IDC_ES_ATTACHREORIENT           1441
#define IDC_ES_WELD                     1442
#define IDC_ES_WELDTHRESH               1443
#define IDC_ES_THRESHSPINNER            1444
#define IDC_ES_DETACHREORIENT           1445
#define IDC_ES_DETACHCOPY               1446
#define IDC_ES_UNBIND                   1447
#define IDC_ES_HIDE                     1448
#define IDC_EM_DIVIDE                   1449
#define IDC_ES_CROSSTHRESH              1449
#define IDC_EM_ALIGNVIEW                1450
#define IDC_ES_CROSSTHRESHSPINNER       1450
#define IDC_TESS_NORMALS                1451
#define IDC_ES_UNHIDE                   1451
#define IDC_ES_CYCLE                    1452
#define IDC_TO_SPLINES                  1480
#define IDC_EM_TURN                     1481
#define IDC_TO_OBJECTS                  1481
#define IDC_EM_EDGE_VIS                 1482
#define IDC_EM_EDGE_INVIS               1483
#define IDC_EM_EDGE_AUTO                1484
#define IDC_SELECTAREA                  1484
#define IDC_SELECTAREA_SPIN             1485
#define IDC_ACQUIRE_REL                 1552
#define IDC_ACQUIRE_ABS                 1553
#define IDC_EM_WELD                     1584
#define IDC_EM_W_THR_SPIN               1685
#define IDC_SMOOTH_GRP1                 1701
#define IDC_SMOOTH_GRP2                 1702
#define IDC_SMOOTH_GRP3                 1703
#define IDC_SMOOTH_GRP4                 1704
#define IDC_SMOOTH_GRP5                 1705
#define IDC_SMOOTH_GRP6                 1706
#define IDC_SMOOTH_GRP7                 1707
#define IDC_SMOOTH_GRP8                 1708
#define IDC_SMOOTH_GRP9                 1709
#define IDC_SMOOTH_GRP10                1710
#define IDC_SMOOTH_GRP11                1711
#define IDC_SMOOTH_GRP12                1712
#define IDC_SMOOTH_GRP13                1713
#define IDC_SMOOTH_GRP14                1714
#define IDC_SMOOTH_GRP15                1715
#define IDC_SMOOTH_GRP16                1716
#define IDC_SMOOTH_GRP17                1717
#define IDC_SMOOTH_GRP18                1718
#define IDC_SMOOTH_GRP19                1719
#define IDC_SMOOTH_GRP20                1720
#define IDC_SMOOTH_GRP21                1721
#define IDC_SMOOTH_GRP22                1722
#define IDC_SMOOTH_GRP23                1723
#define IDC_SMOOTH_GRP24                1724
#define IDC_SMOOTH_GRP25                1725
#define IDC_SMOOTH_GRP26                1726
#define IDC_SMOOTH_GRP27                1727
#define IDC_SMOOTH_GRP28                1728
#define IDC_SMOOTH_GRP29                1729
#define IDC_SMOOTH_GRP30                1730
#define IDC_SMOOTH_GRP31                1731
#define IDC_SMOOTH_GRP32                1732
#define IDC_EP_HOOPSON                  1734
#define IDC_EM_CLONE_NAME               1735
#define IDC_EM_EXPLODE_NAMELABEL        1736
#define IDC_ES_EXPLODE_NAMELABEL        1736
#define IDC_EM_EXPLODE_NAME             1737
#define IDC_ES_EXPLODE_NAME             1737
#define IDC_EM_BEVEL                    1738
#define IDC_EP_BEVEL                    1738
#define IDC_EM_AE_SET                   1739
#define IDC_EM_AR_BACK                  1740
#define IDC_EM_AE_CLEAR                 1741
#define IDC_RADIO1                      1741
#define IDC_EM_AE_SETCLEAR              1742
#define IDC_RADIO2                      1742
#define IDC_CUSTOM                      1742
#define IDC_RADIO3                      1743
#define IDC_UPDATE                      1743
#define IDC_RADIO4                      1744
#define IDC_SPLITMESH                   1744
#define IDC_NURBS_TXT_SRF               1746
#define IDC_EM_WEIGHT                   1749
#define IDC_EM_WEIGHTSPIN               1750
#define IDC_EM_WEIGHT_LABEL             1751
#define IDC_DISP_CHAN                   1752
#define IDC_DISP_CHAN_SPIN              1753
#define IDC_DISP_TEXMAP                 1754
#define IDC_DISP_VERTCOL                1755
#define IDC_TESS_RECALC                 3012
#define IDC_TESS_UPDATE_RENDER          3016
#define IDC_TESS_UPDATE_MANUAL          3017
#define IDC_TESS_UPDATE_ALWAYS          3018
#define IDC_BOOLUNION                   5010
#define IDC_BOOLSUBTRACTION             5011
#define IDC_BOOLINTERSECTION            5012
#define IDC_CROSSINSERTCUR              5016
#define IDC_FILLETCUR                   5017
#define IDC_CHAMFERCUR                  5018
#define IDS_DS_MOVE2                    10004
#define IDS_DS_SELECT                   10007
#define IDS_DS_CREATE                   10008
#define IDS_RB_EXTRUDE                  30001
#define IDS_RB_TAPER                    30003
#define IDS_RB_OBJECT                   30004
#define IDS_RB_EDITMESH                 30009
#define IDS_RB_VERTEX                   30011
#define IDS_RB_FACE                     30012
#define IDS_RB_EDGE                     30013
#define IDS_RB_CENTER                   30014
#define IDS_RB_APPARATUS                30015
#define IDS_RB_EDITMESH_CLASS           30022
#define IDS_RB_PARAMETERS               30028
#define IDS_RB_ANGLE                    30029
#define IDS_RB_DIRECTION                30030
#define IDS_RB_AMOUNT                   30031
#define IDS_RB_AMOUNT2                  30032
#define IDS_RB_CURVITURE                30033
#define IDS_RB_AMPLITUDE                30034
#define IDS_RB_WAVELEN                  30035
#define IDS_RB_PHASE                    30036
#define IDS_RB_DECAY                    30037
#define IDS_RB_FLEXIBILITY              30038
#define IDS_RB_WIDTH                    30039
#define IDS_RB_HEIGHT                   30040
#define IDS_DB_EXTRUDE                  30041
#define IDS_RB_NONE                     30137
#define IDS_RB_RIPPLE                   30155
#define IDS_RB_RIPPLE_BINDING           30156
#define IDS_RB_DELETEVERT               30211
#define IDS_RB_DELETEFACE               30212
#define IDS_RB_ADDVERTS                 30213
#define IDS_RB_ATTACHOBJECT             30214
#define IDS_RB_FACECOLLAPSE             30215
#define IDS_RB_MAKEPLANAR               30216
#define IDS_RB_BUILDFACE                30217
#define IDS_RB_HIDEFACE                 30218
#define IDS_RB_UNHIDEALLFACES           30219
#define IDS_RB_EDGEVISIBLE              30220
#define IDS_RB_EDGEINVISIBLE            30221
#define IDS_RB_AUTOEDGE                 30222
#define IDS_RB_EDGEDIVIDE               30223
#define IDS_RB_EDGETURN                 30224
#define IDS_RB_DELETEEDGE               30225
#define IDS_RB_COLLAPSEEDGE             30226
#define IDS_RB_CLONE                    30227
#define IDS_RB_TESSELLATE               30228
#define IDS_RB_DELETEISOLATED           30229
#define IDS_PW_PLANAR                   30230
#define IDS_PW_LATTICE                  30231
#define IDS_RB_DEFDEFORMATIONS          30270
#define IDS_RB_DEFEDIT                  30271
#define IDS_RB_NODEXFORM                30276
#define IDS_RB_NODEXFORM_CLASS          30277
#define IDS_RB_XFORM_CLASS              30278
#define IDS_RB_EDITSURFACE              30279
#define IDS_RB_SETSMOOTHGROUP           30280
#define IDS_RB_ASSIGNMATID              30281
#define IDS_RB_FLIPNORMALS              30282
#define IDS_RB_UNIFYNORMALS             30283
#define IDS_RB_AUTOSMOOTH               30284
#define IDS_RB_SELECTBYMATID            30285
#define IDS_RB_SELECTBYSMOOTH           30286
#define IDS_RB_SOT                      30287
#define IDS_RB_DEFLECTOR_CLASS          30288
#define IDS_RB_HIDEVERT                 30294
#define IDS_RB_DEFSURFACE               30298
#define IDS_RB_SCALE                    30377
#define IDS_RB_NOISE                    30411
#define IDS_RB_ROTATION2                30521
#define IDS_RB_TWIST                    30522
#define IDS_RB_BENDMOD                  30543
#define IDS_RB_BEND2                    30544
#define IDS_RB_FROM                     30545
#define IDS_RB_TO                       30546
#define IDS_RB_BOMBOBJECT               30547
#define IDS_RB_BOMB                     30548
#define IDS_RB_BOMBMOD                  30549
#define IDS_RB_BOMBBINDING              30550
#define IDS_RB_CLUSTNODEMOD             30551
#define IDS_RB_XFORM                    30552
#define IDS_RB_DEFLECTOR                30553
#define IDS_RB_DEFLECTMOD               30554
#define IDS_RB_DEFLECTORBINDING         30555
#define IDS_RB_BOUNCE                   30556
#define IDS_RB_DISPMOD                  30557
#define IDS_RB_DISPLACE                 30558
#define IDS_RB_DISPLACEMOD              30559
#define IDS_RB_DISPLACEBINDING          30560
#define IDS_RB_SELECTDISPIMAGE          30561
#define IDS_RB_SELECTIMAGE              30562
#define IDS_RB_UTILE                    30563
#define IDS_RB_VTILE                    30564
#define IDS_RB_WTILE                    30565
#define IDS_RB_BLUR                     30566
#define IDS_RB_DOCREATENEWOBJECT        30567
#define IDS_RB_EDITMESH2                30568
#define IDS_RB_GRAVITY                  30569
#define IDS_RB_WIND                     30570
#define IDS_RB_GRAVITYMOD               30571
#define IDS_RB_GRAVITYBINDING           30572
#define IDS_RB_WINDMOD                  30573
#define IDS_RB_WINDBINDING              30574
#define IDS_RB_TURBULENCE               30575
#define IDS_RB_FREQUENCY                30576
#define IDS_RB_MAPMOD                   30577
#define IDS_RB_UVWMAPPING               30578
#define IDS_RB_UVWMAP                   30579
#define IDS_RB_NOISEMOD                 30580
#define IDS_RB_SEED                     30581
#define IDS_RB_FRACTAL                  30582
#define IDS_RB_ROUGH                    30583
#define IDS_RB_ITERATIONS               30584
#define IDS_RB_OPTMOD                   30585
#define IDS_RB_OPTIMIZE                 30586
#define IDS_RB_FACETHRESHL1             30587
#define IDS_RB_FACETHRESHL2             30588
#define IDS_RB_EDGETHRESHL1             30589
#define IDS_RB_EDGETHRESHL2             30590
#define IDS_RB_BIASL1                   30591
#define IDS_RB_BIASL2                   30592
#define IDS_RB_EDITMESHMOD              30593
#define IDS_RB_TWISTMOD                 30594
#define IDS_RB_TWIST2                   30595
#define IDS_RB_TWISTPLUGIN              30596
#define IDS_RB_BIAS                     30597
#define IDS_RB_INCORRECTSTRING          30598
#define IDS_RB_AUTHORIZATION            30599
#define IDS_RB_TAPERMOD                 30600
#define IDS_RB_SYMMETRY                 30601
#define IDS_RB_MATMOD                   30602
#define IDS_RB_MATERIAL3                30603
#define IDS_RB_MATERIALID               30604
#define IDS_RB_MATERIAL4                30605
#define IDS_RB_MATERIALID2              30606
#define IDS_RB_SMOOTHMOD                30607
#define IDS_RB_NORMALMOD                30608
#define IDS_RB_SKEWMOD                  30609
#define IDS_RB_SKEW                     30610
#define IDS_RB_SMOOTH2                  30611
#define IDS_RB_WAVE                     30612
#define IDS_RB_WAVEMOD                  30613
#define IDS_RB_WAVEBINDING              30614
#define IDS_RB_AMPLITUDE1               30615
#define IDS_RB_AMPLITUDE2               30616
#define IDS_RB_VOLSELECT                30617
#define IDS_RB_THRESHOLD                30618
#define IDS_RB_GIZMO                    30619
#define IDS_RB_NORMAL                   30620
#define IDS_RB_BEND_CLASS               30621
#define IDS_RB_DISPLACE_CLASS           30622
#define IDS_RB_VOLSELECT_CLASS          30623
#define IDS_RB_SKEW_CLASS               30624
#define IDS_RB_MATERIAL3_CLASS          30625
#define IDS_RB_SMOOTH2_CLASS            30626
#define IDS_RB_NORMAL_CLASS             30627
#define IDS_TH_LATHE_CLASS              30628
#define IDS_RB_EXPLODE                  30629
#define IDS_RB_COLLAPSE                 30630
#define IDS_RB_WELDVERTS                30631
#define IDS_RB_TAPER_CLASS              30632
#define IDS_RB_TWIST2_CLASS             30633
#define IDS_RB_TWIST_CLASS              30634
#define IDS_RB_BOMBOBJECT_CLASS         30635
#define IDS_RB_BOMB_CLASS               30636
#define IDS_RB_RIPPLE_CLASS             30637
#define IDS_RB_WAVE_CLASS               30638
#define IDS_RB_STRENGTH2                30646
#define IDS_DS_MOVE                     30647
#define IDS_RB_FACESEL                  30651
#define IDS_RB_POLYGONSEL               30652
#define IDS_RB_ELEMENTSEL               30653
#define IDS_RB_NOVERTSTOWELD            30680
#define IDS_RB_CHAOS                    30681
#define IDS_RB_DETONATION               30682
#define IDS_RB_BOMBPARAMS               30683
#define IDS_RB_EDITMESHTITLE            30684
#define IDS_RB_DUPFACEWARNING           30685
#define IDS_RB_NUMVERTSELP              30699
#define IDS_RB_NUMFACESELP              30701
#define IDS_RB_NUMEDGESELP              30703
#define IDS_EM_BEVEL                    30738
#define IDS_EM_OUTLINE                  30739
#define IDS_ADV_DISP_APPROX_WARNING_TITLE 30740
#define IDS_ADV_DISP_APPROX_WARNING     30741
#define ID_UNWRAP_MOVE                  40002
#define ID_UNWRAP_ROTATE                40003
#define ID_UNWRAP_SCALE                 40004
#define ID_UNWRAP                       40005
#define ID_UNWRAP_BREAK                 40006
#define ID_UNWRAP_WELD                  40007
#define ID_UNWRAP_WELDSELECTED          40008
#define ID_UNWRAP_PAN                   40010
#define ID_UNWRAP_ZOOM                  40011
#define ID_UNWRAP_ZOOMREGION            40012
#define ID_UNWRAP_EXTENT                40013
#define ID_UNWRAP_MIRROR                40014
#define IDS_TH_EDITSPLINE               40025
#define IDS_TH_EDITSEGMENT              40026
#define IDS_TH_EDITVERTEX               40027
#define IDS_TH_SPLINE                   40028
#define IDS_TH_SEGMENT                  40029
#define IDS_TH_VERTEX                   40030
#define IDS_TH_EDITOBJECT               40031
#define IDS_TH_EDITPATCH_CLASS          40032
#define IDS_TH_EDITSPLINE_CLASS         40033
#define IDS_RB_EXTRUDE_CLASS            40034
#define IDS_RB_GRAVITY_CLASS            40035
#define IDS_RB_WIND_CLASS               40036
#define IDS_RB_UVWMAP_CLASS             40037
#define IDS_RB_NOISE_CLASS              40038
#define IDS_TH_CLOSESPLINE              40039
#define IDS_RB_OPTIMIZE_CLASS           40040
#define IDS_TH_DELETESPLINE             40041
#define IDS_TH_NOVALIDSPLINESSEL        40042
#define IDS_TH_NOSPLINESSEL             40043
#define IDS_TH_VERTBREAK                40044
#define IDS_TH_NOVALIDVERTSSEL          40045
#define IDS_TH_SEGDELETE                40046
#define IDS_TH_NOSEGSSEL                40047
#define IDS_TH_DETACHSPLINE             40048
#define IDS_TH_OUTLINE                  40049
#define IDS_TH_SEGDETACH                40050
#define IDS_TH_SHAPE                    40051
#define IDS_TH_REFINE                   40052
#define IDS_TH_SEGBREAK                 40053
#define IDS_TH_VERTCONNECT              40054
#define IDS_TH_VERTINSERT               40055
#define IDS_TH_VERTWELD                 40056
#define IDS_TH_NOWELDPERFORMED          40057
#define IDS_TH_SELECTONESPLINE          40058
#define IDS_TH_MORETHANONESPLINESEL     40059
#define IDS_TH_BOOLEAN                  40060
#define IDS_TH_UNION                    40061
#define IDS_TH_SUBTRACTION              40062
#define IDS_TH_INTERSECTION             40063
#define IDS_TH_BOOLWELDFAILED           40064
#define IDS_TH_COINCIDENTVERTEX         40065
#define IDS_TH_SPLINESMUSTOVERLAP       40066
#define IDS_TH_SELECTCLOSEDSPLINE       40067
#define IDS_TH_SPLINESELFINTERSECTS     40068
#define IDS_TH_ATTACH                   40069
#define IDS_TH_CANHAVEONLYONESHAPE      40070
#define IDS_TH_NOVERTSSEL               40071
#define IDS_TH_VERTCHANGE               40072
#define IDS_TH_SMOOTH                   40073
#define IDS_TH_CORNER                   40074
#define IDS_RB_RESETXFORM_CLASS         40075
#define IDS_TH_BEZIER                   40076
#define IDS_TH_SEGCHANGE                40077
#define IDS_TH_CURVE                    40078
#define IDS_TH_LINE                     40079
#define IDS_TH_VERTDELETE               40080
#define IDS_TH_BEZIERCORNER             40081
#define IDS_TH_AMOUNT                   40082
#define IDS_TH_EDITPATCH                40083
#define IDS_TH_PATCH                    40084
#define IDS_TH_SEGMENTS                 40085
#define IDS_TH_PATCHDELETE              40086
#define IDS_TH_NOPATCHESSEL             40087
#define IDS_TH_MAKEFIRST                40160
#define IDS_TH_EDITEDGE                 40170
#define IDS_TH_EDGE                     40171
#define IDS_TH_AUTOINTERIOR             40172
#define IDS_TH_MANUALINTERIOR           40173
#define IDS_TH_NOVALIDEDGESSEL          40174
#define IDS_TH_PATCHADD                 40175
#define IDS_TH_EDGESUBDIVIDE            40176
#define IDS_TH_PATCHSUBDIVIDE           40177
#define IDS_TH_CREATELINE               40178
#define IDS_TH_MIRROR_H                 40179
#define IDS_TH_MIRROR_V                 40180
#define IDS_TH_MIRROR_BOTH              40181
#define IDS_TH_MIRROR                   40182
#define IDS_TH_PATCHCHANGE              40186
#define IDS_TH_COPLANAR                 40187
#define IDS_TH_POLYCONNECT              40190
#define IDS_TH_CONNECT_COINCIDENT       40191
#define IDS_TH_CANHAVEONLYONEPATCH      40192
#define IDS_TH_DETACHPATCH              40193
#define IDS_TH_COPY_SPLINE              40196
#define IDS_TH_COPY_SEGMENT             40197
#define IDS_TH_SPLINECHANGE             40201
#define IDS_TH_MIRRORSPLINE             40279
#define IDS_TH_DEGREES                  40308
#define IDS_TH_AXIS                     40309
#define IDS_TH_LATHE                    40310
#define IDS_TH_VERTWELDRESULT           40316
#define IDS_RB_RESETXFORM               40317
#define IDS_RB_AFRMOD                   40318
#define IDS_RB_STARTPOINT               40319
#define IDS_RB_ENDPOINT                 40320
#define IDS_RB_AFRPOINTS                40321
#define IDS_AFR_FALLOFF                 40322
#define IDS_AFR_PINCH                   40323
#define IDS_AFR_BUBBLE                  40324
#define IDS_RB_TESSMOD                  40325
#define IDS_TESS_TENSION                40326
#define IDS_RB_DELETEMOD                40327
#define IDS_RB_MESHSELMOD               40328
#define IDS_RB_FACEEXTRUDEMOD           40329
#define IDS_RB_EXTRUDECENT              40330
#define IDS_EXT_AMOUNT                  40331
#define IDS_EXT_SCALE                   40332
#define IDS_RB_UVWXFORMMOD              40333
#define IDS_RB_UOFFSET                  40334
#define IDS_RB_VOFFSET                  40335
#define IDS_RB_WOFFSET                  40336
#define IDS_RB_MAXEDGE1                 40337
#define IDS_RB_MAXEDGE2                 40338
#define IDS_RB_CENTERPOINT              40339
#define IDS_RB_MIRRORMOD                40340
#define IDS_RB_MIRRORCENTER             40341
#define IDS_RB_OFFSET                   40342
#define IDS_RB_SELVERTEX                40343
#define IDS_RB_SELFACE                  40344
#define IDS_RB_SELEDGE                  40345
#define IDS_RB_SELOBJECT                40346
#define IDS_RB_UNWRAPMOD                40347
#define IDS_AP_SDELETEMOD               40348
#define IDS_RB_RESETUVWS                40349
#define IDS_RB_SETCHANNEL               40350
#define IDS_RB_SHOULDRESET              40351
#define IDS_RB_RESETUNWRAPUVWS          40352
#define IDS_RB_LENGTH                   40353
#define IDS_SA_TRIANGLE                 40354
#define IDS_SA_POLYGON                  40355
#define IDS_SA_TRI_POLY_RESTORE         40356
#define IDS_RB_SPIN                     40357
#define IDS_RB_FALLOFF                  40358
#define IDS_TH_PATCHMTLCHANGE           40359
#define IDS_RB_MOVE                     40360
#define IDS_RB_ROTATE                   40361
#define IDS_RB_PAN                      40362
#define IDS_RB_ZOOM                     40363
#define IDS_RB_PICKMAP                  40364
#define IDS_RB_UPDATE                   40365
#define IDS_RB_ZOOMEXT                  40366
#define IDS_RB_ZOOMREG                  40367
#define IDS_RB_UVW                      40368
#define IDS_RB_PROP                     40369
#define IDS_RB_SHOWMAP                  40370
#define IDS_RB_DEFMODS                  40371
#define SPACEWARPS_FOR_BOTH             40372
#define SPACEWARPS_FOR_PARTICLES        40373
#define SW_TEST                         40374
#define IDS_EM_SELECTION                40375
#define IDS_EM_POLY                     40376
#define IDS_EM_ELEMENT                  40377
#define IDS_EM_OBJECT_SEL               40378
#define IDS_EM_WHICHVERTSEL             40379
#define IDS_EM_WHICHEDGESEL             40380
#define IDS_EM_WHICHFACESEL             40381
#define IDS_EM_EDIT_GEOM                40382
#define IDS_EM_SHAPE                    40383
#define IDS_EM_SELBYCOLOR               40384
#define IDS_EM_VERTEXCOLOR              40385
#define IDS_EM_SETVERTCOLOR             40386
#define IDS_EM_CREATE_MESH              40387
#define IDS_EM_NEWOBJECTNAME            40388
#define IDS_MS_PARAMS                   40389
#define IDS_EM_FACE_DIVIDE              40390
#define IDS_EM_SELECT_OPEN              40391
#define IDS_EM_CREATECURVE              40392
#define IDS_EM_DELETE_ISOVERTS          40393
#define IDS_MS_AFFECTREGION             40394
#define IDS_EM_ALIGN                    40395
#define IDS_EM_VERT_BREAK               40396
#define IDS_EM_SLICE                    40397
#define IDS_EM_CUT                      40398
#define IDS_EM_DETACHFACES              40399
#define IDS_EM_DETACHVERTS              40400
#define IDS_EM_INHERIT_MATERIAL         40401
#define IDS_EM_COMBINE_MATERIALS        40402
#define IDS_EM_NOEDGESSELECTED          40403
#define IDS_UVWX_CHANNEL                40404
#define IDS_UVWX_MAPCHANNEL             40405
#define IDS_UVWX_UFLIP                  40406
#define IDS_UVWX_VFLIP                  40407
#define IDS_UVWX_WFLIP                  40408
#define IDS_EM_FLIP_NORMAL              40409
#define IDS_TH_SPLSEGSEL                40410
#define IDS_TH_NUMSEGSELP               40411
#define IDS_TH_NUMSPLINESEL             40412
#define IDS_TH_NUMSPLINESELP            40413
#define IDS_TH_SPLVERTSEL               40414
#define IDS_TH_SPLINE_VERT_COUNT        40415
#define IDS_TH_SELECTION                40416
#define IDS_TH_OBJECT_SEL               40417
#define IDS_TH_NUMVERTSEL               40418
#define IDS_TH_NUMVERTSELP              40419
#define IDS_TH_GEOMETRY                 40420
#define IDS_TH_MULTIATTACH              40421
#define IDS_TH_NUMEDGESEL               40422
#define IDS_TH_NUMEDGESELP              40423
#define IDS_TH_NUMPATCHSEL              40424
#define IDS_TH_NUMPATCHSELP             40425
#define IDS_MS_USE_AR                   40426
#define IDS_TH_EXPLODE                  40427
#define IDS_TH_DIVIDE_SEGMENT           40428
#define IDS_TH_REVERSE_SPLINE           40429
#define IDS_TH_MULTIPLE_NODES           40430
#define IDS_TH_CROSS_INSERT             40431
#define IDS_TH_CROSS_NOT_IN_THRESHOLD   40432
#define IDS_TH_EDGEDELETE               40433
#define IDS_TH_NOEDGESSEL               40434
#define IDS_TH_SEGMTLCHANGE             40435
#define IDS_CT_DISPAPPROX_CLASS         40436
#define IDS_CT_DISP_APPROX              40437
#define IDS_CT_DISP_APPROX_CHANGE       40438
#define IDS_CT_MESH_MESHER_CLASS        40439
#define IDS_CT_MESH_MESHER              40440
#define IDS_PW_NSPLINE                  40441
#define IDS_EM_CHAMFER                  40442
#define IDS_EM_BREAK                    40445
#define IDS_EM_DIVIDE                   40446
#define IDS_TH_OPEN                     40447
#define IDS_TH_CLOSED                   40448
#define IDS_EM_ATTACH_LIST              40449
#define IDS_EM_DETACH                   40450
#define IDS_VS_MATID                    40451
#define IDS_VS_SMGROUP                  40452
#define IDS_TH_TRIM                     40453
#define IDS_TH_EXTEND                   40454
#define IDS_TH_FILLET                   40455
#define IDS_TH_CHAMFER                  40456
#define IDS_CHANGEWEIGHT                40457
#define IDS_TH_PASTE_NAMED_SEL          40458
#define IDS_TH_SURFACEPROPERTIES        40459
#define IDS_PW_MOVEH                    40460
#define IDS_PW_MOVEV                    40461
#define IDS_PW_SCALEH                   40462
#define IDS_PW_SCALEV                   40463
#define IDS_PW_WELDSELECTED             40464
#define IDS_PW_APPLYPLANAR              40465
#define IDS_PW_FACEMODE                 40466
#define IDS_PW_UVW_VERT_EDIT            40467
#define IDS_PW_UVW_EDIT                 40468
#define IDS_PW_SELECT_UVW               40469
#define IDS_PW_RESET_UNWRAP             40470
#define IDS_PW_SELECTRESTORE            40471
#define IDS_PW_PLANARMAP                40472
#define IDS_PW_POINT                    40473
#define IDS_PW_MOVE_UVW                 40474
#define IDS_PW_ID_ALLID                 40475
#define IDS_PW_UNWRAPVIEW               40476
#define IDS_PW_DELETE_SELECTED          40477
#define IDS_PW_HIDE_SELECTED            40478
#define IDS_PW_UNHIDEALL                40479
#define IDS_PW_FREEZE_SELECTED          40480
#define IDS_PW_UNFREEZEALL              40481
#define IDS_PW_ASSIGN_CONTROLLER        40482
#define IDS_PW_ROTATE_UVW               40483
#define IDS_PW_SCALE_UVW                40484
#define IDS_PW_WELD_UVW                 40485
#define IDS_PW_LINECOLOR                40486
#define IDS_RB_UNSUPPORTED_MAP_TYPE     40487
#define IDS_MM_ACQ_MAPPING              40488
#define IDS_PARAM_CHANGE                40489
#define IDS_PW_UNDO_RESET               40490
#define IDS_PW_UNDO_FIT                 40491
#define IDS_PW_MOUSE_CENTER             40492
#define IDS_PW_MOUSE_ADD                40493
#define IDS_PW_MOUSE_SUBTRACT           40494
#define IDS_PW_MOUSE_CONSTRAIN          40495
#define IDS_PW_MOUSE_SELECTTV           40496
#define IDS_PW_MOUSE_SELECTTRI          40497
#define IDS_PW_MOUSE_SELECTFACE         40498
#define IDS_PW_CYCLE                    40499
#define IDS_PW_FUSE                     40500
#define IDS_PW_AUTOFIT                  40501
#define IDS_PW_BIND                     40502
#define IDS_PW_UNBIND                   40503
#define IDS_PW_SURFACEERROR             40504
#define IDS_PW_VOLDATA                  40505
#define IDS_PW_ERROR                    40506
#define IDS_PW_INSTANCEERROR            40507
#define IDC_STATIC                      -1
#define IDC_EM_SEL_PT_TEXT              65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        174
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1756
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\selmod.cpp ===
/**********************************************************************
 *<
	FILE: selmod.cpp

	DESCRIPTION:  A volumetric selection modifier

	CREATED BY: Rolf Berteig

	HISTORY: 10/21/95


 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
//#include "iparamm.h"
#include "buildver.h"
#include "iparamm2.h"
#include "sctex.h"
#include "shape.h"
#include "simpobj.h"
#include "tvnode.h"

#define MAX_MATID	0xffff


#define REALLYBIGFLOAT	float( 1.0e+37F )

#define MCONTAINER_TVNODE_CLASS_ID Class_ID(0xe27e0f2b, 0x74fad492)
#define CONTAINER_TVNODE_CLASS_ID Class_ID(0xe27e0f2b, 0x74fad481)
#define SELNODE_TVNODE_CLASS_ID Class_ID(0xe27e0f2b, 0x74fad482)


class SelModData : public LocalModData {
	public:
		int id;
		INode *selfNode;
		SelModData()
			{
			selfNode = NULL;
			}
		SelModData(int i)
			{
			id = i;
			selfNode = NULL;
			}
		~SelModData()
			{
			}	
		LocalModData*	Clone()
			{
			SelModData* d = new SelModData();
			d->id = -1;
			d->selfNode = NULL;

			return d;

			}	


	};

class SelNodeNotify;

class SelMod : public Modifier {	
	public:
//		IParamBlock *pblock;		
		IParamBlock2 *pblock2,*pblock2_afr;		
		Control *tmControl;
		Control *posControl;
		DWORD flags;		

		Box3 mcBox;
		INode *SelfNode;
		SelNodeNotify *notify;
		Matrix3 ntm;
		Matrix3 otm;
		TimeValue rt;
		int map,channel;
		int matID;
		int smG;
		BOOL autoFit;
	
		int useAR, level, method,vol,selType,invert;
		float pinch, falloff, bubble;
		Texmap *tmap;
		Box3 bbox;
		ObjectState sos;
		ShapeObject *pathOb;
		PolyShape workShape;
		SimpleParticle *pobj;
		Mesh *msh;
		SCTex shadeContext;
		INode *targnode;

		Tab<Box2D> boxList;
		Tab<Box3> box3DList;
		Tab<Point3> normList;

		Tab<Point3> uvwList;

		ITrackViewNode *container;

		static IObjParam *ip; static SelMod* curMod;
//		static IParamMap *pmapParam, *pmapParam2;
		static MoveModBoxCMode *moveMode;
		static RotateModBoxCMode *rotMode;
		static UScaleModBoxCMode *uscaleMode;
		static NUScaleModBoxCMode *nuscaleMode;
		static SquashModBoxCMode *squashMode;		

		SelMod(BOOL create);
		~SelMod();
		void InitControl(ModContext &mc,TriObject *obj, TimeValue t);
		Matrix3 CompMatrix(TimeValue t,ModContext *mc, Matrix3 *ntm, BOOL scale=TRUE, BOOL offset=TRUE);
		void DoIcon(PolyLineProc& lp,BOOL sel);
		float PointInVolume(TimeValue t, Point3 pt,float u, float v, float w, Matrix3 &tm,Box3 box);
		float DistFromVolume(Point3 pt, Matrix3 &tm, Matrix3 &ctm, Box3 box);
		void SelectVertices (Mesh &mesh, Matrix3 &tm, Matrix3 &ctm, Box3 &box, TimeValue t);
		void SelectFaces (TimeValue t, Mesh &mesh, Matrix3 &tm,Box3 &box);

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_VOLSELECT_CLASS); }  
		virtual Class_ID ClassID() { return Class_ID(SELECTOSM_CLASS_ID,0);}
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);
		TCHAR *GetObjectName() {return GetString(IDS_RB_VOLSELECT);}
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		int SubNumToRefNum(int subNum);
		BOOL AssignController(Animatable *control,int subAnim);

		ChannelMask ChannelsUsed()  {return OBJ_CHANNELS;}		
		ChannelMask ChannelsChanged() {return SELECT_CHANNEL|SUBSEL_TYPE_CHANNEL|GEOM_CHANNEL|TOPO_CHANNEL;}
		Class_ID InputType() {return triObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);

		int NumRefs() {return 4;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		int NumSubs() {return 4;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

//		TimeValue t;


// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 2; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { if (i == 0) return pblock2; 
											else if (i == 1) return pblock2_afr; 
											else return NULL;
												} // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) {if (pblock2->ID() == id) return pblock2 ;
													 else if (pblock2_afr->ID() == id) return pblock2_afr ;
													else return  NULL; } // return id'd ParamBlock

		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);

		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);

		IOResult SaveLocalData(ISave *isave, LocalModData *pld);
		IOResult LoadLocalData(ILoad *iload, LocalModData **pld);


		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flagst, ModContext *mc);
		void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);			

		void Move(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
		void Rotate(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE);
		void Scale(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void ActivateSubobjSel(int level, XFormModes& modes);

		void EnableAffectRegion (TimeValue t);
		void DisableAffectRegion (TimeValue t);
		float GetPixel(TimeValue t, Point3 pt,float u, float v,float w);

		void RecurseDepth(float u1, float u2, float &fu,  ShapeObject *s,int Curve,int Piece, int &depth, Point3 fp);
		void PointToPiece(float &tempu,ShapeObject *s,int Curve,int Piece, int depth, Point3 fp);
		float SplineToPoint(Point3 p1, ShapeObject *s);
		float DistToFace(Point3 a, Point3 p1,Point3 p2,Point3 p3, int faceIndex);
		float LineToPoint(Point3 p1, Point3 l1, Point3 l2);
		void RecurseDepthB(float u1, float u2, float &fu,  BezierShape *s,int Curve,int Piece, int &depth, Point3 fp);
		void PointToPieceB(float &tempu,BezierShape *s,int Curve,int Piece, int depth, Point3 fp);
	};


static void DoBoxIcon(BOOL sel,float length, PolyLineProc& lp);
static void DoCylinderIcon(BOOL sel,float radius, float height, PolyLineProc& lp);
static void DoSphereIcon(BOOL sel,float radius, PolyLineProc& lp);

enum { vsel_params, vsel_afr };

enum { sel_level, sel_method, sel_type, sel_volume, sel_invert, sel_node, sel_texture, sel_map, sel_map_channel, sel_matid, sel_smGroup, sel_autofit };
// vsel_afr IDs
enum { sel_use_ar, sel_falloff, sel_pinch, sel_bubble };


class SelNodeNotify  : public TVNodeNotify 
{
public:
SelMod *s;
SelNodeNotify(SelMod *smod)
	{
	s = smod;
	}
RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message)
	{
	if ( (message == REFMSG_CHANGE) || 
		 (message == REFMSG_MOUSE_CYCLE_COMPLETED)
		 )
		{
		s->pblock2->SetValue(sel_method,0,s->method);
		return REF_STOP; 
		}
	return REF_SUCCEED ;
	}
};

//TVNodeNotify:: TVNodeNotify(SelMod *smod)



//--- ClassDescriptor and class vars ---------------------------------

//IParamMap*          SelMod::pmapParam   = NULL;
//IParamMap*          SelMod::pmapParam2   = NULL;
IObjParam*          SelMod::ip          = NULL;
SelMod*				SelMod::curMod      = NULL;
MoveModBoxCMode*    SelMod::moveMode    = NULL;
RotateModBoxCMode*  SelMod::rotMode     = NULL;
UScaleModBoxCMode*  SelMod::uscaleMode  = NULL;
NUScaleModBoxCMode* SelMod::nuscaleMode = NULL;
SquashModBoxCMode*  SelMod::squashMode  = NULL;


//class SelClassDesc:public ClassDesc {
class SelClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SelMod(!loading);}
	const TCHAR *	ClassName() { return GetString(IDS_RB_VOLSELECT_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(SELECTOSM_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("VolumeSelect"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static SelClassDesc selDesc;
extern ClassDesc* GetSelModDesc() {return &selDesc;}

// JBW: Here follows the new parameter block descriptors.  There are now 3, 
//      two new STATIC ones to hold the old class var parameters, one for the main
//		per-instance parameters.  Apart from all the extra 
//      metadata you see in the definitions, one important new idea is the
//      folding of ParamMap description info into the parameter descriptor and
//      providing a semi-automatic rollout desipaly mechanism.
//      

// Parameter Block definitions

// JBW: First come the position and version independent IDs for each
//      of the blocks and the parameters in each block.  These IDs are used
//	    in subsequent Get/SetValue() parameter access, etc. and for version-independent
//      load and save

// vsel_params param IDs
#define PBLOCK_REF	0
#define TM_REF		1
#define POS_REF		2
#define PBLOCK_AFR_REF	3
// block IDs
/*
enum { vsel_params, vsel_afr };

enum { sel_level, sel_method, sel_type, sel_volume, sel_invert, sel_node, sel_texture, sel_map, sel_map_channel };
// vsel_afr IDs
enum { sel_use_ar, sel_falloff, sel_pinch, sel_bubble };
*/
// JBW: this descriptor defines the main per-instance parameter block.  It is flagged as AUTO_CONSTRUCT which
//      means that the CreateInstance() will automatically create one of these blocks and set it to the reference
//      number given (0 in this case, as seen at the end of the line).

// per instance geosphere block
static ParamBlockDesc2 sel_param_blk ( vsel_params, _T("Parameters"),  0, &selDesc, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//rollout
	IDD_SELECTPARAM, IDS_RB_PARAMETERS, 0, 0, NULL,
	// params
	sel_level,  _T("level"), TYPE_INT, 	P_RESET_DEFAULT, 	IDS_PW_LEVEL, 
		p_default, 		0,	
		p_range, 		0, 2, 
		p_ui, 			TYPE_RADIO, 3,IDC_SEL_OBJECT,IDC_SEL_VERTEX,IDC_SEL_FACE,
		end, 
	sel_method,  _T("method"), TYPE_INT, 	P_RESET_DEFAULT, 	IDS_PW_METHOD, 
		p_default, 		0,	
		p_range, 		0, 2, 
		p_ui, 			TYPE_RADIO, 3,IDC_SEL_REPLACE,IDC_SEL_ADD,IDC_SEL_SUBTRACT,
		end, 
	sel_type,  _T("type"), TYPE_INT, 	P_RESET_DEFAULT, 	IDS_PW_TYPE, 
		p_default, 		0,	
		p_range, 		0, 1, 
		p_ui, 			TYPE_RADIO, 2,IDC_SEL_WINDOW,IDC_SEL_CROSSING,
		end, 


	sel_volume,  _T("volume"), TYPE_INT, 	P_RESET_DEFAULT, 	IDS_PW_VOLUME, 
		p_default, 		0,	
		p_range, 		0, 6, 
		p_ui, 			TYPE_RADIO,  7, IDC_SEL_BOXB, IDC_SEL_SPHEREB, IDC_SEL_CYLINDERB,
							IDC_SEL_MESH_OBJECTB, IDC_SEL_TEXTURE_MAPB, IDC_SEL_MATB, IDC_SEL_SMGROUPB,
		end, 

	sel_invert, 	_T("invert"),		TYPE_BOOL, 		P_RESET_DEFAULT,				IDS_PW_INVERT,
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_SEL_INVERT, 
		end, 

	sel_node, 	_T("node"),		TYPE_INODE, 		0,				IDS_PW_NODE,
		p_ui, 			TYPE_PICKNODEBUTTON, 	IDC_SEL_OBJECT_BUTTON, 
		end, 
	sel_texture, 	_T("texture"),		TYPE_TEXMAP, 		0,				IDS_PW_TEXMAP,
		p_ui, 			TYPE_TEXMAPBUTTON, 	IDC_SEL_TEXTURE_BUTTON, 
		end, 
	sel_map,  _T("map"), TYPE_INT, 	P_RESET_DEFAULT, 	IDS_PW_MAP, 
		p_default, 		0,	
		p_range, 		0, 1, 
		p_ui, 			TYPE_RADIO,  2,IDC_MAP_CHAN1,IDC_MAP_CHAN2,
		end, 

	sel_map_channel,  _T("mapChannel"),	TYPE_INT, 	P_RESET_DEFAULT, 	IDS_PW_CHANNEL, 
		p_default, 		1,	
		p_range, 		1, 99, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_MAP_CHAN,IDC_MAP_CHAN_SPIN,  SPIN_AUTOSCALE,
		end, 

	sel_matid, _T("matID"), TYPE_INT, P_RESET_DEFAULT, IDS_VS_MATID,
		p_default, 1,
		p_range, 1, MAX_MATID,
		p_ui, TYPE_SPINNER, EDITTYPE_INT, IDC_VS_MATID, IDC_VS_MATIDSPIN, 1.0,
		end,

	sel_smGroup, _T("smGroup"), TYPE_INT, P_RESET_DEFAULT, IDS_VS_SMGROUP,
		p_default, 1,
		p_range, 1, 32,
		p_ui, TYPE_SPINNER, EDITTYPE_INT, IDC_VS_SMG, IDC_VS_SMGSPIN, 1.0,
		end,

	sel_autofit, 	_T("autofit"),		TYPE_BOOL, 		P_RESET_DEFAULT,				IDS_PW_AUTOFIT,
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_SEL_AUTOFIT, 
		end, 


	end
	);


static ParamBlockDesc2 sel_afr_blk ( vsel_afr, _T("AffectRegion"),  0, &selDesc, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_AFR_REF, 

	//rollout
	IDD_MESHSEL_AFFECTREGION, IDS_MS_AFFECTREGION, 0, 0, NULL,
	// params
	sel_use_ar, 	_T("UseAffectRegion"),		TYPE_BOOL, 		P_RESET_DEFAULT,		IDS_PW_USE_AR,
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_MS_AR_USE, 
		p_enabled,		FALSE,
		p_enable_ctrls,	3, sel_falloff, sel_pinch, sel_bubble,
		end, 

	sel_falloff,  _T("falloff"),	TYPE_FLOAT, 	P_ANIMATABLE|P_RESET_DEFAULT, 	IDS_PW_FALLOFF2, 
		p_default, 		20.0f,	
		p_range, 		0.0f, 9999999999.0f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_FALLOFF,IDC_FALLOFFSPIN, SPIN_AUTOSCALE, 
		p_enabled,		FALSE,
		end, 

	sel_pinch,  _T("pinch"),	TYPE_FLOAT, 	P_ANIMATABLE|P_RESET_DEFAULT, 	IDS_PW_PINCH, 
		p_default, 		0.0f,	
		p_range, 		-10.0f, 10.0f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_PINCH,IDC_PINCHSPIN, 0.01f, 
		p_enabled,		FALSE,
		end, 

	sel_bubble,  _T("bubble"),	TYPE_FLOAT, 	P_ANIMATABLE|P_RESET_DEFAULT, 	IDS_PW_BUBBLE, 
		p_default, 		0.0f,	
		p_range, 		-10.0f, 10.0f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_BUBBLE,IDC_BUBBLESPIN, 0.01f, 
		p_enabled,		FALSE,
		end, 


	end
	);

//--- Parameter map/block descriptors -------------------------------

/*
#define PB_LEVEL 0
#define PB_METHOD 1
#define PB_TYPE 2
#define PB_VOLUME 3
#define PB_INVERT 4
#define PB_USE_AR 5
#define PB_FALLOFF 6
#define PB_PINCH 7
#define PB_BUBBLE 8
*/

// Levels
#define SEL_OBJECT		0
#define SEL_VERTEX		1
#define SEL_FACE		2

// Volumes
#define SEL_BOX			0
#define SEL_SPHERE		1
#define SEL_CYLINDER	2
#define SEL_MESH_OBJECT	3
#define SEL_TEXTURE		4
#define SEL_MATID 5
#define SEL_SMG 6

// Methods
#define SEL_REPLACE		0
#define SEL_ADD			1
#define SEL_SUBTRACT	2

// Types
#define SEL_WINDOW		0
#define SEL_CROSSING	1


// Flags
#define CONTROL_FIT		(1<<0)
#define CONTROL_CENTER	(1<<1)
#define CONTROL_UNIFORM	(1<<3)
#define CONTROL_HOLD	(1<<4)
#define CONTROL_INIT	(1<<5)
#define CONTROL_OP		(CONTROL_FIT|CONTROL_CENTER|CONTROL_UNIFORM|CONTROL_CHANGEFROMBOX)

#define CONTROL_USEBOX	(1<<6) // new for version 2. Means that gizmo space is not 0-1 but instead is based on the dimensions of the mod context box
#define CONTROL_CHANGEFROMBOX	(1<<7) // removes the above problem 


//
//
// Parameters

static int levelIDs[] = {IDC_SEL_OBJECT,IDC_SEL_VERTEX,IDC_SEL_FACE};
static int methodIDs[] = {IDC_SEL_REPLACE,IDC_SEL_ADD,IDC_SEL_SUBTRACT};
static int typeIDs[] = {IDC_SEL_WINDOW,IDC_SEL_CROSSING};
//static int volumeIDs[] = {IDC_SEL_BOX,IDC_SEL_SPHERE,IDC_SEL_CYLINDER};
/*
static ParamUIDesc descParam[] = {
	// Selection level
	ParamUIDesc(PB_LEVEL,TYPE_RADIO,levelIDs,3),
	
	// Selection method
	ParamUIDesc(PB_METHOD,TYPE_RADIO,methodIDs,3),
	
	// Selection type
	ParamUIDesc(PB_TYPE,TYPE_RADIO,typeIDs,2),

	// Selection volume
	ParamUIDesc(PB_VOLUME,TYPE_RADIO,volumeIDs,3),

	// Invert
	ParamUIDesc(PB_INVERT,TYPE_SINGLECHEKBOX,IDC_SEL_INVERT),
	};
#define PARAMDESC_LENGH 5

static ParamUIDesc descParam2[] = {
	// Use affect region?
	ParamUIDesc (PB_USE_AR, TYPE_SINGLECHEKBOX, IDC_MS_AR_USE),

	ParamUIDesc (PB_FALLOFF, EDITTYPE_POS_UNIVERSE,
		IDC_FALLOFF, IDC_FALLOFFSPIN,
		0.0f, 9999999999.f, SPIN_AUTOSCALE),

	ParamUIDesc (PB_PINCH, EDITTYPE_UNIVERSE,
		IDC_PINCH, IDC_PINCHSPIN,
		-10.0f, 10.0f, 0.01f),

	ParamUIDesc (PB_BUBBLE, EDITTYPE_UNIVERSE,
		IDC_BUBBLE, IDC_BUBBLESPIN,
		-10.0f, 10.0f, 0.01f),
};
#define PARAMDESC_LENGH2 4

static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, FALSE, PB_LEVEL },
	{ TYPE_INT, NULL, FALSE, PB_METHOD },
	{ TYPE_INT, NULL, FALSE, PB_TYPE },
	{ TYPE_INT, NULL, FALSE, PB_VOLUME },
	{ TYPE_INT, NULL, FALSE, PB_INVERT }
};
static ParamBlockDescID descVer1[] = {
	{ TYPE_INT, NULL, FALSE, PB_LEVEL },
	{ TYPE_INT, NULL, FALSE, PB_METHOD },
	{ TYPE_INT, NULL, FALSE, PB_TYPE },
	{ TYPE_INT, NULL, FALSE, PB_VOLUME },
	{ TYPE_INT, NULL, FALSE, PB_INVERT },
	{ TYPE_INT, NULL, TRUE, PB_USE_AR },
	{ TYPE_FLOAT, NULL, TRUE, PB_FALLOFF },
	{ TYPE_FLOAT, NULL, TRUE, PB_PINCH },
	{ TYPE_FLOAT, NULL, TRUE, PB_BUBBLE },
};
*/
static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, FALSE, sel_level },
	{ TYPE_INT, NULL, FALSE, sel_method },
	{ TYPE_INT, NULL, FALSE, sel_type },
	{ TYPE_INT, NULL, FALSE, sel_volume },
	{ TYPE_INT, NULL, FALSE, sel_invert }
};
static ParamBlockDescID descVer1[] = {
	{ TYPE_INT, NULL, FALSE, sel_level },
	{ TYPE_INT, NULL, FALSE, sel_method },
	{ TYPE_INT, NULL, FALSE, sel_type },
	{ TYPE_INT, NULL, FALSE, sel_volume },
	{ TYPE_INT, NULL, FALSE, sel_invert },
	{ TYPE_INT, NULL, TRUE, sel_use_ar },
	{ TYPE_FLOAT, NULL, TRUE, sel_falloff },
	{ TYPE_FLOAT, NULL, TRUE, sel_pinch },
	{ TYPE_FLOAT, NULL, TRUE, sel_bubble },
};

#define PBLOCK_LENGTH 9

static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,5,0)
};
#define NUM_OLDVERSIONS	1

#define CURRENT_VERSION 1
//static ParamVersionDesc curVersion(descVer1, PBLOCK_LENGTH, CURRENT_VERSION);

//--- SelDlgProc -----------------------------------
 
class SelDlgProc : public ParamMap2UserDlgProc {
public:
	SelMod *mod;		
	SelDlgProc(SelMod *m) {mod = m;}		
	BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
	void DeleteThis() {delete this;}		
};

BOOL SelDlgProc::DlgProc (TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {		
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				//case IDC_SEL_SPHERE:				
					//mod->flags |= CONTROL_UNIFORM|CONTROL_HOLD;
					//mod->NotifyDependents(FOREVER,SELECT_CHANNEL,REFMSG_CHANGE);
					//break;

				case IDC_SEL_FIT:
					mod->flags |= CONTROL_FIT|CONTROL_HOLD|CONTROL_INIT;
					mod->NotifyDependents(FOREVER,SELECT_CHANNEL,REFMSG_CHANGE);
					break;

				case IDC_SEL_CENTER:
					mod->flags |= CONTROL_CENTER|CONTROL_HOLD;
					mod->NotifyDependents(FOREVER,SELECT_CHANNEL,REFMSG_CHANGE);
					break;
				
				case IDC_SEL_RESET:
					theHold.Begin();
					mod->ReplaceReference(TM_REF,NULL);
					mod->flags |= CONTROL_FIT|CONTROL_CENTER|CONTROL_INIT;
					theHold.Accept(GetString(IDS_PW_UNDO_RESET));
					mod->NotifyDependents(FOREVER,SELECT_CHANNEL,REFMSG_CHANGE);
					break;
				case IDC_SEL_OBJECT:
				case IDC_SEL_FACE:
				case IDC_SEL_SMGROUPB:
				case IDC_SEL_MATB:
//watje 5-26-99
				case IDC_SEL_TEXTURE_MAPB:
					{
					mod->DisableAffectRegion(t);
					break;
					}


				//case IDC_SEL_REPLACE:
				//case IDC_SEL_ADD:
				//case IDC_SEL_SUBTRACT:
				case IDC_SEL_VERTEX:
				case IDC_SEL_BOXB:
				case IDC_SEL_SPHEREB:
				case IDC_SEL_CYLINDERB:
				case IDC_SEL_MESH_OBJECTB:

					{
					mod->EnableAffectRegion(t);
					break;
					}
		
				}
			break;
		}
	return FALSE;
	}

class AffectRegProc : public ParamMap2UserDlgProc {
public:
	SelMod *em;
	HWND hWnd;
	AffectRegProc () { em = NULL; }
	BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
	void DeleteThis() { }
	void Update(TimeValue t)
		{

		Rect rect;
		GetClientRectP(GetDlgItem(hWnd,IDC_AR_GRAPH),&rect);
		InvalidateRect(hWnd,&rect,FALSE);
		};

};

static AffectRegProc theAffectRegProc;

#define GRAPHSTEPS 20

float AffectRegFunctA(float dist,float falloff,float pinch,float bubble) {
	if (falloff<dist) return 0.0f;
	float u = ((falloff - dist)/falloff);
	float u2 = u*u, s = 1.0f-u;	
	return (3*u*bubble*s + 3*u2*(1.0f-pinch))*s + u*u2;
}

static void DrawCurve (HWND hWnd,HDC hdc) {
	float pinch, falloff, bubble;
	ISpinnerControl *spin = GetISpinner(GetDlgItem(hWnd,IDC_FALLOFFSPIN));
	falloff = spin->GetFVal();
	ReleaseISpinner(spin);	

	spin = GetISpinner(GetDlgItem(hWnd,IDC_PINCHSPIN));
	pinch = spin->GetFVal();
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_BUBBLESPIN));
	bubble = spin->GetFVal();
	ReleaseISpinner(spin);	

	TSTR label = FormatUniverseValue(falloff);
	SetWindowText(GetDlgItem(hWnd,IDC_FARLEFTLABEL),label);
	SetWindowText(GetDlgItem(hWnd,IDC_FARRIGHTLABEL),label);

	Rect rect, orect;
	GetClientRectP(GetDlgItem(hWnd,IDC_AR_GRAPH),&rect);
	orect = rect;

	SelectObject(hdc,GetStockObject(NULL_PEN));
	SelectObject(hdc,GetStockObject(WHITE_BRUSH));
	Rectangle(hdc,rect.left,rect.top,rect.right,rect.bottom);	
	SelectObject(hdc,GetStockObject(NULL_BRUSH));
	
	rect.left   += 3;
	rect.right  -= 3;
	rect.top    += 20;
	rect.bottom -= 20;
	
	SelectObject(hdc,CreatePen(PS_DOT,0,GetSysColor(COLOR_BTNFACE)));
	MoveToEx(hdc,orect.left,rect.top,NULL);
	LineTo(hdc,orect.right,rect.top);
	MoveToEx(hdc,orect.left,rect.bottom,NULL);
	LineTo(hdc,orect.right,rect.bottom);
	MoveToEx(hdc,(rect.left+rect.right)/2,orect.top,NULL);
	LineTo(hdc,(rect.left+rect.right)/2,orect.bottom);
	DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));
	
	MoveToEx(hdc,rect.left,rect.bottom,NULL);
	for (int i=0; i<=GRAPHSTEPS; i++) {
		float dist = falloff * float(abs(i-GRAPHSTEPS/2))/float(GRAPHSTEPS/2);		
		float y = AffectRegFunctA(dist,falloff,pinch,bubble);
		int ix = rect.left + int(float(rect.w()-1) * float(i)/float(GRAPHSTEPS));
		int	iy = rect.bottom - int(y*float(rect.h()-2)) - 1;
		if (iy<orect.top) iy = orect.top;
		if (iy>orect.bottom-1) iy = orect.bottom-1;
		LineTo(hdc, ix, iy);
	}
	
	WhiteRect3D(hdc,orect,TRUE);
}

BOOL AffectRegProc::DlgProc (TimeValue t, IParamMap2 *map,
										HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	if (!em) return FALSE;
	Rect rect;
	TSTR zero;

	switch (msg) {
	case WM_INITDIALOG:
		zero = FormatUniverseValue(0.0f);
		SetWindowText(GetDlgItem(hWnd,IDC_NEARLABEL),zero);
		ShowWindow(GetDlgItem(hWnd,IDC_AR_GRAPH),SW_HIDE);
		this->hWnd = hWnd;
		em->EnableAffectRegion (t);
		break;
		
	case WM_PAINT: {
//		em->EnableAffectRegion (t);
		PAINTSTRUCT ps;
		HDC hdc = BeginPaint(hWnd,&ps);
		DrawCurve(hWnd,hdc);
		EndPaint(hWnd,&ps);
		return FALSE;
		}

	case CC_SPINNER_CHANGE:
		GetClientRectP(GetDlgItem(hWnd,IDC_AR_GRAPH),&rect);
		InvalidateRect(hWnd,&rect,FALSE);
		return FALSE;
		break;

	default:
		return FALSE;
	}
	return TRUE;
}


//--- SelMod methods -------------------------------

SelMod::SelMod(BOOL create) {	
	if (create) flags = CONTROL_CENTER|CONTROL_FIT|CONTROL_INIT|CONTROL_USEBOX;
	else flags = 0;
/*
	MakeRefByID(FOREVER, PBLOCK_REF, 
		CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	pblock->SetValue (PB_FALLOFF, 0, 20.0f);
*/
	GetSelModDesc()->MakeAutoParamBlocks(this);

	tmControl  = NULL;
	posControl = NULL;
	container = NULL;
	notify = new SelNodeNotify(this);
}


SelMod::~SelMod()
{
// mjm - begin - 5.10.99
	if (container && notify)
		{
		ITrackViewNode *tvr = GetCOREInterface()->GetTrackViewRootNode();
		ITrackViewNode *global = tvr->GetNode(Class_ID(0xb27e9f2a, 0x73fad370));
		ITrackViewNode *tvroot = global->GetNode(MCONTAINER_TVNODE_CLASS_ID);
		if (tvroot) 
			{
			int ct = tvroot->NumItems();
			for (int i = 0; i <ct; i++)
				{
				ITrackViewNode *n = tvroot->GetNode(i);
				if (container == n)
					container->UnRegisterTVNodeNotify(notify);
				}
			}
		else
			{
//			ITrackViewNode *tvroot = tvr->GetNode(CONTAINER_TVNODE_CLASS_ID);
			int ct = tvr->NumItems();
			for (int i = 0; i <ct; i++)
				{
				ITrackViewNode *n = tvr->GetNode(i);
				if (container == n)
					container->UnRegisterTVNodeNotify(notify);
				}

			}
		}

	if (notify)
		delete notify;
// mjm - end
}


#define USEBOX_CHUNK	0x0100
#define BOX_CHUNK		0x0110
#define BACKPATCH_CHUNK		0x0120


class SelModPostLoad : public PostLoadCallback {
	public:
		SelMod *n;
		BOOL param2;
		SelModPostLoad(SelMod *ns, BOOL p) {n = ns;param2 = p;}
		void proc(ILoad *iload) {  
			if (n->container != NULL)
				{
				n->container->RegisterTVNodeNotify(n->notify);
				}
			if (!param2)
				n->pblock2->SetValue(sel_autofit,0,1);

			delete this; 


			} 
	};



IOResult SelMod::Load(ILoad *iload)
	{
	IOResult res;	
	Modifier::Load(iload);	
	ULONG nb;

	flags &= ~CONTROL_USEBOX;


	BOOL param2 = FALSE;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case USEBOX_CHUNK:
				flags |= CONTROL_USEBOX;
				flags |= CONTROL_CHANGEFROMBOX;
				flags |= CONTROL_INIT;
				break; 
			case BOX_CHUNK:
				iload->Read(&mcBox,sizeof(mcBox),&nb);
				break; 
			case BACKPATCH_CHUNK:
				ULONG id;
				iload->Read(&id,sizeof(ULONG), &nb);
				if (id!=0xffffffff)
					{
					iload->RecordBackpatch(id,(void**)&container);
					}
				param2 = TRUE;

				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	if (param2) flags &= ~CONTROL_CHANGEFROMBOX;

/*	iload->RegisterPostLoadCallback (
		new ParamBlockPLCB (versions, NUM_OLDVERSIONS, &curVersion, this, PBLOCK_REF));
*/

	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, NUM_OLDVERSIONS, &sel_param_blk, this, PBLOCK_REF);
	iload->RegisterPostLoadCallback(plcb);

	ParamBlock2PLCB* plcb2 = new ParamBlock2PLCB(versions, NUM_OLDVERSIONS, &sel_afr_blk, this, PBLOCK_AFR_REF);
	iload->RegisterPostLoadCallback(plcb2);

	iload->RegisterPostLoadCallback(new SelModPostLoad(this,param2));

	return IO_OK;

//	return IO_OK;
	}

IOResult SelMod::Save(ISave *isave)
	{
	Modifier::Save(isave);
	ULONG nb;

	isave->BeginChunk(BOX_CHUNK);
	isave->Write(&mcBox,sizeof(mcBox),&nb);

	isave->EndChunk();


	ULONG id = isave->GetRefID(container);

	isave->BeginChunk(BACKPATCH_CHUNK);
	isave->Write(&id,sizeof(ULONG),&nb);
	isave->EndChunk();


	if (flags&CONTROL_USEBOX) {
		isave->BeginChunk(USEBOX_CHUNK);
		isave->EndChunk();
		}


	return IO_OK;
	}

void SelMod::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev) {
	this->ip = ip; curMod = this;

	// Add our sub object type
	TSTR type1( GetString(IDS_RB_APPARATUS));
	TSTR type2( GetString(IDS_RB_CENTER));
	const TCHAR *ptype[] = {type1,type2};
	ip->RegisterSubObjectTypes(ptype, 2);

	// Create sub object editing modes.
	moveMode    = new MoveModBoxCMode(this,ip);
	rotMode     = new RotateModBoxCMode(this,ip);
	uscaleMode  = new UScaleModBoxCMode(this,ip);
	nuscaleMode = new NUScaleModBoxCMode(this,ip);
	squashMode  = new SquashModBoxCMode(this,ip);	
	selDesc.BeginEditParams(ip, this, flags, prev);
	sel_param_blk.SetUserDlgProc(new SelDlgProc(this));
	theAffectRegProc.em = this;
	sel_afr_blk.SetUserDlgProc(&theAffectRegProc);
/*	
	pmapParam = CreateCPParamMap (descParam,PARAMDESC_LENGH,
		pblock, ip, hInstance, MAKEINTRESOURCE(IDD_SELECTPARAM),
		GetString(IDS_RB_PARAMETERS), 0);		
	pmapParam->SetUserDlgProc(new SelDlgProc(this));
	pmapParam2 = CreateCPParamMap (descParam2, PARAMDESC_LENGH2,
		pblock, ip, hInstance, MAKEINTRESOURCE(IDD_MESHSEL_AFFECTREGION),
		GetString (IDS_MS_AFFECTREGION), 0);
	theAffectRegProc.em = this;
	pmapParam2->SetUserDlgProc (&theAffectRegProc);
*/

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);

	int l;
	pblock2->GetValue (sel_level,0,l,FOREVER);
	pblock2->SetValue (sel_level,0,l);

	
	}
		
void SelMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{	
	this->ip = NULL; curMod = NULL;

	TimeValue t = ip->GetTime();
	ClearAFlag(A_MOD_BEING_EDITED);
 	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);

	ip->DeleteMode(moveMode);
	ip->DeleteMode(rotMode);
	ip->DeleteMode(uscaleMode);
	ip->DeleteMode(nuscaleMode);
	ip->DeleteMode(squashMode);	
	delete moveMode; moveMode = NULL;
	delete rotMode; rotMode = NULL;
	delete uscaleMode; uscaleMode = NULL;
	delete nuscaleMode; nuscaleMode = NULL;
	delete squashMode; squashMode = NULL;
	selDesc.EndEditParams(ip, this, flags, next);
/*
	DestroyCPParamMap(pmapParam);
	pmapParam = NULL;
	DestroyCPParamMap (pmapParam2);
	pmapParam2 = NULL;
*/
	theAffectRegProc.em = NULL;
	}


class sMyEnumProc : public DependentEnumProc 
	{
      public :
      virtual int proc(ReferenceMaker *rmaker); 
      INodeTab Nodes;              
	};

int sMyEnumProc::proc(ReferenceMaker *rmaker) 
	{ 
	if (rmaker->SuperClassID()==BASENODE_CLASS_ID)    
			{
            Nodes.Append(1, (INode **)&rmaker);                 
			}
     return 0;              
	}


Interval SelMod::LocalValidity(TimeValue t)
	{	
	Interval valid = FOREVER;
	if (tmControl) {
		Matrix3 tm(1);
		tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);		
		if (posControl) posControl->GetValue(t,&tm,valid,CTRL_RELATIVE);
	}
	int localUseAR=FALSE;
	pblock2->GetValue (sel_level, t, level, FOREVER);
	pblock2->GetValue (sel_method, t, method, FOREVER);
	if ((level==1) && (method==0)) {
		pblock2_afr->GetValue (sel_use_ar, t, useAR, valid);
		localUseAR = useAR;
	}
	if (localUseAR) {
		float f;
		pblock2_afr->GetValue (sel_falloff, t, f, valid);
		pblock2_afr->GetValue (sel_pinch, t, f, valid);
		pblock2_afr->GetValue (sel_bubble, t, f, valid);
	}

	pblock2->GetValue(sel_volume,t,vol,FOREVER);

	if (vol == SEL_TEXTURE) {
		Texmap *ttmap = NULL;
		pblock2->GetValue(sel_texture,t,ttmap,FOREVER);
		if (ttmap != NULL)
			valid &= ttmap->Validity(t);
	}
	if (vol == SEL_MESH_OBJECT) {
		INode *tnode;
		pblock2->GetValue(sel_node,t,tnode,FOREVER);
		if (tnode != NULL) {
			Matrix3 tm = tnode->GetObjectTM(t,&valid);
			ObjectState nos = tnode->EvalWorldState(t);
			if (nos.obj->IsShapeObject()) {
				ShapeObject *pathOb = (ShapeObject*)nos.obj;
				if (!pathOb->NumberOfCurves()) {
					pathOb = NULL;
					}
			
				}

			valid &= nos.obj->ObjectValidity(t);
			valid &= nos.Validity(t);
		    sMyEnumProc dep;              
			EnumDependents(&dep);
			for (int i = 0; i < dep.Nodes.Count(); i++)
				{
				dep.Nodes[i]->GetObjectTM(t,&valid);
				}

		}
//		valid.Set(t,t);  //<- THIS IS A HACK TO FORCE AN UPDATE SINCE THERE IS NO WAY THAT I KNOW OF TO GET THE BASE OBJECT VALIDIDTY
	}
	if (!(valid == FOREVER))
		valid.Set(t,t);  //<- THIS IS A HACK TO FORCE AN UPDATE SINCE THERE IS NO WAY THAT I KNOW OF TO GET THE BASE OBJECT VALIDIDTY

	return valid;
}

RefTargetHandle SelMod::Clone(RemapDir& remap) 
	{
	SelMod* newmod = new SelMod(FALSE);	
	newmod->ReplaceReference(PBLOCK_REF,pblock2->Clone(remap));
	newmod->ReplaceReference(PBLOCK_AFR_REF,pblock2_afr->Clone(remap));
	newmod->ReplaceReference(TM_REF,tmControl->Clone(remap));
	if (posControl)
		newmod->ReplaceReference(POS_REF,posControl->Clone(remap));
	newmod->flags = CONTROL_USEBOX;
	newmod->container = NULL;
	return newmod;
	}

static void FixupBox(Box3 &box)
	{
	if (box.IsEmpty()) box.MakeCube(Point3(0,0,0),10.0f);
	for (int i=0; i<3; i++) {
		if (fabs(box.pmax[i]-box.pmin[i])<0.001) {
			float cent = (box.pmax[i]-box.pmin[i])/2.0f;
			box.pmax[i] = cent + 0.0005f;
			box.pmin[i] = cent - 0.0005f;
			}
		}
	}




void SelMod::InitControl(ModContext &mc,TriObject *obj, TimeValue t)
	{
	Box3 box;
	Matrix3 tm;

	Box3 mcbox = *mc.box;
	FixupBox(mcbox);	

	if (tmControl==NULL) {
		MakeRefByID(FOREVER,TM_REF,NewDefaultMatrix3Controller()); 
		NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
		}
	if (posControl==NULL) {
		MakeRefByID(FOREVER,POS_REF,NewDefaultPositionController()); 
		NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
		}

	if (flags&(CONTROL_FIT|CONTROL_CENTER)) {
		Point3 zero(0,0,0);
		posControl->SetValue(t,&zero);
		}

	tm = Inverse(CompMatrix(t,&mc,NULL,FALSE));	

//	obj->GetDeformBBox(t,box,&tm,TRUE);
//	box = *(mc.box) * (*(mc.tm)) * tm;
	if (mc.box->IsEmpty()) 
		{
		box.MakeCube(Point3(0,0,0),10.0f);
		box = box * (*(mc.tm)) * tm;
		}
	else box = *(mc.box) * (*(mc.tm)) * tm;

	FixupBox(box);
	box.Scale(1.0000005f);	
	BOOL n3 = theHold.IsSuspended();

	BOOL isSuspended = FALSE;
	if (flags&CONTROL_HOLD) 
		{
		if (theHold.IsSuspended())
			{
			theHold.Resume();
			isSuspended = TRUE;
			}
		theHold.Begin();
		}

	if (flags&CONTROL_INIT) {
		SuspendAnimate();
		AnimateOff();
		}
	
	if (flags&CONTROL_UNIFORM) {
		Matrix3 tm(1), id(1);
		Interval valid;
		tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);
		float av = 0.0f;
		Point3 s;
		av += Length(tm.GetRow(0));
		av += Length(tm.GetRow(1));
		av += Length(tm.GetRow(2));
		av /= 3.0f;
		s.x = av/Length(tm.GetRow(0));
		s.y = av/Length(tm.GetRow(1));
		s.z = av/Length(tm.GetRow(2));

		SetXFormPacket pckt(s,TRUE,id,tm);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}

	if (flags&CONTROL_FIT) {
		Point3 s, w  = box.Width();
		Matrix3 tm(1), id(1);
		Interval valid;
		tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);
				
		int axis;
		if (vol==SEL_BOX) {
			s.x = w.x==0.0f ? 1.0f : w.x/2.0f;
			s.y = w.y==0.0f ? 1.0f : w.y/2.0f;
			s.z = w.z==0.0f ? 1.0f : w.z/2.0f;
		} else 
		if (vol==SEL_SPHERE) {
			float max = w.x;
			axis = 0;
			if (w.y>max) 
				{
				max = w.y;
				axis = 1;
				}
			if (w.z>max) 
				{
				max = w.z;
				axis = 2;
				}
			if (max==0.0f) max = 1.0f;
			s.x = s.y = s.z = max/2.0f;
		} else {
			if (w.x>w.y) s.x = s.y = w.x/2.0f;
			else s.x = s.y = w.y/2.0f;
			s.z = w.z/2.0f;
			if (s.x==0.0f) s.x = 1.0f;
			if (s.y==0.0f) s.y = 1.0f;
			if (s.z==0.0f) s.z = 1.0f;
			}
		
		if (flags&CONTROL_USEBOX) {
			if (vol == SEL_CYLINDER)
				{
				if (w.x>w.y) 
					{
					s.x /= mcbox.Width().x*0.5f;
					s.y /= mcbox.Width().x*0.5f;
					}
				else{
					s.x /= mcbox.Width().y*0.5f;
					s.y /= mcbox.Width().y*0.5f;
					}
				s.z /= mcbox.Width().z*0.5f;

				}
			else if (vol == SEL_SPHERE)
				{
				if (axis == 0)
					{
					s.x /= mcbox.Width().x*0.5f;
					s.y /= mcbox.Width().x*0.5f;
					s.z /= mcbox.Width().x*0.5f;
					}
				else if (axis == 1)
					{
					s.x /= mcbox.Width().y*0.5f;
					s.y /= mcbox.Width().y*0.5f;
					s.z /= mcbox.Width().y*0.5f;
					}
				else 
					{
					s.x /= mcbox.Width().z*0.5f;
					s.y /= mcbox.Width().z*0.5f;
					s.z /= mcbox.Width().z*0.5f;
					}


				}

			else
				{
				s.x /= mcbox.Width().x*0.5f;
				s.y /= mcbox.Width().y*0.5f;
				s.z /= mcbox.Width().z*0.5f;
				}
			}

		SetXFormPacket pckt(s,TRUE,id,tm);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		
		// redo the box so our center op works
		tm = Inverse(CompMatrix(t,&mc,NULL,FALSE));	
		obj->GetDeformBBox(t,box,&tm,TRUE);
		FixupBox(box);
		}		

	if (flags&(CONTROL_CENTER|CONTROL_FIT)) {
		Matrix3 tm(1);
		Interval valid;
		tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);		
		if (!(flags&CONTROL_USEBOX)) {
			SetXFormPacket pckt(VectorTransform(tm,box.Center()));
			tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		} else {			
			SetXFormPacket pckt(mcbox.Center()-(mcbox.Center()*tm));
			tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);

			//tm.SetTrans(box.Center()*tm);
			//tm.SetTrans((mc.box->Center()*Inverse(tm))-mc.box->Center());
			//SetXFormPacket pckt(tm);
			//tmControl->SetValue(t,&pckt,TRUE,CTRL_ABSOLUTE);
			}
		}
	
	if (flags&CONTROL_HOLD) 
		{
		if (flags&CONTROL_FIT)
			theHold.Accept(GetString(IDS_PW_UNDO_FIT));	
		else theHold.Accept(GetString(IDS_RB_CENTER));	
			

		if (isSuspended)
			{
			theHold.Suspend();
			}

		}

	if ( (flags&CONTROL_INIT) ||(flags&CONTROL_CHANGEFROMBOX) ) {
		mcBox = mcbox;
		flags &= ~CONTROL_CHANGEFROMBOX;
		ResumeAnimate();
		}

	// Turn off everything except the use box flag
	flags &= CONTROL_USEBOX;
	}


float SelMod::GetPixel(TimeValue t, Point3 pt,float u, float v, float w)
	{
	float f = 0.0f;
	if (tmap) {
		shadeContext.scrPos.x = int(u);
		shadeContext.scrPos.y = int(v);
		shadeContext.uvw.x = u;
		shadeContext.uvw.y = v;
		shadeContext.uvw.z = w;
		shadeContext.pt = pt;
		shadeContext.curTime = t;
		AColor c;
		c  = tmap->EvalColor(shadeContext);
		f += c.r * 0.299f;
		f += c.g * 0.587f;
		f += c.b * 0.114f;		
		}
	return f;
	}

#define EPSILON 0.000001f



void SelMod::RecurseDepth(float u1, float u2, float &fu,  ShapeObject *s,int Curve,int Piece, int &depth, Point3 fp)
{


for (int i = 0; i < depth; i++)
	{
	float u = (u1+u2)*.5f;
	float midu = (u2-u1)*.25f;
	float tu1 = u - midu; 
	float tu2 = u + midu;
	Point3 p1, p2;
	p1 = s->InterpPiece3D(rt, Curve, Piece, tu1);
	p2 = s->InterpPiece3D(rt, Curve, Piece, tu2);



	if ( LengthSquared(fp-p1) < LengthSquared(fp-p2) )
		{
		u1 = u1;
		u2 = u;
		}
	else
		{
		u1 = u;
		u2 = u2;
		}

	}
fu = (u2+u1)*0.5f;
}

void SelMod::PointToPiece(float &tempu,ShapeObject *s,int Curve,int Piece, int depth, Point3 fp)

{
//float tu1,tu2,tu3,tu4;
float tu;
float su,eu;
int depth1;

depth1 = depth;

su = 0.0f;
eu = 0.25f;

float fdist = REALLYBIGFLOAT;
float fu = 0.0f;

for (int i = 0; i < 4; i++)
	{
	tu = 0.0f;
	depth = depth1;
	RecurseDepth(su,eu,tu,s,Curve,Piece,depth,fp);
	su += 0.25f;
	eu += 0.25f;
	Point3 dp = s->InterpPiece3D(rt, Curve, Piece, tu);
	float dist = LengthSquared(fp-dp);
	if (dist<fdist)
		{
		fdist = dist;
		fu = tu;
		}
	}


tempu = fu;
//return fu;
}

void SelMod::RecurseDepthB(float u1, float u2, float &fu,  BezierShape *s,int Curve,int Piece, int &depth, Point3 fp)
{


for (int i = 0; i < depth; i++)
	{
	float u = (u1+u2)*.5f;
	float midu = (u2-u1)*.25f;
	float tu1 = u - midu; 
	float tu2 = u + midu;
	Point3 p1, p2;
//	p1 = s->InterpPiece3D(rt, Curve, Piece, tu1);
//	p2 = s->InterpPiece3D(rt, Curve, Piece, tu2);
	p1 = s->splines[Curve]->InterpBezier3D(Piece, tu1);
	p2 = s->splines[Curve]->InterpBezier3D(Piece, tu2);



	if ( LengthSquared(fp-p1) < LengthSquared(fp-p2) )
		{
		u1 = u1;
		u2 = u;
		}
	else
		{
		u1 = u;
		u2 = u2;
		}

	}
fu = (u2+u1)*0.5f;
}



void SelMod::PointToPieceB(float &tempu,BezierShape *s,int Curve,int Piece, int depth, Point3 fp)

{
//float tu1,tu2,tu3,tu4;
float tu;
float su,eu;
int depth1;

depth1 = depth;

su = 0.0f;
eu = 0.25f;

float fdist = REALLYBIGFLOAT;
float fu = 0.0f;

for (int i = 0; i < 4; i++)
	{
	tu = 0.0f;
	depth = depth1;
	RecurseDepthB(su,eu,tu,s,Curve,Piece,depth,fp);
	su += 0.25f;
	eu += 0.25f;
//	Point3 dp = s->InterpPiece3D(rt, Curve, Piece, tu);
	Point3 dp = s->splines[Curve]->InterpBezier3D(Piece, tu);
	float dist = LengthSquared(fp-dp);
	if (dist<fdist)
		{
		fdist = dist;
		fu = tu;
		}
	}


tempu = fu;
//return fu;
}



float SelMod::SplineToPoint(Point3 p1, ShapeObject *s)

{

int rec_depth = 5;

int piece_count = 0;
float fdist = REALLYBIGFLOAT;
int i = 0;




BezierShape bez;

if (!s->NumberOfCurves ()) return 0.0f;
if (s->CanMakeBezier()) 
	{
	s->MakeBezier (rt, bez);
	if (bez.splineCount < 1) return 0.0f;
	} 
else 
	{	// Do dumb conversion to bezier.
	PolyShape pshp;
	s->MakePolyShape (rt, pshp);
	if (pshp.numLines < 1) return 0.0f;
	bez = pshp;	// Basic conversion implemented in operator=.
	}


for (i = 0; i < bez.SplineCount(); i++)
	{
	for (int j = 0; j < bez.splines[i]->Segments(); j++)
		{
		float u;
		PointToPieceB(u,&bez,i,j,rec_depth,p1);
		Point3 dp = bez.splines[i]->InterpBezier3D(j,u);
		float dist = LengthSquared(p1-dp);
		if (dist<fdist)
			{
			fdist = dist;
			}
		}
	}

return (float)sqrt(fdist);
}

/*

float SelMod::SplineToPoint(Point3 p1, ShapeObject *s)

{

int rec_depth = 5;

int piece_count = 0;
float fdist = REALLYBIGFLOAT;
int i = 0;
for (i = 0; i < s->NumberOfCurves(); i++)
	{
	for (int j = 0; j < s->NumberOfPieces(rt,i); j++)
		{
		float u;
		PointToPiece(u,s,i,j,rec_depth,p1);
		Point3 dp = s->InterpPiece3D(rt, i, j, u);
		float dist = LengthSquared(p1-dp);
		if (dist<fdist)
			{
			fdist = dist;
			}
		}
	}

return (float)sqrt(fdist);
}
*/

float SelMod::LineToPoint(Point3 p1, Point3 l1, Point3 l2)
{
Point3 VectorA,VectorB,VectorC;
float Angle;
float dist = 0.0f;
VectorA = l2-l1;
VectorB = p1-l1;
Angle = (float) acos(DotProd(Normalize(VectorA),Normalize(VectorB)));
if (Angle > (3.14f/2.0f))
	{
	dist = Length(p1-l1);
	}
else
	{
	VectorA = l1-l2;
	VectorB = p1-l2;
	Angle = (float)acos(DotProd(Normalize(VectorA),Normalize(VectorB)));
	if (Angle > (3.14f/2.0f))
		{
		dist = Length(p1-l2);
		}
		else
		{
		float hyp;
		hyp = Length(VectorB);
		dist = (float) sin(Angle) * hyp;
//		u = (float) cos(Angle) * hyp;
//		float a = Length(VectorA);
//		u = ((a-u) / a);

		}

	}

return dist;

}


float SelMod::DistToFace(Point3 pa, Point3 p1,Point3 p2,Point3 p3, int faceIndex)
{
//if insed face take distance from plane
//check if intersects triangle
//compute normal

Ray ray;
Point3 n = normList[faceIndex];
ray.dir = -n;
ray.p = pa;
			
// See if the ray intersects the plane (backfaced)
float rn = DotProd(ray.dir,n);
		
// Use a point on the plane to find d
float d = DotProd(p1,n);

// Find the point on the ray that intersects the plane
float a = (d - DotProd(ray.p,n)) / rn;



// The point on the ray and in the plane.
Point3 hp = ray.p + a*ray.dir;

// Compute barycentric coords.
Point3 bry = msh->BaryCoords(faceIndex,hp);

// barycentric coordinates must sum to 1 and each component must
// be in the range 0-1
if ( (bry.x<0.0f || bry.x>1.0f || bry.y<0.0f || bry.y>1.0f || bry.z<0.0f || bry.z>1.0f) ||
     (fabs(bry.x + bry.y + bry.z - 1.0f) > EPSILON) )
	{
//else take distance from closest edge
//find 2 closest points and use that edge
	float closest,d;
	closest = LineToPoint(pa, p1, p2);
	d = LineToPoint(pa, p2, p3);
	if (d < closest) closest = d;
	d = LineToPoint(pa, p3, p1);
	if (d < closest) closest = d;
	return closest;

	}
else  
	{
	return Length(pa-hp);
	}

return 99999999.9f;
}

float SelMod::PointInVolume(TimeValue t, Point3 pt,float u, float v, float w, Matrix3 &tm,Box3 box)
	{
	int i;
	float f;
	
	switch (vol) {
	case SEL_BOX:
		pt = pt*tm;
		for (i=0; i<3; i++) if ((pt[i]<-1.0f) || (pt[i]>1.0f)) break;
		if (i==3) return 1.0f;
		else return 0.0f;

	case SEL_SPHERE:
		pt = pt*tm;
		if (Length(pt)<=1.0f) return 1.0f;
		else return 0;

	case SEL_CYLINDER:
		pt = pt*tm;
		if (Sqrt(pt.x*pt.x+pt.y*pt.y)>1.0f) return 0.0f;
		if ((pt.z<-1.0f) || (pt.z>1.0f)) return 0.0f;
		return 1.0f;

	case SEL_MESH_OBJECT:
		{
//		INode *node=NULL;
//is node not null

//		pblock2->GetValue(sel_node,0,node,FOREVER);

		if (targnode != NULL)
			{

//transform point into world space then into the object space


			if (sos.obj->SuperClassID()==SHAPE_CLASS_ID)
				{

//is spline
				pt = pt*otm;

				if (sos.obj->SuperClassID()==SHAPE_CLASS_ID)
					{

					if (useAR)
						{
						rt = t;
						Box3 bboxFalloff = bbox;
						bboxFalloff.EnlargeBy(falloff);
						if (bboxFalloff.Contains(pt))
							{
							float d =  SplineToPoint(pt, pathOb);
							return d;
							}

						}
					return 999999999999.0f;

		
	
					}
				}
			else if (sos.obj->IsParticleSystem())
				{
				pt = pt * ntm;
				int count = pobj->parts.Count();
				float closest=999999999.9f;
				for (int pid = 0; pid < count; pid++)
					{
					TimeValue age  = pobj->ParticleAge(rt,pid);
					TimeValue life = pobj->ParticleLife(rt,pid);
					if (age!=-1)
						{
//						Point3 curval = pobj->ParticlePosition(rt,pid);
						Point3 curval = pobj->parts.points[pid];

						float d = LengthSquared(curval-pt);
						if ((d < closest) || (closest == -1.0f))
							closest = d;
						}
					}	
					
				return (float) sqrt(closest);

				}

			else if (sos.obj->SuperClassID()==GEOMOBJECT_CLASS_ID)
				
//is geom object
				{
					
				pt = pt*otm;
				if (bbox.Contains(pt)  )
					{

//					Setup a ray
///intersect axis  rays with mesh;
//this is a brute force ugly way to do this but will work for now

//do bounding box hit first
					Ray ray;
					Point3 norm;
					float at = 0.0f;

					float dist = 0.0f;

	
// See if we hit the object
					Point3 dir (1.0f,0.0f,0.0f);
					ray.p   = pt;
					ray.p.x -= 9999.9f;
					ray.dir = dir;
					BOOL hit = FALSE;
					int ct = 0;
					float l = 0;
					if (msh == NULL)
						{
						while  ((sos.obj->IntersectRay(rt,ray,at,norm)) && (l<9999.9f))
							{
							Point3 tp = ray.dir * (at+0.1f) ;
							ray.p = ray.p + tp;
							l += at;
							if (l< 9999.9f)
								ct++;
							}
						}
					else
						{
						if (boxList.Count() != 0)
							{
							Point3 dir (-1.0f,0.0f,0.0f);
							ray.p   = pt;
							ray.dir = dir;

							for (int k = 0; k < boxList.Count();  k++)
								{
								Point2 p2;
								p2.x = pt.y;
								p2.y = pt.z;
								Point2 min, max;
								min = boxList[k].min;
								max = boxList[k].max;
								if ( (p2.x <= boxList[k].max.x) && (p2.x >= boxList[k].min.x) &&
									 (p2.y <= boxList[k].max.y) && (p2.y >= boxList[k].min.y) )
									{
									Point3 plist[3];
									int index;
									for (int f = 0; f < 3; f++)
										{
										index = msh->faces[k].v[f];
										plist[f] = msh->verts[index];
										}
//check if all point are to the left
								
									if ( (plist[0].x <= pt.x) ||
										 (plist[1].x <= pt.x) ||
										 (plist[2].x <= pt.x)    )
										{
//check if intersects triangle
//compute normal

										Point3 n = normList[k];
			
		// See if the ray intersects the plane (backfaced)
										float rn = DotProd(ray.dir,n);
		
		// Use a point on the plane to find d
										float d = DotProd(msh->verts[index],n);

		// Find the point on the ray that intersects the plane
										float a = (d - DotProd(ray.p,n)) / rn;



		// The point on the ray and in the plane.
										Point3 hp = ray.p + a*ray.dir;

										int fudge = 0;
										if (plist[0].z == hp.z) fudge++;
										if (plist[1].z == hp.z) fudge++;
										if (plist[2].z == hp.z) fudge++;

										if (fudge > 1) hp.z += 0.001f;


		// Compute barycentric coords.
										Point3 bry = msh->BaryCoords(k,hp);

		// barycentric coordinates must sum to 1 and each component must
		// be in the range 0-1
										if (bry.x<0.0f || bry.x>1.0f || bry.y<0.0f || bry.y>1.0f || bry.z<0.0f || bry.z>1.0f)
											{
											}
										else if (fabs(bry.x + bry.y + bry.z - 1.0f) > EPSILON)
											{
											}
										else if (hp.x < pt.x)
											{
											ct++;
											}
										}
									}
								}
							}
	
						}
	
					l = 0;
					ray.p   = pt;
					dir.x = -1.0f;
					ray.dir = dir;

					if (msh == NULL)
						{
						if (sos.obj->ClassID()!=Class_ID(SPHERE_CLASS_ID,0))  // hack to make sphere work since it report intersections going both way
							{
							while  ((sos.obj->IntersectRay(rt,ray,at,norm)))
								{
								Point3 tp = ray.dir * (at+0.1f) ;
								ray.p = ray.p + tp;
								ct++;
								}
							}	
						}
					else
						{
						}
					if ((ct%2) == 1)
						return 1.0f;
					}
//				}
//				else 
					{
					if ((useAR) &&( msh != NULL))
						{
						Box3 bboxFalloff = bbox;
						bboxFalloff.EnlargeBy(falloff);
						if (bboxFalloff.Contains(pt))
							{
							float closest = -1.0f;
							for (int k = 0; k < boxList.Count();  k++)
								{
								if (box3DList[k].Contains(pt))
									{
//get distance from that face
									int a,b,c;
									a = msh->faces[k].v[0];
									b = msh->faces[k].v[1];
									c = msh->faces[k].v[2];
									float d =  DistToFace(pt, msh->verts[a], msh->verts[b], msh->verts[c],k);
									if ((closest == -1) || (d < closest))
										closest = d;
									}
								}
							if (closest != -1.0f) return closest;
							}
						}

					return 999999999.0f;
					}
				}
//				}
			}


			
		return 0.0f;
		}

	case SEL_TEXTURE:
		f = GetPixel(t,pt,u,v,w);
		if (f >0.99f) f = 1.0f;  // this has to be done since MS VC++ optimizer does not evaluate the same for debug and release
		return f;
	}

	return FALSE;
}

// Returns negative amount if point inside volume, 0 on surface, positive outside.
float SelMod::DistFromVolume(Point3 pt, Matrix3 &tm, Matrix3 & ctm, Box3 box)
	{
	Point3 p = tm*pt;
	int i;
	float max;
	Point3 diff, scale, center;
	for (i=0; i<3; i++) scale[i] = Length (ctm.GetRow (i));

	switch (vol) {
	case SEL_BOX:
		for (i=0; i<3; i++) {
			diff[i] = (float(fabs(p[i])) - 1.0f)*scale[i];
			if (!i || (diff[i]>max)) max = diff[i];
			if (diff[i]<0) diff[i] = 0.0f;
		}
		if (max<0) return max;	// this far inside box.
		return Length(diff);

	case SEL_SPHERE: // Not easy!  Distance to ellipsoid...
//		return (Length(p)-1.0f)*Length(scale);	// STEVE: temporary kluge -- or is this the Right Thing?
		return Length(((p)-Normalize(p))*(scale));	// the above is not right. is this right though?

	case SEL_CYLINDER:
		if ((p.z < 0.0) || (p.z > 1.0)) 
			return Length(((p)-Normalize(p))*(scale));	// see note above
		else
			{
			p.z = 0;
			return Length(((p)-Normalize(p))*(scale));	// see note above
			}
/*
		max = diff.x = (Sqrt(p.x*p.x+p.y*p.y)-1.0f) * Sqrt(scale.x*scale.x+scale.y*scale.y);	// STEVE: kluge again.
		if ((diff.z = (float(fabs(p.z))-1.0f)*scale.z) > max) max = diff.z;
		if (max<0) return max;
		if (diff.x<=0) diff.x = 0.0f;
		if (diff.z<=0) diff.z = 0.0f; 
		diff.y = 0;
		return Length(diff);
*/
	}

	return 0.0f;
}

void SelMod::SelectVertices (Mesh &mesh, Matrix3 &tm, Matrix3 & ctm, Box3 &box, TimeValue t) {
	if (method==SEL_REPLACE) {
		mesh.vertSel.ClearAll();
		mesh.ClearVSelectionWeights ();
	}

	if ((vol == SEL_MATID) || (vol == SEL_SMG)) {
		BitArray andVerts;
		BitArray orVerts;
		andVerts.SetSize (mesh.numVerts);
		andVerts.SetAll ();
		orVerts.SetSize (mesh.numVerts);
		orVerts.ClearAll ();
		DWORD realSmG = (1<<(smG-1));
		for (int i=0; i<mesh.numFaces; i++) {
			Face & fac = mesh.faces[i];
			BOOL hot = (vol == SEL_MATID) ? (fac.getMatID () == matID) : (fac.smGroup & realSmG);
			if (hot) {
				for (int j=0; j<3; j++) orVerts.Set (fac.v[j]);
			} else {
				for (int j=0; j<3; j++) andVerts.Clear (fac.v[j]);
			}
		}
		andVerts &= orVerts;	// So that verts with no faces won't be in andVerts.
		// If in crossing mode, select verts that touch this material.  Otherwise, select only verts
		// surrounded by this material.
		BitArray *selVerts = (selType==SEL_CROSSING) ? &orVerts : &andVerts;

		float *vsw = mesh.getVSelectionWeights ();	// NULL if none.
		switch (method) {
		case SEL_REPLACE:
		case SEL_ADD:
			mesh.vertSel |= *selVerts;
			if (vsw) {
				for (i=0; i<mesh.numVerts; i++) if ((*selVerts)[i]) vsw[i] = 1.0f;
			}
			break;
		case SEL_SUBTRACT:
			mesh.vertSel &= ~(*selVerts);
			if (vsw) {
				for (i=0; i<mesh.numVerts; i++) if ((*selVerts)[i]) vsw[i] = 0.0f;
			}
			break;
		}
		if (invert) {
			mesh.vertSel = ~mesh.vertSel;
			if (vsw) {
				for (i=0; i<mesh.numVerts; i++) vsw[i] = 1.0f-vsw[i];
			}
		}
		return;
	}
//watje 5-26-99
	if ((useAR) || (vol == SEL_TEXTURE)) mesh.SupportVSelectionWeights();
	float *vsw = mesh.getVSelectionWeights ();	// NULL if none.

	int currentChannel;
	currentChannel = map ? 0 : channel;

	TVFace *tvFace = mesh.mapFaces(currentChannel);
	Point3 *tVerts = NULL;
	for (int i=0; i<mesh.getNumVerts(); i++) {
		//get texture verts for that vertex
		//loop through faces find ing matched
		Point3 tv(0.5f,0.5f,0.0f);
		if ((tvFace!= NULL) &&(i<uvwList.Count())) tv = uvwList[i];
		float f = PointInVolume(t, mesh.verts[i],tv.x,tv.y,tv.z,tm,box);
		if (f == 1.0f) {
			if (method==SEL_SUBTRACT) {
				mesh.vertSel.Clear(i);
				if (vsw) vsw[i] = 0.0f;
			} else {
				mesh.vertSel.Set(i);
				if (vsw) vsw[i] = 1.0f;
			}
		} else {
			if (vsw) {
				if ((vol != SEL_TEXTURE) && (vol != SEL_MESH_OBJECT)) {
					f = AffectRegFunctA (DistFromVolume (mesh.verts[i], tm, ctm, box), falloff, pinch, bubble);
				} else if (vol != SEL_TEXTURE) f = AffectRegFunctA (f, falloff, pinch, bubble);

				switch (method) {
				case SEL_SUBTRACT:
					vsw[i] = vsw[i] - f;
					if (vsw[i] < 0) vsw[i] = 0.0f;
					break;
				case SEL_ADD:
					vsw[i] += f;
					if (vsw[i] >= 1) vsw[i] = 1.0f;
					break;
				default:
					vsw[i] = f;
					break;
				}
	
				mesh.vertSel.Set (i, vsw[i] == 1.0f);
			}
		}

		if (invert) {
			if (vsw) {
				vsw[i] = 1.0f-vsw[i];
				mesh.vertSel.Set(i, vsw[i] == 1.0f);
			} else mesh.vertSel.Set(i,!mesh.vertSel[i]);
		}
	}
}

void SelMod::SelectFaces (TimeValue t, Mesh &mesh, Matrix3 &tm, Box3 &box) {
	if (method==SEL_REPLACE) mesh.faceSel.ClearAll();

	if ((vol == SEL_MATID) || (vol == SEL_SMG)) {
		DWORD realSmG = (1<<(smG-1));
		for (int i=0; i<mesh.getNumFaces(); i++) {
			if (vol==SEL_MATID){
				if (mesh.faces[i].getMatID () != matID) continue;
			} else {
				if (mesh.faces[i].getSmGroup () != realSmG) continue;
			}
			if (method == SEL_SUBTRACT) mesh.faceSel.Clear (i);
			else mesh.faceSel.Set (i);
		}
		if (invert) mesh.faceSel = ~mesh.faceSel;

		return;
	}
	int in;

//need to put in a channel spinner
//	TVFace *tvFace = mesh.mapFaces(0);
	int currentChannel;
	currentChannel = map ? 0 : channel;

	Point3 *tVerts = mesh.mapVerts(currentChannel);
	TVFace *tvFace = mesh.mapFaces(currentChannel);
	for (int i=0; i<mesh.getNumFaces(); i++) {
		in = 0;
		for (int k=0; k<3; k++) {

			Point3 tv(0.0f,0.0f,0.0f);
			if ((tvFace != NULL) && (vol==SEL_TEXTURE))
				{
				int index = tvFace[i].t[k];
				tv = tVerts[index];
				}
			if (PointInVolume(t,mesh.verts[mesh.faces[i].v[k]],tv.x,tv.y,tv.z,tm,box)==1.0f) {
//			if (1){
				in++;
				if (selType==SEL_CROSSING) break;
			} else {
				if (selType==SEL_WINDOW) goto nextFace;
				}
			}
		
		if (in) {
			if (method==SEL_SUBTRACT) {
				mesh.faceSel.Clear(i);
			} else {
				mesh.faceSel.Set(i);
				}
			}

		nextFace:;

		if (invert) mesh.faceSel.Set(i,!mesh.faceSel[i]);
		}
	}




void SelMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{

	rt = t;
	pblock2->GetValue (sel_volume,t,vol,FOREVER);

	if (ip != NULL && curMod == this)
		{
		ModContextList mcList;
		INodeTab nodes;
		if (mc.localData == NULL)
			{

			ip->GetModContexts(mcList,nodes);

//add a new inode to trackview
			ITrackViewNode *tvr = ip->GetTrackViewRootNode();
			ITrackViewNode *global = tvr->GetNode(Class_ID(0xb27e9f2a, 0x73fad370));
			ITrackViewNode *tvroot = global->GetNode(MCONTAINER_TVNODE_CLASS_ID);
			if (!tvroot) 
				{
				ITrackViewNode *mcontainer =  CreateITrackViewNode();
				global->AddNode(mcontainer,GetString(IDS_PW_VOLDATA),MCONTAINER_TVNODE_CLASS_ID);
				tvroot = mcontainer;
				}
//add a new a container
//			ITrackViewNode *container = CreateITrackViewNode();
			container = CreateITrackViewNode(TRUE);
			tvroot->AddNode(container,GetString(IDS_PW_VOLDATA),CONTAINER_TVNODE_CLASS_ID);
			for (int i = 0; i < nodes.Count(); i++)
				{
				container->AddController(nodes[i]->GetTMController(),nodes[i]->GetName(),SELNODE_TVNODE_CLASS_ID);
				SelModData *d  = new SelModData(i);
				mcList[i]->localData = d;
				}
			container->RegisterTVNodeNotify(notify);

//create a back pointer to the container entry				
//return and call notify again to force another update
			NotifyDependents(FOREVER, OBJ_CHANNELS, REFMSG_CHANGE);

			Interval valid;
			valid.SetEmpty();
			os->obj->UpdateValidity(GEOM_CHAN_NUM,valid); // Have to do this to get it to evaluate
			os->obj->UpdateValidity(TOPO_CHAN_NUM,valid); // Have to do this to get it to evaluate
			return;
			}
		else 
			{
			SelModData *d  = (SelModData *)mc.localData;

			if ( d->id == -1)
				{
				ip->GetModContexts(mcList,nodes);

//add a new inode to trackview
			ITrackViewNode *tvr = ip->GetTrackViewRootNode();
			ITrackViewNode *global = tvr->GetNode(Class_ID(0xb27e9f2a, 0x73fad370));
			ITrackViewNode *tvroot = global->GetNode(MCONTAINER_TVNODE_CLASS_ID);
			if (!tvroot) 
				{
				ITrackViewNode *mcontainer =  CreateITrackViewNode();
				global->AddNode(mcontainer,GetString(IDS_PW_VOLDATA),MCONTAINER_TVNODE_CLASS_ID);
				tvroot = mcontainer;
				}
//add a new a container
//			ITrackViewNode *container = CreateITrackViewNode();
				container = CreateITrackViewNode(TRUE);
				tvroot->AddNode(container,GetString(IDS_PW_VOLDATA),CONTAINER_TVNODE_CLASS_ID);
				for (int i = 0; i < nodes.Count(); i++)
					{
					container->AddController(nodes[i]->GetTMController(),nodes[i]->GetName(),SELNODE_TVNODE_CLASS_ID);
//					SelModData *d  = new SelModData(i);
//					mcList[i]->localData = d;
					d->id = i;
					}
				container->RegisterTVNodeNotify(notify);
//create a back pointer to the container entry				
//return and call notify again to force another update
				NotifyDependents(FOREVER, OBJ_CHANNELS, REFMSG_CHANGE);

				Interval valid;
				valid.SetEmpty();
				os->obj->UpdateValidity(GEOM_CHAN_NUM,valid); // Have to do this to get it to evaluate
				os->obj->UpdateValidity(TOPO_CHAN_NUM,valid); // Have to do this to get it to evaluate
//				ip->RedrawViews(t);
				if (vol == SEL_MESH_OBJECT) return;
				}
			}



		}

	if ((ip && curMod == this) && (mc.localData == NULL))
		{
		NotifyDependents(FOREVER, OBJ_CHANNELS, REFMSG_CHANGE);
		Interval valid;
		valid.SetEmpty();
		os->obj->UpdateValidity(GEOM_CHAN_NUM,valid); // Have to do this to get it to evaluate
		os->obj->UpdateValidity(TOPO_CHAN_NUM,valid); // Have to do this to get it to evaluate
		return;
		}


	if (container == NULL)
		{
		if (vol == SEL_MESH_OBJECT) 
			{
			SelModData *d  = (SelModData *) mc.localData;
			if ((d!= NULL) && (d->selfNode !=NULL))
				{
				Interface *ip = GetCOREInterface();
				ITrackViewNode *tvr = ip->GetTrackViewRootNode();
				ITrackViewNode *global = tvr->GetNode(Class_ID(0xb27e9f2a, 0x73fad370));
				ITrackViewNode *tvroot = global->GetNode(MCONTAINER_TVNODE_CLASS_ID);
				if (!tvroot) 
					{
					ITrackViewNode *mcontainer =  CreateITrackViewNode();
					global->AddNode(mcontainer,GetString(IDS_PW_VOLDATA),MCONTAINER_TVNODE_CLASS_ID);
					tvroot = mcontainer;
					}
//add a new a container
				container = CreateITrackViewNode(TRUE);
				tvroot->AddNode(container,GetString(IDS_PW_VOLDATA),CONTAINER_TVNODE_CLASS_ID);
				container->AddController(d->selfNode->GetTMController(),d->selfNode->GetName(),SELNODE_TVNODE_CLASS_ID);
				d->id = 0;
				container->RegisterTVNodeNotify(notify);
				}
			else
				return;
			}
		}

	Interval valid = LocalValidity(t);
//build local data now
	pblock2->GetValue (sel_level,t,level,FOREVER);
	pblock2->GetValue (sel_method,t,method,FOREVER);
	pblock2->GetValue (sel_type,t,selType,FOREVER);
	pblock2->GetValue (sel_invert,t,invert,FOREVER);
	pblock2->GetValue (sel_map,t,map,FOREVER);
	pblock2->GetValue (sel_matid, t, matID, FOREVER);
	matID--;
	pblock2->GetValue (sel_smGroup, t, smG, FOREVER);
	pblock2->GetValue (sel_map_channel,t,channel,FOREVER);

	pblock2->GetValue (sel_autofit,t,autoFit,FOREVER);

	pblock2_afr->GetValue (sel_use_ar, t, useAR, FOREVER);
	pblock2_afr->GetValue (sel_falloff, t, falloff, FOREVER);
	pblock2_afr->GetValue (sel_pinch, t, pinch, FOREVER);
	pblock2_afr->GetValue (sel_bubble, t, bubble, FOREVER);

	targnode = NULL;
	tmap = NULL;

	assert(os->obj->IsSubClassOf(triObjectClassID));
	TriObject *obj = (TriObject*)os->obj;
	Mesh &mesh = obj->GetMesh();	


	TriObject *collapsedtobj = NULL;
	
	//is texture selection
	if (vol == SEL_TEXTURE) {
		pblock2->GetValue(sel_texture,t,tmap,FOREVER);
		if (tmap)
			tmap->LoadMapFiles(t);
	    float blur = 0.0f;
		shadeContext.scale = 1.0f;
		shadeContext.duvw  = Point3(blur/10.0f+0.001f,blur/10.0f+0.001f,0.0f);
		shadeContext.dpt = Point3(blur/10.0f+0.001f,blur/10.0f+0.001f,blur/10.0f+0.001f);
		shadeContext.curTime = t;
		if (uvwList.Count() != os->obj->NumPoints())
			uvwList.SetCount(os->obj->NumPoints());
		int currentChannel;
		currentChannel = map ? 0 : channel;
	
		TVFace *tvFace = mesh.mapFaces(currentChannel);
		Point3 *tVerts = NULL;
		if (tvFace!= NULL) tVerts= mesh.mapVerts(currentChannel);
		Tab<int>ctList;
		ctList.SetCount(os->obj->NumPoints());

		for (int i=0; i<mesh.getNumVerts(); i++) 
			{
			Point3 tv(0.0f,0.0f,0.0f);
			ctList[i] = 0;
			uvwList[i] = tv;
			}
		if  (tvFace != NULL)
			{
			Point3 tv(0.0f,0.0f,0.0f);
			for (int j = 0; j < mesh.numFaces; j++)
				{
				for (int k = 0; k < 3; k++)
					{
					int index = mesh.faces[j].v[k];
					int tindex = tvFace[j].t[k];
					if (ctList[index] ==0)
						uvwList[index] = tVerts[tindex];
					ctList[index] += 1;
					}
				}
			}
//		for (i=0; i<mesh.getNumVerts(); i++) 
//			uvwList[i] = uvwList[i]/float(ctList[i]);


		}
	else if ((vol == SEL_MESH_OBJECT) && (level != SEL_OBJECT))
		{
//is object
		pblock2->GetValue(sel_node,t,targnode,FOREVER);
		msh = NULL;
		if (targnode != NULL)
			{
			sos = targnode->EvalWorldState(t);
			sos.obj->GetDeformBBox(rt,bbox);

//is spline
			if (sos.obj->SuperClassID()==SHAPE_CLASS_ID)
				{
				pathOb = NULL;
				pathOb = (ShapeObject*)sos.obj;
				pathOb->MakePolyShape(t, workShape);
				}
			else if (sos.obj->IsParticleSystem())
				{
	//is particle
//				sos.obj->Eval(t);
				pobj = (SimpleParticle*)sos.obj;
				pobj->UpdateParticles(t, targnode);
				}
			else
				{
				//is object

				if (sos.obj->IsSubClassOf(triObjectClassID))
					{
					TriObject *tobj = (TriObject*)sos.obj;
					msh = &tobj->GetMesh();
					}
//collapse it to a mesh
				else
					{
					if (sos.obj->CanConvertToType(triObjectClassID))
						{
//						TriObject *tobj;
						collapsedtobj = (TriObject*) sos.obj->ConvertToType(t,triObjectClassID);
						msh = &collapsedtobj->GetMesh();
						}
					}

				}
			}
		}



	if ((vol== SEL_MESH_OBJECT) && (level != SEL_OBJECT))
		{
	    sMyEnumProc dep;              
		EnumDependents(&dep);
		SelfNode = dep.Nodes[0];
		Interval iv;
//check if local data present if so use it
		ntm = SelfNode->GetObjectTM(t,&iv);
//		Object *o = SelfNode->GetObjectRef();
//		INode *node;
//		pblock2->GetValue(sel_node,0,node,FOREVER);

//build box hit list
				//is object
		if (msh != NULL)
			{
	
			if (boxList.Count() != msh->numFaces)
				{
				boxList.SetCount(msh->numFaces);
				box3DList.SetCount(msh->numFaces);
				normList.SetCount(msh->numFaces);
				}
//			Point3 p3;
			for (int i = 0; i < msh->numFaces; i++)
				{
				boxList[i].SetEmpty();
				box3DList[i].Init();
				Point3 pnorm[3];
				for (int j = 0; j < 3; j++)
					{
					Point2 p;
					int index = msh->faces[i].v[j];
//					p3 = msh->verts[index];
					pnorm[j] = msh->verts[index];;
					p.x = msh->verts[index].y;
					p.y = msh->verts[index].z;
					boxList[i] += p;
					box3DList[i] += pnorm[j];
					}
				box3DList[i].EnlargeBy(falloff);
				normList[i] = Normalize(pnorm[1]-pnorm[0])^(pnorm[2]-pnorm[1]); 
				}
			}


		rt = t;

		if (mc.localData!= NULL)
			{
			SelModData *d  = (SelModData *) mc.localData;
//			Control *c = container->GetController(d->id);
//			ntm.IdentityMatrix();
//			c->GetValue(t,&ntm,valid,CTRL_RELATIVE);
			if (d->selfNode)
				ntm = d->selfNode->GetObjectTM(t,&iv);
			else
				{
				d->selfNode = SelfNode;
				ntm = d->selfNode->GetObjectTM(t,&iv);
				}
//			valid &= c->Validity(t);

			if (targnode != NULL)
				{
//				Matrix3 *tm = os->GetTM();
				otm = targnode->GetObjectTM(t,&iv);
				otm = Inverse(otm);
//				otm = ntm * otm;
				otm = ntm * otm;
				}

			}

		}
	else
		{
		boxList.ZeroCount();
		box3DList.ZeroCount();
		normList.ZeroCount();
		}
//copied the mc box into our box so we cause problems later up in the stack.
	if ( (mc.box!=NULL)  && (flags&CONTROL_CHANGEFROMBOX) ) {
		mcBox.pmin = mc.box->pmin ;
		mcBox.pmax = mc.box->pmax ;
		flags &= ~CONTROL_CHANGEFROMBOX;
		}


	// Prepare the controller and set up mats
	if (!tmControl || (flags&CONTROL_OP)) InitControl (mc, obj, t);
	Matrix3 ctm, tm;
	ctm = CompMatrix(t,&mc,NULL,TRUE,FALSE);
	tm = Inverse(ctm);
	
//	Box3 mcbox = *mc.box;
//	FixupBox(mcbox);
//	Box3 mcbox = *mc.box;
	FixupBox(mcBox);


	if (obj->GetMesh().vertSel.GetSize() != obj->GetMesh().getNumVerts()) 
		{
		obj->GetMesh().vertSel.SetSize(obj->GetMesh().getNumVerts(),1);
		}
	if (obj->GetMesh().faceSel.GetSize() != obj->GetMesh().getNumFaces()) 
		obj->GetMesh().faceSel.SetSize(obj->GetMesh().getNumFaces(),1);

		
	switch (level) {
		case SEL_OBJECT:
			obj->GetMesh().selLevel = MESH_OBJECT;
			obj->GetMesh().ClearDispFlag(DISP_VERTTICKS|DISP_SELVERTS|DISP_SELFACES);
			break;

		case SEL_VERTEX:
			obj->GetMesh().selLevel = MESH_VERTEX;
			obj->GetMesh().SetDispFlag(DISP_VERTTICKS|DISP_SELVERTS);
			SelectVertices(obj->GetMesh(), tm, ctm, mcBox, t);
			break;

		case SEL_FACE:
			obj->GetMesh().selLevel = MESH_FACE;
			obj->GetMesh().SetDispFlag(DISP_SELFACES);
			SelectFaces(t, obj->GetMesh(), tm, mcBox);
			break;
		}

	if (collapsedtobj) collapsedtobj->DeleteThis();

	obj->UpdateValidity(SELECT_CHAN_NUM,valid);
	obj->UpdateValidity(GEOM_CHAN_NUM,valid); // Have to do this to get it to evaluate
	obj->UpdateValidity(TOPO_CHAN_NUM,valid); // Have to do this to get it to evaluate
	obj->UpdateValidity(SUBSEL_TYPE_CHAN_NUM,FOREVER);
	}


int SelMod::SubNumToRefNum(int subNum)
	{
	switch (subNum) {
		case TM_REF:
		case POS_REF: return subNum;
		default:      return -1;
		}
	}

BOOL SelMod::AssignController(Animatable *control,int subAnim)
	{
	ReplaceReference(subAnim,(Control*)control);
	NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	return TRUE;
	}

RefTargetHandle SelMod::GetReference(int i)
	{
	switch (i) {
		case PBLOCK_REF: return pblock2;
		case TM_REF: return tmControl;
		case POS_REF: return posControl;
		case PBLOCK_AFR_REF: return pblock2_afr;
		default: return NULL;
		}
	}

void SelMod::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case PBLOCK_REF: pblock2 = (IParamBlock2*)rtarg; break;
		case TM_REF: tmControl = (Control*)rtarg; break;
		case POS_REF: posControl = (Control*)rtarg; break;
		case PBLOCK_AFR_REF: pblock2_afr = (IParamBlock2*)rtarg; break;
		}
	}

Animatable* SelMod::SubAnim(int i)
	{
	switch (i) {
		case PBLOCK_REF: return pblock2;
		case TM_REF: return tmControl;
		case POS_REF: return posControl;
		case PBLOCK_AFR_REF: return pblock2_afr;
		default: return NULL;
		}
	}

TSTR SelMod::SubAnimName(int i)
	{
	switch (i) {
		case PBLOCK_REF: return TSTR(GetString(IDS_RB_PARAMETERS));
		case TM_REF: return TSTR(GetString(IDS_RB_APPARATUS));
		case POS_REF: return TSTR(GetString(IDS_RB_CENTER));
		default: return TSTR(_T(""));
		}
	}

RefResult SelMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
//			ivalid.SetEmpty();
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
			if (hTarget == pblock2)
				{
				ParamID changing_param = pblock2->LastNotifyParamID();

				sel_param_blk.InvalidateUI(changing_param);
			// notify our dependents that we've changed
//				NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);

//				NotifyChanged();
				}
			if (hTarget == pblock2_afr) 
				{
				ParamID changing_param = pblock2_afr->LastNotifyParamID();

				sel_afr_blk.InvalidateUI(changing_param);
			// notify our dependents that we've changed
//				NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
				}

/*
			if (pmapParam && pmapParam->GetParamBlock()==pblock) {
				pmapParam->Invalidate();
			}
			if (pmapParam2 && pmapParam2->GetParamBlock()==pblock) {
				pmapParam2->Invalidate();
			}
*/
			break;
/*
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {				
				case 0:
				default: gpd->dim = defaultDim; break;
				}			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {				
				case 0:
				default: gpn->name = TSTR(_T("")); break;
				}
			return REF_STOP; 
			}
*/
		}
	return REF_SUCCEED;
	}


// --- Gizmo transformations ------------------------------------------

void SelMod::Move(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin) 
	{	
#ifdef DESIGN_VER
	t=0;
#endif
	if (ip && ip->GetSubObjectLevel()==1) {		
		SetXFormPacket pckt(val,partm,tmAxis);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
	} else {
		Matrix3 ptm = partm;				
		tmControl->GetValue(t,&ptm,FOREVER,CTRL_RELATIVE);
		posControl->SetValue(t,
			VectorTransform(tmAxis*Inverse(ptm),val),TRUE,CTRL_RELATIVE);

		}
	}


void SelMod::Rotate(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Quat& val, BOOL localOrigin) 
	{
#ifdef DESIGN_VER
	t=0;
#endif	
	SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
	tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	}

void SelMod::Scale(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin) 
	{
#ifdef DESIGN_VER
	t=0;
#endif	
	SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
	tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	}


Matrix3 SelMod::CompMatrix(
		TimeValue t,ModContext *mc, Matrix3 *ntm, 
		BOOL scale, BOOL offset)
	{
	Matrix3 tm(1);
	Interval valid;
	if (autoFit)
		{
		Box3 mcbox;
		if (mc && mc->box) mcbox = *mc->box;
		FixupBox(mcbox);

		if (mc && scale && (flags&CONTROL_USEBOX)) {
			tm.Scale(mcbox.Width()/2.0f);
			tm.Translate(mcbox.Center());
			}
		}
	else
		{

//	Box3 mcbox;
//	if (mc && mc->box) mcbox = *mc->box;
		FixupBox(mcBox);

		if (mc && scale && (flags&CONTROL_USEBOX)) {
			tm.Scale(mcBox.Width()/2.0f);
			tm.Translate(mcBox.Center());
			}
		}

	
	if (posControl && offset) {
		Matrix3 tmc(1);
		posControl->GetValue(t,&tmc,valid,CTRL_RELATIVE);		
		tm = tm * tmc;
		}
	if (tmControl) {
		Matrix3 tmc(1);
		tmControl->GetValue(t,&tmc,valid,CTRL_RELATIVE);		
		tm = tm * tmc;
		}

	if (mc && mc->tm) {
		tm = tm * Inverse(*mc->tm);
		}
	if (ntm) {
		tm = tm * *ntm;
		}
	return tm;
	}


void SelMod::DoIcon(PolyLineProc& lp,BOOL sel) {
	switch (vol) {
	case SEL_BOX: DoBoxIcon(sel,2.0f,lp); break;
	case SEL_SPHERE: DoSphereIcon(sel,1.0f,lp); break;
	case SEL_CYLINDER: DoCylinderIcon(sel,1.0f,2.0f,lp); break;
	}
}

static Box3 unitBox(Point3(-0.5f,-0.5f,-0.5f),Point3(0.5f,0.5f,0.5f));
 
int SelMod::HitTest (TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc) 
	{	


	int savedLimits;	
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);
	Matrix3 modmat, ntm = inode->GetObjectTM(t);
	DrawLineProc lp(gw);
		
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->clearHitCode();
	
	if (ip && ip->GetSubObjectLevel()==1) {
		modmat = CompMatrix(t,mc,&ntm,TRUE,FALSE);
		gw->setTransform(modmat);
		DoIcon(lp,FALSE);
		}

	if (ip && (
		ip->GetSubObjectLevel()==1 ||
		ip->GetSubObjectLevel()==2)) {
		modmat = CompMatrix(t,mc,&ntm);
		gw->setTransform(modmat);
		DrawCenterMark(lp,unitBox);		
		}
	
	gw->setRndLimits(savedLimits);	
	if (gw->checkHitCode()) {
		vpt->LogHit(inode, mc, gw->getHitDistance(), 0, NULL); 
		return 1;
		}
	return 0;
	}

int SelMod::Display(
		TimeValue t, INode* inode, ViewExp *vpt, int flags, 
		ModContext *mc) 
	{	
	GraphicsWindow *gw = vpt->getGW();
	// Transform the gizmo with the node.
#ifdef DESIGN_VER
	TimeValue rt = GetCOREInterface()->GetTime();
	Matrix3 modmat, ntm = inode->GetObjectTM(rt);
#else
	Matrix3 modmat, ntm = inode->GetObjectTM(t);
#endif
	DrawLineProc lp(gw);

	modmat = CompMatrix(t,mc,&ntm,TRUE,FALSE);	
	gw->setTransform(modmat);	
	DoIcon(lp, ip&&ip->GetSubObjectLevel()==1);

	modmat = CompMatrix(t,mc,&ntm);
	gw->setTransform(modmat);
	if (ip && (
		ip->GetSubObjectLevel()==1 ||
		ip->GetSubObjectLevel()==2)) {
		//gw->setColor(LINE_COLOR, (float)1.0, (float)1.0, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
	} else {
		//gw->setColor( LINE_COLOR, (float).85, (float).5, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
		}
	DrawCenterMark(lp,unitBox);
	return 0;	
	}

void SelMod::GetWorldBoundBox(
		TimeValue t,INode* inode, ViewExp *vpt, Box3& box, 
		ModContext *mc) 
	{
	// Need the correct bound box for proper damage rect calcs.
#ifdef DESIGN_VER
	TimeValue rt = GetCOREInterface()->GetTime();
	Matrix3 modmat, ntm = inode->GetObjectTM(rt);
#else
	Matrix3 modmat, ntm = inode->GetObjectTM(t);	
#endif
	modmat = CompMatrix(t,mc,&ntm,TRUE,FALSE);		
	BoxLineProc bproc(&modmat);
	DoIcon(bproc,FALSE);

	modmat = CompMatrix(t,mc,&ntm);
	DrawCenterMark(bproc,unitBox);

	box = bproc.Box();	
	}

void SelMod::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{	
	Matrix3 modmat, ntm = node->GetObjectTM(t);		
	modmat = CompMatrix(t,mc,&ntm);
	cb->Center(modmat.GetTrans(),0);	
	}

void SelMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Matrix3 ntm = node->GetObjectTM(t), modmat;
	modmat = CompMatrix(t,mc,&ntm);
	cb->TM(modmat,0);
	}

void SelMod::ActivateSubobjSel(int level, XFormModes& modes )
	{	
	switch (level) {
		case 1: // Modifier box
			modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,NULL);
			break;
		case 2: // Modifier Center
			modes = XFormModes(moveMode,NULL,NULL,NULL,NULL,NULL);
			break;
		}
	NotifyDependents(FOREVER,PART_DISPLAY,REFMSG_CHANGE);
	}


//----------------------------------------------------------------



#define NUM_SEGS	16

static void DoSphereIcon(BOOL sel,float radius, PolyLineProc& lp)
	{
	float u;
	Point3 pt[3];
	
	if (sel) //lp.SetLineColor(1.0f,1.0f,0.0f);
		lp.SetLineColor(GetUIColor(COLOR_SEL_GIZMOS));
	else //lp.SetLineColor(0.85f,0.5f,0.0f);		
		lp.SetLineColor(GetUIColor(COLOR_GIZMOS));
	
	// XY
	pt[0] = Point3(radius,0.0f,0.0f);
	for (int i=1; i<=NUM_SEGS; i++) {
		u = float(i)/float(NUM_SEGS) * TWOPI;
		pt[1].x = (float)cos(u) * radius;
		pt[1].y = (float)sin(u) * radius;
		pt[1].z = 0.0f;
		lp.proc(pt,2);
		pt[0] = pt[1];
		}

	// YZ	
	pt[0] = Point3(0.0f,radius,0.0f);
	for (i=1; i<=NUM_SEGS; i++) {
		u = float(i)/float(NUM_SEGS) * TWOPI;
		pt[1].y = (float)cos(u) * radius;
		pt[1].z = (float)sin(u) * radius;
		pt[1].x = 0.0f;
		lp.proc(pt,2);
		pt[0] = pt[1];
		}
	
	// ZX	
	pt[0] = Point3(0.0f,0.0f,radius);
	for (i=1; i<=NUM_SEGS; i++) {		
		u = float(i)/float(NUM_SEGS) * TWOPI;
		pt[1].z = (float)cos(u) * radius;
		pt[1].x = (float)sin(u) * radius;
		pt[1].y = 0.0f;
		lp.proc(pt,2);
		pt[0] = pt[1];
		}
	}

static void DoCylinderIcon(BOOL sel,float radius, float height, PolyLineProc& lp)
	{
	float u;
	Point3 pt[5], opt;
	
	if (sel) //lp.SetLineColor(1.0f,1.0f,0.0f);
		lp.SetLineColor(GetUIColor(COLOR_SEL_GIZMOS));
	else //lp.SetLineColor(0.85f,0.5f,0.0f);		
		lp.SetLineColor(GetUIColor(COLOR_GIZMOS));
	
	height *= 0.5f;
		
	opt = Point3(radius,0.0f,-height);
	for (int i=1; i<=NUM_SEGS; i++) {
		u = float(i)/float(NUM_SEGS) * TWOPI;
		pt[0]   = opt;
		
		pt[1].x = (float)cos(u) * radius;
		pt[1].y = (float)sin(u) * radius;
		pt[1].z = -height;
		
		pt[2].x = pt[1].x;
		pt[2].y = pt[1].y;
		pt[2].z = height;

		pt[3]   = opt;
		pt[3].z = height;
		
		lp.proc(pt,4);		
		opt = pt[1];
		}

	}


static int lStart[12] = {0,1,3,2,4,5,7,6,0,1,2,3};
static int lEnd[12]   = {1,3,2,0,5,7,6,4,4,5,6,7};

static void DoBoxIcon(BOOL sel,float length, PolyLineProc& lp)
	{
	Point3 pt[3];
	
	length *= 0.5f;
	Box3 box;
	box.pmin = Point3(-length,-length,-length);
	box.pmax = Point3( length, length, length);

	if (sel) //lp.SetLineColor(1.0f,1.0f,0.0f);
		lp.SetLineColor(GetUIColor(COLOR_SEL_GIZMOS));
	else //lp.SetLineColor(0.85f,0.5f,0.0f);		
		lp.SetLineColor(GetUIColor(COLOR_GIZMOS));
	
	for (int i=0; i<12; i++) {
		pt[0] = box[lStart[i]];
		pt[1] = box[lEnd[i]];
		lp.proc(pt,2);
		}
	}
/*
static int StraightEnables[] = {
	IDC_MS_AR_USE, IDC_FALLOFF_LABEL,
	IDC_PINCH_LABEL, IDC_BUBBLE_LABEL,
	IDC_FARLEFTLABEL, IDC_FARRIGHTLABEL,
	IDC_NEARLABEL
};

static int SpinnerEnables[] = { IDC_FALLOFFSPIN, IDC_PINCHSPIN, IDC_BUBBLESPIN };
*/
void SelMod::DisableAffectRegion (TimeValue t) 
{
//mesh, face/object/ subtract/add
//int selLevel, vol;
//pblock2->GetValue (sel_level, t, selLevel, FOREVER);
//pblock2->GetValue (sel_volume, t, vol, FOREVER);

//if ((vol == 3) || (selLevel == 0)|| (selLevel == 2))
//if ((level == 0)|| (level == 2))
	{
	IParamMap2 *afrmap = pblock2_afr->GetMap();
	afrmap->Enable(sel_use_ar, FALSE);
	afrmap->Enable(sel_falloff, FALSE);
	afrmap->Enable(sel_pinch, FALSE);
	afrmap->Enable(sel_bubble, FALSE);
	}
}

void SelMod::EnableAffectRegion (TimeValue t) 
{
//int selLevel, vol;
int sl;
pblock2->GetValue (sel_level, t, sl, FOREVER);
int v;
pblock2->GetValue (sel_volume, t, v, FOREVER);
BOOL use;

//if ((vol!=3) && (selLevel == 1))
//if ( (level == 1))
//watje 5-26-99
if ( (v < 4 ) && (sl == 1))
	{

	pblock2_afr->GetValue (sel_use_ar, t, use, FOREVER);


	IParamMap2 *afrmap = pblock2_afr->GetMap();
	afrmap->Enable(sel_use_ar, TRUE);
	if (useAR)
		{
		afrmap->Enable(sel_falloff, TRUE);
		afrmap->Enable(sel_pinch, TRUE);
		afrmap->Enable(sel_bubble, TRUE);
		}
	}

//HWND hWnd = pmap->GetHWnd();

//EnableWindow (GetDlgItem (hWnd, IDC_MS_AR_USE), FALSE);
//pmap->Enable(sel_use_ar, TRUE);
//pmap->Enable(sel_falloff, TRUE);
//pmap->Enable(sel_pinch, TRUE);
//pmap->Enable(sel_bubble, TRUE);


}
/*
void SelMod::EnableAffectRegion (TimeValue t) {
//	if (!pmapParam2) return;
//	HWND hWnd = pmapParam2->GetHWnd();

	IParamMap2* pmap = pblock2_afr->GetMap();
	HWND hWnd = pmap->GetHWnd();
	int selLevel, method;
	pblock2->GetValue (sel_level, t, selLevel, FOREVER);
	pblock2->GetValue (sel_method, t, method, FOREVER);
	BOOL enable = (selLevel==1) && (method==0);
	int vol;
	pblock2->GetValue (sel_volume, t, vol, FOREVER);
	if (vol == 3) enable = FALSE;
		
	EnableWindow (GetDlgItem (hWnd, StraightEnables[0]), enable);
	int useAR = FALSE;
	if (enable) pblock2_afr->GetValue (sel_use_ar, t, useAR, FOREVER);
	enable = useAR;

	int i;
	for (i=1; i<7; i++) EnableWindow (GetDlgItem (hWnd, StraightEnables[i]), enable);

//	ISpinnerControl *spin;
//	for (i=0; i<3; i++) {
//	pmap->Enable(sel_falloff, enable);
//	pmap->Enable(sel_pinch, enable);
//	pmap->Enable(sel_bubble, enable);
//		spin = GetISpinner (GetDlgItem (hWnd, SpinnerEnables[i]));
//		spin->Enable (enable);
//		ReleaseISpinner (spin);
//	}
}

*/
#define ID_CHUNK 0x1000
#define NODE_CHUNK 0x1010

IOResult SelMod::SaveLocalData(ISave *isave, LocalModData *pld)
{
SelModData *p;
IOResult	res;
ULONG		nb;

p = (SelModData*)pld;

isave->BeginChunk(ID_CHUNK);
res = isave->Write(&p->id, sizeof(int), &nb);
isave->EndChunk();


ULONG id = isave->GetRefID(p->selfNode);

isave->BeginChunk(NODE_CHUNK);
isave->Write(&id,sizeof(ULONG),&nb);
isave->EndChunk();


return IO_OK;
}

IOResult SelMod::LoadLocalData(ILoad *iload, LocalModData **pld)

{
	IOResult	res;
	ULONG		nb;

	int id;
	SelModData *p= new SelModData();
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case ID_CHUNK:
				iload->Read(&id,sizeof(int), &nb);
				p->id = id;
				break;
			case NODE_CHUNK:
				ULONG id;
				iload->Read(&id,sizeof(ULONG), &nb);
				if (id!=0xffffffff)
					{
					iload->RecordBackpatch(id,(void**)&p->selfNode);
					}
				break;

			}
		iload->CloseChunk();
		if (res!=IO_OK) return res;
		}

	*pld = p;


return IO_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\resettm.cpp ===
/**********************************************************************
 *<
	FILE: resettm.cpp

	DESCRIPTION: A reset xform utility

	CREATED BY: Rolf Berteig

	HISTORY: created June 28, 1996

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "utilapi.h"
#include "istdplug.h"
#include "modstack.h"
#include "simpmod.h"

class ResetXForm : public UtilityObj {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;
		
		ResetXForm();
		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void SelectionSetChanged(Interface *ip,IUtil *iu);
		void DeleteThis() {}		
		void ResetSel();

	};
static ResetXForm theResetXForm;

class ResetXFormClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theResetXForm;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_RESETXFORM_CLASS);}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(RESET_XFORM_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};

static ResetXFormClassDesc resetXFormDesc;
ClassDesc* GetResetXFormDesc() {return &resetXFormDesc;}


static BOOL CALLBACK ResetXFormDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			theResetXForm.hPanel = hWnd;
			theResetXForm.
				SelectionSetChanged(theResetXForm.ip,theResetXForm.iu);
			break;
		
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					theResetXForm.iu->CloseUtility();
					break;

				case IDC_RESETTM_SELECTED:
					theResetXForm.ResetSel();
					break;
				}
			break;
		
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theResetXForm.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}	


ResetXForm::ResetXForm()
	{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;	
	}

void ResetXForm::BeginEditParams(Interface *ip,IUtil *iu) 
	{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_RESETXFORM_PANEL),
		ResetXFormDlgProc,
		GetString(IDS_RB_RESETXFORM),
		0);
	}
	
void ResetXForm::EndEditParams(Interface *ip,IUtil *iu) 
	{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
	}

void ResetXForm::SelectionSetChanged(Interface *ip,IUtil *iu)
	{
	if (ip->GetSelNodeCount()) {
		BOOL res = FALSE;
		for (int i=0; i<ip->GetSelNodeCount(); i++) {
			INode *node = ip->GetSelNode(i);
			if (!node->IsGroupMember() && !node->IsGroupHead()) {
				res = TRUE;
				break;
				}
			}
		EnableWindow(GetDlgItem(hPanel,IDC_RESETTM_SELECTED),res);
	} else {
		EnableWindow(GetDlgItem(hPanel,IDC_RESETTM_SELECTED),FALSE);
		}
	}

static BOOL SelectedAncestor(INode *node)
	{
	if (!node->GetParentNode()) return FALSE;
	if (node->GetParentNode()->Selected()) return TRUE;
	else return SelectedAncestor(node->GetParentNode());
	}

void ResetXForm::ResetSel()
	{
	//theHold.Begin();

	for (int i=0; i<ip->GetSelNodeCount(); i++) {
		INode *node = ip->GetSelNode(i);
		if (node->IsGroupMember() || node->IsGroupHead()) continue;
		if (SelectedAncestor(node)) continue;

		Matrix3 ntm, ptm, rtm(1), piv(1), tm;
		
		// Get Parent and Node TMs
		ntm = node->GetNodeTM(ip->GetTime());
		ptm = node->GetParentTM(ip->GetTime());
		
		// Compute the relative TM
		ntm = ntm * Inverse(ptm);
		
		// The reset TM only inherits position
		rtm.SetTrans(ntm.GetTrans());
		
		// Set the node TM to the reset TM		
		tm = rtm*ptm;
		node->SetNodeTM(ip->GetTime(), tm);

		// Compute the pivot TM
		piv.SetTrans(node->GetObjOffsetPos());
		PreRotateMatrix(piv,node->GetObjOffsetRot());
		ApplyScaling(piv,node->GetObjOffsetScale());
		
		// Reset the offset to 0
		node->SetObjOffsetPos(Point3(0,0,0));
		node->SetObjOffsetRot(IdentQuat());
		node->SetObjOffsetScale(ScaleValue(Point3(1,1,1)));

		// Take the position out of the matrix since we don't reset position
		ntm.NoTrans();

		// Apply the offset to the TM
		ntm = piv * ntm;

		// Apply a derived object to the node's object
		Object *obj = node->GetObjectRef();
		IDerivedObject *dobj = CreateDerivedObject(obj);
		
		// Create an XForm mod
		SimpleMod *mod = (SimpleMod*)ip->CreateInstance(
			OSM_CLASS_ID,
			Class_ID(CLUSTOSM_CLASS_ID,0));

		// Apply the transformation to the mod.
		SetXFormPacket pckt(ntm);
		mod->tmControl->SetValue(ip->GetTime(),&pckt);

		// Add the bend modifier to the derived object.
		dobj->SetAFlag(A_LOCK_TARGET); // RB 3/11/99: When the macro recorder is on the derived object will get deleted unless it is locked.
		dobj->AddModifier(mod);
		dobj->ClearAFlag(A_LOCK_TARGET);

		// Replace the node's object
		node->SetObjectRef(dobj);
		}
	
	//theHold.Accept(GetString(IDS_RB_RESETXFORM));
	GetSystemSetting(SYSSET_CLEAR_UNDO);
	ip->RedrawViews(ip->GetTime());
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\sinwave.cpp ===
/**********************************************************************
 *<
	FILE: sinwave.cpp

	DESCRIPTION:  Simple WSM

	CREATED BY: Rolf Berteig

	HISTORY: created 9 February, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

// in mods.cpp
extern HINSTANCE hInstance;


#define DEF_FLEX		float(1.0)


// This is the function we're usin'
float WaveFunc( float radius, TimeValue t, float amp, 
				float waveLen, float phase, float decay )
	{
	if (waveLen == float(0)) {
		waveLen = float(0.0000001);
		}
	return float( amp * sin( TWOPI * ( radius/waveLen + phase ) ) 
		* exp(-decay * (float)fabs(radius) ) );
	}

class WaveObject : public SimpleWSMObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
					
		WaveObject();		

		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
				
		// from object		
		int DoOwnSelectHilite() {return TRUE;}
		CreateMouseCallBack* GetCreateMouseCallBack();
		//int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);		

		// From SimpleObject		
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		// WaveObject stuff		
		virtual int DialogID()=0;
		virtual int Circles()=0;
	};

class SinWaveObject : public WaveObject {	
	public:				
		SinWaveObject();

		TCHAR *GetObjectName() {return GetString(IDS_RB_RIPPLE);}		
		Class_ID ClassID() {return Class_ID(SINEWAVE_OBJECT_CLASS_ID,0);}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		IOResult Load(ILoad *iload);

		// From WSMObject
		Modifier *CreateWSMMod(INode *node);
		
		// From SimpleObject
		void MakeCircle(TimeValue t, Mesh &mesh, int startVert, int& face, float radius,float a1,float a2,float w,float s, float d, int numCircleSegs);
		void BuildMesh(TimeValue t);

		// WaveObject stuff
		int DialogID() {return IDD_SINWAVEPARAM1;}
		int Circles() {return 10;}
	};

class LinWaveObject : public WaveObject {	
	public:		
		LinWaveObject();

		TCHAR *GetObjectName() { return GetString(IDS_RB_WAVE); }
		Class_ID ClassID() { return Class_ID(LINWAVE_OBJECT_CLASS_ID,0);}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);
		
		// From SimpleObject		
		void BuildMesh(TimeValue t);

		// WaveObject stuff
		int DialogID() {return IDD_LINWAVEPARAM1;}
		int Circles() {return 4;}
	};

//--- ClassDescriptor and class vars ---------------------------------


IObjParam *SinWaveObject::ip        = NULL;
IParamMap *SinWaveObject::pmapParam = NULL;
HWND       SinWaveObject::hSot      = NULL;

class SinWaveClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SinWaveObject; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_RIPPLE_CLASS); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(SINEWAVE_OBJECT_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetSpaceWarpCatString(SPACEWARP_CAT_GEOMDEF);}
	};

static SinWaveClassDesc swDesc;
ClassDesc* GetSinWaveObjDesc() { return &swDesc; }

class LinWaveClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new LinWaveObject; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_WAVE_CLASS); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(LINWAVE_OBJECT_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetSpaceWarpCatString(SPACEWARP_CAT_GEOMDEF);}
	};

static LinWaveClassDesc lwDesc;
ClassDesc* GetLinWaveObjDesc() { return &lwDesc; }


//--- SineWaveMod -----------------------------------------------------

class WaveMod : public SimpleWSMMod {
	public:		
		static IParamMap *pmapParam;

		WaveMod() {}
		WaveMod(INode *node,WaveObject *obj);		

		// From Animatable
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_WAVEMOD); }
		SClass_ID SuperClassID() { return WSM_CLASS_ID; }		
		void DeleteThis() {delete this;}
		void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void InvalidateUI() {if (pmapParam) pmapParam->Invalidate();}
	};

class SinWaveMod : public WaveMod {
	public:		
		
		SinWaveMod() {}
		SinWaveMod(INode *node,SinWaveObject *obj) : WaveMod(node,obj) {}

		// From Animatable		
		SClass_ID SuperClassID() { return WSM_CLASS_ID; }
		Class_ID ClassID() { return Class_ID(SINEWAVE_CLASS_ID,0); } 		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_RIPPLE_BINDING);}

		// From SimpleWSMMod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
	};

class LinWaveMod : public WaveMod {
	public:		
		
		LinWaveMod() {}
		LinWaveMod(INode *node,LinWaveObject *obj) : WaveMod(node,obj) {}

		// From Animatable		
		SClass_ID SuperClassID() { return WSM_CLASS_ID; }
		Class_ID ClassID() { return Class_ID(LINWAVE_CLASS_ID,0); } 		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_WAVEBINDING);}

		// From SimpleWSMMod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
	};

//--- ClassDescriptor and class vars ---------------------------------

class SinWaveModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) { return new SinWaveMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_RIPPLE_CLASS); }
	SClass_ID		SuperClassID() { return WSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(SINEWAVE_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");}
	};

static SinWaveModClassDesc swModDesc;
ClassDesc* GetSinWaveModDesc() { return &swModDesc; }

class LinWaveModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) { return new LinWaveMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_WAVE_CLASS); }
	SClass_ID		SuperClassID() { return WSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(LINWAVE_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");}
	};

static LinWaveModClassDesc lwModDesc;
ClassDesc* GetLinWaveModDesc() { return &lwModDesc; }

IParamMap *WaveMod::pmapParam = NULL;


//--- Object Space Modifier versions -----------------------------------------

class WaveOMod : public SimpleMod {
	public:		
		static IParamMap *pmapParam;

		WaveOMod();

		// From Animatable
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_WAVEMOD); }		
		void DeleteThis() {delete this;}
		void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);		
		
		// From SimpleMod		
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void InvalidateUI() {if (pmapParam) pmapParam->Invalidate();}

		virtual int DialogID()=0;
	};

class SinWaveOMod : public WaveOMod {
	public:
		// From Animatable		
		Class_ID ClassID() { return Class_ID(SINEWAVE_OMOD_CLASS_ID,0); } 		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_RIPPLE);}

		// From SimpleMod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
		int DialogID() {return IDD_SINWAVEOMODPARAM;}
	};


class LinWaveOMod : public WaveOMod {
	public:		
		// From Animatable		
		Class_ID ClassID() { return Class_ID(LINWAVE_OMOD_CLASS_ID,0); } 
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_WAVE);}

		// From SimpleMod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
		int DialogID() {return IDD_LINWAVEOMODPARAM;}
	};

//--- ClassDescriptor and class vars ---------------------------------

IParamMap *WaveOMod::pmapParam = NULL;


class SinWaveOModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SinWaveOMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_RIPPLE_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(SINEWAVE_OMOD_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static SinWaveOModClassDesc swOModDesc;
ClassDesc* GetSinWaveOModDesc() { return &swOModDesc; }

class LinWaveOModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) {return new LinWaveOMod;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_WAVE_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(LINWAVE_OMOD_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static LinWaveOModClassDesc lwOModDesc;
ClassDesc* GetLinWaveOModDesc() { return &lwOModDesc; }



//--- SineWaveObject Parameter map/block descriptors ------------------

#define PB_AMPLITUDE	0
#define PB_AMPLITUDE2	1
#define PB_WAVELEN		2
#define PB_PHASE		3
#define PB_DECAY		4

#define PB_CIRCLES		5
#define PB_SEGMENTS		6
#define PB_DIVISIONS	7

//
//
// Parameters

static ParamUIDesc descParamObj[] = {
	
	// Amplitude 1
	ParamUIDesc(
		PB_AMPLITUDE,
		EDITTYPE_UNIVERSE,
		IDC_AMPLITUDE,IDC_AMPSPINNER,
		-9999999.0f, 9999999.0f,
		SPIN_AUTOSCALE),	

	// Amplitude 2
	ParamUIDesc(
		PB_AMPLITUDE2,
		EDITTYPE_UNIVERSE,
		IDC_AMPLITUDE2,IDC_AMPSPINNER2,
		-9999999.0f, 9999999.0f,
		SPIN_AUTOSCALE),	

	// Wave Length
	ParamUIDesc(
		PB_WAVELEN,
		EDITTYPE_UNIVERSE,
		IDC_WAVELEN,IDC_WAVELENSPINNER,
		-9999999.0f, 9999999.0f,
		SPIN_AUTOSCALE),	

	// Phase
	ParamUIDesc(
		PB_PHASE,
		EDITTYPE_FLOAT,
		IDC_PHASE,IDC_PHASESPINNER,
		-9999999.0f, 9999999.0f,
		0.1f),
		
	// Decay
	ParamUIDesc(
		PB_DECAY,
		EDITTYPE_FLOAT,
		IDC_DECAY,IDC_DECAYSPINNER,
		0.0f, 9999999.0f,
		0.001f),
		
	// Circles
	ParamUIDesc(
		PB_CIRCLES,
		EDITTYPE_INT,
		IDC_CIRCLES,IDC_CIRCLESSPINNER,
		3.0f, 200.0f,
		0.1f),

	// Segments
	ParamUIDesc(
		PB_SEGMENTS,
		EDITTYPE_INT,
		IDC_SEGS,IDC_SEGSPINNER,
		3.0f, 200.0f,
		0.1f),
	
	// Divisions
	ParamUIDesc(
		PB_DIVISIONS,
		EDITTYPE_INT,
		IDC_DIVISIONS,IDC_DIVSPINNER,
		1.0f, 200.0f,
		0.1f)
	};
#define OBJPARAMDESC_LENGH 8


ParamBlockDescID descObjVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 } };

ParamBlockDescID descObjVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 } };

#define OBJPBLOCK_LENGTH	8


// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descObjVer0,7,0)
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_OBJVERSION	1
static ParamVersionDesc curVersion(descObjVer1,OBJPBLOCK_LENGTH,CURRENT_OBJVERSION);



//--- SineWaveObject methods ------------------------------------------


WaveObject::WaveObject()
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descObjVer1, OBJPBLOCK_LENGTH, CURRENT_OBJVERSION));
	assert(pblock);	
	}

void WaveObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapParam) {
		
		// Left over from last SinWave ceated
		pmapParam->SetParamBlock(pblock);
	} else {
		hSot = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_SINWAVE_SOT),
				DefaultSOTProc,
				GetString(IDS_RB_SOT), 
				(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descParamObj,OBJPARAMDESC_LENGH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(DialogID()),
			GetString(IDS_RB_PARAMETERS),
			0);		
		}
	}

void WaveObject::EndEditParams(IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {				
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	}



#if 0
class SinWaveMtl: public Material {
	public:
	SinWaveMtl();
	};
static SinWaveMtl swMtl;

#define SINEWAVE_R	float(0)
#define SINEWAVE_G	float(.5)
#define SINEWAVE_B	float(.5)

SinWaveMtl::SinWaveMtl():Material() {
	Kd[0] = SINEWAVE_R;
	Kd[1] = SINEWAVE_G;
	Kd[2] = SINEWAVE_B;
	Ks[0] = SINEWAVE_R;
	Ks[1] = SINEWAVE_G;
	Ks[2] = SINEWAVE_B;
	shininess = (float)0.0;
	shadeLimit = GW_WIREFRAME|GW_BACKCULL;
	selfIllum = (float)1.0;
	}
 
int WaveObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
	{
	GraphicsWindow *gw = vpt->getGW();
	Material *mtl = &swMtl;	
 	DWORD rlim = gw->getRndLimits();
	
	gw->setRndLimits(GW_WIREFRAME|/*GW_BACKCULL|*/ (rlim&GW_Z_BUFFER?GW_Z_BUFFER:0) );	//removed BC 2/16/99 DB
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
		gw->setColor( LINE_COLOR, swMtl.Kd[0], swMtl.Kd[1], swMtl.Kd[2]);
	
	SimpleWSMObject::Display(t,inode,vpt,flags);
			
	gw->setRndLimits(rlim);
	return(0);
	}
#endif

class SinWaveObjCreateCallBack: public CreateMouseCallBack {	
	WaveObject *ob;	
	Point3 p0, p1;
	IPoint2 sp0, sp1;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		void SetObj(WaveObject *obj) { ob = obj; }
	};

int SinWaveObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float w;	

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:  // only happens with MOUSE_POINT msg
				sp0    = m;
				p0     = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE); //vpt->GetPointOnCP(m);
				mat.SetTrans(p0);
				break;
			case 1:								
				sp1 = m;		
				p1  = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE); //vpt->GetPointOnCP(m);
				w   = float(4)*Length(p0-p1)/ob->Circles();
				ob->pblock->SetValue(PB_WAVELEN,0,w);
				ob->pmapParam->Invalidate();
				break;
			case 2:	
				if ( Length(sp1-sp0)<3 ) return CREATE_ABORT;			
				w = vpt->GetCPDisp(p1,Point3(0,0,1),sp1,m);				
				ob->pblock->SetValue(PB_AMPLITUDE,0,w);
				ob->pblock->SetValue(PB_AMPLITUDE2,0,w);
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT) 
					return CREATE_STOP;
				break;					   
			}
		}
	else
	if (msg == MOUSE_ABORT)
		return CREATE_ABORT;
	else
	if (msg == MOUSE_FREEMOVE) {
		vpt->SnapPreview(m,m);
		}
	return TRUE;
	}

static SinWaveObjCreateCallBack sinwaveCreateCB;


CreateMouseCallBack* WaveObject::GetCreateMouseCallBack()
	{
	sinwaveCreateCB.SetObj(this);
	return &sinwaveCreateCB;
	}

void WaveObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *WaveObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_AMPLITUDE:	return stdWorldDim;		
		case PB_AMPLITUDE2:	return stdWorldDim;	
		case PB_WAVELEN: 	return stdWorldDim;		
		case PB_PHASE:		return stdNormalizedDim;		
		case PB_DECAY:		return stdNormalizedDim;			
		default:			return defaultDim;
		}
	}

TSTR WaveObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_AMPLITUDE:	return GetString(IDS_RB_AMPLITUDE1);
		case PB_AMPLITUDE2:	return GetString(IDS_RB_AMPLITUDE2);
		case PB_WAVELEN:	return GetString(IDS_RB_WAVELEN);
		case PB_PHASE:		return GetString(IDS_RB_PHASE);
		case PB_DECAY:		return GetString(IDS_RB_DECAY);
		default:			return TSTR(_T(""));
		}
	}



//--- Circular sine wave ---------------------------------------------

SinWaveObject::SinWaveObject()
	{
	pblock->SetValue(PB_CIRCLES, TimeValue(0), 10);
	pblock->SetValue(PB_SEGMENTS, TimeValue(0), 16);
	pblock->SetValue(PB_DIVISIONS, TimeValue(0), 4);
	}

IOResult SinWaveObject::Load(ILoad *iload)
	{
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}

Modifier *SinWaveObject::CreateWSMMod(INode *node)
	{
	return new SinWaveMod(node,this);
	}

RefTargetHandle SinWaveObject::Clone(RemapDir& remap) 
	{
	SinWaveObject* newob = new SinWaveObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	return(newob);
	}

static void MakeQuad(Face *f, int a,  int b , int c , int d, int sg, int dv = 0) {
	f[0].setVerts( a+dv, b+dv, c+dv);
	f[0].setSmGroup(sg);
	f[0].setEdgeVisFlags(1,1,0);
	f[1].setVerts( c+dv, d+dv, a+dv);
	f[1].setSmGroup(sg);
	f[1].setEdgeVisFlags(1,1,0);
	}

void SinWaveObject::MakeCircle(TimeValue t, Mesh &mesh, 
		int startVert, int& face, float radius,
		float a1,float a2,float w,float s, float d, int numCircleSegs)
	{
	float x, y, z, u, u2;			

	for ( int i = startVert; i < startVert+numCircleSegs; i++ ) {
		u = float(i-startVert) / float(numCircleSegs);
		x = radius * (float)cos( u * TWOPI );
		y = radius * (float)sin( u * TWOPI );		
		
		u2 = (u > 0.5f) ? (u-0.5f) : u;
		u2 = (u2 > 0.25f) ? (0.5f-u2) : u2;
		u2 = u2 * 4.0f;
		u2 = u2*u2;
		z = WaveFunc(radius, t, a1*(1.0f-u2) + a2*u2, w, s, d);

		if ( startVert == 0 ) {
			mesh.setVert( i+1, Point3(x, y, z) );
		} else {
			mesh.setVert( numCircleSegs + i, Point3(x, y, z) );
		
			if ( i < startVert+numCircleSegs-1 ) {
				MakeQuad(&(mesh.faces[face]), 
					i+numCircleSegs,i+numCircleSegs+1,i+1,i,1);
				face += 2;
			} else {
				MakeQuad(&(mesh.faces[face]), 
					i+numCircleSegs,startVert+numCircleSegs,startVert,i,1);
				face += 2;
				}
			}
		}
	}

void SinWaveObject::BuildMesh(TimeValue t)
	{		
	int startVert = 1, face = 0, nverts, nfaces, numCircles, numCircleSegs, divs;
	float radius = float(0);
	float dr;
	float a, a2, w, s, d;	

	ivalid = FOREVER;
	pblock->GetValue(PB_AMPLITUDE,t,a,ivalid);
	pblock->GetValue(PB_AMPLITUDE2,t,a2,ivalid);
	pblock->GetValue(PB_WAVELEN,t,w,ivalid);
	pblock->GetValue(PB_PHASE,t,s,ivalid);
	pblock->GetValue(PB_DECAY,t,d,ivalid);
	pblock->GetValue(PB_SEGMENTS,t,numCircleSegs,ivalid);
	pblock->GetValue(PB_CIRCLES,t,numCircles,ivalid);
	pblock->GetValue(PB_DIVISIONS,t,divs,ivalid);
	LimitValue(d,0.0f,float(1.0E30));

	dr     = w/float(divs);
	nverts = numCircles * numCircleSegs + 1;
	nfaces = (numCircles-1) * numCircleSegs * 2;
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);

	mesh.setVert( 0, Point3(0,0,0) );
	MakeCircle(t,mesh,0,face,radius, a, a2, w, s, d, numCircleSegs);

	for ( int i = 1; i < numCircles; i++ ) {
		MakeCircle(t,mesh,startVert,face,radius, a, a2, w, s, d, numCircleSegs);
		startVert += numCircleSegs;
		radius += dr;
		}
	
	mesh.InvalidateGeomCache();
	}


//--- Linear sine wave ---------------------------------------------

LinWaveObject::LinWaveObject()
	{
	pblock->SetValue(PB_CIRCLES, TimeValue(0), 4);
	pblock->SetValue(PB_SEGMENTS, TimeValue(0), 20);
	pblock->SetValue(PB_DIVISIONS, TimeValue(0), 10);
	}

Modifier *LinWaveObject::CreateWSMMod(INode *node)
	{
	return new LinWaveMod(node,this);
	}

RefTargetHandle LinWaveObject::Clone(RemapDir& remap) 
	{
	LinWaveObject* newob = new LinWaveObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	return(newob);
	}


void LinWaveObject::BuildMesh(TimeValue t)
	{		
	int startVert = 1, face = 0, nverts, nfaces, numSides, numSegs, divs;
	float radius = float(0);
	float dx, dy, starty, startx;
	float a, a2, w, s, d, x, y, z, u;	
	int nv=0, nf=0, ix, den;

	ivalid = FOREVER;
	pblock->GetValue(PB_AMPLITUDE,t,a,ivalid);
	pblock->GetValue(PB_AMPLITUDE2,t,a2,ivalid);
	pblock->GetValue(PB_WAVELEN,t,w,ivalid);
	pblock->GetValue(PB_PHASE,t,s,ivalid);
	pblock->GetValue(PB_DECAY,t,d,ivalid);
	pblock->GetValue(PB_SEGMENTS,t,numSegs,ivalid);
	pblock->GetValue(PB_CIRCLES,t,numSides,ivalid);
	pblock->GetValue(PB_DIVISIONS,t,divs,ivalid);	
	LimitValue(d,0.0f,float(1.0E30));
	
	dy     = w/float(divs);
	dx     = dy * 4;
	starty = -float(numSegs)/2.0f * dy;
	startx = -float(numSides)/2.0f * dx;
	nverts = (numSides+1) * (numSegs+1);
	nfaces = (numSides) * numSegs * 2;
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);

	
	for (int i=0; i<=numSides; i++) {
		x   = startx + dx * float(i);		
		den = (int)(dx*numSides*0.5f);
		u   = (float)fabs(x/(den?den:0.00001f));		
		u   = u*u;
		//u = smoothstep(0.0f,1.0f,u);
		for (int j=0; j<=numSegs; j++) {
			y = starty + float(j) * dy;
			z = WaveFunc(y, t, a*(1.0f-u)+a2*u, w, s, d);
			mesh.setVert(nv++,Point3(x, y, z));			
			}
		}
		
	for (i=0; i<numSides; i++) {
		ix = i * (numSegs+1);
		for (int j=0; j<numSegs; j++) {
			MakeQuad(&(mesh.faces[nf]), 
				ix+numSegs+1+j, ix+numSegs+2+j, ix+1+j, ix+j, 1);				
			nf += 2;
			}
		}
	
	assert(nv==mesh.numVerts);
	assert(nf==mesh.numFaces);
	mesh.InvalidateGeomCache();
	}



/*----------------------------------------------------------------*/
// Sine Wave modifier


//--- Parameter map/block descriptors -----------------------------

#define PB_FLEX			0

//
//
// Parameters

static ParamUIDesc descParamMod[] = {
	// Angle
	ParamUIDesc(
		PB_FLEX,
		EDITTYPE_FLOAT,
		IDC_FLEX,IDC_FLEXSPINNER,
		-10.0f,10.0f,
		0.01f)
	};
#define MODPARAMDESC_LENGH 1

ParamBlockDescID descModVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 } };

#define MODPBLOCK_LENGTH	1

#if 0
// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,0)
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);
#endif

#define CURRENT_MODVERSION	0


//--- SinWaveDeformer  --------------------------------------

class SinWaveDeformer : public Deformer {
	public:
		float amp, amp2, wave, phase, decay, flex;
		TimeValue time;
		Matrix3 tm, itm;		
		Point3 Map(int i, Point3 p); 
	};

Point3 SinWaveDeformer::Map(int i, Point3 p)
	{
	Point3 pt = p * tm;
	float r, oldZ, u, a, len;
		
	if (amp!=amp2) {
		len  = Length(pt);
		if (len==0.0f) {
			a = amp;
		} else {
			u = (float)acos(pt.x/len)/PI;
	 		u = (u > 0.5) ? (1.0f-u) : u;
			u *= 2.0f;
	 		//u = u*u;
	 		u = smoothstep(0.0f,1.0f,u);
	 		a = amp*(1.0f-u) + amp2*u;
			}
	} else {
		a = amp;
		}	
	
	oldZ = pt.z;
	pt.z = float(0);	
	r    = Length(pt);
	pt.z = oldZ + flex * WaveFunc(r, time, a, wave, phase, decay);
	return pt * itm;
	}

class LinWaveDeformer : public Deformer {
	public:
		float amp, amp2, wave, phase, decay, flex, dist;
		TimeValue time;
		Matrix3 tm, itm;		
		Point3 Map(int i, Point3 p); 
	};

Point3 LinWaveDeformer::Map(int i, Point3 p)
	{
	Point3 pt = p * tm;	
	float u = (float)fabs(2.0f*pt.x/dist);
	u = u*u;
	pt.z += flex * WaveFunc(pt.y, time, amp*(1.0f-u)+amp2*u, wave, phase, decay);
	return pt * itm;
	}

//--- WaveMod methods -----------------------------------------


WaveMod::WaveMod(INode *node,WaveObject *obj)
	{	
	//MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
	MakeRefByID(FOREVER, SIMPWSMMOD_PBLOCKREF, 
		CreateParameterBlock(descModVer0, MODPBLOCK_LENGTH, CURRENT_MODVERSION));
	obRef = NULL;
	pblock->SetValue(PB_FLEX, TimeValue(0), DEF_FLEX);
	}

void WaveMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleWSMMod::BeginEditParams(ip,flags,prev);
		
	pmapParam = CreateCPParamMap(
		descParamMod,MODPARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_SINWAVEMODPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);		
	}
		
void WaveMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleWSMMod::EndEditParams(ip,flags,next);
	DestroyCPParamMap(pmapParam);
	}

Interval WaveMod::GetValidity(TimeValue t) 
	{
	if (nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;
		pblock->GetValue(PB_FLEX,t,f,valid);
		SinWaveObject *obj = (SinWaveObject*)GetWSMObject(t);
		obj->pblock->GetValue(PB_AMPLITUDE,t,f,valid);
		obj->pblock->GetValue(PB_AMPLITUDE2,t,f,valid);
		obj->pblock->GetValue(PB_WAVELEN,t,f,valid);
		obj->pblock->GetValue(PB_PHASE,t,f,valid);
		obj->pblock->GetValue(PB_DECAY,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {
		return FOREVER;
		}
	}

ParamDimension *WaveMod::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_FLEX: 	return stdNormalizedDim;
		default:		return defaultDim;
		}	
	}

TSTR WaveMod::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_FLEX: 	return GetString(IDS_RB_FLEXIBILITY);
		default:		return GetString(IDS_RB_PARAMETERS);
		}
	}


// --- SinWaveMod -------

Deformer& SinWaveMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	Interval valid;
	static SinWaveDeformer sd;
	pblock->GetValue(PB_FLEX,t,sd.flex,FOREVER);
	SinWaveObject *obj = (SinWaveObject*)GetWSMObject(t);
	obj->pblock->GetValue(PB_AMPLITUDE,t,sd.amp,FOREVER);
	obj->pblock->GetValue(PB_AMPLITUDE2,t,sd.amp2,FOREVER);
	obj->pblock->GetValue(PB_WAVELEN,t,sd.wave,FOREVER);
	obj->pblock->GetValue(PB_PHASE,t,sd.phase,FOREVER);
	obj->pblock->GetValue(PB_DECAY,t,sd.decay,FOREVER);
	LimitValue(sd.decay,0.0f,float(1.0E30));

	sd.time = t;
	//sd.itm  = nodeRef->GetNodeTM(t,&valid);
	sd.itm  = nodeRef->GetObjectTM(t,&valid);
	sd.tm   = Inverse( sd.itm );
	return sd;
	}

RefTargetHandle SinWaveMod::Clone(RemapDir& remap) 
	{
	SinWaveMod *newob = new SinWaveMod(nodeRef,(SinWaveObject*)obRef);
	newob->SimpleWSMModClone(this);
	return newob;
	}

// --- LinWaveMod -------

Deformer& LinWaveMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	Interval valid;
	static LinWaveDeformer ld;
	pblock->GetValue(PB_FLEX,t,ld.flex,FOREVER);
	LinWaveObject *obj = (LinWaveObject*)GetWSMObject(t);
	obj->pblock->GetValue(PB_AMPLITUDE,t,ld.amp,FOREVER);
	obj->pblock->GetValue(PB_AMPLITUDE2,t,ld.amp2,FOREVER);
	obj->pblock->GetValue(PB_WAVELEN,t,ld.wave,FOREVER);
	obj->pblock->GetValue(PB_PHASE,t,ld.phase,FOREVER);
	obj->pblock->GetValue(PB_DECAY,t,ld.decay,FOREVER);
	LimitValue(ld.decay,0.0f,float(1.0E30));

	ld.time = t;
	//ld.itm  = nodeRef->GetNodeTM(t,&valid);
	ld.itm  = nodeRef->GetObjectTM(t,&valid);
	ld.tm   = Inverse(ld.itm);
	//ld.dist = mc.box ? mc.box->Width().x : (4.0f*ld.wave);
	//ld.dist = (2.0f*ld.wave); // Use wave length for the WSM version
		
	int numSides, divs;
	obj->pblock->GetValue(PB_CIRCLES,t,numSides,FOREVER);
	obj->pblock->GetValue(PB_DIVISIONS,t,divs,FOREVER);	
	ld.dist = (ld.wave/float(divs)) * 4.0f * float(numSides);

	if (ld.dist == 0.0f) ld.dist = 1.0f;
	return ld;
	}

RefTargetHandle LinWaveMod::Clone(RemapDir& remap) 
	{
	LinWaveMod *newob = new LinWaveMod(nodeRef,(LinWaveObject*)obRef);
	newob->SimpleWSMModClone(this);
	return newob;
	}



//--- Parameter map/block descriptors -----------------------------

//
//
// Parameters

static ParamUIDesc descParamOMod[] = {
	
	// Amplitude 1
	ParamUIDesc(
		PB_AMPLITUDE,
		EDITTYPE_UNIVERSE,
		IDC_AMPLITUDE,IDC_AMPSPINNER,
		-9999999.0f, 9999999.0f,
		SPIN_AUTOSCALE),	

	// Amplitude 2
	ParamUIDesc(
		PB_AMPLITUDE2,
		EDITTYPE_UNIVERSE,
		IDC_AMPLITUDE2,IDC_AMPSPINNER2,
		-9999999.0f, 9999999.0f,
		SPIN_AUTOSCALE),	

	// Wave Length
	ParamUIDesc(
		PB_WAVELEN,
		EDITTYPE_UNIVERSE,
		IDC_WAVELEN,IDC_WAVELENSPINNER,
		-9999999.0f, 9999999.0f,
		SPIN_AUTOSCALE),	

	// Phase
	ParamUIDesc(
		PB_PHASE,
		EDITTYPE_FLOAT,
		IDC_PHASE,IDC_PHASESPINNER,
		-9999999.0f, 9999999.0f,
		0.1f),
		
	// Decay
	ParamUIDesc(
		PB_DECAY,
		EDITTYPE_FLOAT,
		IDC_DECAY,IDC_DECAYSPINNER,
		0.0f, 9999999.0f,
		0.001f),
	};
#define OMODPARAMDESC_LENGH 5

ParamBlockDescID descOModVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 } };
#define OMODPBLOCK_LENGTH	5

#define CURRENT_OMODVERSION	0


//--- WaveOMod methods -----------------------------------------


WaveOMod::WaveOMod()
	{		
	MakeRefByID(FOREVER, SIMPMOD_PBLOCKREF, 
		CreateParameterBlock(descOModVer0, OMODPBLOCK_LENGTH, CURRENT_OMODVERSION));
	
	pblock->SetValue(PB_WAVELEN,0,50.0f);
	}


void WaveOMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleMod::BeginEditParams(ip,flags,prev);
		
	pmapParam = CreateCPParamMap(
		descParamOMod,OMODPARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(DialogID()),
		GetString(IDS_RB_PARAMETERS),
		0);		
	}
		
void WaveOMod::EndEditParams(IObjParam *ip, ULONG flags,Animatable *next)
	{
	SimpleMod::EndEditParams(ip,flags,next);
	DestroyCPParamMap(pmapParam);
	}

Interval WaveOMod::GetValidity(TimeValue t) 
	{	
	Interval valid = FOREVER;	
	float f;	
	pblock->GetValue(PB_AMPLITUDE,t,f,valid);
	pblock->GetValue(PB_AMPLITUDE2,t,f,valid);
	pblock->GetValue(PB_WAVELEN,t,f,valid);
	pblock->GetValue(PB_PHASE,t,f,valid);
	pblock->GetValue(PB_DECAY,t,f,valid);	
	return valid;	
	}

ParamDimension *WaveOMod::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_AMPLITUDE:	return stdWorldDim;			
		case PB_AMPLITUDE2:	return stdWorldDim;	
		case PB_WAVELEN: 	return stdWorldDim;		
		case PB_PHASE:		return stdNormalizedDim;		
		case PB_DECAY:		return stdNormalizedDim;			
		default:			return defaultDim;
		}
	}

TSTR WaveOMod::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_AMPLITUDE:	return GetString(IDS_RB_AMPLITUDE1);
		case PB_AMPLITUDE2:	return GetString(IDS_RB_AMPLITUDE2);
		case PB_WAVELEN:	return GetString(IDS_RB_WAVELEN);
		case PB_PHASE:		return GetString(IDS_RB_PHASE);
		case PB_DECAY:		return GetString(IDS_RB_DECAY);
		default:			return TSTR(_T(""));
		}
	}


//--- SinWaveOMod methods -----------------------------------------

Deformer& SinWaveOMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	Interval valid;
	static SinWaveDeformer sd;	
	pblock->GetValue(PB_AMPLITUDE,t,sd.amp,FOREVER);
	pblock->GetValue(PB_AMPLITUDE2,t,sd.amp2,FOREVER);
	pblock->GetValue(PB_WAVELEN,t,sd.wave,FOREVER);
	pblock->GetValue(PB_PHASE,t,sd.phase,FOREVER);
	pblock->GetValue(PB_DECAY,t,sd.decay,FOREVER);
	LimitValue(sd.decay,0.0f,float(1.0E30));
	sd.time = t;
	sd.itm  = invmat;
	sd.tm   = mat;
	sd.flex = 1.0f;
	return sd;
	}

RefTargetHandle SinWaveOMod::Clone(RemapDir& remap) 
	{
	SinWaveOMod *newob = new SinWaveOMod();
	newob->ReplaceReference(SIMPMOD_PBLOCKREF,pblock->Clone(remap));
	newob->SimpleModClone(this);
	return newob;
	}


//--- LinWaveOMod methods -----------------------------------------

Deformer& LinWaveOMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	Interval valid;
	static LinWaveDeformer ld;	
	pblock->GetValue(PB_AMPLITUDE,t,ld.amp,FOREVER);
	pblock->GetValue(PB_AMPLITUDE2,t,ld.amp2,FOREVER);
	pblock->GetValue(PB_WAVELEN,t,ld.wave,FOREVER);
	pblock->GetValue(PB_PHASE,t,ld.phase,FOREVER);
	pblock->GetValue(PB_DECAY,t,ld.decay,FOREVER);
	LimitValue(ld.decay,0.0f,float(1.0E30));
	ld.time = t;
	ld.itm  = invmat;
	ld.tm   = mat;
	ld.flex = 1.0f;
	ld.dist = mc.box ? mc.box->Width().x : (4.0f*ld.wave);
	return ld;
	}

RefTargetHandle LinWaveOMod::Clone(RemapDir& remap) 
	{
	LinWaveOMod *newob = new LinWaveOMod();
	newob->ReplaceReference(SIMPMOD_PBLOCKREF,pblock->Clone(remap));
	newob->SimpleModClone(this);
	return newob;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\surfmod.cpp ===
/**********************************************************************
 *<
	FILE: surfmod.cpp

	DESCRIPTION:  Varius surface modifiers

	CREATED BY: Rolf Berteig

	HISTORY: 11/07/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"
#include "MeshDLib.h"

class MatMod : public Modifier {	
	public:
		IParamBlock *pblock;
		static IParamMap *pmapParam;

		MatMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_MATMOD); }  
		virtual Class_ID ClassID() { return Class_ID(MATERIALOSM_CLASS_ID,0);}
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);		
		TCHAR *GetObjectName() { return GetString(IDS_RB_MATERIAL3); }
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 

		ChannelMask ChannelsUsed()  {return OBJ_CHANNELS;}
		ChannelMask ChannelsChanged() {return GEOM_CHANNEL|TOPO_CHANNEL;}
		Class_ID InputType() {return triObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);
		IParamArray *GetParamBlock() {return pblock;}
		int GetParamBlockIndex(int id) {return id;}

		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock = (IParamBlock*)rtarg;}

		int NumSubs() {return 1;}
		Animatable* SubAnim(int i) {return pblock;}
		TSTR SubAnimName(int i) {return GetString(IDS_RB_PARAMETERS);}

		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
	};



//--- ClassDescriptor and class vars ---------------------------------

IParamMap *MatMod::pmapParam = NULL;



class MatClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new MatMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_MATERIAL3_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(MATERIALOSM_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFSURFACE);}
	};

static MatClassDesc matDesc;
extern ClassDesc* GetMatModDesc() { return &matDesc; }


//--- Parameter map/block descriptors -------------------------------

#define PB_MATID 0

//
//
// Parameters

static ParamUIDesc descParam[] = {
	
	// Material ID
	ParamUIDesc(
		PB_MATID,
		EDITTYPE_INT,
		IDC_MATID,IDC_MATIDSPIN,
		1.0f,(float)0xffff,
		0.1f),	
	};
#define PARAMDESC_LENGH 1


static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, TRUE, 0 }};
#define PBLOCK_LENGTH	1

#define CURRENT_VERSION	0


//--- MatMod methods -------------------------------


MatMod::MatMod()
	{	
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));	
	pblock->SetValue(PB_MATID,0,1);
	}

void MatMod::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev)
	{
	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_MATERIALPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);		
	}
		
void MatMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{	
	DestroyCPParamMap(pmapParam);
	pmapParam = NULL;
	}

Interval MatMod::LocalValidity(TimeValue t)
	{
	int i;
	Interval valid = FOREVER;
	pblock->GetValue(PB_MATID,t,i,valid);	
	return valid;
	}

RefTargetHandle MatMod::Clone(RemapDir& remap) 
	{
	MatMod* newmod = new MatMod();	
	newmod->ReplaceReference(0,pblock->Clone(remap));	
	return newmod;
	}

void MatMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	Interval valid = FOREVER;
	int id;
	pblock->GetValue(PB_MATID,t,id,valid);	
	id--;
	if (id<0) id = 0;
	if (id>0xffff) id = 0xffff;

	assert(os->obj->IsSubClassOf(triObjectClassID));
	TriObject *triOb = (TriObject *)os->obj;
	BOOL useSel = triOb->GetMesh().selLevel==MESH_FACE;

	for (int i=0; i<triOb->GetMesh().getNumFaces(); i++) {
		if (!useSel || triOb->GetMesh().faceSel[i]) {
			triOb->GetMesh().setFaceMtlIndex(i,(MtlID)id);
		}
	}
	triOb->GetMesh().InvalidateTopologyCache();
		
	triOb->UpdateValidity(TOPO_CHAN_NUM,valid);		
	}

RefResult MatMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
			if (pmapParam && pmapParam->GetParamBlock()==pblock) {
				pmapParam->Invalidate();
				}
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {				
				case 0:
				default: gpd->dim = defaultDim; break;
				}			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {				
				case PB_MATID:	gpn->name = GetString(IDS_RB_MATERIALID); break;
				default:		gpn->name = TSTR(_T("")); break;
				}
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}

//-------------------------------------------------------------------
//-------------------------------------------------------------------


class SmoothMod : public Modifier {	
	public:
		IParamBlock *pblock;
		static IParamMap *pmapParam;

		SmoothMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_SMOOTHMOD); }  
		virtual Class_ID ClassID() { return Class_ID(SMOOTHOSM_CLASS_ID,0);}
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);		
		TCHAR *GetObjectName() { return GetString(IDS_RB_SMOOTH2); }
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 

		ChannelMask ChannelsUsed()  {return OBJ_CHANNELS;}
		ChannelMask ChannelsChanged() {return GEOM_CHANNEL|TOPO_CHANNEL;}
		Class_ID InputType() {return triObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);
		IParamArray *GetParamBlock() {return pblock;}
		int GetParamBlockIndex(int id) {return id;}

		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock = (IParamBlock*)rtarg;}
		IOResult Load(ILoad *iload);

		int NumSubs() {return 1;}
		Animatable* SubAnim(int i) {return pblock;}
		TSTR SubAnimName(int i) {return GetString(IDS_RB_PARAMETERS);}

		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
	};



//--- ClassDescriptor and class vars ---------------------------------

IParamMap *SmoothMod::pmapParam = NULL;


class SmoothClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) {return new SmoothMod;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_SMOOTH2_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(SMOOTHOSM_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFSURFACE);}
	};

static SmoothClassDesc smoothDesc;
extern ClassDesc* GetSmoothModDesc() { return &smoothDesc; }


//--- Parameter map/block descriptors -------------------------------

#define PB_AUTOSMOOTH 		0
#define PB_THRESHOLD		1
#define PB_SMOOTHBITS		2
#define PB_PREVENTINDIRECT	3

//
//
// Parameters

static ParamUIDesc descSmoothParam[] = {
	// Auto smooth
	ParamUIDesc(PB_AUTOSMOOTH,TYPE_SINGLECHEKBOX,IDC_SMOOTH_AUTO),

	// Prevent Indirect Smoothing
	ParamUIDesc(PB_PREVENTINDIRECT,TYPE_SINGLECHEKBOX,IDC_SMOOTH_PREVENTINDIRECT),

	// Threshold
	ParamUIDesc(
		PB_THRESHOLD,
		EDITTYPE_FLOAT,
		IDC_SMOOTH_THRESH,IDC_SMOOTH_THRESHSPIN,
		0.0f,180.0f,
		0.1f,
		stdAngleDim),
	};
#define SMOOTHPARAMDESC_LENGH 3


static ParamBlockDescID descSmoothVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 }};

static ParamBlockDescID descSmoothVer1[] = {
	{ TYPE_INT,   NULL, FALSE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT,   NULL, FALSE, 2 },
	{ TYPE_INT,   NULL, FALSE, 3 },
	};

#define SMOOTHPBLOCK_LENGTH	4

// Array of old versions
static ParamVersionDesc versionsSmooth[] = {
	ParamVersionDesc(descSmoothVer0,3,0)
	};
#define NUM_OLDSMOOTHVERSIONS	1

#define CURRENT_SMOOTHVERSION	1
static ParamVersionDesc curSmoothVersion(descSmoothVer1,SMOOTHPBLOCK_LENGTH,CURRENT_SMOOTHVERSION);


//--- SmoothDlgProc --------------------------------

class SmoothDlgProc : public ParamMapUserDlgProc {
	public:
		HWND hWnd;
		SmoothMod *mod;		
		SmoothDlgProc(SmoothMod *m) {mod = m;hWnd = NULL;}		
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
		void Update(TimeValue t);

	};

static void SetSmoothButtonState(HWND hWnd,DWORD bits)
	{
	for (int i=IDC_SMOOTH_GRP1; i<IDC_SMOOTH_GRP1+32; i++) {		
		SendMessage(GetDlgItem(hWnd,i),CC_COMMAND,CC_CMD_SET_STATE,
			(bits&(1<<(i-IDC_SMOOTH_GRP1)))?TRUE:FALSE);			
		}
	}

void SmoothDlgProc::Update(TimeValue t)
	{	
	if (!mod || !mod->pblock || !hWnd) return;
	int bits;
	mod->pblock->GetValue(PB_SMOOTHBITS,t,bits,FOREVER);
	SetSmoothButtonState(hWnd,(DWORD)bits);
	}

BOOL SmoothDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG: {
			this->hWnd = hWnd;
			for (int i=IDC_SMOOTH_GRP1; i<IDC_SMOOTH_GRP1+32; i++) {
				SendMessage(GetDlgItem(hWnd,i),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
				}
			IParamBlock *pblock = (IParamBlock*)map->GetParamBlock();
			int bits;
			pblock->GetValue(PB_SMOOTHBITS,t,bits,FOREVER);
			SetSmoothButtonState(hWnd,(DWORD)bits);
			break;
			}

		case WM_COMMAND:
			if (LOWORD(wParam)>=IDC_SMOOTH_GRP1 &&
				LOWORD(wParam)<=IDC_SMOOTH_GRP32) {
				IParamBlock *pblock = (IParamBlock*)map->GetParamBlock();
				ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,LOWORD(wParam)));
				int bits;
				pblock->GetValue(PB_SMOOTHBITS,t,bits,FOREVER);
				int shift = LOWORD(wParam) - IDC_SMOOTH_GRP1;
				if (iBut->IsChecked()) {
					bits |= 1<<shift;
				} else {
					bits &= ~(1<<shift);
					}
				pblock->SetValue(PB_SMOOTHBITS,t,bits);
				ReleaseICustButton(iBut);
				return REDRAW_VIEWS;
				}
			break;
		
		default:
			return TRUE;
		}
	return FALSE;
	}


//--- SmoothMod methods -------------------------------


SmoothMod::SmoothMod()
	{	
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descSmoothVer1, SMOOTHPBLOCK_LENGTH, CURRENT_SMOOTHVERSION));
	pblock->SetValue(PB_THRESHOLD,0,DegToRad(30.0f));
	}

IOResult SmoothMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versionsSmooth,NUM_OLDSMOOTHVERSIONS,&curSmoothVersion,this,0));
	return IO_OK;
	}


void SmoothMod::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev)
	{
	pmapParam = CreateCPParamMap(
		descSmoothParam,SMOOTHPARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_SMOOTHPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);		
	pmapParam->SetUserDlgProc(new SmoothDlgProc(this));
	}
		
void SmoothMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{	
	DestroyCPParamMap(pmapParam);
	pmapParam = NULL;
	}

Interval SmoothMod::LocalValidity(TimeValue t)
	{
	float f;
	Interval valid = FOREVER;
	pblock->GetValue(PB_THRESHOLD,t,f,valid);	
	return valid;
	}

RefTargetHandle SmoothMod::Clone(RemapDir& remap) 
	{
	SmoothMod* newmod = new SmoothMod();	
	newmod->ReplaceReference(0,pblock->Clone(remap));	
	return newmod;
	}

#if 0 // moved into mesh class
static void AutoSmooth(
		Mesh *mesh,
		AdjFaceList &af,
		AdjEdgeList &ae,
		float angle,BOOL useSel)
	{
	FaceClusterList clust(mesh,af,angle,useSel);
	int *grp = new int[clust.count];
	
	// For each cluster, pick the first unused bit
	for (DWORD i=0; i<clust.count; i++) {
		int bit = 0;
		 DWORD used = 0;
		
		// Go through the faces in this cluster and see which
		// bits are used		
		for (int j=0; j<mesh->getNumFaces(); j++) {
			if (useSel&&!mesh->faceSel[j]) continue;

			if (clust[j]==i) {				
				int c;				
							
				for (int k=0; k<3; k++) {					 					
					// New way: We gotta look at all faces that share
					// a vertex even if they are not adjacent across an edge.
					DWORD v = mesh->faces[j].v[k];
					for (int l=0; l<ae[v].Count(); l++) {
						MEdge edge = ae.edges[ae[v][l]];
						if (edge.f[0]!=UNDEFINED && edge.f[0]!=(DWORD)j) {
							c = clust[edge.f[0]];
							if (c!=UNDEFINED && (DWORD)c<i) {
								used |= 1<<(grp[c]);
								}
							}
						if (edge.f[1]!=UNDEFINED && edge.f[1]!=(DWORD)j) {
							c = clust[edge.f[1]];
							if (c!=UNDEFINED && (DWORD)c<i) {
								used |= 1<<(grp[c]);
								}
							}
						}
					}				
				}			
			}

		// Pick the first free bit
		for (j=0; j<32; j++) {
			if (!((1<<j) & used)) {
				bit = j;
				break;
				}
			}

		// We've got a smooth bit for this cluster!
		grp[i] = bit;
		}
	
	// Now we've got bits for each cluster ID. Assign the faces.
	for (int j=0; j<mesh->getNumFaces(); j++) {
		if (useSel&&!mesh->faceSel[j]) continue;
		
		assert(clust[j]!=UNDEFINED);		
		mesh->faces[j].smGroup = (1<<grp[clust[j]]);		
		}
	
	delete[] grp;
	}
#endif


void SmoothMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	Interval valid = FOREVER;
	int autoSmooth, bits, prevent;
	float thresh;
	pblock->GetValue(PB_AUTOSMOOTH,t,autoSmooth,valid);	
	pblock->GetValue(PB_THRESHOLD,t,thresh,valid);	
	pblock->GetValue(PB_SMOOTHBITS,t,bits,valid);	
	pblock->GetValue(PB_PREVENTINDIRECT,t,prevent,valid);

	assert(os->obj->IsSubClassOf(triObjectClassID));
	TriObject *triOb = (TriObject *)os->obj;
	BOOL useSel = triOb->GetMesh().selLevel==MESH_FACE;

	if (!autoSmooth) {
		for (int i=0; i<triOb->GetMesh().getNumFaces(); i++) {
			if (!useSel || triOb->GetMesh().faceSel[i]) {			
				triOb->GetMesh().faces[i].smGroup = (DWORD)bits;
				}
			}
		valid = FOREVER; // No animating without autosmooth
	} else {
		//AdjEdgeList ae(triOb->mesh);
		//AdjFaceList af(triOb->mesh,ae);
		//AutoSmooth(&triOb->mesh,af,ae,thresh,useSel);
		triOb->GetMesh().AutoSmooth(thresh,useSel,prevent);
		}
	triOb->GetMesh().InvalidateTopologyCache ();
			
	triOb->UpdateValidity(TOPO_CHAN_NUM,valid);		
	}

RefResult SmoothMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
			if (pmapParam && pmapParam->GetParamBlock()==pblock) {
				pmapParam->Invalidate();
				}
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {				
				case PB_THRESHOLD: gpd->dim = stdAngleDim; break;
				default: gpd->dim = defaultDim; break;
				}			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {				
				case PB_THRESHOLD:	gpn->name = GetString(IDS_RB_THRESHOLD); break;
				default:		gpn->name = TSTR(_T("")); break;
				}
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}


//-----------------------------------------------------------
//-----------------------------------------------------------


class NormalMod : public Modifier {	
	public:
		IParamBlock *pblock;
		static IParamMap *pmapParam;

		NormalMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_NORMALMOD); }  
		virtual Class_ID ClassID() { return Class_ID(NORMALOSM_CLASS_ID,0);}
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);		
		TCHAR *GetObjectName() { return GetString(IDS_RB_NORMAL); }
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 

		ChannelMask ChannelsUsed()  {return OBJ_CHANNELS;}
		ChannelMask ChannelsChanged() {return PART_TOPO|PART_TEXMAP|PART_VERTCOLOR;}
		Class_ID InputType() {return triObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);
		IParamArray *GetParamBlock() {return pblock;}
		int GetParamBlockIndex(int id) {return id;}

		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock = (IParamBlock*)rtarg;}

		int NumSubs() {return 1;}
		Animatable* SubAnim(int i) {return pblock;}
		TSTR SubAnimName(int i) {return GetString(IDS_RB_PARAMETERS);}

		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
	};



//--- ClassDescriptor and class vars ---------------------------------

IParamMap *NormalMod::pmapParam = NULL;



class NormalClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new NormalMod;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_NORMAL_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(NORMALOSM_CLASS_ID,0);}
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFSURFACE);}
	};

static NormalClassDesc normalDesc;
extern ClassDesc* GetNormalModDesc() { return &normalDesc; }


//--- Parameter map/block descriptors -------------------------------

#define PB_UNIFY	0
#define PB_FLIP 	1

//
//
// Parameters

static ParamUIDesc descNormParam[] = {
	// Unify
	ParamUIDesc(PB_UNIFY,TYPE_SINGLECHEKBOX,IDC_NORM_UNIFY),

	// Flip
	ParamUIDesc(PB_FLIP,TYPE_SINGLECHEKBOX,IDC_NORM_FLIP),
	};
#define NORMPARAMDESC_LENGH 2


static ParamBlockDescID descNormVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_INT, NULL, FALSE, 1 }};
#define NORMPBLOCK_LENGTH	2

#define CURRENT_NORMVERSION	0


//--- NormalMod methods -------------------------------


NormalMod::NormalMod()
	{	
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descNormVer0, NORMPBLOCK_LENGTH, CURRENT_NORMVERSION));	
	}

void NormalMod::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev)
	{
	pmapParam = CreateCPParamMap(
		descNormParam,NORMPARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_NORMALPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);		
	}
		
void NormalMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{	
	DestroyCPParamMap(pmapParam);
	pmapParam = NULL;
	}

Interval NormalMod::LocalValidity(TimeValue t)
	{	
	return FOREVER;
	}

RefTargetHandle NormalMod::Clone(RemapDir& remap) 
	{
	NormalMod* newmod = new NormalMod();	
	newmod->ReplaceReference(0,pblock->Clone(remap));	
	return newmod;
	}

void FlipMeshNormal(Mesh *mesh,DWORD face) {
	DWORD vis  = 0;
	if (mesh->faces[face].flags&EDGE_A) vis |= EDGE_A;
	if (mesh->faces[face].flags&EDGE_B) vis |= EDGE_C;
	if (mesh->faces[face].flags&EDGE_C) vis |= EDGE_B;
	DWORD temp = mesh->faces[face].v[0];
	mesh->faces[face].v[0] = mesh->faces[face].v[1];
	mesh->faces[face].v[1] = temp;				
	mesh->faces[face].flags &= ~EDGE_ALL;
	mesh->faces[face].flags |= vis;	
	if (mesh->tvFace) {		
		temp = mesh->tvFace[face].t[0];
		mesh->tvFace[face].t[0] = mesh->tvFace[face].t[1];
		mesh->tvFace[face].t[1] = temp;		
	}
}

void NormalMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	Interval valid = FOREVER;
	int flip, unify;
	pblock->GetValue(PB_FLIP,t,flip,valid);	
	pblock->GetValue(PB_UNIFY,t,unify,valid);	

	assert(os->obj->IsSubClassOf(triObjectClassID));
	TriObject *triOb = (TriObject *)os->obj;
	BOOL useSel = triOb->GetMesh().selLevel==MESH_FACE;

	if (unify) {
		triOb->GetMesh().UnifyNormals(useSel);
		triOb->GetMesh().InvalidateTopologyCache ();
		}

	if (flip) {
		for (int i=0; i<triOb->GetMesh().getNumFaces(); i++) {
			if (!useSel || triOb->GetMesh().faceSel[i]) {
				FlipMeshNormal(&triOb->GetMesh(),(DWORD)i);
			}
		}
		triOb->GetMesh().InvalidateTopologyCache ();
	}
			
	triOb->UpdateValidity(TOPO_CHAN_NUM,valid);		
	}

RefResult NormalMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message) 
   	{	
	switch (message) {
		case REFMSG_CHANGE:
			if (pmapParam && pmapParam->GetParamBlock()==pblock) {
				pmapParam->Invalidate();
				}
			break;
		}
	return REF_SUCCEED;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\skew.cpp ===
/**********************************************************************
 *<
	FILE: skew.cpp

	DESCRIPTION:  Skew Modifier

	CREATED BY: Rolf Berteig

	HISTORY: created 18 October 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"

// in mods.cpp
extern HINSTANCE hInstance;

#define BIGFLOAT	float(999999)

class SkewMod : public SimpleMod {	
	public:
		static IParamMap *pmapParam;

		SkewMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_SKEWMOD); }  
		virtual Class_ID ClassID() { return Class_ID(SKEWOSM_CLASS_ID,0);}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_RB_SKEW); }
		IOResult Load(ILoad *iload);

		// From simple mod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		BOOL GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis);
		void InvalidateUI() {if (pmapParam) pmapParam->Invalidate();}
	};

class SkewDeformer: public Deformer {
	public:
		Matrix3 tm,invtm;
		Box3 bbox;		
		float from, to, amountOverLength;
		int doRegion;
		SkewDeformer();
		SkewDeformer(
			ModContext &mc,
			float amount, float dir, int naxis, 
			float from, float to, int doRegion, 
			Matrix3& modmat, Matrix3& modinv);		
		Point3 Map(int i, Point3 p); 
	};

#define SKEWWSM_CLASSID	Class_ID(SKEWOSM_CLASS_ID,1)

class SkewWSM : public SimpleOSMToWSMObject {
	public:
		SkewWSM() {}
		SkewWSM(SkewMod *m) : SimpleOSMToWSMObject(m) {}
		void DeleteThis() { delete this; }
		SClass_ID SuperClassID() {return WSM_OBJECT_CLASS_ID;}
		Class_ID ClassID() {return SKEWWSM_CLASSID;} 
		TCHAR *GetObjectName() {return GetString(IDS_RB_SKEW);}
		RefTargetHandle Clone(RemapDir& remap)
			{return (new SkewWSM((SkewMod*)mod->Clone(remap)))->SimpleOSMToWSMClone(this,remap);}
	};



//--- ClassDescriptor and class vars ---------------------------------

IParamMap *SkewMod::pmapParam = NULL;



class SkewClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SkewMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_SKEW_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(SKEWOSM_CLASS_ID,0); }
	const TCHAR* 	Category() {return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static SkewClassDesc skewDesc;
extern ClassDesc* GetSkewModDesc() { return &skewDesc; }

class SkewWSMClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) 
		{if (loading) return new SkewWSM; else return new SkewWSM(new SkewMod);}
	const TCHAR *	ClassName() { return GetString(IDS_RB_SKEW_CLASS); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return SKEWWSM_CLASSID; }
	const TCHAR* 	Category() {return GetSpaceWarpCatString(SPACEWARP_CAT_MODBASED);}
	};

static SkewWSMClassDesc skewWSMDesc;
extern ClassDesc* GetSkewWSMDesc() { return &skewWSMDesc; }


//--- Parameter map/block descriptors -------------------------------

#define PB_AMOUNT	0
#define PB_DIR		1
#define PB_AXIS		2
#define PB_DOREGION	3
#define PB_FROM		4
#define PB_TO		5


//
//
// Parameters

static int axisIDs[] = {IDC_X,IDC_Y,IDC_Z};

static ParamUIDesc descParam[] = {
	// Amount
	ParamUIDesc(
		PB_AMOUNT,
		EDITTYPE_UNIVERSE,
		IDC_SKEW_AMOUNT,IDC_SKEW_AMOUNTSPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),

	// Direction
	ParamUIDesc(
		PB_DIR,
		EDITTYPE_FLOAT,
		IDC_DIR,IDC_DIRSPINNER,
		-BIGFLOAT,BIGFLOAT,
		0.5f),

	// Axis
	ParamUIDesc(PB_AXIS,TYPE_RADIO,axisIDs,3),

	// Affect region
	ParamUIDesc(PB_DOREGION,TYPE_SINGLECHEKBOX,IDC_SKEW_AFFECTREGION),

	// From
	ParamUIDesc(
		PB_FROM,
		EDITTYPE_UNIVERSE,
		IDC_SKEW_FROM,IDC_SKEW_FROMSPIN,
		-BIGFLOAT,0.0f,
		SPIN_AUTOSCALE),

	// To
	ParamUIDesc(
		PB_TO,
		EDITTYPE_UNIVERSE,
		IDC_SKEW_TO,IDC_SKEW_TOSPIN,
		0.0f,BIGFLOAT,		
		SPIN_AUTOSCALE),	
	};
#define PARAMDESC_LENGH 6


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },	
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 } };
#define PBLOCK_LENGTH	6

#if 0
// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,0)
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);
#endif

#define CURRENT_VERSION	0

//--- SkewDlgProc -------------------------------


class SkewDlgProc : public ParamMapUserDlgProc {
	public:
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {}
	};
static SkewDlgProc theSkewProc;

BOOL SkewDlgProc::DlgProc(
		TimeValue t,IParamMap *map,
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case CC_SPINNER_CHANGE:
			switch (LOWORD(wParam)) {
				case IDC_SKEW_FROMSPIN: {
					float from, to;
					map->GetParamBlock()->GetValue(PB_FROM,t,from,FOREVER);
					map->GetParamBlock()->GetValue(PB_TO,t,to,FOREVER);
					if (from>to) {
						map->GetParamBlock()->SetValue(PB_TO,t,from);
						map->Invalidate();
						}
					break;
					}
				
				case IDC_SKEW_TOSPIN: {
					float from, to;
					map->GetParamBlock()->GetValue(PB_FROM,t,from,FOREVER);
					map->GetParamBlock()->GetValue(PB_TO,t,to,FOREVER);
					if (from>to) {
						map->GetParamBlock()->SetValue(PB_FROM,t,to);
						map->Invalidate();
						}
					break;
					}
				}
			break;
		}
	return FALSE;
	}

//--- Skew methods -------------------------------


SkewMod::SkewMod() : SimpleMod()
	{	
	MakeRefByID(FOREVER, SIMPMOD_PBLOCKREF, 
		CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_AXIS, TimeValue(0), 2/*Z*/);
	}

IOResult SkewMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	//iload->RegisterPostLoadCallback(
	//	new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,SIMPMOD_PBLOCKREF));
	return IO_OK;
	}

void SkewMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleMod::BeginEditParams(ip,flags,prev);
		
	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_SKEWPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);	
	pmapParam->SetUserDlgProc(&theSkewProc);
	}
		
void SkewMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleMod::EndEditParams(ip,flags,next);
	DestroyCPParamMap(pmapParam);
	}

Interval SkewMod::GetValidity(TimeValue t)
	{
	float f;	
	Interval valid = FOREVER;
	pblock->GetValue(PB_AMOUNT,t,f,valid);
	pblock->GetValue(PB_DIR,t,f,valid);	
	pblock->GetValue(PB_FROM,t,f,valid);
	pblock->GetValue(PB_TO,t,f,valid);
	return valid;
	}

BOOL SkewMod::GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis)
	{
	int limit;
	pblock->GetValue(PB_DOREGION,t,limit,FOREVER);
	pblock->GetValue(PB_FROM,t,zmin,FOREVER);
	pblock->GetValue(PB_TO,t,zmax,FOREVER);
	pblock->GetValue(PB_AXIS,t,axis,FOREVER);
	return limit?TRUE:FALSE;
	}

RefTargetHandle SkewMod::Clone(RemapDir& remap) 
	{	
	SkewMod* newmod = new SkewMod();	
	newmod->ReplaceReference(SIMPMOD_PBLOCKREF,pblock->Clone(remap));
	newmod->SimpleModClone(this);
	return(newmod);
	}

SkewDeformer::SkewDeformer() 
	{ 
	tm.IdentityMatrix();
	invtm.IdentityMatrix();
	}

Point3 SkewDeformer::Map(int i, Point3 p)
	{
	float z;	
	p = p * tm;
	z = p.z;
	if (doRegion) {
		if (p.z<from) {
			z = from;
		} else 
		if (p.z>to) {
			z = to;
			}
		}			
	p.x += z * amountOverLength;
	return p * invtm;	
	}

SkewDeformer::SkewDeformer(
		ModContext &mc,
		float amount, float dir, int naxis, 
		float from, float to, int doRegion,
		Matrix3& modmat, Matrix3& modinv) 
	{	
	this->doRegion = doRegion;
	this->from = from;
	this->to   = to;
	Matrix3 mat;
	
	mat.IdentityMatrix();	
	switch (naxis) {
		case 0: mat.RotateY( -HALFPI );	 break; //X
		case 1: mat.RotateX( HALFPI );  break; //Y
		case 2: break;  //Z
		}
	mat.RotateZ(DegToRad(dir));		
	tm    = modmat * mat;
	invtm = Inverse(mat) * modinv;
	
	assert (mc.box);
	bbox = *mc.box;
	
	float len = 0.0f;
	if (!doRegion) {
		switch (naxis) {
			case 0:  len = bbox.pmax.x - bbox.pmin.x; break;
			case 1:	 len = bbox.pmax.y - bbox.pmin.y; break;
			case 2:  len = bbox.pmax.z - bbox.pmin.z; break;
			}
	} else {
		len = to-from;
		}		
	if (len==0.0f) len = 0.000001f;
	amountOverLength = amount/len;
	} 


Deformer& SkewMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	float amount, dir, from, to;
	int axis;	
	int doRegion;
	pblock->GetValue(PB_AMOUNT,t,amount,FOREVER);
	pblock->GetValue(PB_DIR,t,dir,FOREVER);
	pblock->GetValue(PB_AXIS,t,axis,FOREVER);
	pblock->GetValue(PB_FROM,t,from,FOREVER);
	pblock->GetValue(PB_TO,t,to,FOREVER);
	pblock->GetValue(PB_DOREGION,t,doRegion,FOREVER);
	static SkewDeformer deformer;
	deformer = SkewDeformer(mc,amount,dir,axis,from,to,doRegion,mat,invmat);
	return deformer;
	}

ParamDimension *SkewMod::GetParameterDim(int pbIndex)
	{
	switch (pbIndex) {
		case PB_AMOUNT: return stdWorldDim;
		case PB_DIR:	return defaultDim;
		case PB_FROM:	return stdWorldDim;
		case PB_TO:		return stdWorldDim;
		default:		return defaultDim;
		}
	}

TSTR SkewMod::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_AMOUNT:	return GetString(IDS_RB_AMOUNT);
		case PB_DIR:	return GetString(IDS_RB_DIRECTION);
		case PB_FROM:	return GetString(IDS_RB_FROM);
		case PB_TO:		return GetString(IDS_RB_TO);
		default:		return TSTR(_T(""));
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\twist1.cpp ===
#include "mods.h"
#include "twist.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\surfrev.cpp ===
/**********************************************************************
 *<
	FILE: surfrev.cpp

	DESCRIPTION:  Shape->patch surfrev modifier

	CREATED BY: Tom Hudson, Dan Silva & Rolf Berteig

	HISTORY: created 11 November, 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm.h"
#include "shape.h"
#include "spline3d.h"
#include "splshape.h"
#include "linshape.h"
#include "surf_api.h"

//--- SurfrevMod -----------------------------------------------------------

#define CORE_THRESHOLD	0.01f

#define MIN_DEGREES		0.0f
#define MAX_DEGREES		360.0f

#define DEF_DEGREES 360.0f
#define DEF_SEGS 16
#define DEF_CAPSTART 1
#define DEF_CAPEND 1
#define DEF_CAPTYPE CAPTYPE_MORPH
#define DEF_WELDCORE FALSE
#define DEF_FLIPNORMALS FALSE
#define DEF_MAPPING FALSE
#define DEF_GEN_MATIDS TRUE
#define DEF_USE_SHAPEIDS FALSE
#define DEF_SMOOTH TRUE

#define PATCH_OUTPUT 0
#define MESH_OUTPUT 1
#define NURBS_OUTPUT 2

#define DEF_OUTPUT MESH_OUTPUT //PATCH_OUTPUT

#define X_AXIS 0
#define Y_AXIS 1
#define Z_AXIS 2

#define ALIGN_MIN 0
#define ALIGN_CENTER 1
#define ALIGN_MAX 2

class SurfrevMod;

// Our reference indexes
#define AXISREF 0
#define PBLOCKREF 1

// Special dialog handling
class SurfrevDlgProc : public ParamMapUserDlgProc {
	private:
		SurfrevMod *mod;
	public:
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void SetMod(SurfrevMod *m) { mod = m; }
		void DeleteThis() {}
	};

class SurfrevMod: public Modifier {
	protected:
		Control *axisControl;

		static IObjParam *ip;
		static SurfrevMod *editMod;
		static MoveModBoxCMode *moveMode;
		static RotateModBoxCMode *rotMode;
		static UScaleModBoxCMode *uscaleMode;
		static NUScaleModBoxCMode *nuscaleMode;
		static SquashModBoxCMode *squashMode;		

		SurfrevDlgProc dlgProc;
		BOOL doAlign;			// Special command flag.  See SurfrevMod::Align
		int alignType;
	public:
		IParamBlock *pblock;

		static IParamMap *pmapParam;
		
		static float dlgDegrees;
		static BOOL dlgWeldCore;
		static BOOL dlgFlipNormals;
		static int dlgSegs;
		static int dlgCapStart;
		static int dlgCapEnd;
		static int dlgCapType;
		static int dlgOutput;
		static int dlgMapping;
		static int dlgGenMatIDs;
		static int dlgUseShapeIDs;
		static int dlgSmooth;

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= TSTR(GetString(IDS_TH_LATHE_CLASS)); }  
		virtual Class_ID ClassID() { return Class_ID(SURFREVOSM_CLASS_ID,0);}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_TH_LATHE); }
		IOResult Load(ILoad *iload);

		SurfrevMod();
		virtual ~SurfrevMod();

		ChannelMask ChannelsUsed()  { return PART_GEOM|PART_TOPO; }
		// Possible GOTCHA -- Modifiers like this one, which completely change the type of
		// object (shape -> Mesh or Patch) change ALL channels!  Be sure to tell the system!
		ChannelMask ChannelsChanged() { return PART_ALL; }
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Class_ID InputType() {return genericShapeClassID;}
		Interval LocalValidity(TimeValue t);

		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flagst, ModContext *mc);
		void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);
		
		IParamArray *GetParamBlock() {return pblock;}
		int GetParamBlockIndex(int id) {return id;}

		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		BOOL ChangeTopology() {return TRUE;}

		Matrix3 CompMatrix(TimeValue t, ModContext& mc, Matrix3& ntm, 
			Interval& valid, BOOL needOffset);

		// Affine transform methods
		void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
		void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE );
		void Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );

		int NumRefs() {return 2;}
		void RescaleWorldUnits(float f);
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		int SubNumToRefNum(int i) { return i; }
		BOOL AssignController(Animatable *control,int subAnim);

 		int NumSubs() { return 2; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);		

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 

		void ActivateSubobjSel(int level, XFormModes& modes);

		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);

		void BuildMeshFromShape(TimeValue t,ModContext &mc, ObjectState * os, Matrix3 &axis, Mesh &mesh);
		void BuildPatchFromShape(TimeValue t,ModContext &mc, ObjectState * os, Matrix3 &axis, PatchMesh &pmesh);

		void SetAxis(TimeValue t,int type);
		void Align(TimeValue t, int type);
		void UpdateUI(TimeValue t) {}
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		// Automatic texture support
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);

		// Parameter access
		BOOL GetGenMatIDs();
	};

BOOL SurfrevDlgProc::DlgProc(
		TimeValue t,IParamMap *map,
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	ICustButton *but;
	switch (msg) {
		case WM_INITDIALOG:
			but = GetICustButton(GetDlgItem(hWnd,IDC_X));
			but->SetType(CBT_PUSH);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hWnd,IDC_Y));
			but->SetType(CBT_PUSH);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hWnd,IDC_Z));
			but->SetType(CBT_PUSH);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hWnd,IDC_ALIGNMIN));
			but->SetType(CBT_PUSH);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hWnd,IDC_ALIGNCENTER));
			but->SetType(CBT_PUSH);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hWnd,IDC_ALIGNMAX));
			but->SetType(CBT_PUSH);
			ReleaseICustButton(but);
			EnableWindow(GetDlgItem(hWnd,IDC_USE_SHAPE_IDS),mod->GetGenMatIDs());
			break;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_X:
					mod->SetAxis(t, X_AXIS);
					break;
				case IDC_Y:
					mod->SetAxis(t, Y_AXIS);
					break;
				case IDC_Z:
					mod->SetAxis(t, Z_AXIS);
					break;
				case IDC_ALIGNMIN:
					mod->Align(t, ALIGN_MIN);
					break;
				case IDC_ALIGNCENTER:
					mod->Align(t, ALIGN_CENTER);
					break;
				case IDC_ALIGNMAX:
					mod->Align(t, ALIGN_MAX);
					break;
				case IDC_GEN_MATIDS:
					EnableWindow(GetDlgItem(hWnd,IDC_USE_SHAPE_IDS),mod->GetGenMatIDs());
					break;
				}
			break;
		}
	return FALSE;
	}

class SurfrevClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SurfrevMod; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_LATHE_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return  Class_ID(SURFREVOSM_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	void			ResetClassParams(BOOL fileReset);
	};

void SurfrevClassDesc::ResetClassParams(BOOL fileReset)
	{
	SurfrevMod::dlgDegrees = DEF_DEGREES;
	SurfrevMod::dlgWeldCore = DEF_WELDCORE;
	SurfrevMod::dlgFlipNormals = DEF_FLIPNORMALS;
	SurfrevMod::dlgSegs = DEF_SEGS;
	SurfrevMod::dlgCapStart = DEF_CAPSTART;
	SurfrevMod::dlgCapEnd = DEF_CAPEND;
	SurfrevMod::dlgCapType = DEF_CAPTYPE;
	SurfrevMod::dlgOutput = DEF_OUTPUT;
	SurfrevMod::dlgMapping = DEF_MAPPING;
	SurfrevMod::dlgGenMatIDs    = DEF_GEN_MATIDS;
	SurfrevMod::dlgUseShapeIDs  = DEF_USE_SHAPEIDS;
	SurfrevMod::dlgSmooth = DEF_SMOOTH;
	}

static SurfrevClassDesc surfrevDesc;
extern ClassDesc* GetSurfrevModDesc() { return &surfrevDesc; }

IObjParam*		SurfrevMod::ip          = NULL;
SurfrevMod *	SurfrevMod::editMod	    = NULL;
MoveModBoxCMode*    SurfrevMod::moveMode    = NULL;
RotateModBoxCMode*  SurfrevMod::rotMode 	   = NULL;
UScaleModBoxCMode*  SurfrevMod::uscaleMode  = NULL;
NUScaleModBoxCMode* SurfrevMod::nuscaleMode = NULL;
SquashModBoxCMode*  SurfrevMod::squashMode  = NULL;

IParamMap *		SurfrevMod::pmapParam = NULL;
float			SurfrevMod::dlgDegrees = DEF_DEGREES;
BOOL			SurfrevMod::dlgWeldCore = DEF_WELDCORE;
BOOL			SurfrevMod::dlgFlipNormals = DEF_FLIPNORMALS;
int				SurfrevMod::dlgSegs = DEF_SEGS;
int				SurfrevMod::dlgCapStart = DEF_CAPSTART;
int				SurfrevMod::dlgCapEnd = DEF_CAPEND;
int				SurfrevMod::dlgCapType = DEF_CAPTYPE;
int				SurfrevMod::dlgOutput = DEF_OUTPUT;
BOOL			SurfrevMod::dlgMapping = DEF_MAPPING;
int				SurfrevMod::dlgGenMatIDs = DEF_GEN_MATIDS;
int				SurfrevMod::dlgUseShapeIDs = DEF_USE_SHAPEIDS;
int				SurfrevMod::dlgSmooth = DEF_SMOOTH;

//--- Parameter map/block descriptors -------------------------------

#define PB_DEGREES		0
#define PB_SEGS			1
#define PB_CAPSTART		2
#define PB_CAPEND		3
#define PB_CAPTYPE		4
#define PB_WELDCORE		5
#define PB_OUTPUT		6
#define PB_MAPPING		7
#define PB_FLIPNORMALS	8
#define PB_GEN_MATIDS	9
#define PB_USE_SHAPEIDS	10
#define PB_SMOOTH		11

//
//
// Parameters

static int captypeIDs[] = {IDC_MORPHCAP,IDC_GRIDCAP};
static int outputIDs[] = {IDC_PATCH,IDC_MESH, IDC_NURBS};

static ParamUIDesc descParam[] = {
	// Degrees
	ParamUIDesc(
		PB_DEGREES,
		EDITTYPE_FLOAT,
		IDC_DEGREES,IDC_DEGREESSPINNER,
		MIN_DEGREES,MAX_DEGREES,
		0.5f),

	// Weld Core
	ParamUIDesc(PB_WELDCORE,TYPE_SINGLECHEKBOX,IDC_WELDCORE),

	// Segments
	ParamUIDesc(
		PB_SEGS,
		EDITTYPE_INT,
		IDC_SEGMENTS,IDC_SEGMENTSPINNER,
		3.0f,100.0f,
		0.5f),

	// Capping start
	ParamUIDesc(PB_CAPSTART,TYPE_SINGLECHEKBOX,IDC_CAPSTART),

	// Capping end
	ParamUIDesc(PB_CAPEND,TYPE_SINGLECHEKBOX,IDC_CAPEND),

	// Cap type
	ParamUIDesc(PB_CAPTYPE,TYPE_RADIO,captypeIDs,2),

	// Output type
	ParamUIDesc(PB_OUTPUT,TYPE_RADIO,outputIDs,3),

	// Generate Texture coords?
	ParamUIDesc(PB_MAPPING,TYPE_SINGLECHEKBOX,IDC_GENMAPPING),

	// Flip Normals
	ParamUIDesc(PB_FLIPNORMALS,TYPE_SINGLECHEKBOX,IDC_FLIPNORMALS),

	// Multi material IDs
	ParamUIDesc(PB_GEN_MATIDS,TYPE_SINGLECHEKBOX,IDC_GEN_MATIDS),

	// Shape material IDs
	ParamUIDesc(PB_USE_SHAPEIDS,TYPE_SINGLECHEKBOX,IDC_USE_SHAPE_IDS),

	// Smoothing
	ParamUIDesc(PB_SMOOTH,TYPE_SINGLECHEKBOX,IDC_SMOOTH)
	};
#define PARAMDESC_LENGTH 12


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 } };

static ParamBlockDescID descVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 } };

static ParamBlockDescID descVer3[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 } };

static ParamBlockDescID descVer4[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 },
	{ TYPE_INT, NULL, FALSE, 8 } };

static ParamBlockDescID descVer5[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 },
	{ TYPE_INT, NULL, FALSE, 8 },
	{ TYPE_INT, NULL, FALSE, 9 } };

static ParamBlockDescID descVer6[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 },
	{ TYPE_INT, NULL, FALSE, 8 },
	{ TYPE_INT, NULL, FALSE, 9 },
	{ TYPE_INT, NULL, FALSE, 10 } };

static ParamBlockDescID descVer7[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 },
	{ TYPE_INT, NULL, FALSE, 8 },
	{ TYPE_INT, NULL, FALSE, 9 },
	{ TYPE_INT, NULL, FALSE, 10 },
	{ TYPE_INT, NULL, FALSE, 11 } };

#define PBLOCK_LENGTH	12

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,4,0),	
	ParamVersionDesc(descVer1,6,1),
	ParamVersionDesc(descVer2,7,2),	
	ParamVersionDesc(descVer3,8,3),	
	ParamVersionDesc(descVer4,9,4),	
	ParamVersionDesc(descVer5,10,5),	
	ParamVersionDesc(descVer6,11,6)	
	};
#define NUM_OLDVERSIONS	7

// Current version
#define CURRENT_VERSION	7
static ParamVersionDesc curVersion(descVer7,PBLOCK_LENGTH,CURRENT_VERSION);

SurfrevMod::SurfrevMod()
	{
	doAlign = FALSE;

	// Create a parameter block
	MakeRefByID(FOREVER, PBLOCKREF, 
		CreateParameterBlock(descVer7, PBLOCK_LENGTH, CURRENT_VERSION));
	pblock->SetValue(PB_DEGREES, TimeValue(0), dlgDegrees);
	pblock->SetValue(PB_SEGS, TimeValue(0), dlgSegs);
	pblock->SetValue(PB_CAPSTART, TimeValue(0), dlgCapStart);
	pblock->SetValue(PB_CAPEND, TimeValue(0), dlgCapEnd);
	pblock->SetValue(PB_CAPTYPE, TimeValue(0), dlgCapType);
	pblock->SetValue(PB_WELDCORE, TimeValue(0), dlgWeldCore);
	pblock->SetValue(PB_FLIPNORMALS, TimeValue(0), dlgFlipNormals);
	pblock->SetValue(PB_OUTPUT, TimeValue(0), dlgOutput);
	pblock->SetValue(PB_MAPPING, TimeValue(0), dlgMapping);
	pblock->SetValue(PB_GEN_MATIDS, TimeValue(0), dlgGenMatIDs);
	pblock->SetValue(PB_USE_SHAPEIDS, TimeValue(0), dlgUseShapeIDs);
	pblock->SetValue(PB_SMOOTH, TimeValue(0), dlgSmooth);

	// Create a transform controller for the surfrev axis
	MakeRefByID(FOREVER, AXISREF, NewDefaultMatrix3Controller()); 
	NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);

	// Set the axis controller's matrix aligned with the Y axis
	SetAxis(0, Y_AXIS);

	dlgProc.SetMod(this);
	}

SurfrevMod::~SurfrevMod() {	
	DeleteAllRefsFromMe();
	}

void SurfrevMod::RescaleWorldUnits(float f) {
	if (TestAFlag(A_WORK1))
		return;
	SetAFlag(A_WORK1);
	
	// rescale all our references
	for (int i=0; i<NumRefs(); i++) {
		ReferenceMaker *srm = GetReference(i);
		if (srm) 
			srm->RescaleWorldUnits(f);
		}
	}

RefTargetHandle SurfrevMod::GetReference(int i) 
	{ 
	switch (i) {
		case AXISREF: return axisControl;
		case PBLOCKREF: return pblock;
		default: return NULL;
		}
	}

void SurfrevMod::SetReference(int i, RefTargetHandle rtarg) 
	{ 
	switch (i) {
		case AXISREF: axisControl = (Control*)rtarg; break;
		case PBLOCKREF: pblock = (IParamBlock*)rtarg; break;
		}
	}

BOOL SurfrevMod::AssignController(Animatable *control,int subAnim) {
	if(subAnim != 0)
		return FALSE;
	ReplaceReference(0,(Control*)control);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	return TRUE;
	}

Animatable* SurfrevMod::SubAnim(int i) 
	{ 
	switch (i) {
		case AXISREF: return axisControl;
		case PBLOCKREF: return pblock;		
		default: return NULL;
		}
	}

TSTR SurfrevMod::SubAnimName(int i) 
	{ 
	switch (i) {
		case AXISREF: return TSTR(GetString(IDS_TH_AXIS));
		case PBLOCKREF: return TSTR(GetString(IDS_RB_PARAMETERS));
		default: return TSTR(_T(""));
		}	
	}

Interval SurfrevMod::LocalValidity(TimeValue t)
	{
	// if being edited, return NEVER forces a cache to be built 
	// after previous modifier.
	if (TestAFlag(A_MOD_BEING_EDITED))
		return NEVER;  
	Interval valid = GetValidity(t);	
	Matrix3 mat;	
	mat.IdentityMatrix();		
	axisControl->GetValue(t,&mat,valid,CTRL_RELATIVE);
	return valid;
	}

RefTargetHandle SurfrevMod::Clone(RemapDir& remap)
	{
	SurfrevMod* newmod = new SurfrevMod();	
	newmod->ReplaceReference(PBLOCKREF,pblock->Clone(remap));
	newmod->ReplaceReference(AXISREF, axisControl->Clone()); 
	return(newmod);
	}

//  Move, Rotate, and Scale

void SurfrevMod::Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin ) {
	if ( ip && ip->GetSubObjectLevel()==1 ) {
		SetXFormPacket pckt(val,partm,tmAxis);
		axisControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
		}
	}

void SurfrevMod::Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin ) {
	SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
	axisControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	}

void SurfrevMod::Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin ) {
	SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
	axisControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	}

Matrix3 SurfrevMod::CompMatrix(TimeValue t, ModContext& mc, Matrix3& ntm, 
		Interval& valid, BOOL needOffset) {
	Matrix3 tm;
	
	if (mc.tm) {
		tm = *mc.tm;		
		}
	else 
		tm.IdentityMatrix();	
	Matrix3 mat;
	mat.IdentityMatrix();
	axisControl->GetValue(t,&mat,valid,CTRL_RELATIVE);
	tm = tm*Inverse(mat);		

	return Inverse(tm)*ntm;	
	}

int SurfrevMod::HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc) {
	GraphicsWindow *gw = vpt->getGW();
	Interval valid;
	int savedLimits;	
	HitRegion hr;
	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);
	Matrix3 modmat, ntm = inode->GetObjectTM(t);
		
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->clearHitCode();
	
	if (ip && ip->GetSubObjectLevel() == 1) {
		modmat = CompMatrix(t,*mc,ntm,valid,FALSE);
		gw->setTransform(modmat);
		Point3 pt[3];
        ObjectState os = inode->EvalWorldState(t);
        ShapeObject *shape = (ShapeObject *)os.obj;
        // Get our axis orientation
        Matrix3 axis(TRUE);
        axisControl->GetValue(t, &axis, FOREVER, CTRL_RELATIVE);
        Box3 bbox;
        Matrix3 iaxis = Inverse(axis);
        shape->GetDeformBBox(t, bbox, &iaxis);
		pt[0] = Point3(0.0f,0.0f,bbox.Min().z);
		pt[1] = Point3(0.0f,0.0f,bbox.Max().z);
		gw->polyline(2, pt, NULL, NULL, 1, NULL);
    }
    
	gw->setRndLimits(savedLimits);	
	if (gw->checkHitCode()) {
		vpt->LogHit(inode, mc, gw->getHitDistance(), 0, NULL); 
		return 1;
		}
	return 0;
	}

int SurfrevMod::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext *mc) {
	Interval valid;
	GraphicsWindow *gw = vpt->getGW();
#ifdef DESIGN_VER
	// Transform the gizmo with the node.
	TimeValue rt = GetCOREInterface()->GetTime();
	Matrix3 modmat, ntm = inode->GetObjectTM(rt);
#else
	Matrix3 modmat, ntm = inode->GetObjectTM(t);
#endif

	modmat = CompMatrix(t,*mc,ntm,valid,FALSE);
	gw->setTransform(modmat);
	if ( ip && ip->GetSubObjectLevel() == 1 ) {		
		gw->setColor( LINE_COLOR, (float)1.0, (float)1.0, (float)0.0);
		}
	Point3 pt[2];
	ObjectState os = inode->EvalWorldState(t);
	ShapeObject *shape = (ShapeObject *)os.obj;
	// Get our axis orientation
	Matrix3 axis(TRUE);
	axisControl->GetValue(t, &axis, FOREVER, CTRL_RELATIVE);
	Box3 bbox;
	Matrix3 iaxis = Inverse(axis);
	shape->GetDeformBBox(t, bbox, &iaxis);
	pt[0] = Point3(0.0f,0.0f,bbox.Min().z);
	pt[1] = Point3(0.0f,0.0f,bbox.Max().z);
	gw->polyline(2, pt, NULL, NULL, 1, NULL);
	
	UpdateUI(t);
	return 0;	
	}

void SurfrevMod::GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc) {
	Interval valid;
	GraphicsWindow *gw = vpt->getGW();
#ifdef DESIGN_VER
	// Need the correct bound box for proper damage rect calcs.
	TimeValue rt = GetCOREInterface()->GetTime();
	Matrix3 modmat, ntm = inode->GetObjectTM(rt);
#else
	Matrix3 modmat, ntm = inode->GetObjectTM(t);
#endif

	ObjectState os = inode->EvalWorldState(t);
	ShapeObject *shape = (ShapeObject *)os.obj;
	// Get our axis orientation
	Matrix3 axis(TRUE);
	axisControl->GetValue(t, &axis, FOREVER, CTRL_RELATIVE);
	Box3 bbox;
	Matrix3 iaxis = Inverse(axis);
	shape->GetDeformBBox(t, bbox, &iaxis);
	modmat = CompMatrix(t,*mc,ntm,valid,FALSE);
	box.Init();
	box = bbox * modmat;
	}

void SurfrevMod::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Interval valid;
	Matrix3 modmat, tm, ntm = node->GetObjectTM(t,&valid);

	if (cb->Type()==SO_CENTER_PIVOT) {
		tm = CompMatrix(t,*mc,ntm,valid,TRUE);
		cb->Center(tm.GetTrans(),0);
	} else {
		modmat = CompMatrix(t,*mc,ntm,valid,FALSE);
		cb->Center(Point3(0,0,0)*modmat,0);
		}
	}

void SurfrevMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Interval valid;
	Matrix3 ntm = node->GetObjectTM(t,&valid);
	Matrix3 tm = CompMatrix(t,*mc,ntm,valid,TRUE);
	cb->TM(tm,0);
	}

void SurfrevMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState * os, INode *node) 
	{	
	if(doAlign) {
		// Get our axis orientation
		Matrix3 axis(TRUE);
		axisControl->GetValue(t, &axis, FOREVER, CTRL_RELATIVE);
		doAlign = FALSE;
		// Let's get the bounds of the object in the current space
		ShapeObject *shape = (ShapeObject *)os->obj;
		Box3 bbox;
		Matrix3 iaxis = Inverse(axis);
		shape->GetDeformBBox(t, bbox, &iaxis);
		// Use the X axis for the alignment
		Point3 pos(0,0,0);
		switch(alignType) {
			case ALIGN_MIN:
				pos = Point3(bbox.pmin.x, bbox.Center().y, bbox.Center().z);
				break;
			case ALIGN_CENTER:
				pos = bbox.Center();
				break;
			case ALIGN_MAX:
				pos = Point3(bbox.pmax.x, bbox.Center().y, bbox.Center().z);
				break;
			}
		axis.SetTrans(pos * axis);
		axisControl->SetValue(t, &SetXFormPacket(axis));
		}
	 		
//DebugPrint("Surfrev modifying object\n");

	// Get our personal validity interval...
	Interval valid = GetValidity(t);
	// and intersect it with the channels we use as input (see ChannelsUsed)
	valid &= os->obj->ChannelValidity(t,TOPO_CHAN_NUM);
	valid &= os->obj->ChannelValidity(t,GEOM_CHAN_NUM);

	// Get the object TM
	Matrix3 objTM(TRUE);
	if(mc.tm)
		objTM = *mc.tm;
	
	// Get our axis orientation
	Matrix3 axis(TRUE);
	axisControl->GetValue(t, &axis, valid, CTRL_RELATIVE);

	int output;
	pblock->GetValue(PB_OUTPUT, TimeValue(0), output, FOREVER);

	// Here is where all the fun stuff happens
	switch (output) {
	case NURBS_OUTPUT:
#ifndef NO_NURBS
		{
		// Here is where all the fun stuff happens -- GenerateLatheSurface fills in the EM,
		// then we stuff the EditableSurface into the pipeline.
		ShapeObject *shape = (ShapeObject *)os->obj;

		BOOL texturing, genMatIds, useShapeIDs;
		pblock->GetValue(PB_MAPPING, TimeValue(0), texturing, FOREVER);
		pblock->GetValue(PB_GEN_MATIDS, TimeValue(0), genMatIds, FOREVER);
		pblock->GetValue(PB_USE_SHAPEIDS, TimeValue(0), useShapeIDs, FOREVER);

		float degrees;
		int capStart, capEnd, capType, segs;
		BOOL weldCore, flipNormals;

		pblock->GetValue(PB_SEGS,t,segs,FOREVER);
		pblock->GetValue(PB_CAPSTART,t,capStart,FOREVER);
		pblock->GetValue(PB_CAPEND,t,capEnd,FOREVER);
		pblock->GetValue(PB_CAPTYPE,t,capType,FOREVER);
		pblock->GetValue(PB_WELDCORE,t,weldCore,FOREVER);
		pblock->GetValue(PB_FLIPNORMALS,t,flipNormals,FOREVER);

		pblock->GetValue(PB_DEGREES,t,degrees,FOREVER);
		LimitValue(degrees, MIN_DEGREES, MAX_DEGREES);

		BOOL suspended = FALSE;
		if (theHold.Holding()) {
			theHold.Suspend();
			suspended = TRUE;
		}
		Object *nobj = CreateNURBSLatheShape(ip, GetString(IDS_TH_LATHE_CLASS),
						t, shape, axis * Inverse(objTM), degrees, capStart, capEnd, capType,
						weldCore, flipNormals, texturing, segs, genMatIds, useShapeIDs);
		if (suspended) {
			theHold.Resume();
		}

        // We only set geom validity because we preserve animation on clone
        // and copying other cahnnels causes problems -- SCM 9/2/97
		nobj->SetChannelValidity(GEOM_CHAN_NUM, valid);

		os->obj = nobj;
		break;}
#endif
	case PATCH_OUTPUT: {
		// BuildPatchFromShape fills in the PatchObject's patch mesh,
		// then we stuff the PatchObject into the pipeline.
		PatchObject *pat = new PatchObject;
		BuildPatchFromShape(t, mc, os, axis * Inverse(objTM), pat->patch);

		pat->SetChannelValidity(TOPO_CHAN_NUM, valid);
		pat->SetChannelValidity(GEOM_CHAN_NUM, valid);
		pat->SetChannelValidity(TEXMAP_CHAN_NUM, valid);
		pat->SetChannelValidity(MTL_CHAN_NUM, valid);
		pat->SetChannelValidity(SELECT_CHAN_NUM, valid);
		pat->SetChannelValidity(SUBSEL_TYPE_CHAN_NUM, valid);
		pat->SetChannelValidity(DISP_ATTRIB_CHAN_NUM, valid);

		os->obj = pat;
		break; }
	case MESH_OUTPUT: {
		// BuildMeshFromShape fills in the TriObject's mesh,
		// then we stuff the TriObj into the pipeline.
		TriObject *tri = CreateNewTriObject();
		BuildMeshFromShape(t, mc, os, axis * Inverse(objTM), tri->GetMesh());

		tri->SetChannelValidity(TOPO_CHAN_NUM, valid);
		tri->SetChannelValidity(GEOM_CHAN_NUM, valid);
		tri->SetChannelValidity(TEXMAP_CHAN_NUM, valid);
		tri->SetChannelValidity(MTL_CHAN_NUM, valid);
		tri->SetChannelValidity(SELECT_CHAN_NUM, valid);
		tri->SetChannelValidity(SUBSEL_TYPE_CHAN_NUM, valid);
		tri->SetChannelValidity(DISP_ATTRIB_CHAN_NUM, valid);

		os->obj = tri;
		break;}
	}

	os->obj->UnlockObject();
//DebugPrint("Surfrev modification complete!\n");
	}


void SurfrevMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	this->ip = ip;
	editMod = this;

	// Add our sub object type
	TSTR type1( GetString(IDS_TH_AXIS) );
	const TCHAR *ptype[] = { type1 };
	ip->RegisterSubObjectTypes( ptype, 1 );

	// Create sub object editing modes.
	moveMode    = new MoveModBoxCMode(this,ip);
	rotMode     = new RotateModBoxCMode(this,ip);
	uscaleMode  = new UScaleModBoxCMode(this,ip);
	nuscaleMode = new NUScaleModBoxCMode(this,ip);
	squashMode  = new SquashModBoxCMode(this,ip);	
	
	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);

	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGTH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_SURFREVPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);	
	pmapParam->SetUserDlgProc(&dlgProc);
	}

void SurfrevMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next)
	{
	this->ip = NULL;
	editMod = NULL;
	
	TimeValue t = ip->GetTime();

	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);
	ClearAFlag(A_MOD_BEING_EDITED);

	DestroyCPParamMap(pmapParam);

	ip->DeleteMode(moveMode);
	ip->DeleteMode(rotMode);
	ip->DeleteMode(uscaleMode);
	ip->DeleteMode(nuscaleMode);
	ip->DeleteMode(squashMode);	
	if ( moveMode ) delete moveMode;
	moveMode = NULL;
	if ( rotMode ) delete rotMode;
	rotMode = NULL;
	if ( uscaleMode ) delete uscaleMode;
	uscaleMode = NULL;
	if ( nuscaleMode ) delete nuscaleMode;
	nuscaleMode = NULL;
	if ( squashMode ) delete squashMode;
	squashMode = NULL;

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_DEGREES,ip->GetTime(),dlgDegrees,FOREVER);
	pblock->GetValue(PB_SEGS,ip->GetTime(),dlgSegs,FOREVER);
	pblock->GetValue(PB_CAPSTART,ip->GetTime(),dlgCapStart,FOREVER);
	pblock->GetValue(PB_CAPEND,ip->GetTime(),dlgCapEnd,FOREVER);
	pblock->GetValue(PB_CAPTYPE,ip->GetTime(),dlgCapType,FOREVER);
	pblock->GetValue(PB_WELDCORE,ip->GetTime(),dlgWeldCore,FOREVER);
	pblock->GetValue(PB_FLIPNORMALS,ip->GetTime(),dlgFlipNormals,FOREVER);
	pblock->GetValue(PB_OUTPUT,ip->GetTime(),dlgOutput,FOREVER);
	pblock->GetValue(PB_MAPPING,ip->GetTime(),dlgMapping,FOREVER);
	pblock->GetValue(PB_GEN_MATIDS,ip->GetTime(),dlgGenMatIDs,FOREVER);
	pblock->GetValue(PB_USE_SHAPEIDS,ip->GetTime(),dlgUseShapeIDs,FOREVER);
	pblock->GetValue(PB_SMOOTH,ip->GetTime(),dlgSmooth,FOREVER);
	}

Interval SurfrevMod::GetValidity(TimeValue t)
	{
	float f;
	int i;
	Interval valid = FOREVER;
	pblock->GetValue(PB_DEGREES,t,f,valid);
	pblock->GetValue(PB_SEGS,t,i,valid);	
	pblock->GetValue(PB_CAPSTART,t,i,valid);
	pblock->GetValue(PB_CAPEND,t,i,valid);
	pblock->GetValue(PB_CAPTYPE,t,i,valid);
	pblock->GetValue(PB_WELDCORE,t,i,valid);
	pblock->GetValue(PB_FLIPNORMALS,t,i,valid);
	pblock->GetValue(PB_OUTPUT,t,i,valid);
	pblock->GetValue(PB_MAPPING,t,i,valid);
	return valid;
	}

void SurfrevMod::ActivateSubobjSel(int level, XFormModes& modes )
	{	
	switch ( level ) {
		case 1: // Axis
			modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,NULL);
			break;
		}
	NotifyDependents(FOREVER,PART_DISPLAY,REFMSG_CHANGE);
	}

RefResult SurfrevMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message ) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
			if ((editMod==this) && pmapParam) pmapParam->Invalidate();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}

ParamDimension *SurfrevMod::GetParameterDim(int pbIndex)
	{
	switch (pbIndex) {
		case PB_DEGREES: 	return stdAngleDim;
		case PB_SEGS:		return defaultDim;
		case PB_CAPSTART:	return defaultDim;
		case PB_CAPEND:		return defaultDim;
		case PB_CAPTYPE:	return defaultDim;
		case PB_WELDCORE:	return defaultDim;
		case PB_FLIPNORMALS:	return defaultDim;
		default:			return defaultDim;
		}
	}

TSTR SurfrevMod::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_DEGREES:	return TSTR(GetString(IDS_TH_DEGREES));
		case PB_SEGS:		return TSTR(GetString(IDS_TH_SEGMENTS));
		default:			return TSTR(_T(""));
		}
	}

BOOL SurfrevMod::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_MAPPING, 0, genUVs, v);
	return genUVs; 
	}

void SurfrevMod::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_MAPPING,0, sw);				
	}

BOOL SurfrevMod::GetGenMatIDs() {
	int sw;
	Interval v;
	pblock->GetValue(PB_GEN_MATIDS, 0, sw, v);
	return sw;
	}

class SurfrevPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		SurfrevPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload);
	};

void SurfrevPostLoadCallback::proc(ILoad *iload) {
	DWORD oldVer = ((SurfrevMod*)(cb->targ))->pblock->GetVersion();
	ReferenceTarget *targ = cb->targ;
	cb->proc(iload);
	if (oldVer<5)			
		((SurfrevMod*)targ)->pblock->SetValue(PB_GEN_MATIDS,0,FALSE);
	if (oldVer<6)
		((SurfrevMod*)targ)->pblock->SetValue(PB_USE_SHAPEIDS,0,FALSE);
	if (oldVer<7)
		((SurfrevMod*)targ)->pblock->SetValue(PB_SMOOTH,0,TRUE);
	delete this;
	}

IOResult SurfrevMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	iload->RegisterPostLoadCallback(
		new SurfrevPostLoadCallback(
			new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,PBLOCKREF)));
	return IO_OK;
	}

class ShapeDims {
	public:
	float minx, maxx, xsize, coreThresh;
	ShapeDims() { minx = maxx = xsize = coreThresh = 0.0f; }
	};

static void MakeMeshCapTexture(Mesh &mesh, Matrix3 &itm, int fstart, int fend) {
	if(fstart == fend)
		return;
	// Find out which verts are used by the cap
	BitArray capVerts(mesh.numVerts);
	capVerts.ClearAll();
	for(int i = fstart; i < fend; ++i) {
		Face &f = mesh.faces[i];
		capVerts.Set(f.v[0]);
		capVerts.Set(f.v[1]);
		capVerts.Set(f.v[2]);
		}
	// Minmax the verts involved in X/Y axis and total them
	Box3 bounds;
	int numCapVerts = 0;
	int numCapFaces = fend - fstart;
	IntTab capIndexes;
	capIndexes.SetCount(mesh.numVerts);
	int baseTVert = mesh.getNumTVerts();
	for(i = 0; i < mesh.numVerts; ++i) {
		if(capVerts[i]) {
			capIndexes[i] = baseTVert + numCapVerts++;
			bounds += mesh.verts[i] * itm;
			}
		}
	mesh.setNumTVerts(baseTVert + numCapVerts, TRUE);
	Point3 s(1.0f / bounds.Width().x, 1.0f / bounds.Width().y, 0.0f);
	Point3 t(-bounds.Min().x, -bounds.Min().y, 0.0f);
	// Do the TVerts
	for(i = 0; i < mesh.numVerts; ++i) {
		if(capVerts[i])
			mesh.setTVert(baseTVert++, ((mesh.verts[i] * itm) + t) * s);
		}
	// Do the TVFaces
	for(i = fstart; i < fend; ++i) {
		Face &f = mesh.faces[i];
		mesh.tvFace[i] = TVFace(capIndexes[f.v[0]], capIndexes[f.v[1]], capIndexes[f.v[2]]);
		}
	}

void SurfrevMod::BuildMeshFromShape(TimeValue t,ModContext &mc, ObjectState * os, Matrix3 &axis, Mesh &mesh) {
	BOOL texturing;
	pblock->GetValue(PB_MAPPING, TimeValue(0), texturing, FOREVER);
	BOOL genMatIDs;
	pblock->GetValue(PB_GEN_MATIDS, TimeValue(0), genMatIDs, FOREVER);
	BOOL useShapeIDs;
	pblock->GetValue(PB_USE_SHAPEIDS, TimeValue(0), useShapeIDs, FOREVER);
	BOOL smooth;
	pblock->GetValue(PB_SMOOTH, TimeValue(0), smooth, FOREVER);
	
	ShapeObject *shape = (ShapeObject *)os->obj;

	float degrees;
	int levels,capStart,capEnd,capType;
	BOOL weldCore, flipNormals;

	pblock->GetValue(PB_DEGREES,t,degrees,FOREVER);
	pblock->GetValue(PB_SEGS,t,levels,FOREVER);
	pblock->GetValue(PB_CAPSTART,t,capStart,FOREVER);
	pblock->GetValue(PB_CAPEND,t,capEnd,FOREVER);
	pblock->GetValue(PB_CAPTYPE,t,capType,FOREVER);
	pblock->GetValue(PB_WELDCORE,t,weldCore,FOREVER);
	pblock->GetValue(PB_FLIPNORMALS,t,flipNormals,FOREVER);

	LimitValue(degrees, MIN_DEGREES, MAX_DEGREES);
	LimitValue(levels, 3, 100);

	BOOL fullCircle = (degrees == 360.0f) ? TRUE : FALSE;

	// Get the basic dimension stuff
	float radians = (float)fabs(degrees) * DEG_TO_RAD;

	// Make the shape convert itself to a PolyShape -- This makes our mesh conversion MUCH easier!
	
	PolyShape pShape;
	shape->MakePolyShape(t, pShape);
	ShapeHierarchy hier;
	pShape.OrganizeCurves(t, &hier);
	// Need to flip the reversed curves in the shape!
	pShape.Reverse(hier.reverse);

	int polys = pShape.numLines;
	int levelVerts = 0, levelFaces = 0, levelTVerts = 0;
	int verts = 0, faces = 0, tVerts = 0;
	int poly, piece;

	BOOL anyClosed = FALSE;
	for(poly = 0; poly < polys; ++poly) {
		PolyLine &line = pShape.lines[poly];
		if(!line.numPts)
			continue;
		if(line.IsClosed()) {
			anyClosed = TRUE;
			levelTVerts++;
			}
		levelVerts += line.numPts;
		levelTVerts += line.numPts;
		levelFaces += (line.Segments() * 2);
		}

	int vertsPerLevel = levelVerts;
	int numLevels = levels;
	int vertLevels = levels + (fullCircle ? 0 : 1);
	int TVlevels = levels + 1;

	verts = levelVerts * vertLevels;
	tVerts = levelTVerts * TVlevels;
	faces = levelFaces * levels;

	mesh.setNumVerts(verts);
	mesh.setNumFaces(faces);
	if(texturing) {
		mesh.setNumTVerts(tVerts);
		mesh.setNumTVFaces(faces);
		}

	// Set up the rotational axis transform
	Matrix3 iaxis = Inverse(axis);

	// Set up a transform that will back out everything but our rotation
	// about the axis
	Matrix3 itm = Inverse(iaxis * RotateZMatrix(0.0f) * axis);

	// A flag to detect whether this will be an inside-out object
	BOOL inverse = FALSE;

	// Make a bit array which indicates which verts get welded
	BitArray weldFlags(levelVerts);
	weldFlags.ClearAll();

	// Get information on the shapes
	ShapeDims *sDims = new ShapeDims [polys];
	for(poly = 0; poly < polys; ++poly) {
		ShapeDims &dim = sDims[poly];
		PolyLine &line = pShape.lines[poly];
		if(!line.numPts)
			continue;
		int lverts = line.numPts;
		for(int v = 0; v < lverts; ++v) {
			PolyPt &pp = line[v];
			Point3 test = pp.p * iaxis;
			if(v == 0 || test.x < dim.minx)
				dim.minx = test.x;
			if(v == 0 || test.x > dim.maxx)
				dim.maxx = test.x;
			}
		dim.xsize = dim.maxx - dim.minx;
		dim.coreThresh = dim.xsize / 100.0f;
		if(dim.coreThresh > 0.01f)
			dim.coreThresh = 0.01f;
		}

	// Create the vertices!
	int vert = 0;
	Matrix3 mat1, mat2;
	for(int level = 0; level < vertLevels; ++level) {
		int levelBase = vert;
		// Create a matrix for the operation
		Matrix3 tm = iaxis * RotateZMatrix((float)level / (float)levels * radians) * axis;
		if(level == 0)
			mat1 = tm;
		else
		if(level == (vertLevels - 1))
			mat2 = tm;
#ifdef TEST_TAPER
		// For testing -- tapers down toward end
		float scale = 1.0f - (float)level / 2.0f / (float)vertLevels;
#endif //TEST_TAPER
		for(poly = 0; poly < polys; ++poly) {
			ShapeDims &dim = sDims[poly];
			PolyLine &line = pShape.lines[poly];
			if(!line.numPts)
				continue;
			int lverts = line.numPts;
			for(int v = 0; v < lverts; ++v) {
				PolyPt &pp = line[v];
				Point3 test = pp.p * iaxis;
				if(weldCore && level == 0) {
					if(fabs(test.x) < dim.coreThresh)
						weldFlags.Set(vert);
					}
#ifdef TEST_TAPER
				Point3 p = pp.p * scale * tm;
#else
				Point3 p = pp.p * tm;
#endif //TEST_TAPER
				mesh.setVert(vert++, p);
				if(level == 1 && !inverse && (float)fabs(test.x) > dim.coreThresh) {
					Point3 ip = p * itm;
					if(ip.z > 0.0f)
						inverse = TRUE;
					}
				}
			}
		}

	// Flip 'inverse' state if flipNormals is true
	if(flipNormals)
		inverse = 1 - inverse;

	delete [] sDims;

	assert(vert == verts);

	// May need to add the texture verts
	if(texturing) {
		int tvertex = 0;
		for(int level = 0; level < TVlevels; ++level) {
			float tV = (float)level / (float)(TVlevels - 1);
			for(poly = 0; poly < polys; ++poly) {
				PolyLine &line = pShape.lines[poly];
				if(!line.numPts)
					continue;
				int lverts = line.numPts;
				int tp;
				int texPts = line.numPts + (line.IsClosed() ? 1 : 0);
				float cumLen = 0.0f;
				float totLen = line.CurveLength();
				Point3 prevPt = line.pts[0].p;
				for(tp = 0; tp < texPts; ++tp) {
					float tU;
					int ltp = tp % line.numPts;
					if(tp == (texPts - 1))
						tU = 1.0f;
					else {
						Point3 &pt = line.pts[ltp].p;
						cumLen += Length(pt - prevPt);
						tU = cumLen / totLen;
						prevPt = pt;
						}
					mesh.setTVert(tvertex++, UVVert(tU, tV, 0.0f));
					}
				}
			}
		}

	// If capping, do it!
	if(degrees < 360.0f && anyClosed && (capStart || capEnd)) {
		MeshCapInfo capInfo;
		pShape.MakeCap(t, capInfo, capType);
		// Build information for capping
		MeshCapper capper(pShape);
		if(capStart) {
			vert = 0;
			for(poly = 0; poly < polys; ++poly) {
				PolyLine &line = pShape.lines[poly];
				if(!line.numPts)
					continue;
				MeshCapPoly &capline = capper[poly];
				int lverts = line.numPts;
				for(int v = 0; v < lverts; ++v)
					capline.SetVert(v, vert++);			// Gives this vert's location in the mesh!
				}
			int oldFaces = mesh.numFaces;
			capper.CapMesh(mesh, capInfo, inverse, 16, &mat1, genMatIDs ? 1: 0);
			// If texturing, create the texture faces and vertices
			if(texturing)
				MakeMeshCapTexture(mesh, Inverse(mat1), oldFaces, mesh.numFaces);
			}
		if(capEnd) {
			vert = levelVerts * levels;
			for(poly = 0; poly < polys; ++poly) {
				PolyLine &line = pShape.lines[poly];
				if(!line.numPts)
					continue;
				MeshCapPoly &capline = capper[poly];
				int lverts = line.numPts;
				for(int v = 0; v < lverts; ++v)
					capline.SetVert(v, vert++);			// Gives this vert's location in the mesh!
				}
			int oldFaces = mesh.numFaces;
			capper.CapMesh(mesh, capInfo, 1-inverse, 16, &mat2, 0);
			// If texturing, create the texture faces and vertices
			if(texturing)
				MakeMeshCapTexture(mesh, Inverse(mat2), oldFaces, mesh.numFaces);
			}
		}

	// Create the faces!
	int face = 0;
	int baseVert = 0;
	int TVface = 0;
	int baseTVert = 0;
	for(level = 0; level < levels; ++level) {
		for(poly = 0; poly < polys; ++poly) {
			PolyLine &line = pShape.lines[poly];
			if(!line.numPts)
				continue;
			int pieces = line.Segments();
			int closed = line.IsClosed();
			int segVerts = pieces + ((closed) ? 0 : 1);
			int segTVerts = pieces + 1;
			int sm = 0;		// Initial smoothing group
			BOOL firstSmooth = (line.pts[0].flags & POLYPT_SMOOTH) ? TRUE : FALSE;
			for(piece = 0; piece < pieces; ++piece) {
				
				// Get vertex indices
				int v1 = baseVert + piece;
				int v2 = baseVert + ((piece + 1) % segVerts);
				int v3 = (v1 + levelVerts) % verts;
				int v4 = (v2 + levelVerts) % verts;

				// If the vertex is not smooth, go to the next group!
				BOOL thisSmooth = line.pts[piece].flags & POLYPT_SMOOTH;
				MtlID mtl = useShapeIDs ? line.pts[piece].GetMatID() : 2;
				if(piece > 0 && !thisSmooth) {
					sm++;
					if(sm > 2)
						sm = 1;
					}
				DWORD smoothGroup = 1 << sm;
				// Advance to the next smoothing group right away
				if(sm == 0)
					sm++;
				// Special case for smoothing from first segment
				if(piece == 1 && thisSmooth)
					smoothGroup |= 1;
				// Special case for smoothing from last segment
				if((piece == pieces - 1) && firstSmooth)
					smoothGroup |= 1;
				if(inverse) {
					mesh.faces[face].setEdgeVisFlags(1,1,0);
					mesh.faces[face].setSmGroup(smooth ? smoothGroup : 0);
					if(genMatIDs)
						mesh.faces[face].setMatID(mtl);
					mesh.faces[face++].setVerts(v1, v2, v4);
					mesh.faces[face].setEdgeVisFlags(0,1,1);
					mesh.faces[face].setSmGroup(smooth ? smoothGroup : 0);
					if(genMatIDs)
						mesh.faces[face].setMatID(mtl);
					mesh.faces[face++].setVerts(v1, v4, v3);
					}
				else {
					mesh.faces[face].setEdgeVisFlags(0,1,1);
					mesh.faces[face].setSmGroup(smooth ? smoothGroup : 0);
					if(genMatIDs)
						mesh.faces[face].setMatID(mtl);
					mesh.faces[face++].setVerts(v1, v4, v2);
					mesh.faces[face].setEdgeVisFlags(1,1,0);
					mesh.faces[face].setSmGroup(smooth ? smoothGroup : 0);
					if(genMatIDs)
						mesh.faces[face].setMatID(mtl);
					mesh.faces[face++].setVerts(v1, v3, v4);
					}
//DebugPrint("BV:%d V:%d v1:%d v2:%d v3:%d v4:%d\n",baseVert, vert, v1, v2, v3, v4);
				// Create texture faces, if necessary
				if(texturing) {
					int tv1 = baseTVert + piece;
					int tv2 = baseTVert + piece + 1;
					int tv3 = tv1 + levelTVerts;
					int tv4 = tv2 + levelTVerts;
					if(inverse) {
						mesh.tvFace[TVface++].setTVerts(tv1, tv2, tv4);
						mesh.tvFace[TVface++].setTVerts(tv1, tv4, tv3);
						}
					else {
						mesh.tvFace[TVface++].setTVerts(tv1, tv4, tv2);
						mesh.tvFace[TVface++].setTVerts(tv1, tv3, tv4);
						}
					}
				}
			baseVert += segVerts;
			baseTVert += segTVerts;
			}
		}
	assert(face == faces);

	// If welding, weld all those core points
	if(weldCore && weldFlags.NumberSet()) {
		int verts = mesh.getNumVerts();
		int faces = mesh.getNumFaces();
		int tverts = mesh.getNumTVerts();
		BitArray faceDel(faces);
		faceDel.ClearAll();
		// First go thru and redirect all welded points to the first instance,
		// plus delete the faces which are degenerate
		int outFace = 0;
		for(int i = 0; i < faces; ++i) {
			Face &f = mesh.faces[i];
			DWORD a = f.v[0], b=f.v[1], c=f.v[2];
			if(weldFlags[a % levelVerts])
				a = a % levelVerts;
			if(weldFlags[b % levelVerts])
				b = b % levelVerts;
			if(weldFlags[c % levelVerts])
				c = c % levelVerts;
			if(a != b && b != c && a != c) {
				f.v[0] = a;
				f.v[1] = b;
				f.v[2] = c;
				mesh.faces[outFace++] = f;
				}
			else
				faceDel.Set(i);
			}
		// Also do the texture faces
		if(mesh.tvFace && faceDel.NumberSet()) {
			int outTVFace = 0;
			for(i = 0; i < faces; ++i) {
				if(!faceDel[i])
					mesh.tvFace[outTVFace++] = mesh.tvFace[i];
				}
			}
		mesh.setNumFaces(outFace, TRUE);
		mesh.setNumTVFaces(outFace, TRUE, faces);
		// Tag the verts we need to keep
		BitArray vertDel(verts);
		vertDel.SetAll();
		for(i = 0; i < outFace; ++i) {
			Face &f = mesh.faces[i];
			vertDel.Clear(f.v[0]);
			vertDel.Clear(f.v[1]);
			vertDel.Clear(f.v[2]);
			}
		// Repack the vertex array
		DWORD *vredir = new DWORD[verts];
		int outVert = 0;
		for(i = 0; i < verts; ++i) {
			if(!vertDel[i]) {
				vredir[i] = outVert;
				mesh.verts[outVert++] = mesh.verts[i];
				}
			}
		mesh.setNumVerts(outVert, TRUE);
		// Now repoint the face vertices
		for(i = 0; i < outFace; ++i) {
			Face &f = mesh.faces[i];
			f.v[0] = vredir[f.v[0]];
			f.v[1] = vredir[f.v[1]];
			f.v[2] = vredir[f.v[2]];
			}
		delete [] vredir;
		// Tag the tverts we need to keep
		if(tverts && mesh.tvFace) {
			BitArray tvertDel(tverts);
			tvertDel.SetAll();
			for(i = 0; i < outFace; ++i) {
				TVFace &f = mesh.tvFace[i];
				tvertDel.Clear(f.t[0]);
				tvertDel.Clear(f.t[1]);
				tvertDel.Clear(f.t[2]);
				}
			// Repack the tvertex array
			DWORD *tvredir = new DWORD[tverts];
			int outTVert = 0;
			for(i = 0; i < tverts; ++i) {
				if(!tvertDel[i]) {
					tvredir[i] = outTVert;
					mesh.tVerts[outTVert++] = mesh.tVerts[i];
					}
				}
			mesh.setNumTVerts(outTVert, TRUE);
			// Now repoint the tface vertices
			for(i = 0; i < outFace; ++i) {
				TVFace &f = mesh.tvFace[i];
				f.t[0] = tvredir[f.t[0]];
				f.t[1] = tvredir[f.t[1]];
				f.t[2] = tvredir[f.t[2]];
				}
			delete [] tvredir;
			}
		}

	mesh.InvalidateGeomCache();
	}

void SurfrevMod::SetAxis(TimeValue t, int type) {
	switch(type) {
		case X_AXIS:
			axisControl->SetValue(t, &SetXFormPacket(RotateYMatrix(HALFPI)));
			break;
		case Y_AXIS:
			axisControl->SetValue(t, &SetXFormPacket(RotateXMatrix(-HALFPI)));
			break;
		case Z_AXIS:
			axisControl->SetValue(t, &SetXFormPacket(Matrix3(TRUE)));
			break;
		}
//	pmapParam->Invalidate();
	}

void SurfrevMod::Align(TimeValue t, int type) {
	// Set up a flag to make us align on the next ModifyObject
	doAlign = TRUE;
	alignType = type;
	// Force us to evaluate!
	NotifyDependents(Interval(t,t), 
			PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|PART_DISPLAY|PART_TOPO,
		    REFMSG_MOD_EVAL);
	}

// Quad patch layout
//
//   A---> ad ----- da <---D
//   |                     |
//   |                     |
//   v                     v
//   ab    i1       i4     dc
//
//   |                     |
//   |                     |
// 
//   ba    i2       i3     cd
//   ^					   ^
//   |                     |
//   |                     |
//   B---> bc ----- cb <---C
//
// vertices ( a b c d ) are in counter clockwise order when viewed from 
// outside the surface

/* Find the vector length for a circle segment	*/
/* Returns a unit value (radius=1.0)		*/
/* Angle expressed in radians			*/

static float
veccalc(float angstep) {
	static float lastin = -9999.0f,lastout;
	if(lastin == angstep)
		return lastout;

	float lo,hi,totdist;
	float sinfac=(float)sin(angstep),cosfac=(float)cos(angstep),test;
	int ix,count;
	Spline3D work;
	Point3 k1((float)cos(0.0f),(float)sin(0.0f),0.0f);
	Point3 k2(cosfac,sinfac,0.0f);

	hi=1.5f;
	lo=0.0f;
	count=200;

	/* Loop thru test vectors */

	loop:
	work.NewSpline();
	test=(hi+lo)/2.0f;
	Point3 out = k1 + Point3(0.0f, test, 0.0f);
	Point3 in = k2 + Point3(sinfac * test, -cosfac * test, 0.0f);

 	work.AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,k1,k1,out));
 	work.AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,k2,in,k2));

	totdist=0.0f;
	for(ix=0; ix<10; ++ix) {
		Point3 terp = work.InterpBezier3D(0,(float)ix/10.0f);
		totdist += (float)sqrt(terp.x * terp.x + terp.y * terp.y);
		}
	
	totdist /= 10.0f;
	count--;
	if(totdist==1.0f || count<=0)
		goto done;
	if(totdist>1.0f) {
		hi=test;
		goto loop;
		}
	lo=test;
	goto loop;

	done:
	lastin = angstep;
	lastout = test;
	return test;
	}

static void MakePatchCapTexture(PatchMesh &pmesh, Matrix3 &itm, int pstart, int pend) {
	if(pstart == pend)
		return;

	// Find out which verts are used by the cap
	BitArray capVerts(pmesh.numVerts);
	capVerts.ClearAll();
	for(int i = pstart; i < pend; ++i) {
		Patch &p = pmesh.patches[i];
		capVerts.Set(p.v[0]);
		capVerts.Set(p.v[1]);
		capVerts.Set(p.v[2]);
		if(p.type == PATCH_QUAD)
			capVerts.Set(p.v[3]);
		}
	// Minmax the verts involved in X/Y axis and total them
	Box3 bounds;
	int numCapVerts = 0;
	int numCapPatches = pend - pstart;
	IntTab capIndexes;
	capIndexes.SetCount(pmesh.numVerts);
	int baseTVert = pmesh.getNumTVerts();
	for(i = 0; i < pmesh.numVerts; ++i) {
		if(capVerts[i]) {
			capIndexes[i] = baseTVert + numCapVerts++;
			bounds += pmesh.verts[i].p * itm;
			}
		}
	pmesh.setNumTVerts(baseTVert + numCapVerts, TRUE);
	Point3 s(1.0f / bounds.Width().x, 1.0f / bounds.Width().y, 0.0f);
	Point3 t(-bounds.Min().x, -bounds.Min().y, 0.0f);
	// Do the TVerts
	for(i = 0; i < pmesh.numVerts; ++i) {
		if(capVerts[i])
			pmesh.setTVert(baseTVert++, ((pmesh.verts[i].p * itm) + t) * s);
		}
	// Do the TVPatches
	for(i = pstart; i < pend; ++i) {
		Patch &p = pmesh.patches[i];
		TVPatch &tp = pmesh.getTVPatch(i);
		if(p.type == PATCH_TRI)
			tp.setTVerts(capIndexes[p.v[0]], capIndexes[p.v[1]], capIndexes[p.v[2]]);
		else
			tp.setTVerts(capIndexes[p.v[0]], capIndexes[p.v[1]], capIndexes[p.v[2]], capIndexes[p.v[3]]);
		}
	}

void SurfrevMod::BuildPatchFromShape(TimeValue t,ModContext &mc, ObjectState * os, Matrix3 &axis, PatchMesh &pmesh) {
	ShapeObject *shape = (ShapeObject *)os->obj;

	float degrees;
	int levels,capStart,capEnd,capType;
	BOOL weldCore, flipNormals;

	pblock->GetValue(PB_DEGREES,t,degrees,FOREVER);
	pblock->GetValue(PB_SEGS,t,levels,FOREVER);
	pblock->GetValue(PB_CAPSTART,t,capStart,FOREVER);
	pblock->GetValue(PB_CAPEND,t,capEnd,FOREVER);
	pblock->GetValue(PB_CAPTYPE,t,capType,FOREVER);
	pblock->GetValue(PB_WELDCORE,t,weldCore,FOREVER);
	pblock->GetValue(PB_FLIPNORMALS,t,flipNormals,FOREVER);

	BOOL texturing;
	pblock->GetValue(PB_MAPPING, TimeValue(0), texturing, FOREVER);
	BOOL genMatIDs;
	pblock->GetValue(PB_GEN_MATIDS, TimeValue(0), genMatIDs, FOREVER);
	BOOL useShapeIDs;
	pblock->GetValue(PB_USE_SHAPEIDS, TimeValue(0), useShapeIDs, FOREVER);
	BOOL smooth;
	pblock->GetValue(PB_SMOOTH, TimeValue(0), smooth, FOREVER);

	LimitValue(degrees, MIN_DEGREES, MAX_DEGREES);

	BOOL fullCircle = (degrees == 360.0f) ? TRUE : FALSE;

	// Get the basic dimension stuff
	float radians = (float)fabs(degrees) * DEG_TO_RAD;

	// Get the unit length for the angle per level of our surfrev operation
	float veclen = veccalc(radians / (float)levels);

	// If the shape can convert itself to a BezierShape, have it do so!
	BezierShape bShape;
	if(shape->CanMakeBezier())
		shape->MakeBezier(t, bShape);
	else {
		PolyShape pShape;
		shape->MakePolyShape(t, pShape);
		bShape = pShape;	// UGH -- Convert it from a PolyShape -- not good!
		}
	
	ShapeHierarchy hier;
	bShape.OrganizeCurves(t, &hier);
	// Need to flip the reversed polys...
	bShape.Reverse(hier.reverse);
	// ...and tell the hierarchy they're no longer reversed!
	hier.reverse.ClearAll();

	// Our shapes are now organized for patch-making -- Let's do the sides!
	int polys = bShape.splineCount;
	int poly, knot;
	int levelVerts = 0, levelVecs = 0, levelPatches = 0, nverts = 0, nvecs = 0, npatches = 0;
	int TVlevels = levels + 1, levelTVerts = 0, ntverts = 0, ntpatches = 0;
	BOOL anyClosed = FALSE;
	for(poly = 0; poly < polys; ++poly) {
		Spline3D *spline = bShape.splines[poly];
		if(!spline->KnotCount())
			continue;
		BOOL closed = spline->Closed();
		if(closed)
			anyClosed = TRUE;
		levelVerts += spline->KnotCount();
		levelTVerts += (spline->Segments() + 1);
		levelVecs += (spline->Segments() * 2);
		levelPatches += spline->Segments();
		}
	int vertLevels = levels + (fullCircle ? 0 : 1);
	nverts = levelVerts * vertLevels;
	npatches = levelPatches * levels;
	nvecs = levelVecs * vertLevels + levels * levelVerts * 2 + npatches * 4;
	if(texturing) {
		ntverts = levelTVerts * TVlevels;
		ntpatches = npatches;
		}
		
	pmesh.setNumVerts(nverts);
	pmesh.setNumVecs(nvecs);
	pmesh.setNumPatches(npatches);
	pmesh.setNumTVerts(ntverts);
	pmesh.setNumTVPatches(ntpatches);

	// Set up the rotational axis transform
	Matrix3 iaxis = Inverse(axis);

	// Set up a transform that will back out everything but our rotation
	// about the axis
	Matrix3 itm = Inverse(iaxis * RotateZMatrix(0.0f) * axis);

	// A flag to detect whether this will be an inside-out object
	BOOL inverse = FALSE;

	// Get information on the shapes

	ShapeDims *sDims = new ShapeDims [polys];
	for(poly = 0; poly < polys; ++poly) {
		ShapeDims &dim = sDims[poly];
		PolyLine line;
		Spline3D *spline = bShape.splines[poly];
		if(!spline->KnotCount())
			continue;
		spline->MakePolyLine(line);
		int lverts = line.numPts;
		for(int v = 0; v < lverts; ++v) {
			PolyPt &pp = line[v];
			Point3 test = pp.p * iaxis;
			if(v == 0 || test.x < dim.minx)
				dim.minx = test.x;
			if(v == 0 || test.x > dim.maxx)
				dim.maxx = test.x;
			}
		dim.xsize = dim.maxx - dim.minx;
		dim.coreThresh = dim.xsize / 100.0f;
		if(dim.coreThresh > 0.01f)
			dim.coreThresh = 0.01f;
		}

	// Create the vertices!
	int vert = 0;
	Matrix3 mat1, mat2;
	int level;
	for(poly = 0; poly < polys; ++poly) {
		ShapeDims &dim = sDims[poly];
		Spline3D *spline = bShape.splines[poly];
		if(!spline->KnotCount())
			continue;
		int knots = spline->KnotCount();
		for(level = 0; level < vertLevels; ++level) {
			int levelBase = vert;
			// Create a matrix for the operation
			Matrix3 tm = iaxis * RotateZMatrix((float)level / (float)levels * radians) * axis;
			if(level == 0)
				mat1 = tm;
			else
			if(level == (vertLevels - 1))
				mat2 = tm;
			for(knot = 0; knot < knots; ++knot) {
				Point3 p = spline->GetKnotPoint(knot) * tm;
				Point3 test = spline->GetKnotPoint(knot) * iaxis;
				pmesh.setVert(vert++, p);
				// If the first level, check for inversion!
				if(level == 1 && !inverse && (float)fabs(test.x) > dim.coreThresh) {
					Point3 ip = p * itm;
					if(p.z > 0.0f)
						inverse = TRUE;
					}
				}
			}
		}
	assert(vert == nverts);

	// Maybe create the texture vertices
	if(texturing) {
		int tvert = 0;
		int level;
		for(poly = 0; poly < polys; ++poly) {
			Spline3D *spline = bShape.splines[poly];
			if(!spline->KnotCount())
				continue;
			// Make it a polyline
			PolyLine pline;
			spline->MakePolyLine(pline, 10);
			int knots = spline->KnotCount();
			for(level = 0; level < TVlevels; ++level) {
				float tV = (float)level / (float)(TVlevels - 1);
				int lverts = pline.numPts;
				int tp = 0;
				int texPts = spline->Segments() + 1;
				float cumLen = 0.0f;
				float totLen = pline.CurveLength();
				Point3 prevPt = pline.pts[0].p;
				int plix = 0;
				while(tp < texPts) {
					Point3 &pt = pline[plix].p;
					cumLen += Length(pt - prevPt);
					prevPt = pt;
					if(pline[plix].flags & POLYPT_KNOT) {
						float tU;
						if(tp == (texPts - 1))
							tU = 1.0f;
						else
							tU = cumLen / totLen;
						pmesh.setTVert(tvert++, UVVert(tU, tV, 0.0f));
						tp++;
						}
					plix = (plix + 1) % pline.numPts;
					}
				}
			}
		assert(tvert == ntverts);
		}

	// Create the vectors!
	int seg;
	int vec = 0;
	for(poly = 0; poly < polys; ++poly) {
		Spline3D *spline = bShape.splines[poly];
		if(!spline->KnotCount())
			continue;
		int segs = spline->Segments();
		int knots = spline->KnotCount();
		// First, the vectors on each level
		for(level = 0; level < vertLevels; ++level) {
			// Create a matrix for the operation
			Matrix3 tm = iaxis * RotateZMatrix((float)level / (float)levels * radians) * axis;
			for(seg = 0; seg < segs; ++seg) {
				int seg2 = (seg + 1) % knots;
				if(spline->GetLineType(seg) == LTYPE_CURVE) {
					Point3 p = spline->GetOutVec(seg);
					pmesh.setVec(vec++, p * tm);
					p = spline->GetInVec(seg2);
					pmesh.setVec(vec++, p * tm);
					}
				else {
					Point3 p = spline->InterpBezier3D(seg, 0.333333f);
					pmesh.setVec(vec++, p * tm);
					p = spline->InterpBezier3D(seg, 0.666666f);
					pmesh.setVec(vec++, p * tm);
					}
				}
			}

		// Now, the vectors between the levels
		int baseVec = vec;
		for(level = 0; level < levels; ++level) {
			// Create a matrix for the operation
			Matrix3 rot = RotateZMatrix((float)level / (float)levels * radians);
			Matrix3 rot2 = RotateZMatrix((float)(level+1) / (float)levels * radians);
			for(knot = 0; knot < knots; ++knot) {
				Point3 p = spline->GetKnotPoint(knot);
				// Find the distance from the axis
				Point3 ip = p * iaxis;
				Point3 ipw(ip.x, ip.y, 0.0f);
				float radius = Length(ipw);
				// Get the normal for the vector that's perpendicular to the axis
				Point3 perp = Normalize(ipw ^ Point3(0,0,1));
				// Compute a vector length for this radius
				Point3 theVec = perp * veclen * radius;
				pmesh.setVec(vec++, (ip - theVec) * rot * axis);
				pmesh.setVec(vec++, (ip + theVec) * rot2 * axis);
				}
			}
		}

	// Flip 'inverse' if flipNormals is TRUE
	if(flipNormals)
		inverse = 1 - inverse;

	// Create the patches!
	int np = 0;
	int baseVert = 0;
	int baseVec = 0;
	for(poly = 0; poly < polys; ++poly) {
		Spline3D *spline = bShape.splines[poly];
		if(!spline->KnotCount())
			continue;
		int baseKnot = 0;
		int knots = spline->KnotCount();
		int pverts = knots * vertLevels;
		int segs = spline->Segments();
		int secVecs = segs * 2 * vertLevels;	// Number of vectors on cross-sections
		int segVecs = levels * knots * 2;	// Number of vectors between cross-sections
		int baseVec1 = 0;	// Base vector index for this level
		int baseVec2 = 0;	// Base vector index for between levels
		for(level = 0; level < levels; ++level) {
			int sm = 0;
			BOOL firstSmooth = (spline->GetLineType(0) == LTYPE_CURVE && spline->GetLineType(segs-1) == LTYPE_CURVE && (spline->GetKnotType(0) == KTYPE_AUTO || spline->GetKnotType(0) == KTYPE_BEZIER)) ? TRUE : FALSE;
			for(seg = 0; seg < segs; ++seg, vec += 4) {
				int prevseg = (seg + segs - 1) % segs;
				int seg2 = (seg + 1) % knots;
				int a,b,c,d,ab,ba,bc,cb,cd,dc,da,ad;
				MtlID mtl = useShapeIDs ? spline->GetMatID(seg) : 2;
				a = baseVert + baseKnot + seg;
				b = baseVert + baseKnot + seg2;
				c = baseVert + ((baseKnot + seg2 + knots) % pverts);
				d = baseVert + ((baseKnot + seg + knots) % pverts);
				ab = baseVec + baseVec1 + seg * 2;
				ba = ab + 1;
				bc = baseVec + secVecs + ((baseVec2 + seg2 * 2) % segVecs);
				cb = bc + 1;
				cd = baseVec + ((baseVec1 + seg * 2 + 1 + segs * 2) % secVecs);
				dc = cd - 1;
				da = baseVec + secVecs + ((baseVec2 + seg * 2 + 1) % segVecs);
				ad = da - 1;
//DebugPrint("Making patch %d: %d (%d %d) %d (%d %d) %d (%d %d) %d (%d %d)\n",np, a, ab, ba, b, bc, cb, c, cd, dc, d, da, ad);
				// If the vertex is not smooth, go to the next group!
				if(seg > 0 && !(spline->GetLineType(prevseg) == LTYPE_CURVE && spline->GetLineType(seg) == LTYPE_CURVE && (spline->GetKnotType(seg) == KTYPE_AUTO || spline->GetKnotType(seg) == KTYPE_BEZIER))) {
					sm++;
					if(sm > 2)
						sm = 1;
					}
				DWORD smoothGroup = 1 << sm;
				if(seg == segs - 1 && firstSmooth) {
					smoothGroup |= 1;
					}
				if(inverse)
					pmesh.MakeQuadPatch(np, a, ab, ba, b, bc, cb, c, cd, dc, d, da, ad, vec, vec+1, vec+2, vec+3, smooth ? smoothGroup : 0);
				else
					pmesh.MakeQuadPatch(np, a, ad, da, d, dc, cd, c, cb, bc, b, ba, ab, vec+3, vec+2, vec+1, vec, smooth ? smoothGroup : 0);
				pmesh.setPatchMtlIndex(np++, genMatIDs ? mtl : 0);
				}
			baseKnot += knots;
			baseVec1 += (segs * 2);
			baseVec2 += (knots * 2);
			}
		baseVert += (knots * vertLevels);
		baseVec += (secVecs + segVecs);
		}
	assert(vec == nvecs);
	assert(np == npatches);

 	// Maybe create the texture patches!
	if(texturing) {
		int ntp = 0;
		int baseTVert = 0;
		for(poly = 0; poly < polys; ++poly) {
			Spline3D *spline = bShape.splines[poly];
			if(!spline->KnotCount())
				continue;
			int baseKnot = 0;
			int pknots = spline->Segments() + 1;
			int pverts = pknots * TVlevels;
			int segs = spline->Segments();
			for(level = 0; level < levels; ++level) {
				for(seg = 0; seg < segs; ++seg) {
					int prevseg = (seg + segs - 1) % segs;
					int seg2 = seg + 1;
					int a,b,c,d;
					a = baseTVert + baseKnot + seg;
					b = baseTVert + baseKnot + seg2;
					c = baseTVert + baseKnot + seg2 + pknots;
					d = baseTVert + baseKnot + seg + pknots;
					TVPatch &tp = pmesh.getTVPatch(ntp++);
					if(inverse)
						tp.setTVerts(a, b, c, d);
					else
						tp.setTVerts(a, d, c, b);
					}
				baseKnot += pknots;
				}
			baseTVert += (pknots * TVlevels);
			}
		assert(ntp == ntpatches);
		}

	// If capping, do it!
	if(degrees < 360.0f && anyClosed && (capStart || capEnd)) {
		PatchCapInfo capInfo;
		bShape.MakeCap(t, capInfo);

		// Build information for capping
		PatchCapper capper(bShape);
		if(capStart) {
			vert = 0;
			int baseVec = 0;
			for(poly = 0; poly < polys; ++poly) {
				Spline3D *spline = bShape.splines[poly];
				if(!spline->KnotCount())
					continue;
				PatchCapPoly &capline = capper[poly];
				int lverts = spline->KnotCount();
				for(int v = 0; v < lverts; ++v)
					capline.SetVert(v, vert++);			// Gives this vert's location in the mesh!
				vert += lverts * levels;
				vec = baseVec;
				int lvecs = spline->Segments() * 2;
				for(v = 0; v < lvecs; ++v)
					capline.SetVec(v, vec++);			// Gives this vec's location in the mesh!
				baseVec += lvecs * (levels + 1) + spline->KnotCount() * levels * 2;
				}
			int oldPatches = pmesh.numPatches;
			capper.CapPatchMesh(pmesh, capInfo, inverse, 16, &mat1, genMatIDs ? 1 : 0);
			// If texturing, create the texture patches and vertices
			if(texturing)
				MakePatchCapTexture(pmesh, Inverse(mat1), oldPatches, pmesh.numPatches);
			}
		if(capEnd) {
			int baseVert = 0;
			int baseVec = 0;
			for(poly = 0; poly < polys; ++poly) {
				Spline3D *spline = bShape.splines[poly];
				if(!spline->KnotCount())
					continue;
				PatchCapPoly &capline = capper[poly];
				int lverts = spline->KnotCount();
				int vert = baseVert + lverts * levels;
				for(int v = 0; v < lverts; ++v)
					capline.SetVert(v, vert++);			// Gives this vert's location in the mesh!
				baseVert += lverts * (levels + 1);
				int lvecs = spline->Segments()*2;
				int vec = baseVec + lvecs * levels;
				for(v = 0; v < lvecs; ++v)
					capline.SetVec(v, vec++);			// Gives this vec's location in the mesh!
				baseVec += lvecs * (levels + 1) + spline->KnotCount() * levels * 2;
				}
			int oldPatches = pmesh.numPatches;
			capper.CapPatchMesh(pmesh, capInfo, 1-inverse, 16, &mat2, 0);
			// If texturing, create the texture patches and vertices
			if(texturing)
				MakePatchCapTexture(pmesh, Inverse(mat2), oldPatches, pmesh.numPatches);
			}
		}

	// Ready the patch representation!
	assert(pmesh.buildLinkages());
	pmesh.computeInteriors();

//pmesh.Dump();

	pmesh.InvalidateGeomCache();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\tessmod.cpp ===
/**********************************************************************
 *<
	FILE: tessmod.cpp

	DESCRIPTION:  A tessellation modifier

	CREATED BY: Rolf Berteig
	(Modified later, MNMesh stuff added, by Steve Anderson)

	HISTORY: 10/22/96
	(Modified 3/21/97)

 *>	Copyright (c) 1994, 1996, 1997, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "MNMath.h" 
#include "iparamm.h"

// LocalModData and related classes:

class TessModData : public LocalModData {
public:
	Mesh m;	// Cached output
	MNMesh mm;
	Interval ivalid;
	bool force;
	TessModData () { ivalid.SetEmpty (); force=TRUE; }
	~TessModData () { }
	LocalModData *Clone ();
};

LocalModData *TessModData::Clone () {
	TessModData *foo = new TessModData ();
	foo->ivalid = ivalid;
	foo->force = force;
	foo->m = m;
	foo->mm = m;
	return (LocalModData *) foo;
}

class TessInvalidateEnumProc : public ModContextEnumProc {
	BOOL proc (ModContext *mc);
};

BOOL TessInvalidateEnumProc::proc (ModContext *mc) {
	if (mc->localData == NULL) return TRUE;
	TessModData *msmd = (TessModData *) mc->localData;
	msmd->ivalid.SetEmpty ();
	return TRUE;
}

static TessInvalidateEnumProc theTessInvalidateEnumProc;

class TessForceEnumProc : public ModContextEnumProc {
	BOOL proc (ModContext *mc);
};

BOOL TessForceEnumProc::proc (ModContext *mc) {
	if (mc->localData == NULL) return TRUE;
	TessModData *msmd = (TessModData *) mc->localData;
	msmd->force = TRUE;
	msmd->ivalid.SetEmpty ();
	return TRUE;
}

static TessForceEnumProc theTessForceEnumProc;

#define DEF_FACE_TYPE 0	// triangle
#define DEF_TESS_TYPE 0 // edge
#define DEF_TENSION 25.0f
#define DEF_ITERS 0	// Really, 1.

// Flags:
#define TESS_ABORT 0x01
#define TESS_INRENDER 0x02

class TessMod : public Modifier, public MeshOpProgress, public FlagUser {	
public:
	IParamBlock *pblock;
	static int LastFaceType, LastType;

	static IObjParam *ip;
	static IParamMap *pmapParam;
	static TessMod *editMod;

	TessMod();

	// From Animatable
	void DeleteThis() { delete this; }
	void GetClassName(TSTR& s) {s = GetString(IDS_RB_TESSMOD);}  
	virtual Class_ID ClassID() { return Class_ID(TESSELLATE_CLASS_ID,0);}
	void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
	void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	TCHAR *GetObjectName() {return GetString(IDS_RB_TESSMOD);}
	IOResult Load (ILoad *iload);

	// From modifier
	ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO|PART_SELECT|PART_SUBSEL_TYPE|PART_TEXMAP|PART_VERTCOLOR;}
	ChannelMask ChannelsChanged() {return PART_GEOM|PART_TOPO|PART_SELECT|PART_TEXMAP|PART_VERTCOLOR;}
	Class_ID InputType() {return triObjectClassID;}
	void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
	Interval LocalValidity(TimeValue t);

	// From BaseObject
	CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}
	IParamArray *GetParamBlock() {return pblock;}
	int GetParamBlockIndex(int id) {return id;}

	int NumRefs() {return 1;}
	RefTargetHandle GetReference(int i) {return pblock;}
	void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}

	int NumSubs() {return 1;}
	Animatable* SubAnim(int i) {return GetReference(i);}
	TSTR SubAnimName(int i) {return _T("");}

	RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
	   PartID& partID, RefMessage message);
	void NotifyInputChanged (Interval changeInt, PartID part,
		RefMessage msg, ModContext *mc);

	int RenderBegin (TimeValue t, ULONG flags);
	int RenderEnd (TimeValue t);

	// MeshOpProgress:
	void SuperInit (int numSteps);
	void Init (int numSteps) {}
	BOOL Progress (int step);
};


//--- ClassDescriptor and class vars ---------------------------------

IObjParam *TessMod::ip = NULL;
IParamMap *TessMod::pmapParam = NULL;
TessMod   *TessMod::editMod = NULL;
int TessMod::LastFaceType = DEF_FACE_TYPE;
int TessMod::LastType = DEF_TESS_TYPE;

// Class to create and destroy the image list we need at startup & exit.
class faceImageHandler {
public:
	HIMAGELIST hFaceImages;
	faceImageHandler () { hFaceImages = NULL; }
	~faceImageHandler () { if (hFaceImages) ImageList_Destroy (hFaceImages); }
	void LoadImages ();
};

void faceImageHandler::LoadImages () {
	if (hFaceImages) return;
	HBITMAP hBitmap, hMask;
	hFaceImages = ImageList_Create(17, 15, ILC_MASK, 3, 0);	// 17 is kluge to center square. -SA
	hBitmap     = LoadBitmap (hInstance,MAKEINTRESOURCE(IDB_FACESELTYPES));
	hMask       = LoadBitmap (hInstance,MAKEINTRESOURCE(IDB_MASK_FACESELTYPES));
	ImageList_Add(hFaceImages, hBitmap, hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
}

static faceImageHandler theFaceImageHandler;

class TessClassDesc:public ClassDesc {
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new TessMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_TESSMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(TESSELLATE_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	void ResetClassParams (BOOL fileReset);
};

void TessClassDesc::ResetClassParams (BOOL fileReset) {
	TessMod::LastType = DEF_TESS_TYPE;
	TessMod::LastFaceType = DEF_FACE_TYPE;
}
static TessClassDesc tessDesc;
ClassDesc* GetTessModDesc() {return &tessDesc;}

//--- Parameter map/block descriptors -------------------------------

#define PB_TYPE			0
#define PB_TENSION		1
#define PB_ITERATIONS	2
#define PB_FACE_TYPE	3
#define PB_UPDATE 4

//
//
// Parameters

static int typeIDs[] = {IDC_TES_EDGE,IDC_TES_CENTER};
static int iterationsIDs[] = {IDC_ITERATIONS1,IDC_ITERATIONS2,IDC_ITERATIONS3,IDC_ITERATIONS4};
static int updateIDs[] = { IDC_TESS_UPDATE_ALWAYS, IDC_TESS_UPDATE_RENDER, IDC_TESS_UPDATE_MANUAL };

static ParamUIDesc descParam[] = {
	ParamUIDesc(PB_TYPE,TYPE_RADIO,typeIDs,2),
	ParamUIDesc (PB_TENSION, EDITTYPE_FLOAT,
		IDC_TENSION,IDC_TENSIONSPIN,
		-100.0f,100.0f, 0.1f),
	ParamUIDesc(PB_ITERATIONS,TYPE_RADIO,iterationsIDs,4),
	ParamUIDesc (PB_UPDATE, TYPE_RADIO, updateIDs, 3),
};
#define PARAMDESC_LENGTH	4

static ParamBlockDescID descVer0[] = {
	{ TYPE_INT,   NULL, FALSE, PB_TYPE },		// Type
	{ TYPE_FLOAT, NULL, TRUE,  PB_TENSION },		// Tension	
	{ TYPE_INT,   NULL, FALSE, PB_ITERATIONS },		// Iterations
};
static ParamBlockDescID descVer1[] = {
	{ TYPE_INT,   NULL, FALSE, PB_TYPE },
	{ TYPE_FLOAT, NULL, TRUE,  PB_TENSION },
	{ TYPE_INT,   NULL, FALSE, PB_ITERATIONS },
	{ TYPE_INT,   NULL, FALSE, PB_FACE_TYPE },
};
static ParamBlockDescID descVer2[] = {
	{ TYPE_INT,   NULL, FALSE, PB_TYPE },
	{ TYPE_FLOAT, NULL, TRUE,  PB_TENSION },
	{ TYPE_INT,   NULL, FALSE, PB_ITERATIONS },
	{ TYPE_INT,   NULL, FALSE, PB_FACE_TYPE },
	{ TYPE_INT,   NULL, FALSE, PB_UPDATE },
};
#define PBLOCK_LENGTH	5

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,0),
	ParamVersionDesc(descVer1,4,1),
};
#define NUM_OLDVERSIONS	2

#define CURRENT_VERSION 2
static ParamVersionDesc curVersion (descVer2, PBLOCK_LENGTH, CURRENT_VERSION);

// Undo/redo for tri/poly buttons:
class TriPolyRestore : public RestoreObj {
public:
	int was_poly, is_poly;
	TessMod * tm;

	TriPolyRestore (TessMod *mod);
	void Restore (int isUndo);
	void Redo ();
	int Size () { return (sizeof(TessMod *) + 2*sizeof (int)); }
	TSTR Description() { return TSTR(_T("TessMod Tri/Poly toggle")); }
};

TriPolyRestore::TriPolyRestore (TessMod *mod) {
	tm = mod;
	MaxAssert (tm);
	MaxAssert (tm->pblock);
	tm->pblock->GetValue (PB_FACE_TYPE, TimeValue(0), was_poly, FOREVER);
}

void TriPolyRestore::Restore (int isUndo) {
	if (!tm) return;
	if (!tm->pmapParam) return;
	if (tm->pblock) {
		tm->pblock->GetValue (PB_FACE_TYPE, TimeValue(0), is_poly, FOREVER);
		if (is_poly == was_poly) return;
	}
	ICustButton *iTri, *iPoly;
	iTri = GetICustButton (GetDlgItem (tm->pmapParam->GetHWnd(), IDC_TES_FACE_TRI));
	iPoly = GetICustButton (GetDlgItem (tm->pmapParam->GetHWnd(), IDC_TES_FACE_POLY));
	iTri->SetCheck (!was_poly);
	iPoly->SetCheck (was_poly);
	ReleaseICustButton (iTri);
	ReleaseICustButton (iPoly);
}

void TriPolyRestore::Redo () {
	if (!tm) return;
	if (!tm->pmapParam) return;
	if (tm->pblock) {
		int isNowPoly;
		tm->pblock->GetValue (PB_FACE_TYPE, TimeValue(0), isNowPoly, FOREVER);
		if (is_poly == isNowPoly) return;
	}
	ICustButton *iTri, *iPoly;
	iTri = GetICustButton (GetDlgItem (tm->pmapParam->GetHWnd(), IDC_TES_FACE_TRI));
	iPoly = GetICustButton (GetDlgItem (tm->pmapParam->GetHWnd(), IDC_TES_FACE_POLY));
	iTri->SetCheck (!is_poly);
	iPoly->SetCheck (is_poly);
	ReleaseICustButton (iTri);
	ReleaseICustButton (iPoly);
}

// Face-type dlg user proc
class TessModDlgProc : public ParamMapUserDlgProc {
public:
	TessMod *mod;
	TessModDlgProc () { mod = NULL; }
	BOOL DlgProc (TimeValue t, IParamMap *map, HWND hWnd,
		UINT msg, WPARAM wParam, LPARAM lParam);
	void DeleteThis () { }
};

BOOL TessModDlgProc::DlgProc (TimeValue t, IParamMap *map, HWND hWnd,
							  UINT msg,WPARAM wParam,LPARAM lParam) {
	if (mod==NULL) return FALSE;
	ICustButton *iTri, *iPoly;
	switch (msg) {
	case WM_COMMAND:
		switch (LOWORD (wParam)) {
		case IDC_TES_FACE_TRI:
			theHold.Begin ();
			theHold.Put (new TriPolyRestore (mod));
			iTri = GetICustButton (GetDlgItem (hWnd, IDC_TES_FACE_TRI));
			iPoly = GetICustButton (GetDlgItem (hWnd, IDC_TES_FACE_POLY));
			mod->pblock->SetValue (PB_FACE_TYPE, t, 0);
			iTri->SetCheck (1);
			iPoly->SetCheck (0);
			ReleaseICustButton (iTri);
			ReleaseICustButton (iPoly);
			theHold.Accept (GetString (IDS_SA_TRI_POLY_RESTORE));
			break;
		case IDC_TES_FACE_POLY:
			theHold.Begin ();
			theHold.Put (new TriPolyRestore (mod));
			iTri = GetICustButton (GetDlgItem (hWnd, IDC_TES_FACE_TRI));
			iPoly = GetICustButton (GetDlgItem (hWnd, IDC_TES_FACE_POLY));
			mod->pblock->SetValue (PB_FACE_TYPE, t, 1);
			iTri->SetCheck (0);
			iPoly->SetCheck (1);
			ReleaseICustButton (iTri);
			ReleaseICustButton (iPoly);
			theHold.Accept (GetString (IDS_SA_TRI_POLY_RESTORE));
			break;

		case IDC_TESS_RECALC:
			mod->EnumModContexts (&theTessForceEnumProc);
			mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
			// Force a re-evaluation:
			/*int dummy;
			mod->pblock->GetValue (PB_UPDATE, t, dummy, FOREVER);
			mod->pblock->SetValue (PB_UPDATE, t, dummy);*/
			break;
		}
		break;
	}
	return FALSE;
}

static TessModDlgProc theTessModDlgProc;

//--- tessellate mod methods -------------------------------

TessMod::TessMod()
{
	pblock = NULL;
	MakeRefByID (FOREVER, 0,
		CreateParameterBlock(descVer2, PBLOCK_LENGTH, CURRENT_VERSION));
	pblock->SetValue (PB_TENSION, 0, DEF_TENSION);
	pblock->SetValue (PB_TYPE, 0, LastType);
	pblock->SetValue (PB_ITERATIONS, 0, DEF_ITERS);		// "1" iteration
	pblock->SetValue (PB_FACE_TYPE, 0, LastFaceType);
	theFaceImageHandler.LoadImages();
}

void TessMod::BeginEditParams (IObjParam  *ip, ULONG flags,Animatable *prev) {
	this->ip = ip;
	editMod  = this;

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	SetAFlag(A_MOD_BEING_EDITED);

	pmapParam = CreateCPParamMap (descParam,PARAMDESC_LENGTH,
		pblock, ip, hInstance, MAKEINTRESOURCE(IDD_TESSPARAM),
		GetString(IDS_RB_PARAMETERS), 0);
	theTessModDlgProc.mod = this;
	pmapParam->SetUserDlgProc (&theTessModDlgProc);

	int ft;
	pblock->GetValue (PB_FACE_TYPE, TimeValue(0), ft, FOREVER);
	HWND hParam = pmapParam->GetHWnd();
	ICustButton *iFaceTri = GetICustButton (GetDlgItem (hParam, IDC_TES_FACE_TRI));
	iFaceTri->SetImage(theFaceImageHandler.hFaceImages, 0, 0, 0, 0, 16, 15);
	iFaceTri->SetType (CBT_CHECK);
	iFaceTri->SetCheck (!ft);
	iFaceTri->SetTooltip (TRUE, GetString (IDS_SA_TRIANGLE));
	ReleaseICustButton (iFaceTri);

	ICustButton *iFacePoly = GetICustButton (GetDlgItem (hParam, IDC_TES_FACE_POLY));
	iFacePoly->SetImage(theFaceImageHandler.hFaceImages, 1, 1, 1, 1, 16, 15);
	iFacePoly->SetType (CBT_CHECK);
	iFacePoly->SetCheck (ft);
	iFacePoly->SetTooltip (TRUE, GetString (IDS_SA_POLYGON));
	ReleaseICustButton (iFacePoly);

// mjm - begin - 2.15.99
// copied from TessMod::NotifyRefChanged()
	int type;
	pblock->GetValue (PB_TYPE, TimeValue(0), type, FOREVER);
	ISpinnerControl *spin = GetISpinner (GetDlgItem (hParam, IDC_TENSIONSPIN));
	spin->Enable (!type);
	ReleaseISpinner (spin);
// mjm - end
}

void TessMod::EndEditParams (IObjParam *ip,ULONG flags,Animatable *next) {
	this->ip = NULL;
	editMod  = NULL;

	TimeValue t = ip->GetTime();

	// NOTE: This flag must be cleared before sending the REFMSG_END_EDIT
	ClearAFlag(A_MOD_BEING_EDITED);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);	

	DestroyCPParamMap(pmapParam);
	theTessModDlgProc.mod = NULL;
	pblock->GetValue (PB_FACE_TYPE, t, LastFaceType, FOREVER);
	pblock->GetValue (PB_TYPE, t, LastType, FOREVER);
}

RefTargetHandle TessMod::Clone(RemapDir& remap) {
	TessMod *mod = new TessMod();
	mod->ReplaceReference(0,pblock->Clone(remap));
	return mod;
}

IOResult TessMod::Load (ILoad *iload) {
	Modifier::Load(iload);
	// Add following when there's a new pblock version.
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
}

void TessMod::ModifyObject (TimeValue t, ModContext &mc, ObjectState *os, INode *node) {
	if (!os->obj->IsSubClassOf (triObjectClassID)) return;
	TriObject *tobj = (TriObject*)os->obj;

	if (!mc.localData) mc.localData = (LocalModData *) new TessModData;
	TessModData *tmd = (TessModData *) mc.localData;

	int faceType;
	pblock->GetValue (PB_FACE_TYPE, t, faceType, FOREVER);

	if (tmd->ivalid.InInterval (t)) {
		if (faceType) tmd->mm.OutToTri (tobj->GetMesh());
		else tobj->GetMesh() = tmd->m;
		os->obj->SetChannelValidity(TOPO_CHAN_NUM, tmd->ivalid);
		os->obj->SetChannelValidity(GEOM_CHAN_NUM, tmd->ivalid);
		os->obj->SetChannelValidity(TEXMAP_CHAN_NUM, tmd->ivalid);
		os->obj->SetChannelValidity(SELECT_CHAN_NUM, tmd->ivalid);
		os->obj->SetChannelValidity (VERT_COLOR_CHAN_NUM, tmd->ivalid);
		return;
	}

	int update;
	pblock->GetValue (PB_UPDATE, t, update, FOREVER);

	bool updateMe = TRUE;
	switch (update) {
	case 1:		// IDC_UPDATE_RENDER
		if (!GetFlag (TESS_INRENDER)) updateMe = FALSE;
		break;

	case 2:		// IDC_UPDATE_MANUAL
		updateMe = FALSE;
		break;
	}
	if (tmd->force) {
		tmd->force = FALSE;
		updateMe = TRUE;
	}

	if (!updateMe) {
		// The object should be considered valid
		tmd->ivalid.SetInstant(t);
		if (faceType) tmd->mm.OutToTri (tobj->GetMesh());
		else tobj->GetMesh() = tmd->m;
		os->obj->SetChannelValidity(TOPO_CHAN_NUM, tmd->ivalid);
		os->obj->SetChannelValidity(GEOM_CHAN_NUM, tmd->ivalid);
		os->obj->SetChannelValidity(TEXMAP_CHAN_NUM, tmd->ivalid);
		os->obj->SetChannelValidity(SELECT_CHAN_NUM, tmd->ivalid);
		os->obj->SetChannelValidity (VERT_COLOR_CHAN_NUM, tmd->ivalid);
		return;
	}

	int type, iterations;
	float tens;
	BOOL ignoreSel = FALSE;
	tmd->ivalid = os->obj->ChannelValidity (t, GEOM_CHAN_NUM);
	tmd->ivalid &= os->obj->ChannelValidity (t, TOPO_CHAN_NUM);
	tmd->ivalid &= os->obj->ChannelValidity (t, SELECT_CHAN_NUM);
	tmd->ivalid &= os->obj->ChannelValidity (t, SUBSEL_TYPE_CHAN_NUM);
	tmd->ivalid &= os->obj->ChannelValidity (t, TEXMAP_CHAN_NUM);
	tmd->ivalid &= os->obj->ChannelValidity (t, VERT_COLOR_CHAN_NUM);

	pblock->GetValue(PB_TYPE,t,type,tmd->ivalid);
	pblock->GetValue(PB_ITERATIONS,t,iterations,tmd->ivalid);
	iterations++;

	int order, i;
	if (faceType == 0) {
		if (tobj->GetMesh().selLevel != MESH_FACE) {
			ignoreSel = TRUE;
			order = tobj->GetMesh().numFaces;
		} else {
			order = tobj->GetMesh().faceSel.NumberSet();
		}
		for (i=0; i<iterations; i++) order *= (type ? 3 : 4);
		SuperInit (order);
		if (type) {
			for (int i=0; i<iterations; i++) {
				tobj->GetMesh().FaceCenterTessellate(ignoreSel, this);
				if (GetFlag (TESS_ABORT)) break;
			}
		} else {
			pblock->GetValue(PB_TENSION, t, tens, tmd->ivalid);
			for (int i=0; i<iterations; i++) {
				tobj->GetMesh().EdgeTessellate(tens/400.0f, ignoreSel, this);
				if (GetFlag (TESS_ABORT)) break;
			}
		}
		tobj->GetMesh().InvalidateGeomCache ();
		tobj->GetMesh().InvalidateTopologyCache ();
		tmd->m = tobj->GetMesh();
	} else {
		tmd->mm.SetFromTri (tobj->GetMesh());
		tmd->mm.FillInMesh ();
		tmd->mm.MakePolyMesh ();
		tmd->mm.MakeConvex ();
		order = tmd->mm.TargetFacesBySelection (tobj->GetMesh().selLevel);
		for (int i=0; i<iterations; i++) order *= (type ? 3 : 4);
		SuperInit (order);
		if (type) {
			for (i=0; i<iterations; i++) {
				tmd->mm.TessellateByCenters (this);
				if (GetFlag (TESS_ABORT)) break;
			}
		} else {
			pblock->GetValue(PB_TENSION,t,tens,tmd->ivalid);
			tens /= 400.0f;
			for (i=0; i<iterations; i++) {
				tmd->mm.TessellateByEdges (tens, this);
				if (GetFlag (TESS_ABORT)) break;
			}
		}
		tmd->mm.OutToTri (tobj->GetMesh());
	}
	if (GetFlag (TESS_ABORT)) {
		if (!GetFlag(TESS_INRENDER)) pblock->SetValue (PB_UPDATE, t, 2);
		tmd->ivalid.SetInstant (t);
		ClearFlag (TESS_ABORT);
	}
	os->obj->UpdateValidity (GEOM_CHAN_NUM, tmd->ivalid);
	os->obj->UpdateValidity (TOPO_CHAN_NUM, tmd->ivalid);
	os->obj->UpdateValidity (SELECT_CHAN_NUM, tmd->ivalid);
	os->obj->UpdateValidity (SUBSEL_TYPE_CHAN_NUM, tmd->ivalid);
	os->obj->UpdateValidity (TEXMAP_CHAN_NUM, tmd->ivalid);
	os->obj->UpdateValidity (VERT_COLOR_CHAN_NUM, tmd->ivalid);
}

Interval TessMod::LocalValidity(TimeValue t) {
	Interval iv = FOREVER;
	int type, iterations, faceType;
	float tens;
	pblock->GetValue(PB_TYPE,t,type,iv);	
	pblock->GetValue(PB_ITERATIONS,t,iterations,iv);
	pblock->GetValue (PB_FACE_TYPE, t, faceType, iv);
	if (!type) pblock->GetValue(PB_TENSION,t,tens,iv);
	return iv;
}

RefResult TessMod::NotifyRefChanged (Interval changeInt,RefTargetHandle hTarget,
									 PartID& partID, RefMessage message) {
	int type;
	switch (message) {
		case REFMSG_CHANGE:
			if (editMod==this && pmapParam) {
				pblock->GetValue (PB_TYPE, TimeValue(0), type, FOREVER);
				ISpinnerControl *spin;
				spin = GetISpinner (GetDlgItem (pmapParam->GetHWnd(), IDC_TENSIONSPIN));
				spin->Enable (!type);
				ReleaseISpinner (spin);
				pmapParam->Invalidate();
			}
			EnumModContexts (&theTessInvalidateEnumProc);
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_TENSION: gpd->dim = stdPercentDim; break;				
			}
			return REF_STOP;
		}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;			
			switch (gpn->index) {
				case PB_TENSION: gpn->name = GetString(IDS_TESS_TENSION); break;				
			}
			return REF_STOP; 
		}
	}
	return REF_SUCCEED;
}

void TessMod::NotifyInputChanged (Interval changeInt, PartID part,
									  RefMessage msg, ModContext *mc) {
	if (!mc->localData) return;
	TessModData *tmd = (TessModData *) mc->localData;
	tmd->ivalid = NEVER;
}

int TessMod::RenderBegin(TimeValue t, ULONG flags) {
	SetFlag(TESS_INRENDER);
	if (!pblock) return 0;
	int update;
	pblock->GetValue (PB_UPDATE, t, update, FOREVER);
	if (update == 1 /*IDC_UPDATE_RENDER*/) {
		EnumModContexts (&theTessInvalidateEnumProc);
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
	return 0;
}

int TessMod::RenderEnd(TimeValue t) {
	ClearFlag(TESS_INRENDER);
	return 0;
}

static BOOL testEscape=FALSE;

void TessMod::SuperInit (int total) {
	ClearFlag (TESS_ABORT);
	if (total<200) { testEscape=FALSE; return; }
	testEscape = TRUE;
	SetCursor (LoadCursor (NULL, IDC_WAIT));
	GetAsyncKeyState (VK_ESCAPE);	// to clear the escape-key.
}

BOOL TessMod::Progress(int p) {
	if (!testEscape) return TRUE;
	if (GetAsyncKeyState(VK_ESCAPE)) {
		SetFlag(TESS_ABORT);
		return FALSE;
	}
	else return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\twist.cpp ===
/**********************************************************************
 *<
	FILE: twist.cpp

	DESCRIPTION:  Twist OSM

	CREATED BY: Dan Silva & Rolf Berteig
	MODIFIED BY: Keith Trummel

	HISTORY: created 30 Jauary, 1995
	         Keith modified bend.cpp to create this on 13 March, 1995
		 updated for new API on 24 April, 1995
		 updated and added authorization code 11 May, 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include <stdio.h>

#ifdef CHECK_AUTHORIZE
#define TwistMod		TwistMod2
#define TwistDeformer	TwistDeformer2
#define AuthInfo		AuthInfo2
#define TwistClassDesc	TwistClassDesc2
#endif

//------------------------------------------------------
// Functions used by the rest of the library
//------------------------------------------------------
static int authorized = 0;

static int 
IsAuthorized()
{
    return authorized;
}

static void
Authorize()
{
    authorized = 1;
}

static void
UnAuthorize()
{
    authorized = 0;
}
//////////////////////////////////////////////////////////


// in mods.cpp
extern HINSTANCE hInstance;

#define ABS(x)   (((x) >= 0) ? (x) : -(x))

#define BIGFLOAT	float(999999)



class TwistMod : public SimpleMod {
		static HWND hAuthWnd;
		static int inAuthorizationMode;
		static IParamMap *pmapParam;

	public:
		TwistMod();
		
		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_TWISTMOD); }  
		
	#ifdef CHECK_AUTHORIZE
		virtual Class_ID ClassID() { return Class_ID(TWISTOSM_CLASS_ID,1);}
	#else
		virtual Class_ID ClassID() { return Class_ID(TWISTOSM_CLASS_ID,0);}
	#endif
		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next );
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
	
	#ifdef CHECK_AUTHORIZE
		TCHAR *GetObjectName() { return GetString(IDS_RB_TWIST2); }
	#else
		TCHAR *GetObjectName() { return GetString(IDS_RB_TWIST); }
	#endif
				
		IOResult Load(ILoad *iload);

		// From simple mod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		BOOL GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis);
		void InvalidateUI() {if (pmapParam) pmapParam->Invalidate();}
	};

class TwistDeformer: public Deformer {
	public:
		Matrix3 tm,invtm;
		Box3 bbox;
		TimeValue time;
		float theAngle;
		float height;
		float angleOverHeight, from, to, bias;
		int doRegion, doBias;
		TwistDeformer();
		TwistDeformer(
			TimeValue t, ModContext &mc,
			float angle, int naxis, float bias, 
			float from, float to, int doRegion,
			Matrix3& modmat, Matrix3& modinv);
		void SetAxis(Matrix3 &tmAxis);
		void CalcHeight(int axis, float angle);
		Point3 Map(int i, Point3 p); 
	};


#define TWISTWSM_CLASSID	Class_ID(TWISTOSM_CLASS_ID,2)

class TwistWSM : public SimpleOSMToWSMObject {
	public:
		TwistWSM() {}
		TwistWSM(TwistMod *m) : SimpleOSMToWSMObject(m) {}
		void DeleteThis() { delete this; }
		SClass_ID SuperClassID() {return WSM_OBJECT_CLASS_ID;}
		Class_ID ClassID() {return TWISTWSM_CLASSID;} 
		TCHAR *GetObjectName() {return GetString(IDS_RB_TWIST);}
		RefTargetHandle Clone(RemapDir& remap)
			{return (new TwistWSM((TwistMod*)mod->Clone(remap)))->SimpleOSMToWSMClone(this,remap);}
	};

//--- ClassDescriptor and class vars ---------------------------------


HWND TwistMod::hAuthWnd           = NULL;
int TwistMod::inAuthorizationMode = 0;
IParamMap *TwistMod::pmapParam     = NULL;

static BOOL CALLBACK AuthorizationDialogProc( HWND hDlg, UINT message, 
				       WPARAM wParam, LPARAM lParam );
static BOOL CALLBACK AuthRollupProc( HWND hDlg, UINT message, 
			      WPARAM wParam, LPARAM lParam );

class AuthInfo {
public:
    TwistMod    *twistMod;
    IObjParam   *iobjParam;
    int         create;
};


class TwistClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new TwistMod; }	
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
#ifdef CHECK_AUTHORIZE	
	const TCHAR *	ClassName() { return GetString(IDS_RB_TWIST2_CLASS); }
	Class_ID		ClassID() { return Class_ID(TWISTOSM_CLASS_ID,1); }
#else
	const TCHAR *	ClassName() { return GetString(IDS_RB_TWIST_CLASS); }
	Class_ID		ClassID() { return Class_ID(TWISTOSM_CLASS_ID,0); }
#endif
	const TCHAR* 	Category() {return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static TwistClassDesc twistDesc;
#ifndef CHECK_AUTHORIZE	
extern ClassDesc* GetTwistModDesc() { return &twistDesc; }
#else
extern ClassDesc* GetTwistModDesc2() { return &twistDesc; }
#endif


class TwistWSMClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) 
		{if (loading) return new TwistWSM; else return new TwistWSM(new TwistMod);}
	const TCHAR *	ClassName() { return GetString(IDS_RB_TWIST_CLASS); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return TWISTWSM_CLASSID; }
	const TCHAR* 	Category() {return GetSpaceWarpCatString(SPACEWARP_CAT_MODBASED);}
	};

static TwistWSMClassDesc twistWSMDesc;
extern ClassDesc* GetTwistWSMDesc() { return &twistWSMDesc; }


//--- Parameter map/block descriptors -------------------------------

#define PB_ANGLE	0
#define PB_BIAS		1
#define PB_AXIS		2
#define PB_DOREGION	3
#define PB_FROM		4
#define PB_TO		5

//
//
// Parameters

static int axisIDs[] = {IDC_X,IDC_Y,IDC_Z};

static ParamUIDesc descParam[] = {
	// Angle
	ParamUIDesc(
		PB_ANGLE,
		EDITTYPE_FLOAT,
		IDC_ANGLE,IDC_ANGLESPINNER,
		-BIGFLOAT,BIGFLOAT,
		0.5f),
	
	// Bias
	ParamUIDesc(
		PB_BIAS,
		EDITTYPE_FLOAT,
		IDC_TWIST_BIAS,IDC_TWIST_BIASSPIN,
		-100.0f,100.0f,
		0.5f),
	
	// Axis
	ParamUIDesc(PB_AXIS,TYPE_RADIO,axisIDs,3),

	// Affect region
	ParamUIDesc(PB_DOREGION,TYPE_SINGLECHEKBOX,IDC_TWIST_AFFECTREGION),

	// From
	ParamUIDesc(
		PB_FROM,
		EDITTYPE_UNIVERSE,
		IDC_TWIST_FROM,IDC_TWIST_FROMSPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),

	// To
	ParamUIDesc(
		PB_TO,
		EDITTYPE_UNIVERSE,
		IDC_TWIST_TO,IDC_TWIST_TOSPIN,
		-BIGFLOAT,BIGFLOAT,		
		SPIN_AUTOSCALE),	
	};
#define PARAMDESC_LENGH 6

static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, FALSE, 1 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_INT, NULL, FALSE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 } };

#define PBLOCK_LENGTH	6

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,2,0)
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);


//--- TwistDlgProc -------------------------------



class TwistDlgProc : public ParamMapUserDlgProc {
	public:
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {}
	};
static TwistDlgProc theTwistProc;

#ifndef CHECK_AUTHORIZE	
BOOL TwistDlgProc::DlgProc(
		TimeValue t,IParamMap *map,
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case CC_SPINNER_CHANGE:
			switch (LOWORD(wParam)) {
				case IDC_TWIST_FROMSPIN: {
					float from, to;
					map->GetParamBlock()->GetValue(PB_FROM,t,from,FOREVER);
					map->GetParamBlock()->GetValue(PB_TO,t,to,FOREVER);
					if (from>to) {
						map->GetParamBlock()->SetValue(PB_TO,t,from);
						map->Invalidate();
						}
					break;
					}
				
				case IDC_TWIST_TOSPIN: {
					float from, to;
					map->GetParamBlock()->GetValue(PB_FROM,t,from,FOREVER);
					map->GetParamBlock()->GetValue(PB_TO,t,to,FOREVER);
					if (from>to) {
						map->GetParamBlock()->SetValue(PB_FROM,t,to);
						map->Invalidate();
						}
					break;
					}
				}
			break;
		}
	return FALSE;
	}
#endif

//--- Twist methods -------------------------------


TwistMod::TwistMod() : SimpleMod()
	{	
	MakeRefByID(FOREVER, SIMPMOD_PBLOCKREF, 
		CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue( PB_AXIS, TimeValue(0), 2/*Z*/ );
	}

IOResult TwistMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,SIMPMOD_PBLOCKREF));
	return IO_OK;
	}


void TwistMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
        static AuthInfo authInfo;

#ifdef CHECK_AUTHORIZE        
   	if (!IsAuthorized()) {
	    authInfo.twistMod = this;
	    authInfo.iobjParam = ip;
	    authInfo.create = flags&BEGIN_EDIT_CREATE;
	    hAuthWnd = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_AUTHMSG),
			AuthRollupProc,
			GetString(IDS_RB_TWISTPLUGIN),
			(LPARAM)&authInfo );	    
	    inAuthorizationMode = 1;
	    return;
		}
#endif

	inAuthorizationMode = 0;

	SimpleMod::BeginEditParams(ip,flags,prev);
		
	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_TWISTPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);	
	pmapParam->SetUserDlgProc(&theTwistProc);
	}

		
void TwistMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	if (inAuthorizationMode) {
	    if (flags&END_EDIT_REMOVEUI) {
			if (hAuthWnd) {		    	
		    	ip->DeleteRollupPage(hAuthWnd);
		    	hAuthWnd = NULL;
				}		
	    	}
	    return;
		}

	SimpleMod::EndEditParams(ip,flags,next);
	DestroyCPParamMap(pmapParam);
	}

Interval TwistMod::GetValidity(TimeValue t)
	{
	float f;
	Interval valid = FOREVER;
	pblock->GetValue(PB_ANGLE,t,f,valid);	
	pblock->GetValue(PB_BIAS,t,f,valid);
	pblock->GetValue(PB_FROM,t,f,valid);
	pblock->GetValue(PB_TO,t,f,valid);
	return valid;
	}

BOOL TwistMod::GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis)
	{
	int limit;
	pblock->GetValue(PB_DOREGION,t,limit,FOREVER);
	pblock->GetValue(PB_FROM,t,zmin,FOREVER);
	pblock->GetValue(PB_TO,t,zmax,FOREVER);
	pblock->GetValue(PB_AXIS,t,axis,FOREVER);
	return limit?TRUE:FALSE;
	}

RefTargetHandle TwistMod::Clone(RemapDir& remap) 
	{	
	TwistMod* newmod = new TwistMod();
	newmod->ReplaceReference(SIMPMOD_PBLOCKREF,pblock->Clone());
	newmod->SimpleModClone(this);
	return(newmod);
	}



TwistDeformer::TwistDeformer() 
	{ 
	tm.IdentityMatrix();
	time = 0;	
	}

TwistDeformer::TwistDeformer(
		TimeValue t, ModContext &mc,
		float angle, int naxis, float bias,
		float from, float to, int doRegion,
		Matrix3& modmat, Matrix3& modinv) 
	{	
	this->doRegion = doRegion;
	this->from = from;
	this->to   = to;
	if (bias!=0.0f) {
		this->bias = 1.0f-(bias+100.0f)/200.0f;
		if (this->bias < 0.00001f) this->bias = 0.00001f;
		if (this->bias > 0.99999f) this->bias = 0.99999f;
		this->bias = float(log(this->bias)/log(0.5));
		doBias = TRUE;
	} else {
		this->bias = 1.0f;
		doBias = FALSE;
		}
	
	Matrix3 mat;
	Interval valid;	
	time   = t;	

	tm = modmat;
	invtm = modinv;
	mat.IdentityMatrix();
	
	switch ( naxis ) {
		case 0: mat.RotateY( -HALFPI );	 break; //X
		case 1: mat.RotateX( HALFPI );  break; //Y
		case 2: break;  //Z
		}
	SetAxis( mat );	
	assert (mc.box);
	bbox = *mc.box;
	CalcHeight(naxis,DegToRad(angle));
	}

void TwistDeformer::SetAxis(Matrix3 &tmAxis)
	{
	Matrix3 itm = Inverse(tmAxis);
	tm    = tm*tmAxis;
	invtm =	itm*invtm;
	}

void TwistDeformer::CalcHeight(int axis, float angle)
	{
	switch ( axis ) {
		case 0:
			height = bbox.pmax.x - bbox.pmin.x;
			break;
		case 1:
			height = bbox.pmax.y - bbox.pmin.y;
			break;
		case 2:
			height = bbox.pmax.z - bbox.pmin.z;
			break;
		}
	if (height==0.0f) {
		theAngle = 0.0f;
		angleOverHeight = 0.0f;
	} else {
		theAngle = angle;
		angleOverHeight = angle / height;
		}
	}

Point3 TwistDeformer::Map(int i, Point3 p)
	{
	float x, y, z, cosine, sine, a;
	if (theAngle==0.0f) return p;
	p = p * tm;

	x = p.x;
	y = p.y;
	
	if (doRegion) {
		if (p.z<from) {
			z = from;
		} else 
		if (p.z>to) {
			z = to;
		} else {
			z = p.z;
			}
	} else {	
		z = p.z;
		}	
	
	if (doBias) {
		float u = z/height;
		a = theAngle * (float)pow(fabs(u), bias);
		if (u<0.0) a = -a;
	} else {
		a = z * angleOverHeight;
		}
	cosine = float(cos(a));
	sine = float(sin(a));
	p.x =  cosine*x + sine*y;
	p.y = -sine*x + cosine*y;

	p = p * invtm;
	return p;
	}


Deformer& TwistMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	float angle, from, to, bias;
	int axis;	
	int doRegion;
	static TwistDeformer deformer;
	pblock->GetValue(PB_ANGLE,t,angle,FOREVER);	
	pblock->GetValue(PB_AXIS,t,axis,FOREVER);
	pblock->GetValue(PB_FROM,t,from,FOREVER);
	pblock->GetValue(PB_TO,t,to,FOREVER);
	pblock->GetValue(PB_BIAS,t,bias,FOREVER);
	pblock->GetValue(PB_DOREGION,t,doRegion,FOREVER);
	deformer = TwistDeformer(t,mc,angle,axis,bias,from,to,doRegion,mat,invmat);
	return deformer;
	}

ParamDimension *TwistMod::GetParameterDim(int pbIndex)
	{
	switch (pbIndex) {
		case PB_ANGLE: 	return defaultDim; 		
		case PB_FROM:	return stdWorldDim;
		case PB_TO:		return stdWorldDim;
		case PB_BIAS:	return defaultDim;
		default:		return defaultDim;
		}
	}

TSTR TwistMod::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_ANGLE:	return GetString(IDS_RB_ANGLE);
		case PB_FROM:	return GetString(IDS_RB_FROM);
		case PB_TO:		return GetString(IDS_RB_TO);
		case PB_BIAS:	return GetString(IDS_RB_BIAS);
		default:		return TSTR(_T(""));
		}
	}



//--- Authorization Code -------------------------------------------


static void OutputLockID (HWND hWnd, unsigned int lockID)
{
    char string[10];

    PAINTSTRUCT ps;
    HDC hDC;
    InvalidateRect (hWnd, NULL, TRUE);
    hDC = BeginPaint (hWnd, &ps);
    SetBkMode (hDC, TRANSPARENT);
    sprintf (string, "%0x", lockID);
    TextOut (hDC, 0, 0, string, strlen(string));
    EndPaint (hWnd, &ps);
}


static BOOL CALLBACK AuthRollupProc( HWND hDlg, UINT message, 
			      WPARAM wParam, LPARAM lParam )
{
    AuthInfo *authInfo = (AuthInfo *) GetWindowLong (hDlg, GWL_USERDATA);

    switch (message) {
    case WM_CREATE:
	break;

    case WM_INITDIALOG:
	authInfo = (AuthInfo *) lParam;
	SetWindowLong (hDlg, GWL_USERDATA, (LONG) authInfo);
	return TRUE;

    case WM_COMMAND:
	switch (wParam) {
	case IDC_AUTHORIZE:
	    DialogBox (hInstance, MAKEINTRESOURCE(IDD_AUTHORIZE),
		       hDlg, AuthorizationDialogProc);
	    if (IsAuthorized()) {
		authInfo->twistMod->EndEditParams (authInfo->iobjParam, BEGIN_EDIT_CREATE,NULL);
		authInfo->twistMod->BeginEditParams (authInfo->iobjParam, 
						     authInfo->create?BEGIN_EDIT_CREATE:0,NULL);
	    }
	    return TRUE;
	case IDCANCEL:
	    EndDialog (hDlg, 0);
	    return TRUE;
	}
    }
    return FALSE;
}

static BOOL CALLBACK AuthorizationDialogProc( HWND hDlg, UINT message, 
				       WPARAM wParam, LPARAM lParam )
{
#define AUTH_LENGTH 20
    static HWND hCtrlWin;
    static char authString[AUTH_LENGTH];
    static unsigned int lockID;
    unsigned int authNum;

    switch (message) {
    case WM_INITDIALOG:
	hCtrlWin = GetDlgItem (hDlg, IDC_LOCKID);
	SetDlgItemText (hDlg, IDC_EDIT2, authString);
	SetFocus (GetDlgItem (hDlg, IDC_EDIT2));
	lockID = HardwareLockID ();
	return FALSE;

    case WM_COMMAND:
	switch (wParam) {
	case IDC_AUTHORIZE:
	    GetDlgItemText (hDlg, IDC_EDIT2, authString, AUTH_LENGTH);
	    sscanf (authString, "%x", &authNum);
	    if (authNum != lockID) {
//		char buffer[50];
//		sprintf (buffer, "Incorrect authorization string %s %0x",
//			 authString, authNum);
		
		TSTR buf1 = GetString(IDS_RB_INCORRECTSTRING);
		TSTR buf2 = GetString(IDS_RB_AUTHORIZATION);
		MessageBox (NULL, buf1, buf2,MB_ICONINFORMATION);
	    }
	    else
		Authorize();
	    EndDialog (hDlg, 0);
	    return TRUE;
	case IDCANCEL:
	    EndDialog (hDlg, 0);
	    return TRUE;
	}

    case WM_PAINT:
	OutputLockID (hCtrlWin, lockID);
	break;

    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\taper.cpp ===
/**********************************************************************
 *<
	FILE: taper.cpp

	DESCRIPTION:  Taper OSM

	CREATED BY: Dan Silva & Rolf Berteig

	HISTORY: created 30 Jauary, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"

// in mods.cpp
extern HINSTANCE hInstance;

#define BIGFLOAT	float(999999)

class TaperMod : public SimpleMod {
	public:
		static IParamMap *pmapParam;

		TaperMod();		
				
		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_TAPERMOD); }  
		virtual Class_ID ClassID() { return Class_ID(TAPEROSM_CLASS_ID,0);}
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next );
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_RB_TAPER); }		
		IOResult Load(ILoad *iload);

		// From simple mod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		BOOL GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis);
		void InvalidateUI() {if (pmapParam) pmapParam->Invalidate();}
	};


class TaperDeformer: public Deformer {
	public:
		Matrix3 tm,invtm;
		Box3 bbox;
		TimeValue time;
		float k1,k2, from, to;
		int doRegion, naxis;
		BOOL doX, doY, sym;
		TaperDeformer();
		TaperDeformer(
			TimeValue t, ModContext &mc, 
			float  amt, float crv, int naxis,
			int eaxis, int sym,
			float from, float to, int doRegion,
			Matrix3& modmat, Matrix3& modinv);
		void SetAxis(Matrix3 &tmAxis);
		void SetK(float K1, float K2) { k1 = K1; k2 = K2; }
		Point3 Map(int i, Point3 p); 
	};

#define TAPERWSM_CLASSID	Class_ID(TAPEROSM_CLASS_ID,1)

class TaperWSM : public SimpleOSMToWSMObject {
	public:
		TaperWSM() {}
		TaperWSM(TaperMod *m) : SimpleOSMToWSMObject(m) {}
		void DeleteThis() { delete this; }
		SClass_ID SuperClassID() {return WSM_OBJECT_CLASS_ID;}
		Class_ID ClassID() {return TAPERWSM_CLASSID;} 
		TCHAR *GetObjectName() {return GetString(IDS_RB_TAPER);}
		RefTargetHandle Clone(RemapDir& remap)
			{return (new TaperWSM((TaperMod*)mod->Clone(remap)))->SimpleOSMToWSMClone(this,remap);}
	};


//--- ClassDescriptor and class vars ---------------------------------

IParamMap *TaperMod::pmapParam;

class TaperClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new TaperMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_TAPER_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return  Class_ID(TAPEROSM_CLASS_ID,0); }
	const TCHAR* 	Category() {return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static TaperClassDesc taperDesc;
extern ClassDesc* GetTaperModDesc() { return &taperDesc; }

class TaperWSMClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) 
		{if (loading) return new TaperWSM; else return new TaperWSM(new TaperMod);}
	const TCHAR *	ClassName() { return GetString(IDS_RB_TAPER_CLASS); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return TAPERWSM_CLASSID; }
	const TCHAR* 	Category() {return GetSpaceWarpCatString(SPACEWARP_CAT_MODBASED);}
	};

static TaperWSMClassDesc taperWSMDesc;
extern ClassDesc* GetTaperWSMDesc() { return &taperWSMDesc; }


//--- Parameter map/block descriptors -------------------------------

#define PB_AMT			0
#define PB_CRV			1
#define PB_AXIS			2
#define PB_EFFECTAXIS	3
#define PB_SYMMETRY		4
#define PB_DOREGION		5
#define PB_FROM			6
#define PB_TO			7


//
//
// Parameters

static int axisIDs[] = {IDC_X,IDC_Y,IDC_Z};
static int effectAxisIDs[] = {IDC_EFFECT_X,IDC_EFFECT_Y,IDC_EFFECT_BOTH};

static ParamUIDesc descParam[] = {
	// Amount
	ParamUIDesc(
		PB_AMT,
		EDITTYPE_FLOAT,
		IDC_AMT,IDC_AMTSPINNER,
		-10.0f,10.0f,
		0.01f),

	// Curve
	ParamUIDesc(
		PB_CRV,
		EDITTYPE_FLOAT,
		IDC_CRV,IDC_CRVSPINNER,
		-10.0f,10.0f,
		0.01f),
	
	// Primary Axis
	ParamUIDesc(PB_AXIS,TYPE_RADIO,axisIDs,3),

	// Effect Axis
	ParamUIDesc(PB_EFFECTAXIS,TYPE_RADIO,effectAxisIDs,3),

	// Symmetry
	ParamUIDesc(PB_SYMMETRY,TYPE_SINGLECHEKBOX,IDC_TAPER_SYMMETRY),

	// Affect region
	ParamUIDesc(PB_DOREGION,TYPE_SINGLECHEKBOX,IDC_TAPER_AFFECTREGION),

	// From
	ParamUIDesc(
		PB_FROM,
		EDITTYPE_UNIVERSE,
		IDC_TAPER_FROM,IDC_TAPER_FROMSPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),

	// To
	ParamUIDesc(
		PB_TO,
		EDITTYPE_UNIVERSE,
		IDC_TAPER_TO,IDC_TAPER_TOSPIN,
		-BIGFLOAT,BIGFLOAT,		
		SPIN_AUTOSCALE),	
	};
#define PARAMDESC_LENGH 8


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 } };

#define PBLOCK_LENGTH	8

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,0)
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);


//--- TaperDlgProc -------------------------------

class TaperDlgProc : public ParamMapUserDlgProc {
	public:
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void InitEffectAxis(HWND hWnd,TimeValue t,IParamMap *map);
		void DeleteThis() {}
	};
static TaperDlgProc theTaperProc;

void TaperDlgProc::InitEffectAxis(HWND hWnd,TimeValue t,IParamMap *map)
	{
	int axis;
	map->GetParamBlock()->GetValue(PB_AXIS,t,axis,FOREVER);
	switch (axis) {
		case 0:
			SetWindowText(GetDlgItem(hWnd,IDC_EFFECT_X),_T("Z"));
			SetWindowText(GetDlgItem(hWnd,IDC_EFFECT_Y),_T("Y"));
			SetWindowText(GetDlgItem(hWnd,IDC_EFFECT_BOTH),_T("ZY"));
			break;
		case 1:
			SetWindowText(GetDlgItem(hWnd,IDC_EFFECT_X),_T("X"));
			SetWindowText(GetDlgItem(hWnd,IDC_EFFECT_Y),_T("Z"));
			SetWindowText(GetDlgItem(hWnd,IDC_EFFECT_BOTH),_T("XZ"));
			break;
		case 2:
			SetWindowText(GetDlgItem(hWnd,IDC_EFFECT_X),_T("X"));
			SetWindowText(GetDlgItem(hWnd,IDC_EFFECT_Y),_T("Y"));
			SetWindowText(GetDlgItem(hWnd,IDC_EFFECT_BOTH),_T("XY"));
			break;
		}
	}

BOOL TaperDlgProc::DlgProc(
		TimeValue t,IParamMap *map,
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			InitEffectAxis(hWnd,t,map);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_X:
				case IDC_Y:
				case IDC_Z:
					InitEffectAxis(hWnd,t,map);
					break;		
				}
			break;

		case CC_SPINNER_CHANGE:
			switch (LOWORD(wParam)) {
				case IDC_TAPER_FROMSPIN: {
					float from, to;
					map->GetParamBlock()->GetValue(PB_FROM,t,from,FOREVER);
					map->GetParamBlock()->GetValue(PB_TO,t,to,FOREVER);
					if (from>to) {
						map->GetParamBlock()->SetValue(PB_TO,t,from);
						map->Invalidate();
						}
					break;
					}
				
				case IDC_TAPER_TOSPIN: {
					float from, to;
					map->GetParamBlock()->GetValue(PB_FROM,t,from,FOREVER);
					map->GetParamBlock()->GetValue(PB_TO,t,to,FOREVER);
					if (from>to) {
						map->GetParamBlock()->SetValue(PB_FROM,t,to);
						map->Invalidate();
						}
					break;
					}
				}
			break;
		}
	return FALSE;
	}

//--- Bend methods -------------------------------


TaperMod::TaperMod()
	{
	MakeRefByID(FOREVER, SIMPMOD_PBLOCKREF, 
		CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));

	pblock->SetValue(PB_AXIS, TimeValue(0), 2/*Z*/);
	pblock->SetValue(PB_EFFECTAXIS, TimeValue(0), 2/*XY*/);
	}

IOResult TaperMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,SIMPMOD_PBLOCKREF));
	return IO_OK;
	}

void TaperMod::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev)
	{
	SimpleMod::BeginEditParams(ip,flags,prev);
		
	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_TAPERPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);	
	pmapParam->SetUserDlgProc(&theTaperProc);
	}
		
void TaperMod::EndEditParams(IObjParam *ip, ULONG flags,Animatable *next)
	{
	SimpleMod::EndEditParams(ip,flags,next);
	DestroyCPParamMap(pmapParam);
	}

Interval TaperMod::GetValidity(TimeValue t)
	{
	float f;	
	int i;
	Interval valid = FOREVER;
	pblock->GetValue(PB_AMT,t,f,valid);
	pblock->GetValue(PB_CRV,t,f,valid);
	pblock->GetValue(PB_FROM,t,f,valid);
	pblock->GetValue(PB_TO,t,f,valid);
	pblock->GetValue(PB_SYMMETRY,t,i,valid);
	return valid;
	}

BOOL TaperMod::GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis)
	{
	int limit;
	pblock->GetValue(PB_DOREGION,t,limit,FOREVER);
	pblock->GetValue(PB_FROM,t,zmin,FOREVER);
	pblock->GetValue(PB_TO,t,zmax,FOREVER);
	pblock->GetValue(PB_AXIS,t,axis,FOREVER);
	return limit?TRUE:FALSE;
	}

RefTargetHandle TaperMod::Clone(RemapDir& remap) 
	{	
	TaperMod* newmod = new TaperMod();
	newmod->ReplaceReference(SIMPMOD_PBLOCKREF,pblock->Clone(remap));
	newmod->SimpleModClone(this);
	return(newmod);
	}

TaperDeformer::TaperDeformer() 
	{ 
	tm.IdentityMatrix();
	time = 0;	
	}

void TaperDeformer::SetAxis(Matrix3 &tmAxis)
	{
	Matrix3 itm = Inverse(tmAxis);
	tm    = tm*tmAxis;
	invtm =	itm*invtm;
	}

Point3 TaperDeformer::Map(int i, Point3 p)
	{
	float f, z, l;
	l = (bbox.pmax[naxis]-bbox.pmin[naxis]);
	if ( l == float(0) ) return p;
	p = p * tm;
	if (doRegion) {
		if (p.z<from) {
			z = from/l;
		} else 
		if (p.z>to) {
			z = to/l;
		} else {
			z = p.z/l;
			}
	} else {	
		z = p.z/l;
		}	
	if (sym && z<0.0f) z = -z;	
	f =  float(1.0) + z*k1 + k2*z*(float(1.0)-z);	
  	if (doX) p.x *= f;
  	if (doY) p.y *= f;
	p = p * invtm;
	return p;
	}

TaperDeformer::TaperDeformer(
		TimeValue t, ModContext &mc, 
		float  amt, float crv, int naxis,
		int eaxis, int sym,
		float from, float to, int doRegion,
 		Matrix3& modmat, Matrix3& modinv)
	{		
	this->naxis = naxis;
	this->doRegion = doRegion;
	this->from = from;
	this->to   = to;
	this->sym  = sym;
	switch (eaxis) {
		case 0: doX = TRUE;  doY = FALSE; break;
		case 1: doX = FALSE; doY = TRUE;  break;
		case 2: doX = TRUE;  doY = TRUE;  break;
		}
	Interval valid;
	Matrix3 mat;	
	time   = t;	
	tm = modmat;
	invtm = modinv;
	mat.IdentityMatrix();
	SetK(amt,crv);
	switch (naxis) {
		case 0: mat.RotateY( -HALFPI );	 break; //x
		case 1:	mat.RotateX( HALFPI );	break;  //y
		case 2: break;   //z
		}
	SetAxis( mat );
	bbox = *mc.box;
	}


Deformer& TaperMod::GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	static TaperDeformer deformer;
	float amt, crv, from, to;
	int doRegion, axis;
	int eaxis, sym;

	pblock->GetValue(PB_AMT,t,amt,FOREVER);
	pblock->GetValue(PB_CRV,t,crv,FOREVER);
	pblock->GetValue(PB_AXIS,t,axis,FOREVER);
	pblock->GetValue(PB_EFFECTAXIS,t,eaxis,FOREVER);
	pblock->GetValue(PB_SYMMETRY,t,sym,FOREVER);
	pblock->GetValue(PB_FROM,t,from,FOREVER);
	pblock->GetValue(PB_TO,t,to,FOREVER);
	pblock->GetValue(PB_DOREGION,t,doRegion,FOREVER);
	
	deformer = TaperDeformer(t,mc,amt,crv,axis,eaxis,sym,from,to,doRegion,mat,invmat);
	return deformer;
	}

ParamDimension *TaperMod::GetParameterDim(int pbIndex)
	{
	switch (pbIndex) {
		case PB_AMT: 		return stdNormalizedDim; 
		case PB_CRV:		return stdNormalizedDim;		
		case PB_FROM:		return stdWorldDim;
		case PB_TO:			return stdWorldDim;
		case PB_SYMMETRY:	return defaultDim;
		default:			return defaultDim;
		}
	}

TSTR TaperMod::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_AMT:		return GetString(IDS_RB_AMOUNT);
		case PB_CRV:		return GetString(IDS_RB_CURVITURE);
		case PB_FROM:		return GetString(IDS_RB_FROM);
		case PB_TO:			return GetString(IDS_RB_TO);
		case PB_SYMMETRY:	return GetString(IDS_RB_SYMMETRY);
		default:			return TSTR(_T(""));
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\twist2.cpp ===
#include "mods.h"
//#define CHECK_AUTHORIZE
//#include "twist.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\uvwxform.cpp ===
/**********************************************************************
 *<
	FILE: uvwxform.cpp

	DESCRIPTION:  Transforms UVW coords

	CREATED BY: Rolf Berteig

	HISTORY: 10/26/96

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm.h"


class UVWXFormMod : public Modifier {	
public:		
	IParamBlock *pblock;
	
	static IObjParam *ip;
	static IParamMap *pmapParam;
	static UVWXFormMod *editMod;

	UVWXFormMod();

	// From Animatable
	void DeleteThis() { delete this; }
	void GetClassName(TSTR& s) {s = GetString(IDS_RB_UVWXFORMMOD);}  
	virtual Class_ID ClassID() { return Class_ID(UVW_XFORM_CLASS_ID,0);}		
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	TCHAR *GetObjectName() {return GetString(IDS_RB_UVWXFORMMOD);}
	void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
	void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);

	IOResult Load(ILoad *iload);

	// From modifier
	ChannelMask ChannelsUsed()  {return PART_TEXMAP|PART_VERTCOLOR|PART_TOPO|PART_GEOM;} // mjm - 10.5.99 - added PART_GEOM
	ChannelMask ChannelsChanged() {return PART_TEXMAP|PART_VERTCOLOR;}
	Class_ID InputType() {return triObjectClassID;}
	void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
	Interval LocalValidity(TimeValue t);

	// From BaseObject
	CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
	IParamArray *GetParamBlock() {return pblock;}
	int GetParamBlockIndex(int id) {return id;}

	int NumRefs() {return 1;}
	RefTargetHandle GetReference(int i) {return pblock;}
	void SetReference(int i, RefTargetHandle rtarg) {pblock = (IParamBlock*)rtarg;}

	int NumSubs() {return 1;}
	Animatable* SubAnim(int i) {return pblock;}
	TSTR SubAnimName(int i) {return _T("");}

	RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
	   PartID& partID, RefMessage message);
};


//--- ClassDescriptor and class vars ---------------------------------

IParamMap       *UVWXFormMod::pmapParam = NULL;
IObjParam       *UVWXFormMod::ip        = NULL;
UVWXFormMod     *UVWXFormMod::editMod   = NULL;


class UVWXFormClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new UVWXFormMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_UVWXFORMMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(UVW_XFORM_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
};

static UVWXFormClassDesc uvwxformDesc;
ClassDesc* GetUVWXFormModDesc() {return &uvwxformDesc;}

//--- Parameter map/block descriptors -------------------------------

#define PB_UTILE	0
#define PB_VTILE	1
#define PB_WTILE	2
#define PB_UOFFSET	3
#define PB_VOFFSET	4
#define PB_WOFFSET	5
#define PB_UFLIP	6
#define PB_VFLIP	7
#define PB_WFLIP	8
#define PB_CHANNEL	9
#define PB_MAPCHANNEL 10

//
//
// Parameters

static int chanIDs[] = {IDC_MAP_TEXMAP, IDC_MAP_VERTCOL};

static ParamUIDesc descParam[] = {
	// U Tile
	ParamUIDesc (PB_UTILE, EDITTYPE_FLOAT,
		IDC_MAP_UTILE,IDC_MAP_UTILESPIN,
		-BIGFLOAT,BIGFLOAT, SPIN_AUTOSCALE),

	// V Tile
	ParamUIDesc (PB_VTILE, EDITTYPE_FLOAT,
		IDC_MAP_VTILE,IDC_MAP_VTILESPIN,
		-BIGFLOAT,BIGFLOAT, SPIN_AUTOSCALE),

	// W Tile
	ParamUIDesc (PB_WTILE, EDITTYPE_FLOAT,
		IDC_MAP_WTILE,IDC_MAP_WTILESPIN,
		-BIGFLOAT,BIGFLOAT, SPIN_AUTOSCALE),

	// U Offset
	ParamUIDesc (PB_UOFFSET, EDITTYPE_FLOAT,
		IDC_MAP_UOFFSET,IDC_MAP_UOFFSETSPIN,
		-BIGFLOAT,BIGFLOAT, SPIN_AUTOSCALE),

	// V Offset
	ParamUIDesc (PB_VOFFSET, EDITTYPE_FLOAT,
		IDC_MAP_VOFFSET,IDC_MAP_VOFFSETSPIN,
		-BIGFLOAT,BIGFLOAT, SPIN_AUTOSCALE),

	// W Offset
	ParamUIDesc (PB_WOFFSET, EDITTYPE_FLOAT,
		IDC_MAP_WOFFSET,IDC_MAP_WOFFSETSPIN,
		-BIGFLOAT,BIGFLOAT, SPIN_AUTOSCALE),

	// U Flip
	ParamUIDesc(PB_UFLIP,TYPE_SINGLECHEKBOX,IDC_MAP_UFLIP),

	// V Flip
	ParamUIDesc(PB_VFLIP,TYPE_SINGLECHEKBOX,IDC_MAP_VFLIP),

	// W Flip
	ParamUIDesc(PB_WFLIP,TYPE_SINGLECHEKBOX,IDC_MAP_WFLIP),

	// Channel
	ParamUIDesc(PB_CHANNEL,TYPE_RADIO,chanIDs,2),

	// MapChannel
	ParamUIDesc (PB_MAPCHANNEL, EDITTYPE_POS_INT,
		IDC_MAP_CHAN, IDC_MAP_CHAN_SPIN,
		1, MAX_MESHMAPS-1, SPIN_AUTOSCALE),
};
#define PARAMDESC_LENGTH	11

static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE,  PB_UTILE },		// U Tile
	{ TYPE_FLOAT, NULL, TRUE,  PB_VTILE },		// V Tile
	{ TYPE_FLOAT, NULL, TRUE,  PB_WTILE },		// W Tile
	{ TYPE_FLOAT, NULL, TRUE,  PB_UOFFSET },		// U Offset
	{ TYPE_FLOAT, NULL, TRUE,  PB_VOFFSET },		// V Offset
	{ TYPE_FLOAT, NULL, TRUE,  PB_WOFFSET },		// W Offset
	{ TYPE_INT,   NULL, FALSE, PB_UFLIP },		// U Flip
	{ TYPE_INT,   NULL, FALSE, PB_VFLIP },		// V Flip
	{ TYPE_INT,   NULL, FALSE, PB_WFLIP },		// W Flip	
	};

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE,  PB_UTILE },		// U Tile
	{ TYPE_FLOAT, NULL, TRUE,  PB_VTILE },		// V Tile
	{ TYPE_FLOAT, NULL, TRUE,  PB_WTILE },		// W Tile
	{ TYPE_FLOAT, NULL, TRUE,  PB_UOFFSET },		// U Offset
	{ TYPE_FLOAT, NULL, TRUE,  PB_VOFFSET },		// V Offset
	{ TYPE_FLOAT, NULL, TRUE,  PB_WOFFSET },		// W Offset
	{ TYPE_INT,   NULL, FALSE, PB_UFLIP },		// U Flip
	{ TYPE_INT,   NULL, FALSE, PB_VFLIP },		// V Flip
	{ TYPE_INT,   NULL, FALSE, PB_WFLIP },		// W Flip	
	{ TYPE_INT,   NULL, FALSE, PB_CHANNEL },		// channel
};

static ParamBlockDescID descVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE,  PB_UTILE },		// U Tile
	{ TYPE_FLOAT, NULL, TRUE,  PB_VTILE },		// V Tile
	{ TYPE_FLOAT, NULL, TRUE,  PB_WTILE },		// W Tile
	{ TYPE_FLOAT, NULL, TRUE,  PB_UOFFSET },		// U Offset
	{ TYPE_FLOAT, NULL, TRUE,  PB_VOFFSET },		// V Offset
	{ TYPE_FLOAT, NULL, TRUE,  PB_WOFFSET },		// W Offset
	{ TYPE_INT,   NULL, FALSE, PB_UFLIP },		// U Flip
	{ TYPE_INT,   NULL, FALSE, PB_VFLIP },		// V Flip
	{ TYPE_INT,   NULL, FALSE, PB_WFLIP },		// W Flip	
	{ TYPE_INT,   NULL, FALSE, PB_CHANNEL },		// channel
	{ TYPE_INT,   NULL, FALSE, PB_MAPCHANNEL },
};

#define PBLOCK_LENGTH	11

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,9,0),	
	ParamVersionDesc(descVer1,10,1),	
};
#define NUM_OLDVERSIONS	2

// Current version
#define CURRENT_VERSION	2
static ParamVersionDesc curVersion(descVer2, PBLOCK_LENGTH, CURRENT_VERSION);


//--- UVWXForm mod methods -------------------------------

UVWXFormMod::UVWXFormMod() {
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descVer2, PBLOCK_LENGTH, CURRENT_VERSION));

	pblock->SetValue(PB_UTILE,0,1.0f);
	pblock->SetValue(PB_VTILE,0,1.0f);
	pblock->SetValue(PB_WTILE,0,1.0f);
	pblock->SetValue (PB_MAPCHANNEL, 0, 1);
}

// Following is necessary to make sure mapchannel doesn't come in as zero;
// this happens when loading up an old scene -- the pblock with the defaults
// is overwritten.
class XSetChannelToOne : public PostLoadCallback {
public:
	UVWXFormMod *xm;
	XSetChannelToOne (UVWXFormMod *xMod) { xm = xMod; }
	void proc (ILoad *iload);
};

void XSetChannelToOne::proc (ILoad *iload) {
	if (xm && xm->pblock) {
		int mapChan;
		xm->pblock->GetValue (PB_MAPCHANNEL, 0, mapChan, FOREVER);
		if (!mapChan) xm->pblock->SetValue (PB_MAPCHANNEL, 0, 1);
	}
	delete this;
}

IOResult UVWXFormMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);

	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	iload->RegisterPostLoadCallback (new XSetChannelToOne (this));
	return IO_OK;
	}

void UVWXFormMod::BeginEditParams (IObjParam  *ip, ULONG flags,Animatable *prev) {
	this->ip = ip;
	editMod  = this;
	
	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);	
	SetAFlag(A_MOD_BEING_EDITED);

	pmapParam = CreateCPParamMap (descParam,PARAMDESC_LENGTH,
		pblock, ip, hInstance, MAKEINTRESOURCE(IDD_UVWXFORMPARAM),
		GetString(IDS_RB_PARAMETERS), 0);	
}

void UVWXFormMod::EndEditParams(IObjParam *ip,ULONG flags,Animatable *next) {
	this->ip = NULL;
	editMod  = NULL;

	TimeValue t = ip->GetTime();

	// NOTE: This flag must be cleared before sending the REFMSG_END_EDIT
	ClearAFlag(A_MOD_BEING_EDITED);

	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	
	DestroyCPParamMap(pmapParam);
	}

RefTargetHandle UVWXFormMod::Clone(RemapDir& remap)
	{
	UVWXFormMod *mod = new UVWXFormMod();
	mod->ReplaceReference(0,pblock->Clone(remap));	
	return mod;
	}

void UVWXFormMod::ModifyObject (TimeValue t, ModContext &mc, ObjectState *os, INode *node) {
	if (!os->obj->IsSubClassOf(triObjectClassID)) return;

	TriObject *tobj = (TriObject*)os->obj;
	Mesh &mesh = tobj->GetMesh();
	Interval iv = FOREVER;
	float ut, vt, wt, uo, vo, wo;
	int uf, vf, wf, channel, mapChannel;
	pblock->GetValue(PB_UTILE,t,ut,iv);
	pblock->GetValue(PB_VTILE,t,vt,iv);
	pblock->GetValue(PB_WTILE,t,wt,iv);
	pblock->GetValue(PB_UOFFSET,t,uo,iv);
	pblock->GetValue(PB_VOFFSET,t,vo,iv);
	pblock->GetValue(PB_WOFFSET,t,wo,iv);	
	pblock->GetValue(PB_UFLIP,t,uf,iv);
	pblock->GetValue(PB_VFLIP,t,vf,iv);
	pblock->GetValue(PB_WFLIP,t,wf,iv);
	pblock->GetValue(PB_CHANNEL,t,channel,iv);
	pblock->GetValue (PB_MAPCHANNEL, t, mapChannel, iv);

	if (channel) {
		mapChannel = 0;
		iv &= tobj->ChannelValidity (t, VERT_COLOR_CHAN_NUM);
	} else {
		iv &= tobj->ChannelValidity (t, TEXMAP_CHAN_NUM);
	}

	if (!mesh.mapSupport(mapChannel)) return;
	int ct = mesh.getNumMapVerts (mapChannel);
	UVVert *mv = mesh.mapVerts (mapChannel);
	for (int i=0; i<ct; i++) {
		Point3 & uvw = mv[i];
		if (uf) uvw.x = 1.0f-uvw.x;
		if (vf) uvw.y = 1.0f-uvw.y;
		if (wf) uvw.z = 1.0f-uvw.z;
		if (ut!=0.0f) uvw.x *= ut;
		if (vt!=0.0f) uvw.y *= vt;
		if (wt!=0.0f) uvw.z *= wt;
		uvw.x += uo;
		uvw.y += vo;
		uvw.z += wo;
	}

	if (channel) os->obj->UpdateValidity (VERT_COLOR_CHAN_NUM, iv);
	else os->obj->UpdateValidity(TEXMAP_CHAN_NUM,iv);
}

Interval UVWXFormMod::LocalValidity(TimeValue t)
	{
	Interval iv = FOREVER;
	float f;
	pblock->GetValue(PB_UTILE,t,f,iv);
	pblock->GetValue(PB_VTILE,t,f,iv);
	pblock->GetValue(PB_WTILE,t,f,iv);
	pblock->GetValue(PB_UOFFSET,t,f,iv);
	pblock->GetValue(PB_VOFFSET,t,f,iv);
	pblock->GetValue(PB_WOFFSET,t,f,iv);	
	return iv;
	}

RefResult UVWXFormMod::NotifyRefChanged( 
		Interval changeInt,RefTargetHandle hTarget, 
		PartID& partID, RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			if (editMod==this && pmapParam) pmapParam->Invalidate();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_UTILE:
				case PB_VTILE:
				case PB_WTILE:
				case PB_UOFFSET:
				case PB_VOFFSET:
				case PB_WOFFSET: gpd->dim = stdNormalizedDim; break;				
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;			
			switch (gpn->index) {
				case PB_UTILE:	 gpn->name = GetString(IDS_RB_UTILE); break;
				case PB_VTILE:	 gpn->name = GetString(IDS_RB_VTILE); break;
				case PB_WTILE:	 gpn->name = GetString(IDS_RB_WTILE); break;
				case PB_UOFFSET: gpn->name = GetString(IDS_RB_UOFFSET); break;
				case PB_VOFFSET: gpn->name = GetString(IDS_RB_VOFFSET); break;
				case PB_WOFFSET: gpn->name = GetString(IDS_RB_WOFFSET); break;
				case PB_UFLIP: gpn->name = GetString(IDS_UVWX_UFLIP); break;
				case PB_VFLIP: gpn->name = GetString(IDS_UVWX_VFLIP); break;
				case PB_WFLIP: gpn->name = GetString(IDS_UVWX_WFLIP); break;
				case PB_CHANNEL: gpn->name = GetString(IDS_UVWX_CHANNEL); break;
				}
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\unwrap.cpp ===
/********************************************************************** *<
	FILE: unwrap.cpp

	DESCRIPTION: A UVW map modifier unwraps the UVWs onto the image

	HISTORY: 12/31/96
	CREATED BY: Rolf Berteig
	UPDATED Sept. 16, 1998 Peter Watje




 *>	Copyright (c) 1998, All Rights Reserved.
**********************************************************************/

#include "mods.h"
#include "iparamm.h"
#include "meshadj.h"
#include "sctex.h"
#include "decomp.h"

#include "gport.h"
#include "bmmlib.h"

#include "stdmat.h"


#define UNWRAP_NAME		GetString(IDS_RB_UNWRAPMOD)
#define UNWRAP_CLASSID	Class_ID(0x02df2e3a,0x72ba4e1f)

// Flags
#define CONTROL_FIT			(1<<0)
#define CONTROL_CENTER		(1<<1)
#define CONTROL_ASPECT		(1<<2)
#define CONTROL_UNIFORM		(1<<3)
#define CONTROL_HOLD		(1<<4)
#define CONTROL_INIT		(1<<5)
#define CONTROL_OP			(CONTROL_FIT|CONTROL_CENTER|CONTROL_ASPECT|CONTROL_UNIFORM)
#define CONTROL_INITPARAMS	(1<<10)

#define IS_MESH		1
#define IS_PATCH	2
#define IS_NURBS	3


class UnwrapMod;

static HCURSOR selCur   = NULL;
static HCURSOR moveCur  = NULL;
static HCURSOR moveXCur  = NULL;
static HCURSOR moveYCur  = NULL;
static HCURSOR rotCur   = NULL;
static HCURSOR scaleCur = NULL;
static HCURSOR scaleXCur = NULL;
static HCURSOR scaleYCur = NULL;

static HCURSOR zoomCur = NULL;
static HCURSOR zoomRegionCur = NULL;
static HCURSOR panCur = NULL;
static HCURSOR weldCur = NULL;

#define CBS		(WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST | WS_VSCROLL)


// Rightclick menu UI stuff


void UnwrapMatrixFromNormal(Point3& normal, Matrix3& mat);


class SelectMode : public MouseCallBack {
	public:
		UnwrapMod *mod;
		BOOL region, toggle, subtract;
		IPoint2 om, lm;
		SelectMode(UnwrapMod *m) {mod=m;}
		int proc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
		virtual int subproc(HWND hWnd, int msg, int point, int flags, IPoint2 m)=0;
		virtual HCURSOR GetXFormCur()=0;
	};




class MoveMode : public SelectMode {
	public:				
		UnwrapMod *mod;
		MoveMode(UnwrapMod *m) : SelectMode(m) {mod = m;}
		int subproc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
		HCURSOR GetXFormCur();
	};
class RotateMode : public SelectMode {
	public:				
		RotateMode(UnwrapMod *m) : SelectMode(m) {}
		int subproc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
		HCURSOR GetXFormCur() {return rotCur;}
	};
class ScaleMode : public SelectMode {
	public:				
		ScaleMode(UnwrapMod *m) : SelectMode(m) {}
		int subproc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
		HCURSOR GetXFormCur();// {return scaleCur;}
	};
class WeldMode : public SelectMode {
	public:				
		WeldMode(UnwrapMod *m) : SelectMode(m) {}
		int subproc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
		HCURSOR GetXFormCur() {return weldCur;}
	};

class PanMode : public MouseCallBack {
	public:
		UnwrapMod *mod;
		IPoint2 om;
		float oxscroll, oyscroll;
		PanMode(UnwrapMod *m) {mod=m;}
		int proc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
		HCURSOR GetXFormCur() {return panCur;}

	};
class ZoomMode : public MouseCallBack {
	public:
		UnwrapMod *mod;
		IPoint2 om;
		float ozoom;
		float oxscroll, oyscroll;
		ZoomMode(UnwrapMod *m) {mod=m;}
		int proc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
		HCURSOR GetXFormCur() {
			return zoomCur;
			}
	};
class ZoomRegMode : public MouseCallBack {
	public:
		UnwrapMod *mod;
		IPoint2 om, lm;		
		ZoomRegMode(UnwrapMod *m) {mod=m;}
		int proc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
		HCURSOR GetXFormCur() {return zoomCur;}
	};



class RightMouseMode : public MouseCallBack {
	public:
		UnwrapMod *mod;		
		RightMouseMode(UnwrapMod *m) {mod=m;}
		int proc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
	};


class MiddleMouseMode : public MouseCallBack {
	public:
		UnwrapMod *mod;		
		IPoint2 om;
		float ozoom;
		float oxscroll, oyscroll;
		MiddleMouseMode(UnwrapMod *m) {mod=m;}
		int proc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
	};


#define CID_FACEALIGNMAP 	0x4f298c7c
#define CID_REGIONFIT 		0x4f298c7d





//nee a table of TV faces

class UVW_TVFaceClass
{
public:

int t[4];
int FaceIndex;
int MatID;
int flags;
Point3 pt[4];
};

#define FLAG_DEAD		1
#define FLAG_HIDDEN		2
#define FLAG_FROZEN		4
#define FLAG_QUAD		8
#define FLAG_SELECTED	16

//need a table of TVert pointers
class UVW_TVVertClass
{
public:
Point3 p;
float influence;
BYTE flags;
};

class UVW_ChannelClass
{
public:
int channel;
Tab<UVW_TVVertClass> v;
Tab<UVW_TVFaceClass> f;
Tab<Control*> cont;		
};


class VertexLookUpDataClass
{
public:
int index;
int newindex;
Point3 p;

};
class VertexLookUpListClass
{
public:
BitArray sel;
Tab<VertexLookUpDataClass> d;
void addPoint(int a_index, Point3 a);
};

void VertexLookUpListClass::addPoint(int a_index, Point3 a)
	{	
	BOOL found = FALSE;
	if (sel[a_index]) found = TRUE;
/*	
	for (int i = 0; i < d.Count(); i++)
		{
		if (d[i].index == a_index)
			{
			found = TRUE;
			i = d.Count();
			}
		}
*/
	if (!found)
		{
		VertexLookUpDataClass t;
		t.index = a_index;
		t.newindex = a_index;
		t.p = a;
//		d.Append(1,&t,1);
		d[a_index] = t;
		sel.Set(a_index);
		}
	};



class UnwrapRegionFitMode;
class UnwrapFaceAlignMode;

class UnwrapMod : public Modifier, TimeChangeCallback {	
	public:	
//		Tab<Point3> tvert;
//		Tab<TVFace> tvFace;
//		Tab<Control*> cont;		
		int version;
		BOOL oldDataPresent;
		BOOL firstPass;
		BitArray vsel;
//		BitArray meshsel;
		Tab<int> facehit;
		Control *tmControl;
		Control *offsetControl;
		Control *scaleControl;
		Control *rotateControl;


		Point3 gNormal,gCenter;
		float gXScale,gYScale;


		DWORD flags;
		BOOL instanced;

		Point3 s;

		float zoom, aspect, xscroll, yscroll;
		Mtl *BaseMtl; 
		static int CurrentMap;
		Texmap *map[10];
		void AddMaterial(MtlBase *mtl);
		void LoadMaterials();
		void UpdateListBox();

		UBYTE *image;
		int iw, ih, uvw, move,scale;
		int rendW, rendH;
		int channel;
		int pixelSnap;
		int isBitmap;
		int bitmapWidth, bitmapHeight;
		BOOL useBitmapRes;
		int type;
		int objType;

		int zoomext;
		int lockSelected;
		int mirror;
		int hide;
		int freeze;
		int incSelected;
		int falloff;
		int falloffSpace;
		BOOL showMap;

		BOOL updateCache;

		static COLORREF lineColor, selColor;
		static float weldThreshold;
		static BOOL update;
		static int showVerts;
		static int midPixelSnap;

	
//		int CurrentTVMap;
//		Tab<UVW_ChannelClass*> TVMaps;
		UVW_ChannelClass TVMaps;

//planar gizmo stuff
		Point3 gOffset;
		Point3 gScale;
		float gRotate;
		Matrix3 PlanarTM;
		int GizmoSelected;
		Tab<UVW_TVFaceClass> gfaces;
		VertexLookUpListClass gverts;
		void ApplyGizmo();
		void ComputeSelectedFaceData();
	
//filter stuff
		int filterSelectedFaces;
		int matid;
		int alignDir;
		void BuildMatIDList();
		int IsFaceVisible(int i);
		int IsVertVisible(int i);
		Tab<int> filterMatID;
		BitArray vertMatIDList;
		void SetMatFilters();
	

		static HWND hParams, hWnd, hView;
		static IObjParam  *ip;
		static UnwrapMod *editMod;
		static ICustToolbar *iTool;
		static ICustToolbar *iVertex;
		static ICustToolbar *iView;
		static ICustToolbar *iOption;
		static ICustToolbar *iFilter;
        static ICustButton *iApplyButton;

		HWND hTextures;
		HWND hMatIDs;

		static ICustButton *iMove, *iRot, *iScale,*iMirror, *iPan, *iZoom,*iFalloff ;
		static ICustButton *iZoomReg, *iZoomExt, *iUVW, *iProp, *iShowMap, *iUpdate;
		static ICustButton *iSnap,*iWeld,*iLockSelected,*iFilterSelected;
		static ICustButton *iHide,*iFreeze;
		static ICustButton *iIncSelected;
		static ICustButton *iFalloffSpace;

		static ICustButton *iWeldSelected, *iBreak;


		static ISpinnerControl *iU, *iV, *iW;
		static ISpinnerControl *iStr;
		static ISpinnerControl *iMapID;

		static MouseManager mouseMan;
		static IOffScreenBuf *iBuf;
		static int mode;
		static int oldMode;
		static MoveMode *moveMode;
		static RotateMode *rotMode;
		static ScaleMode *scaleMode;
		static PanMode *panMode;
		static ZoomMode *zoomMode;
		static ZoomRegMode *zoomRegMode;
		static WeldMode *weldMode;



		static RightMouseMode *rightMode;
		static MiddleMouseMode *middleMode;


		static SelectModBoxCMode *selectMode;

/*		static MoveModBoxCMode *gmoveMode;
		static RotateModBoxCMode *grotMode;
		static UScaleModBoxCMode *guscaleMode;
		static NUScaleModBoxCMode *gnuscaleMode;
		static SquashModBoxCMode *gsquashMode;		

		static UnwrapFaceAlignMode *faceAlignMode;
		static UnwrapRegionFitMode *regionFitMode;
*/
		// From MappingMod
		void EnterNormalAlign();
		void ExitNormalAlign();
		void EnterRegionFit();
		void ExitRegionFit();
		int axis;
		int GetAxis();


		static BOOL viewValid, typeInsValid;

		Point2 center;
		int centeron;
		Matrix3 InverseTM;
		Point3 cdebug;


		UnwrapMod();
		~UnwrapMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) {s=UNWRAP_NAME;}
		virtual Class_ID ClassID() {return UNWRAP_CLASSID;}
		void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);		
		TCHAR *GetObjectName() { return UNWRAP_NAME; }
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		BOOL AssignController(Animatable *control,int subAnim);

		ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO|PART_SELECT|PART_SUBSEL_TYPE|PART_VERTCOLOR;}
		ChannelMask ChannelsChanged() {return TEXMAP_CHANNEL|PART_VERTCOLOR; }		
//		Class_ID InputType() {return triObjectClassID;}
		Class_ID InputType() {return mapObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);		

		int NumRefs() {
						int ct = 0;
						ct += TVMaps.cont.Count();
						return ct+11;
						}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		int RemapRefOnLoad(int iref) ;

		// From BaseObject
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flagst, ModContext *mc);
		Box3 BuildBoundVolume(Object *obj);


		void InitControl(TimeValue t);
/*		void Move(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
		void Rotate(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE);
		void Scale(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
*/
		Matrix3 CompMatrix(TimeValue t,ModContext *mc, Matrix3 *ntm,BOOL applySize=TRUE, BOOL applyAxis=TRUE);
		void DoIcon(PolyLineProc& lp,BOOL sel);
		void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);
		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		void ActivateSubobjSel(int level, XFormModes& modes);
		void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE);
//		void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE);
		void ClearSelection(int selLevel);
//		void SelectAll(int selLevel);
//		void InvertSelection(int selLevel);


		int NumSubs() {
						int ct = 0;
						ct += TVMaps.cont.Count();

						return ct;
//						return cont.Count();
						}

		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// From TimeChangeCallback
		void TimeChanged(TimeValue t) {InvalidateView();}

		// Local methods
		void EditMapping(HWND hWnd);
//		void SynchWithMesh(Mesh &mesh);

		// Floater win methods
		void SetupDlg(HWND hWnd);
		void SizeDlg();
		void DestroyDlg();
		void PaintView();		
		void RegisterClasses();
		Point2 UVWToScreen(Point3 pt, float xzoom, float yzoom,int w,int h);
		void ComputeZooms(HWND hWnd, float &xzoom, float &yzoom,int &width,int &height);
		void SetMode(int m);
		void InvalidateView();
		BOOL HitTest(Rect rect,Tab<int> &hits,BOOL selOnly);
		void Select(Tab<int> &hits,BOOL toggle,BOOL subtract,BOOL all);
		void ClearSelect();
		void HoldPoints();
		void HoldPointsAndFaces();
		void HoldSelection();
		void MovePoints(Point2 pt);
		void MoveGizmo(Point2 pt);
		void RotatePoints(HWND h, float ang);
		void RotateGizmo(HWND h, float ang);
		void ScalePoints(HWND h, float scale, int direction);
		void ScaleGizmo(HWND h, float scale, int direction);
		void MirrorPoints(HWND h, int direction);
		void MirrorGizmo(HWND h, int direction);
		void AlignMap();
		void PickMap();
		void SetupImage();
		void GetUVWIndices(int &i1, int &i2);
		void PropDialog();
		void PlugControllers();
		Point3 GetPoint(TimeValue t,int i);
//		Point3 GetObjectPoint(TimeValue t,int i);

		Tab<Point3> objectPointList;
		Point3 GetObjectPoint(TimeValue t,int i);
		void BuildObjectPoints();

		void ZoomExtents();
		void Reset();
		void SetupChannelButtons();
		void SetupTypeins();
		void InvalidateTypeins();
		void TypeInChanged(int which);

		void SnapPoint( Point3 &p);
		void BreakSelected();
		void WeldSelected();
		BOOL WeldPoints(HWND h, IPoint2 m);

		void HideSelected();
		void UnHideAll();

		void FreezeSelected();
		void UnFreezeAll();

		void ZoomSelected();

		void DeleteSelected();

		Tab<int> ActiveAddFaces;
		void AddFaces(BitArray sel, Mesh *mesh);
		void ExpandFaces(BitArray sel, Mesh *mesh);
		void AddFaces(BitArray sel, PatchMesh *patch);
		void ExpandFaces(BitArray sel, PatchMesh *patch);
		void DeleteVertsFromFace(Tab<UVW_TVFaceClass> f);
		void DeleteVertsFromFace(BitArray f);

		void UpdateFaceSelection(BitArray f);
		int IsSelected(int index);

		void ExpandSelection(int dir);

		void RebuildDistCache();
		void ComputeFalloff(float &u, int ftype);

		void LoadUVW(HWND hWnd);
		void SaveUVW(HWND hWnd);
		void TrackRBMenu(HWND hwnd, int x, int y);


		Tab<TSTR*> namedSel;		
		Tab<DWORD> ids;
		BOOL SupportsNamedSubSels() {return TRUE;}
		void ActivateSubSelSet(TSTR &setName);
		void NewSetFromCurSel(TSTR &setName);
		void RemoveSubSelSet(TSTR &setName);
		void SetupNamedSelDropDown();
		int NumNamedSelSets();
		TSTR GetNamedSelSetName(int i);
		void SetNamedSelSetName(int i,TSTR &newName);
		void NewSetByOperator(TSTR &newName,Tab<int> &sets,int op);

	// Local methods for handling named selection sets
		int FindSet(TSTR &setName);		
		DWORD AddSet(TSTR &setName);
		void RemoveSet(TSTR &setName);
		void ClearSetNames();

		void LocalDataChanged();
		IOResult LoadNamedSelChunk(ILoad *iload);
		IOResult SaveLocalData(ISave *isave, LocalModData *ld);
		IOResult LoadLocalData(ILoad *iload, LocalModData **pld);
		void SetNumSelLabel();		
		void BuildInitialMapping(Mesh *msh);
		void BuildInitialMapping(PatchMesh *msh);

		void RemoveDeadVerts(PatchMesh *mesh,int CurrentChannel);
		int IsSelectedSetup();
		BitArray isSelected;

//watje 10-19-99 213458
		BOOL DependOnTopology(ModContext &mc) {return TRUE;}
};

class UnwrapFaceAlignMouseProc : public MouseCallBack {
	public:
		UnwrapMod *mod;
		IObjParam *ip;
		UnwrapFaceAlignMouseProc(UnwrapMod *m,IObjParam *i) {mod=m;ip=i;}
		int proc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
		void FaceAlignMap(HWND hWnd,IPoint2 m);
	};
class UnwrapFaceAlignMode : public CommandMode {
	public:
		ChangeFGObject fgProc;
		UnwrapFaceAlignMouseProc proc;
		IObjParam *ip;
		UnwrapMod *mod;

		UnwrapFaceAlignMode(UnwrapMod *m,IObjParam *i) 
			: fgProc(m), proc(m,i) {ip=i;mod=m;}

		int Class() {return MOVE_COMMAND;}		
		int ID() {return CID_FACEALIGNMAP;}
		MouseCallBack *MouseProc(int *numPoints) {*numPoints=2;return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
		BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc() != &fgProc;}
		void EnterMode();
		void ExitMode();
	};




HCURSOR MoveMode::GetXFormCur()
	{		
	if (mod->move==1)
		return moveXCur;
	else if (mod->move==2) return moveYCur;
	return moveCur;
	}

HCURSOR ScaleMode::GetXFormCur()
	{		
	if (mod->scale==1)
		return scaleXCur;
	else if (mod->scale==2) return scaleYCur;
	return scaleCur;

	}


class UnwrapRightMenu : public RightClickMenu {
	private:
		UnwrapMod *ep;
	public:
		void Init(RightClickMenuManager* manager, HWND hWnd, IPoint2 m);
		void Selected(UINT id);
		void SetMod(UnwrapMod *ep) { this->ep = ep; }
	};



void UnwrapRightMenu::Init(RightClickMenuManager* manager, HWND hWnd, IPoint2 m) {
		
		int flags1,flags2,flags3,flags4,flags5,flags6;

		flags1 = flags2 = flags3 = flags4 = flags5 = flags6 = MF_STRING | MF_UNCHECKED;


		
		manager->AddMenu(this, MF_SEPARATOR, 0, NULL);
		manager->AddMenu(this, flags1, 0, GetString(IDS_PW_FACEMODE));
		manager->AddMenu(this, flags6, 5, GetString(IDS_PW_APPLYPLANAR));

		}
	

void UnwrapRightMenu::Selected(UINT id) {
//  Add Cross Section
	if (id ==  0)
		ep->ip->SetSubObjectLevel(1);	
	else if (id == 5)
		{
		SendMessage(ep->hParams,WM_COMMAND,IDC_UNWRAP_APPLY,0);

		}

	}

UnwrapRightMenu rMenu;



class UnwrapRegionFitMouseProc : public MouseCallBack {
	public:
		UnwrapMod *mod;
		IObjParam *ip;
		IPoint2 om;
		UnwrapRegionFitMouseProc(UnwrapMod *m,IObjParam *i) {mod=m;ip=i;}
		int proc(HWND hWnd, int msg, int point, int flags, IPoint2 m);
		void RegionFitMap(HWND hWnd,IPoint2 m);
	};

class UnwrapRegionFitMode : public CommandMode {
	public:
		ChangeFGObject fgProc;
		UnwrapRegionFitMouseProc proc;
		IObjParam *ip;
		UnwrapMod *mod;

		UnwrapRegionFitMode(UnwrapMod *m,IObjParam *i) 
			: fgProc(m), proc(m,i) {ip=i;mod=m;}

		int Class() {return MOVE_COMMAND;}		
		int ID() {return CID_REGIONFIT;}
		MouseCallBack *MouseProc(int *numPoints) {*numPoints=2;return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
		BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc() != &fgProc;}
		void EnterMode();
		void ExitMode();
	};


class UVWUnwrapDeleteEvent : public EventUser {
public:
	UnwrapMod *m;

	void Notify() {if (m) 
						{
						m->DeleteSelected();
						m->InvalidateView();

						}
					}
	void SetEditMeshMod(UnwrapMod *im) {m=im;}
};

UVWUnwrapDeleteEvent delEvent;

class MeshTopoData : public LocalModData {
public:
	Mesh *mesh;
	PatchMesh *patch;
	BitArray faceSel;
	GenericNamedSelSetList fselSet;

	MeshTopoData(Mesh &mesh);
	MeshTopoData(PatchMesh &patch);
	MeshTopoData() { mesh=NULL; patch = NULL; }
	~MeshTopoData() { FreeCache(); }
	LocalModData *Clone();

	Mesh *GetMesh() {return mesh;}
	PatchMesh *GetPatch() {return patch;}
	void SetCache(Mesh &mesh);
	void SetCache(PatchMesh &patch);
	void FreeCache();

	BitArray &GetFaceSel() { return faceSel; }
	void SetFaceSel(BitArray &set, UnwrapMod *imod, TimeValue t);

};

LocalModData *MeshTopoData::Clone() {
	MeshTopoData *d = new MeshTopoData;
	mesh = NULL;
	patch = NULL;
	return d;
	}

MeshTopoData::MeshTopoData(Mesh &mesh) {
	this->mesh = new Mesh(mesh);
	this->patch = NULL;
}

MeshTopoData::MeshTopoData(PatchMesh &patch) {
	this->mesh = NULL;
	this->patch = new PatchMesh(patch);
}

void MeshTopoData::SetCache(Mesh &mesh)
	{
	if (this->mesh) delete this->mesh;
	this->mesh = new Mesh(mesh);
	}

void MeshTopoData::SetCache(PatchMesh &patch)
	{
	if (this->patch) delete this->patch;
	this->patch = new PatchMesh(patch);
	}

void MeshTopoData::FreeCache() {
	if (mesh) delete mesh;
	mesh = NULL;
	if (patch) delete patch;
	patch = NULL;
}

void MeshTopoData::SetFaceSel(BitArray &set, UnwrapMod *imod, TimeValue t) {
	UnwrapMod *mod = (UnwrapMod *) imod;
	faceSel = set;
	if (mesh) mesh->faceSel = set;
	if (patch) patch->patchSel = set;
}




class UnwrapClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new UnwrapMod;}
	const TCHAR *	ClassName() {return UNWRAP_NAME;}
	SClass_ID		SuperClassID() {return OSM_CLASS_ID;}
	Class_ID		ClassID() {return UNWRAP_CLASSID;}
	const TCHAR* 	Category() {return GetString(IDS_RB_DEFSURFACE);}
	};

static UnwrapClassDesc unwrapDesc;
ClassDesc* GetUnwrapModDesc() {return &unwrapDesc;}

#define ID_TOOL_MOVE	0x0100
#define ID_TOOL_ROTATE	0x0110
#define ID_TOOL_SCALE	0x0120
#define ID_TOOL_PAN		0x0130
#define ID_TOOL_ZOOM    0x0140
#define ID_TOOL_PICKMAP	0x0160
#define ID_TOOL_ZOOMREG 0x0170
#define ID_TOOL_UVW		0x0200
#define ID_TOOL_PROP	0x0210 
#define ID_TOOL_SHOWMAP	0x0220
#define ID_TOOL_UPDATE	0x0230
#define ID_TOOL_ZOOMEXT	0x0240
#define ID_TOOL_BREAK	0x0250
#define ID_TOOL_WELD	0x0260
#define ID_TOOL_WELD_SEL 0x0270
#define ID_TOOL_HIDE	 0x0280
#define ID_TOOL_UNHIDE	 0x0290
#define ID_TOOL_FREEZE	 0x0300
#define ID_TOOL_UNFREEZE	 0x0310
#define ID_TOOL_TEXTURE_COMBO 0x0320
#define ID_TOOL_SNAP 0x0330
#define ID_TOOL_LOCKSELECTED 0x0340
#define ID_TOOL_MIRROR 0x0350
#define ID_TOOL_FILTER_SELECTEDFACES 0x0360
#define ID_TOOL_FILTER_MATID 0x0370
#define ID_TOOL_INCSELECTED 0x0380
#define ID_TOOL_FALLOFF 0x0390
#define ID_TOOL_FALLOFF_SPACE 0x0400




HWND            UnwrapMod::hParams = NULL;
HWND            UnwrapMod::hWnd = NULL;
HWND            UnwrapMod::hView = NULL;
IObjParam      *UnwrapMod::ip = NULL;
ICustToolbar   *UnwrapMod::iTool = NULL;
ICustToolbar   *UnwrapMod::iVertex = NULL;
ICustToolbar   *UnwrapMod::iView = NULL;
ICustToolbar   *UnwrapMod::iOption = NULL;
ICustToolbar   *UnwrapMod::iFilter = NULL;
ICustButton    *UnwrapMod::iMove = NULL;
ICustButton    *UnwrapMod::iRot = NULL;
ICustButton    *UnwrapMod::iScale = NULL;
ICustButton    *UnwrapMod::iFalloff = NULL;
ICustButton    *UnwrapMod::iFalloffSpace = NULL;

ICustButton    *UnwrapMod::iMirror = NULL;
ICustButton    *UnwrapMod::iWeld = NULL;
ICustButton    *UnwrapMod::iPan = NULL;
ICustButton    *UnwrapMod::iZoom = NULL;
ICustButton    *UnwrapMod::iUpdate = NULL;
ISpinnerControl *UnwrapMod::iU = NULL;
ISpinnerControl *UnwrapMod::iV = NULL;
ISpinnerControl *UnwrapMod::iW = NULL;
ISpinnerControl *UnwrapMod::iStr = NULL;
ISpinnerControl *UnwrapMod::iMapID = NULL;
MouseManager    UnwrapMod::mouseMan;
IOffScreenBuf  *UnwrapMod::iBuf = NULL;
int             UnwrapMod::mode = ID_TOOL_MOVE;
int             UnwrapMod::oldMode = ID_TOOL_MOVE;
 
MoveMode       *UnwrapMod::moveMode = NULL;
RotateMode     *UnwrapMod::rotMode = NULL;
ScaleMode      *UnwrapMod::scaleMode = NULL;
PanMode        *UnwrapMod::panMode = NULL;
ZoomMode       *UnwrapMod::zoomMode = NULL;
ZoomRegMode    *UnwrapMod::zoomRegMode = NULL;
WeldMode       *UnwrapMod::weldMode = NULL;
RightMouseMode *UnwrapMod::rightMode = NULL;
MiddleMouseMode *UnwrapMod::middleMode = NULL;
BOOL            UnwrapMod::viewValid = FALSE;
BOOL            UnwrapMod::typeInsValid = FALSE;
UnwrapMod      *UnwrapMod::editMod = NULL;
ICustButton    *UnwrapMod::iZoomReg = NULL;
ICustButton    *UnwrapMod::iZoomExt = NULL;
ICustButton    *UnwrapMod::iUVW = NULL;
ICustButton    *UnwrapMod::iProp = NULL;
ICustButton    *UnwrapMod::iShowMap = NULL;
ICustButton    *UnwrapMod::iLockSelected = NULL;
ICustButton    *UnwrapMod::iFilterSelected = NULL;
ICustButton    *UnwrapMod::iHide = NULL;
ICustButton    *UnwrapMod::iFreeze = NULL;
ICustButton    *UnwrapMod::iIncSelected = NULL;
ICustButton    *UnwrapMod::iSnap = NULL;

ICustButton    *UnwrapMod::iBreak = NULL;
ICustButton    *UnwrapMod::iWeldSelected = NULL;



SelectModBoxCMode *UnwrapMod::selectMode      = NULL;
/*
MoveModBoxCMode*    UnwrapMod::gmoveMode      = NULL;
RotateModBoxCMode*  UnwrapMod::grotMode       = NULL;
UScaleModBoxCMode*  UnwrapMod::guscaleMode    = NULL;
NUScaleModBoxCMode* UnwrapMod::gnuscaleMode   = NULL;
SquashModBoxCMode*  UnwrapMod::gsquashMode    = NULL;
UnwrapFaceAlignMode*      UnwrapMod::faceAlignMode = NULL;
UnwrapRegionFitMode*      UnwrapMod::regionFitMode = NULL;
*/
//ICustButton*			  UnwrapMod::iAlignButton  = NULL;
ICustButton*			  UnwrapMod::iApplyButton  = NULL;
//ICustButton*			  UnwrapMod::iFitButton  = NULL;
int						  UnwrapMod::CurrentMap = 0;
COLORREF UnwrapMod::lineColor = RGB(255,255,255);
COLORREF UnwrapMod::selColor  = RGB(255,0,0);
float UnwrapMod::weldThreshold = 0.01f;
BOOL UnwrapMod::update = TRUE;
int UnwrapMod::showVerts = 1;
int UnwrapMod::midPixelSnap = 0;

static BOOL CALLBACK UnwrapFloaterDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

class TVertRestore : public RestoreObj {
	public:
		UnwrapMod *mod;
		Tab<UVW_TVVertClass> undo, redo;
		BitArray uvsel, rvsel;

		TVertRestore(UnwrapMod *m) {
			mod = m;
//			undo = mod->tvert;
			undo = mod->TVMaps.v;
			uvsel   = mod->vsel;

			}
		void Restore(int isUndo) {
			if (isUndo) {
//				redo = mod->tvert;
				redo = mod->TVMaps.v;
				rvsel   = mod->vsel;

				}
//			mod->tvert = undo;
			mod->TVMaps.v = undo;
			mod->vsel = uvsel;

			mod->NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
			if (mod->editMod==mod && mod->hView) mod->InvalidateView();
			}
		void Redo() {
			mod->TVMaps.v = redo;
			mod->vsel = rvsel;
			mod->NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
			if (mod->editMod==mod && mod->hView) mod->InvalidateView();
			}
		void EndHold() {mod->ClearAFlag(A_HELD);}
		TSTR Description() {return TSTR(_T(GetString(IDS_PW_UVW_VERT_EDIT)));
		}
		
	};

class TVertAndTFaceRestore : public RestoreObj {
	public:
		UnwrapMod *mod;
		Tab<UVW_TVVertClass> undo, redo;
		Tab<UVW_TVFaceClass> fundo, fredo;
		BitArray uvsel, rvsel;



		TVertAndTFaceRestore(UnwrapMod *m) {
			mod = m;
//			undo = mod->tvert;
			undo = mod->TVMaps.v;
			fundo = mod->TVMaps.f;
			uvsel   = mod->vsel;
			}
		void Restore(int isUndo) {
			if (isUndo) {
//				redo = mod->tvert;
				redo = mod->TVMaps.v;
				fredo = mod->TVMaps.f;
				rvsel   = mod->vsel;
				}
//			mod->tvert = undo;
			mod->TVMaps.v = undo;
			mod->TVMaps.f = fundo;
			mod->vsel = uvsel;
			mod->NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
			if (mod->editMod==mod && mod->hView) mod->InvalidateView();
			}
		void Redo() {
			mod->TVMaps.v = redo;
			mod->TVMaps.f = fredo;
			mod->vsel = rvsel;

			mod->NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
			if (mod->editMod==mod && mod->hView) mod->InvalidateView();
			}
		void EndHold() {mod->ClearAFlag(A_HELD);}
		TSTR Description() {return TSTR(_T(GetString(IDS_PW_UVW_EDIT)));}
	};


class TSelRestore : public RestoreObj {
	public:
		UnwrapMod *mod;
		BitArray undo, redo;

		TSelRestore(UnwrapMod *m) {
			mod = m;
			undo = mod->vsel;
			}
		void Restore(int isUndo) {
			if (isUndo) {
				redo = mod->vsel;

				}
			mod->vsel = undo;
			if (mod->editMod==mod && mod->hView) mod->InvalidateView();
			}
		void Redo() {
			mod->vsel = redo;
			if (mod->editMod==mod && mod->hView) mod->InvalidateView();
			}
		void EndHold() {mod->ClearAFlag(A_HELD);}
		TSTR Description() {return TSTR(_T(GetString(IDS_PW_SELECT_UVW)));}
	};	

class ResetRestore : public RestoreObj {
	public:
		UnwrapMod *mod;
/*
		Tab<UVW_TVVertClass> utvert, rtvert;
		Tab<UVW_TVFaceClass> utvFace, rtvFace;
		Tab<Control*> ucont, rcont;
*/
		UVW_ChannelClass undoTVMaps,redoTVMaps;
		BitArray uvsel, rvsel;
		int uchan, rchan;
		

		ResetRestore(UnwrapMod *m) {
			mod     = m;
//			utvert  = mod->tvert;
//			utvFace = mod->tvFace;
//			ucont   = mod->cont;
			undoTVMaps = mod->TVMaps;
			uvsel   = mod->vsel;
			uchan   = mod->channel;
			}
		void Restore(int isUndo) {
			if (isUndo) {
				redoTVMaps = mod->TVMaps;
//				rtvert  = mod->tvert;
//				rtvFace = mod->tvFace;
//				rcont   = mod->cont;
				rvsel   = mod->vsel;
				rchan   = mod->channel;
				}
//			mod->tvert   = utvert;
//			mod->tvFace  = utvFace;
//			mod->cont   = ucont;
			mod->TVMaps = undoTVMaps;
			mod->vsel    = uvsel;
			mod->channel = uchan;
			if (mod->editMod==mod && mod->hView) mod->InvalidateView();
			mod->SetupChannelButtons();
			}
		void Redo() {
//			mod->tvert   = rtvert;
//			mod->tvFace  = rtvFace;
//			mod->cont   = rcont;
			mod->TVMaps = redoTVMaps;
			mod->vsel    = rvsel;
			mod->channel = rchan;
			if (mod->editMod==mod && mod->hView) mod->InvalidateView();
			mod->SetupChannelButtons();
			}		
		TSTR Description() {return TSTR(_T(GetString(IDS_PW_RESET_UNWRAP)));
		}
	};

// MeshSelRestore --------------------------------------------------
class UnwrapSelRestore : public RestoreObj {
public:
	BitArray usel, rsel;
	BitArray *sel;
	UnwrapMod *mod;
	MeshTopoData *d;
//	int level;

	UnwrapSelRestore(UnwrapMod *m, MeshTopoData *d);
	UnwrapSelRestore(UnwrapMod *m, MeshTopoData *d, int level);
	void Restore(int isUndo);
	void Redo();
	int Size() { return 1; }
	void EndHold() {
//		d->held=FALSE;
	}
	TSTR Description() { return TSTR(_T(GetString(IDS_PW_SELECTRESTORE))); 
	}
};


UnwrapSelRestore::UnwrapSelRestore(UnwrapMod *m, MeshTopoData *data) {
	mod     = m;
	d       = data;
//	d->held = TRUE;
//	usel = d->faceSel;
	usel.SetSize(mod->TVMaps.f.Count());
	usel.ClearAll();
	for (int i =0; i < usel.GetSize();i++)
		{
		if (mod->TVMaps.f[i].flags & FLAG_SELECTED)
			usel.Set(i);
		}

	
}

UnwrapSelRestore::UnwrapSelRestore(UnwrapMod *m, MeshTopoData *data, int sLevel) 
{
	mod     = m;
//	level   = sLevel;
	d       = data;
//	d->held = TRUE;
	usel = d->faceSel;
	
}

void UnwrapSelRestore::Restore(int isUndo) {
	if (isUndo) {
		rsel = d->faceSel;
		}
	
	d->faceSel = usel; 
	mod->UpdateFaceSelection(d->faceSel);
	mod->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	mod->InvalidateView();
//	mod->SetNumSelLabel();
}

void UnwrapSelRestore::Redo() {
	d->faceSel = rsel;
	mod->UpdateFaceSelection(d->faceSel);
	mod->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	mod->InvalidateView();
	}


//--- UnwrapMod methods -----------------------------------------------

UnwrapMod::UnwrapMod()
	{
	move    = 0;
	zoom    = 0.9f;
	aspect	= 1.0f;
	xscroll = 0.0f;
	yscroll = 0.0f;
	for (int i =0;i<10;i++)
		map[i] = NULL;
	image = NULL;
	iw = ih = 0;
	uvw = 0;
	scale =0;
	zoomext =0;
	showMap = TRUE;	
	rendW = 256;
	rendH = 256;
	channel = 0;
//	CurrentMap = 0;
	isBitmap = 0;
	useBitmapRes = TRUE;
	pixelSnap =0;
	tmControl = NULL;
	offsetControl = NULL;
	scaleControl = NULL;
	rotateControl = NULL;
	TVMaps.v.ZeroCount();
	TVMaps.f.ZeroCount();
	flags = CONTROL_CENTER|CONTROL_FIT|CONTROL_INIT;
	PlanarTM.IdentityMatrix();	
	gScale.x = 0.25f;
	gScale.y = 0.25f;
	gScale.z = 0.0f;
	gOffset.x =0.5f;
	gOffset.y =0.5f;
	gOffset.z =0.5f;
	version = 2;
	lockSelected = 0;
	mirror = 0;
	filterSelectedFaces = 0;
	hide = 0;
	freeze = 0;
	incSelected = 0;
	falloff = 0;
	falloffSpace = 0;
	alignDir = 3;
	oldDataPresent = FALSE;
	firstPass = FALSE;
	type = MAP_PLANAR;

	updateCache = FALSE;
	instanced = FALSE;


//	lineColor = RGB(255,255,255);
//	selColor  = RGB(255,0,0);
//	weldThreshold = 0.01f;
//	update = TRUE;
//	showVerts = 1;
//	midPixelSnap = 0;
	}

UnwrapMod::~UnwrapMod()
	{
	DeleteAllRefsFromMe();
	}

static BOOL CALLBACK UnwrapRollupWndProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	UnwrapMod *mod = (UnwrapMod*)GetWindowLong(hWnd,GWL_USERDATA);
	
	static BOOL inEnter = FALSE;

	switch (msg) {
		case WM_INITDIALOG:
			mod = (UnwrapMod*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mod->hParams = hWnd;
			
			mod->iApplyButton = GetICustButton(GetDlgItem(hWnd, IDC_UNWRAP_APPLY));
			mod->iApplyButton->SetType(CBT_PUSH);
			mod->iApplyButton->SetHighlightColor(GREEN_WASH);
			mod->iApplyButton->Enable(TRUE);

			mod->iMapID = GetISpinner(GetDlgItem(hWnd,IDC_MAP_CHAN_SPIN));
			mod->iMapID->LinkToEdit(GetDlgItem(hWnd,IDC_MAP_CHAN),EDITTYPE_INT);
			mod->iMapID->SetLimits(1, 99, FALSE);
			mod->iMapID->SetAutoScale();	

			mod->SetupChannelButtons();
			mod->ip->GetRightClickMenuManager()->Register(&rMenu);


			CheckDlgButton(hWnd,IDC_RADIO4,TRUE);
			mod->alignDir = 3;

			break;


		case WM_CUSTEDIT_ENTER:
				{
				if (!inEnter)
					{
					inEnter = TRUE;
					TSTR buf1 = GetString(IDS_RB_SHOULDRESET);
					TSTR buf2 = GetString(IDS_RB_UNWRAPMOD);
					int tempChannel = mod->iMapID->GetIVal();
					if (tempChannel == 1) tempChannel = 0;
					if (tempChannel != mod->channel)
						{
						int res = MessageBox(mod->ip->GetMAXHWnd(),buf1,buf2,MB_YESNO|MB_ICONQUESTION|MB_TASKMODAL);
						if (res==IDYES)
							{
							theHold.Begin();
							mod->Reset();
							mod->channel = mod->iMapID->GetIVal();
							if (mod->channel == 1) mod->channel = 0;
							theHold.Accept(GetString(IDS_RB_SETCHANNEL));					
							mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
							mod->ip->RedrawViews(mod->ip->GetTime());
							mod->InvalidateView();
							}
						else mod->SetupChannelButtons();
						}
					inEnter = FALSE;

					}

				}

			break;
		case CC_SPINNER_BUTTONUP:
				{
				TSTR buf1 = GetString(IDS_RB_SHOULDRESET);
				TSTR buf2 = GetString(IDS_RB_UNWRAPMOD);
				int tempChannel = mod->iMapID->GetIVal();
				if (tempChannel == 1) tempChannel = 0;
				if (tempChannel != mod->channel)
					{
					int res = MessageBox(mod->ip->GetMAXHWnd(),buf1,buf2,MB_YESNO|MB_ICONQUESTION|MB_TASKMODAL);
					if (res==IDYES)
						{
						theHold.Begin();
						mod->Reset();
						mod->channel = mod->iMapID->GetIVal();
						if (mod->channel == 1) mod->channel = 0;
						theHold.Accept(GetString(IDS_RB_SETCHANNEL));					
						mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
						mod->ip->RedrawViews(mod->ip->GetTime());
						mod->InvalidateView();
						}
					else mod->SetupChannelButtons();
					}

				}

			break;


		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_UNWRAP_SAVE:
					DragAcceptFiles(mod->ip->GetMAXHWnd(), FALSE);
					mod->SaveUVW(hWnd);
					DragAcceptFiles(mod->ip->GetMAXHWnd(), TRUE);
					break;
				case IDC_UNWRAP_LOAD:
					DragAcceptFiles(mod->ip->GetMAXHWnd(), FALSE);
					mod->LoadUVW(hWnd);
					DragAcceptFiles(mod->ip->GetMAXHWnd(), TRUE);
					mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mod->ip->RedrawViews(mod->ip->GetTime());
					break;

				case IDC_RADIO1: 
					if (IsDlgButtonChecked(hWnd,IDC_RADIO1)) mod->alignDir = 0;
					mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mod->ip->RedrawViews(mod->ip->GetTime());
					mod->InvalidateView();
					break;
				case IDC_RADIO2:
					if (IsDlgButtonChecked(hWnd,IDC_RADIO2)) mod->alignDir = 1;
					mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mod->ip->RedrawViews(mod->ip->GetTime());
					mod->InvalidateView();
					break;
				case IDC_RADIO3:
					if (IsDlgButtonChecked(hWnd,IDC_RADIO3)) mod->alignDir = 2;
					mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mod->ip->RedrawViews(mod->ip->GetTime());
					mod->InvalidateView();
					break;

				case IDC_RADIO4:
					if (IsDlgButtonChecked(hWnd,IDC_RADIO4)) mod->alignDir = 3;
					mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mod->ip->RedrawViews(mod->ip->GetTime());
					mod->InvalidateView();

					break;

				case IDC_MAP_CHAN1:
				case IDC_MAP_CHAN2: {
					TSTR buf1 = GetString(IDS_RB_SHOULDRESET);
					TSTR buf2 = GetString(IDS_RB_UNWRAPMOD);
					int res = MessageBox(mod->ip->GetMAXHWnd(),buf1,buf2,MB_YESNO|MB_ICONQUESTION|MB_TASKMODAL);
					if (res==IDYES)
						{
						theHold.Begin();
						mod->Reset();
						mod->channel = IsDlgButtonChecked(hWnd,IDC_MAP_CHAN2);
						if (mod->channel == 1)
							mod->iMapID->Enable(FALSE);
						else 
							{
							int ival = mod->iMapID->GetIVal();
							if (ival == 1) mod->channel = 0;
							  else mod->channel = ival;
							mod->iMapID->Enable(TRUE);
							}
						mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
						mod->ip->RedrawViews(mod->ip->GetTime());
						mod->InvalidateView();

						theHold.Accept(GetString(IDS_RB_SETCHANNEL));					
						}
					else mod->SetupChannelButtons();

					break;
					}

				case IDC_UNWRAP_RESET: {
					TSTR buf1 = GetString(IDS_RB_RESETUNWRAPUVWS);
					TSTR buf2 = GetString(IDS_RB_UNWRAPMOD);
					if (IDYES==MessageBox(mod->ip->GetMAXHWnd(),buf1,buf2,MB_YESNO|MB_ICONQUESTION|MB_TASKMODAL)) {
						theHold.Begin();
						mod->Reset();
						theHold.Accept(GetString(IDS_RB_RESETUVWS));
						mod->ip->RedrawViews(mod->ip->GetTime());
						mod->InvalidateView();

						}
					break;
					}

				case IDC_UNWRAP_APPLY:
					{
//align to normals
					mod->AlignMap();
//call fit

					mod->flags |= CONTROL_FIT|CONTROL_CENTER|CONTROL_HOLD;
					mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mod->ip->RedrawViews(mod->ip->GetTime());
					mod->ApplyGizmo();					
					mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mod->ip->RedrawViews(mod->ip->GetTime());


					break;
					}
				case IDC_UNWRAP_EDIT:
					mod->EditMapping(hWnd);
					break;
				case IDC_UNWRAP_FIT:
//					mod->flags |= CONTROL_FIT|CONTROL_CENTER|CONTROL_HOLD;
//					mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
//					mod->ip->RedrawViews(mod->ip->GetTime());
					break;
				case IDC_UNWRAP_ALIGN_TO_NORMAL:
/*
					if (mod->ip->GetCommandMode()->ID()==CID_FACEALIGNMAP) {
						mod->ip->SetStdCommandMode(CID_OBJMOVE);
					} else {
						mod->ip->SetCommandMode(mod->faceAlignMode);
						}
*/
					break;




				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

void UnwrapMod::SetupChannelButtons()
	{
	if (hParams && editMod==this) {		
		if (channel == 0)
			{
			iMapID->Enable(TRUE);
			iMapID->SetValue(1,TRUE);
			CheckDlgButton(hParams,IDC_MAP_CHAN1,TRUE);
			CheckDlgButton(hParams,IDC_MAP_CHAN2,FALSE);

			}
		else if (channel == 1)
			{
			CheckDlgButton(hParams,IDC_MAP_CHAN1,FALSE);
			CheckDlgButton(hParams,IDC_MAP_CHAN2,TRUE);
			iMapID->Enable(FALSE);
//			iMapID->SetValue(0,TRUE);
			}
		else
			{
			CheckDlgButton(hParams,IDC_MAP_CHAN1,TRUE);
			CheckDlgButton(hParams,IDC_MAP_CHAN2,FALSE);
			iMapID->Enable(TRUE);
			iMapID->SetValue(channel,TRUE);
			}
		}
	}

void UnwrapMod::Reset()
	{
	if (theHold.Holding()) theHold.Put(new ResetRestore(this));

	for (int i=0; i<TVMaps.cont.Count(); i++) DeleteReference(i+11);
	TVMaps.v.Resize(0);
	TVMaps.f.Resize(0);
	TVMaps.cont.Resize(0);
	vsel.SetSize(0);
	updateCache = TRUE;

	NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE,TREE_VIEW_CLASS_ID,FALSE);	
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

BOOL UnwrapMod::AssignController(Animatable *control,int subAnim)
	{
	ReplaceReference(subAnim+11,(RefTargetHandle)control);	
	NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE,TREE_VIEW_CLASS_ID,FALSE);	
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	return TRUE;
	}

void UnwrapMod::BeginEditParams(
		IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	selCur   = ip->GetSysCursor(SYSCUR_SELECT);
	moveCur	 = ip->GetSysCursor(SYSCUR_MOVE);
	
	if (moveXCur == NULL)
		moveXCur	 = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_MOVEX));
	if (moveYCur == NULL)
		moveYCur	 = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_MOVEY));

	if (scaleXCur == NULL)
		scaleXCur	 = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_SCALEX));
	if (scaleYCur == NULL)
		scaleYCur	 = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_SCALEY));

	if (zoomCur == NULL)
		zoomCur	 = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_ZOOM));
	if (zoomRegionCur == NULL)
		zoomRegionCur	 = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_ZOOMREG));
	if (panCur == NULL)
		panCur	 = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_PANHAND));
	if (weldCur == NULL)
		weldCur	 = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_WELDCUR));


	rotCur   = ip->GetSysCursor(SYSCUR_ROTATE);
	scaleCur = ip->GetSysCursor(SYSCUR_USCALE);


	// Add our sub object type
	TSTR type1(GetString(IDS_PW_SELECTFACE));
	TSTR type2 (GetString(IDS_PW_FACEMAP));
	TSTR type3 (GetString(IDS_PW_PLANAR));
	const TCHAR *ptype[] = {type1};
	ip->RegisterSubObjectTypes(ptype, 1);

	selectMode = new SelectModBoxCMode(this,ip);
/*
	gmoveMode      = new MoveModBoxCMode(this,ip);
	grotMode       = new RotateModBoxCMode(this,ip);
	guscaleMode    = new UScaleModBoxCMode(this,ip);
	gnuscaleMode   = new NUScaleModBoxCMode(this,ip);
	gsquashMode    = new SquashModBoxCMode(this,ip);	

	regionFitMode = new UnwrapRegionFitMode(this,ip);
	faceAlignMode = new UnwrapFaceAlignMode(this,ip);
*/

	offsetControl = NewDefaultPoint3Controller();
	Point3 p(0.5f,0.5f,0.0f);
	offsetControl->SetValue(0,&p,CTRL_ABSOLUTE);

	scaleControl = NewDefaultPoint3Controller();
	Point3 sp(0.25f,0.25f,0.0f);
	scaleControl->SetValue(0,&sp,CTRL_ABSOLUTE);

	rotateControl = NewDefaultFloatController();
	float a = 0.0f;
	rotateControl->SetValue(0,&a,CTRL_ABSOLUTE);


	this->ip = ip;
	editMod  = this;
	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);

	hParams  = ip->AddRollupPage( 
		hInstance, 
		MAKEINTRESOURCE(IDD_UNWRAP_PARAMS),
		UnwrapRollupWndProc,
		GetString(IDS_RB_PARAMETERS),
		(LPARAM)this);

	ip->RegisterTimeChangeCallback(this);

	SetNumSelLabel();
	firstPass = TRUE;

	}


void UnwrapMod::EndEditParams(
		IObjParam *ip,ULONG flags,Animatable *next)
	{	
	ClearAFlag(A_MOD_BEING_EDITED);

	ip->UnRegisterTimeChangeCallback(this);
	if (hParams) ip->DeleteRollupPage(hParams);
	hParams  = NULL;	
	if (hWnd) DestroyWindow(hWnd);

/*
	ip->DeleteMode(gmoveMode);
	ip->DeleteMode(grotMode);
	ip->DeleteMode(guscaleMode);
	ip->DeleteMode(gnuscaleMode);
	ip->DeleteMode(gsquashMode);	
	ip->DeleteMode(regionFitMode);
*/

	ip->DeleteMode(selectMode);

	if (selectMode) delete selectMode;
	selectMode = NULL;
/*
	delete gmoveMode; gmoveMode = NULL;
	delete grotMode; grotMode = NULL;
	delete guscaleMode; guscaleMode = NULL;
	delete gnuscaleMode; gnuscaleMode = NULL;
	delete gsquashMode; gsquashMode = NULL;
	delete faceAlignMode; faceAlignMode = NULL;
	delete regionFitMode; regionFitMode = NULL;
*/

//	ReleaseICustButton(iAlignButton);
//	iAlignButton = NULL;

	ReleaseICustButton(iApplyButton);
	iApplyButton = NULL;

//	ReleaseICustButton(iFitButton);
//	iFitButton = NULL;
	ReleaseISpinner(iMapID); iMapID = NULL;

	ip->GetRightClickMenuManager()->Unregister(&rMenu);


	TimeValue t =ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);
	this->ip = NULL;

	editMod  = NULL;
	
	ip->EnableSubObjectSelection(TRUE);


	}




class NullView: public View {
	public:
		Point2 ViewToScreen(Point3 p) { return Point2(p.x,p.y); }
		NullView() { worldToView.IdentityMatrix(); screenW=640.0f; screenH = 480.0f; }
	};

static AdjFaceList *BuildAdjFaceList(Mesh &mesh)
	{
	AdjEdgeList ae(mesh);
	return new AdjFaceList(mesh,ae);
	}


Box3 UnwrapMod::BuildBoundVolume(Object *obj)

{
Box3 b;
b.Init();
if (objType == IS_PATCH)
	{
	PatchObject *pobj = (PatchObject*)obj;
	for (int i = 0; i < pobj->patch.patchSel.GetSize(); i++)
		{
		if (pobj->patch.patchSel[i])
			{
			int pcount = 3;
			if (pobj->patch.patches[i].type == PATCH_QUAD) pcount = 4;
			for (int j = 0; j < pcount; j++)
				{
				int index = pobj->patch.patches[i].v[j];

				b+= pobj->patch.verts[index].p;
				}
			}	
		}

	}	
else if (objType == IS_MESH)
	{
	TriObject *tobj = (TriObject*)obj;
	for (int i = 0; i < tobj->GetMesh().faceSel.GetSize(); i++)
		{
		if (tobj->GetMesh().faceSel[i])
			{
			for (int j = 0; j < 3; j++)
				{
				int index = tobj->GetMesh().faces[i].v[j];

				b+= tobj->GetMesh().verts[index];
				}
			}	
		}
	}
return b;
}


void UnwrapMod::InitControl(TimeValue t)
	{
	Box3 box;
	Matrix3 tm;

	if (tmControl==NULL) {
		MakeRefByID(FOREVER,0,NewDefaultMatrix3Controller()); 
		NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
		}		
	
	if (flags&CONTROL_INIT) {
		SuspendAnimate();
		AnimateOff();		
		// Rotate the seem to the back
		s.x = 100.0f;
		s.y = 100.0f;
		s.z = 100.0f;	

		SetXFormPacket pckt(Quat(RotateZMatrix(0)),TRUE);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		ResumeAnimate();
		}
/*
	if (flags&CONTROL_INITPARAMS) {
		}

	if (!(flags&CONTROL_OP)) {
		flags = 0;
		return;
		}

	if (flags&CONTROL_HOLD) theHold.Begin();	

	Matrix3 oldtm = tm = Inverse(CompMatrix(t,&mc,NULL,FALSE));	
	AffineParts parts;
	decomp_affine(tm, &parts);
	parts.q.MakeMatrix(tm);
	tm.Translate(parts.t);
	
	Matrix3 mctm(1);
	if (mc.tm) mctm = *mc.tm;
	tm.Scale(Point3(
		Length(mctm.GetRow(0)),
		Length(mctm.GetRow(1)),
		Length(mctm.GetRow(2))
		));

	Point3 tp;
	tp  = s;
	box = BuildBoundVolume(obj);
	box = box * tm;
	box.Scale(1.001f);  // prevent wrap-around on sides of boxes

	int type = MAP_PLANAR;

	if (flags&CONTROL_ASPECT &&
		(type==MAP_PLANAR ||
		 type==MAP_BOX ||
		 type==MAP_CYLINDRICAL)) {

		if (type==MAP_PLANAR || type==MAP_BOX) {			
			float w = aspect*tp.y;
			tp.x *= w / tp.x;			
			tp.z *= tp.y / tp.z;				
		} else
		if (type==MAP_CYLINDRICAL) {
			float w = (tp.x+tp.y)*PI;			
			tp.z *= w/(aspect*tp.z);
			}
		}

	if (flags&CONTROL_UNIFORM) {
		float av = (tp.x + tp.y + tp.z)/3.0f;
		tp.x = tp.y = tp.z = av;
		}

	if (flags&CONTROL_FIT) {
		Point3 w = box.Width();
		if (box.IsEmpty()) w = Point3(10.0f,10.0f,10.0f);

		if (type==MAP_PLANAR) {
			tp.x = w.x==0.0f ? 1.0f : w.x;
			tp.y = w.y==0.0f ? 1.0f : w.y;
			tp.z = w.z==0.0f ? 1.0f : w.z;
		} else
		if (type==MAP_BOX) {
			tp.x = w.x==0.0f ? 1.0f : w.x;
			tp.y = w.y==0.0f ? 1.0f : w.y;
			tp.z = w.z==0.0f ? 1.0f : w.z;
		} else
		if (type==MAP_SPHERICAL || type==MAP_BALL) {
			float max = w.x;
			if (w.y>max) max = w.y;
			if (w.z>max) max = w.z;
			if (max==0.0f) max = 1.0f;
			tp.x = tp.y = tp.z = max;
		} else {
			if (w.x>w.y) tp.x = tp.y = w.x;
			else tp.x = tp.y = w.y;
			s.z = w.z;
			if (tp.x==0.0f) tp.x = 1.0f;
			if (tp.y==0.0f) tp.y = 1.0f;
			if (tp.z==0.0f) tp.z = 1.0f;			
			}

		}

	if (flags&(CONTROL_CENTER|CONTROL_FIT)) {		
		
		Box3 sbox;		
//		obj->GetDeformBBox(t,sbox,&oldtm,TRUE);

//fix this i think this needs to be put in old tm space
		sbox = BuildBoundVolume(obj);


		Point3 pt = sbox.Center();
		// Get the mod context tm
		Matrix3 tm(1);
		if (mc.tm) tm = tm * *mc.tm;
		
		// Transform the point and ray into mod context space
		pt = pt * tm;
		// Construct the target transformation in mod context space
		Matrix3 destTM(1);
		destTM.SetTrans(pt);

		// Our current transformation... gives relative TM
		Matrix3 curTM(1), relTM, id(1);
		Interval valid;
		tmControl->GetValue(t,&curTM,valid,CTRL_RELATIVE);
		relTM = Inverse(curTM) * destTM;
		
		// Here's the modifications we need to make to get there
		tm.IdentityMatrix();
		tm.SetTrans(curTM.GetTrans());
		AffineParts parts;			
		decomp_affine(relTM,&parts);
		Point3 delta = destTM.GetTrans()-curTM.GetTrans();
//		mod->Rotate(t,id,tm,parts.q);
		Move(t,id,id,delta);

		}

	if (flags&(CONTROL_FIT|CONTROL_ASPECT|CONTROL_INITPARAMS|CONTROL_UNIFORM)) {
		SuspendAnimate();
		AnimateOff();

		// Clear out any scale in the transform
		tm = Matrix3(1);	
		tmControl->GetValue(t,&tm,FOREVER,CTRL_RELATIVE);	
		decomp_affine(tm, &parts);
		parts.q.MakeMatrix(tm);
		tm.Translate(parts.t);	
		SetXFormPacket pckt(tm);		
		tmControl->SetValue(t,&pckt,TRUE,CTRL_ABSOLUTE);

		// Set the new dimensions
		s = tp;
		
		ResumeAnimate();
		}

	if (flags&CONTROL_HOLD) theHold.Accept(0);
*/
	flags = 0;
	}


/*
// --- Gizmo transformations ------------------------------------------

void UnwrapMod::Move(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin) 
	{	
	assert(tmControl);	
	SetXFormPacket pckt(val,partm,tmAxis);
	tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
	}


void UnwrapMod::Rotate(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Quat& val, BOOL localOrigin) 
	{
	assert(tmControl);
	SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
	tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	}

void UnwrapMod::Scale(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin) 
	{
	assert(tmControl);
	SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
	tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	}

*/

Matrix3 UnwrapMod::CompMatrix(
		TimeValue t,ModContext *mc, Matrix3 *ntm,BOOL applySize, BOOL applyAxis)
	{
	Matrix3 tm(1);
	Interval valid;
	
//	int type = GetMapType();

	if (tmControl) {
		tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);
		}
	
	// Rotate icon	
	if (applyAxis && TestAFlag(A_PLUGIN1)) {
		switch (type) {
			case MAP_BOX:
			case MAP_PLANAR:
				tm.PreRotateZ(PI);
				break;
			
			case MAP_BALL:
			case MAP_SPHERICAL:
			case MAP_CYLINDRICAL:
				tm.PreRotateZ(HALFPI);
				break;
			}
		}
	
	if (applyAxis) {
		switch (GetAxis()) {
			case 0:
				tm.PreRotateY(-HALFPI);
				break;
			case 1:			
				tm.PreRotateX(HALFPI);
				break;
			}
		}

	if (applySize) {
		Point3 ts;
		ts = s;
//		Point3 s;
//		s.x = GetWidth(t);
//		s.y = GetLength(t);
//		s.z = GetHeight(t);
//		s.x = 100.0f;
//		s.y = 100.0f;
//		s.z = 100.0f;
		switch (type) {
			case MAP_CYLINDRICAL:			
			case MAP_PLANAR:
				ts.x *= 0.5f;
				ts.y *= 0.5f;
				break;
			
			case MAP_BALL:
			case MAP_SPHERICAL:
			case MAP_BOX:
				ts *= 0.5f;				
				break;
			}
		tm.PreScale(ts);
		}

	if (mc && mc->tm) {
		tm = tm * Inverse(*mc->tm);
		}
	if (ntm) {
		tm = tm * *ntm;
		}
	return tm;
	}

static int lStart[12] = {0,1,3,2,4,5,7,6,0,1,2,3};
static int lEnd[12]   = {1,3,2,0,5,7,6,4,4,5,6,7};

static void DoBoxIcon(BOOL sel,float length, PolyLineProc& lp)
	{
	Point3 pt[3];
	
	length *= 0.5f;
	Box3 box;
	box.pmin = Point3(-length,-length,-length);
	box.pmax = Point3( length, length, length);

	if (sel) //lp.SetLineColor(1.0f,1.0f,0.0f);
		 lp.SetLineColor(GetUIColor(COLOR_SEL_GIZMOS));
	else //lp.SetLineColor(0.85f,0.5f,0.0f);		
		 lp.SetLineColor(GetUIColor(COLOR_GIZMOS));

	for (int i=0; i<12; i++) {
		pt[0] = box[lStart[i]];
		pt[1] = box[lEnd[i]];
		lp.proc(pt,2);
		}
	}


void UnwrapMod::ComputeSelectedFaceData()
{
//gNormal,gCenter;
//gXSscale,gYScale;
//compute average normal
Point3 pnorm(0.0f,0.0f,0.0f);
int ct = 0;
gCenter.x = 0.0f;
gCenter.y = 0.0f;
gCenter.z = 0.0f;
int gCt = 0;
int dir = alignDir;
if (dir == 0) //x
	{
	gNormal.x = 1.0f; 
	gNormal.y = 0.0f; 
	gNormal.z = 0.0f; 
	}
else if (dir == 1) //y
	{	
	gNormal.y = 1.0f; 
	gNormal.x = 0.0f; 
	gNormal.z = 0.0f; 
	}	
else if (dir == 2) //z
	{
	gNormal.z = 1.0f; 
	gNormal.x = 0.0f; 
	gNormal.y = 0.0f; 
	}
else
	{

	for (int k=0; k<gfaces.Count(); k++) {
		// Grap the three points, xformed
		int pcount = 3;
		if (gfaces[k].flags & FLAG_QUAD) pcount = 4;

		Point3 temp_point[4];
		for (int j=0; j<pcount; j++) {
			int index = gfaces[k].t[j];
//					Point3 temp_point;
			temp_point[j] = gverts.d[index].p;
			gCenter += gverts.d[index].p;
		
			}
		pnorm += Normalize(temp_point[1]-temp_point[0]^temp_point[2]-temp_point[1]);
		ct++;
		}
	gNormal = pnorm/(float)ct;
	}
gCenter.x = 0.0f;
gCenter.y = 0.0f;
gCenter.z = 0.0f;

gCt = 0;
float minx = 99999999999.9f,miny = 99999999999.9f,maxx= -999999999.0f,maxy= -9999999999.0f;
float minz = 99999999999.9f,maxz = -99999999999.9f;

for (int k=0; k<gverts.d.Count(); k++) {
	// Grap the three points, xformed
	if (gverts.sel[k])
		{
		Point3 pd2 = gverts.d[k].p;
		if (pd2.x < minx) minx = pd2.x;
		if (pd2.y < miny) miny = pd2.y;
		if (pd2.z < minz) minz = pd2.z;
		if (pd2.x > maxx) maxx = pd2.x;
		if (pd2.y > maxy) maxy = pd2.y;
		if (pd2.z > maxz) maxz = pd2.z;
		}
	}

gCenter.x = (float) (maxx+minx)/2.0f ;
gCenter.y = (float) (maxy+miny)/2.0f ;
gCenter.z = (float) (maxz+minz)/2.0f ;


Matrix3 tm;
UnwrapMatrixFromNormal(gNormal,tm);
tm.SetTrans(gCenter);
tm = Inverse(tm);
minx = 99999999999.9f;
miny = 99999999999.9f;
maxx= -999999999.0f;
maxy= -9999999999.0f;
minz = 99999999999.9f;
maxz = 99999999999.9f;

for (k=0; k<gfaces.Count(); k++) {
	// Grap the three points, xformed
	int pcount = 3;
	if (gfaces[k].flags & FLAG_QUAD) pcount = 4;

	for (int j=0; j<pcount; j++) {
		int index = gfaces[k].t[j];
		Point3 pd2 = gverts.d[index].p*tm;
		if (pd2.x < minx) minx = pd2.x;
		if (pd2.y < miny) miny = pd2.y;
		if (pd2.x > maxx) maxx = pd2.x;
		if (pd2.y > maxy) maxy = pd2.y;
		
		}
	}
gXScale = (float) fabs(maxx-minx)/2.0f ;
gYScale = (float) fabs(maxy-miny)/2.0f ;

}

void UnwrapMod::DoIcon(PolyLineProc& lp,BOOL sel)
	{
//	int type = GetMapType();	
	type = MAP_PLANAR;
	switch (type) {
		case MAP_BOX: DoBoxIcon(sel,2.0f,lp); break;
		case MAP_PLANAR: DoPlanarMapIcon(sel,2.0f,2.0f,lp); break;
		case MAP_BALL:
		case MAP_SPHERICAL: DoSphericalMapIcon(sel,1.0f,lp); break;
		case MAP_CYLINDRICAL: DoCylindricalMapIcon(sel,1.0f,1.0f,lp); break;
		}
	}
 

int UnwrapMod::Display(
		TimeValue t, INode* inode, ViewExp *vpt, int flags, 
		ModContext *mc) 
	{	

	if ( (ip && (ip->GetSubObjectLevel() == 1) ) && (gfaces.Count() > 0))
		{
		ComputeSelectedFaceData();

		Matrix3 vtm(1);
		Interval iv;
		if (inode) 
			vtm = inode->GetObjectTM(t,&iv);

		Point3 off;
		off = vtm.GetTrans();
		Matrix3 tm;
		UnwrapMatrixFromNormal(gNormal,tm);

		Point3 a(-0.5f,-0.5f,0.0f),b(0.5f,-0.5f,0.0f),c(0.5f,0.5f,0.0f),d(-0.5f,0.5f,0.0f);
		
		Point3 xvec,yvec;
		xvec = tm.GetRow(0)*(gXScale *1.5f);		
		yvec = tm.GetRow(1)*(gYScale *1.5f);		
		a = -xvec+yvec;
		b = xvec+yvec;
		c = xvec-yvec;
		d = -xvec-yvec;

		GraphicsWindow *gw = vpt->getGW();
		Matrix3 modmat, ntm = inode->GetObjectTM(t);

//		DrawLineProc lp(gw);

//		modmat = CompMatrix(t,mc,&ntm);	
		gw->setTransform(vtm);	
		Point3 line[5];
		line[0] = gCenter + a;
		line[1] = gCenter + b;
		line[2] = gCenter + c;
		line[3] = gCenter + d;
		line[4] = line[0];
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
		gw->polyline(5, line, NULL, NULL, 0);

//		DoIcon(lp, ip&&ip->GetSubObjectLevel()==1);
		return 1;
		}

	return 0;	
	}


void UnwrapMod::GetWorldBoundBox(
		TimeValue t,INode* inode, ViewExp *vpt, Box3& box, 
		ModContext *mc) 
	{

	if ( (ip && (ip->GetSubObjectLevel() == 1) )&& (gfaces.Count() > 0))
		{
		ComputeSelectedFaceData();

		Matrix3 tm;
		UnwrapMatrixFromNormal(gNormal,tm);

		Point3 a(-0.5f,-0.5f,0.0f),b(0.5f,-0.5f,0.0f),c(0.5f,0.5f,0.0f),d(-0.5f,0.5f,0.0f);
		
		Point3 xvec,yvec;
		xvec = tm.GetRow(0)*(gXScale * 1.5f);		
		yvec = tm.GetRow(1)*(gYScale * 1.5f);		
		a = -xvec+yvec;
		b = xvec+yvec;
		c = xvec-yvec;
		d = -xvec-yvec;

		Matrix3 modmat = inode->GetObjTMBeforeWSM(t);	

		Point3 line[5];
		line[0] = (gCenter + a)*modmat;
		line[1] = (gCenter + b)*modmat;
		line[2] = (gCenter + c)*modmat;
		line[3] = (gCenter + d)*modmat;
		line[4] = line[0];
		box.Init();
		box += line[0];
		box += line[1];
		box += line[2];
		box += line[3];
		}

	}

void UnwrapMod::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{	
	Matrix3 modmat, ntm = node->GetObjectTM(t);	
	modmat = CompMatrix(t,mc,&ntm);
	cb->Center(modmat.GetTrans(),0);	
	}

void UnwrapMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Matrix3 ntm = node->GetObjectTM(t), modmat;
	modmat = CompMatrix(t,mc,&ntm);
	cb->TM(modmat,0);
	}



int UnwrapMod::HitTest (TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc) {
	Interval valid;
	int savedLimits, res = 0;
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	

// Face slection and Face Map selection

	if (ip && (ip->GetSubObjectLevel() == 1) )
		{
		MakeHitRegion(hr,type, crossing,4,p);
		gw->setHitRegion(&hr);
		Matrix3 mat = inode->GetObjectTM(t);
		gw->setTransform(mat);	
		gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
		if (type == HITTYPE_POINT)
			gw->setRndLimits(gw->getRndLimits() & GW_BACKCULL);
		else gw->setRndLimits(gw->getRndLimits() & ~GW_BACKCULL);
		gw->clearHitCode();

		BOOL add = GetKeyState(VK_CONTROL)<0;
		BOOL sub = GetKeyState(VK_MENU)<0;
		BOOL polySelect = !(GetKeyState(VK_SHIFT)<0);

		if (add)
			ip->ReplacePrompt( GetString(IDS_PW_MOUSE_ADD));
		else if (sub)
			ip->ReplacePrompt( GetString(IDS_PW_MOUSE_SUBTRACT));
		else if (!polySelect)
			ip->ReplacePrompt( GetString(IDS_PW_MOUSE_SELECTTRI));
		else ip->ReplacePrompt( GetString(IDS_PW_MOUSE_SELECTFACE));



		if (objType == IS_MESH)
			{
			SubObjHitList hitList;
			MeshSubHitRec *rec;	
		
			if (!((MeshTopoData*)mc->localData)->GetMesh()) return 0;

			Mesh &mesh = *((MeshTopoData*)mc->localData)->GetMesh();
			mesh.faceSel = ((MeshTopoData*)mc->localData)->faceSel;
			res = mesh.SubObjectHitTest(gw, gw->getMaterial(), &hr,
				flags|SUBHIT_FACES|SUBHIT_SELSOLID, hitList);

			rec = hitList.First();
			while (rec) {
				vpt->LogHit(inode,mc,rec->dist,rec->index,NULL);
				rec = rec->Next();
				}

			}
		else if (objType == IS_PATCH)
			{
			SubPatchHitList hitList;
		
			if (!((MeshTopoData*)mc->localData)->GetPatch()) return 0;

			PatchMesh &patch = *((MeshTopoData*)mc->localData)->GetPatch();
			patch.patchSel = ((MeshTopoData*)mc->localData)->faceSel;

			res = patch.SubObjectHitTest(gw, gw->getMaterial(), &hr,
				flags|SUBHIT_PATCH_PATCHES|SUBHIT_SELSOLID, hitList);

			PatchSubHitRec *rec = hitList.First();
			while (rec) {
				vpt->LogHit(inode,mc,rec->dist,rec->index,NULL);
				rec = rec->Next();
				}

			}

		}

	gw->setRndLimits(savedLimits);	
	return res;	
	}

void UnwrapMod::DeleteVertsFromFace(Tab<UVW_TVFaceClass> f)

{
Tab<int> fcount;
Tab<int> fcount_original;
fcount.SetCount(TVMaps.v.Count());
fcount_original.SetCount(TVMaps.v.Count());

for (int i = 0; i < fcount.Count(); i++)
	{
	fcount[i] = 0;
	fcount_original[i] = 0;
	}
	
for (i = 0; i < f.Count(); i++)
	{
	if (!(TVMaps.f[f[i].FaceIndex].flags & FLAG_DEAD))
		{
		int pcount =3;
		if (TVMaps.f[f[i].FaceIndex].flags & FLAG_QUAD) pcount = 4;

		for (int j = 0; j < pcount; j++)
			{
			int index = TVMaps.f[f[i].FaceIndex].t[j];
			fcount[index] += 1;
			}
		}
	}

for (i = 0; i < TVMaps.f.Count(); i++)
	{
	if (!(TVMaps.f[i].flags & FLAG_DEAD))
		{
		int pcount =3;
		if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;

		for (int j = 0; j < pcount; j++)
			{
			int index = TVMaps.f[i].t[j];
			fcount_original[index] += 1;
			}

		}
	}
for (i = 0; i < f.Count(); i++)
	{
	if (!(TVMaps.f[f[i].FaceIndex].flags & FLAG_DEAD))
		{
		int pcount =3;
		if (TVMaps.f[f[i].FaceIndex].flags & FLAG_QUAD) pcount = 4;

		for (int j = 0; j < pcount; j++)
			{
			int index = TVMaps.f[f[i].FaceIndex].t[j];
			if (fcount[index] == fcount_original[index])
				TVMaps.v[index].flags = FLAG_DEAD;

			}
		}
	}


}


void UnwrapMod::DeleteVertsFromFace(BitArray f)

{
Tab<int> fcount;
Tab<int> fcount_original;
fcount.SetCount(TVMaps.v.Count());
fcount_original.SetCount(TVMaps.v.Count());

for (int i = 0; i < fcount.Count(); i++)
	{
	fcount[i] = 0;
	fcount_original[i] = 0;
	}
	
for (i = 0; i < f.GetSize(); i++)
	{
	if (f[i] ==1)
		{
		if (!(TVMaps.f[i].flags & FLAG_DEAD))
			{
			for (int j = 0; j < 3; j++)
				{
				int index = TVMaps.f[i].t[j];
				fcount[index] += 1;
				}
			}
		}
	}

for (i = 0; i < TVMaps.f.Count(); i++)
	{
	if (!(TVMaps.f[i].flags & FLAG_DEAD))
		{
		for (int j = 0; j < 3; j++)
			{
			int index = TVMaps.f[i].t[j];
			fcount_original[index] += 1;
			}

		}
	}
for (i = 0; i < f.GetSize(); i++)
	{
	if (f[i] ==1)
		{
		if (!(TVMaps.f[i].flags & FLAG_DEAD))
			{
			for (int j = 0; j < 3; j++)
				{
				int index = TVMaps.f[i].t[j];
				if (fcount[index] == fcount_original[index])
					TVMaps.v[index].flags = FLAG_DEAD;

				}
			}
		}
	}


}

void UnwrapMod::ApplyGizmo()
{

theHold.SuperBegin();
theHold.Begin();
HoldPointsAndFaces();	


//add vertices to our internal vertex list filling in dead spots where appropriate
int ct = 0;  

//get align normal
//get fit data

PlanarTM.IdentityMatrix();
Interval v;
scaleControl->GetValue(0,&gScale,v);
PlanarTM.SetScale(gScale);
rotateControl->GetValue(0,&gRotate,v);
PlanarTM.RotateZ(gRotate);
offsetControl->GetValue(0,&gOffset,v);
PlanarTM.SetTrans(gOffset);

ComputeSelectedFaceData();

Matrix3 gtm;
UnwrapMatrixFromNormal(gNormal,gtm);

gtm = Inverse(gtm);

//nuke any verts previously held in the faces
//for (int i = 0; i < gfaces.Count(); i++)
//	{
	DeleteVertsFromFace(gfaces);
//	}

//unselect all verts
for (int j=0;j<TVMaps.v.Count();j++)
	{
	if (vsel[j])
		{
		vsel.Clear(j);
		}
	}

//build available list
Tab<int> alist;
alist.ZeroCount();

for (j=0;j<TVMaps.v.Count();j++)
	{
	if (TVMaps.v[j].flags & FLAG_DEAD)
//dead veretx found copy new vert in and note the place
		{
		alist.Append(1,&j,1);
		}
	}


for (int i = 0; i < gverts.d.Count(); i++)
	{
	BOOL found = FALSE;
	if (gverts.sel[i])
		{
		if (ct < alist.Count() )
			{
			j = alist[ct];
			TVMaps.v[j].flags = 0;
			TVMaps.v[j].influence = 0.0f;
			
			Point3 tp = gverts.d[i].p - gCenter;
			tp = tp * gtm;
			tp.x = tp.x/gXScale *.25f +0.5f;
			tp.y = tp.y/gYScale *.25f +0.5f;

			TVMaps.v[j].p = tp;
			int vcount = vsel.GetSize();
			vsel.Set(j);

			if (TVMaps.cont[j]) TVMaps.cont[j]->SetValue(0,&tp,CTRL_ABSOLUTE);
			gverts.d[i].newindex = j;
			ct++;

			}
		else
			{
			UVW_TVVertClass tempv;

			Point3 tp = gverts.d[i].p - gCenter;
			tp = tp * gtm;
			tp.x = tp.x/gXScale *.25f +0.5f;
			tp.y = tp.y/gYScale *.25f +0.5f;
			tempv.p = tp;

			tempv.flags = 0;
			tempv.influence = 0.0f;
			gverts.d[i].newindex = TVMaps.v.Count();
			TVMaps.v.Append(1,&tempv,1);

			vsel.SetSize(TVMaps.v.Count(), 1);
			vsel.Set(TVMaps.v.Count()-1);

			Control* c;
			c = NULL;
			TVMaps.cont.Append(1,&c,1);
			if (TVMaps.cont[TVMaps.v.Count()-1]) 
				TVMaps.cont[TVMaps.v.Count()-1]->SetValue(0,&TVMaps.v[TVMaps.v.Count()-1].p,CTRL_ABSOLUTE);
			}
		}

	}
//now copy our face data over
for (i = 0; i < gfaces.Count(); i++)
	{
//	if (fs[i])
		{
//		ActiveAddFaces.Append(1,&i,1);
		int ct = gfaces[i].FaceIndex;
		TVMaps.f[ct].flags = gfaces[i].flags;
		TVMaps.f[ct].flags |= FLAG_SELECTED;
		int pcount = 3;
		if (gfaces[i].flags & FLAG_QUAD) pcount = 4;
		for (int j = 0; j < pcount; j++)
			{
			int index = gfaces[i].t[j];
//find spot in our list
			TVMaps.f[ct].t[j] = gverts.d[index].newindex;

			}
		}
	}
//make a named selection for new face selection
TSTR namePre(GetString(IDS_PW_PLANARMAP));
TSTR name;
int ctn = 0;
while (1) {				
	char num[10];
	wsprintf(num,"%d",ctn);
	name = namePre+num;
	Tab<TSTR*> &setList = namedSel;

	BOOL unique = TRUE;
	for (int i=0; i<setList.Count(); i++) {
		if (name==*setList[i]) {
			unique = FALSE;
			break;
		}
	}
	ctn++;
	if (unique) break;

	}
NewSetFromCurSel(name); 
SetupNamedSelDropDown();

theHold.Accept(_T(GetString(IDS_PW_PLANARMAP)));
theHold.SuperAccept(_T(GetString(IDS_PW_PLANARMAP)));

//update our views to show new faces
InvalidateView();
}

void UnwrapMod::AddFaces(BitArray fs, Mesh *mesh)
{

theHold.SuperBegin();
theHold.Begin();
HoldPointsAndFaces();	

ActiveAddFaces.ZeroCount();

Face *tf = mesh->faces;
Point3 *tp = mesh->verts;
VertexLookUpListClass v;

DeleteVertsFromFace(fs);


//isolate a vertex list of just the selected faces

for (int i = 0; i < fs.GetSize(); i++)
	{
	if (fs[i])
		{
		for (int j = 0; j < 3; j++)
			{
			int index = tf[i].v[j];
			v.addPoint(index, tp[index]);
			}

		}
	}

//center the selection
Point3 center(.0f,0.0f,0.0f);
for (i = 0; i<v.d.Count(); i++)
	{
	center += v.d[i].p;
	}
center = center/(float)v.d.Count();
for (i = 0; i<v.d.Count(); i++)
	{
	v.d[i].p -= center;
	}

//get normal
Point3 zaxis = CrossProd(Normalize(v.d[1].p - v.d[0].p),Normalize(v.d[2].p - v.d[0].p));
zaxis = Normalize(zaxis);
//find first visible edge and use those cords as the xaxis
Point3 xaxis = Normalize(v.d[1].p - v.d[0].p);




Point3 yaxis = CrossProd(zaxis,xaxis);
yaxis = Normalize(yaxis);

Matrix3 tm(1);

tm.SetRow(0,xaxis);
tm.SetRow(1,yaxis);
tm.SetRow(2,zaxis);

for (i = 0; i<v.d.Count(); i++)
	{
	v.d[i].p = v.d[i].p * Inverse(tm);
	}


mesh->buildBoundingBox();
Box3 b = mesh->getBoundingBox();


float d = 0.0f;
d = Length(b.pmax-b.pmin);
d = 1.0f/d;
for (i = 0; i<v.d.Count(); i++)
	{
	v.d[i].p = v.d[i].p*d + 0.5f;
	}

//add vertices to our internal vertex list filling in dead spots where appropriate
int ct = 0;  
for (i = 0; i < v.d.Count(); i++)
	{
	BOOL found = FALSE;
	for (int j=ct;j<TVMaps.v.Count();j++)
		{
		if (TVMaps.v[j].flags & FLAG_DEAD)
//dead veretx found copy new vert in and note the place
			{

			TVMaps.v[j].flags = 0;
			TVMaps.v[j].influence = 0.0f;
			TVMaps.v[j].p = v.d[i].p;
			if (TVMaps.cont[j]) TVMaps.cont[j]->SetValue(0,&TVMaps.v[j].p);
			v.d[i].newindex = j;
			ct = j;
			j = TVMaps.v.Count();
			found  = TRUE;
			}
		}
	if (!found)
		{
		UVW_TVVertClass tempv;

		tempv.p = v.d[i].p;
		tempv.flags = 0;
		tempv.influence = 0.0f;
		v.d[i].newindex = TVMaps.v.Count();
		TVMaps.v.Append(1,&tempv,1);

		vsel.SetSize(TVMaps.v.Count(), 1);
		Control* c;
		c = NULL;
		TVMaps.cont.Append(1,&c,1);
		if (TVMaps.cont[TVMaps.v.Count()-1]) TVMaps.cont[TVMaps.v.Count()-1]->SetValue(0,&TVMaps.v[TVMaps.v.Count()-1].p);
		}

	}

//now copy our face data over
for (i = 0; i < fs.GetSize(); i++)
	{
	if (fs[i])
		{
		ActiveAddFaces.Append(1,&i,1);
		TVMaps.f[i].flags = 0;
		for (int j = 0; j < 3; j++)
			{
			int index = tf[i].v[j];
//find spot in our list
			for (int k = 0; k < v.d.Count();k++)
				{
				if (v.d[k].index == index)
					{
					TVMaps.f[i].t[j] = v.d[k].newindex;
					k = v.d.Count();
					}
				}
			}
		}
	}
theHold.Accept(_T(GetString(IDS_PW_PLANARMAP)));
theHold.SuperAccept(_T(GetString(IDS_PW_PLANARMAP)));

//update our views to show new faces
InvalidateView();
}

void UnwrapMod::AddFaces(BitArray fs, PatchMesh *patch)
{

theHold.SuperBegin();
theHold.Begin();
HoldPointsAndFaces();	

ActiveAddFaces.ZeroCount();

Patch *tf = patch->patches;
PatchVert *tp = patch->verts;
VertexLookUpListClass v;

DeleteVertsFromFace(fs);


//isolate a vertex list of just the selected faces
for (int i = 0; i < fs.GetSize(); i++)
	{
	if (fs[i])
		{
		int pcount =3;
		if (tf[i].type == PATCH_QUAD) pcount = 4;
		for (int j = 0; j < pcount; j++)
			{
			int index = tf[i].v[j];
			v.addPoint(index, tp[index].p);
			}

		}
	}

//center the selection
Point3 center(.0f,0.0f,0.0f);
for (i = 0; i<v.d.Count(); i++)
	{
	center += v.d[i].p;
	}
center = center/(float)v.d.Count();
for (i = 0; i<v.d.Count(); i++)
	{
	v.d[i].p -= center;
	}

//get normal
Point3 zaxis = CrossProd(Normalize(v.d[1].p - v.d[0].p),Normalize(v.d[2].p - v.d[0].p));
zaxis = Normalize(zaxis);
//find first visible edge and use those cords as the xaxis
Point3 xaxis = Normalize(v.d[1].p - v.d[0].p);




Point3 yaxis = CrossProd(zaxis,xaxis);
yaxis = Normalize(yaxis);

Matrix3 tm(1);

tm.SetRow(0,xaxis);
tm.SetRow(1,yaxis);
tm.SetRow(2,zaxis);

for (i = 0; i<v.d.Count(); i++)
	{
	v.d[i].p = v.d[i].p * Inverse(tm);
	}


patch->buildBoundingBox();
Box3 b = patch->getBoundingBox();


float d = 0.0f;
d = Length(b.pmax-b.pmin);
d = 1.0f/d;
for (i = 0; i<v.d.Count(); i++)
	{
	v.d[i].p = v.d[i].p*d + 0.5f;
	}

//add vertices to our internal vertex list filling in dead spots where appropriate
int ct = 0;  
for (i = 0; i < v.d.Count(); i++)
	{
	BOOL found = FALSE;
	for (int j=ct;j<TVMaps.v.Count();j++)
		{
		if (TVMaps.v[j].flags & FLAG_DEAD)
//dead veretx found copy new vert in and note the place
			{

			TVMaps.v[j].flags = 0;
			TVMaps.v[j].influence = 0.0f;
			TVMaps.v[j].p = v.d[i].p;
			if (TVMaps.cont[j]) TVMaps.cont[j]->SetValue(0,&TVMaps.v[j].p);
			v.d[i].newindex = j;
			ct = j;
			j = TVMaps.v.Count();
			found  = TRUE;
			}
		}
	if (!found)
		{
		UVW_TVVertClass tempv;

		tempv.p = v.d[i].p;
		tempv.flags = 0;
		tempv.influence = 0.0f;
		v.d[i].newindex = TVMaps.v.Count();
		TVMaps.v.Append(1,&tempv,1);

		vsel.SetSize(TVMaps.v.Count(), 1);
		Control* c;
		c = NULL;
		TVMaps.cont.Append(1,&c,1);
		if (TVMaps.cont[TVMaps.v.Count()-1]) TVMaps.cont[TVMaps.v.Count()-1]->SetValue(0,&TVMaps.v[TVMaps.v.Count()-1].p);
		}

	}

//now copy our face data over
for (i = 0; i < fs.GetSize(); i++)
	{
	if (fs[i])
		{
		ActiveAddFaces.Append(1,&i,1);

		if (tf[i].type == PATCH_QUAD)
			TVMaps.f[i].flags = FLAG_QUAD;
		else TVMaps.f[i].flags = 0;


		int pcount =3;
		if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;

		for (int j = 0; j < pcount; j++)
			{
			int index = tf[i].v[j];
//find spot in our list
			for (int k = 0; k < v.d.Count();k++)
				{
				if (v.d[k].index == index)
					{
					TVMaps.f[i].t[j] = v.d[k].newindex;
					k = v.d.Count();
					}
				}
			}
		}
	}
theHold.Accept(_T(GetString(IDS_PW_PLANARMAP)));
theHold.SuperAccept(_T(GetString(IDS_PW_PLANARMAP)));

//update our views to show new faces
InvalidateView();
}


void UnwrapMod::ExpandFaces(BitArray fs, Mesh *mesh)
{
theHold.SuperBegin();
theHold.Begin();
HoldPointsAndFaces();	


Face *tf = mesh->faces;
Point3 *tp = mesh->verts;
VertexLookUpListClass v;

DeleteVertsFromFace(fs);

//isolate a vertex list of just the selected faces
for (int i = 0; i < fs.GetSize(); i++)
	{
	if (fs[i])
		{
		for (int j = 0; j < 3; j++)
			{
			int index = tf[i].v[j];
			v.addPoint(index, tp[index]);
			}

		}
	}

//center the selection
Point3 center(.0f,0.0f,0.0f);
for (i = 0; i<v.d.Count(); i++)
	{
	center += v.d[i].p;
	}
center = center/(float)v.d.Count();
for (i = 0; i<v.d.Count(); i++)
	{
	v.d[i].p -= center;
	}

//get normal
Point3 zaxis = CrossProd(Normalize(v.d[1].p - v.d[0].p),Normalize(v.d[2].p - v.d[0].p));
zaxis = Normalize(zaxis);
//find first visible edge and use those cords as the xaxis
Point3 xaxis = Normalize(v.d[1].p - v.d[0].p);




Point3 yaxis = CrossProd(zaxis,xaxis);
yaxis = Normalize(yaxis);

Matrix3 tm(1);

tm.SetRow(0,xaxis);
tm.SetRow(1,yaxis);
tm.SetRow(2,zaxis);

for (i = 0; i<v.d.Count(); i++)
	{
	v.d[i].p = v.d[i].p * Inverse(tm);
	}


mesh->buildBoundingBox();
Box3 b = mesh->getBoundingBox();


float d = 0.0f;
d = Length(b.pmax-b.pmin);
d = 1.0f/d;
for (i = 0; i<v.d.Count(); i++)
	{
	v.d[i].p = v.d[i].p*d + 0.5f;
	}


//now we need to line them up
Point3 offset(0.0f,0.0f,0.0f);
float angle;
float scale;

Point3 pa,pb,ta,tb;

for (i = 0; i < fs.GetSize(); i++)
	{
	if (fs[i])
		{
//loop through each face edge
		for (int j = 0; j < 3; j++)
			{
			int a,b;
			a = tf[i].v[j];
			if (j==2)
				b = tf[i].v[0];
			else b = tf[i].v[j+1];
			for (int k = 0; k < ActiveAddFaces.Count(); k++)
				{
				int afaceid = ActiveAddFaces[k];
				for (int m = 0; m < 3; m++)
					{
					int target_a, target_b;
					target_b = tf[afaceid].v[m];
					if (m==2)
						target_a = tf[afaceid].v[0];
					else target_a = tf[afaceid].v[m+1];
//share a common mesh edge so share the TV Face edge also 
//move and rotat to align
					if ((a==target_a) && (b==target_b))
						{
						int index,index_target;
						if (m==2)
							index = TVMaps.f[afaceid].t[0];
						else index = TVMaps.f[afaceid].t[m+1];
						index_target = tf[i].v[j];

						for (int n =  0; n < v.d.Count(); n++)
							{
							if (v.d[n].index == index_target)
								{	
//get the transform offfset
								pa = TVMaps.v[index].p;
								ta = v.d[n].p;
								offset = TVMaps.v[index].p-v.d[n].p;
								n = v.d.Count();
								}
							}
						index = TVMaps.f[afaceid].t[m];
						if (j==2)
							index_target = tf[i].v[0];
						else index_target = tf[i].v[j+1];
						for (n =  0; n < v.d.Count(); n++)
							{
							if (v.d[n].index == index_target)
								{	
//get the transform offfset
								pb = TVMaps.v[index].p;
								tb = v.d[n].p;
								n = v.d.Count();
								}
							}
						Point3 pvec,tvec;
						pvec = pb-pa;
						tvec = tb-ta;
//get the scale offset
						scale = Length(pvec)/Length(tvec);
//get the angle offset
						angle = (float)acos(DotProd(Normalize(pvec),Normalize(tvec)));
						Point3 dirvec = CrossProd(Normalize(pvec),Normalize(tvec));
//						if ((pvec.x < 0.0) || (pvec.y < 0.0) )angle = -angle;
						if ( dirvec.z>0.0f )angle = -angle;

						m = 4;
						k = ActiveAddFaces.Count();
						j = 4;
						i = fs.GetSize();
						}

					}
			
				}


			}
		}
	}
//need to scale and rotate our new pieces
//offset *= scale;
Matrix3 rtm(1);
rtm.RotateZ(angle);

for (i = 0; i < v.d.Count(); i++)
	{
//zero out corner
	Point3 ZeroOffset;
	ZeroOffset = -ta;
	v.d[i].p += ZeroOffset;
//scale it 
	v.d[i].p *= scale;

//rotate it
	v.d[i].p = v.d[i].p * rtm;
//move it back
	v.d[i].p += -ZeroOffset;
//offset it
	v.d[i].p += offset;
	}
/*
for (i = 0; i < v.d.Count(); i++)
	{
	ZeroOffset = -pa;
	v.d[i].p += ZeroOffset;

//move it back
	v.d[i].p += -ZeroOffset;
	}
*/
//add vertices to our internal vertex list filling in dead spots where appropriate
int ct = 0;  
for (i = 0; i < v.d.Count(); i++)
	{
	BOOL found = FALSE;
	for (int j=ct;j<TVMaps.v.Count();j++)
		{
		if (TVMaps.v[j].flags & FLAG_DEAD)
//dead veretx found copy new vert in and note the place
			{

			TVMaps.v[j].flags = 0;
			TVMaps.v[j].influence = 0.0f;
			TVMaps.v[j].p = v.d[i].p;
			if (TVMaps.cont[j]) TVMaps.cont[j]->SetValue(0,&TVMaps.v[j].p);
			v.d[i].newindex = j;
			ct = j;
			j = TVMaps.v.Count();
			found  = TRUE;
			}
		}
	if (!found)
		{
		UVW_TVVertClass tempv;

		tempv.p = v.d[i].p;
		tempv.flags = 0;
		tempv.influence = 0.0f;
		v.d[i].newindex = TVMaps.v.Count();
		TVMaps.v.Append(1,&tempv,1);

		vsel.SetSize(TVMaps.v.Count(), 1);
		Control* c;
		c = NULL;
		TVMaps.cont.Append(1,&c,1);
		if (TVMaps.cont[TVMaps.v.Count()-1]) TVMaps.cont[TVMaps.v.Count()-1]->SetValue(0,&TVMaps.v[TVMaps.v.Count()-1].p);
		}

	}

//now copy our face data over
for (i = 0; i < fs.GetSize(); i++)
	{
	if (fs[i])
		{
		ActiveAddFaces.Append(1,&i,1);
		TVMaps.f[i].flags = 0;
		for (int j = 0; j < 3; j++)
			{
			int index = tf[i].v[j];
//find spot in our list
			for (int k = 0; k < v.d.Count();k++)
				{
				if (v.d[k].index == index)
					{
					TVMaps.f[i].t[j] = v.d[k].newindex;
					k = v.d.Count();
					}
				}
			}
		}
	}

theHold.Accept(_T(GetString(IDS_PW_PLANARMAP)));
theHold.SuperAccept(_T(GetString(IDS_PW_PLANARMAP)));


//update our views to show new faces
InvalidateView();
}

void UnwrapMod::ExpandFaces(BitArray fs, PatchMesh *patch)
{
theHold.SuperBegin();
theHold.Begin();
HoldPointsAndFaces();	


Patch *tf = patch->patches;
PatchVert *tp = patch->verts;
VertexLookUpListClass v;

DeleteVertsFromFace(fs);

//isolate a vertex list of just the selected faces
for (int i = 0; i < fs.GetSize(); i++)
	{
	if (fs[i])
		{
		int pcount =3;
//		if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;
		if (tf[i].type == PATCH_QUAD) pcount = 4;
		for (int j = 0; j < pcount; j++)
			{
			int index = tf[i].v[j];
			v.addPoint(index, tp[index].p);
			}

		}
	}

//center the selection
Point3 center(.0f,0.0f,0.0f);
for (i = 0; i<v.d.Count(); i++)
	{
	center += v.d[i].p;
	}
center = center/(float)v.d.Count();
for (i = 0; i<v.d.Count(); i++)
	{
	v.d[i].p -= center;
	}

//get normal
Point3 zaxis = CrossProd(Normalize(v.d[1].p - v.d[0].p),Normalize(v.d[2].p - v.d[0].p));
zaxis = Normalize(zaxis);
//find first visible edge and use those cords as the xaxis
Point3 xaxis = Normalize(v.d[1].p - v.d[0].p);




Point3 yaxis = CrossProd(zaxis,xaxis);
yaxis = Normalize(yaxis);

Matrix3 tm(1);

tm.SetRow(0,xaxis);
tm.SetRow(1,yaxis);
tm.SetRow(2,zaxis);

for (i = 0; i<v.d.Count(); i++)
	{
	v.d[i].p = v.d[i].p * Inverse(tm);
	}


patch->buildBoundingBox();
Box3 b = patch->getBoundingBox();


float d = 0.0f;
d = Length(b.pmax-b.pmin);
d = 1.0f/d;
for (i = 0; i<v.d.Count(); i++)
	{
	v.d[i].p = v.d[i].p*d + 0.5f;
	}


//now we need to line them up
Point3 offset(0.0f,0.0f,0.0f);
float angle;
float scale;

Point3 pa,pb,ta,tb;

for (i = 0; i < fs.GetSize(); i++)
	{
	if (fs[i])
		{
//loop through each face edge
		int pcount =3;
//		if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;
		if (tf[i].type == PATCH_QUAD) pcount = 4;

		for (int j = 0; j < pcount; j++)
			{
			int a,b;
			a = tf[i].v[j];
			if (j==(pcount-1))
				b = tf[i].v[0];
			else b = tf[i].v[j+1];
			for (int k = 0; k < ActiveAddFaces.Count(); k++)
				{
				int afaceid = ActiveAddFaces[k];
				int mpcount =3;
//				if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;
				if (tf[afaceid].type == PATCH_QUAD) mpcount = 4;

				for (int m = 0; m < mpcount; m++)
					{
					int target_a, target_b;
					target_b = tf[afaceid].v[m];
					if (m==(mpcount-1))
						target_a = tf[afaceid].v[0];
					else target_a = tf[afaceid].v[m+1];
//share a common mesh edge so share the TV Face edge also 
//move and rotat to align
					if ((a==target_a) && (b==target_b))
						{
						int index,index_target;
						if (m==(mpcount-1))
							index = TVMaps.f[afaceid].t[0];
						else index = TVMaps.f[afaceid].t[m+1];
						index_target = tf[i].v[j];

						for (int n =  0; n < v.d.Count(); n++)
							{
							if (v.d[n].index == index_target)
								{	
//get the transform offfset
								pa = TVMaps.v[index].p;
								ta = v.d[n].p;
								offset = TVMaps.v[index].p-v.d[n].p;
								n = v.d.Count();
								}
							}
						index = TVMaps.f[afaceid].t[m];
						if (j==(pcount-1))
							index_target = tf[i].v[0];
						else index_target = tf[i].v[j+1];
						for (n =  0; n < v.d.Count(); n++)
							{
							if (v.d[n].index == index_target)
								{	
//get the transform offfset
								pb = TVMaps.v[index].p;
								tb = v.d[n].p;
								n = v.d.Count();
								}
							}
						Point3 pvec,tvec;
						pvec = pb-pa;
						tvec = tb-ta;
//get the scale offset
						scale = Length(pvec)/Length(tvec);
//get the angle offset
						angle = (float)acos(DotProd(Normalize(pvec),Normalize(tvec)));
						Point3 dirvec = CrossProd(Normalize(pvec),Normalize(tvec));
//						if ((pvec.x < 0.0) || (pvec.y < 0.0) )angle = -angle;
						if ( dirvec.z>0.0f )angle = -angle;

						m = 5;
						k = ActiveAddFaces.Count();
						j = 5;
						i = fs.GetSize();
						}

					}
			
				}


			}
		}
	}
//need to scale and rotate our new pieces
//offset *= scale;
Matrix3 rtm(1);
rtm.RotateZ(angle);

for (i = 0; i < v.d.Count(); i++)
	{
//zero out corner
	Point3 ZeroOffset;
	ZeroOffset = -ta;
	v.d[i].p += ZeroOffset;
//scale it 
	v.d[i].p *= scale;

//rotate it
	v.d[i].p = v.d[i].p * rtm;
//move it back
	v.d[i].p += -ZeroOffset;
//offset it
	v.d[i].p += offset;
	}
/*
for (i = 0; i < v.d.Count(); i++)
	{
	ZeroOffset = -pa;
	v.d[i].p += ZeroOffset;

//move it back
	v.d[i].p += -ZeroOffset;
	}
*/
//add vertices to our internal vertex list filling in dead spots where appropriate
int ct = 0;  
for (i = 0; i < v.d.Count(); i++)
	{
	BOOL found = FALSE;
	for (int j=ct;j<TVMaps.v.Count();j++)
		{
		if (TVMaps.v[j].flags & FLAG_DEAD)
//dead veretx found copy new vert in and note the place
			{

			TVMaps.v[j].flags = 0;
			TVMaps.v[j].influence = 0.0f;
			TVMaps.v[j].p = v.d[i].p;
			if (TVMaps.cont[j]) TVMaps.cont[j]->SetValue(0,&TVMaps.v[j].p);
			v.d[i].newindex = j;
			ct = j;
			j = TVMaps.v.Count();
			found  = TRUE;
			}
		}
	if (!found)
		{
		UVW_TVVertClass tempv;

		tempv.p = v.d[i].p;
		tempv.flags = 0;
		tempv.influence = 0;
		v.d[i].newindex = TVMaps.v.Count();
		TVMaps.v.Append(1,&tempv,1);

		vsel.SetSize(TVMaps.v.Count(), 1);
		Control* c;
		c = NULL;
		TVMaps.cont.Append(1,&c,1);
		if (TVMaps.cont[TVMaps.v.Count()-1]) TVMaps.cont[TVMaps.v.Count()-1]->SetValue(0,&TVMaps.v[TVMaps.v.Count()-1].p);
		}

	}

//now copy our face data over
for (i = 0; i < fs.GetSize(); i++)
	{
	if (fs[i])
		{
		ActiveAddFaces.Append(1,&i,1);

		if (tf[i].type == PATCH_QUAD)
			TVMaps.f[i].flags = FLAG_QUAD;
		else TVMaps.f[i].flags = 0;

//		TVMaps.f[i].flags = 0;

		int pcount =3;
		if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;

		for (int j = 0; j < pcount; j++)
			{
			int index = tf[i].v[j];
//find spot in our list
			for (int k = 0; k < v.d.Count();k++)
				{
				if (v.d[k].index == index)
					{
					TVMaps.f[i].t[j] = v.d[k].newindex;
					k = v.d.Count();
					}
				}
			}
		}
	}

theHold.Accept(_T(GetString(IDS_PW_PLANARMAP)));
theHold.SuperAccept(_T(GetString(IDS_PW_PLANARMAP)));


//update our views to show new faces
InvalidateView();
}

void UnwrapMod::UpdateFaceSelection(BitArray f)
{
int ct = 0;
for (int i = 0; i < TVMaps.f.Count();i++)
	{
	if (!(TVMaps.f[i].flags & FLAG_DEAD))
		{
		if (f[i] == 1)
			{
			TVMaps.f[i].flags |= FLAG_SELECTED;
			ct++;
			}
		else TVMaps.f[i].flags &= (~FLAG_SELECTED);
		}
	}
//if (ct > 0) AlignMap();

}

int UnwrapMod::IsSelected(int index)
{
if (index < isSelected.GetSize())
	return isSelected[index];
else return 0;
int sel = 0;
for (int i = 0; i < TVMaps.f.Count();i++)
	{
	int pcount = 3;
	if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;
	for (int j = 0;  j < pcount;j++)
		{
		if ( (TVMaps.f[i].t[j] == index) && ((TVMaps.f[i].flags & FLAG_SELECTED)))
			{
			sel = 1;
			return sel;
			}
		}
	}
return sel;
}

int UnwrapMod::IsSelectedSetup()
{
int sel = 0;
isSelected.SetSize(TVMaps.v.Count());
isSelected.ClearAll();

for (int i = 0; i < TVMaps.f.Count();i++)
	{
	int pcount = 3;
	if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;
	for (int j = 0;  j < pcount;j++)
		{
		if ( (TVMaps.f[i].flags & FLAG_SELECTED))
			{
			isSelected.Set(TVMaps.f[i].t[j]);
			}
		}
	}
return 1;
}


void UnwrapMod::ExpandSelection(int dir)

{
Tab<int>SelectMe;


/*
DebugPrint("vsel sixe %d number set %d\n",vsel.GetSize(),vsel.NumberSet());
for (int i = 0; i < vsel.GetSize();i++)
	{
	DebugPrint("%d",vsel[i]);

	}
DebugPrint("\n");
*/

for (int i = 0; i < TVMaps.v.Count();i++)
	{
	if (vsel[i]==dir)
		{
//if face is selected select me
		for (int j = 0; j < TVMaps.f.Count();j++)
			{
			if (!(TVMaps.f[j].flags & FLAG_DEAD))
				{
				int pcount = 3;
				if (TVMaps.f[j].flags & FLAG_QUAD) pcount = 4;
				int match = 0;
				for (int k = 0; k < pcount; k++)
					{
					int index = TVMaps.f[j].t[k];
					if (index == i)
						match = 1;
					}
				if (match)
					{
					for (k = 0; k < pcount; k++)
						{
						int index = TVMaps.f[j].t[k];
						if (vsel[index]!=dir)
							{
							SelectMe.Append(1,&i,1);
							k = 5;
							j = TVMaps.f.Count();
							}
						}
					}
				}
			}
		}
	}
for (i = 0; i < SelectMe.Count(); i++)
	{
	if (dir == 0)
		vsel.Set(SelectMe[i],1);
	else vsel.Set(SelectMe[i],0);
	}

}

void UnwrapMod::SelectSubComponent (HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert) {

MeshTopoData *d = NULL, *od = NULL;

BitArray set;
//BitArray tempset;
AdjFaceList *al = NULL;
facehit.ZeroCount();
BOOL add = GetKeyState(VK_CONTROL)<0;
BOOL sub = GetKeyState(VK_MENU)<0;
BOOL polySelect = !(GetKeyState(VK_SHIFT)<0);

ip->ClearCurNamedSelSet();

if ( (ip && (ip->GetSubObjectLevel() == 1)  ))
	{
	if (objType == IS_MESH)
		{
		Mesh &mesh = *(((MeshTopoData*)hitRec->modContext->localData)->GetMesh());
		set.SetSize(mesh.getNumFaces());


		AdjFaceList *al = NULL;
		if (polySelect)
			al = BuildAdjFaceList(mesh);

		if (theHold.Holding()) theHold.Put (new UnwrapSelRestore (this,(MeshTopoData*)hitRec->modContext->localData));

		while (hitRec) {					
			d = (MeshTopoData*)hitRec->modContext->localData;					
//			if (set.GetSize()!=d->faceSel.GetSize()) d->faceSel.SetSize(set.GetSize(),TRUE);
			set.ClearAll();
			if (polySelect)
				{
//6-29--99 watje
				if ((hitRec->hitInfo < mesh.numFaces) &&
				    (d->faceSel.GetSize() == set.GetSize()))
					{

					mesh.PolyFromFace (hitRec->hitInfo, set, 45.0, FALSE, al);
					if (invert) d->faceSel ^= set;
					else if (selected) d->faceSel |= set;
					else d->faceSel &= ~set;
					}


				}
			else
				{
				BOOL state = selected;
//6-29--99 watje
				if (hitRec->hitInfo < d->faceSel.GetSize())
					{
					if (invert) state = !d->faceSel[hitRec->hitInfo];
					if (state) d->faceSel.Set(hitRec->hitInfo);
					else       d->faceSel.Clear(hitRec->hitInfo);
					}
				}
			if (!all) break;

			hitRec = hitRec->Next();
		}
		UpdateFaceSelection(d->faceSel);
		if (al) delete al;
		}
	else if (objType == IS_PATCH)
		{
		if (theHold.Holding()) theHold.Put (new UnwrapSelRestore (this,(MeshTopoData*)hitRec->modContext->localData));

		while (hitRec) {
			PatchMesh &patch = *(((MeshTopoData*)hitRec->modContext->localData)->GetPatch());
//			if (patch.numPatches!=d->faceSel.GetSize()) d->faceSel.SetSize(patch.numPatches,TRUE);
			od = d;
			d  = (MeshTopoData*)hitRec->modContext->localData;

	// Build it the first time
			BOOL state = selected;
//6-29--99 watje
			if (hitRec->hitInfo < d->faceSel.GetSize())
				{

				if (invert) state = !d->faceSel[hitRec->hitInfo];
				if (state) d->faceSel.Set(hitRec->hitInfo);
				else       d->faceSel.Clear(hitRec->hitInfo);
				}
			if (!all) break;
			hitRec = hitRec->Next();

			}
		UpdateFaceSelection(d->faceSel);
		}
	if (filterSelectedFaces == 1) InvalidateView();

	}

ComputeSelectedFaceData();
theHold.Accept (GetString (IDS_DS_SELECT));

NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
SetNumSelLabel();
}

void UnwrapMod::ClearSelection(int selLevel)
{
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	MeshTopoData *d;
	for (int i=0; i<list.Count(); i++) {
		d = (MeshTopoData*)list[i]->localData;
		if (!d) continue;
		if (theHold.Holding()) theHold.Put (new UnwrapSelRestore (this,d));

		switch (selLevel) {
			case 1:
				d->faceSel.ClearAll();
				UpdateFaceSelection(d->faceSel);
				break;
			}
		}
	theHold.Accept (GetString (IDS_DS_SELECT));

	ip->ClearCurNamedSelSet();
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	SetNumSelLabel();
//update our views to show new faces
	InvalidateView();


}



void UnwrapMod::ActivateSubobjSel(int level, XFormModes& modes) {
	// Fill in modes with our sub-object modes

	if (level ==0)
		{
//		iAlignButton->Enable(FALSE);
		iApplyButton->Enable(FALSE);
//		iFitButton->Enable(FALSE);
		}
	if (level==1) 
		{
//		AlignMap();
		SetupNamedSelDropDown();
//face select
//		iAlignButton->Enable(FALSE);
		iApplyButton->Enable(TRUE);
//		iFitButton->Enable(FALSE);
		modes = XFormModes(NULL,NULL,NULL,NULL,NULL,selectMode);
		}
/*
	else if (level==2) 
		{
//face map mode
//		iAlignButton->Enable(FALSE);
		iApplyButton->Enable(FALSE);
//		iFitButton->Enable(FALSE);
		modes = XFormModes(NULL,NULL,NULL,NULL,NULL,selectMode);
		}
	else if (level==3) 
		{
//face map mode
//		iAlignButton->Enable(TRUE);
		iApplyButton->Enable(TRUE);
//		iFitButton->Enable(TRUE);
		modes = XFormModes(gmoveMode,grotMode,gnuscaleMode,guscaleMode,gsquashMode,NULL);
		type = MAP_PLANAR;
		}
*/
	SetNumSelLabel ();

	InvalidateView();
	NotifyDependents(FOREVER,PART_DISPLAY,REFMSG_CHANGE);

}

class MyEnumProc : public DependentEnumProc 
	{
      public :
      virtual int proc(ReferenceMaker *rmaker); 
      INodeTab Nodes;              
	};

int MyEnumProc::proc(ReferenceMaker *rmaker) 
	{ 
	if (rmaker->SuperClassID()==BASENODE_CLASS_ID)    
			{
            Nodes.Append(1, (INode **)&rmaker);                 
			}
     return 0;              
	}

void UnwrapMod::LoadMaterials()
{
//no entries on our material list lets add some based on the current assigned material in MtlBase
int ct =0;

MyEnumProc dep;              
EnumDependents(&dep);
INode *SelfNode = dep.Nodes[0];
BaseMtl = SelfNode->GetMtl();

//if ((map[0] == NULL) && (BaseMtl != NULL))
if ((BaseMtl != NULL))
	{
//check is standard material
//	if (BaseMtl->ClassID() == DMTL_CLASS_ID)
	if (BaseMtl->ClassID() == Class_ID(DMTL_CLASS_ID,0))
		{
		StdMat *stdmat = (StdMat*) BaseMtl;
		int tex_count = stdmat->NumSubTexmaps();
		for (int i = 0; i < tex_count; i++)
			{
			Texmap *tmap;
			MtlBase *m;
			tmap = stdmat->GetSubTexmap(i);
			m = (MtlBase*) tmap;
//			m = (MtlBase*) stdmat->GetSubMtl(i);
			if (m != NULL)
				{
//add to our list
				AddMaterial(m);
				ct++;
				if (ct ==10) return;
				}
			}
		}
//check multi sub material
	else if (BaseMtl->IsMultiMtl())
		{	
		int mat_count = 0;
		mat_count = BaseMtl->NumSubMtls();
		for (int j=0; j < mat_count; j++)
			{
			
			MtlBase *m;
			m = (MtlBase*) BaseMtl->GetSubMtl(j);
			if (m != NULL)
				{
				int tex_count = m->NumSubTexmaps();
				for (int i = 0; i < tex_count; i++)
					{

					Texmap *tmap;
					MtlBase *mt;
					tmap = m->GetSubTexmap(i);
					mt = (MtlBase*) tmap;
					if (mt != NULL)
						{
//add to our list
						AddMaterial(mt);
						ct++;
						if (ct ==10) return;

						}
					}
				}
			}

		}

	}
CurrentMap = 0;
SetupImage();
SendMessage(hTextures, CB_SETCURSEL, CurrentMap, 0 );

}

void UnwrapMod::BuildMatIDList()
{

filterMatID.ZeroCount();
for (int i = 0; i < TVMaps.f.Count(); i++)
	{
	int found = 0;
	if (!(TVMaps.f[i].flags & FLAG_DEAD))
		{
		for (int j = 0; j < filterMatID.Count(); j++)
			{
			if (filterMatID[j] == TVMaps.f[i].MatID) 
				{
				found = 1;
				j = filterMatID.Count();
				}
			}
		}
	else found = 1;
	if (found == 0)
		filterMatID.Append(1,&TVMaps.f[i].MatID,1);
	}

vertMatIDList.SetSize(TVMaps.v.Count());
vertMatIDList.SetAll();
matid = -1;
}


void UnwrapMod::ComputeFalloff(float &u, int ftype)

{
if (u<= 0.0f) u = 0.0f;
else if (u>= 1.0f) u = 1.0f;
else switch (ftype)
	{
	case (3) : u = u*u*u; break;
//	case (BONE_FALLOFF_X2_FLAG) : u = u*u; break;
	case (0) : u = u; break;
	case (1) : u = 1.0f-((float)cos(u*PI) + 1.0f)*0.5f; break;
//	case (BONE_FALLOFF_2X_FLAG) : u = (float) sqrt(u); break;
	case (2) : u = (float) pow(u,0.3); break;

	}

}

void UnwrapMod::RebuildDistCache()
{
float str = iStr->GetFVal();
float sstr = str*str;
if (str == 0.0f)
	{
	for (int i = 0; i<TVMaps.v.Count(); i++)
		TVMaps.v[i].influence = 0.0f;
	return;
	}
Tab<int> Selected;

for (int i = 0; i<TVMaps.v.Count(); i++)
	{
	if (vsel[i])
		Selected.Append(1,&i,1);
	}
if (falloffSpace == 0)
	BuildObjectPoints();
for (i = 0; i<TVMaps.v.Count(); i++)
	{
	if (vsel[i] == 0)
		{
		float closest_dist = BIGFLOAT;
		for (int j= 0; j < Selected.Count();j++)
			{
//use XY	Z space values
			if (falloffSpace == 0)
				{
				Point3 sp = GetObjectPoint(ip->GetTime(),i);
				Point3 rp = GetObjectPoint(ip->GetTime(),Selected[j]);
				float d = LengthSquared(sp-rp);
				if (d < closest_dist) closest_dist = d;

				}
			else
//use UVW space values
				{
				Point3 sp = GetPoint(ip->GetTime(),Selected[j]);
				Point3 rp = GetPoint(ip->GetTime(),i);
				float d = LengthSquared(sp-rp);
				if (d < closest_dist) closest_dist = d;
				}
			}
		if (closest_dist < sstr)
			{
			closest_dist = (float) sqrt(closest_dist);
			TVMaps.v[i].influence = 1.0f - closest_dist/str;
			ComputeFalloff(TVMaps.v[i].influence,falloff);
			}
		else TVMaps.v[i].influence = 0.0f;
		}
	}	
}

void UnwrapMod::BuildInitialMapping(Mesh *msh)
{
//build bounding box
Box3 bbox;
bbox.Init();
//normalize the length width height
for (int i = 0; i < TVMaps.f.Count(); i++)
	{
	int pcount = 3;
	if (TVMaps.f[i].flags & FLAG_QUAD)
		pcount = 4;
	for (int j = 0; j < pcount; j++)
		{
		bbox += TVMaps.f[i].pt[j];
		}

	}
Tab<int> indexList;

indexList.SetCount(TVMaps.f.Count() *4);
BitArray usedIndex;
usedIndex.SetSize(TVMaps.f.Count() *4);
usedIndex.ClearAll();

for (i = 0; i < TVMaps.f.Count()*4; i++)
	indexList[i] = -1;

for (i = 0; i < TVMaps.f.Count(); i++)
	{
	if (!(TVMaps.f[i].flags & FLAG_DEAD))
		{
		int pcount = 3;
		if (TVMaps.f[i].flags & FLAG_QUAD)
			pcount = 4;
		for (int j = 0; j < pcount; j++)
			{
			usedIndex.Set(msh->faces[i].v[j]);
			}
		}

	}

int ct = 0;
for (i = 0; i < usedIndex.GetSize(); i++)
	{
	if (usedIndex[i])
		indexList[i] = ct++;

	}

TVMaps.v.SetCount(usedIndex.NumberSet());
TVMaps.cont.SetCount(usedIndex.NumberSet());
vsel.SetSize(usedIndex.NumberSet());

//watje 10-19-99 bug 213437  to prevent a divide by 0 which gives you a huge u,v, or w value
if (bbox.Width().x == 0.0f) bbox += Point3(0.5f,0.0f,0.0f);
if (bbox.Width().y == 0.0f) bbox += Point3(0.0f,0.5f,0.0f);
if (bbox.Width().z == 0.0f) bbox += Point3(0.0f,0.0f,0.5f);

for (i = 0; i < TVMaps.f.Count(); i++)
	{
	if (!(TVMaps.f[i].flags & FLAG_DEAD))
		{
		int pcount = 3;
		if (TVMaps.f[i].flags & FLAG_QUAD)
			pcount = 4;
		TVMaps.f[i].flags &= ~FLAG_DEAD;
		for (int j = 0; j < pcount; j++)
			{
			int index;
			int a = msh->faces[i].v[j];
			index = indexList[a];
			TVMaps.f[i].t[j] = index;
			TVMaps.v[index].p.x =  TVMaps.f[i].pt[j].x/bbox.Width().x + 0.5f;
			TVMaps.v[index].p.y =  TVMaps.f[i].pt[j].y/bbox.Width().y + 0.5f;
			TVMaps.v[index].p.z =  TVMaps.f[i].pt[j].z/bbox.Width().z + 0.5f;
			TVMaps.v[index].influence =  0.f;
			TVMaps.v[index].flags =  0.f;
			TVMaps.cont[index] = NULL;
		
			}

		}
	}

//PlugControllers();
//NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);

//if (ip) ip->RedrawViews(ip->GetTime());
}



void UnwrapMod::BuildInitialMapping(PatchMesh *msh)
{
//build bounding box
Box3 bbox;
bbox.Init();
//normalize the length width height
for (int i = 0; i < TVMaps.f.Count(); i++)
	{
	int pcount = 3;
	if (TVMaps.f[i].flags & FLAG_QUAD)
		pcount = 4;
	for (int j = 0; j < pcount; j++)
		{
		bbox += TVMaps.f[i].pt[j];
		}

	}
Tab<int> indexList;

indexList.SetCount(TVMaps.f.Count() *4);
BitArray usedIndex;
usedIndex.SetSize(TVMaps.f.Count() *4);
usedIndex.ClearAll();

for (i = 0; i < TVMaps.f.Count()*4; i++)
	indexList[i] = -1;

for (i = 0; i < TVMaps.f.Count(); i++)
	{
	if (!(TVMaps.f[i].flags & FLAG_DEAD))
		{
		int pcount = 3;
		if (TVMaps.f[i].flags & FLAG_QUAD)
			pcount = 4;
		for (int j = 0; j < pcount; j++)
			{
//		usedIndex.Set(TVMaps.f[i].t[j]);
			usedIndex.Set(msh->patches[i].v[j]);
			}
		}

	}

int ct = 0;
for (i = 0; i < usedIndex.GetSize(); i++)
	{
	if (usedIndex[i])
		indexList[i] = ct++;

	}

TVMaps.v.SetCount(usedIndex.NumberSet());
TVMaps.cont.SetCount(usedIndex.NumberSet());
vsel.SetSize(usedIndex.NumberSet());

//watje 10-19-99 bug 213437  to prevent a divide by 0 which gives you a huge u,v, or w value
if (bbox.Width().x == 0.0f) bbox += Point3(0.5f,0.0f,0.0f);
if (bbox.Width().y == 0.0f) bbox += Point3(0.0f,0.5f,0.0f);
if (bbox.Width().z == 0.0f) bbox += Point3(0.0f,0.0f,0.5f);

for (i = 0; i < TVMaps.f.Count(); i++)
	{
	if (!(TVMaps.f[i].flags & FLAG_DEAD))
		{
		int pcount = 3;
		if (TVMaps.f[i].flags & FLAG_QUAD)
			pcount = 4;
		TVMaps.f[i].flags &= ~FLAG_DEAD;
		for (int j = 0; j < pcount; j++)
			{
			int index;
			int a = msh->patches[i].v[j];
			index = indexList[a];
			TVMaps.f[i].t[j] = index;
			TVMaps.v[index].p.x =  TVMaps.f[i].pt[j].x/bbox.Width().x + 0.5f;
			TVMaps.v[index].p.y =  TVMaps.f[i].pt[j].y/bbox.Width().y + 0.5f;
			TVMaps.v[index].p.z =  TVMaps.f[i].pt[j].z/bbox.Width().z + 0.5f;;
			TVMaps.v[index].influence =  0.f;
			TVMaps.v[index].flags =  0.f;
			TVMaps.cont[index] = NULL;
		
			}
		}

	}

//PlugControllers();
//NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
//if (ip) ip->RedrawViews(ip->GetTime());


}

void UnwrapMod::RemoveDeadVerts(PatchMesh *mesh, int channel)
{
	Tab<Point3> vertList;
	Tab<int> idList;
//copy over vertlist

	int ct = mesh->getNumMapVerts(channel);
	vertList.SetCount(ct);
	Point3 *tVerts = mesh->mapVerts(channel);
	for (int i = 0; i < ct; i++)
		vertList[i] = tVerts[i];

	BitArray usedList;
	usedList.SetSize(ct);
	TVPatch *tvFace = NULL;
	if (!mesh->getMapSupport(channel))
		{
		return;
		}

	tvFace = mesh->tvPatches[channel];
	if (tvFace == NULL) return;

	for (i =0; i < mesh->numPatches; i++)
		{
		int pcount = 3;
		if (mesh->patches[i].type == PATCH_QUAD) pcount = 4;

		for (int j = 0; j < pcount; j++)
			{
			int index = tvFace[i].tv[j];
			usedList.Set(index);
			}
		}
	mesh->setNumMapVerts (channel,usedList.NumberSet(),TRUE);

	int current = 0;
	tVerts = mesh->mapVerts(channel);

	for (i = 0; i < ct; i++)
		{
		if (usedList[i])
			{
			tVerts[current] = vertList[i];
//now fix up faces
			for (int j = 0; j < mesh->numPatches; j++)
				{
				int pcount = 3;
				if (mesh->patches[j].type == PATCH_QUAD) pcount = 4;

				for (int k = 0; k < pcount; k++)
					{
					int index = tvFace[j].tv[k];
					if (index == i)
						{
						tvFace[j].tv[k] = current;
						}
					}

				}
			current++;
			}
		}




}



void UnwrapMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{


	MyEnumProc dep;              
	EnumDependents(&dep);
/*
	if ((dep.Nodes.Count() > 1) && (firstPass))
		{

		ip->EnableSubObjectSelection(FALSE);
		iApplyButton->Enable(FALSE);
		EnableWindow(GetDlgItem(hParams,IDC_RADIO1),FALSE);
		EnableWindow(GetDlgItem(hParams,IDC_RADIO2),FALSE);
		EnableWindow(GetDlgItem(hParams,IDC_RADIO3),FALSE);
		EnableWindow(GetDlgItem(hParams,IDC_RADIO4),FALSE);

		EnableWindow(GetDlgItem(hParams,IDC_UNWRAP_EDIT),FALSE);
		EnableWindow(GetDlgItem(hParams,IDC_UNWRAP_SAVE),FALSE);
		EnableWindow(GetDlgItem(hParams,IDC_UNWRAP_LOAD),FALSE);
		EnableWindow(GetDlgItem(hParams,IDC_UNWRAP_RESET),FALSE);
		iMapID->Enable(FALSE);
		EnableWindow(GetDlgItem(hParams,IDC_MAP_CHAN1),FALSE);
		EnableWindow(GetDlgItem(hParams,IDC_MAP_CHAN2),FALSE);


//do unhide here
		firstPass = FALSE;
		instanced = TRUE;
		TSTR buf2 = GetString(IDS_PW_ERROR);
		TSTR buf1 = GetString(IDS_PW_INSTANCEERROR);
		MessageBox(GetCOREInterface()->GetMAXHWnd(),buf1,buf2,MB_OK|MB_TASKMODAL);
		}
	else instanced = FALSE;
	if (dep.Nodes.Count() > 1) 
		{
//		TVMaps.v.Count();
//		TVMaps.f.Count();
		return;
		}
*/

	// Prepare the controller and set up mats
	Object *obj = os->obj;

	if (oldDataPresent)
		{
		oldDataPresent = FALSE;
		Tab<UVW_TVFaceClass> tempStorage;
		tempStorage = TVMaps.f;
		TriObject *tobj = (TriObject*)os->obj;

		Mesh &mesh = tobj->GetMesh();
		if (mesh.selLevel==MESH_FACE) 
			{


			TVMaps.f.SetCount(tobj->GetMesh().getNumFaces());
			int current = 0;
			for (int i = 0; i < TVMaps.f.Count(); i++)
				{
				if (tobj->GetMesh().faceSel[i])
					{
					TVMaps.f[i] = tempStorage[current];
					current++;
					}
				else TVMaps.f[i].flags |= FLAG_DEAD;
				}	
			}
		}


	if ((!os->obj->IsSubClassOf(patchObjectClassID)) && (!os->obj->IsSubClassOf(triObjectClassID)))
		{
//neither patch or NURBS convert to a mesh
		if (os->obj->CanConvertToType(triObjectClassID))
			{
			TriObject *tri = (TriObject *) os->obj->ConvertToType(t, Class_ID(TRIOBJ_CLASS_ID, 0));
			os->obj = tri;
			os->obj->UnlockObject();
			}
		
		}

//poll for material on mesh
	int CurrentChannel = 0;

	if (channel == 0)
		{
		CurrentChannel = 1;
//should be from scroller;

		}
	else if (channel == 1)
		{
		CurrentChannel = 0;
		}
	else CurrentChannel = channel;


	INode *SelfNode = dep.Nodes[0];
	BaseMtl = SelfNode->GetMtl();

	if ((os->obj->IsSubClassOf(patchObjectClassID)) &  (firstPass))
		{
		PatchObject *pobj = (PatchObject*)os->obj;
		if (ip) 
			{
			firstPass = FALSE;
			if (pobj->patch.selLevel==PATCH_PATCH ) 
				{	
				ip->EnableSubObjectSelection(FALSE);
				iApplyButton->Enable(FALSE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO1),FALSE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO2),FALSE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO3),FALSE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO4),FALSE);
				}
			else
				{
				ip->EnableSubObjectSelection(TRUE);
				iApplyButton->Enable(TRUE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO1),TRUE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO2),TRUE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO3),TRUE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO4),TRUE);

				}


			}

		}
	else if ((os->obj->IsSubClassOf(triObjectClassID)) && (firstPass))
		{
		TriObject *tobj = (TriObject*)os->obj;
		if (ip) 
			{
			firstPass = FALSE;
			if (tobj->GetMesh().selLevel==MESH_FACE) 
				{
				ip->EnableSubObjectSelection(FALSE);
				iApplyButton->Enable(FALSE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO1),FALSE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO2),FALSE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO3),FALSE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO4),FALSE);

				}
			else
				{
				ip->EnableSubObjectSelection(TRUE);
				iApplyButton->Enable(TRUE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO1),TRUE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO2),TRUE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO3),TRUE);
				EnableWindow(GetDlgItem(hParams,IDC_RADIO4),TRUE);

				}


			}
		}


	if (os->obj->IsSubClassOf(patchObjectClassID))
		{
		objType = IS_PATCH;
		PatchObject *pobj = (PatchObject*)os->obj;
		MeshTopoData *d  = (MeshTopoData*)mc.localData;
		if (!d) 
			{
			mc.localData = d = new MeshTopoData(pobj->patch);
			d->SetFaceSel(pobj->patch.patchSel, this, t);
			}
		if (((editMod==this) && (!d->GetPatch())) || (updateCache))
			{
			d->SetCache(pobj->patch);
			d->SetFaceSel(pobj->patch.patchSel, this, t);
			updateCache = FALSE;
			}

		
		BitArray faceSel = d->faceSel;
		faceSel.SetSize(pobj->patch.getNumPatches(),TRUE);
		if ( (ip && (ip->GetSubObjectLevel() > 0) ))
			{

			pobj->patch.patchSel = faceSel;
			if (showVerts)
				{
//select verts based on the current tverts;
				BitArray vertSel;
				vertSel.SetSize(pobj->patch.getNumVerts(),TRUE);
				vertSel.ClearAll();
				for(int sv = 0; sv < TVMaps.f.Count();sv++)
					{
					if (!(TVMaps.f[sv].flags & FLAG_DEAD))
						{

						int pcount = 3;
						if (TVMaps.f[sv].flags & FLAG_QUAD) pcount = 4;
						for (int j = 0; j < pcount ; j++)
							{
							int index = TVMaps.f[sv].t[j];
//6-29--99 watje
							if ((index < vsel.GetSize()) && (vsel[index] ==1) && (sv < pobj->patch.numPatches))
//							if (vsel[index] ==1)
								{
								int findex = pobj->patch.patches[sv].v[j];
//6-29--99 watje
								if ((findex < vertSel.GetSize()) && (findex >=0))
									vertSel.Set(findex,1);
								}
							}
						}
					}
				pobj->patch.vertSel = vertSel;

				pobj->patch.SetDispFlag(DISP_SELPATCHES|DISP_LATTICE|DISP_SELVERTS|DISP_VERTTICKS);
				}
			else pobj->patch.SetDispFlag(DISP_SELPATCHES|DISP_LATTICE);
			}

//		pobj->patch.SetDispFlag(DISP_SELPATCHES|DISP_LATTICE);

		
		if (!tmControl || (flags&CONTROL_OP) || (flags&CONTROL_INITPARAMS)) 
			InitControl(t);


//if planar mode build vert and face list
		if ( (ip && (ip->GetSubObjectLevel() == 1) ))
			{
//			Matrix3 tm;	
//			tm = Inverse(CompMatrix(t,&mc,NULL));
//copy verts		
//			gverts.d.ZeroCount();
			gfaces.ZeroCount();
			gverts.d.SetCount(faceSel.GetSize()*4);

			gverts.sel.SetSize(faceSel.GetSize()*4,1);
			gverts.sel.ClearAll();
		
			Patch *tf = pobj->patch.patches;
			PatchVert *tp = pobj->patch.verts;
//			VertexLookUpListClass v;

//isolate a vertex list of just the selected faces
			for (int i = 0; i < faceSel.GetSize(); i++)
				{
				if (faceSel[i])
					{
					int pcount = 3;
					if (tf[i].type == PATCH_QUAD) pcount = 4;
					for (int j = 0; j < pcount; j++)
						{
						int index = tf[i].v[j];
//						gverts.addPoint(index, tp[index].p*tm);
						gverts.addPoint(index, tp[index].p);
						}

					}
				}
//build new tv faces
			gfaces.SetCount(faceSel. NumberSet());
			int ct = 0;
			for (i = 0; i < faceSel.GetSize(); i++)
				{
				if (faceSel[i])
					{
					UVW_TVFaceClass t;
					t.FaceIndex = i;
					int pcount = 3;
					t.flags = 0;
					if (tf[i].type == PATCH_QUAD) 
						{
						pcount = 4;
						t.flags = FLAG_QUAD;
						}

					for (int j = 0; j < pcount; j++)
						{
//find indes in our vert array
						t.t[j] = (int)tf[i].v[j];

//						for (int k = 0; k < gverts.d.Count(); k++)
//							{
//							if (gverts.d[k].index == (int)tf[i].v[j])
//								{
//								t.t[j] = k;
//								}
//							}

						}
					gfaces[ct++] = t;


					}
				}
	
			}
		}
	else if (os->obj->IsSubClassOf(triObjectClassID))
		{
		objType = IS_MESH;
		TriObject *tobj = (TriObject*)os->obj;
		MeshTopoData *d  = (MeshTopoData*)mc.localData;
		if (!d) 
			{
			mc.localData = d = new MeshTopoData(tobj->GetMesh());
			d->SetFaceSel(tobj->GetMesh().faceSel, this, t);
			}
		if ( ((editMod==this) && (!d->GetMesh())) || (updateCache))
			{
			d->SetCache(tobj->GetMesh());
			d->SetFaceSel(tobj->GetMesh().faceSel, this, t);
			updateCache = FALSE;
			}

		BitArray faceSel = d->faceSel;


		faceSel.SetSize(tobj->GetMesh().getNumFaces(),TRUE);

		if ( (ip && (ip->GetSubObjectLevel() > 0) ))
			{

			tobj->GetMesh().faceSel = faceSel;

			if (showVerts)
				{
//select verts based on the current tverts;
				BitArray vertSel;
				vertSel.SetSize(tobj->GetMesh().getNumVerts(),TRUE);
				vertSel.ClearAll();
				for(int sv = 0; sv < TVMaps.f.Count();sv++)
					{
					if (!(TVMaps.f[sv].flags & FLAG_DEAD))
						{
						int pcount = 3;
						if (TVMaps.f[sv].flags & FLAG_QUAD) pcount = 4;
						for (int j = 0; j < pcount ; j++)
							{
							int index = TVMaps.f[sv].t[j];
//6-29--99 watje
							if ((index < vsel.GetSize()) && (vsel[index] ==1) && (sv<tobj->GetMesh().numFaces))
//							if (vsel[index] ==1)
								{
								int findex = tobj->GetMesh().faces[sv].v[j];
//6-29--99 watje
								if ((findex < vertSel.GetSize()) && (findex >=0))
									vertSel.Set(findex,1);
								}
							}
						}
					}
				tobj->GetMesh().vertSel = vertSel;
				tobj->GetMesh().SetDispFlag(DISP_SELFACES|DISP_VERTTICKS|DISP_SELVERTS);
//done++;
				}
			else
				{
				tobj->GetMesh().SetDispFlag(DISP_SELFACES);
//done++;
				}

			}

		
		if (!tmControl || (flags&CONTROL_OP) || (flags&CONTROL_INITPARAMS)) 
			InitControl(t);


//if planar mode build vert and face list

		if ( (ip && (ip->GetSubObjectLevel() == 1) ))
			{
			gfaces.ZeroCount();
			gverts.d.SetCount(faceSel.GetSize()*4);

			gverts.sel.SetSize(faceSel.GetSize()*4,1);
			gverts.sel.ClearAll();

			Face *tf = tobj->GetMesh().faces;
			Point3 *tp = tobj->GetMesh().verts;

//isolate a vertex list of just the selected faces
			for (int i = 0; i < faceSel.GetSize(); i++)
				{
				if (faceSel[i])
					{
					for (int j = 0; j < 3; j++)
						{
						int index = tf[i].v[j];
						gverts.addPoint(index, tp[index]);
						}

					}
				}
//build new tv faces
			gfaces.SetCount(faceSel. NumberSet());
			int ct = 0;
			for (i = 0; i < faceSel.GetSize(); i++)
				{
				if (faceSel[i])
					{
					UVW_TVFaceClass t;
					t.FaceIndex = i;
					t.flags = 0;

					for (int j = 0; j < 3; j++)
						{
//find indes in our vert array
						t.t[j] = (int)tf[i].v[j];


						}

					gfaces[ct++] = t;


					}
				}
	
			}
		}


	BOOL reset = FALSE;
	if (os->obj->IsSubClassOf(patchObjectClassID))
		{
// is whole mesh
		PatchObject *pobj = (PatchObject*)os->obj;
		PatchMesh &patch = pobj->patch;
		if (TVMaps.f.Count() != patch.getNumPatches())
			reset =TRUE;

		}
	else if (os->obj->IsSubClassOf(triObjectClassID)) 
		{
		TriObject *tobj = (TriObject*)os->obj;
				// Apply our mapping
		Mesh &mesh = tobj->GetMesh();
		if (TVMaps.f.Count() != mesh.getNumFaces())
			reset = TRUE;
	}


//check is TVMap == 0 then get data from mesh, patch, or nurbs and copy to our data
	if ((TVMaps.v.Count() == 0) || (reset))
		{
///is patch
		if (os->obj->IsSubClassOf(patchObjectClassID))
			{
// is whole mesh

			PatchObject *pobj = (PatchObject*)os->obj;
			// Apply our mapping
			PatchMesh &patch = pobj->patch;

					
			if ( (patch.selLevel==PATCH_PATCH) && (patch.patchSel.NumberSet() == 0) ) 
				{
				return;
				}
	

//loop through all maps
//get channel from mesh
			TVMaps.channel = CurrentChannel;
					
	
//get from mesh based on cahne
			Point3 *tVerts = NULL;
			TVPatch *tvFace = NULL;
			if (!patch.getMapSupport(CurrentChannel))
				{
				patch.setNumMaps(CurrentChannel+1);
				}

			tVerts = patch.tVerts[CurrentChannel];
			tvFace = patch.tvPatches[CurrentChannel];

			if (patch.selLevel!=PATCH_PATCH ) 
				{
//copy into our structs
				TVMaps.f.SetCount(patch.getNumPatches());
				TVMaps.v.SetCount(patch.getNumMapVerts(CurrentChannel));
				TVMaps.cont.SetCount(patch.getNumMapVerts(CurrentChannel));

				vsel.SetSize(patch.getNumMapVerts (CurrentChannel));


				for (int j=0; j<TVMaps.f.Count(); j++) 
					{
					TVMaps.f[j].flags = 0;
					if (tvFace == NULL)
						{
						TVMaps.f[j].t[0] = 0;
						TVMaps.f[j].t[1] = 0;
						TVMaps.f[j].t[2] = 0;
						TVMaps.f[j].t[3] = 0;
						TVMaps.f[j].FaceIndex = j;
						TVMaps.f[j].MatID = patch.getPatchMtlIndex(j);
						TVMaps.f[j].flags = 0;
						int pcount = 3;
						if (patch.patches[j].type == PATCH_QUAD) 
							{
							TVMaps.f[j].flags |= FLAG_QUAD;
							pcount = 4;
							}
								 
						for (int k = 0; k < pcount; k++)
							{
							int index = patch.patches[j].v[k];
							TVMaps.f[j].pt[k] = patch.verts[index].p;
							}

						}
					else
						{
						TVMaps.f[j].t[0] = tvFace[j].tv[0];
						TVMaps.f[j].t[1] = tvFace[j].tv[1];
						TVMaps.f[j].t[2] = tvFace[j].tv[2];
						TVMaps.f[j].t[3] = tvFace[j].tv[3];
						TVMaps.f[j].FaceIndex = j;
						TVMaps.f[j].MatID = patch.getPatchMtlIndex(j);

						int pcount = 3;

						if (patch.patches[j].type == PATCH_QUAD) 
							{
							TVMaps.f[j].flags = FLAG_QUAD;
							pcount = 4;
							}
						else TVMaps.f[j].flags = 0;

						if ((patch.selLevel==PATCH_PATCH ) && (patch.patchSel[j] == 0))
							TVMaps.f[j].flags |= FLAG_DEAD;

						for (int k = 0; k < pcount; k++)
							{
							int index = patch.patches[j].v[k];
							TVMaps.f[j].pt[k] = patch.verts[index].p;
							}



						}
					}
				for (    j=0; j<TVMaps.v.Count(); j++) 
					{
					TVMaps.cont[j] = NULL;
					TVMaps.v[j].flags = 0;
					if (tVerts)
						TVMaps.v[j].p  = tVerts[j];
					else TVMaps.v[j].p  = Point3(0.0f,0.0f,0.0f);
					TVMaps.v[j].influence = 0.0f;
					}
				if (tvFace == NULL) BuildInitialMapping(&patch);
				}
			else
				{

//copy into our structs
				TVMaps.f.SetCount(patch.getNumPatches());

				TVMaps.v.SetCount(patch.getNumMapVerts (CurrentChannel));
				TVMaps.cont.SetCount(patch.getNumMapVerts (CurrentChannel));

				vsel.SetSize(patch.getNumMapVerts (CurrentChannel));

				for (int j=0; j<TVMaps.f.Count(); j++) 
					{
					TVMaps.f[j].flags = 0;
					if (tvFace == NULL)
						{
						TVMaps.f[j].t[0] = 0;
						TVMaps.f[j].t[1] = 0;
						TVMaps.f[j].t[2] = 0;
						TVMaps.f[j].t[3] = 0;
						TVMaps.f[j].FaceIndex = j;
						TVMaps.f[j].MatID = patch.patches[j].getMatID();
						if (patch.patchSel[j])
							TVMaps.f[j].flags = 0;
						else TVMaps.f[j].flags = FLAG_DEAD;
						int pcount = 3;

						if (patch.patches[j].type == PATCH_QUAD) 
							{
							TVMaps.f[j].flags |= FLAG_QUAD;
							pcount = 4;
							}
						for (int k = 0; k < pcount; k++)
							{
							int index = patch.patches[j].v[k];
							TVMaps.f[j].pt[k] = patch.verts[index].p;
							}

						}
					else
						{
						TVMaps.f[j].t[0] = tvFace[j].tv[0];
						TVMaps.f[j].t[1] = tvFace[j].tv[1];
						TVMaps.f[j].t[2] = tvFace[j].tv[2];
						TVMaps.f[j].t[3] = tvFace[j].tv[3];
						TVMaps.f[j].FaceIndex = j;
						TVMaps.f[j].MatID = patch.patches[j].getMatID();
				

						if (patch.patchSel[j])
							TVMaps.f[j].flags = 0;
						else TVMaps.f[j].flags = FLAG_DEAD;

						int pcount = 3;
						if (patch.patches[j].type == PATCH_QUAD) 
							{
							TVMaps.f[j].flags |= FLAG_QUAD;
							pcount = 4;
							}

						for (int k = 0; k < pcount; k++)
							{
							int index = patch.patches[j].v[k];
							TVMaps.f[j].pt[k] = patch.verts[index].p;
							}

						}
					}
				for (j=0; j<TVMaps.v.Count(); j++) 
					{
					TVMaps.cont[j] = NULL;
					TVMaps.v[j].flags = FLAG_DEAD;
					if (tVerts)
						TVMaps.v[j].p  = tVerts[j];
					else TVMaps.v[j].p  = Point3(.0f,0.0f,0.0f);
//check if vertex for this face selected
					TVMaps.v[j].influence = 0.0f;

					}


				if (tvFace == NULL) BuildInitialMapping(&patch);

				for (j=0; j<TVMaps.f.Count(); j++) 
					{
					if (!(TVMaps.f[j].flags & FLAG_DEAD))
						{
						int a;
						a = TVMaps.f[j].t[0];
						TVMaps.v[a].flags = 0;
						a = TVMaps.f[j].t[1];
						TVMaps.v[a].flags = 0;
						a = TVMaps.f[j].t[2];
						TVMaps.v[a].flags = 0;
						a = TVMaps.f[j].t[3];
						TVMaps.v[a].flags = 0;
						}
					}

				}



			}
///else it is something else convert to a mesh
		else if (os->obj->IsSubClassOf(triObjectClassID)) 
	
			{

			TriObject *tobj = (TriObject*)os->obj;
				// Apply our mapping
			Mesh &mesh = tobj->GetMesh();




//get channel from mesh
			TVMaps.channel = CurrentChannel;
					
			if ( (mesh.selLevel==MESH_FACE) && (mesh.faceSel.NumberSet() == 0) ) 
				{
				return;
				}
						
	
//get from mesh based on cahne
			TVFace *tvFace = mesh.mapFaces(CurrentChannel);
			Point3 *tVerts = mesh.mapVerts(CurrentChannel);
			if (mesh.selLevel!=MESH_FACE) 
				{
//copy into our structs
				TVMaps.f.SetCount(mesh.getNumFaces());
				TVMaps.v.SetCount(mesh.getNumMapVerts (CurrentChannel));
				TVMaps.cont.SetCount(mesh.getNumMapVerts (CurrentChannel));

				vsel.SetSize(mesh.getNumMapVerts (CurrentChannel));


				for (int j=0; j<TVMaps.f.Count(); j++) 
					{
					TVMaps.f[j].flags = 0;
					if (tvFace == NULL)
						{
						TVMaps.f[j].t[0] = 0;
						TVMaps.f[j].t[1] = 0;
						TVMaps.f[j].t[2] = 0;
						TVMaps.f[j].FaceIndex = j;
						TVMaps.f[j].MatID = mesh.faces[j].getMatID();
						TVMaps.f[j].flags = 0;
						for (int k = 0; k < 3; k++)
							{
							int index = mesh.faces[j].v[k];
							TVMaps.f[j].pt[k] = mesh.verts[index];
							}
						}
					else
						{
						TVMaps.f[j].t[0] = tvFace[j].t[0];
						TVMaps.f[j].t[1] = tvFace[j].t[1];
						TVMaps.f[j].t[2] = tvFace[j].t[2];
						TVMaps.f[j].FaceIndex = j;
						TVMaps.f[j].MatID = mesh.faces[j].getMatID();
				

						TVMaps.f[j].flags = 0;
						for (int k = 0; k < 3; k++)
							{
							int index = mesh.faces[j].v[k];
							TVMaps.f[j].pt[k] = mesh.verts[index];
							}

							
						}
					}
				for (    j=0; j<TVMaps.v.Count(); j++) 
					{
					TVMaps.cont[j] = NULL;
					TVMaps.v[j].flags = 0;
					if (tVerts)
						TVMaps.v[j].p  = tVerts[j];
					else TVMaps.v[j].p  = Point3(.0f,0.0f,0.0f);
					TVMaps.v[j].influence = 0.0f;
					}
				if (tvFace == NULL) BuildInitialMapping(&mesh);
				}
			else
				{
//copy into our structs
				TVMaps.f.SetCount(mesh.getNumFaces());

				TVMaps.v.SetCount(mesh.getNumMapVerts (CurrentChannel));
				TVMaps.cont.SetCount(mesh.getNumMapVerts (CurrentChannel));

				vsel.SetSize(mesh.getNumMapVerts (CurrentChannel));


				for (int j=0; j<TVMaps.f.Count(); j++) 
					{
					TVMaps.f[j].flags = 0;
					if (tvFace == NULL)
						{
						TVMaps.f[j].t[0] = 0;
						TVMaps.f[j].t[1] = 0;
						TVMaps.f[j].t[2] = 0;
						TVMaps.f[j].FaceIndex = j;
						TVMaps.f[j].MatID = mesh.faces[j].getMatID();
						if (mesh.faceSel[j])
							TVMaps.f[j].flags = 0;
						else TVMaps.f[j].flags = FLAG_DEAD;
						for (int k = 0; k < 3; k++)
							{
							int index = mesh.faces[j].v[k];
							TVMaps.f[j].pt[k] = mesh.verts[index];
							}
						}
					else
						{
						TVMaps.f[j].t[0] = tvFace[j].t[0];
						TVMaps.f[j].t[1] = tvFace[j].t[1];
						TVMaps.f[j].t[2] = tvFace[j].t[2];
						TVMaps.f[j].FaceIndex = j;
						TVMaps.f[j].MatID = mesh.faces[j].getMatID();
				
						if (mesh.faceSel[j])
							TVMaps.f[j].flags = 0;
						else TVMaps.f[j].flags = FLAG_DEAD;
						for (int k = 0; k < 3; k++)
							{
							int index = mesh.faces[j].v[k];
							TVMaps.f[j].pt[k] = mesh.verts[index];
							}
								
						}
					}
				for (j=0; j<TVMaps.v.Count(); j++) 
					{
					TVMaps.cont[j] = NULL;
					TVMaps.v[j].flags = FLAG_DEAD;
					if (tVerts)
						TVMaps.v[j].p  = tVerts[j];
					else TVMaps.v[j].p  = Point3(0.0f,0.0f,0.0f);
//check if vertex for this face selected
					TVMaps.v[j].influence = 0.0f;

					}
				if (tvFace == NULL) BuildInitialMapping(&mesh);
				for (j=0; j<TVMaps.f.Count(); j++) 
					{
					if (TVMaps.f[j].flags != FLAG_DEAD)
						{
						int a;
						a = TVMaps.f[j].t[0];
						TVMaps.v[a].flags = 0;
						a = TVMaps.f[j].t[1];
						TVMaps.v[a].flags = 0;
						a = TVMaps.f[j].t[2];
						TVMaps.v[a].flags = 0;
						}
					}


				}


			}

		BuildMatIDList();

			
		}
//we already have edits so just copy them into the  tv faces/verts
	if (TVMaps.v.Count() != 0)
		{
//else copy our data into the mesh,patch or nurbs tv data
///is patch
			if (os->obj->IsSubClassOf(patchObjectClassID))
				{
// is whole mesh
				PatchObject *pobj = (PatchObject*)os->obj;
				// Apply our mapping
				PatchMesh &patch = pobj->patch;

//fix this get the channels from mesh
//				int NumChannels = 1;

//loop through all maps
//				for (int i =0; i<NumChannels;i++)
					{	
//get channel from mesh
//					int CurrentChannel = 0;
					TVMaps.channel = CurrentChannel;
					
	
//get from mesh 

					if (!patch.getMapSupport(CurrentChannel) )
						{
						patch.setNumMaps (CurrentChannel+1);
						}

					TVPatch *tvFace = patch.tvPatches[CurrentChannel];

					
					int tvFaceCount =  patch.numPatches;

					if (patch.selLevel!=PATCH_PATCH) 
						{
//copy into mesh struct
						if (!tvFace) 
							{
			// Create tvfaces and init to 0
							patch.setNumMapPatches(CurrentChannel,patch.getNumPatches());
							tvFace = patch.tvPatches[CurrentChannel];
							for (int k=0; k<patch.getNumPatches(); k++)
								{	
								for (int j=0; j<4; j++) 
									{
									tvFace[k].tv[j] = 0;			
									}
								}
							}
						for (int k=0; k<tvFaceCount; k++) 
							{
							if (k < TVMaps.f.Count())
								{
								tvFace[k].tv[0] = TVMaps.f[k].t[0];
								tvFace[k].tv[1] = TVMaps.f[k].t[1];
								tvFace[k].tv[2] = TVMaps.f[k].t[2];
								tvFace[k].tv[3] = TVMaps.f[k].t[3];
								}
							else{
								tvFace[k].tv[0] = 0;
								tvFace[k].tv[1] = 0;
								tvFace[k].tv[2] = 0;
								tvFace[k].tv[3] = 0;
								}
							}
//match verts
						patch.setNumMapVerts (CurrentChannel,TVMaps.v.Count());
						Point3 *tVerts = patch.tVerts[CurrentChannel];
						for (    k=0; k<TVMaps.v.Count(); k++) 
							tVerts[k] = GetPoint(t,k);
		
						}
					else
						{
//copy into mesh struct
						if (!tvFace) 
							{
			// Create tvfaces and init to 0
							patch.setNumMapPatches (CurrentChannel,patch.getNumPatches());
							tvFace = patch.tvPatches[CurrentChannel];
							for (int k=0; k<patch.getNumPatches(); k++)
								{	
								for (int j=0; j<4; j++) 
									{
									tvFace[k].tv[j] = 0;			
									}
								}
							}
						int offset = patch.getNumMapVerts (CurrentChannel);
						int current = 0;
						for (int k=0; k<tvFaceCount; k++) 
//						for (int k=0; k<TVMaps.f.Count(); k++) 
							{
//copy if face is selected
							if (patch.patchSel[k])
								{
//								if (current < TVMaps.f.Count())
									{
									tvFace[k].tv[0] = TVMaps.f[k].t[0]+offset;
									tvFace[k].tv[1] = TVMaps.f[k].t[1]+offset;
									tvFace[k].tv[2] = TVMaps.f[k].t[2]+offset;
									tvFace[k].tv[3] = TVMaps.f[k].t[3]+offset;
//									current++;
									}
								}
							}
//match verts
						patch.setNumMapVerts (CurrentChannel,TVMaps.v.Count()+offset,TRUE);
						Point3 *tVerts = patch.tVerts[CurrentChannel];
						for (    k=0; k<TVMaps.v.Count(); k++) 
							tVerts[k+offset] = GetPoint(t,k);
		
						}
					RemoveDeadVerts(&patch,CurrentChannel);

					}
				}


///else convert to a mesh
			else if (os->obj->IsSubClassOf(triObjectClassID)) 
				{
// is whole mesh
				TriObject *tobj = (TriObject*)os->obj;
				// Apply our mapping
				Mesh &mesh = tobj->GetMesh();

				if (!mesh.mapSupport(CurrentChannel)) {
		// allocate texture verts. Setup tv faces into a parallel
		// topology as the regular faces
					if (CurrentChannel >= mesh.getNumMaps ()) mesh.setNumMaps (CurrentChannel+1, TRUE);
					mesh.setMapSupport (CurrentChannel, TRUE);
					} 


	
				TVFace *tvFace = mesh.mapFaces(CurrentChannel);
				
				int tvFaceCount =  mesh.numFaces;

				if (mesh.selLevel!=MESH_FACE) 
					{
//copy into mesh struct

					for (int k=0; k<tvFaceCount; k++) 
						{
						if (k < TVMaps.f.Count())
							{
							tvFace[k].t[0] = TVMaps.f[k].t[0];
							tvFace[k].t[1] = TVMaps.f[k].t[1];
							tvFace[k].t[2] = TVMaps.f[k].t[2];
							}
						else 
							{
							tvFace[k].t[0] = 0;
							tvFace[k].t[1] = 0;
							tvFace[k].t[2] = 0;
							}
						}
//match verts
					mesh.setNumMapVerts (CurrentChannel, TVMaps.v.Count());
					Point3 *tVerts = mesh.mapVerts(CurrentChannel);
					for (    k=0; k<TVMaps.v.Count(); k++) 
						{
						tVerts[k] = GetPoint(t,k);
						}

		
					}
				else
					{
//copy into mesh struct
//check if mesh has existing tv faces
					int offset = mesh.getNumMapVerts (CurrentChannel);
					int current = 0;
					for (int k=0; k<tvFaceCount; k++) 
						{
//copy if face is selected
						if (mesh.faceSel[k]==1)
							{
//							if (current < TVMaps.f.Count())
								{
								tvFace[k].t[0] = TVMaps.f[k].t[0] + offset;
								tvFace[k].t[1] = TVMaps.f[k].t[1] + offset;
								tvFace[k].t[2] = TVMaps.f[k].t[2] + offset;
//								current++;
								}
							}
						}
//add our verts
					mesh.setNumMapVerts (CurrentChannel,TVMaps.v.Count()+offset,TRUE);
					Point3 *tVerts = mesh.mapVerts(CurrentChannel);
					for (    k=0; k<TVMaps.v.Count(); k++) 
						tVerts[k+offset] = GetPoint(t,k);

							

					}
				mesh.DeleteIsoMapVerts(CurrentChannel);

					
				}

		}

	os->obj->UpdateValidity(TEXMAP_CHAN_NUM,LocalValidity(t));	

	}

Interval UnwrapMod::LocalValidity(TimeValue t)
	{
	Interval iv = FOREVER;
	for (int i=0; i<TVMaps.cont.Count(); i++) {
		if (TVMaps.cont[i]) {
			TVMaps.cont[i]->GetValue(t,&TVMaps.v[i].p,iv);
			}
		}
	return iv;
	}

RefTargetHandle UnwrapMod::GetReference(int i)
	{
		if (i==0) return tmControl;
		if (i<11) return map[i-1];
		return TVMaps.cont[i-11];
	}

void UnwrapMod::SetReference(int i, RefTargetHandle rtarg)
	{
		if (i==0) tmControl = (Control*)rtarg;
		else if (i<11) map[i-1] = (Texmap*)rtarg;
		else TVMaps.cont[i-11] = (Control*)rtarg;
	}

int UnwrapMod::RemapRefOnLoad(int iref) 
{
if (version == 1)
	{
	if (iref == 0)
		return 1;
	else if (iref > 0)
		return iref + 10;

	}	
return iref;
}

Animatable* UnwrapMod::SubAnim(int i)
	{
	return TVMaps.cont[i];
	}

TSTR UnwrapMod::SubAnimName(int i)
	{
	TSTR buf;
//	buf.printf(_T("Point %d"),i+1);
	buf.printf(_T("%s %d"),GetString(IDS_PW_POINT),i+1);
	return buf;
	}


RefTargetHandle UnwrapMod::Clone(RemapDir& remap)
	{
	UnwrapMod *mod = new UnwrapMod;
	mod->TVMaps    = TVMaps;
//	mod->tvert     = tvert;
//	mod->tvFace    = tvFace;
//	mod->cont      = cont;
	mod->vsel      = vsel;
	mod->zoom      = zoom;
	mod->aspect    = aspect;
	mod->xscroll   = xscroll;
	mod->yscroll   = yscroll;
	mod->uvw       = uvw;
	mod->showMap   = showMap;
	mod->update    = update;
	mod->lineColor = lineColor;
	mod->selColor  =	selColor;
	mod->rendW     = rendW;
	mod->rendH     = rendH;
	mod->isBitmap =  isBitmap;
	mod->isBitmap =  pixelSnap;
	mod->useBitmapRes = useBitmapRes;
	mod->channel = channel;
	mod->ReplaceReference(0,remap.CloneRef(tmControl));
	for (int i=0; i<10; i++) 
		mod->ReplaceReference(i+1,map[i]);
	for (i=0; i<TVMaps.cont.Count(); i++) {
		mod->TVMaps.cont[i] = NULL;		
		if (TVMaps.cont[i]) mod->ReplaceReference(i+11,remap.CloneRef(TVMaps.cont[i]));
		}

	if (instanced)
		{
		for (i=0; i<mod->TVMaps.cont.Count(); i++) mod->DeleteReference(i+11);
		mod->TVMaps.v.Resize(0);
		mod->TVMaps.f.Resize(0);
		mod->TVMaps.cont.Resize(0);
		mod->vsel.SetSize(0);
		mod->updateCache = TRUE;
		mod->instanced = FALSE;
		}

	return mod;
	}

#define NAMEDSEL_STRING_CHUNK	0x2809
#define NAMEDSEL_ID_CHUNK		0x2810


RefResult UnwrapMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message)
	{
	for (int i = 0; i < 10; i++)
		if (hTarget==map[i]) return REF_STOP;
	switch (message) {
		case REFMSG_CHANGE:
			if (editMod==this && hView) {
				InvalidateView();
				}
			break;
		case REFMSG_TARGET_DELETED:
			{
			for (int i=0; i<10; i++) 
				{
				if (hTarget==map[i]) {
					map[i] = NULL;
					}
				}
			break;
			}

		}
	return REF_SUCCEED;
	}

#define VERTCOUNT_CHUNK	0x0100
#define VERTS_CHUNK		0x0110
#define VERTSEL_CHUNK	0x0120
#define ZOOM_CHUNK		0x0130
#define ASPECT_CHUNK	0x0140
#define XSCROLL_CHUNK	0x0150
#define YSCROLL_CHUNK	0x0160
#define IWIDTH_CHUNK	0x0170
#define IHEIGHT_CHUNK	0x0180
#define SHOWMAP_CHUNK	0x0190
#define UPDATE_CHUNK	0x0200
#define LINECOLOR_CHUNK	0x0210
#define SELCOLOR_CHUNK	0x0220
#define FACECOUNT_CHUNK	0x0230
#define FACE_CHUNK		0x0240
#define UVW_CHUNK		0x0250
#define CHANNEL_CHUNK	0x0260
#define VERTS2_CHUNK	0x0270
#define FACE2_CHUNK		0x0280
#define PREFS_CHUNK		0x0290
#define USEBITMAPRES_CHUNK		0x0300

IOResult UnwrapMod::Save(ISave *isave)
	{
	ULONG nb;
	Modifier::Save(isave);

	int vct = TVMaps.v.Count(), fct = TVMaps.f.Count();

	isave->BeginChunk(VERTCOUNT_CHUNK);
	isave->Write(&vct, sizeof(vct), &nb);
	isave->EndChunk();

	if (vct) {
		isave->BeginChunk(VERTS2_CHUNK);
		isave->Write(TVMaps.v.Addr(0), sizeof(UVW_TVVertClass)*vct, &nb);
		isave->EndChunk();
		}
	
	isave->BeginChunk(FACECOUNT_CHUNK);
	isave->Write(&fct, sizeof(fct), &nb);
	isave->EndChunk();

	if (fct) {
		isave->BeginChunk(FACE2_CHUNK);
		isave->Write(TVMaps.f.Addr(0), sizeof(UVW_TVFaceClass)*fct, &nb);
		isave->EndChunk();
		}

	isave->BeginChunk(VERTSEL_CHUNK);
	vsel.Save(isave);
	isave->EndChunk();

	isave->BeginChunk(ZOOM_CHUNK);
	isave->Write(&zoom, sizeof(zoom), &nb);
	isave->EndChunk();

	isave->BeginChunk(ASPECT_CHUNK);
	isave->Write(&aspect, sizeof(aspect), &nb);
	isave->EndChunk();

	isave->BeginChunk(XSCROLL_CHUNK);
	isave->Write(&xscroll, sizeof(xscroll), &nb);
	isave->EndChunk();

	isave->BeginChunk(YSCROLL_CHUNK);
	isave->Write(&yscroll, sizeof(yscroll), &nb);
	isave->EndChunk();

	isave->BeginChunk(IWIDTH_CHUNK);
	isave->Write(&rendW, sizeof(rendW), &nb);
	isave->EndChunk();

	isave->BeginChunk(IHEIGHT_CHUNK);
	isave->Write(&rendH, sizeof(rendH), &nb);
	isave->EndChunk();

	isave->BeginChunk(UVW_CHUNK);
	isave->Write(&uvw, sizeof(uvw), &nb);
	isave->EndChunk();

	isave->BeginChunk(SHOWMAP_CHUNK);
	isave->Write(&showMap, sizeof(showMap), &nb);
	isave->EndChunk();

	isave->BeginChunk(UPDATE_CHUNK);
	isave->Write(&update, sizeof(update), &nb);
	isave->EndChunk();

	isave->BeginChunk(LINECOLOR_CHUNK);
	isave->Write(&lineColor, sizeof(lineColor), &nb);
	isave->EndChunk();

	isave->BeginChunk(SELCOLOR_CHUNK);
	isave->Write(&selColor, sizeof(selColor), &nb);
	isave->EndChunk();

	isave->BeginChunk(CHANNEL_CHUNK);
	isave->Write(&channel, sizeof(channel), &nb);
	isave->EndChunk();

	isave->BeginChunk(PREFS_CHUNK);
	isave->Write(&lineColor, sizeof(lineColor), &nb);
	isave->Write(&selColor, sizeof(selColor), &nb);
	isave->Write(&weldThreshold, sizeof(weldThreshold), &nb);
	isave->Write(&update, sizeof(update), &nb);
	isave->Write(&showVerts, sizeof(showVerts), &nb);
	isave->Write(&midPixelSnap, sizeof(midPixelSnap), &nb);
	isave->EndChunk();

		if (namedSel.Count()) {
			isave->BeginChunk(0x2806);			
			for (int i=0; i<namedSel.Count(); i++) {
				isave->BeginChunk(NAMEDSEL_STRING_CHUNK);
				isave->WriteWString(*namedSel[i]);
				isave->EndChunk();

				isave->BeginChunk(NAMEDSEL_ID_CHUNK);
				isave->Write(&ids[i],sizeof(DWORD),&nb);
				isave->EndChunk();
				}
			isave->EndChunk();
			}
	if (useBitmapRes)
		{
		isave->BeginChunk(USEBITMAPRES_CHUNK);
		isave->EndChunk();
		}

		
	return IO_OK;
	}


void UnwrapMod::LoadUVW(HWND hWnd)
{
static TCHAR fname[256] = {'\0'};
OPENFILENAME ofn;
memset(&ofn,0,sizeof(ofn));
FilterList fl;
fl.Append( GetString(IDS_PW_UVWFILES));
fl.Append( _T("*.uvw"));		
TSTR title = GetString(IDS_PW_LOADOBJECT);

ofn.lStructSize     = sizeof(OPENFILENAME);
ofn.hwndOwner       = hWnd;
ofn.lpstrFilter     = fl;
ofn.lpstrFile       = fname;
ofn.nMaxFile        = 256;    
//ofn.lpstrInitialDir = ip->GetDir(APP_EXPORT_DIR);
ofn.Flags           = OFN_HIDEREADONLY|OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST;
ofn.lpstrDefExt     = _T("uvw");
ofn.lpstrTitle      = title;


if (GetOpenFileName(&ofn)) {
//load stuff here  stuff here
	FILE *file = fopen(fname,_T("rb"));

	for (int i = 0; i < TVMaps.cont.Count(); i++)
		{
		if (TVMaps.cont[i]) TVMaps.cont[i]->DeleteThis();
		}

	int vct = TVMaps.v.Count(), fct = TVMaps.f.Count();

	fread(&vct, sizeof(vct), 1,file);

	TVMaps.v.SetCount(vct);
	vsel.SetSize(vct);

	TVMaps.cont.SetCount(vct);
	for (i = 0; i < vct; i++)
		TVMaps.cont[i] = NULL;

	if (vct) {
		fread(TVMaps.v.Addr(0), sizeof(UVW_TVVertClass)*vct, 1,file);
		}
	
	fread(&fct, sizeof(fct), 1,file);
	TVMaps.f.SetCount(fct);

	if (fct) {
		fread(TVMaps.f.Addr(0), sizeof(UVW_TVFaceClass)*fct, 1,file);
		}

	fclose(file);

	}

}
void UnwrapMod::SaveUVW(HWND hWnd)
{
static TCHAR fname[256] = {'\0'};
OPENFILENAME ofn;
memset(&ofn,0,sizeof(ofn));
FilterList fl;
fl.Append( GetString(IDS_PW_UVWFILES));
fl.Append( _T("*.uvw"));		
TSTR title = GetString(IDS_PW_SAVEOBJECT);

ofn.lStructSize     = sizeof(OPENFILENAME);
ofn.hwndOwner       = hWnd;
ofn.lpstrFilter     = fl;
ofn.lpstrFile       = fname;
ofn.nMaxFile        = 256;    
//ofn.lpstrInitialDir = ip->GetDir(APP_EXPORT_DIR);
ofn.Flags           = OFN_HIDEREADONLY|OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST;
ofn.lpstrDefExt     = _T("uvw");
ofn.lpstrTitle      = title;

tryAgain:
if (GetSaveFileName(&ofn)) {
	if (DoesFileExist(fname)) {
		TSTR buf1;
		TSTR buf2 = GetString(IDS_PW_SAVEOBJECT);
		buf1.printf(GetString(IDS_PW_FILEEXISTS),fname);
		if (IDYES!=MessageBox(
			hParams,
			buf1,buf2,MB_YESNO|MB_ICONQUESTION)) {
			goto tryAgain;
			}
		}
//save stuff here
//	theAsciiOut.OutputObject(node,fname);
// this is timed slice so it will not save animation not sure how to save controller info but will neeed to later on in other plugs

	FILE *file = fopen(fname,_T("wb"));
	int vct = TVMaps.v.Count(), fct = TVMaps.f.Count();

//	isave->BeginChunk(VERTCOUNT_CHUNK);
//	isave->Write(&vct, sizeof(vct), &nb);
//	isave->EndChunk();
	fwrite(&vct, sizeof(vct), 1,file);

	if (vct) {
//		isave->BeginChunk(VERTS2_CHUNK);
//		isave->Write(TVMaps.v.Addr(0), sizeof(UVW_TVVertClass)*vct, &nb);
//		isave->EndChunk();
		fwrite(TVMaps.v.Addr(0), sizeof(UVW_TVVertClass)*vct, 1,file);
		}
	
//	isave->BeginChunk(FACECOUNT_CHUNK);
//	isave->Write(&fct, sizeof(fct), &nb);
//	isave->EndChunk();
	fwrite(&fct, sizeof(fct), 1,file);

	if (fct) {
//		isave->BeginChunk(FACE2_CHUNK);
//		isave->Write(TVMaps.f.Addr(0), sizeof(UVW_TVFaceClass)*fct, &nb);
//		isave->EndChunk();
		fwrite(TVMaps.f.Addr(0), sizeof(UVW_TVFaceClass)*fct, 1,file);
		}

	fclose(file);
	}

}


IOResult UnwrapMod::LoadNamedSelChunk(ILoad *iload) {	
	IOResult res;
	DWORD ix=0;
	ULONG nb;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
		case NAMEDSEL_STRING_CHUNK: {
			TCHAR *name;
			res = iload->ReadWStringChunk(&name);
			//AddSet(TSTR(name),level+1);
			TSTR *newName = new TSTR(name);
			namedSel.Append(1,&newName);				
			ids.Append(1,&ix);
			ix++;
			break;
			}
		case NAMEDSEL_ID_CHUNK:
			iload->Read(&ids[ids.Count()-1],sizeof(DWORD), &nb);
			break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) return res;
	}
	return IO_OK;
}


class UnwrapPostLoadCallback:public  PostLoadCallback
{
public:
	UnwrapMod      *s;

	int oldData;
	UnwrapPostLoadCallback(UnwrapMod *r, BOOL b) {s=r;oldData = b;}
	void proc(ILoad *iload);
};

void UnwrapPostLoadCallback::proc(ILoad *iload)
{
	if (!oldData)
		{
		for (int i=0; i<10; i++) 
			s->ReplaceReference(i+1,NULL);
		}
	delete this;
}



IOResult UnwrapMod::Load(ILoad *iload)
	{

	version = 2;
	IOResult res;
	ULONG nb;
	Modifier::Load(iload);
	int ct, i;
//check for backwards compatibility
	useBitmapRes = FALSE;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case 0x2806:
				res = LoadNamedSelChunk(iload);
				break;

			case VERTCOUNT_CHUNK:
				iload->Read(&ct, sizeof(ct), &nb);
				TVMaps.v.SetCount(ct);
				TVMaps.cont.SetCount(ct);
				vsel.SetSize(ct);
				for (i=0; i<ct; i++) TVMaps.cont[i] = NULL;				
				break;
			case FACECOUNT_CHUNK:
				iload->Read(&ct, sizeof(ct), &nb);
				TVMaps.f.SetCount(ct);
				break;
//old way here for legacy reason only
			case FACE_CHUNK:
				{
				version = 1;
				oldDataPresent = TRUE;
				Tab<TVFace> f;
				f.SetCount(TVMaps.f.Count());
				iload->Read(f.Addr(0), sizeof(TVFace)*TVMaps.f.Count(), &nb);
				for (i=0;i<TVMaps.f.Count();i++)
					{
					TVMaps.f[i].t[0] = f[i].t[0];
					TVMaps.f[i].t[1] = f[i].t[1];
					TVMaps.f[i].t[2] = f[i].t[2];
					TVMaps.f[i].flags = 0;
					}

				break;
				}
//old way here for legacy reason only
			case VERTS_CHUNK:
				{
				Tab<Point3> p;
				p.SetCount(TVMaps.v.Count());
				oldDataPresent = TRUE;

				iload->Read(p.Addr(0), sizeof(Point3)*TVMaps.v.Count(), &nb);

				for (i=0;i<TVMaps.v.Count();i++)
					{
					TVMaps.v[i].p = p[i];
					TVMaps.v[i].flags = 0;
					TVMaps.v[i].influence = 0.0f;
					}
				break;
				}
			case FACE2_CHUNK:
				
				iload->Read(TVMaps.f.Addr(0), sizeof(UVW_TVFaceClass)*TVMaps.f.Count(), &nb);

				break;
			case VERTS2_CHUNK:
				iload->Read(TVMaps.v.Addr(0), sizeof(UVW_TVVertClass)*TVMaps.v.Count(), &nb);
				break;
			case VERTSEL_CHUNK:
				vsel.Load(iload);
				break;
			case ZOOM_CHUNK:
				iload->Read(&zoom, sizeof(zoom), &nb);
				break;
			case ASPECT_CHUNK:
				iload->Read(&aspect, sizeof(aspect), &nb);
				break;
			case XSCROLL_CHUNK:
				iload->Read(&xscroll, sizeof(xscroll), &nb);
				break;
			case YSCROLL_CHUNK:
				iload->Read(&yscroll, sizeof(yscroll), &nb);
				break;
			case IWIDTH_CHUNK:
				iload->Read(&rendW, sizeof(rendW), &nb);
				break;
			case IHEIGHT_CHUNK:
				iload->Read(&rendH, sizeof(rendH), &nb);
				break;
			case SHOWMAP_CHUNK:
				iload->Read(&showMap, sizeof(showMap), &nb);
				break;
			case UPDATE_CHUNK:
				iload->Read(&update, sizeof(update), &nb);
				break;
			case LINECOLOR_CHUNK:
				iload->Read(&lineColor, sizeof(lineColor), &nb);
				break;
			case SELCOLOR_CHUNK:
				iload->Read(&selColor, sizeof(selColor), &nb);
				break;			
			case UVW_CHUNK:
				iload->Read(&uvw, sizeof(uvw), &nb);
				break;
			case CHANNEL_CHUNK:
				iload->Read(&channel, sizeof(channel), &nb);
				break;			
			case PREFS_CHUNK:
				iload->Read(&lineColor, sizeof(lineColor), &nb);
				iload->Read(&selColor, sizeof(selColor), &nb);
				iload->Read(&weldThreshold, sizeof(weldThreshold), &nb);
				iload->Read(&update, sizeof(update), &nb);
				iload->Read(&showVerts, sizeof(showVerts), &nb);
				iload->Read(&midPixelSnap, sizeof(midPixelSnap), &nb);
				break;
			case USEBITMAPRES_CHUNK:
				useBitmapRes = TRUE;
				break;			



			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	BuildMatIDList();

	UnwrapPostLoadCallback* unwrapplcb = new UnwrapPostLoadCallback(this,oldDataPresent);
	iload->RegisterPostLoadCallback(unwrapplcb);

	return IO_OK;
	}

#define FACESEL_CHUNKID			0x0210
#define FSELSET_CHUNK			0x2846


IOResult UnwrapMod::SaveLocalData(ISave *isave, LocalModData *ld) {	
	MeshTopoData *d = (MeshTopoData*)ld;


	isave->BeginChunk(FACESEL_CHUNKID);
	d->faceSel.Save(isave);
	isave->EndChunk();

	if (d->fselSet.Count()) {
		isave->BeginChunk(FSELSET_CHUNK);
		d->fselSet.Save(isave);
		isave->EndChunk();
		}

	return IO_OK;
	}

IOResult UnwrapMod::LoadLocalData(ILoad *iload, LocalModData **pld) {
	MeshTopoData *d = new MeshTopoData;
	*pld = d;
	IOResult res;	
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case FACESEL_CHUNKID:
				d->faceSel.Load(iload);
				break;
			case FSELSET_CHUNK:
				res = d->fselSet.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) return res;
	}
	return IO_OK;
}


void UnwrapMod::EditMapping(HWND hWnd)
	{
	RegisterClasses();
	if (!this->hWnd) {
		CreateDialogParam(
			hInstance,
			MAKEINTRESOURCE(IDD_UNWRAP_FLOATER),
//			hWnd,
			ip->GetMAXHWnd (),
			UnwrapFloaterDlgProc,
			(LPARAM)this);
		LoadMaterials();

	} else {
		SetForegroundWindow(this->hWnd);
		ShowWindow(this->hWnd,SW_RESTORE);
		}
	}

/*
void UnwrapMod::SynchWithMesh(Mesh &mesh)
	{
	int ct=0;
	if (mesh.selLevel==MESH_FACE) {
		for (int i=0; i<mesh.getNumFaces(); i++) {
			if (mesh.faceSel[i]) ct++;
			}
	} else {
		ct = mesh.getNumFaces();
		}
	if (ct != tvFace.Count()) {
		DeleteAllRefsFromMe();
		tvert.Resize(0);
		cont.Resize(0);
		tvFace.SetCount(ct);
		
		TVFace *tvFaceM = mesh.tvFace;
		Point3 *tVertsM = mesh.tVerts;
		int numTV = channel ? mesh.getNumVertCol() : mesh.getNumTVerts();
		if (channel) {
			tvFaceM = mesh.vcFace;
			tVertsM = mesh.vertCol;
			}

		if (mesh.selLevel==MESH_FACE) {
			// Mark tverts that are used by selected faces
			BitArray used;
			if (tvFaceM) used.SetSize(numTV);
			else used.SetSize(mesh.getNumVerts());
			for (int i=0; i<mesh.getNumFaces(); i++) {
				if (mesh.faceSel[i]) {
					if (tvFaceM) {
						for (int j=0; j<3; j++) 
							used.Set(tvFaceM[i].t[j]);
					} else {
						for (int j=0; j<3; j++) 
							used.Set(mesh.faces[i].v[j]);
						}
					}
				}

			// Now build a vmap
			Tab<DWORD> vmap;
			vmap.SetCount(used.GetSize());
			int ix=0;
			for (i=0; i<used.GetSize(); i++) {
				if (used[i]) vmap[i] = ix++;
				else vmap[i] = UNDEFINED;				
				}

			// Copy in tverts
			tvert.SetCount(ix);
			cont.SetCount(ix);
			vsel.SetSize(ix);
			ix = 0;
			Box3 box = mesh.getBoundingBox();
			for (i=0; i<used.GetSize(); i++) {
				if (used[i]) {
					cont[ix] = NULL;
					if (tvFaceM) tvert[ix++] = tVertsM[i];
					else {
						// Do a planar mapping if there are no tverts
						tvert[ix].x = mesh.verts[i].x/box.Width().x + 0.5f;
						tvert[ix].y = mesh.verts[i].y/box.Width().y + 0.5f;
						tvert[ix].z = mesh.verts[i].z/box.Width().z + 0.5f;
						ix++;
						}
					}
				}

			// Copy in face and remap indices		
			ix = 0;
			for (i=0; i<mesh.getNumFaces(); i++) {
				if (mesh.faceSel[i]) {
					if (tvFaceM) tvFace[ix] = tvFaceM[i];
					else {
						for (int j=0; j<3; j++) 
							tvFace[ix].t[j] = mesh.faces[i].v[j];
						}

					for (int j=0; j<3; j++) {
						tvFace[ix].t[j] = vmap[tvFace[ix].t[j]];
						}
					ix++;
					}
				}
		} else {
			// Just copy all the tverts and faces
			if (tvFaceM) {
				tvert.SetCount(numTV);
				cont.SetCount(numTV);
				vsel.SetSize(numTV);
				for (int i=0; i<numTV; i++) {
					tvert[i] = tVertsM[i];
					cont[i]  = NULL;
					}
				for (i=0; i<mesh.getNumFaces(); i++) {
					tvFace[i] = tvFaceM[i];
					}
			} else {
				Box3 box = mesh.getBoundingBox();
				tvert.SetCount(mesh.getNumVerts());
				cont.SetCount(mesh.getNumVerts());
				vsel.SetSize(mesh.getNumVerts());
				for (int i=0; i<mesh.getNumVerts(); i++) {
					// Do a planar mapping if there are no tverts
					tvert[i].x = mesh.verts[i].x/box.Width().x + 0.5f;
					tvert[i].y = mesh.verts[i].y/box.Width().y + 0.5f;
					tvert[i].z = mesh.verts[i].z/box.Width().z + 0.5f;
					cont[i]  = NULL;
					}
				for (i=0; i<mesh.getNumFaces(); i++) {
					for (int j=0; j<3; j++) 
						tvFace[i].t[j] = mesh.faces[i].v[j];
					}
				}
			}
		if (hView && editMod==this) {
			InvalidateView();
			}
		}
	}
*/
void UnwrapMod::GetUVWIndices(int &i1, int &i2)
	{
	switch (uvw) {
		case 0: i1 = 0; i2 = 1; break;
		case 1: i1 = 1; i2 = 2; break;
		case 2: i1 = 0; i2 = 2; break;
		}
	}


//--- Floater Dialog -------------------------------------------------


#define TOOL_HEIGHT		30
#define SPINNER_HEIGHT	30

#define WM_SETUPMOD	WM_USER+0x18de

static HIMAGELIST hToolImages = NULL;
static HIMAGELIST hOptionImages = NULL;
static HIMAGELIST hViewImages = NULL;
static HIMAGELIST hVertexImages = NULL;

class DeleteResources {
	public:
		~DeleteResources() {
			if (hToolImages) ImageList_Destroy(hToolImages);			
			if (hOptionImages) ImageList_Destroy(hOptionImages);			
			if (hViewImages) ImageList_Destroy(hViewImages);			
			if (hVertexImages) ImageList_Destroy(hVertexImages);			
			}
	};
static DeleteResources	theDelete;

void UnwrapMod::TrackRBMenu(HWND hwnd, int x, int y) {
//	hPopMenu = LoadMenu(hInst,MAKEINTRESOURCE(IDR_POPUP_MENU));
//	HMENU hMenu = getResMgr().getMenu(IDR_UNWRAP_RIGHT_MENU);
	HMENU hMenu = LoadMenu(hInstance,MAKEINTRESOURCE(IDR_UNWRAP_RIGHT_MENU));
	HMENU subMenu = GetSubMenu(hMenu, 0);
	RECT rect;

/*	CheckMenuItem(subMenu, ID_DRAG_COPY,  dragMode == DRAG_COPY   ? MF_CHECKED : MF_UNCHECKED);
	CheckMenuItem(subMenu, ID_DRAG_ROT, dragMode == DRAG_ROTATE ? MF_CHECKED : MF_UNCHECKED);
	EnableMenuItem(subMenu, ID_RENDERMAP, IsTex(CurMtl(activeSlot))?MF_ENABLED:MF_GRAYED );

	CheckMenuItem(subMenu, ID_MEDIT_ZOOM0,  zoomLevel == 0  ? MF_CHECKED : MF_UNCHECKED);
	CheckMenuItem(subMenu, ID_MEDIT_ZOOM1,  zoomLevel == 1  ? MF_CHECKED : MF_UNCHECKED);
	CheckMenuItem(subMenu, ID_MEDIT_ZOOM2,  zoomLevel == 2  ? MF_CHECKED : MF_UNCHECKED);

	EnableMenuItem(subMenu, ID_MEDIT_MAG, (CanMagnify(activeSlot)&&!isMag)?MF_ENABLED:MF_GRAYED );
*/

	GetWindowRect(hwnd, &rect);
	TrackPopupMenu(subMenu, TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, 
		rect.left+x-2, rect.top+y, 0, hWnd, NULL);
	DestroyMenu(subMenu);
	DestroyMenu(hMenu);		

	}




static BOOL CALLBACK UnwrapFloaterDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	UnwrapMod *mod = (UnwrapMod*)GetWindowLong(hWnd,GWL_USERDATA);
	//POINTS p = MAKEPOINTS(lParam);	commented out by sca 10/7/98 -- causing warning since unused.
	switch (msg) {
		case WM_INITDIALOG:
			mod = (UnwrapMod*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			SendMessage(hWnd, WM_SETICON, ICON_SMALL, GetClassLong(mod->ip->GetMAXHWnd(), GCL_HICONSM)); // mjm - 3.12.99
			mod->ip->RegisterDlgWnd(hWnd);
			mod->SetupDlg(hWnd);

			delEvent.SetEditMeshMod(mod);
			mod->ip->RegisterDeleteUser(&delEvent);

			mod->UpdateListBox();
			SendMessage( mod->hTextures, CB_SETCURSEL, mod->CurrentMap, 0 );


			break;
		case WM_SIZE:
			mod->SizeDlg();
			break;
//		case WM_RBUTTONDOWN:
//			break;

		case WM_PAINT: {
			PAINTSTRUCT ps;
			HDC hdc = BeginPaint(hWnd,&ps);
			Rect rect;
			GetClientRect(hWnd,&rect);			
			rect.top += TOOL_HEIGHT-2;
			SelectObject(hdc,GetStockObject(WHITE_BRUSH));			
			WhiteRect3D(hdc,rect,TRUE);
			EndPaint(hWnd,&ps);
			break;
			}
		case CC_SPINNER_BUTTONDOWN:
			if (LOWORD(wParam) != IDC_UNWRAP_STRSPIN) 
				{
				theHold.SuperBegin();
				mod->PlugControllers();			
				theHold.Begin();
				}
			break;

		case CC_SPINNER_CHANGE:
			if (LOWORD(wParam) == IDC_UNWRAP_STRSPIN) 
				{
				mod->RebuildDistCache();
				UpdateWindow(hWnd);
				mod->InvalidateView();
				}
			else
				{
				if (!theHold.Holding()) {
					theHold.SuperBegin();
					mod->PlugControllers();			
					theHold.Begin();
					}
			
				switch (LOWORD(wParam)) {
					case IDC_UNWRAP_USPIN:
						mod->TypeInChanged(0);
						break;
					case IDC_UNWRAP_VSPIN:
						mod->TypeInChanged(1);
						break;
					case IDC_UNWRAP_WSPIN:
						mod->TypeInChanged(2);
						break;
					}
				UpdateWindow(hWnd);
				}
			break;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
			if ( (LOWORD(wParam) == IDC_UNWRAP_STR) || (LOWORD(wParam) == IDC_UNWRAP_STRSPIN) )
				{
				mod->RebuildDistCache();
				mod->InvalidateView();
				UpdateWindow(hWnd);
				}
			else
				{
				if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) {
					theHold.Accept(_T(GetString(IDS_PW_MOVE_UVW)));
					theHold.SuperAccept(_T(GetString(IDS_PW_MOVE_UVW)));
				} else {
					theHold.Cancel();
					theHold.SuperCancel();
					mod->NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
					mod->InvalidateView();
					UpdateWindow(hWnd);
					mod->ip->RedrawViews(mod->ip->GetTime());
					}
				}
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case ID_TOOL_MOVE:
				case ID_TOOL_ROTATE:
				case ID_TOOL_SCALE:
				case ID_TOOL_WELD:
				case ID_TOOL_PAN:
				case ID_TOOL_ZOOM:
				case ID_TOOL_ZOOMREG:
				case ID_UNWRAP_MOVE:
				case ID_UNWRAP_ROTATE:
				case ID_UNWRAP_SCALE:
				case ID_UNWRAP_PAN:
				case ID_UNWRAP_WELD:
				case ID_UNWRAP_ZOOM:
				case ID_UNWRAP_ZOOMREGION:

					mod->move = mod->iMove->GetCurFlyOff();
					if (mod->move == 0)
						mod->iMove->SetTooltip(TRUE,GetString(IDS_RB_MOVE));
					else if (mod->move == 1)
						mod->iMove->SetTooltip(TRUE,GetString(IDS_PW_MOVEH));
					else if (mod->move == 2)
						mod->iMove->SetTooltip(TRUE,GetString(IDS_PW_MOVEV));
					
					mod->scale = mod->iScale->GetCurFlyOff();
					if (mod->scale == 0)
						mod->iScale->SetTooltip(TRUE,GetString(IDS_RB_SCALE));
					else if (mod->scale == 1)
						mod->iScale->SetTooltip(TRUE,GetString(IDS_PW_SCALEH));
					else if (mod->scale == 2)
						mod->iScale->SetTooltip(TRUE,GetString(IDS_PW_SCALEV));

					mod->SetMode(LOWORD(wParam));
					break;				

				case ID_TOOL_FALLOFF:
					mod->falloff = mod->iFalloff->GetCurFlyOff();
					mod->RebuildDistCache();
					mod->InvalidateView();
					break;
				case ID_TOOL_FALLOFF_SPACE:
					mod->falloffSpace = mod->iFalloffSpace->GetCurFlyOff();
					if (mod->falloffSpace)
						mod->iFalloffSpace->SetTooltip(TRUE,GetString(IDS_PW_FALLOFFSPACEUVW));
					else mod->iFalloffSpace->SetTooltip(TRUE,GetString(IDS_PW_FALLOFFSPACE));

					mod->RebuildDistCache();
					mod->InvalidateView();
					break;
				
				case ID_TOOL_INCSELECTED:
					mod->incSelected = mod->iIncSelected->GetCurFlyOff();
					if (mod->incSelected)
						mod->iIncSelected->SetTooltip(TRUE,GetString(IDS_PW_CONTRACTSELECTION));
					else mod->iIncSelected->SetTooltip(TRUE,GetString(IDS_PW_EXPANDSELECTION)); 
					mod->ExpandSelection(mod->incSelected);
					mod->InvalidateView();
					UpdateWindow(hWnd);
					break;
				case ID_UNWRAP_MIRROR:
				case ID_TOOL_MIRROR:
					mod->mirror = mod->iMirror->GetCurFlyOff();
					if (mod->mirror ==0)
						mod->iMirror->SetTooltip(TRUE,GetString(IDS_PW_MIRRORH));
					else if (mod->mirror ==1)
						mod->iMirror->SetTooltip(TRUE,GetString(IDS_PW_MIRRORV));

					mod->MirrorPoints(hWnd, mod->mirror);

					break;
				case ID_TOOL_LOCKSELECTED:
					mod->lockSelected = mod->iLockSelected->IsChecked();
					break;
				case ID_TOOL_FILTER_SELECTEDFACES:
					mod->filterSelectedFaces = mod->iFilterSelected->IsChecked();
					mod->InvalidateView();
					UpdateWindow(hWnd);
					break;
				case ID_UNWRAP_EXTENT:
				case ID_TOOL_ZOOMEXT:
					mod->zoomext = mod->iZoomExt->GetCurFlyOff();

					if (mod->zoomext ==0)
						mod->ZoomExtents();
					else mod->ZoomSelected();
					break;

				case ID_TOOL_FILTER_MATID:
					if ( HIWORD(wParam) == CBN_SELCHANGE ) {
						//get count
						mod->matid = SendMessage( mod->hMatIDs, CB_GETCURSEL, 0, 0 )-1;
						mod->SetMatFilters();

						mod->InvalidateView();
						}
					break;
				case ID_TOOL_TEXTURE_COMBO:
					if ( HIWORD(wParam) == CBN_SELCHANGE ) {
//get count
						int ct = SendMessage( mod->hTextures, CB_GETCOUNT, 0, 0 );
						int res = SendMessage( mod->hTextures, CB_GETCURSEL, 0, 0 );
//pick a new map
						if (res == (ct -2))
							{
							mod->PickMap();
							SendMessage( mod->hTextures, CB_SETCURSEL, mod->CurrentMap, 0 );
							}
						else if (res < (ct-3))
//select a current
							{
							mod->CurrentMap = res;
							mod->SetupImage();

							}

						}
					break;


				
				case ID_TOOL_UVW:
					mod->uvw = mod->iUVW->GetCurFlyOff();
					mod->InvalidateView();
					break;

				case ID_TOOL_PROP:
					SetFocus(hWnd);
					mod->PropDialog();
					break;

				case ID_TOOL_SHOWMAP:
					mod->showMap = mod->iShowMap->IsChecked();
					mod->InvalidateView();
					break;

				case ID_TOOL_SNAP:
					mod->pixelSnap = mod->iSnap->IsChecked();
//					mod->InvalidateView();
					break;

				case ID_UNWRAP_BREAK:
				case ID_TOOL_BREAK:
					mod->BreakSelected();
					mod->InvalidateView();
					break;
				case ID_UNWRAP_WELDSELECTED:
				case ID_TOOL_WELD_SEL:
					mod->WeldSelected();
					mod->InvalidateView();
					break;
				case ID_TOOL_UPDATE:
					mod->SetupImage();
					mod->InvalidateView();
					break;
				case ID_TOOL_HIDE:
					mod->hide = mod->iHide->GetCurFlyOff();
					if (mod->hide == 0)
						{
						mod->iHide->SetTooltip(TRUE,GetString(IDS_PW_HIDE));
						mod->HideSelected();
						}
					else{
						mod->iHide->SetTooltip(TRUE,GetString(IDS_PW_UNHIDE));
						mod->UnHideAll();
						}
					mod->InvalidateView();
					break;
/*
				case ID_TOOL_UNHIDE:
					mod->UnHideAll();
					mod->InvalidateView();
					break;
*/
				case ID_TOOL_FREEZE:
					mod->freeze = mod->iFreeze->GetCurFlyOff();
					if (mod->freeze == 0)
						{
						mod->iFreeze->SetTooltip(TRUE,GetString(IDS_PW_FREEZE));
						mod->FreezeSelected();
						}
					else
						{
						mod->iFreeze->SetTooltip(TRUE,GetString(IDS_PW_UNFREEZE));
						mod->UnFreezeAll();
						}
					mod->InvalidateView();
					break;
/*
				case ID_TOOL_UNFREEZE:
					mod->UnFreezeAll();
					mod->InvalidateView();
					break;
*/

				}
			break;

		case WM_CLOSE:
			DestroyWindow(hWnd);
			break;

		case WM_DESTROY:
			mod->DestroyDlg();
			mod->ip->UnRegisterDeleteUser(&delEvent);

			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

static LRESULT CALLBACK UnwrapViewProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	UnwrapMod *mod = (UnwrapMod*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_CREATE:
			break;

		case WM_SIZE:			
			if (mod) {
				mod->iBuf->Resize();
				mod->InvalidateView();
				}
			break;

		case WM_PAINT:
			if (mod) mod->PaintView();
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
		case WM_LBUTTONUP:		
		case WM_RBUTTONDOWN:
		case WM_RBUTTONUP:
		case WM_RBUTTONDBLCLK:
		case WM_MBUTTONDOWN:
		case WM_MBUTTONDBLCLK:
		case WM_MBUTTONUP:		

		case WM_MOUSEMOVE:

			return mod->mouseMan.MouseWinProc(hWnd,msg,wParam,lParam);

		default:
			return DefWindowProc(hWnd,msg,wParam,lParam);
		}	
	return 0;
	}

void UnwrapMod::DestroyDlg()
	{
	ReleaseICustToolbar(iTool);
	iTool = NULL;
	ReleaseICustToolbar(iView);
	iView = NULL;
	ReleaseICustToolbar(iOption);
	iOption = NULL;
	ReleaseICustToolbar(iFilter);
	iFilter = NULL;
	ReleaseICustToolbar(iVertex);
	iVertex = NULL;
	ReleaseICustButton(iMove   ); iMove    = NULL;
	ReleaseICustButton(iRot    ); iRot     = NULL;
	ReleaseICustButton(iScale  ); iScale   = NULL;
	ReleaseICustButton(iFalloff   ); iFalloff    = NULL;
	ReleaseICustButton(iFalloffSpace   ); iFalloffSpace    = NULL;

	ReleaseICustButton(iMirror  ); iMirror   = NULL;
	ReleaseICustButton(iWeld   ); iWeld    = NULL;
	ReleaseICustButton(iPan    ); iPan     = NULL;
	ReleaseICustButton(iZoom   ); iZoom    = NULL;
	ReleaseICustButton(iUpdate ); iUpdate  = NULL;
	ReleaseICustButton(iZoomReg); iZoomReg = NULL;
	ReleaseICustButton(iZoomExt); iZoomExt = NULL;
	ReleaseICustButton(iUVW	   ); iUVW	   = NULL;
	ReleaseICustButton(iProp   ); iProp    = NULL;
	ReleaseICustButton(iShowMap); iShowMap = NULL;
	ReleaseICustButton(iLockSelected); iLockSelected = NULL;
	ReleaseICustButton(iFilterSelected); iFilterSelected = NULL;
	ReleaseICustButton(iHide); iHide = NULL;
	ReleaseICustButton(iFreeze); iFreeze = NULL;
	ReleaseICustButton(iIncSelected); iFreeze = NULL;
	ReleaseICustButton(iSnap); iSnap = NULL;
	ReleaseISpinner(iU); iU = NULL;
	ReleaseISpinner(iV); iV = NULL;
	ReleaseISpinner(iW); iW = NULL;

	ReleaseISpinner(iStr); iStr = NULL;

	ReleaseICustButton(iWeldSelected); iWeldSelected = NULL;
	ReleaseICustButton(iBreak); iBreak = NULL;

	DestroyIOffScreenBuf(iBuf); iBuf   = NULL;
	hWnd = NULL;
	delete moveMode; moveMode = NULL;
	delete rotMode; rotMode = NULL;
	delete scaleMode; scaleMode = NULL;
	delete panMode; panMode = NULL;
	delete zoomMode; zoomMode = NULL;
	delete zoomRegMode; zoomRegMode = NULL;
	delete weldMode; weldMode = NULL;
	delete rightMode; rightMode = NULL;	
	delete middleMode; middleMode = NULL;	
	mouseMan.SetMouseProc(NULL,LEFT_BUTTON,0);
	mouseMan.SetMouseProc(NULL,RIGHT_BUTTON,0);
	mouseMan.SetMouseProc(NULL,MIDDLE_BUTTON,0);
	ip->UnRegisterDlgWnd(hWnd);

	}



void UnwrapMod::SetupDlg(HWND hWnd)
	{
	this->hWnd = hWnd;
	
	hView = GetDlgItem(hWnd,IDC_UNWRAP_VIEW);
	SetWindowLong(hView,GWL_USERDATA,(LONG)this);
	iBuf = CreateIOffScreenBuf(hView);
	iBuf->SetBkColor(RGB(150,150,150));
	viewValid    = FALSE;
	typeInsValid = FALSE;

	moveMode = new MoveMode(this);
	rotMode = new RotateMode(this);
	scaleMode = new ScaleMode(this);
	panMode = new PanMode(this);
	zoomMode = new ZoomMode(this);
	zoomRegMode = new ZoomRegMode(this);
	weldMode = new WeldMode(this);
	rightMode = new RightMouseMode(this);
	middleMode = new MiddleMouseMode(this);

	mouseMan.SetMouseProc(rightMode,RIGHT_BUTTON,1);
	mouseMan.SetMouseProc(middleMode,MIDDLE_BUTTON,2);

	iU = GetISpinner(GetDlgItem(hWnd,IDC_UNWRAP_USPIN));
	iU->LinkToEdit(GetDlgItem(hWnd,IDC_UNWRAP_U),EDITTYPE_FLOAT);
	iU->SetLimits(-9999999, 9999999, FALSE);
	iU->SetAutoScale();
	
	iV = GetISpinner(GetDlgItem(hWnd,IDC_UNWRAP_VSPIN));
	iV->LinkToEdit(GetDlgItem(hWnd,IDC_UNWRAP_V),EDITTYPE_FLOAT);
	iV->SetLimits(-9999999, 9999999, FALSE);
	iV->SetAutoScale();
	
	iW = GetISpinner(GetDlgItem(hWnd,IDC_UNWRAP_WSPIN));
	iW->LinkToEdit(GetDlgItem(hWnd,IDC_UNWRAP_W),EDITTYPE_FLOAT);
	iW->SetLimits(-9999999, 9999999, FALSE);
	iW->SetAutoScale();	

	iStr = GetISpinner(GetDlgItem(hWnd,IDC_UNWRAP_STRSPIN));
	iStr->LinkToEdit(GetDlgItem(hWnd,IDC_UNWRAP_STR),EDITTYPE_FLOAT);
	iStr->SetLimits(0, 9999999, FALSE);
	iStr->SetAutoScale();	


	iTool = GetICustToolbar(GetDlgItem(hWnd,IDC_UNWARP_TOOLBAR));
	iTool->SetBottomBorder(TRUE);	
	iTool->SetImage(hToolImages);
	iTool->AddTool(ToolSeparatorItem(5));
	iTool->AddTool(
		ToolButtonItem(CTB_CHECKBUTTON,
			0, 0, 1, 1, 16, 15, 23, 22, ID_TOOL_MOVE));
	iTool->AddTool(
		ToolButtonItem(CTB_CHECKBUTTON,
			2, 2, 3, 3, 16, 15, 23, 22, ID_TOOL_ROTATE));
	iTool->AddTool(
		ToolButtonItem(CTB_CHECKBUTTON,
			4, 4, 5, 5, 16, 15, 23, 22, ID_TOOL_SCALE));
	iTool->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,
			14, 14, 15, 15, 16, 15, 23, 22, ID_TOOL_MIRROR));
	iTool->AddTool(ToolSeparatorItem(5));
	iTool->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,
			18, 18, 19, 19, 16, 15, 23, 22, ID_TOOL_INCSELECTED));
	iTool->AddTool(ToolSeparatorItem(5));
	iTool->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,
			24, 24, 25, 25, 16, 15, 23, 22, ID_TOOL_FALLOFF));

	iTool->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,
			32, 32, 33, 33, 16, 15, 23, 22, ID_TOOL_FALLOFF_SPACE));
	

	iOption = GetICustToolbar(GetDlgItem(hWnd,IDC_UNWRAP_OPTION_TOOLBAR));
	iOption->SetBottomBorder(TRUE);	
	iOption->SetImage(hOptionImages);
	iOption->AddTool(ToolSeparatorItem(5));
	iOption->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,
			0, 0, 0, 0, 16, 15, 70, 22, ID_TOOL_UPDATE));
	iOption->AddTool(
		ToolButtonItem(CTB_CHECKBUTTON,
			0, 0, 1, 1, 16, 15, 23, 22, ID_TOOL_SHOWMAP));
	iOption->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,
			2, 2, 2, 2, 16, 15, 23, 22, ID_TOOL_UVW));
	iOption->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,
			5, 5, 5, 5, 16, 15, 23, 22, ID_TOOL_PROP));

//	iOption->AddTool(ToolSeparatorItem(5));

// get the objects materail texture list

	iOption->AddTool(ToolOtherItem(_T("combobox"), 110,	230, ID_TOOL_TEXTURE_COMBO,
		                           CBS, 2, NULL, 0));
	hTextures = iOption->GetItemHwnd(ID_TOOL_TEXTURE_COMBO);
//	SendMessage(hTextures, WM_SETFONT, (WPARAM)GetAppHFont(), MAKELONG(0, 0));
	SendMessage(hTextures, CB_ADDSTRING, 0, (LPARAM)_T("---------------------"));	
	SendMessage(hTextures, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PW_PICK));	
	SendMessage(hTextures, CB_ADDSTRING, 0, (LPARAM)_T("---------------------"));
	SendMessage(hTextures,CB_SETCURSEL, (WPARAM)CurrentMap, (LPARAM)0 );


	


	iView = GetICustToolbar(GetDlgItem(hWnd,IDC_UNWARP_VIEW_TOOLBAR));
	iView->SetBottomBorder(FALSE);	
	iView->SetImage(hViewImages);
	iView->AddTool(ToolSeparatorItem(5));

	iView->AddTool(
		ToolButtonItem(CTB_CHECKBUTTON,
			0, 0, 1, 1, 16, 15, 23, 22, ID_TOOL_PAN));
	iView->AddTool(
		ToolButtonItem(CTB_CHECKBUTTON,
			2, 2, 3, 3, 16, 15, 23, 22, ID_TOOL_ZOOM));
	iView->AddTool(
		ToolButtonItem(CTB_CHECKBUTTON,
			 4,  4,  5,  5, 16, 15, 23, 22, ID_TOOL_ZOOMREG));
	iView->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,
			 6,  6,  7,  7, 16, 15, 23, 22, ID_TOOL_ZOOMEXT));
	iView->AddTool(
		ToolButtonItem(CTB_CHECKBUTTON,
			 10, 10,  10,  10, 16, 15, 23, 22, ID_TOOL_SNAP));

/*View->AddTool(
		ToolButtonItem(CTB_CHECKBUTTON,
			 11, 11,  11,  11, 16, 15, 23, 22, ID_TOOL_LOCKSELECTED));
*/



	iVertex = GetICustToolbar(GetDlgItem(hWnd,IDC_UNWRAP_VERTS_TOOLBAR));
	iVertex->SetBottomBorder(TRUE);	
	iVertex->SetImage(hVertexImages);
	iVertex->AddTool(ToolSeparatorItem(5));

	iVertex->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,
			0, 1, 1, 1, 16, 15, 23, 22, ID_TOOL_BREAK));
	iVertex->AddTool(
		ToolButtonItem(CTB_CHECKBUTTON,
			2, 2, 3, 3, 16, 15, 23, 22, ID_TOOL_WELD));
	iVertex->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,
			 4,  4,  5,  5, 16, 15, 23, 22, ID_TOOL_WELD_SEL));
//	iVertex->AddTool(ToolSeparatorItem(10));

	iFilter = GetICustToolbar(GetDlgItem(hWnd,IDC_UNWRAP_FILTER_TOOLBAR));
	iFilter->SetBottomBorder(FALSE);	
	iFilter->SetImage(hVertexImages);
	iFilter->AddTool(ToolSeparatorItem(5));

	iFilter->AddTool(
		ToolButtonItem(CTB_CHECKBUTTON,
			 14, 16,  15,  17, 16, 15, 23, 22, ID_TOOL_LOCKSELECTED));
	iFilter->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,
			 6,  6,  7,  7, 16, 15, 23, 22, ID_TOOL_HIDE));
	iFilter->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,
			 10,  10,  11,  11, 16, 15, 23, 22, ID_TOOL_FREEZE));

	iFilter->AddTool(
		ToolButtonItem(CTB_CHECKBUTTON,
			18, 19, 18, 19, 16, 15, 23, 22, ID_TOOL_FILTER_SELECTEDFACES));

	iFilter->AddTool(ToolSeparatorItem(10));

	iFilter->AddTool(ToolOtherItem(_T("combobox"), 70,	280, ID_TOOL_FILTER_MATID,
		                           CBS, 2, NULL, 0));
	hMatIDs = iFilter->GetItemHwnd(ID_TOOL_FILTER_MATID);
//	SendMessage(hTextures, WM_SETFONT, (WPARAM)GetAppHFont(), MAKELONG(0, 0));
//FIX THIS make res id
	SendMessage(hMatIDs, CB_ADDSTRING, 0, (LPARAM)_T(GetString(IDS_PW_ID_ALLID)));	
	SendMessage(hMatIDs,CB_SETCURSEL, (WPARAM)0, (LPARAM)0 );



	iWeld    = iVertex->GetICustButton(ID_TOOL_WELD);
	iLockSelected = iFilter->GetICustButton(ID_TOOL_LOCKSELECTED);
	iHide	 = iFilter->GetICustButton(ID_TOOL_HIDE);
	iFreeze	 = iFilter->GetICustButton(ID_TOOL_FREEZE);
	iFilterSelected = iFilter->GetICustButton(ID_TOOL_FILTER_SELECTEDFACES);

	iMove    = iTool->GetICustButton(ID_TOOL_MOVE);
	iRot     = iTool->GetICustButton(ID_TOOL_ROTATE);
	iScale   = iTool->GetICustButton(ID_TOOL_SCALE);	
	iMirror   = iTool->GetICustButton(ID_TOOL_MIRROR);	
	iIncSelected = iTool->GetICustButton(ID_TOOL_INCSELECTED);	
	iFalloff = iTool->GetICustButton(ID_TOOL_FALLOFF);	
	iFalloffSpace = iTool->GetICustButton(ID_TOOL_FALLOFF_SPACE);

	iPan     = iView->GetICustButton(ID_TOOL_PAN);	
	iZoom    = iView->GetICustButton(ID_TOOL_ZOOM);
	iZoomExt = iView->GetICustButton(ID_TOOL_ZOOMEXT);
	iZoomReg = iView->GetICustButton(ID_TOOL_ZOOMREG);
	iSnap = iView->GetICustButton(ID_TOOL_SNAP);

	iBreak = iVertex->GetICustButton(ID_TOOL_BREAK);
	iWeldSelected = iVertex->GetICustButton(ID_TOOL_WELD_SEL);

	iUpdate  = iOption->GetICustButton(ID_TOOL_UPDATE);
	iUVW	 = iOption->GetICustButton(ID_TOOL_UVW);
	iProp	 = iOption->GetICustButton(ID_TOOL_PROP);
	iShowMap = iOption->GetICustButton(ID_TOOL_SHOWMAP);
	
	iMove->SetTooltip(TRUE,GetString(IDS_RB_MOVE));
	iRot->SetTooltip(TRUE,GetString(IDS_RB_ROTATE));
	iScale->SetTooltip(TRUE,GetString(IDS_RB_SCALE));
	iPan->SetTooltip(TRUE,GetString(IDS_RB_PAN));
	iZoom->SetTooltip(TRUE,GetString(IDS_RB_ZOOM));
	iUpdate->SetTooltip(TRUE,GetString(IDS_RB_UPDATE));
	iZoomExt->SetTooltip(TRUE,GetString(IDS_RB_ZOOMEXT));
	iZoomReg->SetTooltip(TRUE,GetString(IDS_RB_ZOOMREG));
	iUVW->SetTooltip(TRUE,GetString(IDS_RB_UVW));
	iProp->SetTooltip(TRUE,GetString(IDS_RB_PROP));
	iShowMap->SetTooltip(TRUE,GetString(IDS_RB_SHOWMAP));
	iSnap->SetTooltip(TRUE,GetString(IDS_PW_SNAP));
	iWeld->SetTooltip(TRUE,GetString(IDS_PW_WELD));

	iWeldSelected->SetTooltip(TRUE,GetString(IDS_PW_WELDSELECTED));
	iBreak->SetTooltip(TRUE,GetString(IDS_PW_BREAK));



	iMirror->SetTooltip(TRUE,GetString(IDS_PW_MIRRORH));
	iIncSelected->SetTooltip(TRUE,GetString(IDS_PW_EXPANDSELECTION));
	iFalloff->SetTooltip(TRUE,GetString(IDS_PW_FALLOFF)); 
	iFalloffSpace->SetTooltip(TRUE,GetString(IDS_PW_FALLOFFSPACE)); 
//need break tool tip	iBreak->SetTooltip(TRUE,GetString(IDS_PW_BREAK)); 
//need weld selecetd	iBreak->SetTooltip(TRUE,GetString(IDS_PW_BREAK)); 
	iLockSelected->SetTooltip(TRUE,GetString(IDS_PW_LOCKSELECTED));
	iHide->SetTooltip(TRUE,GetString(IDS_PW_HIDE));
	iFreeze->SetTooltip(TRUE,GetString(IDS_PW_FREEZE));
	iFilterSelected->SetTooltip(TRUE,GetString(IDS_PW_FACEFILTER));

	iMove->SetHighlightColor(GREEN_WASH);
	iRot->SetHighlightColor(GREEN_WASH);
	iScale->SetHighlightColor(GREEN_WASH);
	iWeld->SetHighlightColor(GREEN_WASH);
	iPan->SetHighlightColor(GREEN_WASH);
	iZoom->SetHighlightColor(GREEN_WASH);	
	iZoomReg->SetHighlightColor(GREEN_WASH);	
	iMirror->SetHighlightColor(GREEN_WASH);	
	iFalloff->SetHighlightColor(GREEN_WASH);	
	iFalloffSpace->SetHighlightColor(GREEN_WASH);	

	iUpdate->SetImage(NULL,0,0,0,0,0,0);
	iUpdate->SetText(GetString(IDS_RB_UPDATE));

	FlyOffData fdata1[] = {
		{ 2, 2 ,  2,  2},
		{ 3,  3,  3,  3},
		{ 4,  4,  4,  4}};
	iUVW->SetFlyOff(3,fdata1,ip->GetFlyOffTime(),uvw,FLY_DOWN);

	FlyOffData fdata2[] = {
		{ 0,  0,  1,  1},
		{10, 10, 11, 11},
		{12, 12, 13, 13}};
	iMove->SetFlyOff(3,fdata2,ip->GetFlyOffTime(),move,FLY_DOWN);

	FlyOffData fdata2a[] = {
		{24, 24, 25, 25},
		{26, 26, 27, 27},
		{28, 28, 29, 29},
		{30, 30, 31, 31}
		};
	iFalloff->SetFlyOff(4,fdata2a,ip->GetFlyOffTime(),falloff,FLY_DOWN);


	FlyOffData fdata2b[] = {
		{32, 32, 32, 32},
		{33, 33, 33, 33},
		};
	iFalloffSpace->SetFlyOff(2,fdata2b,ip->GetFlyOffTime(),falloffSpace,FLY_DOWN);



	FlyOffData fdata3[] = {
		{ 4,  4,  5,  5},
		{ 6,  6,  7,  7},
		{ 8,  8,  9,  9}};
	iScale->SetFlyOff(3,fdata3,ip->GetFlyOffTime(),scale,FLY_DOWN);

	FlyOffData fdata5[] = {
		{ 14,  14,  15,  15},
		{ 16,  16,  17,  17}
		};
	iMirror->SetFlyOff(2,fdata5,ip->GetFlyOffTime(),mirror,FLY_DOWN);

	FlyOffData fdata4[] = {
		{ 6,  6,  7,  7},
		{ 8,  8,  9,  9}};
	iZoomExt->SetFlyOff(2,fdata4,ip->GetFlyOffTime(),zoomext,FLY_UP);

	FlyOffData fdata6[] = {
		{ 6,  6,  7,  7},
		{ 8,  8,  9,  9}};
	iHide->SetFlyOff(2,fdata6,ip->GetFlyOffTime(),hide,FLY_UP);

	FlyOffData fdata7[] = {
		{ 10,  11,  11,  11},
		{ 12,  13,  13,  13}};
	iFreeze->SetFlyOff(2,fdata7,ip->GetFlyOffTime(),hide,FLY_UP);

	FlyOffData fdata8[] = {
		{ 18,  18,  19,  19},
		{ 20,  20,  21,  21}};
	iIncSelected->SetFlyOff(2,fdata8,ip->GetFlyOffTime(),hide,FLY_DOWN);




	iShowMap->SetCheck(showMap);
	if (image) iShowMap->Enable();
	else iShowMap->Disable();


	iSnap->SetCheck(pixelSnap);

	iFilterSelected->SetCheck(filterSelectedFaces);


	SizeDlg();
	SetMode(mode);
	
	for (int i = 0; i<filterMatID.Count();i++)
		{
		char st[20];
		sprintf(st,"%d",filterMatID[i]+1);
		SendMessage(hMatIDs, CB_ADDSTRING , 0, (LPARAM) (TCHAR*) st);
		}
	matid = -1;
	SendMessage(hMatIDs, CB_SETCURSEL, matid+1, 0 );

	}

static void SetWindowYPos(HWND hWnd,int y)
	{
	Rect rect;
	GetClientRectP(hWnd,&rect);
	SetWindowPos(hWnd,NULL,rect.left,y,0,0,SWP_NOSIZE|SWP_NOZORDER);
	}

static void SetWindowXPos(HWND hWnd,int x)
	{
	Rect rect;
	GetClientRectP(hWnd,&rect);
	SetWindowPos(hWnd,NULL,x,rect.top,0,0,SWP_NOSIZE|SWP_NOZORDER);
	}

void UnwrapMod::SizeDlg()
	{
	Rect rect;
	GetClientRect(hWnd,&rect);
	MoveWindow(GetDlgItem(hWnd,IDC_UNWARP_TOOLBAR),
		0, 0, 176, TOOL_HEIGHT, TRUE);

	SetWindowXPos(GetDlgItem(hWnd,IDC_UNWRAP_STR),176);
	SetWindowYPos(GetDlgItem(hWnd,IDC_UNWRAP_STR),6);
	SetWindowXPos(GetDlgItem(hWnd,IDC_UNWRAP_STRSPIN),208);
	SetWindowYPos(GetDlgItem(hWnd,IDC_UNWRAP_STRSPIN),6);

	MoveWindow(GetDlgItem(hWnd,IDC_UNWRAP_VERTS_TOOLBAR),
		232, 0, 80, TOOL_HEIGHT, TRUE);


	MoveWindow(GetDlgItem(hWnd,IDC_UNWRAP_OPTION_TOOLBAR),
		310, 0, 320, TOOL_HEIGHT, TRUE);


/*
	MoveWindow(GetDlgItem(hWnd,IDC_UNWRAP_TEXTURE_COMBO),
		480, 4, 100, TOOL_HEIGHT, TRUE);
	MoveWindow(GetDlgItem(hWnd,IDC_MATID_STRING),
		582, 0, 36, TOOL_HEIGHT-4, TRUE);
	MoveWindow(GetDlgItem(hWnd,IDC_MATID_COMBO),
		620, 4, 50, TOOL_HEIGHT, TRUE);
*/

	MoveWindow(GetDlgItem(hWnd,IDC_UNWRAP_VIEW),
		2, TOOL_HEIGHT, rect.w()-5, rect.h()-TOOL_HEIGHT-SPINNER_HEIGHT-3,FALSE);

	
	int ys = rect.h()-TOOL_HEIGHT+3;
	int yl = rect.h()-TOOL_HEIGHT+5;
	
	SetWindowYPos(GetDlgItem(hWnd,IDC_UNWRAP_ULABEL),yl);
	SetWindowYPos(GetDlgItem(hWnd,IDC_UNWRAP_VLABEL),yl);
	SetWindowYPos(GetDlgItem(hWnd,IDC_UNWRAP_WLABEL),yl);

	SetWindowYPos(GetDlgItem(hWnd,IDC_UNWRAP_U),ys);
	SetWindowYPos(GetDlgItem(hWnd,IDC_UNWRAP_V),ys);
	SetWindowYPos(GetDlgItem(hWnd,IDC_UNWRAP_W),ys);
	
	SetWindowYPos(GetDlgItem(hWnd,IDC_UNWRAP_USPIN),ys);
	SetWindowYPos(GetDlgItem(hWnd,IDC_UNWRAP_VSPIN),ys);
	SetWindowYPos(GetDlgItem(hWnd,IDC_UNWRAP_WSPIN),ys);
	int w = rect.w();
	if (rect.w() < 600)
		{
		MoveWindow(GetDlgItem(hWnd,IDC_UNWRAP_FILTER_TOOLBAR),
			220, ys-5, 175, TOOL_HEIGHT, TRUE);
		MoveWindow(GetDlgItem(hWnd,IDC_UNWARP_VIEW_TOOLBAR),
			440, ys-5, 120, TOOL_HEIGHT, TRUE);

		}
	else
		{


		MoveWindow(GetDlgItem(hWnd,IDC_UNWRAP_FILTER_TOOLBAR),
			rect.w()-380, ys-5, 175, TOOL_HEIGHT, TRUE);
		MoveWindow(GetDlgItem(hWnd,IDC_UNWARP_VIEW_TOOLBAR),
			rect.w()-123-32, ys-5, 120, TOOL_HEIGHT, TRUE);

		}

	InvalidateRect(hWnd,NULL,TRUE);
	}

Point2 UnwrapMod::UVWToScreen(Point3 pt,float xzoom, float yzoom,int w,int h)
	{	
	int i1, i2;
	GetUVWIndices(i1,i2);
	int tx = (w-int(xzoom))/2;
	int ty = (h-int(yzoom))/2;
	return Point2(pt[i1]*xzoom+xscroll+tx, (float(h)-pt[i2]*yzoom)+yscroll-ty);
	}

void UnwrapMod::ComputeZooms(
		HWND hWnd, float &xzoom, float &yzoom,int &width, int &height)
	{
 	Rect rect;
	GetClientRect(hWnd,&rect);	
	width = rect.w()-1;
	height = rect.h()-1;

	xzoom = zoom*aspect*float(width);
	yzoom = zoom*float(height);
	}


void UnwrapMod::SetMatFilters()
{
if (vertMatIDList.GetSize() != TVMaps.v.Count())
	vertMatIDList.SetSize(TVMaps.v.Count());
if (matid == -1)
	vertMatIDList.SetAll();
else 
	{
	vertMatIDList.ClearAll();
	for (int j = 0; j < TVMaps.f.Count(); j++)
		{
		int pcount = 3;
		if (TVMaps.f[j].flags & FLAG_QUAD) pcount = 4;
		for (int k = 0; k < pcount; k++)
			{
			int index = TVMaps.f[j].t[k];
//			if (filterMatID[matid] == TVMaps.f[j].MatID)
//6-29-99 watje
			if ((matid < filterMatID.Count()) && (filterMatID[matid] == TVMaps.f[j].MatID) && (index < vertMatIDList.GetSize()))
					vertMatIDList.Set(index);
			}
		}
	}

}


int UnwrapMod::IsFaceVisible(int i)
{
if (!(TVMaps.f[i].flags & FLAG_DEAD) )
	{
	if ((filterSelectedFaces==0) || (TVMaps.f[i].flags & FLAG_SELECTED))
		{
		if ((matid == -1) || (matid >= filterMatID.Count()))
			return 1;
		else if (filterMatID[matid] ==TVMaps.f[i].MatID)
			return 1;

		}
	}
return 0;

}

int UnwrapMod::IsVertVisible(int i)
{
if ( (!(TVMaps.v[i].flags & FLAG_DEAD)) && (!(TVMaps.v[i].flags & FLAG_HIDDEN)) )
	{
	if ((filterSelectedFaces==0) || (IsSelected(i) == 1))
		{
		if ((matid == -1)|| (i >= vertMatIDList.GetSize()))
			return 1;
		else 
			{
			if (vertMatIDList[i]) return 1;
/*
			for (int j = 0; j < TVMaps.f.Count(); j++)
				{
				int pcount = 3;
				if (TVMaps.f[j].flags & FLAG_QUAD) pcount = 4;
				for (int k = 0; k < pcount; k++)
					{
					int index = TVMaps.f[j].t[k];
					if (index==i)
						{
						if (filterMatID[matid] ==TVMaps.f[j].MatID)
							return 1;
						}
					}
				}
*/
			}
		}
	}
return 0;

}


void UnwrapMod::PaintView()
	{	
	PAINTSTRUCT		ps;
	BeginPaint(hView,&ps);
	EndPaint(hView,&ps);
	TimeValue t = ip->GetTime();

	COLORREF frozenColor = RGB(64,64,64);
	COLORREF yellowColor = RGB(255,255,64);
	COLORREF darkyellowColor = RGB(117,117,28);
	COLORREF darkgreenColor = RGB(28,117,28);
	COLORREF greenColor = RGB(0,255,0);
	COLORREF blueColor = RGB(0,0,255);


	SetupTypeins();
	
	if (!viewValid) {
		if (!image && map[CurrentMap]) SetupImage();
		viewValid = TRUE;
		Point2 pt[4];
		float xzoom, yzoom;
		int width,height;
		ComputeZooms(hView,xzoom,yzoom,width,height);
		iBuf->Erase();
		HDC hdc = iBuf->GetDC();
		int i1, i2;
		GetUVWIndices(i1,i2);

		if (image && showMap) {						
			Point3 p(0,0,0);
			p[i2] = 1.0f;
			Point2 sp;
			sp = UVWToScreen(p,xzoom,yzoom,width,height);
			Rect dest;
			dest.left   = (int)sp.x;
			dest.top    = (int)sp.y;
			dest.right  = dest.left + int(xzoom)-1;
			dest.bottom = dest.top + int(yzoom)-1;
			Rect src;
			src.left   = src.top = 0;
			src.right  = iw-1;
			src.bottom = ih-1;
//			GetGPort()->DisplayMap(hdc, dest, src, image, ByteWidth(iw*3));
			GetGPort()->DisplayMap(hdc, dest, src, image, ByteWidth(iw));
		} else {
			HPEN gPen = CreatePen(PS_SOLID,2,RGB(100,100,100));
			Point3 p1(0,0,0),p2(0,0,0);
			Point2 sp1, sp2;
			p2[i1] = 1.0f;
			p2[i2] = 1.0f;
			sp1 = UVWToScreen(p1,xzoom,yzoom,width,height);
			sp2 = UVWToScreen(p2,xzoom,yzoom,width,height);			
			SelectObject(hdc,gPen);
			Rectangle(hdc,(int)sp1.x,(int)sp2.y,(int)sp2.x,(int)sp1.y);
			SelectObject(hdc,GetStockObject(WHITE_PEN));
			DeleteObject(gPen);
			}

		// Paint faces		
		HPEN selPen   = CreatePen(PS_SOLID,2,selColor);
		HPEN unselPen = CreatePen(PS_SOLID,0,lineColor);
		HPEN frozenPen = CreatePen(PS_SOLID,0,frozenColor);
		HPEN yellowPen = CreatePen(PS_SOLID,0,yellowColor);
		HPEN darkyellowPen = CreatePen(PS_SOLID,0,darkyellowColor);
		HPEN darkgreenPen = CreatePen(PS_SOLID,0,darkgreenColor);
		HPEN greenPen = CreatePen(PS_SOLID,0,greenColor);
		HPEN bluePen = CreatePen(PS_SOLID,0,blueColor);
		
		SelectObject(hdc,unselPen);
//		for (int i=0; i<tvFace.Count(); i++) {
		for (int i=0; i<TVMaps.f.Count(); i++) {
			// Grap the three points, xformed
			BOOL hidden = FALSE;
			if (IsFaceVisible(i))
				{
				int pcount = 3;
				if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;

				for (int j=0; j<pcount; j++) {
					int index = TVMaps.f[i].t[j];
					pt[j] = UVWToScreen(GetPoint(t,index),xzoom,yzoom,width,height);
					if (TVMaps.v[index].flags & FLAG_HIDDEN) hidden = TRUE;
					}
			// Now draw the face
				if (!hidden)
					{
					MoveToEx(hdc,(int)pt[0].x, (int)pt[0].y, NULL);
					for (j=0; j<pcount; j++) {
						LineTo(hdc,(int)pt[(j+1)%pcount].x, (int)pt[(j+1)%pcount].y);
						}
					}
					
				}
			}

		// Now paint points		
		Point3 selSoft = GetUIColor(COLOR_SUBSELECTION_SOFT);
		Point3 selMedium = GetUIColor(COLOR_SUBSELECTION_MEDIUM);
		Point3 selHard = GetUIColor(COLOR_SUBSELECTION_HARD);

		IsSelectedSetup();
		for (i=0; i<TVMaps.v.Count(); i++) {
			if (IsVertVisible(i))
/*
			if ( (!(TVMaps.v[i].flags & FLAG_DEAD)) && (!(TVMaps.v[i].flags & FLAG_HIDDEN)) )
				{
				if ((filterSelectedFaces==0) || (IsSelected(i) == 1))
					{
*/
				{
				Point3 selColor(0.0f,0.0f,0.0f);

				pt[0] = UVWToScreen(GetPoint(t,i),xzoom,yzoom,width,height);
/*
				if (TVMaps.v[i].flags & FLAG_FROZEN)
					SelectObject(hdc,frozenPen);
				else if (vsel[i]) SelectObject(hdc,selPen);
				else
*/
				{ 


					if (TVMaps.v[i].influence == 0.0f)
						{
//						delColor = 
//						SelectObject(hdc,unselPen);
						}
					else if (TVMaps.v[i].influence <0.5f)
						selColor = selSoft + ( (selMedium-selSoft) * (TVMaps.v[i].influence/0.5f));
					else if (TVMaps.v[i].influence<=1.0f)
						selColor = selMedium + ( (selHard-selMedium) * ((TVMaps.v[i].influence-0.5f)/0.5f));
/*
					else if (TVMaps.v[i].influence <0.333)
						SelectObject(hdc,bluePen);
					else if (TVMaps.v[i].influence<0.666)
						SelectObject(hdc,greenPen);
					else if (TVMaps.v[i].influence<1.0)
						SelectObject(hdc,yellowPen);
*/

					}
				COLORREF inflColor;
				inflColor = RGB((int)(selColor.x * 255.f), (int)(selColor.y * 255.f),(int)(selColor.z * 255.f));

				HPEN inflPen = CreatePen(PS_SOLID,0,inflColor);
				if (TVMaps.v[i].flags & FLAG_FROZEN)
					SelectObject(hdc,frozenPen);
				else if (vsel[i]) SelectObject(hdc,selPen);
				else if (TVMaps.v[i].influence == 0.0f)
					SelectObject(hdc,unselPen);
				else SelectObject(hdc,inflPen);

				Rectangle(hdc,
					(int)pt[0].x-3,(int)pt[0].y-3,
					(int)pt[0].x+3,(int)pt[0].y+3);					
				SelectObject(hdc,GetStockObject(BLACK_PEN));
				DeleteObject(inflPen);

				}
			}

//check if planar if so draw planar gizmo in dialog
		if ( (ip && (ip->GetSubObjectLevel() == 3) ))
			{
// draw gizmo
			Point3 pt0,pt1,pt2,pt3,pt4,pt5,pt6;
			

			pt0.x = -.5f;
			pt0.y = -.5f;
			pt0.z = 0.0f;

			pt1.x = .5f;
			pt1.y = -.5f;
			pt1.z = 0.0f;

			pt2.x = .5f;
			pt2.y = .5f;
			pt2.z = 0.0f;

			pt3.x = -0.5f;
			pt3.y = 0.5f;
			pt3.z = 0.0f;

			pt4.x = 0.0f;
			pt4.y = 0.0f;
			pt4.z = 0.0f;

			pt5.x = 0.0f;
			pt5.y = 0.5f;
			pt5.z = 0.0f;

			pt6.x = 0.0f;
			pt6.y = 0.75f;
			pt6.z = 0.0f;



			PlanarTM.IdentityMatrix();
			Interval v;
			scaleControl->GetValue(0,&gScale,v);
			PlanarTM.SetScale(gScale);
			rotateControl->GetValue(0,&gRotate,v);
			PlanarTM.RotateZ(gRotate);
			offsetControl->GetValue(0,&gOffset,v);
			PlanarTM.SetTrans(gOffset);
			
			pt1 = pt1 * PlanarTM;

			pt2 = pt2 * PlanarTM;
			pt3 = pt3 * PlanarTM;
			pt4 = pt4 * PlanarTM;
			pt0 = pt0 * PlanarTM;
			pt5 = pt5 * PlanarTM;
			pt6 = pt6 * PlanarTM;


			Point2 spt[7];
			spt[0] = UVWToScreen(pt0,xzoom,yzoom,width,height);
			spt[1] = UVWToScreen(pt1,xzoom,yzoom,width,height);
			spt[2] = UVWToScreen(pt2,xzoom,yzoom,width,height);
			spt[3] = UVWToScreen(pt3,xzoom,yzoom,width,height);
			spt[4] = UVWToScreen(pt4,xzoom,yzoom,width,height);
			spt[5] = UVWToScreen(pt5,xzoom,yzoom,width,height);
			spt[6] = UVWToScreen(pt6,xzoom,yzoom,width,height);

			SelectObject(hdc,yellowPen);

			MoveToEx(hdc,(int)spt[5].x, (int)spt[5].y, NULL);
			LineTo(hdc,(int)spt[6].x, (int)spt[6].y);
			MoveToEx(hdc,(int)spt[0].x, (int)spt[0].y, NULL);
			LineTo(hdc,(int)spt[1].x, (int)spt[1].y);
			SelectObject(hdc,darkgreenPen);
			LineTo(hdc,(int)spt[2].x, (int)spt[2].y);


			SelectObject(hdc,yellowPen);

			LineTo(hdc,(int)spt[3].x, (int)spt[3].y);

			LineTo(hdc,(int)spt[0].x, (int)spt[0].y);

			Rectangle(hdc,
					(int)spt[0].x-3,(int)spt[0].y-3,
					(int)spt[0].x+3,(int)spt[0].y+3);					

			Rectangle(hdc,
					(int)spt[1].x-3,(int)spt[1].y-3,
					(int)spt[1].x+3,(int)spt[1].y+3);					
			Rectangle(hdc,
					(int)spt[2].x-3,(int)spt[2].y-3,
					(int)spt[2].x+3,(int)spt[2].y+3);					
			Rectangle(hdc,
					(int)spt[3].x-3,(int)spt[3].y-3,
					(int)spt[3].x+3,(int)spt[3].y+3);					


			Rectangle(hdc,
					(int)spt[4].x-4,(int)spt[4].y-4,
					(int)spt[4].x+4,(int)spt[4].y+4);					
//do selecetd verts in plane
			SelectObject(hdc,darkyellowPen);
			for (i = 0; i < gverts.d.Count();i++)
				{
				Point2 gv;
				Point3 gv3;
				gv3 = gverts.d[i].p;
//				gv3 .x -=0.5;
//				gv3 .y -=0.5;
				gv3 = gv3*0.5f;
				gv3 = gv3 * PlanarTM;
				gv = UVWToScreen(gv3,xzoom,yzoom,width,height);

				Rectangle(hdc,
					(int)gv.x-2,(int)gv.y-2,
					(int)gv.x+2,(int)gv.y+2);					

				}
			for (i=0; i<gfaces.Count(); i++) {
			// Grap the three points, xformed
				int pcount = 3;
				if (gfaces[i].flags & FLAG_QUAD) pcount = 4;

				for (int j=0; j<pcount; j++) {
					int index = gfaces[i].t[j];
					Point3 temp_point;
					temp_point = gverts.d[index].p;
					temp_point = temp_point * 0.5f;
					temp_point = temp_point *PlanarTM;
					pt[j] = UVWToScreen(temp_point,xzoom,yzoom,width,height);
					}
			// Now draw the face
				MoveToEx(hdc,(int)pt[0].x, (int)pt[0].y, NULL);
				for (j=0; j<pcount; j++) 
					{
					LineTo(hdc,(int)pt[(j+1)%pcount].x, (int)pt[(j+1)%pcount].y);
					}
				}




			}

		SelectObject(hdc,GetStockObject(BLACK_PEN));
		DeleteObject(selPen);
		DeleteObject(yellowPen);		
		DeleteObject(darkyellowPen);		
		DeleteObject(darkgreenPen);		
		DeleteObject(greenPen);		
		DeleteObject(bluePen);		
		DeleteObject(frozenPen);		
		DeleteObject(unselPen);		
		}		
	iBuf->Blit();
	}

void UnwrapMod::InvalidateView()
	{
	InvalidateTypeins();
	viewValid = FALSE;
	if (hView) {
		InvalidateRect(hView,NULL,TRUE);
		}
	}

void UnwrapMod::SetMode(int m)
	{
	switch (mode) {
		case ID_TOOL_MOVE:
		case ID_UNWRAP_MOVE:
			iMove->SetCheck(FALSE);   break;
		case ID_UNWRAP_ROTATE:
		case ID_TOOL_ROTATE:  iRot->SetCheck(FALSE);    break;
		case ID_UNWRAP_SCALE:
		case ID_TOOL_SCALE:   iScale->SetCheck(FALSE);  break;
		case ID_UNWRAP_PAN:
		case ID_TOOL_PAN:     iPan->SetCheck(FALSE);    break;
		case ID_UNWRAP_ZOOM:
		case ID_TOOL_ZOOM:    iZoom->SetCheck(FALSE);   break;
		case ID_UNWRAP_ZOOMREGION:
		case ID_TOOL_ZOOMREG: iZoomReg->SetCheck(FALSE);break;
		case ID_UNWRAP_WELD:
		case ID_TOOL_WELD:	  iWeld->SetCheck(FALSE);break;
		}

	oldMode = mode;
	mode = m;

	switch (mode) {
		case ID_UNWRAP_MOVE:   
		case ID_TOOL_MOVE:   
			iMove->SetCheck(TRUE);  
			mouseMan.SetMouseProc(moveMode, LEFT_BUTTON);
			break;

		case ID_UNWRAP_ROTATE:   
		case ID_TOOL_ROTATE: 
			iRot->SetCheck(TRUE);   
			mouseMan.SetMouseProc(rotMode, LEFT_BUTTON);
			break;

		case ID_UNWRAP_SCALE:   
		case ID_TOOL_SCALE:  
			iScale->SetCheck(TRUE); 
			mouseMan.SetMouseProc(scaleMode, LEFT_BUTTON);
			break;
		case ID_UNWRAP_WELD:
		case ID_TOOL_WELD:   
			iWeld->SetCheck(TRUE);  
			mouseMan.SetMouseProc(weldMode, LEFT_BUTTON);
			break;


		case ID_UNWRAP_PAN:
		case ID_TOOL_PAN:    
			iPan->SetCheck(TRUE);   
			mouseMan.SetMouseProc(panMode, LEFT_BUTTON);
			break;

		case ID_UNWRAP_ZOOM:
		case ID_TOOL_ZOOM:   
			iZoom->SetCheck(TRUE);
			mouseMan.SetMouseProc(zoomMode, LEFT_BUTTON);
			break;



		case ID_UNWRAP_ZOOMREGION:
		case ID_TOOL_ZOOMREG:
			iZoomReg->SetCheck(TRUE);
			mouseMan.SetMouseProc(zoomRegMode, LEFT_BUTTON);
			break;
		}
	}

void UnwrapMod::RegisterClasses()
	{
	if (!hToolImages) {
		HBITMAP hBitmap, hMask;	
		hToolImages = ImageList_Create(16, 15, TRUE, 4, 0);
		hBitmap = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_UNWRAP_TRANSFORM));
		hMask   = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_UNWRAP_TRANSFORM_MASK));
		ImageList_Add(hToolImages,hBitmap,hMask);
		DeleteObject(hBitmap);
		DeleteObject(hMask);
		}

	if (!hOptionImages) {
		HBITMAP hBitmap, hMask;	
		hOptionImages = ImageList_Create(16, 15, TRUE, 4, 0);
		hBitmap = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_UNWRAP_OPTION));
		hMask   = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_UNWRAP_OPTION_MASK));
		ImageList_Add(hOptionImages,hBitmap,hMask);
		DeleteObject(hBitmap);
		DeleteObject(hMask);
		}

	if (!hViewImages) {
		HBITMAP hBitmap, hMask;	
		hViewImages = ImageList_Create(16, 15, TRUE, 4, 0);
		hBitmap = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_UNWRAP_VIEW));
		hMask   = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_UNWRAP_VIEW_MASK));
		ImageList_Add(hViewImages,hBitmap,hMask);
		DeleteObject(hBitmap);
		DeleteObject(hMask);
		}

	if (!hVertexImages) {
		HBITMAP hBitmap, hMask;	
		hVertexImages = ImageList_Create(16, 15, TRUE, 4, 0);
		hBitmap = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_UNWRAP_VERT));
		hMask   = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_UNWRAP_VERT_MASK));
		ImageList_Add(hVertexImages,hBitmap,hMask);
		DeleteObject(hBitmap);
		DeleteObject(hMask);
		}

	static BOOL registered = FALSE;
	if (!registered) {
		registered = TRUE;
		WNDCLASS  wc;
		wc.style         = 0;
		wc.hInstance     = hInstance;
		wc.hIcon         = NULL;
		wc.hCursor       = NULL;
		wc.hbrBackground = NULL; //(HBRUSH)GetStockObject(WHITE_BRUSH);	
		wc.lpszMenuName  = NULL;
		wc.cbClsExtra    = 0;
		wc.cbWndExtra    = 0;
		wc.lpfnWndProc   = UnwrapViewProc;
		wc.lpszClassName = _T(GetString(IDS_PW_UNWRAPVIEW));
		RegisterClass(&wc);
		}
	}

//static int lStart[12] = {0,1,3,2,4,5,7,6,0,1,2,3};
//static int lEnd[12]   = {1,3,2,0,5,7,6,4,4,5,6,7};
/*
static void DoBoxIcon(BOOL sel,float length, PolyLineProc& lp)
	{
	Point3 pt[3];
	
	length *= 0.5f;
	Box3 box;
	box.pmin = Point3(-length,-length,-length);
	box.pmax = Point3( length, length, length);

	if (sel) //lp.SetLineColor(1.0f,1.0f,0.0f);
		 lp.SetLineColor(GetUIColor(COLOR_SEL_GIZMOS));
	else //lp.SetLineColor(0.85f,0.5f,0.0f);		
		 lp.SetLineColor(GetUIColor(COLOR_GIZMOS));

	for (int i=0; i<12; i++) {
		pt[0] = box[lStart[i]];
		pt[1] = box[lEnd[i]];
		lp.proc(pt,2);
		}
	}

*/

BOOL UnwrapMod::HitTest(Rect rect,Tab<int> &hits,BOOL selOnly)
	{
	Point2 pt;
	float xzoom, yzoom;
	int width,height;
	TimeValue t = ip->GetTime();
	ComputeZooms(hView,xzoom,yzoom,width,height);	

	if ( (abs(rect.left-rect.right) <= 4) && (abs(rect.bottom-rect.top) <= 4) )
		{
		rect.left -= 4;
		rect.right += 4;
		rect.top -= 4;
		rect.bottom += 4;
		}

	for (int i=0; i<TVMaps.v.Count(); i++) {
		if (selOnly && !vsel[i]) continue;
		if (TVMaps.v[i].flags & FLAG_HIDDEN) continue;
		if (TVMaps.v[i].flags & FLAG_FROZEN) continue;
		if (!IsVertVisible(i)) continue;

		pt = UVWToScreen(GetPoint(t,i),xzoom,yzoom,width,height);
		IPoint2 ipt(int(pt.x),int(pt.y));
		if (rect.Contains(ipt)) {
			hits.Append(1,&i,10);
			}
		}
	return hits.Count();
	}

void UnwrapMod::InvalidateTypeins()
	{
	typeInsValid = FALSE;	
	}

void UnwrapMod::SetupTypeins()
	{
	if (typeInsValid) return;
	typeInsValid = TRUE;

	Point3 uv(0,0,0);
	BOOL found = FALSE;
	BOOL u = TRUE, v = TRUE, w = TRUE;

	for (int i=0; i<TVMaps.v.Count(); i++) {
		if (!vsel[i]) continue;
		
		if (found) {
			if (uv.x!=TVMaps.v[i].p.x) {
				u = FALSE;				
				}
			if (uv.y!=TVMaps.v[i].p.y) {
				v = FALSE;				
				}
			if (uv.z!=TVMaps.v[i].p.z) {
				w = FALSE;				
				}			
		} else {
			uv = TVMaps.v[i].p;
			found = TRUE;
			}
		}

	if (!found) {
		iU->Disable();
		iV->Disable();
		iW->Disable();
	} else {
		iU->Enable();
		iV->Enable();
		iW->Enable();
		if (u) {
			iU->SetIndeterminate(FALSE);
			iU->SetValue(uv.x,FALSE);
		} else {
			iU->SetIndeterminate(TRUE);
			}

		if (v) {
			iV->SetIndeterminate(FALSE);
			iV->SetValue(uv.y,FALSE);
		} else {
			iV->SetIndeterminate(TRUE);
			}

		if (w) {
			iW->SetIndeterminate(FALSE);
			iW->SetValue(uv.z,FALSE);
		} else {
			iW->SetIndeterminate(TRUE);
			}
		}
	}

void UnwrapMod::Select(Tab<int> &hits,BOOL toggle,BOOL subtract,BOOL all)
	{
	if ( (ip && (ip->GetSubObjectLevel() == 3) ))
		{
		GizmoSelected = FALSE;
		for (int i=0; i<hits.Count(); i++) 
			{
			if (hits[i]!= 0)
				GizmoSelected = TRUE;
			}

		}
	else
		{
		HoldSelection();
		IsSelectedSetup();
		for (int i=0; i<hits.Count(); i++) {
			if ( (IsVertVisible(hits[i])) &&  (!(TVMaps.v[hits[i]].flags & FLAG_FROZEN)) )
				{
/*			if ( (!(TVMaps.v[hits[i]].flags & FLAG_DEAD)) && 
				 (!(TVMaps.v[hits[i]].flags & FLAG_HIDDEN)) && 
				 (!(TVMaps.v[hits[i]].flags & FLAG_FROZEN))   )
				{
				if ((filterSelectedFaces==0) || (IsSelected(hits[i]) == 1))
*/
//					{

					if (toggle) vsel.Set(hits[i],!vsel[hits[i]]);
					else if (subtract) vsel.Set(hits[i],FALSE);
					else vsel.Set(hits[i],TRUE);
					if (!all) break;
//					}
				}
			}	
		RebuildDistCache();
		}
	}

void UnwrapMod::ClearSelect()
	{
	HoldSelection();
	vsel.ClearAll();	
	for (int i=0; i<TVMaps.v.Count(); i++) 
		{
		TVMaps.v[i].influence = 0.0f;
		}

	}

void UnwrapMod::HoldPoints()
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		SetAFlag(A_HELD);
		theHold.Put(new TVertRestore(this));
		}
	}


void UnwrapMod::HoldSelection()
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {	
		SetAFlag(A_HELD);
		theHold.Put(new TSelRestore(this));
		}
	}

void UnwrapMod::HoldPointsAndFaces()
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		SetAFlag(A_HELD);
		theHold.Put(new TVertAndTFaceRestore(this));
		}
	}


void UnwrapMod::TypeInChanged(int which)
	{
	TimeValue t = ip->GetTime();
	HoldPoints();
	Point3 uvw;
	uvw[0] = iU->GetFVal();
	uvw[1] = iV->GetFVal();
	uvw[2] = iW->GetFVal();

	for (int i=0; i<TVMaps.v.Count(); i++) {
		if (vsel[i]) {
			if (TVMaps.cont[i]) TVMaps.cont[i]->GetValue(t,&TVMaps.v[i].p,FOREVER);
			TVMaps.v[i].p[which] = uvw[which];
			if (TVMaps.cont[i]) TVMaps.cont[i]->SetValue(t,&TVMaps.v[i].p);
			}
		}

	NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
	InvalidateView();
	ip->RedrawViews(ip->GetTime());
	}

void UnwrapMod::DeleteSelected()
{
if (TVMaps.v.Count() == 0) return;
theHold.SuperBegin();
theHold.Begin();

HoldPointsAndFaces();	
	
for (int i=0; i<TVMaps.v.Count(); i++) 
	{
	if ( (vsel[i]) && (!(TVMaps.v[i].flags & FLAG_DEAD)) )
		{
		TVMaps.v[i].flags |= FLAG_DEAD;
		vsel.Set(i,FALSE);
		}
	}
for (i=0; i<TVMaps.f.Count(); i++) 
	{
	for (int j=0; j<3; j++) 
		{
		int index = TVMaps.f[i].t[j];
		if (TVMaps.v[index].flags & FLAG_DEAD)
			{
			TVMaps.f[i].flags |= FLAG_DEAD;
			}
		}
	}
// loop through faces all
theHold.Accept(_T(GetString(IDS_PW_DELETE_SELECTED)));
theHold.SuperAccept(_T(GetString(IDS_PW_DELETE_SELECTED)));

}

void UnwrapMod::HideSelected()
{

theHold.SuperBegin();
theHold.Begin();
HoldPoints();	
	
for (int i=0; i<TVMaps.v.Count(); i++) 
	{
	if ( (vsel[i]) && (!(TVMaps.v[i].flags & FLAG_DEAD)) )
		{
	
		TVMaps.v[i].flags |= FLAG_HIDDEN;
		vsel.Set(i,FALSE);
		}
	}

theHold.Accept(_T(GetString(IDS_PW_HIDE_SELECTED)));
theHold.SuperAccept(_T(GetString(IDS_PW_HIDE_SELECTED)));
}

void UnwrapMod::UnHideAll()
{
theHold.SuperBegin();
theHold.Begin();
HoldPoints();	
for (int i=0; i<TVMaps.v.Count(); i++) 
	{
	if ( (TVMaps.v[i].flags & FLAG_HIDDEN) && (!(TVMaps.v[i].flags & FLAG_DEAD)) )
		{
		TVMaps.v[i].flags -= FLAG_HIDDEN;
		}
	}

theHold.Accept(_T(GetString(IDS_PW_UNHIDEALL)));
theHold.SuperAccept(_T(GetString(IDS_PW_UNHIDEALL)));


}


void UnwrapMod::FreezeSelected()
{
theHold.SuperBegin();
theHold.Begin();
HoldPoints();	
for (int i=0; i<TVMaps.v.Count(); i++) 
	{
	if ( (vsel[i]) && (!(TVMaps.v[i].flags & FLAG_DEAD)) )
		{
		TVMaps.v[i].flags |= FLAG_FROZEN;
		vsel.Set(i,FALSE);
		}
	}
theHold.Accept(_T(GetString(IDS_PW_FREEZE_SELECTED)));
theHold.SuperAccept(_T(GetString(IDS_PW_FREEZE_SELECTED)));


}

void UnwrapMod::UnFreezeAll()
{
theHold.SuperBegin();
theHold.Begin();
HoldPoints();	
for (int i=0; i<TVMaps.v.Count(); i++) 
	{
	if ( !(TVMaps.v[i].flags & FLAG_DEAD)) 
		{
		if ( (TVMaps.v[i].flags & FLAG_FROZEN)) 
			TVMaps.v[i].flags -= FLAG_FROZEN;
		}
	}
theHold.Accept(_T(GetString(IDS_PW_UNFREEZEALL)));
theHold.SuperAccept(_T(GetString(IDS_PW_UNFREEZEALL)));

}

void UnwrapMod::WeldSelected()
{

theHold.SuperBegin();
theHold.Begin();
HoldPointsAndFaces();	
float sweldThreshold;

sweldThreshold = weldThreshold * weldThreshold;

for (int m=0; m<TVMaps.v.Count(); m++) 
	{
	if (vsel[m])
		{
		Point3 p(0.0f,0.0f,0.0f);
		Point3 op(0.0f,0.0f,0.0f);
		p = GetPoint(ip->GetTime(),m);
		op = p;
		int ct = 0;
		int index = -1;
		for (int i=m+1; i<TVMaps.v.Count(); i++) 
			{
			if ( (vsel[i]) && (!(TVMaps.v[i].flags & FLAG_DEAD)) )
//	if (vsel[i]) 
				{
				Point3 np;
				
				np= GetPoint(ip->GetTime(),i);
				if (LengthSquared(np-op) < sweldThreshold)
					{
					p+= np;
					ct++;
					if (index == -1)
						index = m;
					TVMaps.v[i].flags |= FLAG_DEAD;
					}
				}
			}

		if ((index == -1) || (ct == 0))
			{
//			theHold.SuperCancel();
//			theHold.Cancel();
//			return;
			}
		else
			{
			ct++;
			p = p /(float)ct;


			if (TVMaps.cont[index]) 
				TVMaps.cont[index]->GetValue(ip->GetTime(),&TVMaps.v[index].p,FOREVER);

			TVMaps.v[index].p = p;
			if (TVMaps.cont[index]) 
				TVMaps.cont[index]->SetValue(ip->GetTime(),&TVMaps.v[index].p);

			for (i=0; i<TVMaps.f.Count(); i++) 
				{
				int pcount = 3;
				if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;
				for (int j=0; j<pcount; j++) 
					{
					int tvfIndex = TVMaps.f[i].t[j];
					Point3 np = TVMaps.v[tvfIndex].p;
					 

					if ((vsel[tvfIndex]) && (LengthSquared(np-op) < sweldThreshold)) 
						{
						if (tvfIndex != index)
							{
							TVMaps.f[i].t[j] = index;
//							vsel.Set(tvfIndex,0);
							}

						}
					}
				}
			}
		}
	}
theHold.Accept(_T(GetString(IDS_PW_WELDSELECTED)));
theHold.SuperAccept(_T(GetString(IDS_PW_WELDSELECTED)));

}

BOOL UnwrapMod::WeldPoints(HWND h, IPoint2 m)
{
//theHold.SuperBegin();
//theHold.Begin();
theHold.Put(new TVertAndTFaceRestore(this));
//HoldPointsAndFaces();	

Point3 p(0.0f,0.0f,0.0f);
int ct = 0;
Point2 mp;
mp.x = (float) m.x;
mp.y = (float) m.y;

float xzoom, yzoom;
int width,height;
ComputeZooms(h,xzoom,yzoom,width,height);
int index = -1;
BOOL holdNeeded = FALSE;
for (int i=0; i<TVMaps.v.Count(); i++) 
	{
	if (!vsel[i]) 
		{
		Point2 sp;
		p = GetPoint(ip->GetTime(),i);
		sp = UVWToScreen(p,xzoom,yzoom,width,height);
		if (Length(sp-mp) < 4.0f)
			{
			index = i;
			i = TVMaps.v.Count();
			}

		}
	}

BOOL first = TRUE;
if (index != -1)
	{
	for (i=0; i<TVMaps.f.Count(); i++) 
		{
		int pcount = 3;
		if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;
		for (int j=0; j<pcount; j++) 
			{
			int tvfIndex = TVMaps.f[i].t[j];
			if (vsel[tvfIndex])
				{
				TVMaps.f[i].t[j] = index;
				TVMaps.v[tvfIndex].flags |= FLAG_DEAD;
				holdNeeded = TRUE;
				}
			}
		}
	
	}
theHold.Accept(_T(GetString(IDS_PW_WELD)));

InvalidateView();

return holdNeeded;
}

void UnwrapMod::BreakSelected()
{

theHold.SuperBegin();
theHold.Begin();
HoldPointsAndFaces();	

for (int i=0; i<TVMaps.v.Count(); i++) 
	{
	if ( (vsel[i]) && (!(TVMaps.v[i].flags & FLAG_DEAD)) )
		{
//find all faces attached to this vertex
		Point3 p = GetPoint(ip->GetTime(),i);
		BOOL first = TRUE;
		for (int j=0; j<TVMaps.f.Count(); j++) 
			{
			int pcount = 3;
			if (TVMaps.f[j].flags & FLAG_QUAD) pcount = 4;
			for (int k = 0; k < pcount;k++)
				{
				if ((TVMaps.f[j].t[k] == i) && (!(TVMaps.f[j].flags & FLAG_DEAD)))
					{
					if (first)
						{
						first = FALSE;
						}
					else
						{
//loop through vertex list looking for dead ones else attache to end
						int found = -1;
						for (int m= 0; m <TVMaps.v.Count();m++)
							{
							if (TVMaps.v[m].flags & FLAG_DEAD)
								{
								found =m;
								m = TVMaps.v.Count();
								}
							}
//found dead spot add to it
						if (found != -1)
							{
							TVMaps.v[found].p = p;
							if (TVMaps.cont[found]) 
								TVMaps.cont[found]->SetValue(ip->GetTime(),&TVMaps.v[found].p);

							TVMaps.f[j].t[k] = found;
							TVMaps.v[found].flags -= FLAG_DEAD;
							}
//create a new vert
						else
							{
							UVW_TVVertClass tv;
							tv.p = p;
							tv.flags = 0;
							TVMaps.v.Append(1,&tv,1);
							TVMaps.f[j].t[k] = TVMaps.v.Count()-1;

							vsel.SetSize(TVMaps.v.Count(), 1);
							Control* c;
							c = NULL;
							TVMaps.cont.Append(1,&c,1);
	
							}
						}
					}

				}
			}

		}
	}
theHold.Accept(_T(GetString(IDS_PW_BREAK)));
theHold.SuperAccept(_T(GetString(IDS_PW_BREAK)));


}

void UnwrapMod::SnapPoint(Point3 &p)
	{
	int i1,i2;
	GetUVWIndices(i1,i2);
//	int ix, iy;
	float fx,fy;
	double dx,dy;
//compute in pixel space
//find closest whole pixel
	fx = (float) modf(( (float) p[i1] * (float) (bitmapWidth-1) ),&dx);
	fy = (float) modf(( (float) p[i2] * (float) (bitmapHeight-1) ),&dy);
	if (midPixelSnap)
		{
//		if (fx > 0.5f) dx+=1.0f;
//		if (fy > 0.5f) dy+=1.0f;
		dx += 0.5f;
		dy += 0.5f;
		}
	else
		{
		if (fx > 0.5f) dx+=1.0f;
		if (fy > 0.5f) dy+=1.0f;
		}
//put back in UVW space
	p[i1] = (float)dx/(float)(bitmapWidth-1);
	p[i2] = (float)dy/(float)(bitmapHeight-1);
	}
void UnwrapMod::MovePoints(Point2 pt)
	{
	int i1, i2;
	GetUVWIndices(i1,i2);
	HoldPoints();	
	TimeValue t = ip->GetTime();

	for (int i=0; i<TVMaps.v.Count(); i++) {
		if (vsel[i]) {
			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->GetValue(t,&TVMaps.v[i].p,FOREVER);
//check snap and bitmap
			TVMaps.v[i].p[i1] += pt.x;
			TVMaps.v[i].p[i2] += pt.y;
			if ((isBitmap) && (pixelSnap))
				{
				SnapPoint(TVMaps.v[i].p);
				}
			if (TVMaps.cont[i]) TVMaps.cont[i]->SetValue(t,&TVMaps.v[i].p);
			}
		else if(TVMaps.v[i].influence != 0.0f)
			{
			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->GetValue(t,&TVMaps.v[i].p,FOREVER);
//check snap and bitmap
			Point3 NewPoint = TVMaps.v[i].p;
			NewPoint[i1] += pt.x;
			NewPoint[i2] += pt.y;
			Point3 vec;
			vec = (NewPoint - TVMaps.v[i].p) * TVMaps.v[i].influence;
			TVMaps.v[i].p += vec;
			if ((isBitmap) && (pixelSnap))
				{
				SnapPoint(TVMaps.v[i].p);
				}
			if (TVMaps.cont[i]) TVMaps.cont[i]->SetValue(t,&TVMaps.v[i].p);
			}

		}
	NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
	InvalidateView();
	}

void UnwrapMod::MoveGizmo(Point2 pt)
	{
	int i1, i2;
	GetUVWIndices(i1,i2);


	HoldPoints();	
	TimeValue t = ip->GetTime();

	if (offsetControl) 
		offsetControl->GetValue(t,&gOffset,FOREVER);
	gOffset[i1] += pt.x;
	gOffset[i2] += pt.y;
	if (offsetControl) offsetControl->SetValue(t,&gOffset);

	NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
	InvalidateView();
	}

void UnwrapMod::RotatePoints(HWND h, float ang)
	{
	HoldPoints();	
	TimeValue t = ip->GetTime();

	Point3 cent(0,0,0);

	if (centeron)
		{
		float xzoom, yzoom;
		int width,height;

		ComputeZooms(h,xzoom,yzoom,width,height);


		int tx = (width-int(xzoom))/2;
		int ty = (height-int(yzoom))/2;
		cent.x = (center.x-tx-xscroll)/xzoom;
		cent.y = (center.y+ty-yscroll - height)/-yzoom;
		cent.z = 0.0f;
//		cent.x = 0.0f(center.x-tx-xscroll)/xzoom;
//		cent.y = 0.0f;//(center.y+ty-yscroll - height)/-yzoom;
		}
	else
		{

		int ct = 0;
		for (int i=0; i<TVMaps.v.Count(); i++) {
			if (vsel[i]) {
				cent += TVMaps.v[i].p;
				ct++;
				}
			}
		if (!ct) return;
		cent /= float(ct);
		}

	Matrix3 mat(1);	
	mat.Translate(-cent);
	ang = ip->SnapAngle(ang,FALSE);
	switch (uvw) {
		case 0: mat.RotateZ(ang); break;
		case 1: mat.RotateX(ang); break;
		case 2: mat.RotateY(ang); break;
		}
	mat.Translate(cent);

	for (int i=0; i<TVMaps.v.Count(); i++) {
		if (vsel[i]) {
			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->GetValue(t,&TVMaps.v[i].p,FOREVER);
//check snap and bitmap
			TVMaps.v[i].p = mat * TVMaps.v[i].p;
			if ((isBitmap) && (pixelSnap))
				{
				SnapPoint(TVMaps.v[i].p);
				}
			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->SetValue(t,&TVMaps.v[i].p);
			}
		else if(TVMaps.v[i].influence != 0.0f)
			{
			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->GetValue(t,&TVMaps.v[i].p,FOREVER);
//check snap and bitmap
			Point3 NewPoint = TVMaps.v[i].p;
			NewPoint = mat * TVMaps.v[i].p;

			Point3 vec;
			vec = (NewPoint - TVMaps.v[i].p) * TVMaps.v[i].influence;
			TVMaps.v[i].p += vec;

			if ((isBitmap) && (pixelSnap))
				{
				SnapPoint(TVMaps.v[i].p);
				}
			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->SetValue(t,&TVMaps.v[i].p);
			}

		}

	NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
	InvalidateView();
	}

void UnwrapMod::RotateGizmo(HWND h, float ang)
	{
	HoldPoints();	
	TimeValue t = ip->GetTime();

	Point3 cent(0,0,0);

	if (centeron)
		{
		float xzoom, yzoom;
		int width,height;

		ComputeZooms(h,xzoom,yzoom,width,height);


		int tx = (width-int(xzoom))/2;
		int ty = (height-int(yzoom))/2;
		cent.x = (center.x-tx-xscroll)/xzoom;
		cent.y = (center.y+ty-yscroll - height)/-yzoom;
		cent.z = 0.0f;
//		cent.x = 0.0f(center.x-tx-xscroll)/xzoom;
//		cent.y = 0.0f;//(center.y+ty-yscroll - height)/-yzoom;
		}
	else
		{
		cent = gOffset;
/*
		int ct = 0;
		for (int i=0; i<TVMaps.v.Count(); i++) {
			if (vsel[i]) {
				cent += TVMaps.v[i].p;
				ct++;
				}
			}
		if (!ct) return;
		cent /= float(ct);
*/
		}

	if (rotateControl) 
		rotateControl->GetValue(t,&gRotate,FOREVER);
	gRotate += ang;

	if (rotateControl) 
		rotateControl->SetValue(t,&gRotate);

/*
	Matrix3 mat(1);	
	mat.Translate(-cent);
	switch (uvw) {
		case 0: mat.RotateZ(ang); break;
		case 1: mat.RotateX(ang); break;
		case 2: mat.RotateY(ang); break;
		}
	mat.Translate(cent);

	for (int i=0; i<TVMaps.v.Count(); i++) {
		if (vsel[i]) {
			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->GetValue(t,&TVMaps.v[i].p,FOREVER);
//check snap and bitmap
			TVMaps.v[i].p = mat * TVMaps.v[i].p;
			if ((isBitmap) && (pixelSnap))
				{
				SnapPoint(TVMaps.v[i].p);
				}
			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->SetValue(t,&TVMaps.v[i].p);
			}
		}
*/
	NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
	InvalidateView();
	}


void UnwrapMod::ScaleGizmo(HWND h, float scale, int direction)
	{
	HoldPoints();	
	TimeValue t = ip->GetTime();

	Point3 cent(0,0,0);
	scale = scale - 1.0f;
	if (centeron)
		{
		float xzoom, yzoom;
		int width,height;

		ComputeZooms(h,xzoom,yzoom,width,height);

		int tx = (width-int(xzoom))/2;
		int ty = (height-int(yzoom))/2;
		cent.x = (center.x-tx-xscroll)/xzoom;
		cent.y = (center.y+ty-yscroll - height)/-yzoom;
		cent.z = 0.0f;
		}
	else
		{
		cent = gOffset;
/*
		int ct = 0;
		for (int i=0; i<TVMaps.v.Count(); i++) {
			if (vsel[i]) {
				cent += TVMaps.v[i].p;
				ct++;
				}
			}
		if (!ct) return;
		cent /= float(ct);
*/
		}

	Matrix3 mat(1);	
	mat.Translate(-cent);
	Point3 sc(0.0f,0.0f,0.0f);
	int i1, i2;
	GetUVWIndices(i1,i2);
	if (direction == 0)
		{
		sc[i1] = scale;
		sc[i2] = scale;
		}
	else if (direction == 1)
		{
		sc[i1] = -scale;
//		sc[i2] = scale;
		}
	else if (direction == 2)
		{
//		sc[i1] = scale;
		sc[i2] = scale;
		}

//	sc[i1] = scale;
//	sc[i2] = scale;

	mat.Scale(sc,TRUE);
	mat.Translate(cent);
	if (scaleControl) 
		scaleControl->GetValue(t,&gScale,FOREVER);
	gScale += sc;

	if (scaleControl) 
		scaleControl->SetValue(t,&gScale);

	NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
	InvalidateView();
	}


void UnwrapMod::ScalePoints(HWND h, float scale, int direction)
	{
	HoldPoints();	
	TimeValue t = ip->GetTime();

	Point3 cent(0,0,0);
	int i;
	if (centeron)
		{
		float xzoom, yzoom;
		int width,height;

		ComputeZooms(h,xzoom,yzoom,width,height);
/*
Rect rect;
GetClientRect(hWnd,&rect);	
int w = rect.w()-1;
int h = height = rect.h()-1;
*/

		int tx = (width-int(xzoom))/2;
		int ty = (height-int(yzoom))/2;
		cent.x = (center.x-tx-xscroll)/xzoom;
		cent.y = (center.y+ty-yscroll - height)/-yzoom;
		cent.z = 0.0f;
		}
	else
		{
		int ct = 0;
		for (int i=0; i<TVMaps.v.Count(); i++) {
			if (vsel[i]) {
				cent += TVMaps.v[i].p;
				ct++;
				}
			}
		if (!ct) return;
		cent /= float(ct);
		}

	Matrix3 mat(1);	
	mat.Translate(-cent);
	Point3 sc(1,1,1);
	int i1, i2;
	GetUVWIndices(i1,i2);
	if (direction == 0)
		{
		sc[i1] = scale;
		sc[i2] = scale;
		}
	else if (direction == 1)
		{
		sc[i1] = scale;
//		sc[i2] = scale;
		}
	else if (direction == 2)
		{
//		sc[i1] = scale;
		sc[i2] = scale;
		}

//	sc[i1] = scale;
//	sc[i2] = scale;

	mat.Scale(sc,TRUE);
	mat.Translate(cent);

	for (i=0; i<TVMaps.v.Count(); i++) {
		if (vsel[i]) {
			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->GetValue(t,&TVMaps.v[i].p,FOREVER);
//check snap and bitmap
			TVMaps.v[i].p = mat * TVMaps.v[i].p;
			if ((isBitmap) && (pixelSnap))
				{
				SnapPoint(TVMaps.v[i].p);
				}

			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->SetValue(t,&TVMaps.v[i].p);
			}
		else if(TVMaps.v[i].influence != 0.0f)
			{
			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->GetValue(t,&TVMaps.v[i].p,FOREVER);
//check snap and bitmap
//			TVMaps.v[i].p = mat * TVMaps.v[i].p;
			Point3 NewPoint = TVMaps.v[i].p;
			NewPoint = mat * TVMaps.v[i].p;
			Point3 vec;
			vec = (NewPoint - TVMaps.v[i].p) * TVMaps.v[i].influence;
			TVMaps.v[i].p += vec;

			if ((isBitmap) && (pixelSnap))
				{
				SnapPoint(TVMaps.v[i].p);
				}

			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->SetValue(t,&TVMaps.v[i].p);
			}

		



		}

	NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
	InvalidateView();
	}


void UnwrapMod::MirrorGizmo(HWND h, int direction)
	{

	HoldPoints();	
	TimeValue t = ip->GetTime();
/*
	Point3 cent(0,0,0);
	int ct = 0;
	for (int i=0; i<TVMaps.v.Count(); i++) {
		if (vsel[i]) {
			cent += TVMaps.v[i].p;
			ct++;
			}
		}
	if (!ct) return;
	cent /= float(ct);
*/
//	Matrix3 mat(1);	
//	mat.Translate(-cent);
	Point3 sc(1.0f,1.0f,1.0f);
	int i1, i2;
	GetUVWIndices(i1,i2);
	if (direction == 0)
		{
		sc[i1] = -1.0f;
		}
	else if (direction == 1)
		{
		sc[i2] = -1.0f;
		}


//flip the scale transform
//	mat.Scale(sc,TRUE);
//	mat.Translate(cent);
	if (scaleControl) 
		scaleControl->GetValue(t,&gScale,FOREVER);
	gScale *= sc;

	if (scaleControl) 
		scaleControl->SetValue(t,&gScale);

	NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
	InvalidateView();
	}


void UnwrapMod::MirrorPoints(HWND h, int direction)
	{
	TimeValue t = ip->GetTime();

	Point3 cent(0,0,0);
	int i;
	int ct = 0;
	for (i=0; i<TVMaps.v.Count(); i++) {
		if (vsel[i]) {
			cent += TVMaps.v[i].p;
			ct++;
			}
		}
	if (!ct) return;
	cent /= float(ct);

	theHold.SuperBegin();
	theHold.Begin();
	HoldPoints();	


	Matrix3 mat(1);	
	mat.Translate(-cent);
	Point3 sc(1.0f,1.0f,1.0f);
	int i1, i2;
	GetUVWIndices(i1,i2);
	if (direction == 0)
		{
		sc[i1] = -1.0f;
		}
	else if (direction == 1)
		{
		sc[i2] = -1.0f;
		}

//	sc[i1] = scale;
//	sc[i2] = scale;

	mat.Scale(sc,TRUE);
	mat.Translate(cent);

	for (i=0; i<TVMaps.v.Count(); i++) {
		if (vsel[i]) {
			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->GetValue(t,&TVMaps.v[i].p,FOREVER);
//check snap and bitmap
			TVMaps.v[i].p = mat * TVMaps.v[i].p;
			if ((isBitmap) && (pixelSnap))
				{
				SnapPoint(TVMaps.v[i].p);
				}

			if (TVMaps.cont[i]) 
				TVMaps.cont[i]->SetValue(t,&TVMaps.v[i].p);
			}
		}

	theHold.Accept(_T(GetString(IDS_TH_MIRROR)));
	theHold.SuperAccept(_T(GetString(IDS_TH_MIRROR)));

	NotifyDependents(FOREVER,TEXMAP_CHANNEL,REFMSG_CHANGE);
	if (ip) ip->RedrawViews(ip->GetTime());
	InvalidateView();
	}

void UnwrapMod::UpdateListBox()
{
	int ct = 0;
	for (int i = 0; i < 10; i++)
		{
		if (map[i] != NULL) 
			{
			SendMessage(hTextures, CB_INSERTSTRING , ct++, (LPARAM) (TCHAR*) map[i]->GetName());
			}
		}

}

void UnwrapMod::AddMaterial(MtlBase *mtl)
{
	int found = -1;

	for (int i = 0; i < 10; i++)
		{
		if (map[i] == mtl) 
			{
			return;
			}
		}

	for (i = 0; i < 10; i++)
		{
		if (map[i] == NULL) 
			{
			found = i;
			i = 10;
			}
		}
	if (found == -1)
		{
		for (i = 9; i >0 ;i--)
			ReplaceReference(i+1,map[i-1]);
		ReplaceReference(1,mtl);
		SendMessage(hTextures, CB_DELETESTRING , 0, (LPARAM) (TCHAR*) mtl->GetName());
		SendMessage(hTextures, CB_INSERTSTRING , 0, (LPARAM) (TCHAR*) mtl->GetName());
//		SendMessage(hTextures, CB_INSERTSTRING , found, (LPARAM) (TCHAR*) mtl->GetName());
		found = 0;
		}
	else 
		{
		ReplaceReference(found+1,mtl);
		SendMessage(hTextures, CB_INSERTSTRING , found, (LPARAM) (TCHAR*) mtl->GetName());
		}
	CurrentMap = found;
	SetupImage();

}

void UnwrapMod::PickMap()
	{	
	BOOL newMat=FALSE, cancel=FALSE;
	MtlBase *mtl = ip->DoMaterialBrowseDlg(
		hWnd,
		BROWSE_MAPSONLY|BROWSE_INCNONE|BROWSE_INSTANCEONLY,
		newMat,cancel);
	if (cancel) {
		if (newMat) mtl->DeleteThis();
		return;
		}

	AddMaterial(mtl);
	}

UBYTE *RenderBitmap(Bitmap *bmp,int w, int h)
	{
	float du = 1.0f/float(w);
	float dv = 1.0f/float(h);
	AColor col;
//	SCTex sc;
//	int scanw = ByteWidth(w*3);
	int scanw = ByteWidth(w);
//	UBYTE *image = new UBYTE[ByteWidth(w*3)*h];
	UBYTE *image = new UBYTE[ByteWidth(w)*h];
	UBYTE *p1;
		
//	sc.scale = 1.0f;
//	sc.duvw = Point3(du,dv,0.0f);
//	sc.dpt  = sc.duvw;
//	sc.uvw.y = 1.0f-0.5f*dv;

	BMM_Color_64 color;
	for (int j=0; j<h; j++) {
//		sc.scrPos.y = j;
//		sc.uvw.x = 0.5f*du;				
		p1 = image + (h-j-1)*scanw;
		for (int i=0; i<w; i++) {
			bmp->GetPixels(i,j,1,&color);
			
			*p1++ = (UBYTE)(color.b>>8);
			*p1++ = (UBYTE)(color.g>>8);
			*p1++ = (UBYTE)(color.r>>8);	

			}		
		}
	return image;
	}


void UnwrapMod::SetupImage()
	{
	delete image; image = NULL;
	if (map[CurrentMap]) {		
		iw = rendW;
		ih = rendH;
		aspect = 1.0f;
//		Class_ID bid = Class_ID(BMTEX_CLASS_ID);
		Bitmap *bmp = NULL;
		if (map[CurrentMap]->ClassID() == Class_ID(BMTEX_CLASS_ID,0) )
			{
			isBitmap = 1;
			BitmapTex *bmt;
			bmt = (BitmapTex *) map[CurrentMap];
			bmp = bmt->GetBitmap(ip->GetTime());
			if (bmp!= NULL)
				{
				if (useBitmapRes)
					{
					bitmapWidth = bmp->Width();
					bitmapHeight = bmp->Height();
					iw = bitmapWidth;
					ih = bitmapHeight;
					aspect = (float)bitmapWidth/(float)bitmapHeight;
					}
				else	
					{
					bitmapWidth = iw;
					bitmapHeight = ih;

					aspect = (float)iw/(float)ih;
					}


				}
			}
		else
			{
			isBitmap = 0;
			}
		if (iw==0 || ih==0) return;
		map[CurrentMap]->Update(ip->GetTime(), FOREVER);
		map[CurrentMap]->LoadMapFiles(ip->GetTime());
		SetCursor(LoadCursor(NULL,IDC_WAIT));
//		if (isBitmap)
//			image = RenderTexMap(map[CurrentMap],bitmapWidth,bitmapHeight);
//		else 
		if (map[CurrentMap]->ClassID() == Class_ID(BMTEX_CLASS_ID,0) )
			{
			if (bmp != NULL)
				{
				if (useBitmapRes)
					image = RenderBitmap(bmp,iw,ih);
				else image = RenderTexMap(map[CurrentMap],iw,ih);
				}
			}
		else image = RenderTexMap(map[CurrentMap],iw,ih);
		SetCursor(LoadCursor(NULL,IDC_ARROW));
		InvalidateView();
		}
	if (image) iShowMap->Enable();
	else iShowMap->Disable();
	}

void UnwrapMod::PlugControllers()
	{
	theHold.Begin();
	SuspendAnimate();
	AnimateOff();
	for (int i=0; i<TVMaps.v.Count(); i++) {
		if ((vsel[i] && !TVMaps.cont[i]) || ((TVMaps.v[i].influence != 0.0f) && !TVMaps.cont[i])){
			ReplaceReference(i+11,NewDefaultPoint3Controller());			
			TVMaps.cont[i]->SetValue(0,&TVMaps.v[i].p);
			}
		}
	ResumeAnimate();
	theHold.Accept(_T(GetString(IDS_PW_ASSIGN_CONTROLLER)));
	}

int UnwrapMod::GetAxis()
{
return 2;
return axis;
}

Point3 UnwrapMod::GetPoint(TimeValue t,int i)
	{
	if (i>=TVMaps.cont.Count() || i>= TVMaps.v.Count()) {
		return Point3(0,0,0);
		}
	if (TVMaps.v[i].flags & FLAG_DEAD) {
		return Point3(0,0,0);
		}

	if (TVMaps.cont[i]) TVMaps.cont[i]->GetValue(t,&TVMaps.v[i].p,FOREVER);
	return TVMaps.v[i].p;
	}


void UnwrapMod::BuildObjectPoints()
{
	objectPointList.SetCount(TVMaps.v.Count());

	Point3 p(0.0f,0.0f,0.0f);
	for (int i = 0; i < TVMaps.f.Count(); i++)
		{
		int pcount = 3;
		if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;
		for (int j = 0 ; j < pcount; j++)
			{
			if (TVMaps.f[i].t[j]<objectPointList.Count())
				objectPointList[TVMaps.f[i].t[j]] = TVMaps.f[i].pt[j];
//			if (index == TVMaps.f[i].t[j])
//				return TVMaps.f[i].pt[j];
			}
			
		}

}

Point3 UnwrapMod::GetObjectPoint(TimeValue t,int index)
	{

	Point3 p(0.0f,0.0f,0.0f);
	if (index<objectPointList.Count())
		p = objectPointList[index];
/*	for (int i = 0; i < TVMaps.f.Count(); i++)
		{
		int pcount = 3;
		if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;
		for (int j = 0 ; j < pcount; j++)
			{
			if (index == TVMaps.f[i].t[j])
				return TVMaps.f[i].pt[j];
			}
			
		}
*/
	return p;

	}
/*
Point3 UnwrapMod::GetObjectPoint(TimeValue t,int index)
	{
	Point3 p(0.0f,0.0f,0.0f);
	for (int i = 0; i < TVMaps.f.Count(); i++)
		{
		int pcount = 3;
		if (TVMaps.f[i].flags & FLAG_QUAD) pcount = 4;
		for (int j = 0 ; j < pcount; j++)
			{
			if (index == TVMaps.f[i].t[j])
				return TVMaps.f[i].pt[j];
			}
			
		}
	return p;

	}
*/

void UnwrapMod::ZoomExtents()
	{
	Rect brect;
	Point2 pt;
	float xzoom, yzoom;
	int width,height;
	TimeValue t = ip->GetTime();
	ComputeZooms(hView,xzoom,yzoom,width,height);	
	brect.SetEmpty();
	IsSelectedSetup();
	for (int i=0; i<TVMaps.v.Count(); i++) {		
		if (!(TVMaps.v[i].flags & FLAG_DEAD))
			{
			if (IsVertVisible(i))
				{
				pt = UVWToScreen(GetPoint(t,i),xzoom,yzoom,width,height);
				IPoint2 ipt(int(pt.x),int(pt.y));
				brect += ipt;		
				}
			}
		}
	Rect srect;
	GetClientRect(hView,&srect);		
	float rat1, rat2;
	rat1 = float(srect.w()-1)/float(fabs(double(brect.w()-1)));
	rat2 = float(srect.h()-1)/float(fabs(double(brect.h()-1)));
	float rat = (rat1<rat2?rat1:rat2) * 0.9f;
	zoom *= rat;
	IPoint2 delta = srect.GetCenter() - brect.GetCenter();
	xscroll += delta.x;
	yscroll += delta.y;
	xscroll *= rat;
	yscroll *= rat;	
	InvalidateView();
	}


void UnwrapMod::ZoomSelected()
	{
	Rect brect;
	Point2 pt;
	float xzoom, yzoom;
	int width,height;
	TimeValue t = ip->GetTime();
	ComputeZooms(hView,xzoom,yzoom,width,height);	
	brect.SetEmpty();
	int found = 0;
	for (int i=0; i<TVMaps.v.Count(); i++) {		
		if (!(TVMaps.v[i].flags & FLAG_DEAD))
			{
			if (vsel[i])
				{
				pt = UVWToScreen(GetPoint(t,i),xzoom,yzoom,width,height);
				IPoint2 ipt(int(pt.x),int(pt.y));
				brect += ipt;		
				found++;
				}
			}
		}
	if (found <=1) return;
	Rect srect;
	GetClientRect(hView,&srect);		
	float rat1 = 1.0f, rat2 = 1.0f;
	if (brect.w()>2.0f )
		rat1 = float(srect.w()-1)/float(fabs(double(brect.w()-1)));
	if (brect.h()>2.0f )
		rat2 = float(srect.h()-1)/float(fabs(double(brect.h()-1)));
	float rat = (rat1<rat2?rat1:rat2) * 0.9f;
	zoom *= rat;
	IPoint2 delta = srect.GetCenter() - brect.GetCenter();
	xscroll += delta.x;
	yscroll += delta.y;
	xscroll *= rat;
	yscroll *= rat;	
	InvalidateView();
	}


void UnwrapMod::AlignMap()
	{
	TimeValue t = ip->GetTime();	
	GeomObject *obj;
	Point3 norm, pt;
	Interval valid;

	// Get mod contexts and nodes for this modifier
	ModContextList mcList;
	INodeTab nodeList;
	ip->GetModContexts(mcList,nodeList);

	// Calculate a ray from the mouse point

	for (int i=0; i<nodeList.Count(); i++) {
		INode *node = nodeList[i];

		// Get the object from the node
		ObjectState os = node->EvalWorldState(t);
		if (os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID) {
			obj = (GeomObject*)os.obj;
		} else {
			continue;
			}

//compute the average normal or use x/y/z
		// See if we hit the object
//find center of selection
//average normal if needed
		Point3 zeroPoint(.0f,.0f,.0f);
		Ray ray;
		ray.p  = zeroPoint;
		ray.dir = zeroPoint;
		int dir = alignDir;
		if (dir == 0) //x
			{
			ray.dir.x = 1.0f; 
			norm = -ray.dir;
			}
		else if (dir == 1) //y
			{	
			ray.dir.y = 1.0f; 
			norm = -ray.dir;
			}	
		else if (dir == 2) //z
			{
			ray.dir.z = 1.0f; 
			norm = ray.dir;
			}
		else
			{
//compute average normal
			Point3 pnorm(0.0f,0.0f,0.0f);
			for (int k=0; k<gfaces.Count(); k++) {
			// Grap the three points, xformed
				int pcount = 3;
				if (gfaces[k].flags & FLAG_QUAD) pcount = 4;

				Point3 temp_point[4];
				for (int j=0; j<pcount; j++) {
					int index = gfaces[k].t[j];
//					Point3 temp_point;
					temp_point[j] = gverts.d[index].p;
					}
				pnorm += Normalize(temp_point[1]-temp_point[0]^temp_point[2]-temp_point[1]);
				}
			ray.dir = pnorm / (float) gfaces.Count();
			norm = -ray.dir;
			}


//		if (obj->IntersectRay(t,ray,at,norm)) {
		if (1) {
			// Calculate the hit point
			pt = ray.p + ray.dir;
					
			// Get the mod context tm
			Matrix3 tm(1);
			if (mcList[0]->tm) tm = tm * *mcList[0]->tm;
		
			// Transform the point and ray into mod context space
			pt = pt * tm;
			norm = Normalize(VectorTransform(tm,norm));
		
			// Construct the target transformation in mod context space
			Matrix3 destTM;
			UnwrapMatrixFromNormal(norm,destTM);
			destTM.SetTrans(pt);
			destTM.PreRotateZ(0);

			switch (GetAxis()) {
				case 0:
					destTM.PreRotateY(-HALFPI);
					break;
				case 1:
					destTM.PreRotateX(HALFPI);
					break;

				}

			// Our current transformation... gives relative TM
			Matrix3 curTM(1), relTM, id(1);
			tmControl->GetValue(t,&curTM,valid,CTRL_RELATIVE);
			relTM = Inverse(curTM) * destTM;
		
			// Here's the modifications we need to make to get there
			tm.IdentityMatrix();
			tm.SetTrans(curTM.GetTrans());
			AffineParts parts;			
			decomp_affine(relTM,&parts);
			Point3 delta = destTM.GetTrans()-curTM.GetTrans();
			Rotate(t,id,tm,parts.q);
			Move(t,id,id,delta);
			break;
			}
		}

	nodeList.DisposeTemporary();
	}

//--- Mouse procs for modes -----------------------------------------------

int SelectMode::proc(HWND hWnd, int msg, int point, int flags, IPoint2 m)
	{
	switch (msg) {
		case MOUSE_POINT:
			if (point==0) {
				// First click
				
				region   = FALSE;
				toggle   = flags&MOUSE_CTRL;
				subtract = flags&MOUSE_ALT;
				
				// Hit test
				Tab<int> hits;
				Rect rect;
				rect.left = m.x-2;
				rect.right = m.x+2;
				rect.top = m.y-2;
				rect.bottom = m.y+2;
				// First hit test sel only
				mod->centeron = 0;
				if (toggle && subtract)
					{
					mod->centeron = 1;
					return subproc(hWnd,msg,point,flags,m);
					}
				
				// First hit test sel only
				if ((!toggle && !subtract && mod->HitTest(rect,hits,TRUE)) || (mod->lockSelected==1)){
					return subproc(hWnd,msg,point,flags,m);
				} else
				// Next hit test everything
				if (mod->HitTest(rect,hits,subtract)) {
					theHold.Begin();
					if (!toggle && !subtract) mod->ClearSelect();
					mod->Select(hits,toggle,subtract,FALSE);
					mod->InvalidateView();
					theHold.Accept(_T(GetString(IDS_PW_SELECT_UVW)));
					mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mod->ip->RedrawViews(mod->ip->GetTime());

					if (toggle || subtract) return FALSE;
					return subproc(hWnd,msg,point,flags,m);
				} else {					
					region = TRUE;
					lm = om = m;
					XORDottedRect(hWnd,om,m);
					}				
			} else {
				// Second click
				if (region) {
					Rect rect;
					rect.left   = om.x;
					rect.top    = om.y;
					rect.right  = m.x;
					rect.bottom = m.y;
					rect.Rectify();					
					Tab<int> hits;
					theHold.Begin();
					if (!toggle && !subtract) mod->ClearSelect();
					if (mod->HitTest(rect,hits,subtract)) {						
						mod->Select(hits,FALSE,subtract,TRUE);											
						}
					theHold.Accept(_T(GetString(IDS_PW_SELECT_UVW)));
					
					mod->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mod->ip->RedrawViews(mod->ip->GetTime());

					mod->InvalidateView();
				} else {
					return subproc(hWnd,msg,point,flags,m);
					}
				}
			break;			

		case MOUSE_MOVE:
			SetCursor(LoadCursor(NULL, IDC_ARROW));
			if (region) {
				XORDottedRect(hWnd,om,lm);
				XORDottedRect(hWnd,om,m);
				lm = m;
			} else {
				SetCursor(GetXFormCur());
				return subproc(hWnd,msg,point,flags,m);
				}
			break;
		case MOUSE_FREEMOVE: {
			Tab<int> hits;
			Rect rect;
			rect.left = m.x-2;
			rect.right = m.x+2;
			rect.top = m.y-2;
			rect.bottom = m.y+2;

			if ((flags&MOUSE_CTRL) &&  (flags&MOUSE_ALT))
				mod->ip->ReplacePrompt( GetString(IDS_PW_MOUSE_CENTER));
			else if (flags&MOUSE_CTRL)
				mod->ip->ReplacePrompt( GetString(IDS_PW_MOUSE_ADD));
			else if (flags&MOUSE_ALT)
				mod->ip->ReplacePrompt( GetString(IDS_PW_MOUSE_SUBTRACT));
			else if (flags&MOUSE_SHIFT)
				mod->ip->ReplacePrompt( GetString(IDS_PW_MOUSE_CONSTRAIN));
			else mod->ip->ReplacePrompt( GetString(IDS_PW_MOUSE_SELECTTV));


			if (mod->HitTest(rect,hits,FALSE)) {
				if (mod->vsel[hits[0]]) {
					SetCursor(GetXFormCur());
				} else {
					SetCursor(selCur);
					}
			} else {
				SetCursor(LoadCursor(NULL, IDC_ARROW));
				}


			return subproc(hWnd,msg,point,flags,m);
			}

		case MOUSE_ABORT:
			if (region) {
				InvalidateRect(hWnd,NULL,FALSE);
			} else {
				return subproc(hWnd,msg,point,flags,m);
				}
			break;
		}
	return 1;
	}

int MoveMode::subproc(HWND hWnd, int msg, int point, int flags, IPoint2 m)
	{
	switch (msg) {
		case MOUSE_POINT:
			if (point==0) {
				theHold.SuperBegin();
				mod->PlugControllers();
				theHold.Begin();
				om = m;
			} else {
				theHold.Accept(_T(GetString(IDS_PW_MOVE_UVW)));
				theHold.SuperAccept(_T(GetString(IDS_PW_MOVE_UVW)));
				mod->ip->RedrawViews(mod->ip->GetTime());
				}
			break;

		case MOUSE_MOVE: {
			theHold.Restore();
			float xzoom, yzoom;
			int width, height;
			IPoint2 delta = m-om;
			if (flags&MOUSE_SHIFT && mod->move==0) {
				if (abs(delta.x) > abs(delta.y)) delta.y = 0;
				else delta.x = 0;
			} else if (mod->move==1) {
				delta.y = 0;
			} else if (mod->move==2) {
				delta.x = 0;
				}
			mod->ComputeZooms(hWnd,xzoom,yzoom,width,height);
			Point2 mv;
			mv.x = delta.x/xzoom;
			mv.y = -delta.y/yzoom;
//check if moving points or gizmo

			if ( (mod->ip && (mod->ip->GetSubObjectLevel() == 3) ))
				{
//				mv.x += (float)om.x/xzoom;
//				mv.y += (float)om.y/yzoom;

				mod->MoveGizmo(mv);
				}
			else mod->MovePoints(mv);
	
	

			if (mod->update) mod->ip->RedrawViews(mod->ip->GetTime());
			UpdateWindow(hWnd);
			break;		
			}


		case MOUSE_ABORT:
			if ( (mod->ip && (mod->ip->GetSubObjectLevel() == 3) ))
				{
				}
			else
				{
				theHold.Cancel();
				theHold.SuperCancel();
				}
			mod->ip->RedrawViews(mod->ip->GetTime());
			break;
		}
	return 1;
	}

#define ZOOM_FACT	0.01f
#define ROT_FACT	DegToRad(0.5f)

int RotateMode::subproc(HWND hWnd, int msg, int point, int flags, IPoint2 m)
	{
	switch (msg) {
		case MOUSE_POINT:
			if (point==0) {
				theHold.SuperBegin();
				mod->PlugControllers();
				theHold.Begin();
				mod->center.x = (float) m.x;
				mod->center.y = (float) m.y;
				om = m;
			} else {
				theHold.Accept(_T(GetString(IDS_PW_ROTATE_UVW)));
				theHold.SuperAccept(_T(GetString(IDS_PW_ROTATE_UVW)));
				mod->ip->RedrawViews(mod->ip->GetTime());
				}
			break;

		case MOUSE_MOVE:
			theHold.Restore();
			if ( (mod->ip && (mod->ip->GetSubObjectLevel() == 3) ))
				{
				mod->RotateGizmo(hWnd,float(m.y-om.y)*ROT_FACT);
				}
			else mod->RotatePoints(hWnd,float(m.y-om.y)*ROT_FACT);
			if (mod->update) mod->ip->RedrawViews(mod->ip->GetTime());
			UpdateWindow(hWnd);
			break;		

		case MOUSE_ABORT:
			theHold.Cancel();
			theHold.SuperCancel();
			mod->ip->RedrawViews(mod->ip->GetTime());
			break;
		}
	return 1;
	}

int ScaleMode::subproc(HWND hWnd, int msg, int point, int flags, IPoint2 m)
	{
	switch (msg) {
		case MOUSE_POINT:
			if (point==0) {
				theHold.SuperBegin();
				mod->PlugControllers();
				theHold.Begin();
				mod->center.x = (float) m.x;
				mod->center.y = (float) m.y;
				om = m;
			} else {
				theHold.Accept(_T(GetString(IDS_PW_SCALE_UVW)));
				theHold.SuperAccept(_T(GetString(IDS_PW_SCALE_UVW)));
				mod->ip->RedrawViews(mod->ip->GetTime());
				}
			break;

		case MOUSE_MOVE: {
			theHold.Restore();
			IPoint2 delta = om-m;
			int direction = 0;
			if (flags&MOUSE_SHIFT ){
				if (abs(delta.x) > abs(delta.y)) 
					{
					delta.y = 0;
					direction = 1;
					}
				else 
					{	
					delta.x = 0;
					direction = 2;
					}
				}
			else if (mod->scale > 0)
				{
				if (mod->scale == 1) 
					{
					delta.y = 0;
					direction = 1;
					}
				else if (mod->scale == 2) 
					{	
					delta.x = 0;
					direction = 2;
					}

				}

			float z;
			if (direction == 0)
				{
				if (delta.y<0)
					 z = (1.0f/(1.0f-ZOOM_FACT*delta.y));
				else z = (1.0f+ZOOM_FACT*delta.y);
				}
			else if (direction == 1)
				{
				if (delta.x<0)
					 z = (1.0f/(1.0f-ZOOM_FACT*delta.x));
				else z = (1.0f+ZOOM_FACT*delta.x);

				}
			else if (direction == 2)
				{
				if (delta.y<0)
					 z = (1.0f/(1.0f-ZOOM_FACT*delta.y));
				else z = (1.0f+ZOOM_FACT*delta.y);
				}
//Rect rect;
//GetWindowRect(hWnd,&rect);	
			if ( (mod->ip && (mod->ip->GetSubObjectLevel() == 3) ))
				{
				mod->ScaleGizmo(hWnd, z,direction);
				}
			else mod->ScalePoints(hWnd, z,direction);
/*
			if (delta.y<0)
				 z = (1.0f/(1.0f-ZOOM_FACT*delta.y));
			else z = (1.0f+ZOOM_FACT*delta.y);
			mod->ScalePoints(z);
*/
			if (mod->update) mod->ip->RedrawViews(mod->ip->GetTime());
			UpdateWindow(hWnd);
			break;
			}

		case MOUSE_ABORT:
			theHold.Cancel();
			theHold.SuperCancel();
			mod->ip->RedrawViews(mod->ip->GetTime());
			break;
		}
	return 1;
	}

int WeldMode::subproc(HWND hWnd, int msg, int point, int flags, IPoint2 m)
	{
	switch (msg) {
		case MOUSE_POINT:
			if (point==0) {
				theHold.SuperBegin();
		 		mod->PlugControllers();
				theHold.Begin();
				om = m;
			} else {
				if (mod->WeldPoints(hWnd,m))
					{
					theHold.Accept(_T(GetString(IDS_PW_WELD_UVW)));
					theHold.SuperAccept(_T(GetString(IDS_PW_WELD_UVW)));
					}
				else{
					theHold.Accept(_T(GetString(IDS_PW_MOVE_UVW)));
					theHold.SuperAccept(_T(GetString(IDS_PW_MOVE_UVW)));
					}
				mod->ip->RedrawViews(mod->ip->GetTime());
				}
			break;

		case MOUSE_MOVE: {
			theHold.Restore();
			float xzoom, yzoom;
			int width, height;
			IPoint2 delta = m-om;
			if (flags&MOUSE_SHIFT && mod->move==0) {
				if (abs(delta.x) > abs(delta.y)) delta.y = 0;
				else delta.x = 0;
			} else if (mod->move==1) {
				delta.y = 0;
			} else if (mod->move==2) {
				delta.x = 0;
				}
			mod->ComputeZooms(hWnd,xzoom,yzoom,width,height);
			Point2 mv;
			mv.x = delta.x/xzoom;
			mv.y = -delta.y/yzoom;
			mod->MovePoints(mv);
			if (mod->update) mod->ip->RedrawViews(mod->ip->GetTime());
			UpdateWindow(hWnd);
			break;		
			}

		case MOUSE_ABORT:
			theHold.Cancel();
			theHold.SuperCancel();
			mod->ip->RedrawViews(mod->ip->GetTime());
			break;
		}
	return 1;
	}


int PanMode::proc(HWND hWnd, int msg, int point, int flags, IPoint2 m)
	{
	switch (msg) {
		case MOUSE_POINT:
			if (point==0) {
				om = m;
				oxscroll = mod->xscroll;
				oyscroll = mod->yscroll;
				}
			break;

		case MOUSE_MOVE: {
			IPoint2 delta = m-om;
			mod->xscroll = oxscroll + float(delta.x);
			mod->yscroll = oyscroll + float(delta.y);
			mod->InvalidateView();
			SetCursor(GetPanCursor());
			break;
			}

		case MOUSE_ABORT:
			mod->xscroll = oxscroll;
			mod->yscroll = oyscroll;
			mod->InvalidateView();
			break;

		case MOUSE_FREEMOVE:
			SetCursor(GetPanCursor());
			break;		
		}
	return 1;
	}

int ZoomMode::proc(HWND hWnd, int msg, int point, int flags, IPoint2 m)
	{
	switch (msg) {
		case MOUSE_POINT:
			if (point==0) {
				om = m;
				ozoom = mod->zoom;
				oxscroll = mod->xscroll;
				oyscroll = mod->yscroll;
				}
			break;

		case MOUSE_MOVE: {
			IPoint2 delta = om-m;
			float z;
			if (delta.y<0)
				 z = (1.0f/(1.0f-ZOOM_FACT*delta.y));
			else z = (1.0f+ZOOM_FACT*delta.y);
			mod->zoom = ozoom * z;
			mod->xscroll = oxscroll*z;
			mod->yscroll = oyscroll*z;
			mod->InvalidateView();
			SetCursor(zoomCur);

//			SetCursor(LoadCursor(NULL, IDC_ARROW));
			break;
			}

		case MOUSE_ABORT:
			mod->zoom = ozoom;
			mod->xscroll = oxscroll;
			mod->yscroll = oyscroll;
			mod->InvalidateView();
			break;

		case MOUSE_FREEMOVE:
			SetCursor(zoomCur);

//			SetCursor(LoadCursor(NULL, IDC_ARROW));
			break;		
		}
	return 1;
	}

int ZoomRegMode::proc(HWND hWnd, int msg, int point, int flags, IPoint2 m)
	{
	switch (msg) {
		case MOUSE_POINT:
			if (point==0) {
				lm = om = m;
				XORDottedRect(hWnd,om,lm);
			} else {

				if (om!=m)
				{

					Rect rect;
					GetClientRect(hWnd,&rect);
					IPoint2 mcent = (om+m)/2;
					IPoint2 scent = rect.GetCenter();
					IPoint2 delta = m-om;
					float rat1, rat2;
					if ((delta.x  != 0) && (delta.y != 0))
						{
						rat1 = float(rect.w()-1)/float(fabs((double)delta.x));
						rat2 = float(rect.h()-1)/float(fabs((double)delta.y));
						float rat = rat1<rat2?rat1:rat2;
						mod->zoom *= rat;
						delta = scent - mcent;
						mod->xscroll += delta.x;
						mod->yscroll += delta.y;
						mod->xscroll *= rat;
						mod->yscroll *= rat;
						}
					}
				mod->InvalidateView();
				}
			break;

		case MOUSE_MOVE:
			XORDottedRect(hWnd,om,lm);
			XORDottedRect(hWnd,om,m);
			lm = m;
			SetCursor(zoomRegionCur);
			break;

		case MOUSE_ABORT:
			InvalidateRect(hWnd,NULL,FALSE);
			break;
		
		case MOUSE_FREEMOVE:
			SetCursor(zoomRegionCur);
			break;		
		}
	return 1;
	}

int RightMouseMode::proc(HWND hWnd, int msg, int point, int flags, IPoint2 m)
	{
	switch (msg) {
		case MOUSE_POINT:
		case MOUSE_PROPCLICK:
//check if in pan zoom or soom region mode
			if ( (mod->mode == ID_UNWRAP_PAN) ||
				 (mod->mode == ID_TOOL_PAN) ||
				 (mod->mode == ID_UNWRAP_ZOOM) ||
				 (mod->mode == ID_TOOL_ZOOM) ||
				 (mod->mode == ID_UNWRAP_ZOOMREGION) ||
				 (mod->mode == ID_TOOL_ZOOMREG) ||
				 (mod->mode == ID_UNWRAP_WELD) ||
				 (mod->mode == ID_TOOL_WELD) 
				)
				{
				if (!( (mod->oldMode == ID_UNWRAP_PAN) ||
					 (mod->oldMode == ID_TOOL_PAN) ||
					 (mod->oldMode == ID_UNWRAP_ZOOM) ||
					 (mod->oldMode == ID_TOOL_ZOOM) ||
					 (mod->oldMode == ID_UNWRAP_ZOOMREGION) ||
					 (mod->oldMode == ID_TOOL_ZOOMREG) ||
					 (mod->oldMode == ID_UNWRAP_WELD) ||
					 (mod->oldMode == ID_TOOL_WELD) 
					))
					{
					mod->SetMode(mod->oldMode);
					}
				else mod->TrackRBMenu(hWnd, m.x, m.y);

				}
			else mod->TrackRBMenu(hWnd, m.x, m.y);
			break;
		}
	return 1;
	}

int MiddleMouseMode::proc(HWND hWnd, int msg, int point, int flags, IPoint2 m)
	{
	static int modeType = 0;
	switch (msg) {
			
		case MOUSE_POINT:
			if (point==0) {
				BOOL ctrl = flags & MOUSE_CTRL;
				BOOL alt = flags & MOUSE_ALT;

				if (ctrl && alt)
					{
					modeType = ID_TOOL_ZOOM;
					ozoom = mod->zoom;
					}
				else modeType = ID_TOOL_PAN;

				om = m;
				oxscroll = mod->xscroll;
				oyscroll = mod->yscroll;
				}
			break;

		case MOUSE_MOVE: {
			if (modeType == ID_TOOL_PAN)
				{
				IPoint2 delta = m-om;
				mod->xscroll = oxscroll + float(delta.x);
				mod->yscroll = oyscroll + float(delta.y);
				mod->InvalidateView();
				SetCursor(GetPanCursor());
				}
			else if (modeType == ID_TOOL_ZOOM)
				{
				IPoint2 delta = om-m;
				float z;
				if (delta.y<0)
					 z = (1.0f/(1.0f-ZOOM_FACT*delta.y));
				else z = (1.0f+ZOOM_FACT*delta.y);
				mod->zoom = ozoom * z;
				mod->xscroll = oxscroll*z;
				mod->yscroll = oyscroll*z;
				mod->InvalidateView();
				SetCursor(zoomCur);
				}
			break;
			}

		case MOUSE_ABORT:
			mod->xscroll = oxscroll;
			mod->yscroll = oyscroll;
			if (modeType == ID_TOOL_ZOOM)
				mod->zoom = ozoom;
			mod->InvalidateView();
			break;



/*		case MOUSE_FREEMOVE:
			SetCursor(GetPanCursor());
			break;		
*/

/*
		case MOUSE_PROPCLICK:
//check if in pan zoom or soom region mode
			if ( (mod->mode == ID_UNWRAP_PAN) ||
				 (mod->mode == ID_TOOL_PAN) ||
				 (mod->mode == ID_UNWRAP_ZOOM) ||
				 (mod->mode == ID_TOOL_ZOOM) ||
				 (mod->mode == ID_UNWRAP_ZOOMREGION) ||
				 (mod->mode == ID_TOOL_ZOOMREG) ||
				 (mod->mode == ID_UNWRAP_WELD) ||
				 (mod->mode == ID_TOOL_WELD) 
				)
				mod->SetMode(mod->oldMode);
			else mod->TrackRBMenu(hWnd, m.x, m.y);
			break;
*/
		}
	return 1;
	}


static BOOL CALLBACK PropDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	static IColorSwatch *iSelColor, *iLineColor;
	static ISpinnerControl *spinW, *spinH;
	static ISpinnerControl *spinThreshold ;

	UnwrapMod *mod = (UnwrapMod*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG: {
			mod = (UnwrapMod*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			
			iSelColor = GetIColorSwatch(GetDlgItem(hWnd,IDC_UNWRAP_SELCOLOR), 
				mod->selColor, _T(GetString(IDS_PW_LINECOLOR)));			
			iLineColor = GetIColorSwatch(GetDlgItem(hWnd,IDC_UNWRAP_LINECOLOR), 
				mod->lineColor, _T(GetString(IDS_PW_LINECOLOR)));						
			
			CheckDlgButton(hWnd,IDC_UNWRAP_CONSTANTUPDATE,mod->update);


			CheckDlgButton(hWnd,IDC_UNWRAP_SELECT_VERTS,mod->showVerts);
			CheckDlgButton(hWnd,IDC_UNWRAP_MIDPIXEL_SNAP,mod->midPixelSnap);

			CheckDlgButton(hWnd,IDC_UNWRAP_USEBITMAPRES,mod->useBitmapRes);
			if ((mod->map[mod->CurrentMap]) && (mod->map[mod->CurrentMap]->ClassID() != Class_ID(BMTEX_CLASS_ID,0) ) )
				EnableWindow(GetDlgItem(hWnd,IDC_UNWRAP_USEBITMAPRES),FALSE);
			
			spinThreshold = SetupFloatSpinner(
				hWnd,IDC_UNWRAP_WELDTHRESHSPIN,IDC_UNWRAP_WELDTHRESH,
				0.0f,10.0f,mod->weldThreshold);			
			spinW = SetupIntSpinner(
				hWnd,IDC_UNWRAP_WIDTHSPIN,IDC_UNWRAP_WIDTH,
				10,1000,mod->rendW);			
			spinH = SetupIntSpinner(
				hWnd,IDC_UNWRAP_HEIGHTSPIN,IDC_UNWRAP_HEIGHT,
				10,1000,mod->rendH);			
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					{
					mod->lineColor = iLineColor->GetColor();
					mod->selColor  = iSelColor->GetColor();					
					mod->update = IsDlgButtonChecked(hWnd,IDC_UNWRAP_CONSTANTUPDATE);
					mod->showVerts = IsDlgButtonChecked(hWnd,IDC_UNWRAP_SELECT_VERTS);
					mod->midPixelSnap = IsDlgButtonChecked(hWnd,IDC_UNWRAP_MIDPIXEL_SNAP);
//watje 5-3-99
					BOOL oldRes = mod->useBitmapRes;

					mod->useBitmapRes = IsDlgButtonChecked(hWnd,IDC_UNWRAP_USEBITMAPRES);
					mod->weldThreshold = spinThreshold->GetFVal();
					mod->rendW = spinW->GetIVal();
					mod->rendH = spinH->GetIVal();
//watje 5-3-99
					if (mod->rendW!=mod->iw ||
						mod->rendH!=mod->ih || oldRes!=mod->useBitmapRes) {
						mod->SetupImage();
						}
					mod->InvalidateView();
					//fall through
					}
				case IDCANCEL:
					ReleaseIColorSwatch(iSelColor);
					ReleaseIColorSwatch(iLineColor);
					ReleaseISpinner(spinThreshold);
					ReleaseISpinner(spinW);
					ReleaseISpinner(spinH);
					EndDialog(hWnd,0);
					break;

				case IDC_UNWRAP_DEFAULTS:
					iLineColor->SetColor(RGB(255,255,255));
					iSelColor->SetColor(RGB(255,0,0));
					spinW->SetValue(256,FALSE);
					spinH->SetValue(256,FALSE);					
					spinThreshold->SetValue(2,FALSE);					
					CheckDlgButton(hWnd,IDC_UNWRAP_CONSTANTUPDATE,TRUE);
					CheckDlgButton(hWnd,IDC_UNWRAP_SELECT_VERTS,TRUE);
					CheckDlgButton(hWnd,IDC_UNWRAP_MIDPIXEL_SNAP,FALSE);
					CheckDlgButton(hWnd,IDC_UNWRAP_USEBITMAPRES,TRUE);
					break;
				}
			break;

		default:
			return FALSE;
		} 
	return TRUE;
	}

void UnwrapMod::PropDialog() 
	{
	DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_UNWRAP_PROP),
		hWnd,
		PropDlgProc,
		(LONG)this);
	}


static void UnwrapMatrixFromNormal(Point3& normal, Matrix3& mat)
	{
	Point3 vx;
	vx.z = .0f;
	vx.x = -normal.y;
	vx.y = normal.x;	
	if ( vx.x == .0f && vx.y == .0f ) {
		vx.x = 1.0f;
		}
	mat.SetRow(0,vx);
	mat.SetRow(1,normal^vx);
	mat.SetRow(2,normal);
	mat.SetTrans(Point3(0,0,0));
	mat.NoScale();
	}

void UnwrapFaceAlignMouseProc::FaceAlignMap(HWND hWnd,IPoint2 m)
	{
	ViewExp *vpt = ip->GetViewport(hWnd);
	if (!vpt) return;

	Ray ray, wray;
	float at;
	TimeValue t = ip->GetTime();	
	GeomObject *obj;
	Point3 norm, pt;
	Interval valid;

	// Get mod contexts and nodes for this modifier
	ModContextList mcList;
	INodeTab nodeList;
	ip->GetModContexts(mcList,nodeList);

	// Calculate a ray from the mouse point
	vpt->MapScreenToWorldRay(float(m.x), float(m.y),wray);

	for (int i=0; i<nodeList.Count(); i++) {
		INode *node = nodeList[i];

		// Get the object from the node
		ObjectState os = node->EvalWorldState(t);
		if (os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID) {
			obj = (GeomObject*)os.obj;
		} else {
			continue;
			}

		// Back transform the ray into object space.		
		Matrix3 obtm  = node->GetObjectTM(t);
		Matrix3 iobtm = Inverse(obtm);
		ray.p   = iobtm * wray.p;
		ray.dir = VectorTransform(iobtm, wray.dir);
	
		// See if we hit the object
		if (obj->IntersectRay(t,ray,at,norm)) {
			// Calculate the hit point
			pt = ray.p + ray.dir * at;
					
			// Get the mod context tm
			Matrix3 tm(1);
			if (mcList[0]->tm) tm = tm * *mcList[0]->tm;
		
			// Transform the point and ray into mod context space
			pt = pt * tm;
			norm = Normalize(VectorTransform(tm,norm));
		
			// Construct the target transformation in mod context space
			Matrix3 destTM;
			UnwrapMatrixFromNormal(norm,destTM);
			destTM.SetTrans(pt);
			destTM.PreRotateZ(0);

			switch (mod->GetAxis()) {
				case 0:
					destTM.PreRotateY(-HALFPI);
					break;
				case 1:
					destTM.PreRotateX(HALFPI);
					break;

				}

			// Our current transformation... gives relative TM
			Matrix3 curTM(1), relTM, id(1);
			mod->tmControl->GetValue(t,&curTM,valid,CTRL_RELATIVE);
			relTM = Inverse(curTM) * destTM;
		
			// Here's the modifications we need to make to get there
			tm.IdentityMatrix();
			tm.SetTrans(curTM.GetTrans());
			AffineParts parts;			
			decomp_affine(relTM,&parts);
			Point3 delta = destTM.GetTrans()-curTM.GetTrans();
			mod->Rotate(t,id,tm,parts.q);
			mod->Move(t,id,id,delta);
			break;
			}
		}

	nodeList.DisposeTemporary();
	ip->ReleaseViewport(vpt);
	}



int UnwrapFaceAlignMouseProc::proc(
		HWND hWnd, int msg, int point, int flags, IPoint2 m)
	{
	switch (msg) {
		case MOUSE_POINT:
			if (point==0) {				
				theHold.Begin();
				ip->RedrawViews(ip->GetTime(),REDRAW_BEGIN);
			} else {
				theHold.Accept(0);
				ip->RedrawViews(ip->GetTime(),REDRAW_END);
				}
			break;

		case MOUSE_MOVE: {
			theHold.Restore();
			FaceAlignMap(hWnd,m);
			ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);			
			break;
			}

		case MOUSE_ABORT:
			theHold.Cancel();
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			break;

		case MOUSE_FREEMOVE:			
			SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
			break;
		}
	return TRUE;
	}

void UnwrapFaceAlignMode::EnterMode()
	{
	mod->EnterNormalAlign();	
	}

void UnwrapFaceAlignMode::ExitMode()
	{
	mod->ExitNormalAlign();	
	}


void UnwrapRegionFitMouseProc::RegionFitMap(HWND hWnd,IPoint2 m)
	{
	ViewExp *vpt = ip->GetViewport(hWnd);
	if (!vpt) return;

	// Get mod contexts and nodes for this modifier
	ModContextList mcList;
	INodeTab nodeList;
	ip->GetModContexts(mcList,nodeList);

	// Viewport tm
	Matrix3 vtm;
	vpt->GetAffineTM(vtm);
	vtm = Inverse(vtm);

	// Node tm
	Matrix3 ntm = nodeList[0]->GetObjectTM(ip->GetTime());	
	
	// MC tm
	Matrix3 mctm(1);
	if (mcList[0]->tm) mctm = *mcList[0]->tm;

	// Current val of tmCont.. remove any scale
	Matrix3 ctm(1);
	mod->tmControl->GetValue(ip->GetTime(),&ctm,FOREVER,CTRL_RELATIVE);
	AffineParts parts;
	decomp_affine(ctm, &parts);
	parts.q.MakeMatrix(ctm);
	ctm.Translate(parts.t);
	
	// Compute the inverse world space tm for the gizmo
	Matrix3 iwtm = Inverse(ctm * Inverse(mctm) * ntm);
	
	// Calculate a ray from the two mouse points
	Ray mray, omray;
	float at;
	Point3 p1, p2;
	vpt->MapScreenToWorldRay(float(m.x), float(m.y),mray);
	vpt->MapScreenToWorldRay(float(om.x), float(om.y),omray);
	
	// Back transform the rays into gizmo space
	mray.p    = iwtm * mray.p;
	mray.dir  = VectorTransform(iwtm, mray.dir);
	omray.p   = iwtm * omray.p;
	omray.dir = VectorTransform(iwtm, omray.dir);

	float dir, pnt, odir, opnt;
/*
	switch (mod->GetAxis()) {
		case 0:
			dir = mray.dir.x; odir = omray.dir.x;
			pnt = mray.p.x; opnt = omray.p.x;
			break;
		case 1:
			dir = mray.dir.y; odir = omray.dir.y;
			pnt = mray.p.y; opnt = omray.p.y;
			break;
		case 2:
*/
			dir = mray.dir.z; odir = omray.dir.z;
			pnt = mray.p.z; opnt = omray.p.z;
/*
			break;
		}
*/
#define EPSILON	0.001
	// Make sure we're going to hit
	if (fabs(dir)>EPSILON && fabs(odir)>EPSILON) {
	
		// Compute the point of intersection
		at = -pnt/dir;
		p1 = mray.p + at*mray.dir;
		at = -opnt/odir;
		p2 = omray.p + at*omray.dir;
		
		// Center the map in the region
		ctm.PreTranslate((p1+p2)/2.0f);

		// Compute scale factors and scale
		float sx;
		float sy;
/*
		switch (mod->GetAxis()) {
			case 0:
				sx = (float)fabs(p1.z-p2.z);
				sy = (float)fabs(p1.y-p2.y);
				break;
			case 1:
				sx = (float)fabs(p1.x-p2.x);
				sy = (float)fabs(p1.z-p2.z);
				break;

			case 2:
*/
				sx = (float)fabs(p1.x-p2.x);
				sy = (float)fabs(p1.y-p2.y);
/*
				break;

			}
*/
		
		// Scale params instead of the matrix
		TimeValue t = ip->GetTime();		
/*		mod->SetWidth(t,sx);
		mod->SetLength(t,sy);		
*/
		mod->s.x = sx;
		mod->s.y = sy;
		/*
		if (sx>0.0f && sy>0.0f) {
			ctm.PreScale(Point3(sx,sy,1.0f));
			}
		*/

		// Plug-in the new value		
		SetXFormPacket pckt(ctm);
		mod->tmControl->SetValue(ip->GetTime(), &pckt);		
		}

	nodeList.DisposeTemporary();
	ip->ReleaseViewport(vpt);
	ip->RedrawViews(ip->GetTime());
	}

int UnwrapRegionFitMouseProc::proc(
		HWND hWnd, int msg, int point, int flags, IPoint2 m)
	{
	switch (msg) {
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:
			if (point==0) {				
				om = m;
				theHold.Begin();
				ip->RedrawViews(ip->GetTime(),REDRAW_BEGIN);
			} else {
				theHold.Accept(0);
				ip->RedrawViews(ip->GetTime(),REDRAW_END);
				}
			break;

		case MOUSE_MOVE: {
			theHold.Restore();
			RegionFitMap(hWnd,m);
			ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);			
			break;
			}

		case MOUSE_ABORT:
			theHold.Cancel();
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			break;

		case MOUSE_FREEMOVE:			
			SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
			break;
		}
	return TRUE;
	}

void UnwrapRegionFitMode::EnterMode()
	{
	mod->EnterRegionFit();	
	}

void UnwrapRegionFitMode::ExitMode()
	{
	mod->ExitRegionFit();	
	}

void UnwrapMod::EnterRegionFit()
	{
	SendMessage(GetDlgItem(hParams,IDC_UNWRAP_FIT),CC_COMMAND,CC_CMD_SET_STATE,1);
	}

void UnwrapMod::ExitRegionFit()
	{
	SendMessage(GetDlgItem(hParams,IDC_UNWRAP_FIT),CC_COMMAND,CC_CMD_SET_STATE,0);
	}

void UnwrapMod::EnterNormalAlign()
	{	
//	iAlignButton->SetCheck(TRUE );
//	SendMessage(GetDlgItem(hParams,IDC_UNWRAP_ALIGN_TO_NORMAL),CC_COMMAND,CC_CMD_SET_STATE,1);
	}

void UnwrapMod::ExitNormalAlign()
	{	
//	iAlignButton->SetCheck(FALSE );
//	SendMessage(GetDlgItem(hParams,IDC_UNWRAP_ALIGN_TO_NORMAL),CC_COMMAND,CC_CMD_SET_STATE,0);
	}



//--- Named selection sets -----------------------------------------

int UnwrapMod::FindSet(TSTR &setName) {
	for (int i=0; i<namedSel.Count(); i++) {
		if (setName == *namedSel[i]) return i;
	}
	return -1;
}

DWORD UnwrapMod::AddSet(TSTR &setName) {
	DWORD id = 0;
	TSTR *name = new TSTR(setName);
	namedSel.Append(1,&name);
	BOOL found = FALSE;
	while (!found) {
		found = TRUE;
		for (int i=0; i<ids.Count(); i++) {
			if (ids[i]!=id) continue;
			id++;
			found = FALSE;
			break;
		}
	}
	ids.Append(1,&id);
	return id;
}

void UnwrapMod::RemoveSet(TSTR &setName) {
	int i = FindSet(setName);
	if (i<0) return;
	delete namedSel[i];
	namedSel.Delete(i,1);
	ids.Delete(i,1);
}

void UnwrapMod::ClearSetNames() {
	for (int i=0; i<3; i++) {
		for (int j=0; j<namedSel.Count(); j++) {
			delete namedSel[j];
			namedSel[j] = NULL;
		}
	}
}

void UnwrapMod::ActivateSubSelSet(TSTR &setName) {
	ModContextList mcList;
	INodeTab nodes;
	int index = FindSet (setName);	
	if (index<0 || !ip) return;

	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) 
		{
		MeshTopoData *meshData = (MeshTopoData*)mcList[i]->localData;
		if (!meshData) continue;
//		if (theHold.Holding() && !meshData->held) theHold.Put(new UnwrapRestore(this,meshData));

		BitArray *set = NULL;

		set = meshData->fselSet.GetSet(ids[index]);
		if (set) 
			{
			if (set->GetSize()!=meshData->faceSel.GetSize()) 
				{
				set->SetSize(meshData->faceSel.GetSize(),TRUE);
				}
			meshData->SetFaceSel (*set, this, ip->GetTime());
			UpdateFaceSelection(*set);
			InvalidateView();
			UpdateWindow(hWnd);
			}
		}
	
	nodes.DisposeTemporary();
	LocalDataChanged ();
	ip->RedrawViews(ip->GetTime());
}

void UnwrapMod::NewSetFromCurSel(TSTR &setName) {
	ModContextList mcList;
	INodeTab nodes;
	DWORD id = -1;
	int index = FindSet(setName);
	if (index<0) id = AddSet(setName);
	else id = ids[index];

	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		MeshTopoData *meshData = (MeshTopoData*)mcList[i]->localData;
		if (!meshData) continue;
		
		BitArray *set = NULL;

			if (index>=0 && (set = meshData->fselSet.GetSet(id))) {
				*set = meshData->faceSel;
			} else meshData->fselSet.AppendSet(meshData->faceSel,id);
		}
		
	nodes.DisposeTemporary();
}

void UnwrapMod::RemoveSubSelSet(TSTR &setName) {
	int index = FindSet (setName);
	if (index<0 || !ip) return;		

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	DWORD id = ids[index];

	for (int i = 0; i < mcList.Count(); i++) {
		MeshTopoData *meshData = (MeshTopoData*)mcList[i]->localData;
		if (!meshData) continue;		

//				if (theHold.Holding()) theHold.Put(new DeleteSetRestore(&meshData->fselSet,id));
				meshData->fselSet.RemoveSet(id);
		}
	
//	if (theHold.Holding()) theHold.Put(new DeleteSetNameRestore(&(namedSel[nsl]),this,&(ids[nsl]),id));
	RemoveSet (setName);
	ip->ClearCurNamedSelSet();
	nodes.DisposeTemporary();
}

void UnwrapMod::SetupNamedSelDropDown() {


	ip->ClearSubObjectNamedSelSets();
	for (int i=0; i<namedSel.Count(); i++)
		ip->AppendSubObjectNamedSelSet(*namedSel[i]);
//	if (namedSel.Count() >= 0)
//		ip->SetCurNamedSelSet(*namedSel[namedSel.Count()]);
}

int UnwrapMod::NumNamedSelSets() {
	return namedSel.Count();
}

TSTR UnwrapMod::GetNamedSelSetName(int i) {
	return *namedSel[i];
}


void UnwrapMod::SetNamedSelSetName(int i,TSTR &newName) {
//	if (theHold.Holding()) theHold.Put(new SetNameRestore(&namedSel,this,&ids,ids[i]));
	*namedSel[i] = newName;
}

void UnwrapMod::NewSetByOperator(TSTR &newName,Tab<int> &sets,int op) {
	ModContextList mcList;
	INodeTab nodes;
	
	DWORD id = AddSet(newName);
//	if (theHold.Holding()) theHold.Put(new AppendSetNameRestore(this,&namedSel,&ids));

	BOOL delSet = TRUE;
	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		MeshTopoData *meshData = (MeshTopoData*)mcList[i]->localData;
		if (!meshData) continue;
	
		BitArray bits;
		GenericNamedSelSetList *setList;

		setList = &meshData->fselSet; break;			
				

		bits = (*setList)[sets[0]];

		for (int i=1; i<sets.Count(); i++) {
			switch (op) {
			case NEWSET_MERGE:
				bits |= (*setList)[sets[i]];
				break;

			case NEWSET_INTERSECTION:
				bits &= (*setList)[sets[i]];
				break;

			case NEWSET_SUBTRACT:
				bits &= ~((*setList)[sets[i]]);
				break;
			}
		}
		if (bits.NumberSet()) delSet = FALSE;

		setList->AppendSet(bits,id);
//		if (theHold.Holding()) theHold.Put(new AppendSetRestore(setList));
	}
	if (delSet) RemoveSubSelSet(newName);
}

void UnwrapMod::LocalDataChanged() {
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	if (ip && editMod==this) {
	//	SetNumSelLabel();
		ip->ClearCurNamedSelSet();
	}
}

void UnwrapMod::SetNumSelLabel() {	
	TSTR buf;
	int num = 0, which;

	if (!hParams) return;

	ModContextList mcList;
	INodeTab nodes;

	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		MeshTopoData *meshData = (MeshTopoData*)mcList[i]->localData;
		if (!meshData) continue;

		num += meshData->faceSel.NumberSet();
		if (meshData->faceSel.NumberSet() == 1) {
			for (which=0; which<meshData->faceSel.GetSize(); which++) if (meshData->faceSel[which]) break;
			}
	}

/*
	if (num==1) buf.printf (GetString(IDS_EM_WHICHFACESEL), which+1);
	else buf.printf(GetString(IDS_RB_NUMFACESELP),num);
	SetDlgItemText(hParams,IDC_MS_NUMBER_SEL,buf);
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\BonesDef\bonesdef.h ===
#ifndef __BONESDEF__H
#define __BONESDEF__H

#include "mods.h"
#include "iparamm.h"
#include "shape.h"
#include "spline3d.h"
#include "splshape.h"
#include "linshape.h"

// This uses the linked-list class templates
#include "linklist.h"

extern void SpinnerOn(HWND hWnd,int SpinNum,int Winnum);
extern void SpinnerOff(HWND hWnd,int SpinNum,int Winnum);

#define PBLOCK_PARAM_REF		0
#define POINT1_REF				1
#define BONES_REF				2

#define BASE_TM_CHUNK           0x10
#define BONE_COUNT_CHUNK        0x20
#define BONE_DATATM_CHUNK       0x25
#define BONE_DATA_CHUNK         0x30
#define VERTEX_COUNT_CHUNK      0x40
#define VERTEX_DATA_CHUNK       0x50
#define BONE_NAME_CHUNK			0x160
#define BONE_BIND_CHUNK			0x200
#define BONE_SPLINE_CHUNK		0x210


#define DELTA_COUNT_CHUNK      0x400
#define DELTA_DATA_CHUNK       0x410

#define SELMOD 26

//--- Parameter map/block descriptors -------------------------------

#define PB_EFFECT               0
#define PB_LOCK_BONE			1
#define PB_ABSOLUTE_INFLUENCE   2
#define PB_FILTER_VERTICES      3
#define PB_FILTER_BONES         4
#define PB_FILTER_ENVELOPES     5
#define PB_DRAW_ENVELOPES       6
#define PB_DRAW_VERTICES        7
#define PB_REF_FRAME            8

#define PB_RADIUS               9

#define PB_PROJECT_THROUGH      10
#define PB_FALLOFF              11

#define PB_BONE_FALLOFF         12
#define PB_FEATHER              13
#define PB_DRAW_BONE_ENVELOPE   14

#define PB_ERADIUS				15
#define PB_ALWAYS_DEFORM		16
#define PB_PAINTSTR				17



#define BONE_LOCK_FLAG          1       
#define BONE_ABSOLUTE_FLAG      2
#define BONE_SPLINE_FLAG        4
#define BONE_SPLINECLOSED_FLAG  8
#define BONE_DRAW_ENVELOPE_FLAG 16
#define BONE_BONE_FLAG			32
#define BONE_DEAD_FLAG			64


#define BONE_FALLOFF_X3_FLAG    0
#define BONE_FALLOFF_X2_FLAG    1
#define BONE_FALLOFF_X_FLAG     2
#define BONE_FALLOFF_SINE_FLAG  3
#define BONE_FALLOFF_2X_FLAG    4
#define BONE_FALLOFF_3X_FLAG    5

//
#define CID_CREATECROSS CID_USER + 203
#define CID_CREATEPAINT CID_USER + 204

#define ID_LOCK				0x0100
#define ID_ABSOLUTE			0x0110
#define ID_DRAW_ENVELOPE	0x0120
#define ID_FALLOFF			0x0130
#define ID_COPY				0x0140
#define ID_PASTE			0x0150




// block IDs
//enum { bones_params,bones_paint, bones_filter, bones_advance };
//enum { bones_params};//,bones_paint,bones_filter,bones_advance};
// param param IDs
//enum { bones_effect, bones_radius, bones_lock, bones_absolute, bones_drawenvelopes, bones_falloff };
//enum { bones_paint_radius, bones_paint_feather};//, bones_paint_str };
//enum { bones_filter_vertices, bones_filter_bones, bones_filter_envelope, bones_filter_draw_all,bones_filter_color_verts };
//enum { bones_adv_always_deform, bones_adv_refframe, bones_adv_auto, bones_adv_inner, bones_adv_outer};



static Point2
ProjectPointF(GraphicsWindow *gw, Point3 fp) {
        IPoint3 out;
        gw->wTransPoint(&fp,&out);
        Point2 work;
        work.x = (float)out.x;
        work.y = (float)out.y;
        return work;
        }


class WeightRestore;

class BoneHitDataClass:public HitData
{
public:
        BoneHitDataClass(int v, int b, int e, int c, int ch)
                {
                VertexId = v;
                BoneId = b;
                EndPoint = e;
                CrossId = c;
                CrossHandleId = ch;
                }
        ~BoneHitDataClass() {}
int VertexId;
int BoneId;
int EndPoint;
int CrossId;
int CrossHandleId;
};


class VertexInfluenceListClass
{
public:
        int Bones;          
        float Influences;  
		float normalizedInfluences;
//extra data to hold spline stuff
        int SubCurveIds;
        int SubSegIds;
        float u;
        Point3 Tangents;
        Point3 OPoints;
};

class VertexListClass
        {
public:
        BOOL selected;
        BOOL modified;
        Point3 LocalPos;
//table of misc data    
        Tab<VertexInfluenceListClass> d;
        };

class CrossSectionClass
        {
public:
//        float Inner,Outer;
        float u;

		Control *InnerControl,*OuterControl;
		int RefInnerID,RefOuterID;
		BOOL innerSelected, outerSelected;
        };

class BoneDataClass
        {
public:
        INode *Node;
		Control *EndPoint1Control,*EndPoint2Control;

        Matrix3 tm;
        Matrix3 temptm;
        Tab<CrossSectionClass> CrossSectionList;
        BYTE flags;
        BYTE FalloffType;

		int BoneRefID;
		int RefEndPt1ID,RefEndPt2ID;
		BOOL end1Selected, end2Selected;
		TSTR name;
		Spline3D referenceSpline;
};

class CopyCrossClass
{
public:
	float inner, outer;
	float u;
};
class CopyClass
{
public:
	Point3 E1, E2;
	BOOL absolute,showEnvelope;
	int falloffType;
	Tab<CopyCrossClass> CList;
};

class VertexDistanceClass
{
public:
	float dist;
	float u;
    int SubCurveIds;
    int SubSegIds;
    Point3 Tangents;
    Point3 OPoints;

};

MakeLinkedList(BoneDataClass);

class CreateCrossSectionMode;
class CreatePaintMode;

class DumpHitDialog;

class BoneModData : public LocalModData {
	public:

//vertex info
        int VertexDataCount;
        float effect;

		Point3 hitPoint;
		BOOL isHit;

		Tab<VertexListClass*> VertexData;
		Matrix3 BaseTM,InverseBaseTM;

		ObjectState *hitState;
//		Mesh mesh;
//		PatchMesh patch;
		BOOL isMesh;
		BOOL isPatch;
		BOOL isSurf;
//selectio info
        BitArray selected;

		Tab<VertexDistanceClass> DistCache;
		int CurrentCachePiece;

		Tab<Matrix3> tmCacheToBoneSpace;
		Tab<Matrix3> tmCacheToObjectSpace;

		Tab<Point3> tempTableL1;
		Tab<Point3> tempTableL2;
		Tab<Point3> tempTableL1ObjectSpace;
		Tab<Point3> tempTableL2ObjectSpace;

		BOOL forceUpdate;
		Point3 localCenter;

		WeightRestore *wundo;
//6-18-99
		BOOL inputObjectIsNURBS;

//watje 9-7-99  198721 
        BOOL reevaluate;


		BoneModData()
			{
			VertexDataCount = 0;
			isMesh = FALSE;
			forceUpdate = FALSE;
			effect = -1.0f;
//watje 9-7-99  198721 
            reevaluate = FALSE;

			//mesh = NULL;
//			sel.ZeroCount();
			}
		~BoneModData()
			{
			for (int i=0;i<VertexDataCount;i++)
				{
				VertexData[i]->d.ZeroCount();
				if (VertexData[i] != NULL)
					delete (VertexData[i]);
				VertexData[i] = NULL;

				}


			VertexData.ZeroCount();
			VertexDataCount =0;


			}	
		LocalModData*	Clone()
			{
//			BoneModData* d = new BoneModData();
//			d->VertexDataCount = -1;


			return NULL;

			}	
};


class BonesDefMod : public Modifier {   
        public:


                IParamBlock *pblock_param;
                static HWND hParam;

                Control *p1Temp;


				int GetOpenID()
					{
					for (int i = 0; i < RefTable.Count();i++)
						{
						if (RefTable[i] == 0)
							{
							RefTable[i] = 1;
							return i+2;
							}
						}
					int u = 1;
					RefTable.Append(1,&u,1);
					return RefTable.Count()-1+2;
					}

				Tab<int> RefTable;



//                Matrix3 obtm;
//              Matrix3 iobtm;

//bones info
	            BoneDataClassList BoneData;

				BOOL inPaint;
				BOOL painting;
				BOOL reloadSplines;

				BOOL splineChanged;
				int whichSplineChanged;


//vertex info
//              int VertexDataCount;
//				Tab<VertexListClass*> VertexData;
//				BoneModData *bmd;


	            int OldVertexDataCount;
				Tab<VertexListClass*> OldVertexData;
				Matrix3 OldBaseTM,OldInverseBaseTM;

				BOOL forceRecomuteBaseNode;
				BOOL cacheValid;
				BOOL unlockVerts;
				BOOL unlockBone;
				void UnlockBone(BoneModData *bmd,TimeValue t, ObjectState *os);


				void RegisterClasses();
				static ICustToolbar *iParams;


                void ClearVertexSelections(BoneModData *bmd);
                void ClearBoneEndPointSelections();
                void ClearEnvelopeSelections();

				void DumpVertexList();
				void LockThisBone(int bid);
                void SelectFlexibleVerts(BoneModData *bmd);
                void BuildFalloff(BoneModData *bmd);

				int ConvertSelectedListToBoneID(int fsel);
				int ConvertSelectedBoneToListID(int fsel);

                
//selection space is   NOT RIGHT REDOC
//              vertices
//                      { bones
//                      Bone End
//                      Bone Start
//                      8 * Number of Ccross Sections
//                      }
//                      }

//edit modes to determine what is currently being edited since we only use one sub object
                int ModeEdit;
                int ModeBoneIndex;
                int ModeBoneEndPoint;
                int ModeBoneEnvelopeIndex;
                int ModeBoneEnvelopeSubType;
				int inPaintMode;

                Point3 Worldl1, Worldl2;

				void EnableButtons();
				void DisableButtons();

				CopyClass CopyBuffer;
				void CopyBone();
				void PasteBone();

                void AddCrossSection(int boneid, float u, float inner, float outer);
                void AddCrossSection(float u);

                float GetU(ViewExp *vpt,Point3 a, Point3 b, IPoint2 p);
				void GetCrossSectionRanges(float &inner, float &outer, int BoneID, int CrossID);
				void GetEndPoints(BoneModData *bmd, TimeValue t,Point3 &l1, Point3 &l2, int BoneID);
				void GetEndPointsLocal(BoneModData *bmd, TimeValue t,Point3 &l1, Point3 &l2, int BoneID);

				float ModifyU(TimeValue t, float LineU,  int BoneID, int sid);
				float ComputeInfluence(TimeValue t, float Influence, float u, int BoneID, int StartCross, int EndCross, int sid);

				void BuildCache(BoneModData *bmd, int BoneIndex, TimeValue t, ObjectState *os);
				void BuildCacheThread(BoneModData *bmd, int start, int end, int BoneIndex, TimeValue t, ObjectState *os, ShapeObject *pathOb, Matrix3 ntm );

				void UpdateTMCacheTable(BoneModData *bmd, TimeValue t, Interval& valid);


//distance stuff
                void RecurseDepth(float u1, float u2, float &fu,  ShapeObject *s,int Curve,int Piece, int &depth, Point3 fp);
                void PointToPiece(float &tempu, ShapeObject *s,int Curve,int Piece, int depth, Point3 fp);
                float SplineToPoint(Point3 p1, ShapeObject *s, float &u, Point3 &p, Point3 &t, int &cid, int &sid, Matrix3 tm);

                void RecurseDepth(float u1, float u2, float &fu,  Spline3D *s,int Curve,int Piece, int &depth, Point3 fp);
                void PointToPiece(float &tempu, Spline3D *s,int Curve,int Piece, int depth, Point3 fp);
                float SplineToPoint(Point3 p1, Spline3D *s, float &u, Point3 &p, Point3 &t, int &cid, int &sid, Matrix3 tm);

                
				float LineToPoint(Point3 p1, Point3 l1, Point3 l2, float &u);
//this one does no end caping test
                float LineToPoint(Point3 p1, Ray r, float &u);

                void ClosestPoint(float inc, float start, float end, 
                                                           Tab<float> *cl, Tab<int> *ci, ShapeObject *s, Point3 p1);
                void ClosestPoint(float inc, float start, float end, 
                                                           Tab<float> *cl, int ci, ShapeObject *s, Point3 p1);


//				void BuildEnvelopes(INode *bnode, INode *mnode, Point3 l1, Point3 l2, float &el1, float &el2);
				void BuildEnvelopes(INode *bnode, Object *obj, Point3 l1, Point3 l2, float &el1, float &el2);
                void BuildMajorAxis(INode *node, Point3 &t, Point3 &e);

                void RemoveBone();
                void RemoveBone(int bid);
                void RemoveCrossSection();
				void RemoveCrossSection(int bid, int eid);
				void RemoveCrossSectionNoNotify(int bid, int eid);

                void SetSelectedVertices(BoneModData *bmd, int BoneID, float amount);
                void IncrementVertices(BoneModData *bmd, int BoneID, Tab<float> amount, int flip);
                void SetVertex(BoneModData *bmd, int vertID, int BoneID, float amount);
				void SetVertices(BoneModData *bmd,int vertID, Tab<int> BoneIDList, Tab<float> amountList);

                void ComputeFalloff(float &u, int ftype);


				float RetrieveNormalizedWeight(BoneModData *bmd, int vid, int bid);
                void RecomputeAllBones(BoneModData *bmd, TimeValue t, ObjectState *os);
                void RecomputeBone(BoneModData *bmd, int BoneIndex,TimeValue t, ObjectState *os);

                Point3 VertexAnimation(TimeValue t, BoneModData * bmd, int vertex, int bone, Point3 p);

//dialog variables
                int LockBone;
                int AbsoluteInfluence;
                int FilterVertices, FilterBones,FilterEnvelopes,DrawEnvelopes;
                int DrawVertices;
                int RefFrame;
                int BoneFalloff;
				int AlwaysDeform;
//Paint controlls
                float Radius;
                float Feather;
				float paintStr;
                int ProjectThrough, Falloff;


                BOOL reset;
                BOOL BoneMoved;
                int absolute;

//                Matrix3 BaseTM,InverseBaseTM;



                static IObjParam *ip;
                static IParamMap *pmapParam;
                static BonesDefMod *editMod;
                static MoveModBoxCMode *moveMode;

                void StartCrossSectionMode(int type);
                static CreateCrossSectionMode *CrossSectionMode;

                void StartPaintMode();
                static CreatePaintMode *PaintMode;


                static ICustButton*   iCrossSectionButton;
                static ICustButton*   iPaintButton;
                static ICustButton*   iLock;
				static ICustButton*	  iEnvelope;
				static ICustButton*   iAbsolute;
				static ICustButton*   iFalloff;
				static ICustButton*   iCopy;
				static ICustButton*   iPaste;

                static int LastSelected;


                
                BonesDefMod();
                ~BonesDefMod();


                // From Animatable
                void DeleteThis() { 
					delete this; 
					}
                void GetClassName(TSTR& s) {s = GetString(IDS_RB_BONESDEFMOD);}  
                virtual Class_ID ClassID() { return Class_ID(9815843,87654);}           
                void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
                void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);         
                RefTargetHandle Clone(RemapDir& remap = NoRemap());
                TCHAR *GetObjectName() {return GetString(IDS_RB_BONESDEFMOD);}

                int SubNumToRefNum(int subNum);


                // From modifier
                ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO|PART_SELECT|PART_SUBSEL_TYPE;}
                ChannelMask ChannelsChanged() {return PART_GEOM;}
                Class_ID InputType() {return defObjectClassID;}
                void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
                Interval LocalValidity(TimeValue t);



                void LoadAxis(Point3 st, float dist, Matrix3 tm, Point3 *plist);
                void DrawCrossSection(Point3 a, Point3 Align, float length, Matrix3 tm, GraphicsWindow *gw);
                void DrawCrossSectionNoMarkers(Point3 a, Point3 Align, float length,GraphicsWindow *gw);
                void DrawEndCrossSection(Point3 a, Point3 align, float length,  Matrix3 tm, GraphicsWindow *gw);
                void GetCrossSection(Point3 a, Point3 Align, float length, Matrix3 tm,  Point3 *edge_p);
                void GetCrossSectionLocal(Point3 a, Point3 Align, float length, Point3 *edge_p);

                void DrawEnvelope(Tab<Point3> a, Tab<float> length, int count, Matrix3 tm, GraphicsWindow *gw);
                // From BaseObject
                int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
                int Display(TimeValue t, INode* inode, ViewExp *vpt, int flagst, ModContext *mc);

                void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);               

                void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
                CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
                void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
                void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
                void ActivateSubobjSel(int level, XFormModes& modes);
                void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE);
                void ClearSelection(int selLevel);
                void SelectAll(int selLevel);

                void InvertSelection(int selLevel);

				void UpdateEffectSpinner(BoneModData*bmd);

				BOOL updateP;
				void UpdateP(BoneModData* bmd);
				Tab<Point3> endPointDelta;
				void UpdateEndPointDelta();
					
				void SyncSelections();


				void EnableRadius(BOOL enable);
				void EnableEffect(BOOL enable);

				void UpdatePropInterface();

                int NumRefs(); 
/*				{
					int ct = 0;
					for (int i = 0; i<BoneData.Count();i++)
						{
						ct +=2 ;
						ct += BoneData[i].CrossSectionList.Count();
						}
					return 2+BoneData.Count()+ct;
//					ViewControls.Count();
					}
*/
                RefTargetHandle GetReference(int i);
                void SetReference(int i, RefTargetHandle rtarg);

                int NumSubs() {return 1;}
                Animatable* SubAnim(int i) {return GetReference(i);}
                TSTR SubAnimName(int i);

                RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
                   PartID& partID, RefMessage message);

                Matrix3 CompMatrix(TimeValue t,INode *inode,ModContext *mc);

                IOResult Load(ILoad *iload);
                IOResult Save(ISave *isave);
				
				IOResult SaveLocalData(ISave *isave, LocalModData *pld);
				IOResult LoadLocalData(ILoad *iload, LocalModData **pld);

				Matrix3 initialXRefTM;
				Matrix3 xRefTM;
				INode *bindNode;

				HoldWeights();
				AcceptWeights(BOOL accept);
				void NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc);


//watje 9-7-99  198721 
				void Reevaluate(BOOL eval);
//watje 10-13-99 212156
				BOOL DependOnTopology(ModContext &mc);
};

class LocalBoneData : public LocalModData {
public:
//vertex data count
//need individual vertex data
//sel sets
//need matrices
/*
	Mesh *mesh;
	PatchMesh *patch;
	BitArray faceSel;

	MeshTopoData(Mesh &mesh);
	MeshTopoData(PatchMesh &patch);
	MeshTopoData() { mesh=NULL; patch = NULL; }
	~MeshTopoData() { FreeCache(); }
	LocalModData *Clone();

	Mesh *GetMesh() {return mesh;}
	PatchMesh *GetPatch() {return patch;}
	void SetCache(Mesh &mesh);
	void SetCache(PatchMesh &patch);
	void FreeCache();

	BitArray &GetFaceSel() { return faceSel; }
	void SetFaceSel(BitArray &set, UnwrapMod *imod, TimeValue t);
*/

};



class CreateCrossSectionMouseProc : public MouseCallBack {
        private:
                BonesDefMod *mod;
                IObjParam *iObjParams;
                IPoint2 om;
                int type; // See above
				Point3 a,b;
				float SplineU;
        
        protected:
                HCURSOR GetTransformCursor();
                BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
                BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }           

        public:
                CreateCrossSectionMouseProc(BonesDefMod* bmod, IObjParam *i) { mod=bmod; iObjParams=i; }
                int proc( 
                        HWND hwnd, 
                        int msg, 
                        int point, 
                        int flags, 
                        IPoint2 m );
                void SetType(int type) { this->type = type; }
				void GetHit(float &ou) {ou = SplineU;}
        };





class CreateCrossSectionMode : public CommandMode {
        private:
                ChangeFGObject fgProc;
                CreateCrossSectionMouseProc eproc;
                BonesDefMod* mod;
                int type; // See above

        public:
                CreateCrossSectionMode(BonesDefMod* bmod, IObjParam *i) :
                        fgProc(bmod), eproc(bmod,i) {mod=bmod;}

                int Class() { return MODIFY_COMMAND; }
                int ID() { return CID_CREATECROSS; }
                MouseCallBack *MouseProc(int *numPoints) { *numPoints=1; return &eproc; }
                ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
                BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
                void EnterMode();
                void ExitMode();
                void SetType(int type) { this->type = type; eproc.SetType(type); }
        };



class CreatePaintMouseProc : public MouseCallBack {
        private:
                BonesDefMod *mod;
                IObjParam *iObjParams;
                IPoint2 om,lastPoint;
                Tab<float> FalloffList;

				Tab<IPoint2> mouseHitList;
				Tab<Object*> objList;
				BOOL BuildFalloffList( ViewExp *vpt, Tab<IPoint2> plist, BoneModData *bmd, Object *obj);

        
        protected:
                HCURSOR GetTransformCursor();
                BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags, BoneModData *bmd, Object *obj );
                BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }           

        public:
				BOOL first;
				float screenRadius;
				float prevScreenRadius;
                CreatePaintMouseProc(BonesDefMod* bmod, IObjParam *i) { mod=bmod; iObjParams=i; }
                int proc( 
                        HWND hwnd, 
                        int msg, 
                        int point, 
                        int flags, 
                        IPoint2 m );
        };



class CreatePaintMode : public CommandMode {
        private:
                ChangeFGObject fgProc;
                CreatePaintMouseProc eproc;
                BonesDefMod* mod;

        public:
                CreatePaintMode(BonesDefMod* bmod, IObjParam *i) :
                        fgProc(bmod), eproc(bmod,i) {mod=bmod;}

                int Class() { return MODIFY_COMMAND; }
                int ID() { return CID_CREATEPAINT; }
                MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &eproc; }
                ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
                BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
                void EnterMode();
                void ExitMode();
        };



class DumpHitDialog : public HitByNameDlgCallback {
public:
	BonesDefMod *eo;
	DumpHitDialog(BonesDefMod *e) {eo=e;};
	TCHAR *dialogTitle() {return _T(GetString(IDS_PW_SELECTBONES));};
	TCHAR *buttonText() {return _T(GetString(IDS_PW_SELECT));};
	BOOL singleSelect() {return FALSE;};
	BOOL useProc() {return TRUE;};
	int filter(INode *node);
	void proc(INodeTab &nodeTab);
	};


//---------------------------------------------------------------------
// Rightclick menu UI stuff


class BonesRightMenu : public RightClickMenu {
	private:
		BonesDefMod *ep;
	public:
		void Init(RightClickMenuManager* manager, HWND hWnd, IPoint2 m);
		void Selected(UINT id);
		void SetMod(BonesDefMod *ep) { this->ep = ep; }
	};

//BonesRightMenu rMenu;

class MapDlgProc : public ParamMapUserDlgProc {
	public:
		BonesDefMod *mod;		
		MapDlgProc(BonesDefMod *m) {mod = m;}		
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {
				delete this;
				}
//		void DoBitmapFit(HWND hWnd);
	};


class HitFaceClass
{
public:
Box2 b;
float zDepth;
BOOL inVolume;
BOOL isSelected;
};

class ZHashClass
{
public:
HitFaceClass *d;
ZHashClass *next;
};

class ZHashTableClass
{
ZHashClass *Table;
int TableSize;
float Zmin,Zmax;
/*
ClearTable()
	{
	return;
	};
AddEntry(HitFaceClass *p)
	{
	return;
	};
*/
};


class PasteRestore : public RestoreObj {
	public:
		BonesDefMod *mod;
		CopyClass ubuffer,rbuffer;
		CopyClass tbuffer;
		int whichBone;
		PasteRestore(BonesDefMod *c) 
			{
			mod = c;
			ubuffer.CList.ZeroCount();
			for (int i = 0; i < mod->BoneData[mod->ModeBoneIndex].CrossSectionList.Count();i++)
				{
				CopyCrossClass c;
				Interval v;
				c.u = mod->BoneData[mod->ModeBoneIndex].CrossSectionList[i].u;
				mod->BoneData[mod->ModeBoneIndex].CrossSectionList[i].InnerControl->GetValue(0,&c.inner,v);
				mod->BoneData[mod->ModeBoneIndex].CrossSectionList[i].OuterControl->GetValue(0,&c.outer,v);
				ubuffer.CList.Append(1,&c,1);
				}

//			ubuffer = mod->CopyBuffer;
			ubuffer.absolute = FALSE;
			if (mod->BoneData[mod->ModeBoneIndex].flags & BONE_ABSOLUTE_FLAG)
				ubuffer.absolute = TRUE;
			ubuffer.showEnvelope = FALSE;
			if (mod->BoneData[mod->ModeBoneIndex].flags & BONE_DRAW_ENVELOPE_FLAG)
				ubuffer.showEnvelope = TRUE;
			ubuffer.falloffType = mod->BoneData[mod->ModeBoneIndex].FalloffType;

			whichBone = mod->ModeBoneIndex;
			}   		
		void Restore(int isUndo) 
			{
			if (isUndo) 
				{
				rbuffer.CList.ZeroCount();
				for (int i = 0; i < mod->BoneData[mod->ModeBoneIndex].CrossSectionList.Count();i++)
					{
					CopyCrossClass c;
					Interval v;
					c.u = mod->BoneData[mod->ModeBoneIndex].CrossSectionList[i].u;
					mod->BoneData[mod->ModeBoneIndex].CrossSectionList[i].InnerControl->GetValue(0,&c.inner,v);
					mod->BoneData[mod->ModeBoneIndex].CrossSectionList[i].OuterControl->GetValue(0,&c.outer,v);
					rbuffer.CList.Append(1,&c,1);
					rbuffer.absolute = FALSE;
					if (mod->BoneData[mod->ModeBoneIndex].flags & BONE_ABSOLUTE_FLAG)
						rbuffer.absolute = TRUE;
					rbuffer.showEnvelope = FALSE;
					if (mod->BoneData[mod->ModeBoneIndex].flags & BONE_DRAW_ENVELOPE_FLAG)
						rbuffer.showEnvelope = TRUE;
					rbuffer.falloffType = mod->BoneData[mod->ModeBoneIndex].FalloffType;

					}

//				rbuffer = mod->CopyBuffer;
				}
			tbuffer = mod->CopyBuffer;
			mod->CopyBuffer = ubuffer;
			mod->ModeBoneIndex = whichBone;

			mod->PasteBone();
//watje 9-7-99  198721 
			mod->Reevaluate(TRUE);

			mod->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			mod->CopyBuffer = tbuffer;

			}
		void Redo()
			{
			tbuffer = mod->CopyBuffer;
			mod->CopyBuffer = rbuffer;
			mod->ModeBoneIndex = whichBone;
			mod->PasteBone();
//watje 9-7-99  198721 
			mod->Reevaluate(TRUE);

			mod->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			mod->CopyBuffer = tbuffer;

			}		
		void EndHold() 
			{ 
			mod->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T(GetString(IDS_PW_PASTE))); }
	};

class SelectionRestore : public RestoreObj {
	public:
		BonesDefMod *mod;
		BoneModData *bmd;
		int rModeBoneIndex;
		int rModeBoneEnvelopeIndex;
		int rModeBoneEndPoint;
		int rModeBoneEnvelopeSubType;
		BitArray rVertSel;

		int uModeBoneIndex;
		int uModeBoneEnvelopeIndex;
		int uModeBoneEndPoint;
		int uModeBoneEnvelopeSubType;
		BitArray uVertSel;

		SelectionRestore(BonesDefMod *c, BoneModData *md) 
			{
			mod = c;
			bmd = md;
			uModeBoneIndex = mod->ModeBoneIndex;
			uModeBoneEnvelopeIndex  = mod->ModeBoneEnvelopeIndex;
			uModeBoneEndPoint  = mod->ModeBoneEndPoint;
			uModeBoneEnvelopeIndex = mod->ModeBoneEnvelopeIndex;
			uModeBoneEnvelopeSubType = mod->ModeBoneEnvelopeSubType;
			uVertSel.SetSize(bmd->selected.GetSize());
			uVertSel = bmd->selected;
//			uVertSel;
			}   		
		void Restore(int isUndo) 
			{
			if (isUndo) 
				{
				rModeBoneIndex = mod->ModeBoneIndex;
				rModeBoneEnvelopeIndex  = mod->ModeBoneEnvelopeIndex;
				rModeBoneEndPoint  = mod->ModeBoneEndPoint;
				rModeBoneEnvelopeIndex = mod->ModeBoneEnvelopeIndex;
				rModeBoneEnvelopeSubType = mod->ModeBoneEnvelopeSubType;
				rVertSel.SetSize(bmd->selected.GetSize());
				rVertSel = bmd->selected;
				}
			mod->ModeBoneIndex = uModeBoneIndex;
			mod->ModeBoneEnvelopeIndex = uModeBoneEnvelopeIndex ;
			mod->ModeBoneEndPoint = uModeBoneEndPoint  ;
			mod->ModeBoneEnvelopeIndex = uModeBoneEnvelopeIndex ;
			mod->ModeBoneEnvelopeSubType = uModeBoneEnvelopeSubType ;
			bmd->selected = uVertSel;
			if (bmd->selected.NumberSet() >0)
				mod->EnableEffect(TRUE);
			else mod->EnableEffect(FALSE);

			mod->SyncSelections();
			mod->UpdatePropInterface();

			mod->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo()
			{
			mod->ModeBoneIndex = rModeBoneIndex;
			mod->ModeBoneEnvelopeIndex = rModeBoneEnvelopeIndex ;
			mod->ModeBoneEndPoint = rModeBoneEndPoint  ;
			mod->ModeBoneEnvelopeIndex = rModeBoneEnvelopeIndex ;
			mod->ModeBoneEnvelopeSubType = rModeBoneEnvelopeSubType ;
			bmd->selected = rVertSel;
			if (bmd->selected.NumberSet() >0)
				mod->EnableEffect(TRUE);
			else mod->EnableEffect(FALSE);

			mod->SyncSelections();
			mod->UpdatePropInterface();


			mod->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}		
		void EndHold() 
			{ 
			mod->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T(GetString(IDS_PW_SELECT))); }
	};

class DeleteBoneRestore : public RestoreObj {
	public:
		BonesDefMod *mod;
		BoneDataClass undo,redo;
		int undoID, redoID;
		Tab<int> undoRefTable,redoRefTable;


		DeleteBoneRestore(BonesDefMod *c, int whichBone) 
			{
			mod = c;
 			undo = mod->BoneData[whichBone];
			undoID = whichBone;
			undoRefTable = mod->RefTable;
			}   		
		void Restore(int isUndo) 
			{
			if (isUndo) 
				{
				redo = mod->BoneData[undoID];
				redoRefTable = mod->RefTable;

				}

			mod->BoneData[undoID].CrossSectionList = undo.CrossSectionList;
	        mod->BoneData[undoID].flags = undo.flags;
			mod->RefTable = undoRefTable;

//watje 9-7-99  198721 
			mod->Reevaluate(TRUE);
			mod->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo()
			{
			mod->BoneData[undoID].CrossSectionList = redo.CrossSectionList;
	        mod->BoneData[undoID].flags = redo.flags;
			mod->RefTable = redoRefTable;



//watje 9-7-99  198721 
			mod->Reevaluate(TRUE);
			mod->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}		
		void EndHold() 
			{ 
			mod->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T(GetString(IDS_PW_DELETEBONE))); }
	};


class WeightRestore : public RestoreObj {
	public:
		BonesDefMod *mod;
		BoneModData *bmd;
		Tab<VertexListClass*> undoVertexData;
		Tab<VertexListClass*> redoVertexData;

		WeightRestore(BonesDefMod *bmod, BoneModData *md) 
			{
			int c = md->VertexData.Count();
			undoVertexData.SetCount(md->VertexData.Count());
			for (int i=0; i<c; i++) {
				VertexListClass *vc;
				vc = new VertexListClass;
				undoVertexData[i] = vc;
				undoVertexData[i]->modified = md->VertexData[i]->modified;
				undoVertexData[i]->selected = md->VertexData[i]->selected;
				undoVertexData[i]->d = md->VertexData[i]->d;
				}

			mod = bmod;
			bmd = md;
			}   	
		~WeightRestore()
			{
			int c = undoVertexData.Count();
			for (int i=0; i<c; i++) 
				delete undoVertexData[i];
			c = redoVertexData.Count();
			for (i=0; i<c; i++) 
				delete redoVertexData[i];

			}
		void Restore(int isUndo) 
			{
			if (isUndo) 
				{
				int c = bmd->VertexData.Count();
				redoVertexData.SetCount(bmd->VertexData.Count());
				for (int i=0; i<c; i++) {
					VertexListClass *vc;
					vc = new VertexListClass;
					redoVertexData[i] = vc;
					redoVertexData[i]->modified = bmd->VertexData[i]->modified;
					redoVertexData[i]->selected = bmd->VertexData[i]->selected;
					redoVertexData[i]->d = bmd->VertexData[i]->d;
					}

				}

			int c = bmd->VertexData.Count();
			for (int i=0; i<c; i++) {
				bmd->VertexData[i]->modified = undoVertexData[i]->modified;
				bmd->VertexData[i]->selected = undoVertexData[i]->selected;
				bmd->VertexData[i]->d = undoVertexData[i]->d;
				}

			float ef;
			mod->pblock_param->GetValue(PB_EFFECT,0,ef,FOREVER);
			bmd->effect = ef;

			mod->SyncSelections();

			mod->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo()
			{
			int c = bmd->VertexData.Count();
			for (int i=0; i<c; i++) {
				bmd->VertexData[i]->modified = redoVertexData[i]->modified;
				bmd->VertexData[i]->selected = redoVertexData[i]->selected;
				bmd->VertexData[i]->d = redoVertexData[i]->d;
				}

			float ef;
			mod->pblock_param->GetValue(PB_EFFECT,0,ef,FOREVER);
			bmd->effect = ef;
			mod->SyncSelections();


			mod->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}		
		void EndHold() 
			{ 
			mod->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T(GetString(IDS_PW_SELECT))); }
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\wind.cpp ===
/**********************************************************************
 *<
	FILE: wind.cpp

	DESCRIPTION:  Wind World Space Modifier

	CREATED BY: Rolf Berteig (as part of gravity.CPP)
	Split out, range added, by Eric Peterson

	HISTORY: 10-30-95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

#define FORCE_PLANAR	0
#define FORCE_SPHERICAL	1

class WindMtl: public Material {
	public:
	WindMtl();
	};
static WindMtl swMtl;
const Point3 WHOOPCOLOR(0.0f,0.0f,0.0f);

#define WIND_R	float(.7)
#define WIND_G	float(0)
#define WIND_B	float(0)

WindMtl::WindMtl():Material() 
{	Kd[0] = WIND_R;
	Kd[1] = WIND_G;
	Kd[2] = WIND_B;
	Ks[0] = WIND_R;
	Ks[1] = WIND_G;
	Ks[2] = WIND_B;
	shininess = (float)0.0;
	shadeLimit = GW_WIREFRAME|GW_BACKCULL;
	selfIllum = (float)1.0;
}

class WindObject : public SimpleWSMObject {	
	public:		
		WindObject();		
		TCHAR *GetObjectName() {return GetString(IDS_RB_WIND);}
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
					
		BOOL SupportsDynamics() {return TRUE;}

		// From Animatable		
		void DeleteThis() {delete this;}		
		Class_ID ClassID() {return Class_ID(WINDOBJECT_CLASS_ID,0);}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack();	
		
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);
		ForceField *GetForceField(INode *node);
		
		// From SimpleWSMObject		
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void InvalidateUI();		
		void BuildMesh(TimeValue t);

		int DialogID() {return IDD_WINDPARAM;}
		ParamUIDesc *UIDesc();
		int UIDescLength();

		// from ref
		IOResult Load(ILoad *iload);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		void GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
	};

IObjParam *WindObject::ip        = NULL;
IParamMap *WindObject::pmapParam = NULL;
HWND       WindObject::hSot      = NULL;


//--- ClassDescriptor and class vars ---------------------------------

class WindClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new WindObject;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_WIND_CLASS);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return Class_ID(WINDOBJECT_CLASS_ID,0);}
	const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_BOTH);}
	};

static WindClassDesc windDesc;
ClassDesc* GetWindObjDesc() {return &windDesc;}

//--- WindMod -----------------------------------------------------

class WindMod;

class WindField : public ForceField {
	public:
		WindObject *obj;
		INode *node;
		Matrix3 tm;
		Interval tmValid;
		Point3 force;
		Interval fValid;
		int type;
		Point3 Force(TimeValue t,const Point3 &pos, const Point3 &vel,int index);
		void DeleteThis() {delete this;} // RB 5/12/99
	};

class WindMod : public SimpleWSMMod {
	public:				
		WindField force;

		WindMod() {}
		WindMod(INode *node,WindObject *obj);		

		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_RB_WINDMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return Class_ID(WINDMOD_CLASS_ID,0);}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_WINDBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};

//--- ClassDescriptor and class vars ---------------------------------

class WindModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) {return new WindMod;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_WINDMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(WINDMOD_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};

static WindModClassDesc windModDesc;
ClassDesc* GetWindModDesc() {return &windModDesc;}

#define PB_STRENGTH		0
#define PB_DECAY		1
#define PB_TYPE			2
#define PB_DISPLENGTH	3
#define PB_TURBULENCE	4
#define PB_FREQUENCY	5
#define PB_SCALE		6
#define PB_HOOPSON		7

//
//
// Parameters

static int typeIDs[] = {IDC_FORCE_PLANAR,IDC_FORCE_SPHERICAL};

static ParamUIDesc descParamWind[] = {
	// Strength
	ParamUIDesc(
		PB_STRENGTH,
		EDITTYPE_FLOAT,
		IDC_WIND_STRENGTH,IDC_WIND_STRENGTHSPIN,
		-9999999.0f, 9999999.0f,
		0.01f),

	// Decay
	ParamUIDesc(
		PB_DECAY,
		EDITTYPE_FLOAT,
		IDC_WIND_DECAY,IDC_WIND_DECAYSPIN,
		0.0f, 9999999.0f,
		0.001f),

	// Force type
	ParamUIDesc(PB_TYPE,TYPE_RADIO,typeIDs,2),

	// Turbulence
	ParamUIDesc(
		PB_TURBULENCE,
		EDITTYPE_FLOAT,
		IDC_WIND_TURB,IDC_WIND_TURBSPIN,
		0.0f, 9999999.0f,
		0.01f),

	// Frequency
	ParamUIDesc(
		PB_FREQUENCY,
		EDITTYPE_FLOAT,
		IDC_WIND_FREQ,IDC_WIND_FREQSPIN,
		0.0f, 9999999.0f,
		0.01f),

	// Scale
	ParamUIDesc(
		PB_SCALE,
		EDITTYPE_FLOAT,
		IDC_WIND_SCALE,IDC_WIND_SCALESPIN,
		0.0f, 9999999.0f,
		0.01f),

	// Display length
	ParamUIDesc(
		PB_DISPLENGTH,
		EDITTYPE_UNIVERSE,
		IDC_DISPLENGTH,IDC_DISPLENGTHSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Use  Range Hoops Checkbox
	ParamUIDesc(PB_HOOPSON,TYPE_SINGLECHEKBOX,IDC_EP_HOOPSON),

	};

#define WINDPARAMDESC_LENGTH	8

ParamBlockDescID descWindVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_FLOAT, NULL, FALSE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
};

ParamBlockDescID descWindVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_FLOAT, NULL, FALSE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 },
};

#define WINDPBLOCK_LENGTH		8

static ParamVersionDesc windversions[] = {
	ParamVersionDesc(descWindVer0,7,0),
	};

#define CURRENT_WINDVERSION		1
#define NUM_OLDVERSIONS			1

static ParamVersionDesc windcurVersion(descWindVer1,WINDPBLOCK_LENGTH,CURRENT_WINDVERSION);

//--- WindObject Methods ---------------------------------------------

void WindObject::BeginEditParams(
		IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapParam) {		
		// Left over from last SinWave ceated
		pmapParam->SetParamBlock(pblock);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_WINDGRAV_SOT),
			DefaultSOTProc,
			GetString(IDS_RB_SOT), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			UIDesc(),UIDescLength(),
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(DialogID()),
			GetString(IDS_RB_PARAMETERS),
			0);
		}
	}

void WindObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	}

class ModDrawLineProc:public PolyLineProc {
	GraphicsWindow *gw;
	public:
		ModDrawLineProc() { gw = NULL; }
		ModDrawLineProc(GraphicsWindow *g) { gw = g; }
		int proc(Point3 *p, int n) { gw->polyline(n, p, NULL, NULL, 0, NULL); return 0; }
		int Closed(Point3 *p, int n) { gw->polyline(n, p, NULL, NULL, TRUE, NULL); return 0; }
		void SetLineColor(float r, float g, float b) {gw->setColor(LINE_COLOR,r,g,b);}
		void SetLineColor(Point3 c) {gw->setColor(LINE_COLOR,c);}
		void Marker(Point3 *p,MarkerType type) {gw->marker(p,type);}
	};

static void DrawPlaneRangeHoops(float range,float len3, ModDrawLineProc& lp)
{	Point3 pt[5];
	lp.SetLineColor(GetUIColor(COLOR_END_RANGE));		
	pt[0] = Point3(len3, len3, range); 
	pt[1] = Point3(-len3, len3, range); 
	pt[2] = Point3(-len3,-len3, range); 
	pt[3] = Point3(len3,-len3, range); 
 	lp.Closed(pt,4);
	pt[0].z =-range; 
	pt[1].z =-range;
	pt[2].z =-range;
	pt[3].z =-range;
 	lp.Closed(pt,4);
}

#define NUM_SEGS	16

static void DrawFalloffSphere(float range, ModDrawLineProc& lp)
{	float u;
	Point3 pt[3],pty[3],ptz[3],first,firsty;
	
	lp.SetLineColor(GetUIColor(COLOR_END_RANGE));	
	pt[0]=(first= Point3(range,0.0f,0.0f));
	pty[0] =(firsty=Point3(0.0f,range,0.0f));
	ptz[0] = pt[0];
	for (int i=0; i<NUM_SEGS; i++)
	{	u = float(i)/float(NUM_SEGS) * TWOPI;
		float crange=(float)cos(u)*range,srange=(float)sin(u)*range;
		pt[1]=Point3(crange, srange, 0.0f);
		lp.proc(pt,2); pt[0]=pt[1];
		pty[1]=Point3(0.0f, crange, srange);
		lp.proc(pty,2); pty[0]=pty[1];
		ptz[1]=Point3(crange, 0.0f, srange);
		lp.proc(ptz,2); ptz[0]=ptz[1];
	}
	pt[1]=first;lp.proc(pt,2); 
	pty[1]=firsty;lp.proc(pty,2); 
	ptz[1]=first;lp.proc(ptz,2); 
}

int WindObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{	GraphicsWindow *gw = vpt->getGW();
	Material *mtl = &swMtl;
	Matrix3 mat = inode->GetObjectTM(t);
 	DWORD rlim = gw->getRndLimits();
	gw->setRndLimits(GW_WIREFRAME|/*GW_BACKCULL|*/ (rlim&GW_Z_BUFFER?GW_Z_BUFFER:0) );//removed BC 2/16/99 DB

	gw->setTransform(mat);
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SPACE_WARPS));
	mesh.render(gw, mtl, NULL, COMP_ALL);
	int hoopson;float decay;
	pblock->GetValue(PB_HOOPSON,t,hoopson,FOREVER);
	pblock->GetValue(PB_DECAY,t,decay,FOREVER);
	if (hoopson && (decay > 0.0f))
	{ int type;pblock->GetValue(PB_TYPE,t,type,FOREVER);
	  float range;
	  range=(decay > 0.0f?0.6931472f / decay:0.0f);
	  ModDrawLineProc lp(gw);
	  if (type==FORCE_PLANAR)
	  { float length;
	    pblock->GetValue(PB_DISPLENGTH,t,length,FOREVER);
	    DrawPlaneRangeHoops(range,3.0f*length,lp);
	  }
	  else DrawFalloffSphere(range,lp);
	}
	gw->setRndLimits(rlim);
	return(0);
}

void WindObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
	{
	Box3 meshBox;
	Matrix3 mat = inode->GetObjectTM(t);
	box.Init();
	int hoopson;
	pblock->GetValue(PB_HOOPSON,t,hoopson,FOREVER);
	if (hoopson)
	{ float decay; pblock->GetValue(PB_DECAY,t,decay,FOREVER);
	  if (decay>0.0f)
	  {	float range,xy; range=2.0f*(decay > 0.0f?0.6931472f / decay:0.0f);
		int type;pblock->GetValue(PB_TYPE,t,type,ivalid);
		if (type==FORCE_PLANAR)	{ pblock->GetValue(PB_DISPLENGTH,t,xy,FOREVER);xy*=3.0f;} else xy=range;
	    Box3 rangeBox(Point3(-xy,-xy,-range),Point3(xy,xy,range)); 
		for(int i = 0; i < 8; i++)	box += mat * rangeBox[i];
	  }
	}
	GetLocalBoundBox(t,inode,vpt,meshBox);	
	for(int i = 0; i < 8; i++)
		box += mat * meshBox[i];
	}

void WindObject::BuildMesh(TimeValue t)
{	ivalid = FOREVER;
	float length;
	int type;	
	pblock->GetValue(PB_DISPLENGTH,t,length,ivalid);
	pblock->GetValue(PB_TYPE,t,type,ivalid);
	int norvs,norfs,extraverts,extrafaces;
	float decay,range;
	pblock->GetValue(PB_DECAY,t,decay,ivalid);
	range=decay;
	int hoopson;
	pblock->GetValue(PB_HOOPSON,t,hoopson,FOREVER);
	range=(decay > 0.0f?0.6931472f / decay:0.0f);
	if (type==FORCE_PLANAR)
	{	extrafaces = 0;
		extraverts = 0;
		mesh.setNumVerts((norvs=15) + extraverts);
		mesh.setNumFaces((norfs=5) + extrafaces);
		mesh.setVert(0, Point3(-length,-length, 0.0f));
		mesh.setVert(1, Point3( length,-length, 0.0f));
		mesh.setVert(2, Point3( length, length, 0.0f));
		mesh.setVert(3, Point3(-length, length, 0.0f));
		mesh.setVert(4, Point3(   0.0f,   0.0f, 0.0f));
		mesh.setVert(5, Point3(   0.0f,   0.0f, 3*length));
		mesh.setVert(6, Point3(   0.0f,   0.0f, 0.0f));
		length *= 0.3f;
		mesh.setVert(7, Point3(-length,-length, 7.0f*length));
		mesh.setVert(8, Point3( length,-length, 7.0f*length));
		mesh.setVert(9, Point3( length, length, 7.0f*length));
		mesh.setVert(10, Point3(-length, length, 7.0f*length));

		mesh.setVert(11, Point3(-length,-length, range));
		mesh.setVert(12, Point3( length,-length, range));
		mesh.setVert(13, Point3( length, length, range));
		mesh.setVert(14, Point3(-length, length, range));

		mesh.faces[0].setEdgeVisFlags(1,0,1);
		mesh.faces[0].setSmGroup(0);
		mesh.faces[0].setVerts(0,1,3);

		mesh.faces[1].setEdgeVisFlags(1,1,0);
		mesh.faces[1].setSmGroup(0);
		mesh.faces[1].setVerts(1,2,3);

		mesh.faces[2].setEdgeVisFlags(1,1,0);
		mesh.faces[2].setSmGroup(0);
		mesh.faces[2].setVerts(4,5,6);

		mesh.faces[3].setEdgeVisFlags(0,1,1);
		mesh.faces[3].setSmGroup(0);
		mesh.faces[3].setVerts(7,9,5);

		mesh.faces[4].setEdgeVisFlags(0,1,1);
		mesh.faces[4].setSmGroup(0);
		mesh.faces[4].setVerts(10,8,5);
	}
	else
	{	extrafaces = 0;
		extraverts = 0;
		float u;

		mesh.setNumVerts((norvs = 3*NUM_SEGS + 1) + extraverts);
		mesh.setNumFaces((norfs = 3*NUM_SEGS) + extrafaces);

		for (int i=0; i<NUM_SEGS; i++)
		{	u = float(i)/float(NUM_SEGS) * TWOPI;
			mesh.setVert(i           , Point3((float)cos(u) * length, (float)sin(u) * length, 0.0f));
			mesh.setVert(i + NUM_SEGS, Point3(0.0f, (float)cos(u) * length, (float)sin(u) * length));
			mesh.setVert(i+2*NUM_SEGS, Point3((float)cos(u) * length, 0.0f, (float)sin(u) * length));
		}
		mesh.setVert(3*NUM_SEGS, Point3(0.0f, 0.0f, 0.0f));
		
		int i1,lastvertex = 3*NUM_SEGS;
		for (i=0; i<lastvertex; i++)
		{	i1 = i + 1;
			if (i1%NUM_SEGS == 0) 
				i1 -= NUM_SEGS;
			mesh.faces[i].setEdgeVisFlags(1,0,0);
			mesh.faces[i].setSmGroup(0);
			mesh.faces[i].setVerts(i,i1,lastvertex);
		}

	}
	mesh.InvalidateGeomCache();
}

class WindObjCreateCallback : public CreateMouseCallBack {
	public:
		WindObject *ob;	
		Point3 p0, p1;
		IPoint2 sp0;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int WindObjCreateCallback::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:								
				sp0 = m;
				p0  = vpt->GetPointOnCP(m);
				mat.SetTrans(p0);
				break;
			case 1:
				if (ob->ClassID()==Class_ID(GRAVITYOBJECT_CLASS_ID,0)) {
					mat.IdentityMatrix();
					mat.RotateX(PI);
					mat.SetTrans(p0);
					}
				p1  = vpt->GetPointOnCP(m);
				ob->pblock->SetValue(PB_DISPLENGTH,0,Length(p1-p0)/2.0f);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3) return CREATE_ABORT;
					else return CREATE_STOP;
					}
				break;
			}
	} else {
		if (msg == MOUSE_ABORT)	{
			return CREATE_ABORT;
			}
		else
		if (msg == MOUSE_FREEMOVE) {
			vpt->SnapPreview(m,m);
			}
		}
	
	return TRUE;
	}
static WindObjCreateCallback forceCreateCB;

CreateMouseCallBack* WindObject::GetCreateMouseCallBack()
	{
	forceCreateCB.ob = this;
	return &forceCreateCB;
	}

void WindObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

//--- WindObject methods ---------------------------------------


WindObject::WindObject()
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descWindVer1, WINDPBLOCK_LENGTH, CURRENT_WINDVERSION));
	assert(pblock);	

	pblock->SetValue(PB_STRENGTH,0,1.0f);
	pblock->SetValue(PB_SCALE,0,1.0f);
	pblock->SetValue(PB_HOOPSON,0,0);
	}

Modifier *WindObject::CreateWSMMod(INode *node)
	{
	return new WindMod(node,this);
	}

ForceField *WindObject::GetForceField(INode *node)
	{
	WindField *wf = new WindField;	
	wf->obj  = this;
	wf->node = node;
	wf->tmValid.SetEmpty();
	wf->fValid.SetEmpty();
	wf->obj->pblock->GetValue(PB_TYPE,0,wf->type,FOREVER);
	return wf;
	}

RefTargetHandle WindObject::Clone(RemapDir& remap) 
	{
	WindObject* newob = new WindObject();
	newob->ReplaceReference(0,pblock->Clone(remap));
	return newob;
	}

ParamDimension *WindObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case 0:
		default: return defaultDim;
		}
	}

TSTR WindObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {		
		case PB_STRENGTH: 	return GetString(IDS_RB_STRENGTH2);
		case PB_DECAY:		return GetString(IDS_RB_DECAY);
		case PB_TURBULENCE:	return GetString(IDS_RB_TURBULENCE);
		case PB_FREQUENCY:	return GetString(IDS_RB_FREQUENCY);
		case PB_SCALE:		return GetString(IDS_RB_SCALE);
		default: 			return TSTR(_T(""));
		}
	}

ParamUIDesc *WindObject::UIDesc()
	{
	return descParamWind;
	}

int WindObject::UIDescLength()
	{
	return WINDPARAMDESC_LENGTH;
	}

//--- WindMod methods -----------------------------------------


WindMod::WindMod(INode *node,WindObject *obj)
	{	
	//MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
	pblock = NULL;
	obRef = NULL;
	}

Interval WindMod::GetValidity(TimeValue t) 
	{
	if (nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		((WindObject*)GetWSMObject(t))->pblock->GetValue(PB_STRENGTH,t,f,valid);		
		tm = nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {
		return FOREVER;
		}
	}

class WindDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static WindDeformer wdeformer;

Deformer& WindMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return wdeformer;
	}

RefTargetHandle WindMod::Clone(RemapDir& remap) 
	{
	WindMod *newob = new WindMod(nodeRef,(WindObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
	}

void WindMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj) {
		force.obj  = (WindObject*)GetWSMObject(t);
		force.node = nodeRef;
		force.tmValid.SetEmpty();
		force.fValid.SetEmpty();
		force.obj->pblock->GetValue(PB_TYPE,t,force.type,FOREVER);
		obj->ApplyForceField(&force);
		}
	}

static float RTurbulence(Point3 p,float freq)
	{
	return noise3(p*freq);
	}

static float forceScaleFactor = float(1200*1200)/float(TIME_TICKSPERSEC*TIME_TICKSPERSEC);

Point3 WindField::Force(
		TimeValue t,const Point3 &pos, const Point3 &vel,int index)
	{	
	float strength, decay, turb;
	obj->pblock->GetValue(PB_DECAY,t,decay,fValid);
	obj->pblock->GetValue(PB_TURBULENCE,t,turb,FOREVER);
	if (decay <0.0f) decay = 0.0f;

	if (!fValid.InInterval(t) || type==FORCE_SPHERICAL || decay!=0.0f) {
		fValid = FOREVER;		
		if (!tmValid.InInterval(t)) {
			tmValid = FOREVER;
			tm = node->GetObjectTM(t,&tmValid);
			}
		fValid &= tmValid;
		obj->pblock->GetValue(PB_STRENGTH,t,strength,fValid);
		
		if (type==FORCE_PLANAR) {
			force = Normalize(tm.GetRow(2));
			if (decay!=0.0f) {
				float dist = (float)fabs(DotProd(force,pos-tm.GetTrans()));
				strength *= (float)exp(-decay*dist);
				}			
			force *= strength * 0.0001f * forceScaleFactor;
		} else {
			float dist;
			force = pos-tm.GetTrans();
			dist  = Length(force);
			if (dist!=0.0f) force /= dist;
			if (decay!=0.0f) {				
				strength *= (float)exp(-decay*dist);
				}			
			force *= strength * 0.0001f * forceScaleFactor;
			}
		}	
	if (turb!=0.0f) {
		float freq, scale;
		Point3 tf, pt = pos-tm.GetTrans(), p;
		obj->pblock->GetValue(PB_FREQUENCY,t,freq,FOREVER);
		obj->pblock->GetValue(PB_SCALE,t,scale,FOREVER);
		freq *= 0.01f;
		turb *= 0.0001f * forceScaleFactor;

		p    = pt;
		p.x  = freq * float(t);
		tf.x = RTurbulence(p,scale);
		p    = pt;
		p.y  = freq * float(t);
		tf.y = RTurbulence(p,scale);
		p    = pt;
		p.z  = freq * float(t);
		tf.z = RTurbulence(p,scale);

		return force + (turb*tf);
	} else {
		return force;
		}
	}

class WindPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		WindPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((WindObject*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer<1) {	
 				((WindObject*)targ)->pblock->SetValue(PB_HOOPSON,0,0);
				}
			delete this;
			}
	};

IOResult WindObject::Load(ILoad *iload) 
{	iload->RegisterPostLoadCallback(
	new WindPostLoadCallback(
	new ParamBlockPLCB(windversions,NUM_OLDVERSIONS,&windcurVersion,this,0)));
	return IO_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\BonesDef\CommandModes.cpp ===
/**********************************************************************
 
	FILE: CommandModes.cpp

	DESCRIPTION:  Bones def varius command modes
				  Plus scripter access

	CREATED BY: Peter Watje

	HISTORY: 8/5/98




 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/


#include "mods.h"
#include "iparamm.h"
#include "shape.h"
#include "spline3d.h"
#include "splshape.h"
#include "linshape.h"

// This uses the linked-list class templates
#include "linklist.h"
#include "decomp.h"
#include "bonesdef.h"

#include "Maxscrpt.h"
#include "Strings.h"
#include "arrays.h"
#include "3DMath.h"
#include "Numbers.h"
#include "definsfn.h"


// Maxscript stuff
//just returns the number of bones in the system

def_struct_primitive( getNumberBones,skinOps, "GetNumberBones" );

//def_visible_primitive (getNumberBones,			"skinGetNumberBones" );

//just returns the number of vertice in the system
def_struct_primitive (getNumberVertices,skinOps,	"GetNumberVertices" );
//skinGetVertexWeightCount vertexid
//returns the number of bones influencing that vertex
def_struct_primitive (getVertexWeightCount,	skinOps, "GetVertexWeightCount" );
//skinGetBoneName boneID
//just returns the name of the bone
def_struct_primitive (getBoneName, skinOps,			"GetBoneName" );


//skinGetVertexWeight vertexid nthbone
//returns the inlfuence of the nth bone affecting that vertex
def_struct_primitive (getVertexWeight,skinOps,		"GetVertexWeight" );
//skinGetVertexWeightBoneID vertexid nthbone
//returns the bone id of the nth bone affecting that vertex
def_struct_primitive (getVertexWeightBoneID,skinOps,	"GetVertexWeightBoneID" );


//skinSelectVertices number/array/bitarray
//selects the vertices specified
def_struct_primitive (selectSkinVerts, skinOps,			"SelectVertices" );

//skinSetVertexWeights VertexID BoneID Weights
//assigns vertex to BoneID with Weight n
//it does not erase any previous weight info
//BoneID and Weights can be arrays or just numbers but if they are arrays they need to be the same length
def_struct_primitive (setVertWeights,skinOps,				"SetVertexWeights" );
//skinReplaceVertexWeights VertexID BoneID Weights
//assigns vertex to BoneID with Weight n
//it erases any previous bone weight info that vertex before assignment
//BoneID and Weights can be arrays or just numbers but if they are arrays they need to be the same length
def_struct_primitive (replaceVertWeights,skinOps,			"ReplaceVertexWeights" );

//skinIsVertexModified vertID
//just returns if the vertex has been modified
def_struct_primitive (isVertexModified, skinOps,			"IsVertexModified" );


//skinSelectBone BoneID
//selects that bone
def_struct_primitive (selectBone, skinOps,			"SelectBone" );
//GetSelectedBone 
//get the current selected bone
def_struct_primitive (getSelectedBone, skinOps,			"GetSelectedBone" );


//getNumberCrossSections boneID
//returns the number of cross sections for that bone
def_struct_primitive (getNumberCrossSections, skinOps,			"GetNumberCrossSections" );

//getinnerradius boneid crossSectionID
//returns the inner crossscetion radius
def_struct_primitive (getInnerRadius, skinOps,			"GetInnerRadius" );
//getOuterRadius boneid crossSectionID
//returns the inner crossscetion radius
def_struct_primitive (getOuterRadius, skinOps,			"GetOuterRadius" );

//setinnerradius boneid crossSectionID radius
//sets the inner radius of a cross section
def_struct_primitive (setInnerRadius, skinOps,			"SetInnerRadius" );
//setOuterRadius boneid crossSectionID radius
//sets the outer radius of a cross section
def_struct_primitive (setOuterRadius, skinOps,			"SetOuterRadius" );



//IsVertexSelected vertID
//just returns if the vertex has been selected
def_struct_primitive (isVertexSelected, skinOps,		"IsVertexSelected" );




#define get_bonedef_mod()																\
	Modifier *mod = arg_list[0]->to_modifier();										\
	Class_ID id = mod->ClassID();													\
	if ( id != Class_ID(9815843,87654) )	\
		throw RuntimeError(GetString(IDS_PW_NOT_BONESDEF_ERROR), arg_list[0]);			\
	BonesDefMod *bmod = (BonesDefMod*)mod;			

static int 
check_bone_index(BonesDefMod* bmod, int index)
{
	int ct = 0;
	for (int i = 0; i < bmod->BoneData.Count(); i++)
		if (bmod->BoneData[i].Node) ct++;
	if (index < 0 || index >= ct) 
		throw RuntimeError(_T("Bone index out of range: "), Integer::intern(index + 1));
	return bmod->ConvertSelectedListToBoneID(index);
}

Value*
getNumberBones_cf(Value** arg_list, int count)
{
	check_arg_count(getNumberBones, 1, count);
	get_bonedef_mod();
	int ct = 0;
	for (int i = 0; i < bmod->BoneData.Count(); i++)
		if (bmod->BoneData[i].Node) ct++;

//	int ct = bmod->BoneData.Count();
	return Integer::intern(ct);	
}


Value*
getNumberVertices_cf(Value** arg_list, int count)
{
	check_arg_count(getNumberVertices, 1, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	int ct = 0;
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		ct = bmd->VertexData.Count();
		}
	return Integer::intern(ct);	
}

Value*
getVertexWeightCount_cf(Value** arg_list, int count)
{
	check_arg_count(getVertexWeightCount, 2, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	int ct = 0;
	int index = arg_list[1]->to_int()-1;
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		if (index >= bmd->VertexData.Count() ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
		if (index < 0 ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);

		ct = bmd->VertexData[index]->d.Count();
		}
	return Integer::intern(ct);	
}


Value*
getBoneName_cf(Value** arg_list, int count)
{
	check_arg_count(getVertexWeightCount, 3, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	int ct = 0;
	int index = arg_list[1]->to_int()-1;
	int listName = arg_list[2]->to_int();
	index = check_bone_index(bmod, index);

	if (bmod->BoneData[index].Node != NULL)
		{
		if (listName)
			{
			Class_ID bid(BONE_CLASS_ID,0);
			ObjectState os = bmod->BoneData[index].Node->EvalWorldState(bmod->RefFrame);
			if (( os.obj->ClassID() == bid) && (bmod->BoneData[index].name.Length()) )
				{
				return new String((TCHAR*)bmod->BoneData[index].name);			
				}
			else return new String((TCHAR*)bmod->BoneData[index].Node->GetName()); 
			
			}
		else return new String((TCHAR*)bmod->BoneData[index].Node->GetName()); 
		}
	else return &undefined;

}



Value*
getVertexWeight_cf(Value** arg_list, int count)
{
	check_arg_count(getVertexWeight, 3, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	float ct = 0.0f;
	int vindex = arg_list[1]->to_int()-1;
	int subindex = arg_list[2]->to_int()-1;
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		if (vindex >= bmd->VertexData.Count() ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
		if (subindex >= bmd->VertexData[vindex]->d.Count() ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_SUBVERTEX_COUNT), arg_list[0]);
		if (vindex < 0  ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
		if (subindex < 0 ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_SUBVERTEX_COUNT), arg_list[0]);

		ct = bmod->RetrieveNormalizedWeight(bmd,vindex,subindex);
		}
	return Float::intern(ct);	
}

Value*
getVertexWeightBoneID_cf(Value** arg_list, int count)
{
	check_arg_count(getVertexWeightBoneID, 3, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	int ct = 0;
	int vindex = arg_list[1]->to_int()-1;
	int subindex = arg_list[2]->to_int()-1;
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		if (vindex >= bmd->VertexData.Count() ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
		if (subindex >= bmd->VertexData[vindex]->d.Count() ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_SUBVERTEX_COUNT), arg_list[0]);
		if (vindex < 0  ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
		if (subindex < 0 ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_SUBVERTEX_COUNT), arg_list[0]);

		ct = bmd->VertexData[vindex]->d[subindex].Bones;
//watje 10-26-99 Skin fix 185932
		ct = bmod->ConvertSelectedBoneToListID(ct)+1;
		}
	return Integer::intern(ct);	
}




Value*
selectSkinVerts_cf(Value** arg_list, int count)
{
	check_arg_count(selectSkinVerts, 2, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	int ct = 0;
	Value* ival = arg_list[1];

//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		bmd->selected.ClearAll();

		int index;
		if (is_number(ival))   // single index
			{
			index = ival->to_int()-1;
			if ((index <0) || (index >= bmd->selected.GetSize()) )
				throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
			else bmd->selected.Set(index,TRUE);
			}

		else if (is_array(ival))   // array of indexes
			{
			Array* aval = (Array*)ival;
			for (int i = 0; i < aval->size; i++)
				{
				ival = aval->data[i];
				if (is_number(ival))   // single index
					{
					index = ival->to_int()-1;
					if ((index <0) || (index >= bmd->selected.GetSize()))
						throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
					else bmd->selected.Set(index,TRUE);

					}
				}

			}
		else if (is_BitArrayValue(ival))   // array of indexes
			{
			BitArrayValue *list = (BitArrayValue *) ival;
			for (int index = 0; index < list->bits.GetSize(); index++)
				{
				if (list->bits[index])
					{
					if ((index <0) || (index >= bmd->selected.GetSize()))
						throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
					else bmd->selected.Set(index,TRUE);
					}
				}

			}



		}

	bmod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
	bmod->ip->RedrawViews(bmod->ip->GetTime());


	return &ok;	
}


Value*
setVertWeights_cf(Value** arg_list, int count)
{
	check_arg_count(setVertWeights, 4, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	int ct = 0;

	Value* vertval = arg_list[1];
	Value* bonesval = arg_list[2];
	Value* weightsval = arg_list[3];

	int vertID;
	if (!is_number(vertval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else vertID = vertval->to_int()-1;


//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		if (vertID >= bmd->VertexData.Count() ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);

//		bmd->selected.ClearAll();

//		int index;
		if (is_number(weightsval) && is_number(bonesval))  // single index
			{
			int boneID = bonesval->to_int()-1;
			boneID = check_bone_index(bmod, boneID);

			float weight = weightsval->to_float();
			if (weight < 0.0f ) weight = 0.0f;
			if (weight > 1.0f ) weight = 1.0f;
			if (bmod->BoneData[boneID].Node != NULL)
				{
//				bmd->VertexData[vertID]->d.ZeroCount();
				bmod->SetVertex(bmd,vertID, boneID, weight);
				}
			}

		else if (is_array(weightsval) && is_array(bonesval))   // array of indexes
			{

			Array* wval = (Array*)weightsval;
			Array* bval = (Array*)bonesval;
			if (wval->size != bval->size) throw RuntimeError(GetString(IDS_PW_WEIGHT_BONE_COUNT), arg_list[0]);

//			bmd->VertexData[vertID]->d.ZeroCount();
			Tab<int> b;
			Tab<float> v;
			for (int i = 0; i < wval->size; i++)
				{
				Value *boneval = bval->data[i];
				Value *weightval = wval->data[i];
				if ( (is_number(boneval)) && (is_number(weightval)))  // single index
					{
					int boneID = boneval->to_int()-1;
//watje 10-26-99 Skin fix 185932
//					boneID = bmod->ConvertSelectedListToBoneID(boneID);
					boneID = check_bone_index(bmod, boneID);

					float weight = weightval->to_float();
					if (weight < 0.0f ) weight = 0.0f;
					if (weight > 1.0f ) weight = 1.0f;
					if (bmod->BoneData[boneID].Node != NULL)
						{
						b.Append(1,&boneID,1);
						v.Append(1,&weight,1);
						}

					}
				}
			bmod->SetVertices(bmd,vertID, b, v);


			}



		}
//watje 9-7-99  198721 
	bmod->Reevaluate(TRUE);
	bmod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
	bmod->ip->RedrawViews(bmod->ip->GetTime());


	return &ok;	
}


Value*
replaceVertWeights_cf(Value** arg_list, int count)
{
	check_arg_count(replaceVertWeights, 4, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	int ct = 0;

	Value* vertval = arg_list[1];
	Value* bonesval = arg_list[2];
	Value* weightsval = arg_list[3];

	int vertID;
	if (!is_number(vertval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else vertID = vertval->to_int()-1;


//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		if (vertID >= bmd->VertexData.Count() ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);

//		bmd->selected.ClearAll();

//		int index;
		if (is_number(weightsval) && is_number(bonesval))  // single index
			{
			int boneID = bonesval->to_int()-1;
			boneID = check_bone_index(bmod, boneID);
			float weight = weightsval->to_float();
			if (weight < 0.0f ) weight = 0.0f;
			if (weight > 1.0f ) weight = 1.0f;
			if (bmod->BoneData[boneID].Node != NULL)
				{
				bmd->VertexData[vertID]->d.ZeroCount();
				bmod->SetVertex(bmd,vertID, boneID, weight);
				}
			}

		else if (is_array(weightsval) && is_array(bonesval))   // array of indexes
			{

			Array* wval = (Array*)weightsval;
			Array* bval = (Array*)bonesval;
			if (wval->size != bval->size) throw RuntimeError(GetString(IDS_PW_WEIGHT_BONE_COUNT), arg_list[0]);
			bmd->VertexData[vertID]->d.ZeroCount();

			Tab<int> b;
			Tab<float> v;

			bmd->VertexData[vertID]->d.ZeroCount();

			for (int i = 0; i < wval->size; i++)
				{
				Value *boneval = bval->data[i];
				Value *weightval = wval->data[i];
				if ( (is_number(boneval)) && (is_number(weightval)))  // single index
					{
					int boneID = boneval->to_int()-1;
					boneID = check_bone_index(bmod, boneID);
					float weight = weightval->to_float();
					if (weight < 0.0f ) weight = 0.0f;
					if (weight > 1.0f ) weight = 1.0f;
					if (bmod->BoneData[boneID].Node != NULL)
						{
						b.Append(1,&boneID,1);
						v.Append(1,&weight,1);
//						bmod->SetVertex(bmd,vertID, boneID, weight);
						}

					}
				}
			bmod->SetVertices(bmd,vertID, b, v);


			}



		}
//watje 9-7-99  198721 
	bmod->Reevaluate(TRUE);
	bmod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
	bmod->ip->RedrawViews(bmod->ip->GetTime());


	return &ok;	
}


Value*
isVertexModified_cf(Value** arg_list, int count)
{
	check_arg_count(isVertexModified, 2, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();

	int ct = 0;

	Value* vertval = arg_list[1];

	int vertID;
	if (!is_number(vertval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else vertID = vertval->to_int()-1;


//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		if (vertID >= bmd->VertexData.Count() ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
		if (vertID < 0 ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
		ct = bmd->VertexData[vertID]->modified;
		}
	return Integer::intern(ct);	


}


Value*
isVertexSelected_cf(Value** arg_list, int count)
{
	check_arg_count(isVertexModified, 2, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();

	int ct = 0;

	Value* vertval = arg_list[1];

	int vertID;
	if (!is_number(vertval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else vertID = vertval->to_int()-1;


//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		if (vertID >= bmd->selected.GetSize() ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
		if (vertID < 0 ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
		ct = bmd->selected[vertID];
		}
	return Integer::intern(ct);	


}


Value*
selectBone_cf(Value** arg_list, int count)
{
	check_arg_count(selectBone, 2, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();

	int ct = 0;

	Value* vertval = arg_list[1];

	int boneID;
	if (!is_number(vertval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else boneID = vertval->to_int()-1;
	boneID = check_bone_index(bmod, boneID);


//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		SendMessage(GetDlgItem(bmod->hParam,IDC_LIST1),
					LB_SETCURSEL ,boneID,0);
		bmod->ModeBoneIndex = boneID;
//		bmod->reevaluate =TRUE;
		bmod->UpdatePropInterface();

		bmod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);

//		SendMessage(GetDlgItem(bmod->hParam,IDC_LIST1),
//					WM_COMMAND ,MAKEWPARAM(IDC_LIST1,LBN_SELCHANGE),NULL);
		bmod->ip->RedrawViews(bmod->ip->GetTime());

		}

	return &ok;	

}


Value*
getSelectedBone_cf(Value** arg_list, int count)
{
	check_arg_count(getSelectedBone, 1, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();

	int ct = 0;

	ct = bmod->ModeBoneIndex+1;

	return Integer::intern(ct);		

}


Value*
getNumberCrossSections_cf(Value** arg_list, int count)
{
	check_arg_count(getNumberCrossSections, 2, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();

	int ct = 0;

	Value* vertval = arg_list[1];

	int boneID;
	if (!is_number(vertval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else boneID = vertval->to_int()-1;
	boneID = check_bone_index(bmod, boneID);


//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		if (bmod->BoneData[boneID].Node)
			ct = bmod->BoneData[boneID].CrossSectionList.Count();
		}

	return Integer::intern(ct);			

}


Value*
getInnerRadius_cf(Value** arg_list, int count)
{
	check_arg_count(getInnerRadius, 3, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();

	float w = 0;

	Value* vertval = arg_list[1];
	Value* crossval = arg_list[2];

	int boneID;
	int crossID;
	if (!is_number(vertval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else boneID = vertval->to_int()-1;
	boneID = check_bone_index(bmod, boneID);

	if (!is_number(crossval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else crossID = crossval->to_int()-1;


//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		if (bmod->BoneData[boneID].Node)
			{
			if ( (crossID < bmod->BoneData[boneID].CrossSectionList.Count()) &&
				 (crossID >= 0)
				 )
				{
				Interval v;
				bmod->BoneData[boneID].CrossSectionList[crossID].InnerControl->GetValue(0,&w,v);
				}
			else throw RuntimeError(GetString(IDS_PW_EXCEEDED_CROSS_COUNT), arg_list[0]);
			}
		}

	return Float::intern(w);			

}

Value*
getOuterRadius_cf(Value** arg_list, int count)
{
	check_arg_count(getOuterRadius, 3, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();

	float w = 0;

	Value* vertval = arg_list[1];
	Value* crossval = arg_list[2];

	int boneID;
	int crossID;
	if (!is_number(vertval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else boneID = vertval->to_int()-1;
	boneID = check_bone_index(bmod, boneID);

	if (!is_number(crossval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else crossID = crossval->to_int()-1;


//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		if (bmod->BoneData[boneID].Node)
			{
			if ( (crossID < bmod->BoneData[boneID].CrossSectionList.Count()) &&
				 (crossID >= 0)
				 )
				{
				Interval v;
				bmod->BoneData[boneID].CrossSectionList[crossID].OuterControl->GetValue(0,&w,v);
					
				}
			else throw RuntimeError(GetString(IDS_PW_EXCEEDED_CROSS_COUNT), arg_list[0]);
			}
		}

	return Float::intern(w);			

}


Value*
setInnerRadius_cf(Value** arg_list, int count)
{
	check_arg_count(setInnerRadius, 4, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();

	float w = 0;

	Value* vertval = arg_list[1];
	Value* crossval = arg_list[2];
	Value* radiusval = arg_list[3];

	int boneID;
	int crossID;
	float radius;
	if (!is_number(vertval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else boneID = vertval->to_int()-1;
	boneID = check_bone_index(bmod, boneID);

	if (!is_number(crossval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else crossID = crossval->to_int()-1;

	if (!is_number(radiusval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else radius = radiusval->to_float();


//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		if (bmod->BoneData[boneID].Node)
			{
			if ( (crossID < bmod->BoneData[boneID].CrossSectionList.Count()) &&
				 (crossID >= 0)
				 )
				{
				Interval v;
				bmod->BoneData[boneID].CrossSectionList[crossID].InnerControl->SetValue(0,&radius);
					
				}
			else throw RuntimeError(GetString(IDS_PW_EXCEEDED_CROSS_COUNT), arg_list[0]);
			}
		}

	if (bmod->ModeBoneIndex != boneID)
//watje 9-7-99  198721 
		bmod->Reevaluate(TRUE);

	bmod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
	bmod->ip->RedrawViews(bmod->ip->GetTime());


	return &ok;			

}

Value*
setOuterRadius_cf(Value** arg_list, int count)
{
	check_arg_count(setOuterRadius, 4, count);
	get_bonedef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !bmod->ip ) throw RuntimeError(GetString(IDS_PW_SKIN_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	bmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();

	float w = 0;

	Value* vertval = arg_list[1];
	Value* crossval = arg_list[2];
	Value* radiusval = arg_list[3];

	int boneID;
	int crossID;
	float radius;
	if (!is_number(vertval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else boneID = vertval->to_int()-1;
	boneID = check_bone_index(bmod, boneID);

	if (!is_number(crossval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else crossID = crossval->to_int()-1;

	if (!is_number(radiusval)) 
		{
		throw RuntimeError(GetString(IDS_PW_INVALID_DATA), arg_list[0]);
		}
	else radius = radiusval->to_float();


//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		BoneModData *bmd = (BoneModData*)mcList[0]->localData;
		if (bmod->BoneData[boneID].Node)
			{
			if ( (crossID < bmod->BoneData[boneID].CrossSectionList.Count()) &&
				 (crossID >= 0)
				 )
				{
				Interval v;
				bmod->BoneData[boneID].CrossSectionList[crossID].OuterControl->SetValue(0,&radius);
				}
			else throw RuntimeError(GetString(IDS_PW_EXCEEDED_CROSS_COUNT), arg_list[0]);
			}
		}

	if (bmod->ModeBoneIndex != boneID)
//watje 9-7-99  198721 
		bmod->Reevaluate(TRUE);

	bmod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
	bmod->ip->RedrawViews(bmod->ip->GetTime());


	return &ok;			

}



/*-------------------------------------------------------------------*/
/*																	*/
/*				Create Cross Section Command Mode					*/
/*																	*/
/*-------------------------------------------------------------------*/

HCURSOR CreateCrossSectionMouseProc::GetTransformCursor() 
        { 
        static HCURSOR hCur = NULL;

        if ( !hCur ) {
                hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_SEGREFINECUR)); 
                }

        return hCur; 
        }



BOOL CreateCrossSectionMouseProc::HitTest( 
                ViewExp *vpt, IPoint2 *p, int type, int flags )

        {

//do a poly hit test
        int savedLimits, res = 0;
        GraphicsWindow *gw = vpt->getGW();


//		float scale = 1.0f;



        HitRegion hr;
        MakeHitRegion(hr,type, 1,8,p);
        gw->setHitRegion(&hr);
        gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
        gw->setTransform(Matrix3(1));
        gw->clearHitCode();

        gw->setColor(LINE_COLOR, 1.0f,1.0f,1.0f);


		if (mod->BoneData[mod->ModeBoneIndex].flags & BONE_SPLINE_FLAG)
			{
			ShapeObject *pathOb = NULL;
			ObjectState os = mod->BoneData[mod->ModeBoneIndex].Node->EvalWorldState(mod->ip->GetTime());
			pathOb = (ShapeObject*)os.obj;
			Matrix3 tm = mod->BoneData[mod->ModeBoneIndex].Node->GetObjectTM(mod->ip->GetTime());
	        Point3 plist[2];
			SplineU = -1.0f;
			float u = 0.0f;
			for (int spid = 0; spid < 100; spid++)
				{
				plist[0] = pathOb->InterpCurve3D(mod->ip->GetTime(), 0,u) * tm;
				plist[1] = pathOb->InterpCurve3D(mod->ip->GetTime(), 0,u+0.01f) * tm;
				u += 0.01f;
		        gw->polyline(2, plist, NULL, NULL, 0);
			    if (gw->checkHitCode()) 
					{
			        res = TRUE;
				    gw->clearHitCode();
					a = plist[0];
					b = plist[1];
					SplineU = u;
					spid = 100;
					}
				gw->clearHitCode();
		
				}

			}
		else
			{
	        Point3 plist[2];
		    plist[0] = mod->Worldl1;
			plist[1] = mod->Worldl2;

	        gw->polyline(2, plist, NULL, NULL, 0);
		    if (gw->checkHitCode()) {
			        res = TRUE;
//              vpt->CtrlLogHit(NULL,gw->getHitDistance(),0,0);

				    gw->clearHitCode();
					}
			gw->clearHitCode();
			}

        gw->setRndLimits(savedLimits);

        return res;


        }

int CreateCrossSectionMouseProc::proc(
                        HWND hwnd, 
                        int msg, 
                        int point, 
                        int flags, 
                        IPoint2 m )
        {
        ViewExp *vpt = iObjParams->GetViewport(hwnd);   
        int res = TRUE;
		if ( !mod->ip ) return FALSE;


			switch ( msg ) {
                case MOUSE_PROPCLICK:
                        iObjParams->SetStdCommandMode(CID_OBJMOVE);
                        break;

                case MOUSE_POINT:
                        if(HitTest(vpt,&m,HITTYPE_POINT,0) ) {

//transfrom mouse point to world
								float u;
								if (mod->BoneData[mod->ModeBoneIndex].flags & BONE_SPLINE_FLAG)
									GetHit(u);
								else u = mod->GetU(vpt,mod->Worldl1,mod->Worldl2, m);
									
								if (u <= 0.0f) u = 0.0001f;
								if (u >= 1.0f) u = 0.9999f;
                                mod->AddCrossSection(u);
                                BOOL s = FALSE;

//watje 9-7-99  198721 
                                mod->Reevaluate(TRUE);
                                mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
                                mod->ip->RedrawViews(mod->ip->GetTime());
                                }
                        res = FALSE;
                        break;
                
                case MOUSE_FREEMOVE:
                        if ( HitTest(vpt,&m,HITTYPE_POINT,HIT_ABORTONHIT) ) {
                                SetCursor(LoadCursor(NULL,IDC_CROSS ));
                                 }
                        else {
                                SetCursor(LoadCursor(NULL,IDC_ARROW));
                                }
                        break;
                        
                }

        if ( vpt ) iObjParams->ReleaseViewport(vpt);
        return res;
        }


/*-------------------------------------------------------------------*/

void CreateCrossSectionMode::EnterMode()
        {
        mod->iCrossSectionButton->SetCheck(TRUE);
        }

void CreateCrossSectionMode::ExitMode()
        {
        mod->iCrossSectionButton->SetCheck(FALSE);
        }

void BonesDefMod::StartCrossSectionMode(int type)
        {
        if ( !ip ) return;

		if (ip->GetCommandMode() == CrossSectionMode) {
			ip->SetStdCommandMode(CID_OBJMOVE);
			return;
			}


        CrossSectionMode->SetType(type);
        ip->SetCommandMode(CrossSectionMode);
        }



/*-------------------------------------------------------------------*/
/*																	*/
/*				Paint Command Mode									*/
/*																	*/
/*-------------------------------------------------------------------*/



HCURSOR CreatePaintMouseProc::GetTransformCursor() 
        { 
        static HCURSOR hCur = NULL;

        if ( !hCur ) {
                hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_SEGREFINECUR)); 
                }

        return hCur; 
        }



BOOL CreatePaintMouseProc::HitTest( 
                ViewExp *vpt, IPoint2 *p, int type, int flags, BoneModData *bmd, Object *obj)

        {

        Ray ray;
        BOOL res = FALSE;

		

        vpt->MapScreenToWorldRay((float)p->x, (float)p->y, ray);

		if (obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) return FALSE;

		
//now map it to our local space
		if (1)
			{
			ray.p   = bmd->InverseBaseTM * ray.p;
			ray.dir = VectorTransform(bmd->InverseBaseTM, ray.dir);	

			float at;
			Point3 norm;

			if (obj->IntersectRay(mod->ip->GetTime(),ray, at, norm)) 
				{
				bmd->hitPoint = ray.p + ray.dir * at;

				return TRUE;
				}

		
			}
        return FALSE;


 }




/*-------------------------------------------------------------------*/

static void BoneXORDottedLine( HWND hwnd, IPoint2 p0, IPoint2 p1 )
	{
	HDC hdc;
	hdc = GetDC( hwnd );
	SetROP2( hdc, R2_XORPEN );
	SetBkMode( hdc, TRANSPARENT );
	SelectObject( hdc, CreatePen( PS_DOT, 0, RGB(255,255,255) ) );
	MoveToEx( hdc, p0.x, p0.y, NULL );
	LineTo( hdc, p1.x, p1.y );		
	DeleteObject( SelectObject( hdc, GetStockObject( BLACK_PEN ) ) );
	ReleaseDC( hwnd, hdc );
	}

static void BoneXORDottedCircle( HWND hwnd, IPoint2 p0, float Radius )
	{
	HDC hdc;
	hdc = GetDC( hwnd );
	SetROP2( hdc, R2_XORPEN );
	SetBkMode( hdc, TRANSPARENT );
	SelectObject( hdc, CreatePen( PS_DOT, 0, RGB(255,255,255) ) );
	MoveToEx( hdc, p0.x +(int)Radius, p0.y, NULL );
	float angle = 0.0f;
	float inc = 2.0f*PI/20.f;
	IPoint2 p1;
	for (int i = 0; i < 20; i++)
		{
		angle += inc;
		p1.x = (int)(Radius * sin(angle) + Radius * cos(angle));
		p1.y = (int)(Radius * sin(angle) - Radius * cos(angle));
		LineTo( hdc, p0.x + p1.x, p0.y+p1.y );		
		}

	DeleteObject( SelectObject( hdc, GetStockObject( BLACK_PEN ) ) );
	ReleaseDC( hwnd, hdc );
	}


/*-------------------------------------------------------------------*/


BOOL CreatePaintMouseProc::BuildFalloffList( ViewExp *vpt, Tab<IPoint2> plist, 
											 BoneModData *bmd, Object *obj)

{
Box3 boundingBox;

Tab<Point3> hitList;

boundingBox.Init();

if (obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) return FALSE;

for (int pct = 0; pct < plist.Count(); pct++)
		{
        Ray ray;

		IPoint2 p = plist[pct];
        vpt->MapScreenToWorldRay((float)p.x, (float)p.y, ray);
		ray.p   = bmd->InverseBaseTM * ray.p;
		ray.dir = VectorTransform(bmd->InverseBaseTM, ray.dir);	

//now map it to our local space
		if (1)
			{

			float at;
			Point3 norm;

			if (obj->IntersectRay(mod->ip->GetTime(),ray, at, norm)) 
				{
				Point3 hitPoint;
				hitPoint = ray.p + ray.dir * at;
				hitList.Append(1,&hitPoint,1);
				boundingBox += hitPoint;					
				}
			}

		}
boundingBox.EnlargeBy(mod->Radius);
float feather, ifeather;
feather = 1.0f -  mod->Feather;
ifeather = mod->Feather;


if (hitList.Count() ==1 )
	{	
	for (int i = 0; i< bmd->VertexDataCount; i++)
		{
//		if (boundingBox.Contains(bmd->VertexData[i]->LocalPos))
		if (boundingBox.Contains(obj->GetPoint(i)))
			{
//			float dist = Length(bmd->VertexData[i]->LocalPos-hitList[0]);
			float dist = Length(obj->GetPoint(i)-hitList[0]);
			if (dist < mod->Radius)
				{
				float f;
		        if (dist < (mod->Radius*feather))
		           f = 1.0f;
			    else 
				   {
					f = 1.0f - (dist-(mod->Radius*feather))/(mod->Radius*ifeather);
					}
				mod->ComputeFalloff(f,mod->BoneData[mod->ModeBoneIndex].FalloffType);
				f = f * mod->paintStr;
				if (f > FalloffList[i]) 
					FalloffList[i] = f;
				}
			}
		}

	}
else
	{
	for (pct = 1; pct < hitList.Count(); pct++)
		{
		for (int i = 0; i< bmd->VertexDataCount; i++)
			{
//			if (boundingBox.Contains(bmd->VertexData[i]->LocalPos))
			if (boundingBox.Contains(obj->GetPoint(i)))
				{
				Point3 l1,l2;
				l1 = hitList[pct-1];
				l2 = hitList[pct];
//				float dist = Length(bmd->VertexData[i]->LocalPos-hitPoint);
				float u;
//		float dist = mod->LineToPoint(bmd->VertexData[i]->LocalPos,l1, l2,u);
				float dist = mod->LineToPoint(obj->GetPoint(i),l1, l2,u);

				if (dist < mod->Radius)
					{
					float f;
			        if (dist < (mod->Radius*feather))
			           f = 1.0f;
				    else 
					   {
						f = 1.0f - (dist-(mod->Radius*feather))/(mod->Radius*ifeather);
						}	
					mod->ComputeFalloff(f,mod->BoneData[mod->ModeBoneIndex].FalloffType);
					f = f * mod->paintStr;
					if (f > FalloffList[i]) 
						FalloffList[i] = f;

					}
				}
			}
		}

	}
 return 1;


 }



int CreatePaintMouseProc::proc(
                        HWND hwnd, 
                        int msg, 
                        int point, 
                        int flags, 
                        IPoint2 m )
        {

        ViewExp *vpt = iObjParams->GetViewport(hwnd);   
        int res = TRUE;
        float st = 1.0f;
        int flip = 0;

		ModContextList mcList;		
		INodeTab nodes;

		if (!mod->ip) return 0;

		mod->ip->GetModContexts(mcList,nodes);
		int objects = mcList.Count();

		objList.SetCount(nodes.Count());
		for (int nc = 0; nc < nodes.Count(); nc++)
			{
			ObjectState os = nodes[nc]->EvalWorldState(mod->ip->GetTime());
			objList[nc] = os.obj;
			}



		for ( int k = 0; k < objects; k++ ) 
			{

			BoneModData *bmd = (BoneModData*)mcList[k]->localData;
			INode *node = nodes[k];


	        switch ( msg ) {
                case MOUSE_PROPCLICK:
						if (mod->painting)
							theHold.Cancel();
						else iObjParams->SetStdCommandMode(CID_OBJMOVE);
						mod->painting = FALSE;
                        break;

                case MOUSE_POINT:
					if (point == 0)
						{
						mod->HoldWeights();
						mouseHitList.ZeroCount();
						mod->painting = TRUE;
						for (int i = 0; i<bmd->selected.GetSize(); i++)
							 bmd->selected.Set(i,FALSE);


						}
					else 
						{
//compute hit list
						mod->painting = FALSE;

                        st = 1.0f;
                        flip = 0;
                        if (flags & MOUSE_ALT) 
                                {
                                st = 0.0f;
                                flip = 1;
                                }
                        mod->pblock_param->GetValue(PB_RADIUS,0,mod->Radius,FOREVER);
                        mod->pblock_param->GetValue(PB_FEATHER,0,mod->Feather,FOREVER);
                        mod->pblock_param->GetValue(PB_PAINTSTR,0,mod->paintStr,FOREVER);
						FalloffList.SetCount(bmd->VertexData.Count());
						
						for (int i = 0; i < bmd->VertexData.Count(); i++)
							FalloffList[i] = -10.0f;
						BuildFalloffList( vpt, mouseHitList,bmd, objList[k]);

                        mod->IncrementVertices(bmd,mod->ModeBoneIndex,FalloffList,flip);
						for (i = 1; i < mouseHitList.Count(); i++)
							BoneXORDottedLine(hwnd, mouseHitList[i-1], mouseHitList[i]);	// Draw it!
						bmd->forceUpdate = TRUE;
						mod->AcceptWeights(TRUE);

                        mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
                        mod->ip->RedrawViews(mod->ip->GetTime());

						break;

						}


                case MOUSE_MOVE:
						res = TRUE;

						if (mouseHitList.Count() > 1)
							{
							if (mouseHitList[mouseHitList.Count()-1] != m)
								{
								if (mouseHitList.Count() > 1)
									{
									BoneXORDottedLine(hwnd, lastPoint, m);	// Draw it!
									}

		
								lastPoint = m;

						        if ( HitTest(vpt,&m,HITTYPE_CIRCLE,HIT_ABORTONHIT,bmd,objList[k]) ) 
									{

			                        mod->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
									bmd->isHit = TRUE;
						            mod->ip->RedrawViews(mod->ip->GetTime());
	
									}
								else
									{
									if (bmd->isHit)
										{
				                        mod->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
										bmd->isHit = FALSE;
							            mod->ip->RedrawViews(mod->ip->GetTime());
										}
									else bmd->isHit = FALSE;

									}	

								mouseHitList.Append(1,&m,1);
								}

							}
						else {
							mouseHitList.Append(1,&m,1);
							lastPoint = m;
							}



                        break;
                
                case MOUSE_FREEMOVE:

                        if ( HitTest(vpt,&m,HITTYPE_CIRCLE,HIT_ABORTONHIT,bmd,objList[k]) ) {
                                SetCursor(LoadCursor(NULL,IDC_CROSS ));
							bmd->isHit = TRUE;

                             mod->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	                         mod->ip->RedrawViews(mod->ip->GetTime());

                             }
                        else {
                              SetCursor(LoadCursor(NULL,IDC_ARROW));

							  if (bmd->isHit)
								{
								  bmd->isHit = FALSE;
		                         mod->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	                             mod->ip->RedrawViews(mod->ip->GetTime());
								}
	
							  else bmd->isHit = FALSE;

                              }

                        break;
                        
                }
			}

        if ( vpt ) iObjParams->ReleaseViewport(vpt);
        return res;

	return 0;
        }



/*-------------------------------------------------------------------*/

void CreatePaintMode::EnterMode()
        {
        mod->iPaintButton->SetCheck(TRUE);

		SpinnerOn(mod->hParam,IDC_FEATHERSPIN,IDC_FEATHER);
		SpinnerOn(mod->hParam,IDC_SRADIUSSPIN,IDC_SRADIUS);
		SpinnerOn(mod->hParam,IDC_PAINT_STR_SPIN2,IDC_PAINT_STR2);

		eproc.first = TRUE;		
		mod->inPaint = TRUE;
        mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);


        }

void CreatePaintMode::ExitMode()
        {
        mod->iPaintButton->SetCheck(FALSE);
		SpinnerOff(mod->hParam,IDC_FEATHERSPIN,IDC_FEATHER);
		SpinnerOff(mod->hParam,IDC_SRADIUSSPIN,IDC_SRADIUS);
		SpinnerOff(mod->hParam,IDC_PAINT_STR_SPIN2,IDC_PAINT_STR2);

		mod->inPaint = FALSE;
        mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);


//nuke mesh cache

        }

void BonesDefMod::StartPaintMode()
        {
        if ( !ip ) return;

//get mesh
		if (ip->GetCommandMode() == PaintMode) {
			ip->SetStdCommandMode(CID_OBJMOVE);
			return;
			}

        ip->SetCommandMode(PaintMode);
        }


//watje 9-7-99 198721 

class CacheModEnumProc : public ModContextEnumProc {
public:
	BonesDefMod *lm;
	CacheModEnumProc(BonesDefMod *l)
		{
		lm = l;
		}
private:
	BOOL proc (ModContext *mc);
};

BOOL CacheModEnumProc::proc (ModContext *mc) {
	if (mc->localData == NULL) return TRUE;

	BoneModData *bmd = (BoneModData *) mc->localData;
	bmd->CurrentCachePiece = -1;
	return TRUE;
}



/*-------------------------------------------------------------------*/
/*																	*/
/*				Select Bone Dialog Mode									*/
/*																	*/
/*-------------------------------------------------------------------*/



//This handles the output of particle info
//Hit Dialog


#define PERCENT_LENGTH	0.3f
#define PERCENT_LENGTH_CLOSED	0.1f
#define OUTER_MULT		3.5f


void DumpHitDialog::proc(INodeTab &nodeTab)

{

int nodeCount = nodeTab.Count(); 

if (nodeCount == 0) return;

for (int i=0;i<nodeTab.Count();i++)
	{


	ModContextList mcList;
	INodeTab nodes;
	eo->ip->GetModContexts(mcList,nodes);
	assert(nodes.Count());
//	Matrix3 ourTM;

//	ourTM = nodes[0]->GetObjectTM(eo->RefFrame);
//	eo->BaseTM = ourTM;

	Class_ID bid(BONE_CLASS_ID,0);




//need to add subcount for shapes also
	int subcount = 1;
	ObjectState os = nodeTab[i]->EvalWorldState(eo->RefFrame);
	if (os.obj->ClassID() == bid)  
		{
//		subcount = nodeTab[i]->NumberOfChildren();
//		if (subcount == 0) subcount = 1;
		}
	else if (os.obj->SuperClassID()==SHAPE_CLASS_ID)
		{
//get spline piecs
		}


	for (int j = 0; j < subcount; j++)
		{

//		Object *obj = nodes[0]->EvalWorldState(eo->RefFrame).obj;

		BoneDataClass t;
		t.Node = nodeTab[i];
		TCHAR title[200];
		_tcscpy(title,nodeTab[i]->GetName());


		int current=-1;
		BOOL found = FALSE;
		for (int bct = 0; bct < eo->BoneData.Count();bct++)
			{
			if (eo->BoneData[bct].Node == NULL) 
				{
				current = bct;
				found = TRUE;
				bct = eo->BoneData.Count();
				}
			}
		if (!found)
			current = eo->BoneData.Count();
		int BoneRefID = eo->GetOpenID();
		int End1RefID = eo->GetOpenID();
		int End2RefID = eo->GetOpenID();

		if (current != -1) {

			Matrix3 ntm = t.Node->GetObjectTM(eo->RefFrame);	


//append a new bone
			BoneDataClass t;
			if (!found)
				eo->BoneData.Append(t);
			eo->BoneData[current].Node = NULL;
			eo->BoneData[current].EndPoint1Control = NULL;
			eo->BoneData[current].EndPoint2Control = NULL;
		
			eo->BoneData[current].tm    = Inverse(ntm);
			eo->BoneData[current].CrossSectionList.ZeroCount();


			Point3 l1(0.0f,0.0f,0.0f),l2(0.0f,0.0f,0.0f);
		

//object is bone use its first child as the axis
			eo->BoneData[current].flags = 0;
			if (os.obj->ClassID() == bid) 
				{
				l1.x = 0.0f;
				l1.y = 0.0f;
				l1.z = 0.0f;
				l2.x = 0.0f;
				l2.y = 0.0f;
				l2.z = 0.0f;
//get child node
				INode* parent = nodeTab[i]->GetParentNode();
//				ntm = t.Node->GetObjectTM(eo->RefFrame);	
				ntm = parent->GetObjectTM(eo->RefFrame);	
				eo->BoneData[current].tm    = Inverse(ntm);

//				if (nodeTab[i]->NumberOfChildren() > 0)
				if (1)
					{
//					INode *child = nodeTab[i]->GetChildNode(j);
					Matrix3 ChildTM = nodeTab[i]->GetObjectTM(eo->RefFrame);

					_tcscpy(title,nodeTab[i]->GetName());


					l2 = l2 * ChildTM;
					l2 = l2 * Inverse(ntm); 
					Point3 Vec = (l2-l1);
					l1 += Vec * 0.1f;
					l2 -= Vec * 0.1f;
					}
				else 
					{
					l2.x = 0.0f;
					l2.y = 0.0f;
					l2.z = 50.0f;
					}
				float el1 = 0.0f,el2 = 0.0f;
				float d = Length(l2-l1);
				if (d < 0.1f) d = 10.f;
				el1 = d * PERCENT_LENGTH;



				float e_inner, e_outer;
				e_inner = el1 ;
				e_outer = e_inner *OUTER_MULT;
				eo->AddCrossSection(current, 0.0f, e_inner,e_outer);
				e_inner = el1 ;
				e_outer = e_inner *OUTER_MULT;
				eo->AddCrossSection(current, 1.0f, e_inner,e_outer);
				eo->BoneData[current].flags = BONE_BONE_FLAG;

				}
//object is bone use its first child as the axis
			else if (os.obj->SuperClassID()==SHAPE_CLASS_ID)
				{
//build distance based on spline
				eo->BoneData[current].flags = eo->BoneData[current].flags|BONE_SPLINE_FLAG;
				ShapeObject *pathOb = NULL;
				ObjectState os = nodeTab[i]->EvalWorldState(eo->RefFrame);


				BezierShape bShape;
				ShapeObject *shape = (ShapeObject *)os.obj;
				if(shape->CanMakeBezier())
//watje 9-7-99  195862 
					shape->MakeBezier(eo->RefFrame, bShape);
//					shape->MakeBezier(eo->ip->GetTime(), bShape);
				else {
					PolyShape pShape;
//watje 9-7-99  195862 
					shape->MakePolyShape(eo->RefFrame, pShape);
//					shape->MakePolyShape(eo->ip->GetTime(), pShape);
					bShape = pShape;	// UGH -- Convert it from a PolyShape -- not good!
					}

				pathOb = (ShapeObject*)os.obj;

				if (bShape.splines[0]->Closed() )
					eo->BoneData[current].flags = eo->BoneData[current].flags|BONE_SPLINECLOSED_FLAG;

//watje 9-7-99  195862 
				l1 = pathOb->InterpCurve3D(eo->RefFrame, 0, 0.0f, SPLINE_INTERP_SIMPLE);			
//				l1 = pathOb->InterpCurve3D(0, 0, 0.0f, SPLINE_INTERP_SIMPLE);			
//watje 9-7-99  195862 
				l2 = pathOb->InterpCurve3D(eo->RefFrame, 0, 1.0f, SPLINE_INTERP_SIMPLE);			
//				l2 = pathOb->InterpCurve3D(0, 0, 1.0f, SPLINE_INTERP_SIMPLE);			

				float el1 = 0.0f,el2 = 0.0f;
				float s1 = bShape.splines[0]-> SplineLength();
				if (s1< 0.1f) s1 = 10.f;
				if (bShape.splines[0]->Closed() )
					el1 = s1 * PERCENT_LENGTH_CLOSED;
				else el1 = s1 * PERCENT_LENGTH;

				float e_inner, e_outer;
				e_inner = el1;
				e_outer = e_inner *OUTER_MULT;
				eo->AddCrossSection(current, 0.0f, e_inner,e_outer);
				e_inner = el1;
				e_outer = e_inner *OUTER_MULT;
				eo->AddCrossSection(current, 1.0f, e_inner,e_outer);

//copy initial reference spline into our spline
//				SplineShape *shape = (SplineShape *)os.obj;

				eo->BoneData[current].referenceSpline = *bShape.splines[0];

				}

			else 
				{
				eo->BuildMajorAxis(nodeTab[i],l1,l2); 
				float el1 = 0.0f,el2 = 0.0f;
				float d = Length(l2-l1);
				if (d < 0.1f) d = 10.f;
				el1 = d * PERCENT_LENGTH;

				float e_inner, e_outer;
				e_inner = el1 ;
				e_outer = e_inner *OUTER_MULT;
				eo->AddCrossSection(current, 0.0f, e_inner,e_outer);
				e_inner = el1 ;
				e_outer = e_inner *OUTER_MULT;
				eo->AddCrossSection(current, 1.0f, e_inner,e_outer);

				}

			l1 = l1;// * Inverse(eo->BoneData[current].tm);
			l2 = l2;// * Inverse(eo->BoneData[current].tm);
			eo->BoneData[current].flags = eo->BoneData[current].flags|BONE_ABSOLUTE_FLAG;
			eo->BoneData[current].FalloffType = 0;

			eo->BoneData[current].BoneRefID = BoneRefID;
			eo->BoneData[current].RefEndPt1ID = End1RefID;
			eo->BoneData[current].RefEndPt2ID = End2RefID;

			eo->BoneData[current].end1Selected = FALSE;
			eo->BoneData[current].end2Selected = FALSE;


			if (os.obj->ClassID() == bid) 
				{
//get child node
				INode* parent = nodeTab[i]->GetParentNode();
				eo->ReplaceReference(BoneRefID,parent,FALSE);
				eo->BoneData[current].name = title;
				}
			else eo->ReplaceReference(BoneRefID,nodeTab[i],FALSE);


			eo->MakeRefByID(FOREVER,End1RefID,NewDefaultPoint3Controller());
			eo->MakeRefByID(FOREVER,End2RefID,NewDefaultPoint3Controller());
			eo->BoneData[current].EndPoint1Control->SetValue(0,&l1,TRUE,CTRL_ABSOLUTE);
			eo->BoneData[current].EndPoint2Control->SetValue(0,&l2,TRUE,CTRL_ABSOLUTE);


			int rsel = eo->ConvertSelectedBoneToListID(current);

			SendMessage(GetDlgItem(eo->hParam,IDC_LIST1),
				LB_INSERTSTRING,(WPARAM) rsel,(LPARAM)(TCHAR*)title);


			nodes.DisposeTemporary();
			}
		

		eo->ModeBoneIndex = current;
		eo->ModeBoneEndPoint = -1;
		eo->ModeBoneEnvelopeIndex = -1;
		eo->ModeBoneEnvelopeSubType = -1;
		SendMessage(GetDlgItem(eo->hParam,IDC_LIST1),
				LB_SETCURSEL ,current,0);

		if (eo->BoneData[eo->ModeBoneIndex].flags & BONE_LOCK_FLAG)
			eo->pblock_param->SetValue(PB_LOCK_BONE,0,1);
		else
			eo->pblock_param->SetValue(PB_LOCK_BONE,0,0);

		if (eo->BoneData[eo->ModeBoneIndex].flags & BONE_ABSOLUTE_FLAG)
			eo->pblock_param->SetValue(PB_ABSOLUTE_INFLUENCE,0,1);
		else
			eo->pblock_param->SetValue(PB_ABSOLUTE_INFLUENCE,0,0);
//watje 9-7-99  198721 
		eo->Reevaluate(TRUE);
		}
	
	}
	
if ( (eo->BoneData.Count() >0) && (eo->ip && eo->ip->GetSubObjectLevel() == 1) )
	{
	eo->EnableButtons();
	}

if (eo->BoneData[eo->ModeBoneIndex].flags & BONE_ABSOLUTE_FLAG)
	{
	eo->iAbsolute->SetCheck(FALSE);

	eo->pblock_param->SetValue(PB_ABSOLUTE_INFLUENCE,0,1);
	}
else
	{
	eo->iAbsolute->SetCheck(TRUE);
	eo->pblock_param->SetValue(PB_ABSOLUTE_INFLUENCE,0,0);
	}


if (eo->BoneData[eo->ModeBoneIndex].flags & BONE_DRAW_ENVELOPE_FLAG)
	{
	eo->pblock_param->SetValue(PB_DRAW_BONE_ENVELOPE,0,1);
	eo->iEnvelope->SetCheck(TRUE);

	}
else
	{
	eo->pblock_param->SetValue(PB_DRAW_BONE_ENVELOPE,0,0);
	eo->iEnvelope->SetCheck(FALSE);
	}

if (eo->BoneData[eo->ModeBoneIndex].FalloffType == BONE_FALLOFF_X_FLAG)
	eo->iFalloff->SetCurFlyOff(0,FALSE);
else if (eo->BoneData[eo->ModeBoneIndex].FalloffType == BONE_FALLOFF_SINE_FLAG)
	eo->iFalloff->SetCurFlyOff(1,FALSE);
else if (eo->BoneData[eo->ModeBoneIndex].FalloffType == BONE_FALLOFF_X3_FLAG)
	eo->iFalloff->SetCurFlyOff(3,FALSE);
else if (eo->BoneData[eo->ModeBoneIndex].FalloffType == BONE_FALLOFF_3X_FLAG)
	eo->iFalloff->SetCurFlyOff(2,FALSE);

eo->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
//eo->CurrentCachePiece = -1;
//watje 9-7-99  198721 
CacheModEnumProc lmdproc(eo);
eo->EnumModContexts(&lmdproc);

eo->cacheValid = FALSE;
}


int DumpHitDialog::filter(INode *node)

{

	TCHAR name1[200];
	_tcscpy(name1,node->GetName());

	node->BeginDependencyTest();
	eo->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
	if (node->EndDependencyTest()) 
		{		
		return FALSE;
		} 
	else 
		{
		ObjectState os = node->EvalWorldState(0);
		Class_ID bid(BONE_CLASS_ID,0);
		for (int i = 0;i < eo->BoneData.Count(); i++)
			{
			
			if (eo->BoneData[i].Node) 
				{
				ObjectState bos = eo->BoneData[i].Node->EvalWorldState(0);

				if ( (node == eo->BoneData[i].Node) &&
					 (os.obj->ClassID() != bid)  )
					return FALSE;

				}



			}


		if (os.obj->ClassID() == bid)  
				{

				int found = SendMessage(GetDlgItem(eo->hParam,IDC_LIST1),
							LB_FINDSTRING,(WPARAM) 0,(LPARAM)(TCHAR*)name1);
				if (found != LB_ERR ) return FALSE;

				}

			//}

//check for end nodes

		if (os.obj->ClassID() == bid)  
			{
//get parent if
			INode* parent = node->GetParentNode();
			if (parent->IsRootNode()) return FALSE;
			if (parent == NULL) return FALSE;
			
			ObjectState pos = parent->EvalWorldState(0);
			if (pos.obj->ClassID() != bid)  return FALSE;
		
//			int subcount = node->NumberOfChildren();
//			if (subcount == 0) return FALSE;
			}
		if (os.obj->SuperClassID()==SHAPE_CLASS_ID)
			{
			if ( (os.obj->ClassID()==EDITABLE_SURF_CLASS_ID)
				)
				return FALSE;
			}	



		}

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\BonesDef\DistanceStuff.cpp ===
/**********************************************************************
 
	FILE: DistanceStuff.cpp

	DESCRIPTION:  Bones def methods to find distances from stuff

	CREATED BY: Peter Watje

	HISTORY: 8/5/98




 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/



#include "mods.h"
#include "iparamm.h"
#include "shape.h"
#include "spline3d.h"
#include "splshape.h"
#include "linshape.h"

// This uses the linked-list class templates
#include "linklist.h"
#include "bonesdef.h"
#include <process.h>


void BonesDefMod::BuildCacheThread(BoneModData *bmd, int start, int end, int BoneIndex, TimeValue t, ObjectState *os, ShapeObject *pathOb, Matrix3 ntm )
{
	for (int i=start; i<end; i++) 
		{
//get total distance
		float TotalDistance = 0.0f;
		Point3 p,BoneCenter;		
//		if (!bmd->VertexData[i]->modified)
			{

			p = os->obj->GetPoint(i);

			if (BoneData[BoneIndex].Node != NULL)
				{
				float Influence = 1.0f;
				Point3 l1,l2;

				GetEndPoints(bmd,t,l1, l2, BoneIndex);
				float LineU = 0.0f;
				Point3 op,otan;
				int cid,sid;

				if (BoneData[BoneIndex].flags & BONE_SPLINE_FLAG)
					{
//					Interval valid;
//					Matrix3 ntm = BoneData[BoneIndex].Node->GetObjTMBeforeWSM(RefFrame,&valid);
//					ntm =bmd->BaseTM * Inverse(ntm);

//					Influence = SplineToPoint(p,pathOb,LineU,op,otan,cid,sid,ntm);
					Influence = SplineToPoint(p,
											  &BoneData[BoneIndex].referenceSpline,
											  LineU,op,otan,cid,sid,ntm);
					}
				else
					{
					Influence = LineToPoint(p,l1,l2,LineU);
					}
				bmd->DistCache[i].dist = Influence;
				bmd->DistCache[i].u = LineU;
				bmd->DistCache[i].SubCurveIds =cid;
				bmd->DistCache[i].SubSegIds =sid;
				bmd->DistCache[i].Tangents =otan;
				bmd->DistCache[i].OPoints =op;
				}

			}
		}
	
}

class ThreadData
{
public:
BonesDefMod *b;
BoneModData *bmd;
int start,end;
int boneIndex;
TimeValue t;
ObjectState *os;
ShapeObject *pathOb;
Matrix3 ntm;
};
void CallBuildCacheThread();

void CallBuildCacheThread(void *data)
{
//DebugPrint("Thread from %d to %d\n",((ThreadData*)(data))->start,((ThreadData*)(data))->end);

((ThreadData*)(data))->b->BuildCacheThread(((ThreadData*)(data))->bmd,
					((ThreadData*)(data))->start,((ThreadData*)(data))->end,
					((ThreadData*)(data))->boneIndex, ((ThreadData*)(data))->t, ((ThreadData*)(data))->os,
					((ThreadData*)(data))->pathOb,
					((ThreadData*)(data))->ntm
					);
}

void BonesDefMod::BuildCache(BoneModData *bmd, int BoneIndex, TimeValue t, ObjectState *os)
{
if ( GetInMouseAbort() && ( (ModeBoneEndPoint == 0) || (ModeBoneEndPoint == 1)) )
	{
	}
else if (cacheValid)
	{
	if (BoneIndex == bmd->CurrentCachePiece) return;
	}


int nv = os->obj->NumPoints();

if (bmd->DistCache.Count() != nv) bmd->DistCache.SetCount(nv);
bmd->CurrentCachePiece = BoneIndex;
cacheValid = TRUE;

//DebugPrint("Building Cache\n");
int DoThread = 1;
if (DoThread)
	{
//get number of processors
	SYSTEM_INFO info;
	GetSystemInfo(  &info );  // address of system information 
    int numProcessors = info.dwNumberOfProcessors; 

//	numProcessors = 2; 
//break the number verts ont group

	ThreadData TData[8];
	int ct =0,w;
	w = nv/numProcessors;
	static HANDLE ThreadHandles[8];

	ShapeObject *pathOb = NULL;
//	ObjectState pos = BoneData[BoneIndex].Node->EvalWorldState(RefFrame);
//	pathOb = (ShapeObject*)pos.obj;

	Interval valid;
	Matrix3 ntm;
//watje 10-7-99 212059
	ntm = bmd->BaseTM*BoneData[BoneIndex].tm;

//	Matrix3 ntm = BoneData[BoneIndex].Node->GetObjTMBeforeWSM(RefFrame,&valid);
//	ntm =bmd->BaseTM * Inverse(ntm);


	for (int nThreads =0; nThreads < numProcessors;nThreads++)
		{
		TData[nThreads].start = ct;
		if (numProcessors == 1)
			TData[nThreads].end = nv;
		else if (nThreads == (numProcessors-1))
			TData[nThreads].end = nv;
		else TData[nThreads].end = ct+w;
		TData[nThreads].t = t;
		TData[nThreads].boneIndex = BoneIndex;
		TData[nThreads].os = os;
		TData[nThreads].b = this;
		TData[nThreads].bmd = bmd;
//		TData[nThreads].pathOb = pathOb;
		TData[nThreads].ntm = ntm;



		ct += w;
		ThreadHandles[nThreads] = (HANDLE) _beginthread(CallBuildCacheThread,0,(void *) &TData[nThreads]);
		}


	int ThredErr = WaitForMultipleObjects(numProcessors,ThreadHandles,TRUE,INFINITE);
	}
else
	{
	ShapeObject *pathOb = NULL;
	if (BoneData[BoneIndex].flags & BONE_SPLINE_FLAG)
		{
		ObjectState pos = BoneData[BoneIndex].Node->EvalWorldState(RefFrame);
		pathOb = (ShapeObject*)pos.obj;
		}
	for (int i=0; i<nv; i++) {
//get total distance
		float TotalDistance = 0.0f;
		Point3 p,BoneCenter;		
		if (!bmd->VertexData[i]->modified)
			{

			p = os->obj->GetPoint(i);

			if (BoneData[BoneIndex].Node != NULL)
				{
				float Influence = 1.0f;
				Point3 l1,l2;

				GetEndPoints(bmd,t,l1, l2, BoneIndex);
				float LineU = 0.0f;
				Point3 op,otan;
				int cid,sid;

				if (BoneData[BoneIndex].flags & BONE_SPLINE_FLAG)
					{
					ShapeObject *pathOb = NULL;
					ObjectState os = BoneData[BoneIndex].Node->EvalWorldState(RefFrame);
					pathOb = (ShapeObject*)os.obj;

					Interval valid;
					Matrix3 ntm = BoneData[BoneIndex].Node->GetObjTMBeforeWSM(RefFrame,&valid);
					ntm =bmd->BaseTM * Inverse(ntm);

//					Influence = SplineToPoint(p,pathOb,LineU,op,otan,cid,sid,ntm);
					Influence = SplineToPoint(p,
											&BoneData[BoneIndex].referenceSpline,
											LineU,op,otan,cid,sid,ntm);
					}
				else
					{
					Influence = LineToPoint(p,l1,l2,LineU);
					}
				bmd->DistCache[i].dist = Influence;
				bmd->DistCache[i].u = LineU;
				bmd->DistCache[i].SubCurveIds =cid;
				bmd->DistCache[i].SubSegIds =sid;
				bmd->DistCache[i].Tangents =otan;
				bmd->DistCache[i].OPoints =op;
				}

			}
		}
	}


}


void BonesDefMod::ClosestPoint(float inc, float start, float end, 
							   Tab<float> *ClosestU, Tab<int> *ci, ShapeObject *s, Point3 p1)
{

for (int pc = 0; pc < s->NumberOfCurves(); pc++)
	{
	BOOL GoingAway = FALSE;
	float u = start;
	Point3 p;
	p = s->InterpCurve3D(0,pc,start,PARAM_SIMPLE);
	float LastDist = LengthSquared(p-p1);
	u += inc;
	p = s->InterpCurve3D(0,pc,u,PARAM_SIMPLE);
	float dist = LengthSquared(p-p1);
	if (dist>LastDist)
		{
		float cu = 0.0f;
		ClosestU->Append(1,&cu,1);
		ci->Append(1,&pc,1);
		GoingAway = TRUE;
		}
	else
		{
		GoingAway = FALSE;
		}
	while (u < end)
		{
		p = s->InterpCurve3D(0,pc,u,PARAM_SIMPLE);
		dist = LengthSquared(p-p1);
		if (GoingAway)
			{
			if ((dist < LastDist) )
				{
				GoingAway = FALSE;
				}
			}
		else
			{
			if ((dist > LastDist) )
				{
				float cu = u - inc;
				ClosestU->Append(1,&cu,1);
				ci->Append(1,&pc,1);
				GoingAway = TRUE;
				}

			}
		LastDist = dist;
		u += inc;
		}

	p = s->InterpCurve3D(0,pc,u,PARAM_SIMPLE);
	dist = Length(p-p1);
	if (GoingAway)
		{
		if (dist <LastDist)
			{
			float cu = u - inc;
			ClosestU->Append(1,&cu,1);
			ci->Append(1,&pc,1);
			}

		}
	else
		{
		if (dist > LastDist)
			{
			float cu = u - inc;
			ClosestU->Append(1,&cu,1);
			ci->Append(1,&pc,1);
			}

		}
	}

}

void BonesDefMod::ClosestPoint(float inc, float start, float end, 
							   Tab<float> *ClosestU, int ci, ShapeObject *s, Point3 p1)
{
int pc = ci;
float u = start;
Point3 p = s->InterpCurve3D(0,pc,u,PARAM_SIMPLE);
float fdist = Length(p1-p);
u += inc;
BOOL done = FALSE;
while ( (u <= end) && (!done))
	{
	p = s->InterpCurve3D(0,pc,u,PARAM_SIMPLE);
	float dist = LengthSquared(p-p1);
	if (dist > fdist) 
		{
		float cu = u - inc;
		ClosestU->Append(1,&cu,1);
		done = TRUE;
		}
		u += inc;
	}

}

void BonesDefMod::RecurseDepth(float u1, float u2, float &fu,  ShapeObject *s,int Curve,int Piece, int &depth, Point3 fp)
{


//float u = 0.0f;
/*
if (depth == 0)
	{
	fu = (u2+u1)/2.0f;
	}
else
	{
*/

for (int i = 0; i < depth; i++)
	{
	float u = (u1+u2)*.5f;
	float midu = (u2-u1)*.25f;
	float tu1 = u - midu; 
	float tu2 = u + midu;
	Point3 p1, p2;
	p1 = s->InterpPiece3D(RefFrame, Curve, Piece, tu1);
	p2 = s->InterpPiece3D(RefFrame, Curve, Piece, tu2);



	if ( LengthSquared(fp-p1) < LengthSquared(fp-p2) )
		{
		u1 = u1;
		u2 = u;
		}
	else
		{
		u1 = u;
		u2 = u2;
		}

	}
fu = (u2+u1)*0.5f;
}

void BonesDefMod::PointToPiece(float &tempu,ShapeObject *s,int Curve,int Piece, int depth, Point3 fp)

{
//float tu1,tu2,tu3,tu4;
float tu;
float su,eu;
int depth1;

depth1 = depth;

su = 0.0f;
eu = 0.25f;

float fdist = BIGFLOAT;
float fu = 0.0f;

for (int i = 0; i < 4; i++)
	{
	tu = 0.0f;
	depth = depth1;
	RecurseDepth(su,eu,tu,s,Curve,Piece,depth,fp);
	su += 0.25f;
	eu += 0.25f;
	Point3 dp = s->InterpPiece3D(RefFrame, Curve, Piece, tu);
	float dist = LengthSquared(fp-dp);
	if (dist<fdist)
		{
		fdist = dist;
		fu = tu;
		}
	}


tempu = fu;
//return fu;
}



float BonesDefMod::SplineToPoint(Point3 p1, ShapeObject *s, float &finalu, Point3 &op, Point3 &otan, int &cid, int &sid, Matrix3 tm)

{

//brute force for now
p1 = p1 * tm;

int rec_depth = 5;

int piece_count = 0;
float fdist = BIGFLOAT;
int i = 0;
//for (int i = 0; i < s->NumberOfCurves(); i++)
	{
	for (int j = 0; j < s->NumberOfPieces(RefFrame,i); j++)
		{
		float u;
		PointToPiece(u,s,i,j,rec_depth,p1);
		Point3 dp = s->InterpPiece3D(RefFrame, i, j, u);
		float dist = LengthSquared(p1-dp);
		if (dist<fdist)
			{
			fdist = dist;
			finalu = u;
			op = dp;
			otan = s->TangentPiece3D(RefFrame,i,j,finalu);
			cid = i;
			sid = j;
			}
		}
	}

return (float)sqrt(fdist);
}


void BonesDefMod::RecurseDepth(float u1, float u2, float &fu,  Spline3D *s,int Curve,int Piece, int &depth, Point3 fp)
{


//float u = 0.0f;
/*
if (depth == 0)
	{
	fu = (u2+u1)/2.0f;
	}
else
	{
*/

for (int i = 0; i < depth; i++)
	{
	float u = (u1+u2)*.5f;
	float midu = (u2-u1)*.25f;
	float tu1 = u - midu; 
	float tu2 = u + midu;
	Point3 p1, p2;
	p1 = s->InterpBezier3D(Piece, tu1);
	p2 = s->InterpBezier3D(Piece, tu2);



	if ( LengthSquared(fp-p1) < LengthSquared(fp-p2) )
		{
		u1 = u1;
		u2 = u;
		}
	else
		{
		u1 = u;
		u2 = u2;
		}

	}
fu = (u2+u1)*0.5f;
}

void BonesDefMod::PointToPiece(float &tempu,Spline3D *s,int Curve,int Piece, int depth, Point3 fp)

{
//float tu1,tu2,tu3,tu4;
float tu;
float su,eu;
int depth1;

depth1 = depth;

su = 0.0f;
eu = 0.25f;

float fdist = BIGFLOAT;
float fu = 0.0f;

for (int i = 0; i < 4; i++)
	{
	tu = 0.0f;
	depth = depth1;
	RecurseDepth(su,eu,tu,s,Curve,Piece,depth,fp);
	su += 0.25f;
	eu += 0.25f;
	Point3 dp = s->InterpBezier3D(Piece, tu);
	float dist = LengthSquared(fp-dp);
	if (dist<fdist)
		{
		fdist = dist;
		fu = tu;
		}
	}


tempu = fu;
//return fu;
}


float BonesDefMod::SplineToPoint(Point3 p1, 
								 Spline3D *s, 
								 float &finalu, Point3 &op, Point3 &otan, int &cid, int &sid, Matrix3 tm)

{

//brute force for now
p1 = p1 * tm;

int rec_depth = 5;

int piece_count = 0;
float fdist = BIGFLOAT;
int i = 0;
//for (int i = 0; i < s->NumberOfCurves(); i++)
	{
	for (int j = 0; j < s->Segments(); j++)
		{
		float u;
		PointToPiece(u,s,i,j,rec_depth,p1);
		Point3 dp = s->InterpBezier3D( j, u);
		float dist = LengthSquared(p1-dp);
		if (dist<fdist)
			{
			fdist = dist;
			finalu = u;
			op = dp;
			otan = s->TangentBezier3D(j,finalu);
			cid = i;
			sid = j;
			}
		}
	}

return (float)sqrt(fdist);
}


float BonesDefMod::LineToPoint(Point3 p1, Ray r, float &u)

{
Point3 VectorA,VectorB,VectorC;
double Angle;
double dist = 0.0f;

//VectorA = r.p+r.dir;
VectorA = r.dir;
VectorB = p1-r.p;
Angle = acos(DotProd(Normalize(VectorA),Normalize(VectorB)));

double hyp;
hyp = Length(VectorB);
dist =  sin(Angle) * hyp;

u = (float) (cos(Angle) * hyp);

return (float) dist;

}

float BonesDefMod::LineToPoint(Point3 p1, Point3 l1, Point3 l2, float &u)
{
Point3 VectorA,VectorB,VectorC;
double Angle;
double dist = 0.0f;
VectorA = l2-l1;
VectorB = p1-l1;
Angle =  acos(DotProd(Normalize(VectorA),Normalize(VectorB)));
if (Angle > (3.14/2.0))
	{
	dist = Length(p1-l1);
	u = 0.0f;
	}
else
	{
	VectorA = l1-l2;
	VectorB = p1-l2;
	Angle = acos(DotProd(Normalize(VectorA),Normalize(VectorB)));
	if (Angle > (3.14/2.0))
		{
		dist = Length(p1-l2);
		u = 1.0f;
		}
		else
		{
		double hyp;
		hyp = Length(VectorB);
		dist =  sin(Angle) * hyp;
		double du =  (cos(Angle) * hyp);
		double a = Length(VectorA);
		if ( a== 0.0f)
			return 0.0f;
		else u = (float)((a-du) / a);

		}

	}

return (float) dist;

}



void BonesDefMod::ComputeFalloff(float &u, int ftype)

{

switch (ftype)
	{
	case (BONE_FALLOFF_X3_FLAG) : u = u*u*u; break;
	case (BONE_FALLOFF_X2_FLAG) : u = u*u; break;
	case (BONE_FALLOFF_X_FLAG) : u = u; break;
	case (BONE_FALLOFF_SINE_FLAG) : u = 1.0f-((float)cos(u*PI) + 1.0f)*0.5f; break;
	case (BONE_FALLOFF_2X_FLAG) : u = (float) sqrt(u); break;
	case (BONE_FALLOFF_3X_FLAG) : u = (float) pow(u,0.3); break;

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\BonesDef\BonesDef.cpp ===
/**********************************************************************
 
	FILE: BonesDef.cpp

	DESCRIPTION:  Simple Bones Deformation Plugin

	CREATED BY: Peter Watje

	HISTORY: 8/5/98


 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm.h"
#include "shape.h"
#include "spline3d.h"
#include "splshape.h"
#include "linshape.h"
#include "surf_api.h"

// This uses the linked-list class templates
#include "linklist.h"
#include "bonesdef.h"
#include "macrorec.h"


HWND BonesDefMod::hParam  = NULL;
CreateCrossSectionMode* BonesDefMod::CrossSectionMode   = NULL;
CreatePaintMode*        BonesDefMod::PaintMode   = NULL;
ICustButton* BonesDefMod::iCrossSectionButton   = NULL;
ICustButton* BonesDefMod::iLock   = NULL;
ICustButton* BonesDefMod::iAbsolute   = NULL;
ICustButton* BonesDefMod::iEnvelope   = NULL;
ICustButton* BonesDefMod::iFalloff   = NULL;
ICustButton* BonesDefMod::iCopy   = NULL;
ICustButton* BonesDefMod::iPaste   = NULL;
ICustButton* BonesDefMod::iPaintButton  = NULL;
ICustToolbar* BonesDefMod::iParams = NULL;

//--- ClassDescriptor and class vars ---------------------------------

IParamMap       *BonesDefMod::pmapParam = NULL;
IObjParam       *BonesDefMod::ip        = NULL;
BonesDefMod     *BonesDefMod::editMod   = NULL;
MoveModBoxCMode *BonesDefMod::moveMode  = NULL;
int			    BonesDefMod::LastSelected = 0;		

class BonesDefClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new BonesDefMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_BONESDEFMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
											   
	Class_ID		ClassID() { return Class_ID(9815843,87654); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}


	};

static BonesDefClassDesc bonesDefDesc;
extern ClassDesc* GetBonesDefModDesc() {return &bonesDefDesc;}


BonesRightMenu rMenu;

//watje 10-13-99 212156
BOOL BonesDefMod::DependOnTopology(ModContext &mc) {
	BoneModData *bmd = (BoneModData*)mc.localData;
	BOOL topo = FALSE;
	if (bmd) 
		for ( int i =0; i <bmd->VertexData.Count(); i++)
			{
			if (bmd->VertexData[i]->modified)
				{
				topo = TRUE;
				i = bmd->VertexData.Count();
				}

			}
	return topo;
}


int BonesDefMod::NumRefs() {
	int ct = 1;

	for (int i = 0; i<BoneData.Count();i++)
		{

		if (BoneData[i].RefEndPt1ID > ct) ct = BoneData[i].RefEndPt1ID;
		if (BoneData[i].RefEndPt2ID > ct) ct = BoneData[i].RefEndPt2ID;
		if (BoneData[i].BoneRefID > ct) ct = BoneData[i].BoneRefID;
		for (int j = 0; j<BoneData[i].CrossSectionList.Count();j++)
			{
			if (BoneData[i].CrossSectionList[j].RefInnerID > ct) ct = BoneData[i].CrossSectionList[j].RefInnerID;
			if (BoneData[i].CrossSectionList[j].RefOuterID > ct) ct = BoneData[i].CrossSectionList[j].RefOuterID;
//			ct += BoneData[i].CrossSectionList.Count()*2;
			}
		}
	return (ct+1);
	}



//watje 9-7-99  198721 
class ReevalModEnumProc : public ModContextEnumProc {
public:
	BonesDefMod *lm;
	BOOL ev;
	ReevalModEnumProc(BonesDefMod *l, BOOL e)
		{
		lm = l;
		ev = e;
		}
private:
	BOOL proc (ModContext *mc);
};

BOOL ReevalModEnumProc::proc (ModContext *mc) {
	if (mc->localData == NULL) return TRUE;

	BoneModData *bmd = (BoneModData *) mc->localData;
	bmd->reevaluate = ev;
	return TRUE;
}

//watje 9-7-99  198721 
void BonesDefMod::Reevaluate(BOOL eval)
{
ReevalModEnumProc lmdproc(this,eval);
EnumModContexts(&lmdproc);

}

void BonesDefMod::CopyBone()
{

if ((ModeBoneIndex != -1) && (BoneData.Count() > 0))
	{
//get end point1
	Interval v;
	BoneData[ModeBoneIndex].EndPoint1Control->GetValue(0,&CopyBuffer.E1,v,CTRL_ABSOLUTE);
//get end point2
	BoneData[ModeBoneIndex].EndPoint2Control->GetValue(0,&CopyBuffer.E2,v,CTRL_ABSOLUTE);
//need to set in local space
//	CopyBuffer.E1 = CopyBuffer.E1*BoneData[ModeBoneIndex].tm;
//	CopyBuffer.E2 = CopyBuffer.E2*BoneData[ModeBoneIndex].tm;

	CopyBuffer.absolute = FALSE;
	if (BoneData[ModeBoneIndex].flags & BONE_ABSOLUTE_FLAG)
		CopyBuffer.absolute = TRUE;

	CopyBuffer.showEnvelope = FALSE;
	if (BoneData[ModeBoneIndex].flags & BONE_DRAW_ENVELOPE_FLAG)
		CopyBuffer.showEnvelope = TRUE;
	
	CopyBuffer.falloffType = BoneData[ModeBoneIndex].FalloffType;


//get cross sections
	CopyBuffer.CList.ZeroCount();
	for (int i = 0; i < BoneData[ModeBoneIndex].CrossSectionList.Count();i++)
		{
		CopyCrossClass c;
		c.u = BoneData[ModeBoneIndex].CrossSectionList[i].u;
		BoneData[ModeBoneIndex].CrossSectionList[i].InnerControl->GetValue(0,&c.inner,v);
		BoneData[ModeBoneIndex].CrossSectionList[i].OuterControl->GetValue(0,&c.outer,v);
		CopyBuffer.CList.Append(1,&c,1);
		}
	}
}

void BonesDefMod::PasteBone()
{
if (ModeBoneIndex != -1)
	{
//transform end points back

//Delete all old cross sections
	int ct = BoneData[ModeBoneIndex].CrossSectionList.Count();

	CopyBuffer.E1 = CopyBuffer.E1;
	CopyBuffer.E2 = CopyBuffer.E2;

	BoneData[ModeBoneIndex].FalloffType = CopyBuffer.falloffType;

	if (CopyBuffer.absolute)
		BoneData[ModeBoneIndex].flags |= BONE_ABSOLUTE_FLAG;
	else BoneData[ModeBoneIndex].flags &= ~BONE_ABSOLUTE_FLAG;

	if (CopyBuffer.showEnvelope)
		BoneData[ModeBoneIndex].flags |= BONE_DRAW_ENVELOPE_FLAG;
	else BoneData[ModeBoneIndex].flags &= ~BONE_DRAW_ENVELOPE_FLAG;


	UpdatePropInterface();

//	BoneData[ModeBoneIndex].EndPoint1Control->SetValue(0,&CopyBuffer.E1,TRUE,CTRL_ABSOLUTE);
//	BoneData[ModeBoneIndex].EndPoint2Control->SetValue(0,&CopyBuffer.E2,TRUE,CTRL_ABSOLUTE);
	theHold.Suspend();
	for (int i =(ct-1); i >= 0 ; i--)
		RemoveCrossSection(ModeBoneIndex, i);
	for (i =0; i < CopyBuffer.CList.Count() ; i++)
		{
		AddCrossSection(ModeBoneIndex,CopyBuffer.CList[i].u,CopyBuffer.CList[i].inner,CopyBuffer.CList[i].outer);
		}
	theHold.Resume();

	}
}



void BonesDefMod::AddCrossSection(int BoneIndex, float u, float inner, float outer)

{
class CrossSectionClass t;
int index = -1;
t. u = u;
//t.Inner = inner;
//t.Outer = outer;


int CrossInnerRefID = GetOpenID();
int CrossOuterRefID = GetOpenID();
t.RefInnerID = CrossInnerRefID;
t.RefOuterID  = CrossOuterRefID;
t.InnerControl = NULL;
t.OuterControl = NULL;


if ( (BoneData[BoneIndex].CrossSectionList.Count() == 0) || (BoneData[BoneIndex].CrossSectionList.Count() == 1)) 
	{
	index = BoneData[BoneIndex].CrossSectionList.Count();
	BoneData[BoneIndex].CrossSectionList.Append(1,&t,1);	
	}
else
	{
	for (int i = 0; i < BoneData[BoneIndex].CrossSectionList.Count();i++)
		{
		if (BoneData[BoneIndex].CrossSectionList[i].u>=u)
			{
			index =i;
			i = BoneData[BoneIndex].CrossSectionList.Count();
			}
		}
	if (index ==-1)
		{
		BoneData[BoneIndex].CrossSectionList.Append(1,&t);	
		index = BoneData[BoneIndex].CrossSectionList.Count()-1;
		}
	else BoneData[BoneIndex].CrossSectionList.Insert(index,1,&t);	
	}
//create 2 float controls
MakeRefByID(FOREVER,CrossInnerRefID,NewDefaultFloatController());
MakeRefByID(FOREVER,CrossOuterRefID,NewDefaultFloatController());

BoneData[BoneIndex].CrossSectionList[index].InnerControl->SetValue(0,&inner,TRUE,CTRL_ABSOLUTE);
BoneData[BoneIndex].CrossSectionList[index].OuterControl->SetValue(0,&outer,TRUE,CTRL_ABSOLUTE);


/*
float ti,to;
Interval v;
BoneData[BoneIndex].CrossSectionList[index].InnerControl->GetValue(0,&ti,v);
BoneData[BoneIndex].CrossSectionList[index].OuterControl->GetValue(0,&to,v);
*/



}

void BonesDefMod::AddCrossSection(float u)

{
//get current selected bone
// compute the falloff at the u of this bone
class CrossSectionClass t;

float ui,uo,li,lo;
float u_dist;
int index = -1;
t.u = u;
for (int i = 0; i < BoneData[ModeBoneIndex].CrossSectionList.Count();i++)
	{
	if (BoneData[ModeBoneIndex].CrossSectionList[i].u>=u)
		{
		index =i;
		i = BoneData[ModeBoneIndex].CrossSectionList.Count();
		}
	}

int lowerbound, upperbound;
lowerbound = index-1;
upperbound = index;
Interval v;
BoneData[ModeBoneIndex].CrossSectionList[lowerbound].InnerControl->GetValue(0,&li,v);
BoneData[ModeBoneIndex].CrossSectionList[lowerbound].OuterControl->GetValue(0,&lo,v);
BoneData[ModeBoneIndex].CrossSectionList[upperbound].InnerControl->GetValue(0,&ui,v);
BoneData[ModeBoneIndex].CrossSectionList[upperbound].OuterControl->GetValue(0,&uo,v);

//li = BoneData[ModeBoneIndex].CrossSectionList[lowerbound].Inner;
//lo = BoneData[ModeBoneIndex].CrossSectionList[lowerbound].Outer;
//ui = BoneData[ModeBoneIndex].CrossSectionList[upperbound].Inner;
//uo = BoneData[ModeBoneIndex].CrossSectionList[upperbound].Outer;
u_dist = BoneData[ModeBoneIndex].CrossSectionList[upperbound].u - BoneData[ModeBoneIndex].CrossSectionList[lowerbound].u;
u = (u-BoneData[ModeBoneIndex].CrossSectionList[lowerbound].u) /u_dist;
float Inner = (ui-li) * u + li;
float Outer = (uo-lo) * u + lo;

int CrossInnerRefID = GetOpenID();
int CrossOuterRefID = GetOpenID();
t.RefInnerID = CrossInnerRefID;
t.RefOuterID  = CrossOuterRefID;
t.InnerControl = NULL;
t.OuterControl = NULL;
//create 2 float controls
BoneData[ModeBoneIndex].CrossSectionList.Insert(index,1,&t);



MakeRefByID(FOREVER,CrossInnerRefID,NewDefaultFloatController());
MakeRefByID(FOREVER,CrossOuterRefID,NewDefaultFloatController());

BoneData[ModeBoneIndex].CrossSectionList[index].InnerControl->SetValue(0,&Inner,TRUE,CTRL_ABSOLUTE);
BoneData[ModeBoneIndex].CrossSectionList[index].OuterControl->SetValue(0,&Outer,TRUE,CTRL_ABSOLUTE);

if (index <= ModeBoneEnvelopeIndex)
	{
	ModeBoneEnvelopeIndex++;
	if (ModeBoneEnvelopeIndex >= BoneData[ModeBoneIndex].CrossSectionList.Count())
		ModeBoneEnvelopeIndex = BoneData[ModeBoneIndex].CrossSectionList.Count()-1;
	}
/*
int c = sel.Count();
sel.SetCount(c+12);
*/
//append bone to this list.

}


void BonesDefMod::GetCrossSectionRanges(float &inner, float &outer, int BoneID, int CrossID)

{

Interval v;
//if ( (BoneID < BoneData.Count()) && 
//	 (CrossID < BoneData[BoneID].CrossSectionList.Count()) 
  //  )
	{
	BoneData[BoneID].CrossSectionList[CrossID].InnerControl->GetValue(0,&inner,v);
	BoneData[BoneID].CrossSectionList[CrossID].OuterControl->GetValue(0,&outer,v);
	}

}

float BonesDefMod::GetU(ViewExp *vpt,Point3 a, Point3 b, IPoint2 p)
{
//mouse spot
//ModContextList mcList;		
INodeTab nodes;
Point2 fp = Point2((float)p.x, (float)p.y);
float u;
if ( !ip ) return 0.0f;

//ip->GetModContexts(mcList,nodes);
//for ( int i = 0; i < mcList.Count(); i++ ) 
	{
	// Find the location on the segment where the user clicked
//	INode *inode = nodes[i];
	GraphicsWindow *gw = vpt->getGW();
	gw->setTransform(Matrix3(1));
	Point2 spa = ProjectPointF(gw, a);
	Point2 spb = ProjectPointF(gw, b);
	u = Length(spa-fp)/Length(spa-spb);
	}

return u;


}





void BonesDefMod::GetEndPoints(BoneModData *bmd, TimeValue t, Point3 &l1, Point3 &l2, int BoneID)
{

ObjectState os;
ShapeObject *pathOb = NULL;
if ((BoneData[BoneID].flags & BONE_SPLINE_FLAG) && (BoneData[BoneID].Node != NULL) )
	{
	ObjectState os = BoneData[BoneID].Node->EvalWorldState(t);
	pathOb = (ShapeObject*)os.obj;
	l1  = pathOb->InterpPiece3D(t, 0,0 ,0.0f ) * Inverse(BoneData[BoneID].tm);
	l2  = pathOb->InterpPiece3D(t, 0,0 ,1.0f ) * Inverse(BoneData[BoneID].tm);
	}
else
	{
	l1 = bmd->tempTableL1[BoneID];
	l2 = bmd->tempTableL2[BoneID];
/*
	Interval v;
	BoneData[BoneID].EndPoint1Control->GetValue(t,&l1,v);
	BoneData[BoneID].EndPoint2Control->GetValue(t,&l2,v);
	
	l1 = l1 * Inverse(BoneData[BoneID].tm) * Inverse(bmd->BaseTM);
	l2 = l2 * Inverse(BoneData[BoneID].tm) * Inverse(bmd->BaseTM);
*/
	}

}



void BonesDefMod::GetEndPointsLocal(BoneModData *bmd, TimeValue t, Point3 &l1, Point3 &l2, int BoneID)
{

//ObjectState os;
if ((BoneData[BoneID].flags & BONE_SPLINE_FLAG) && (BoneData[BoneID].Node != NULL) )
	{
	ShapeObject *pathOb = NULL;
	ObjectState os = BoneData[BoneID].Node->EvalWorldState(t);
	pathOb = (ShapeObject*)os.obj;
	l1  = pathOb->InterpPiece3D(t, 0,0 ,0.0f );
	l2  = pathOb->InterpPiece3D(t, 0,0 ,1.0f );
	}
else
	{

//	Interval v;
//	BoneData[BoneID].EndPoint1Control->GetValue(t,&l1,v);
//	BoneData[BoneID].EndPoint2Control->GetValue(t,&l2,v);
	l1 = bmd->tempTableL1ObjectSpace[BoneID];
	l2 = bmd->tempTableL2ObjectSpace[BoneID];
	
	}

}



float BonesDefMod::ModifyU(TimeValue t, float LineU,  int BoneID, int sid)

{
ObjectState os;
ShapeObject *pathOb = NULL;
if (BoneData[BoneID].flags & BONE_SPLINE_FLAG)
	{
	os = BoneData[BoneID].Node->EvalWorldState(t);
	pathOb = (ShapeObject*)os.obj;
	int SubCount = pathOb->NumberOfPieces(t,0);
	float start,inc;
	inc = 1.0f/(float)SubCount;
	start = inc * sid;
	LineU = start + (LineU * inc);
	}
return LineU;


}

float BonesDefMod::ComputeInfluence(TimeValue t, float Influence, float LineU, int BoneID, int StartCross, int EndCross, int sid)

{
float Inner, Outer;
float LInner, LOuter;

GetCrossSectionRanges(Inner, Outer, BoneID, StartCross);
GetCrossSectionRanges(LInner, LOuter, BoneID, EndCross);


LineU = ModifyU(t, LineU,BoneID,sid);
/*
if (BoneData[BoneID].flags & BONE_SPLINE_FLAG)
	{
	os = BoneData[BoneID].Node->EvalWorldState(ip->GetTime());
	pathOb = (ShapeObject*)os.obj;
	int SubCount = pathOb->NumberOfPieces(ip->GetTime(),0);
	float start,inc;
	inc = 1.0f/(float)SubCount;
	start = inc * sid;
	LineU = start + (LineU * inc);
	}
*/
float udist = BoneData[BoneID].CrossSectionList[EndCross].u - BoneData[BoneID].CrossSectionList[StartCross].u;
LineU = LineU - BoneData[BoneID].CrossSectionList[StartCross].u;
float per = LineU/udist;


Inner = Inner + (LInner - Inner) * per;
Outer = Outer + (LOuter - Outer) * per;

//float Influence = 0.0f;

//inside inner envelope
if (Influence <= Inner)
	{
	Influence = 1.0f;
	}
// is it oustide  outer
else if (Influence <= Outer)
	{
	float r1,r2;
	r1 = Outer - Inner;
	r2 = Influence - Inner;
	Influence = 1.0f - (r2/r1);
	ComputeFalloff(Influence,BoneData[BoneID].FalloffType);
	}
//outside puter envelope
	else 
	{
	Influence = 0.0f;
	}
return Influence;

}

int BonesDefMod::ConvertSelectedBoneToListID(int fsel)
{
int sel = 0;
for (int i= 0; i < fsel; i++)
	{
	if (BoneData[i].Node != NULL) sel++;
	}
return sel;
}

int BonesDefMod::ConvertSelectedListToBoneID(int fsel)
{
int sel = -1;
int ct = 0;
while ((sel!=fsel) && (ct<BoneData.Count()))
	{
	if (BoneData[ct].Node != NULL) sel++;
	ct++;
	}
return ct-1;
}

void BonesDefMod::RemoveBone()

{
int fsel;

fsel = SendMessage(GetDlgItem(hParam,IDC_LIST1),
			LB_GETCURSEL ,0,0);
int sel = ConvertSelectedListToBoneID(fsel);

if (sel>=0)
	{
	SendMessage(GetDlgItem(hParam,IDC_LIST1),
					LB_DELETESTRING  ,(WPARAM) fsel,0);

//	if (theHold.Holding() ) theHold.Put(new DeleteBoneRestore(this,sel));


//nuke reference

//nuke cross sections
	int ct = BoneData[sel].CrossSectionList.Count();
	for (int i =(ct-1); i >= 0 ; i--)
		RemoveCrossSectionNoNotify(sel, i);

//nuke end points

	DeleteReference(BoneData[sel].RefEndPt1ID);
	BoneData[sel].EndPoint1Control = NULL;
	DeleteReference(BoneData[sel].RefEndPt2ID);
	BoneData[sel].EndPoint2Control = NULL;

	RefTable[BoneData[sel].RefEndPt1ID-2] = 0;
	RefTable[BoneData[sel].RefEndPt2ID-2] = 0;
//	BoneData[sel].Node = NULL;

	DeleteReference(BoneData[sel].BoneRefID);
	RefTable[BoneData[sel].BoneRefID-2] = 0;
	BoneData[sel].Node = NULL;
	BoneData[sel].flags= BONE_DEAD_FLAG;

// bug fix 207093 9/8/99	watje
	BoneData[sel].RefEndPt1ID = -1;
	BoneData[sel].RefEndPt2ID = -1;
	BoneData[sel].BoneRefID = -1;

	
	int NodeCount = BoneData.Count();


	ModeBoneIndex = sel;
	ModeBoneEndPoint = -1;
	ModeBoneEnvelopeIndex = -1;
	ModeBoneEnvelopeSubType = -1;
	if (BoneData[ModeBoneIndex].flags & BONE_LOCK_FLAG)
		pblock_param->SetValue(PB_LOCK_BONE,0,1);
	else
		pblock_param->SetValue(PB_LOCK_BONE,0,0);
	if (BoneData[ModeBoneIndex].flags & BONE_ABSOLUTE_FLAG)
		pblock_param->SetValue(PB_ABSOLUTE_INFLUENCE,0,1);
	else
		pblock_param->SetValue(PB_ABSOLUTE_INFLUENCE,0,0);

//	if (sel != 0)
//		sel--;

	int fsel = ConvertSelectedBoneToListID(sel);

// bug fix 206160 9/8/99	watje
	BOOL noBonesLeft = FALSE;
	if (SendMessage(GetDlgItem(hParam,IDC_LIST1),
				LB_SETCURSEL ,fsel,0) == LB_ERR)
		{
		if (fsel != 0) 
			fsel--;
// bug fix 206160 9/8/99	watje
		else noBonesLeft = TRUE;
		SendMessage(GetDlgItem(hParam,IDC_LIST1),
				LB_SETCURSEL ,fsel,0);
		}
// bug fix 206160 9/8/99	watje
	if (noBonesLeft)
		fsel = -1;
	else fsel = ConvertSelectedListToBoneID(fsel);
	ModeBoneIndex = fsel;
	ModeBoneEndPoint = -1;
	ModeBoneEnvelopeIndex = -1;
	ModeBoneEnvelopeSubType = -1;
	LastSelected = fsel;
	UpdatePropInterface();
	

	BoneMoved = TRUE;
//watje 9-7-99  198721 
	Reevaluate(TRUE);
	cacheValid = FALSE;
	NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
	}
int bct = 0;
for (int i =0; i < BoneData.Count(); i ++)
	{
	if (!(BoneData[i].flags &  BONE_DEAD_FLAG)) bct++;
	}


//if  (BoneData.Count() ==0)
if  (bct == 0)
	{
	DisableButtons();
	}

//for (int k = 0;  k < RefTable.Count(); k++)
//	{
//	DebugPrint(" id %d  refid %d\n",k,RefTable[k]);
//	}
}

void BonesDefMod::RemoveBone(int bid)

{
int sel;
//sel = SendMessage(GetDlgItem(hParams,IDC_LIST1),
//			LB_GETCURSEL ,0,0);
sel = bid;



int fsel = ConvertSelectedBoneToListID(sel);


if (sel>=0)
	{
	SendMessage(GetDlgItem(hParam,IDC_LIST1),
					LB_DELETESTRING  ,(WPARAM) fsel,0);


//nuke reference
//nuke cross sections
	BoneDataClass *b = &BoneData[sel];

	if (theHold.Holding() ) theHold.Put(new DeleteBoneRestore(this,sel));


	int ct = BoneData[sel].CrossSectionList.Count();
	for (int i =(ct-1); i >= 0 ; i--)
		RemoveCrossSectionNoNotify(sel, i);

//nuke end points
	DeleteReference(BoneData[sel].RefEndPt1ID);
	BoneData[sel].EndPoint1Control = NULL;
	DeleteReference(BoneData[sel].RefEndPt2ID);
	BoneData[sel].EndPoint2Control = NULL;

	RefTable[BoneData[sel].RefEndPt1ID-2] = 0;
	RefTable[BoneData[sel].RefEndPt2ID-2] = 0;

	DeleteReference(BoneData[sel].BoneRefID);
	RefTable[BoneData[sel].BoneRefID-2] = 0;
	BoneData[sel].Node = NULL;
	BoneData[sel].flags= BONE_DEAD_FLAG;

// bug fix 207093 9/8/99	watje
	BoneData[sel].RefEndPt1ID = -1;
	BoneData[sel].RefEndPt2ID = -1;
	BoneData[sel].BoneRefID = -1;

	
	
	int NodeCount = BoneData.Count();
	for (int j=sel;j<(BoneData.Count()-1);j++)
		{
//		ReplaceReference(j+2,BoneData[j+1].Node);
//now copy the data down also 
//		mod->BoneData[j].CrossSectionList.ZeroCount();
//		BoneData[j].CrossSectionList=BoneData[j+1].CrossSectionList;

//fix this need to copy contolers around 
//		BoneData[j].l1 = BoneData[j+1].l1;
//		BoneData[j].l2 = BoneData[j+1].l2;
//		BoneData[j].flags = BoneData[j+1].flags;
		}

//	DeleteReference(NodeCount-1+2);

//	BoneData[NodeCount-1].Node = NULL;
//	BoneData[NodeCount-1].CrossSectionList.ZeroCount();


	ModeBoneEndPoint = -1;
	ModeBoneEnvelopeIndex = -1;
	ModeBoneEnvelopeSubType = -1;
	if (BoneData[sel].flags & BONE_LOCK_FLAG)
		pblock_param->SetValue(PB_LOCK_BONE,0,1);
	else
		pblock_param->SetValue(PB_LOCK_BONE,0,0);
	if (BoneData[sel].flags & BONE_ABSOLUTE_FLAG)
		pblock_param->SetValue(PB_ABSOLUTE_INFLUENCE,0,1);
	else
		pblock_param->SetValue(PB_ABSOLUTE_INFLUENCE,0,0);

//	if (sel != 0)
//		sel--;
	ModeBoneIndex = sel;
	int fsel = ConvertSelectedBoneToListID(sel);
	SendMessage(GetDlgItem(hParam,IDC_LIST1),
				LB_SETCURSEL ,fsel,0);


//this is a complete hack to remove the null node off the end of the linked list
//since there are no deletion tools in the template
/*
	BoneDataClassList TempBoneData;

	TempBoneData.New();
	for (i = 0; i<BoneData.Count(); i++)
		{
		if (BoneData[i].Node != NULL) 
			{
			TempBoneData.Append(BoneData[i]);
			}
		}
	BoneData.New();
	for (i = 0; i<TempBoneData.Count(); i++)
		{
		BoneData.Append(TempBoneData[i]);
		}


	TempBoneData.New();
*/
	BoneMoved = TRUE;
//watje 9-7-99  198721 
	Reevaluate(TRUE);
	NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
	}
int bct = 0;
for (int i =0; i < BoneData.Count(); i ++)
	{
	if (!(BoneData[i].flags &  BONE_DEAD_FLAG)) bct++;
	}

//if  (BoneData.Count() ==0)

if  (bct == 0)
	{
	DisableButtons();
	}


/*
	{
	SendMessage(GetDlgItem(hParams,IDC_LIST1),
					LB_DELETESTRING  ,(WPARAM) sel,0);


//nuke reference

	int NodeCount = BoneData.Count();
	for (int j=sel;j<(BoneData.Count()-1);j++)
		{
		ReplaceReference(j+2,BoneData[j+1].Node);
//now copy the data down also 
//		mod->BoneData[j].CrossSectionList.ZeroCount();
		BoneData[j].CrossSectionList=BoneData[j+1].CrossSectionList;

//fix this need to copy contolers around 
//		BoneData[j].l1 = BoneData[j+1].l1;
//		BoneData[j].l2 = BoneData[j+1].l2;
		BoneData[j].flags = BoneData[j+1].flags;
		}
	DeleteReference(NodeCount-1+2);

	BoneData[NodeCount-1].Node = NULL;
	BoneData[NodeCount-1].CrossSectionList.ZeroCount();

	if (sel != 0)
		sel--;

	
	SendMessage(GetDlgItem(hParams,IDC_LIST1),
				LB_SETCURSEL ,sel,0);

	ModeBoneIndex = sel;
	ModeBoneEndPoint = -1;
	ModeBoneEnvelopeIndex = -1;
	ModeBoneEnvelopeSubType = -1;
	if (BoneData[ModeBoneIndex].flags & BONE_LOCK_FLAG)
		pblock->SetValue(PB_LOCK_BONE,0,1);
	else
		pblock->SetValue(PB_LOCK_BONE,0,0);
	if (BoneData[ModeBoneIndex].flags & BONE_ABSOLUTE_FLAG)
		pblock->SetValue(PB_ABSOLUTE_INFLUENCE,0,1);
	else
		pblock->SetValue(PB_ABSOLUTE_INFLUENCE,0,0);



//this is a complete hack to remove the null node off the end of the linked list
//since there are no deletion tools in the template

	BoneDataClassList TempBoneData;

	TempBoneData.New();
	for (int i = 0; i<BoneData.Count(); i++)
		{
		if (BoneData[i].Node != NULL) 
			{
			TempBoneData.Append(BoneData[i]);
			}
		}
	BoneData.New();
	for (i = 0; i<TempBoneData.Count(); i++)
		{
		BoneData.Append(TempBoneData[i]);
		}


	TempBoneData.New();

	BoneMoved = TRUE;
	reevaluate = TRUE;
	NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
	}
*/
}


void BonesDefMod::RemoveCrossSection()

{

if ( (ModeBoneEnvelopeIndex <=0)  || (ModeBoneIndex < 0)  ||
	 (ModeBoneEnvelopeIndex >= (BoneData[ModeBoneIndex].CrossSectionList.Count()-1))
	 )
	return;
BoneDataClass b = BoneData[ModeBoneIndex];

DeleteReference(BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].RefInnerID);
BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].InnerControl = NULL;
DeleteReference(BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].RefOuterID);
BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].OuterControl = NULL;

RefTable[BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].RefInnerID-2] = 0;
RefTable[BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].RefOuterID-2] = 0;

BoneData[ModeBoneIndex].CrossSectionList.Delete(ModeBoneEnvelopeIndex,1);

//watje 9-7-99  198721 
Reevaluate(TRUE);
NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);

}


void BonesDefMod::RemoveCrossSection(int bid, int eid)

{
/*
if ( (ModeBoneEnvelopeIndex <=0)  || (ModeBoneIndex < 0)  ||
	 (ModeBoneEnvelopeIndex >= (BoneData[ModeBoneIndex].CrossSectionList.Count()-1))
	 )
	return;
	*/


DeleteReference(BoneData[bid].CrossSectionList[eid].RefInnerID);
BoneData[bid].CrossSectionList[eid].InnerControl = NULL;
DeleteReference(BoneData[bid].CrossSectionList[eid].RefOuterID);
BoneData[bid].CrossSectionList[eid].OuterControl = NULL;

RefTable[BoneData[bid].CrossSectionList[eid].RefInnerID-2] = 0;
RefTable[BoneData[bid].CrossSectionList[eid].RefOuterID-2] = 0;

BoneData[bid].CrossSectionList.Delete(eid,1);

//watje 9-7-99  198721 
Reevaluate(TRUE);
NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);

}


void BonesDefMod::RemoveCrossSectionNoNotify(int bid, int eid)

{


DeleteReference(BoneData[bid].CrossSectionList[eid].RefInnerID);
BoneData[bid].CrossSectionList[eid].InnerControl = NULL;
DeleteReference(BoneData[bid].CrossSectionList[eid].RefOuterID);
BoneData[bid].CrossSectionList[eid].OuterControl = NULL;

RefTable[BoneData[bid].CrossSectionList[eid].RefInnerID-2] = 0;
RefTable[BoneData[bid].CrossSectionList[eid].RefOuterID-2] = 0;

BoneData[bid].CrossSectionList.Delete(eid,1);

//watje 9-7-99  198721 
Reevaluate(TRUE);

}









static int outputIDs[] = {IDC_RADIO1,IDC_RADIO2,IDC_RADIO3,IDC_RADIO4,IDC_RADIO5,IDC_RADIO6};

//
// Parameters


#define PARAMDESC_LENGTH	18

static ParamUIDesc descParam[18] = {
	// Effect
	ParamUIDesc(
		PB_EFFECT,
		EDITTYPE_FLOAT,
		IDC_EFFECT,IDC_EFFECTSPIN,
		0.0f,1.0f,
		SPIN_AUTOSCALE),


	// Lock Bone
   ParamUIDesc(PB_LOCK_BONE,TYPE_SINGLECHEKBOX,IDC_LOCK_BONE_CHECK),

   // Absolute Influence
   ParamUIDesc(PB_ABSOLUTE_INFLUENCE,TYPE_SINGLECHEKBOX,IDC_ABSOLUTE_INFLUENCE_CHECK),

   // Filter Vertices
   ParamUIDesc(PB_FILTER_VERTICES,TYPE_SINGLECHEKBOX,IDC_FILTER_VERTICES_CHECK),

	// Filter Bones
   ParamUIDesc(PB_FILTER_BONES,TYPE_SINGLECHEKBOX,IDC_FILTER_BONES_CHECK),

	// Filter Envelopes
   ParamUIDesc(PB_FILTER_ENVELOPES,TYPE_SINGLECHEKBOX,IDC_FILTER_ENVELOPES_CHECK),

   // draw Envelopes
   ParamUIDesc(PB_DRAW_ENVELOPES,TYPE_SINGLECHEKBOX,IDC_DRAWALL_ENVELOPES_CHECK),

   // draw Vertices
   ParamUIDesc(PB_DRAW_VERTICES,TYPE_SINGLECHEKBOX,IDC_DRAW_VERTICES_CHECK),

	// Rereference frame
	ParamUIDesc(
		PB_REF_FRAME,
		EDITTYPE_INT,
		IDC_REF_FRAME,IDC_REF_FRAME_SPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),


	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_FLOAT,
		IDC_SRADIUS,IDC_SRADIUSSPIN,
		0.0f,5000.0f,
		SPIN_AUTOSCALE),

   // Project Through
   ParamUIDesc(PB_PROJECT_THROUGH,TYPE_SINGLECHEKBOX,IDC_PROJECT_THROUGH_CHECK),
   // Brush Falloff
   ParamUIDesc(PB_FALLOFF,TYPE_SINGLECHEKBOX,IDC_FALLOFF_CHECK),
//curve falloff
	ParamUIDesc(PB_BONE_FALLOFF,TYPE_RADIO,outputIDs,6),

// Feather
	ParamUIDesc(
		PB_FEATHER,
		EDITTYPE_FLOAT,
		IDC_FEATHER,IDC_FEATHERSPIN,
		0.0f,1.0f,
		SPIN_AUTOSCALE),

//Draw Envelope											
   ParamUIDesc(PB_DRAW_BONE_ENVELOPE,TYPE_SINGLECHEKBOX,IDC_DISPLAY_ENVELOPE_CHECK),

// Envelope Radius
	ParamUIDesc(
		PB_ERADIUS,
		EDITTYPE_FLOAT,
		IDC_ERADIUS,IDC_ERADIUSSPIN,
		0.0f,1000000.0f,
		SPIN_AUTOSCALE),

//Always deform											
   ParamUIDesc(PB_ALWAYS_DEFORM,TYPE_SINGLECHEKBOX,IDC_ALWAYSDEFORM_CHECK),


// Paint str
	ParamUIDesc(
		PB_PAINTSTR,
		EDITTYPE_FLOAT,
		IDC_PAINT_STR2,IDC_PAINT_STR_SPIN2,
		0.0f,1.0f,
		SPIN_AUTOSCALE)


	};

static ParamBlockDescID descVer0[17] = {
	{ TYPE_FLOAT, NULL, FALSE,  0 },		// Effect	
	{ TYPE_INT,   NULL, FALSE, 1 },		// Lock Bone
	{ TYPE_INT,   NULL, FALSE, 2 },		// Absolute Influence
	{ TYPE_INT,   NULL, FALSE, 3 },		// Filter Vertices
	{ TYPE_INT,   NULL, FALSE, 4 },		// Filter Bones
	{ TYPE_INT,   NULL, FALSE, 5 },		// Filter Envelopes
	{ TYPE_INT,   NULL, FALSE, 6 },		// Draw All envelopes
	{ TYPE_INT,   NULL, FALSE, 7 },		// Draw vertice
	{ TYPE_INT,   NULL, FALSE, 8 },		// Ref Frame
	{ TYPE_FLOAT, NULL, FALSE,  9},		// Radius	
	{ TYPE_INT, NULL, FALSE,  10},		// Project through	
	{ TYPE_INT, NULL, FALSE,  11},		// falloff	
	{ TYPE_INT, NULL, FALSE,  12},		// bone falloff	
	{ TYPE_FLOAT, NULL, FALSE,  13},		// feather	
	{ TYPE_INT, NULL, FALSE,  14},		// Draw bone envelope	
	{ TYPE_FLOAT, NULL, FALSE,  15},	// envelope raduis	
	{ TYPE_INT, NULL, FALSE,  16}		// always deform
	};


static ParamBlockDescID descVer1[18] = {
	{ TYPE_FLOAT, NULL, FALSE,  0 },		// Effect	
	{ TYPE_INT,   NULL, FALSE, 1 },		// Lock Bone
	{ TYPE_INT,   NULL, FALSE, 2 },		// Absolute Influence
	{ TYPE_INT,   NULL, FALSE, 3 },		// Filter Vertices
	{ TYPE_INT,   NULL, FALSE, 4 },		// Filter Bones
	{ TYPE_INT,   NULL, FALSE, 5 },		// Filter Envelopes
	{ TYPE_INT,   NULL, FALSE, 6 },		// Draw All envelopes
	{ TYPE_INT,   NULL, FALSE, 7 },		// Draw vertice
	{ TYPE_INT,   NULL, FALSE, 8 },		// Ref Frame
	{ TYPE_FLOAT, NULL, FALSE,  9},		// Radius	
	{ TYPE_INT, NULL, FALSE,  10},		// Project through	
	{ TYPE_INT, NULL, FALSE,  11},		// falloff	
	{ TYPE_INT, NULL, FALSE,  12},		// bone falloff	
	{ TYPE_FLOAT, NULL, FALSE,  13},		// feather	
	{ TYPE_INT, NULL, FALSE,  14},		// Draw bone envelope	
	{ TYPE_FLOAT, NULL, FALSE,  15},	// envelope raduis	
	{ TYPE_INT, NULL, FALSE,  16},		// always deform
	{ TYPE_FLOAT, NULL, FALSE,  17}	// paint str	
	};

#define PBLOCK_LENGTH	18

#define CURRENT_VERSION	1


static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,17,0)
	};
#define NUM_OLDVERSIONS	1

// Current version
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);


//--- Affect region mod methods -------------------------------

BonesDefMod::BonesDefMod() 
	{

	MakeRefByID(
		FOREVER, PBLOCK_PARAM_REF, 
		CreateParameterBlock(
			descVer1, PBLOCK_LENGTH, CURRENT_VERSION));


	
	pblock_param->SetValue(PB_EFFECT,0,0.0f);
	pblock_param->SetValue(PB_ERADIUS,0,10.0f);

	pblock_param->SetValue(PB_FILTER_VERTICES,0,0);
	pblock_param->SetValue(PB_FILTER_BONES,0,1);
	pblock_param->SetValue(PB_FILTER_ENVELOPES,0,1);



	pblock_param->SetValue(PB_DRAW_ENVELOPES,0,0);
	pblock_param->SetValue(PB_DRAW_VERTICES,0,1);



	pblock_param->SetValue(PB_PROJECT_THROUGH,0,1);
	pblock_param->SetValue(PB_FALLOFF,0,1);
	pblock_param->SetValue(PB_FEATHER,0,0.7f);
	pblock_param->SetValue(PB_RADIUS,0,24.0f);

	pblock_param->SetValue(PB_PAINTSTR,0,0.1f);

	pblock_param->SetValue(PB_REF_FRAME,0,0);
	pblock_param->SetValue(PB_ALWAYS_DEFORM,0,1);

	RefTable.ZeroCount();

//	NodeCount = 0;
//	effect = -1.0f;
	BoneData.New();
	//watje 9-7-99  198721 
	Reevaluate(FALSE);
	reset = FALSE;
	BoneMoved = FALSE;
	p1Temp = NULL;
	Point3 p(0.0f,0.0f,0.0f);
	MakeRefByID(FOREVER,POINT1_REF,NewDefaultPoint3Controller()); 
	p1Temp->SetValue(0,p,TRUE,CTRL_ABSOLUTE);
	ModeEdit = 0;
	ModeBoneIndex = -1;
	ModeBoneEndPoint  = -1;
	ModeBoneEnvelopeIndex = -1;
	FilterVertices = 0;
	FilterBones = 0;
	FilterEnvelopes = 0;
	DrawEnvelopes = 0;
	paintStr  = 0.1f;

//	VertexData = NULL;
//	VertexDataCount = 0;
//	CurrentCachePiece = -1;
//	bmd = NULL;
	cacheValid = FALSE;
	unlockVerts = FALSE;
	OldVertexDataCount = 0;
	unlockBone = FALSE;

	painting = FALSE;
	inPaint = FALSE;
	reloadSplines = FALSE;

	splineChanged = FALSE;
	forceRecomuteBaseNode = FALSE;
	updateP = FALSE;

	bindNode = NULL;
	initialXRefTM.IdentityMatrix();
	xRefTM.IdentityMatrix();

	}


BonesDefMod::~BonesDefMod()
	{
	DeleteAllRefsFromMe();
	p1Temp = NULL;


//	VertexData.ZeroCount();

	for (int i=0;i<BoneData.Count();i++)
        BoneData[i].CrossSectionList.ZeroCount();

	BoneData.New();



	}


void BonesDefMod::BeginEditParams(
		IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	this->ip = ip;
	editMod  = this;

	// Add our sub object type
	TSTR type1(GetString(IDS_RB_BONESDEFPOINTS));
	const TCHAR *ptype[] = {type1};
	ip->RegisterSubObjectTypes(ptype, 1);

	// Create sub object editing modes.
	moveMode    = new MoveModBoxCMode(this,ip);
	CrossSectionMode    = new CreateCrossSectionMode(this,ip);
	PaintMode    = new CreatePaintMode(this,ip);
	
	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);

//	bonesDefDesc.BeginEditParams(ip, this, flags, prev);
//	bones_param_blk.SetUserDlgProc(new MapDlgProc(this));
//	bones_paint_blk.SetUserDlgProc(new PaintDlgProc(this));
//	bones_filter_blk.SetUserDlgProc(new FilterDlgProc(this));
//	bones_advance_blk.SetUserDlgProc(new AdvanceDlgProc(this));

	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGTH,
		pblock_param,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_BONESDEFPARAM),
		GetString(IDS_PW_PARAMETERS),
		0);	

	pmapParam->SetUserDlgProc(new MapDlgProc(this));


	}

void BonesDefMod::EndEditParams(
		IObjParam *ip,ULONG flags,Animatable *next)
	{
	this->ip = NULL;
	editMod  = NULL;

	TimeValue t = ip->GetTime();

	// NOTE: This flag must be cleared before sending the REFMSG_END_EDIT
	ClearAFlag(A_MOD_BEING_EDITED);

	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);

	ip->DeleteMode(moveMode);	
	if (moveMode) delete moveMode;
	moveMode = NULL;	

	ip->DeleteMode(CrossSectionMode);	
	if (CrossSectionMode) delete CrossSectionMode;
	CrossSectionMode = NULL;	

	ip->DeleteMode(PaintMode);	
	if (PaintMode) delete PaintMode;
	PaintMode = NULL;	


	iCrossSectionButton = NULL;
	ReleaseICustButton(iCrossSectionButton);
	iCrossSectionButton = NULL;

	iLock = NULL;
	ReleaseICustButton(iLock);
	iLock = NULL;

	iAbsolute = NULL;
	ReleaseICustButton(iAbsolute);
	iAbsolute = NULL;

	iEnvelope = NULL;
	ReleaseICustButton(iEnvelope);
	iEnvelope = NULL;

	iFalloff = NULL;
	ReleaseICustButton(iFalloff);
	iFalloff = NULL;

	iCopy = NULL;
	ReleaseICustButton(iCopy);
	iCopy = NULL;

	iPaste = NULL;
	ReleaseICustButton(iPaste);
	iPaste = NULL;


	iPaintButton = NULL;
	ReleaseICustButton(iPaintButton);
	iPaintButton = NULL;



	ip->GetRightClickMenuManager()->Unregister(&rMenu);


	ReleaseICustToolbar(iParams);
	iParams = NULL;


	DestroyCPParamMap(pmapParam);
	}

RefTargetHandle BonesDefMod::Clone(RemapDir& remap)
	{
	BonesDefMod *mod = new BonesDefMod();
	mod->ReplaceReference(PBLOCK_PARAM_REF,pblock_param->Clone(remap));
	mod->ReplaceReference(POINT1_REF,p1Temp->Clone(remap));

//copy controls
	mod->RefTable = RefTable;

	for (int i = 0; i<BoneData.Count(); i++)
		{
		BoneDataClass b = BoneData[i];
		b.Node = NULL;
		b.EndPoint1Control= NULL;
		b.EndPoint2Control = NULL;
		for (int j = 0; j < b.CrossSectionList.Count(); j++)
			{
			b.CrossSectionList[j].InnerControl = NULL;
			b.CrossSectionList[j].OuterControl = NULL;
			}
		mod->BoneData.Append(b);
		}


	for (i=0;i < BoneData.Count();i++)
		{
		if (BoneData[i].EndPoint1Control)
			mod->ReplaceReference(BoneData[i].RefEndPt1ID,BoneData[i].EndPoint1Control->Clone(remap));
		if (BoneData[i].EndPoint2Control)
			mod->ReplaceReference(BoneData[i].RefEndPt2ID,BoneData[i].EndPoint2Control->Clone(remap));
		if (BoneData[i].Node)
			mod->ReplaceReference(BoneData[i].BoneRefID,BoneData[i].Node);

		for (int j=0;j < BoneData[i].CrossSectionList.Count();j++)
			{
			if (BoneData[i].CrossSectionList[j].InnerControl)
				mod->ReplaceReference(BoneData[i].CrossSectionList[j].RefInnerID,BoneData[i].CrossSectionList[j].InnerControl->Clone(remap));
			if (BoneData[i].CrossSectionList[j].OuterControl)
				mod->ReplaceReference(BoneData[i].CrossSectionList[j].RefOuterID,BoneData[i].CrossSectionList[j].OuterControl->Clone(remap));
			}

		}


	mod->forceRecomuteBaseNode = TRUE;





//	for (int i = 0; i < ; i++)
//		mod->ReplaceReference(i,);
//copy boneData


	return mod;
	}



void BonesDefMod::SetVertex(BoneModData *bmd,int vertID, int BoneID, float amount)

{
//Tab<int> vsel;

if (BoneData[BoneID].flags & BONE_LOCK_FLAG)
	return;

ObjectState os;
ShapeObject *pathOb = NULL;

if (BoneData[BoneID].flags & BONE_SPLINE_FLAG)
	{
	os = BoneData[BoneID].Node->EvalWorldState(ip->GetTime());
	pathOb = (ShapeObject*)os.obj;
	}

/*
int selcount = bmd->selected.GetSize();

for (int i = 0 ; i <bmd->VertexDataCount;i++)
	{
	if (bmd->selected[i]) vsel.Append(1,&i,1);
	}
*/

float effect,originaleffect;
//for ( i = 0; i < vsel.Count();i++)
	{
	int found = 0;

//	int k = vsel[i];
	int k = vertID;
	for (int j =0; j<bmd->VertexData[k]->d.Count();j++)
		{
		if ( (bmd->VertexData[k]->d[j].Bones == BoneID)&& (!(BoneData[bmd->VertexData[k]->d[j].Bones].flags & BONE_LOCK_FLAG)))

			{
			originaleffect = bmd->VertexData[k]->d[j].Influences;
			bmd->VertexData[k]->d[j].Influences = amount;
			bmd->VertexData[k]->d[j].normalizedInfluences = -1.0f;
			found = 1;
			effect = bmd->VertexData[k]->d[j].Influences;
			j = bmd->VertexData[k]->d.Count();

			}
		}

	if ((found == 0) && (amount > 0.0f))
		{

		VertexInfluenceListClass td;
		td.Bones = BoneID;
		td.Influences = amount;
		td.normalizedInfluences = -1.0f;
//check if spline if so add approriate spline data info also
// find closest spline
		
		if (BoneData[BoneID].flags & BONE_SPLINE_FLAG)
			{
			Interval valid;
			Matrix3 ntm = BoneData[BoneID].Node->GetObjTMBeforeWSM(RefFrame,&valid);
			ntm = bmd->BaseTM * Inverse(ntm);

			float garbage = SplineToPoint(bmd->VertexData[k]->LocalPos,
//										pathOb,
										&BoneData[BoneID].referenceSpline,
			                            td.u,
										td.OPoints,td.Tangents,
										td.SubCurveIds,td.SubSegIds,
										ntm);
//										BoneData[BoneID].tm);
			}


		bmd->VertexData[k]->d.Append(1,&td,1);
		effect = amount;
		originaleffect = 0.0f;
		found = 1;
		}

	if (found == 1)
		{
		int bc = bmd->VertexData[k]->d.Count();

//remove 0 influence bones otherwise they skew the reweigthing
		for (j=0;j<bmd->VertexData[k]->d.Count();j++)
			{
			if (bmd->VertexData[k]->d[j].Influences==0.0f)
				{
				bmd->VertexData[k]->d.Delete(j,1);
				j--;
				}
			}


//rebalance rest
		float remainder = 1.0f - effect;
		originaleffect = 1.0f - originaleffect;
		if (bmd->VertexData[k]->d.Count() > 1)
			{
			for (j=0;j<bmd->VertexData[k]->d.Count();j++)
				{
	
				if (!(BoneData[bmd->VertexData[k]->d[j].Bones].flags & BONE_LOCK_FLAG))
					{
					if (bmd->VertexData[k]->d[j].Bones!=BoneID)
						{
						if (originaleffect == 0.0f)
							 bmd->VertexData[k]->d[j].Influences = remainder/(bmd->VertexData[k]->d.Count()-1.0f);
						else 
							bmd->VertexData[k]->d[j].Influences = bmd->VertexData[k]->d[j].Influences/originaleffect * remainder;
						bmd->VertexData[k]->d[j].normalizedInfluences = -1.0f;

						}
					}
				}
			}

		bmd->VertexData[k]->modified = TRUE;

		}
	}
}



void BonesDefMod::SetVertices(BoneModData *bmd,int vertID, Tab<int> BoneIDList, Tab<float> amountList)

{
//Tab<int> vsel;


ObjectState os;
ShapeObject *pathOb = NULL;



float effect,originaleffect;
int k = vertID;

for (int i = 0; i < amountList.Count();i++)
	{
	int found = 0;

	float amount = amountList[i];
	int BoneID = BoneIDList[i];
	if (BoneData[BoneID].flags & BONE_SPLINE_FLAG)
		{
		os = BoneData[BoneID].Node->EvalWorldState(ip->GetTime());
		pathOb = (ShapeObject*)os.obj;
		}

	for (int j =0; j<bmd->VertexData[k]->d.Count();j++)
		{
		if ( (bmd->VertexData[k]->d[j].Bones == BoneID)&& (!(BoneData[bmd->VertexData[k]->d[j].Bones].flags & BONE_LOCK_FLAG)))

			{
			originaleffect = bmd->VertexData[k]->d[j].Influences;
			bmd->VertexData[k]->d[j].Influences = amount;
			bmd->VertexData[k]->d[j].normalizedInfluences = -1.0f;
			found = 1;
			effect = bmd->VertexData[k]->d[j].Influences;
			j = bmd->VertexData[k]->d.Count();

			}
		}

	if ((found == 0) && (amount > 0.0f))
		{

		VertexInfluenceListClass td;
		td.Bones = BoneID;
		td.Influences = amount;
		td.normalizedInfluences = -1.0f;
//check if spline if so add approriate spline data info also
// find closest spline
		
		if (BoneData[BoneID].flags & BONE_SPLINE_FLAG)
			{
			Interval valid;
			Matrix3 ntm = BoneData[BoneID].Node->GetObjTMBeforeWSM(RefFrame,&valid);
			ntm = bmd->BaseTM * Inverse(ntm);

			float garbage = SplineToPoint(bmd->VertexData[k]->LocalPos,
//										pathOb,
										&BoneData[BoneID].referenceSpline,
			                            td.u,
										td.OPoints,td.Tangents,
										td.SubCurveIds,td.SubSegIds,
										ntm);
//										BoneData[BoneID].tm);
			}


		bmd->VertexData[k]->d.Append(1,&td,1);
		effect = amount;
		originaleffect = 0.0f;
		found = 1;
		}

	if (found == 1)
		{
		int bc = bmd->VertexData[k]->d.Count();

//remove 0 influence bones otherwise they skew the reweigthing
		for (j=0;j<bmd->VertexData[k]->d.Count();j++)
			{
			if (bmd->VertexData[k]->d[j].Influences==0.0f)
				{
				bmd->VertexData[k]->d.Delete(j,1);
				j--;
				}
			}


//rebalance rest

		}
	}
bmd->VertexData[k]->modified = TRUE;
if (bmd->VertexData[k]->d.Count() > 1)
	{
	float totalSum = 0.0f;
	for (int j=0;j<bmd->VertexData[k]->d.Count();j++)
		{
		if (bmd->VertexData[k]->d[j].Influences==0.0f)
			{
			bmd->VertexData[k]->d.Delete(j,1);
			j--;
			}
		}

	for (j=0;j<bmd->VertexData[k]->d.Count();j++)
		totalSum += bmd->VertexData[k]->d[j].Influences;
	for (j=0;j<bmd->VertexData[k]->d.Count();j++)
		{
		 bmd->VertexData[k]->d[j].Influences = bmd->VertexData[k]->d[j].Influences/totalSum;
		}
	}


}



  
void BonesDefMod::SetSelectedVertices(BoneModData *bmd, int BoneID, float amount)

{
Tab<int> vsel;

if (BoneData[BoneID].flags & BONE_LOCK_FLAG)
	return;

ObjectState os;
ShapeObject *pathOb = NULL;

if (BoneData[BoneID].flags & BONE_SPLINE_FLAG)
	{
	os = BoneData[BoneID].Node->EvalWorldState(ip->GetTime());
	pathOb = (ShapeObject*)os.obj;
	}


int selcount = bmd->selected.GetSize();

for (int i = 0 ; i <bmd->VertexDataCount;i++)
	{
	if (bmd->selected[i]) vsel.Append(1,&i,1);
	}

float effect,originaleffect;
for ( i = 0; i < vsel.Count();i++)
	{
	int found = 0;

	int k = vsel[i];
	for (int j =0; j<bmd->VertexData[k]->d.Count();j++)
		{
		if ( (bmd->VertexData[k]->d[j].Bones == BoneID)&& (!(BoneData[bmd->VertexData[k]->d[j].Bones].flags & BONE_LOCK_FLAG)))

			{
			originaleffect = bmd->VertexData[k]->d[j].Influences;
			bmd->VertexData[k]->d[j].Influences = amount;
			bmd->VertexData[k]->d[j].normalizedInfluences = -1.0f;
			found = 1;
			effect = bmd->VertexData[k]->d[j].Influences;
			j = bmd->VertexData[k]->d.Count();

			}
		}

	if ((found == 0) && (amount > 0.0f))
		{

		VertexInfluenceListClass td;
		td.Bones = BoneID;
		td.Influences = amount;
		td.normalizedInfluences = -1.0f;
//check if spline if so add approriate spline data info also
// find closest spline
		
		if (BoneData[BoneID].flags & BONE_SPLINE_FLAG)
			{
			Interval valid;
			Matrix3 ntm = BoneData[BoneID].Node->GetObjTMBeforeWSM(RefFrame,&valid);
			ntm = bmd->BaseTM * Inverse(ntm);

			float garbage = SplineToPoint(bmd->VertexData[k]->LocalPos,
//										pathOb,
										&BoneData[BoneID].referenceSpline,
			                            td.u,
										td.OPoints,td.Tangents,
										td.SubCurveIds,td.SubSegIds,
										ntm);
//										BoneData[BoneID].tm);
			}


		bmd->VertexData[k]->d.Append(1,&td,1);
		effect = amount;
		originaleffect = 0.0f;
		found = 1;
		}

	if (found == 1)
		{
		int bc = bmd->VertexData[k]->d.Count();

//remove 0 influence bones otherwise they skew the reweigthing
		for (j=0;j<bmd->VertexData[k]->d.Count();j++)
			{
			if ((bmd->VertexData[k]->d[j].Influences==0.0f) && (bmd->VertexData[k]->d[j].Bones==BoneID))
//			if (bmd->VertexData[k]->d[j].Influences==0.0f)
				{
				bmd->VertexData[k]->d.Delete(j,1);
				j--;
				}
			}



//rebalance rest
		float remainder = 1.0f - effect;
		originaleffect = 1.0f - originaleffect;
		if (bmd->VertexData[k]->d.Count() > 1)
			{
			for (j=0;j<bmd->VertexData[k]->d.Count();j++)
				{
	
				if (!(BoneData[bmd->VertexData[k]->d[j].Bones].flags & BONE_LOCK_FLAG))
					{
					if (bmd->VertexData[k]->d[j].Bones!=BoneID)
						{
//						if (originaleffect == 0.0f)
							 bmd->VertexData[k]->d[j].Influences = remainder/(bmd->VertexData[k]->d.Count()-1.0f);
//						else 
//							bmd->VertexData[k]->d[j].Influences = bmd->VertexData[k]->d[j].Influences/originaleffect * remainder;
						bmd->VertexData[k]->d[j].normalizedInfluences = -1.0f;

						}
					}
				}
			}

		bmd->VertexData[k]->modified = TRUE;

		}
	}
}


void BonesDefMod::IncrementVertices(BoneModData *bmd, int BoneID, Tab<float> amount, int flip )

{

ObjectState os;
ShapeObject *pathOb = NULL;


if (BoneData[BoneID].flags & BONE_SPLINE_FLAG)
	{
	os = BoneData[BoneID].Node->EvalWorldState(ip->GetTime());
	pathOb = (ShapeObject*)os.obj;
	}

float effect,originaleffect;
int found;
float val;
for ( int i = 0; i < amount.Count();i++)
	{
	if (amount[i] != -10.0f)
		{
		found = 0;
		val = amount[i];
		for (int j =0; j<bmd->VertexData[i]->d.Count();j++)
			{
			if  (bmd->VertexData[i]->d[j].Bones == BoneID) 
				{
				originaleffect = bmd->VertexData[i]->d[j].Influences;
				if (flip)
					{
					bmd->VertexData[i]->d[j].Influences -= amount[i];
					if (bmd->VertexData[i]->d[j].Influences < 0.0f ) bmd->VertexData[i]->d[j].Influences = 0.0f;
					bmd->VertexData[i]->d[j].normalizedInfluences = -1.0f;
					}
				else
					{
					bmd->VertexData[i]->d[j].Influences += amount[i];
					if (bmd->VertexData[i]->d[j].Influences > 1.0f ) bmd->VertexData[i]->d[j].Influences = 1.0f;
					bmd->VertexData[i]->d[j].normalizedInfluences = -1.0f;
					}

				found = 1;
				effect = bmd->VertexData[i]->d[j].Influences;
				j = bmd->VertexData[i]->d.Count();

				}
			}

		if ((!found) && (amount[i] > 0.0f) && !(flip) )
			{
			VertexInfluenceListClass td;
			td.Bones = BoneID;
			td.Influences = amount[i];
			td.normalizedInfluences = -1.0f;
			if (BoneData[BoneID].flags & BONE_SPLINE_FLAG)
				{
				Interval valid;
				Matrix3 ntm = BoneData[BoneID].Node->GetObjTMBeforeWSM(RefFrame,&valid);
				ntm = bmd->BaseTM * Inverse(ntm);

				float garbage = SplineToPoint(bmd->VertexData[i]->LocalPos,
//										pathOb,
										&BoneData[BoneID].referenceSpline,
			                            td.u,
										td.OPoints,td.Tangents,
										td.SubCurveIds,td.SubSegIds,
										ntm);
				}

			bmd->VertexData[i]->d.Append(1,&td,1);
			effect = amount[i];
			originaleffect = 0.0f;
			found = 1;
			}

		if (found==1)
			{

//remove 0 influence bones otherwise they skew the reweigthing
/*	for (j=0;j<bmd->VertexData[i]->d.Count();j++)
				{
				if (bmd->VertexData[i]->d[j].Influences==0.0f)
					{
					bmd->VertexData[i]->d.Delete(j,1);
					}
				}
*/
			float remainder = 1.0f - effect;
			originaleffect = 1.0f - originaleffect;
			if (bmd->VertexData[i]->d.Count() > 1)
				{
				for (j=0;j<bmd->VertexData[i]->d.Count();j++)
					{
					if (bmd->VertexData[i]->d[j].Bones!=BoneID)
						{
//				if (originaleffect == 0.0f)
						 bmd->VertexData[i]->d[j].Influences = remainder/(bmd->VertexData[i]->d.Count()-1.0f);
//						else	 
//							bmd->VertexData[i]->d[j].Influences = bmd->VertexData[i]->d[j].Influences/originaleffect * remainder;
						bmd->VertexData[i]->d[j].normalizedInfluences = -1.0f;
						}
					}
				}

			bmd->VertexData[i]->modified = TRUE;
			}

		}
	}

/*
ObjectState os;
ShapeObject *pathOb = NULL;

if (BoneData[BoneID].flags & BONE_LOCK_FLAG)
	return;

if (BoneData[BoneID].flags & BONE_SPLINE_FLAG)
	{
	os = BoneData[BoneID].Node->EvalWorldState(ip->GetTime());
	pathOb = (ShapeObject*)os.obj;
	}

Tab<int> vsel;
for (int i = 0 ; i <bmd->VertexDataCount;i++)
	{
	if (bmd->selected[i]) vsel.Append(1,&i,1);
	}
float effect,originaleffect;
for ( i = 0; i < vsel.Count();i++)
	{
	int found = 0;

	int k = vsel[i];
	for (int j =0; j<bmd->VertexData[k]->d.Count();j++)
		{
		if ( (bmd->VertexData[k]->d[j].Bones == BoneID) && (!(BoneData[bmd->VertexData[k]->d[j].Bones].flags & BONE_LOCK_FLAG)))
			{
			originaleffect = bmd->VertexData[k]->d[j].Influences;
			if (flip)
				{
				if ((1.0f - amount[i]) < bmd->VertexData[k]->d[j].Influences)
					{
					bmd->VertexData[k]->d[j].Influences = (1.0f-amount[i]);
					bmd->VertexData[k]->d[j].normalizedInfluences = -1.0f;
					}
				}
			else
				{
				if (amount[i] > bmd->VertexData[k]->d[j].Influences)
					{
					bmd->VertexData[k]->d[j].Influences = amount[i];
					bmd->VertexData[k]->d[j].normalizedInfluences = -1.0f;
					}
				}

			found = 1;
			effect = bmd->VertexData[k]->d[j].Influences;
			j = bmd->VertexData[k]->d.Count();

			}
		}

	if (flip)
		{
		}
	else
		{
		if ((!found) && (amount[i] > 0.0f))
			{

			VertexInfluenceListClass td;
			td.Bones = BoneID;
			td.Influences = amount[i];
			td.normalizedInfluences = -1.0f;
			if (BoneData[BoneID].flags & BONE_SPLINE_FLAG)
				{
				Interval valid;
				Matrix3 ntm = BoneData[BoneID].Node->GetObjTMBeforeWSM(RefFrame,&valid);
				ntm = bmd->BaseTM * Inverse(ntm);

				float garbage = SplineToPoint(bmd->VertexData[k]->LocalPos,pathOb,
			                            td.u,
										td.OPoints,td.Tangents,
										td.SubCurveIds,td.SubSegIds,
										ntm);
				}


			bmd->VertexData[k]->d.Append(1,&td,1);
			effect = amount[i];
			originaleffect = 0.0f;
			found = 1;
			}
		}

	if (found==1)
		{

//remove 0 influence bones otherwise they skew the reweigthing
		for (j=0;j<bmd->VertexData[k]->d.Count();j++)
			{
			if (bmd->VertexData[k]->d[j].Influences==0.0f)
				{
				bmd->VertexData[k]->d.Delete(j,1);
				}
			}

		float remainder = 1.0f - effect;
		originaleffect = 1.0f - originaleffect;
		for (j=0;j<bmd->VertexData[k]->d.Count();j++)
			{
			if (!(BoneData[bmd->VertexData[k]->d[j].Bones].flags & BONE_LOCK_FLAG))
				{
				if (bmd->VertexData[k]->d[j].Bones!=BoneID)
					{
					if (originaleffect == 0.0f)
						 bmd->VertexData[k]->d[j].Influences = remainder/(bmd->VertexData[k]->d.Count()-1.0f);
					else 
						bmd->VertexData[k]->d[j].Influences = bmd->VertexData[k]->d[j].Influences/originaleffect * remainder;
					bmd->VertexData[k]->d[j].normalizedInfluences = -1.0f;
					}
				}
			}

		bmd->VertexData[k]->modified = TRUE;
		}

	}
*/
}


class NullView: public View {
	public:
		Point2 ViewToScreen(Point3 p) { return Point2(p.x,p.y); }
		NullView() { worldToView.IdentityMatrix(); screenW=640.0f; screenH = 480.0f; }
	};


//void BonesDefMod::BuildEnvelopes(INode *bnode, INode *mnode, Point3 l1, Point3 l2, float &el1, float &el2)
void BonesDefMod::BuildEnvelopes(INode *bnode, Object *obj, Point3 l1, Point3 l2, float &el1, float &el2)

{

//get mesh
//Object *obj = mnode->EvalWorldState(RefFrame).obj;

//ObjectState os = mnode->EvalWorldState(RefFrame);
//if (os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) return;
if (obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) return;

//BOOL needDel;
//NullView nullView;
//Mesh *mesh = ((GeomObject*)os.obj)->GetRenderMesh(RefFrame,mnode,nullView,needDel);
el1 = BIGFLOAT;
el2 = BIGFLOAT;
//if (!mesh) return;


//tranform x,y,z into object space



Matrix3 tm = bnode->GetObjectTM(RefFrame);

//tm = tm * Inverse(BaseTM);

l1 = l1 * tm;
l2 = l2 * tm;

Point3 p_edge[4];
GetCrossSectionLocal(l1, Normalize(l2-l1), 1.0f, p_edge);

///intersect axis  rays with mesh;
Ray ray;
Point3 norm;
float at;

float dist = 0.0f;
int ct = 0;
	
// See if we hit the object
for (int i=0; i < 4; i++)
	{
	ray.p   = l1 + Normalize(p_edge[i]-l1) * 50000.0f;
	ray.dir = -Normalize(p_edge[i]-l1);
	BOOL hit = FALSE;
	while  (obj->IntersectRay(RefFrame,ray,at,norm)) 
		{
		Point3 tp = ray.dir * (at+0.01f) ;
		ray.p = ray.p + tp;
		hit = TRUE;
		}
	if (hit)
		{
		dist += Length(ray.p - l1);
		ct++;
		}
	}

//if (ct == 0)
//el1 = Length(l2-l1) *.1f;
if (ct!=0) el1 = dist/(float) ct;


dist = 0.0f;
int ct2 = 0;
GetCrossSectionLocal(l2, Normalize(l2-l1), 1.0f, p_edge);
ct2 = 0;	
// See if we hit the object
for (i=0; i < 4; i++)
	{
	ray.p   = l2 + Normalize(p_edge[i]-l2) * 50000.0f;
	ray.dir = -Normalize(p_edge[i]-l2);
	BOOL hit = FALSE;
	while  (obj->IntersectRay(RefFrame,ray,at,norm)) 
		{
		Point3 tp = ray.dir * (at+0.01f) ;
		ray.p = ray.p + tp;
		hit = TRUE;
		}
	if (hit)
		{
		dist += Length(ray.p - l2);
		ct2++;
		}
	}

//if (ct == 0)
//el2 = Length(l2-l1) *.1f;
if (ct2!=0) el2 = dist/(float) ct2;

if ((ct==0) && (ct2!=0))
	el1 = el2;
else if ((ct!=0) && (ct2==0))
	el2 = el1;
else if ((ct==0) && (ct2==0))
	{
	el1 = Length(l2-l1) *.5f;
	el2 = el1;
	}



}


void BonesDefMod::BuildMajorAxis(INode *node, Point3 &l1, Point3 &l2)
	{
//get object state
	ObjectState os;
	
	os = node->EvalWorldState(RefFrame);

//get bounding box
	Box3 bb;
//get longest axis
	os.obj->GetDeformBBox(0,bb);
	
	float dx,dy,dz,axislength;
	dx = bb.pmax.x - bb.pmin.x;
	dy = bb.pmax.y - bb.pmin.y;
	dz = bb.pmax.z - bb.pmin.z;
	int axis;
	axislength = dx;
	axis = 0;

	
	if (dy > axislength)
		{
		axis = 1;
		axislength = dy;				
		}
	if (dz > axislength)
		{
		axis = 2;
		axislength = dz;				
		}

	if (axis ==0)
		{
		l1.x = bb.pmax.x;
		l2.x = bb.pmin.x;
		}

	else if (axis ==1)
		{
		l1.y = bb.pmax.y;
		l2.y = bb.pmin.y;
		}

	else if (axis ==2)
		{
		l1.z = bb.pmax.z;
		l2.z = bb.pmin.z;
		}

	}

Matrix3 BonesDefMod::CompMatrix(TimeValue t,INode *inode,ModContext *mc)
	{
	Interval iv;
	Matrix3 tm(1);	
//	if (mc && mc->tm) 
//		tm = Inverse(*(mc->tm));
	if (inode) 
//		tm = tm * inode->GetObjTMBeforeWSM(t,&iv);
		tm = tm * inode->GetObjectTM(t,&iv);
	return tm;
	}


void BonesDefMod::ClearVertexSelections(BoneModData *bmd)
{
for (int i = 0; i <bmd->selected.GetSize(); i++)
	{
	bmd->selected.Set(i,FALSE);
	}
EnableEffect(FALSE);
ip->RedrawViews(ip->GetTime());
}

void BonesDefMod::ClearBoneEndPointSelections()
{

for (int i = 0; i <BoneData.Count(); i++)
	{
	if (BoneData[i].Node != NULL)
		{
		BoneData[i].end1Selected = FALSE;
		BoneData[i].end2Selected = FALSE;
/*		bmd->sel[ct++] = FALSE;
		bmd->sel[ct++] = FALSE;
		for (int j = 0; j <BoneData[i].CrossSectionList.Count(); j++)
			ct += 8;
*/

		}
	}

ip->RedrawViews(ip->GetTime());
}
void BonesDefMod::ClearEnvelopeSelections()
{
for (int i = 0; i <BoneData.Count(); i++)
	{
	if (BoneData[i].Node != NULL)
		{
//		ct++;
//		ct++;
		for (int j = 0; j <BoneData[i].CrossSectionList.Count(); j++)
			{
			BoneData[i].CrossSectionList[j].innerSelected = FALSE;
			BoneData[i].CrossSectionList[j].outerSelected = FALSE;
//			for (int k = 0; k <8; k++)
//			sel[ct++] =FALSE;
			}

		}
	}
ModeBoneEnvelopeIndex = -1;
ip->RedrawViews(ip->GetTime());

}


void BonesDefMod::SelectFlexibleVerts(BoneModData *bmd)
{
for (int i =0;i<bmd->VertexDataCount;i++)
	{
	bmd->selected.Set(i,FALSE);
	for (int j =0; j <bmd->VertexData[i]->d.Count();j++)
		{
		if (bmd->VertexData[i]->d[j].Bones==ModeBoneIndex)
			{
			if (bmd->VertexData[i]->d[j].Influences != 1.0f)
				bmd->selected.Set(i,TRUE);
//				sel[i] = TRUE;
			}
		}
	}
NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
//ip->RedrawViews(mod->ip->GetTime());

}
void BonesDefMod::BuildFalloff(BoneModData *bmd)
{
for (int i =0;i<bmd->VertexDataCount;i++)
	{
	if (bmd->selected[i])
		{
		float f1 = 999999999.9f, f2 = 999999999.9f;
		BOOL found1 = FALSE,found2 = FALSE;
//find closest non selected red vert
		for (int j =0;j<bmd->VertexDataCount;j++)
			{
			bmd->VertexData[i]->modified = TRUE;
			if (!bmd->selected[j])
				{
				for (int k =0;k<bmd->VertexData[j]->d.Count();k++)
					{
					if ( (bmd->VertexData[j]->d[k].Bones == ModeBoneIndex) &&
						 (bmd->VertexData[j]->d[k].Influences == 1.0f) )
						{
						float dist = Length(bmd->VertexData[j]->LocalPos - bmd->VertexData[i]->LocalPos);
						if (dist < f1 ) 
							{
							f1 = dist;
							found1 = TRUE;
							}
						}
					}

				}
			}
//find closest non selected no influence vert
		for (j =0;j<bmd->VertexDataCount;j++)
			{
			BOOL tfound = FALSE;
			if (!bmd->selected[j])
				{

				for (int k =0;k<bmd->VertexData[j]->d.Count();k++)
					{
					if ( (bmd->VertexData[j]->d[k].Bones == ModeBoneIndex) &&
						 (bmd->VertexData[j]->d[k].Influences == 0.0f) )
						{
						float dist = Length(bmd->VertexData[j]->LocalPos - bmd->VertexData[i]->LocalPos);
						if (dist < f2 ) 
							{
							f2 = dist;
							found2 = TRUE;
							}
						}
					if ( (bmd->VertexData[j]->d[k].Bones == ModeBoneIndex) &&
						 (bmd->VertexData[j]->d[k].Influences != 0.0f) )
						 tfound = TRUE;

					}
				if (!tfound)
					{
					float dist = Length(bmd->VertexData[j]->LocalPos - bmd->VertexData[i]->LocalPos);
					if (dist < f2 ) 
						{
						f2 = dist;
						found2 = TRUE;
						}

					}

				}
			}
		if ((found1) && (found2))
			{
			float influ = f2/(f1+f2);
			ComputeFalloff(influ,BoneData[ModeBoneIndex].FalloffType);

			BOOL tfound = false;
			for (int k =0;k<bmd->VertexData[i]->d.Count();k++)
				{
				if (bmd->VertexData[i]->d[k].Bones == ModeBoneIndex)
					{
					tfound = TRUE;
					bmd->VertexData[i]->d[k].Influences = influ;
					bmd->VertexData[i]->d[k].normalizedInfluences = -1.0f;

					k = bmd->VertexData[i]->d.Count();
					}
				}
			if (!tfound)
				{

				VertexInfluenceListClass td;
				td.Bones = ModeBoneIndex;
				td.Influences = influ;
				td.normalizedInfluences = -1.0f;
				bmd->VertexData[i]->d.Append(1,&td,1);

				}
//now rebablance
			float remainder = 1.0f - influ;
			if (bmd->VertexData[i]->d.Count() > 1)
				{
				remainder = remainder /(bmd->VertexData[i]->d.Count()-1);
				for (k =0;k<bmd->VertexData[i]->d.Count();k++)
					{
					if (bmd->VertexData[i]->d[k].Bones != ModeBoneIndex)
						{
						bmd->VertexData[i]->d[k].Influences = remainder;
						bmd->VertexData[i]->d[k].normalizedInfluences = -1.0f;
						}
					}
				}
			else if (bmd->VertexData[i]->d.Count() == 1 )
				{
				if (BoneData[ModeBoneIndex].flags & BONE_ABSOLUTE_FLAG) 
					{
					bmd->VertexData[i]->d[0].Influences = 1.0f;
					bmd->VertexData[i]->d[0].normalizedInfluences = 1.0f;
					}

				}



			}
		}
	}

NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);


}


void BonesDefMod::SyncSelections()
{
for (int i = 0; i < BoneData.Count();i++)
	{
	if (BoneData[i].Node != NULL)
		{
		BoneData[i].end1Selected = FALSE;
		BoneData[i].end2Selected = FALSE;

		for (int j=0;j<BoneData[i].CrossSectionList.Count();j++)
			{
			BoneData[i].CrossSectionList[j].innerSelected = FALSE;
			BoneData[i].CrossSectionList[j].outerSelected = FALSE;
			}

		}	
	}


if (ModeBoneIndex != -1)
	{
	if (ModeBoneEnvelopeIndex == 0)
		{
		BoneData[ModeBoneIndex].end1Selected = TRUE;
		}
	else if (ModeBoneEnvelopeIndex == 1)
		{
		BoneData[ModeBoneIndex].end2Selected = TRUE;
		}
	if (ModeBoneEnvelopeIndex != -1)
		{
		if (ModeBoneEnvelopeSubType < 4)
			BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].innerSelected = TRUE;
		else BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].outerSelected = TRUE;
		EnableRadius(TRUE);

		}
	else
		EnableRadius(FALSE);


	}
//update list box
if (ModeBoneIndex != -1)
	{
	int fsel = ConvertSelectedBoneToListID(ModeBoneIndex);

	SendMessage(GetDlgItem(hParam,IDC_LIST1),
					LB_SETCURSEL ,fsel,0);

	}

}


int BonesDefMod::HitTest(
		TimeValue t, INode* inode, 
		int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt, ModContext* mc)
	{

	pblock_param->GetValue(PB_FILTER_VERTICES,t,FilterVertices,FOREVER);
	pblock_param->GetValue(PB_FILTER_BONES,t,FilterBones,FOREVER);
	pblock_param->GetValue(PB_FILTER_ENVELOPES,t,FilterEnvelopes,FOREVER);

	FilterVertices = !FilterVertices;
	FilterBones = !FilterBones;
	FilterEnvelopes = !FilterEnvelopes;


	ModeEdit = 0;


	GraphicsWindow *gw = vpt->getGW();
	Point3 pt;
	HitRegion hr;
	int savedLimits, res = 0;
	Matrix3 tm = CompMatrix(t,inode,mc);

	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);	
	gw->setTransform(tm);

// Hit test start point
//loop through points checking for selection
//get selected bone	
	int fsel;
	fsel = SendMessage(GetDlgItem(hParam,IDC_LIST1),
					LB_GETCURSEL ,0,0);

	int ssel = ConvertSelectedListToBoneID(fsel);

	BoneModData *bmd = (BoneModData *) mc->localData;

	if (bmd==NULL) return 0;


	if ( (ssel>=0) && (ip && ip->GetSubObjectLevel() == 1) )

		{


		ObjectState os;

		os = inode->EvalWorldState(t);
//loop through points checking for selection and then marking for points
		if (FilterVertices == 0)
			{
			Interval iv;
			Matrix3 atm = inode->GetObjTMAfterWSM(t,&iv);
			Matrix3 ctm = inode->GetObjectTM(t,&iv);


			BOOL isWorldSpace = FALSE;

			if ((atm.IsIdentity()) && (ip->GetShowEndResult ()))
				isWorldSpace = TRUE;


			for (int i=0;i<bmd->VertexDataCount;i++)
				{
				if ((flags&HIT_SELONLY   &&  bmd->selected[i]) ||
					(flags&HIT_UNSELONLY && !bmd->selected[i]) ||
					!(flags&(HIT_UNSELONLY|HIT_SELONLY)) ) 
					{

					Point3 pt;
					gw->clearHitCode();
					if (isWorldSpace)
						pt = os.obj->GetPoint(i) * Inverse(ctm);
					else pt = os.obj->GetPoint(i);
					gw->setColor(LINE_COLOR, 1.0f,1.0f,1.0f);
					gw->marker(&pt,POINT_MRKR);
					if (gw->checkHitCode()) {

						vpt->LogHit(inode, mc, gw->getHitDistance(), i, 
							new BoneHitDataClass(i,-1,-1,-1,-1)); 
						res = 1;
						}
					}
				}
			}
		int ct = bmd->VertexDataCount;
		for (int i =0;i<BoneData.Count();i++)
			{
			if (BoneData[i].Node != NULL)
				{
//add in envelopes start and end
				ObjectState os;
				ShapeObject *pathOb = NULL;


				if (FilterBones == 0)
					{

					Point3 pta,ptb;
//					GetEndPoints(bmd, t,pta, ptb, i);

					GetEndPointsLocal(bmd, t,pta, ptb, i);

//					Interval valid;
//					Matrix3 ntm = BoneData[i].Node->GetObjTMBeforeWSM(t,&valid);

//					pta = pta * ntm  * bmd->InverseBaseTM;
//					ptb = ptb * ntm  * bmd->InverseBaseTM;


/*					if ((flags&HIT_SELONLY   &&  sel[ct]) ||
						(flags&HIT_UNSELONLY && !sel[ct]) ||
						!(flags&(HIT_UNSELONLY|HIT_SELONLY)) ) */

					if ((flags&HIT_SELONLY   &&  BoneData[i].end1Selected) ||
						(flags&HIT_UNSELONLY && !BoneData[i].end1Selected) ||
						!(flags&(HIT_UNSELONLY|HIT_SELONLY)) ) 

						{

						gw->clearHitCode();
						gw->setColor(LINE_COLOR, 1.0f,1.0f,1.0f);
						Point3 pt;
						Interval v;

						Point3 invA;
						invA = (ptb-pta) *.1f;
						
						pta += invA;

						gw->marker(&pta,POINT_MRKR);
						if (gw->checkHitCode()) {

							vpt->LogHit(inode, mc, gw->getHitDistance(), ct,  
								new BoneHitDataClass(-1,i,0,-1,-1)); 
							res = 1;
							}
						}
					if ((flags&HIT_SELONLY   &&  BoneData[i].end2Selected) ||
						(flags&HIT_UNSELONLY && !BoneData[i].end2Selected) ||
						!(flags&(HIT_UNSELONLY|HIT_SELONLY)) ) 

/*					if ((flags&HIT_SELONLY   &&  sel[ct]) ||

						(flags&HIT_UNSELONLY && !sel[ct]) ||
						!(flags&(HIT_UNSELONLY|HIT_SELONLY)) ) */
						{

						gw->clearHitCode();
						gw->setColor(LINE_COLOR, 1.0f,1.0f,1.0f);
						Point3 pt;
						Interval v;

						Point3 invB;
						invB = (pta-ptb) *.1f;
						
						ptb += invB;



						gw->marker(&ptb,POINT_MRKR);
						if (gw->checkHitCode()) {

							vpt->LogHit(inode, mc, gw->getHitDistance(), ct,
								new BoneHitDataClass(-1,i,1,-1,-1)); 
								
							res = 1;
							}
						}
					}

//add in enevelope inner and outer
				if ((FilterEnvelopes == 0) && (i == ModeBoneIndex))
					{
					if (BoneData[i].flags & BONE_SPLINE_FLAG)
						{
						ObjectState os = BoneData[i].Node->EvalWorldState(t);
						pathOb = (ShapeObject*)os.obj;
						}
					Point3 l1,l2;
					Interval v;

//					GetEndPoints(bmd, t,l1, l2, i);

					GetEndPointsLocal(bmd, t,l1, l2, i);

					Interval valid;
					Matrix3 ntm = BoneData[i].Node->GetObjTMBeforeWSM(t,&valid);

//					l1 = l1 * ntm  * bmd->InverseBaseTM;
//					l2 = l2 * ntm  * bmd->InverseBaseTM;


					Point3 align = (l2-l1);
					Point3 nvec = align;

					for (int j=0;j<BoneData[i].CrossSectionList.Count();j++)
						{

						Point3 p_edge[8];
						Point3 ept(0.0f,0.0f,0.0f);
						Point3 vec;


						if (BoneData[i].flags & BONE_SPLINE_FLAG)
							{
//							ept = pathOb->InterpCurve3D(t, 0,BoneData[i].CrossSectionList[j].u) * Inverse(BoneData[i].tm);
//							align = VectorTransform(Inverse(BoneData[i].tm),pathOb->TangentCurve3D(t, 0,BoneData[i].CrossSectionList[j].u));
							ept = pathOb->InterpCurve3D(t, 0,BoneData[i].CrossSectionList[j].u) * ntm  * bmd->InverseBaseTM;
							align = VectorTransform(ntm  * bmd->InverseBaseTM,pathOb->TangentCurve3D(t, 0,BoneData[i].CrossSectionList[j].u));
							float Inner,Outer;
							BoneData[i].CrossSectionList[j].InnerControl->GetValue(0,&Inner,v);
							BoneData[i].CrossSectionList[j].OuterControl->GetValue(0,&Outer,v);
							GetCrossSection(ept, align, Inner,BoneData[i].temptm, p_edge);
							GetCrossSection(ept, align, Outer,BoneData[i].temptm, &p_edge[4]);

							}
						else
							{
//							align = (BoneData[i].l2-BoneData[i].l1);
//							ept = BoneData[i].l1;
							align = (l2-l1);
							ept = l1;
							float Inner,Outer;
							BoneData[i].CrossSectionList[j].InnerControl->GetValue(0,&Inner,v);
							BoneData[i].CrossSectionList[j].OuterControl->GetValue(0,&Outer,v);


							ept = ept + nvec * BoneData[i].CrossSectionList[j].u;
							GetCrossSection(ept, align, Inner,BoneData[i].temptm, p_edge);
							GetCrossSection(ept, align, Outer,BoneData[i].temptm, &p_edge[4]);
//							GetCrossSection(ept, align, BoneData[i].CrossSectionList[j].Inner,BoneData[i].temptm, p_edge);
//							GetCrossSection(ept, align, BoneData[i].CrossSectionList[j].Outer,BoneData[i].temptm, &p_edge[4]);

							}



						for (int m=0;m<4;m++)
							{
							if ((flags&HIT_SELONLY   &&  BoneData[i].CrossSectionList[j].innerSelected) ||
								(flags&HIT_UNSELONLY && !BoneData[i].CrossSectionList[j].innerSelected) ||
								!(flags&(HIT_UNSELONLY|HIT_SELONLY)) ) 
								{
		
								gw->clearHitCode();
								gw->setColor(LINE_COLOR, 1.0f,1.0f,1.0f);


								
								gw->marker(&p_edge[m],POINT_MRKR);
								if (gw->checkHitCode()) {

									vpt->LogHit(inode, mc, gw->getHitDistance(), ct, 
										new BoneHitDataClass(-1,i,-1,j,m)); 
									res = 1;
									}
								}
							}
						for (m=4;m<8;m++)
							{
							if ((flags&HIT_SELONLY   &&  BoneData[i].CrossSectionList[j].outerSelected) ||
								(flags&HIT_UNSELONLY && !BoneData[i].CrossSectionList[j].outerSelected) ||
								!(flags&(HIT_UNSELONLY|HIT_SELONLY)) ) 
								{
		
								gw->clearHitCode();
								gw->setColor(LINE_COLOR, 1.0f,1.0f,1.0f);


								
								gw->marker(&p_edge[m],POINT_MRKR);
								if (gw->checkHitCode()) {

									vpt->LogHit(inode, mc, gw->getHitDistance(), ct, 
										new BoneHitDataClass(-1,i,-1,j,m)); 
									res = 1;
									}
								}
							}

						}
					}
				}
			}

		}

	gw->setRndLimits(savedLimits);

	return res;

	}



int BonesDefMod::Display(
		TimeValue t, INode* inode, ViewExp *vpt, 
		int flagst, ModContext *mc)
	{

	if (inode)
		{
		if (ip)
			{
			int nodeCount = ip->GetSelNodeCount();
			BOOL found = FALSE;
			for (int nct =0; nct < nodeCount; nct++)
				{
				if (inode == ip->GetSelNode(nct))
					{
					found = TRUE;
					nct = nodeCount;
					}
				}
			if (!found) return 0;
			}

		}


	BoneModData *bmd = (BoneModData *) mc->localData;

	if (!bmd) return 0;

	Interval iv;
	Matrix3 atm = inode->GetObjTMAfterWSM(t,&iv);
	Matrix3 ctm = inode->GetObjectTM(t,&iv);
	BOOL isWorldSpace = FALSE;
	if ((atm.IsIdentity()) && (ip->GetShowEndResult ()))
		isWorldSpace = TRUE;


	GraphicsWindow *gw = vpt->getGW();
	Point3 pt[4];
	Matrix3 tm = CompMatrix(t,inode,mc);
	int savedLimits;

//	obtm = tm;
//	iobtm = Inverse(tm);

	gw->setRndLimits((savedLimits = gw->getRndLimits()) & ~GW_ILLUM);
	gw->setTransform(tm);

//get selected bone	
	int fsel;
	fsel = SendMessage(GetDlgItem(hParam,IDC_LIST1),
					LB_GETCURSEL ,0,0);

	int tsel = ConvertSelectedListToBoneID(fsel);




	if ((tsel>=0) && (ip && ip->GetSubObjectLevel() == 1) )
		{

		if (inPaint)
			{
			if (bmd->isHit)
				{
//draw 3d cursor
				Point3 x(1.0f,0.0f,0.0f),y(0.0f,1.0f,0.0f),z(0.0f,0.0f,1.0f);
				gw->setColor(LINE_COLOR, 1.0f,1.0f,0.0f);

				DrawCrossSectionNoMarkers(bmd->hitPoint, x, Radius, gw); // optimize these can be moved out of the loop
				DrawCrossSectionNoMarkers(bmd->hitPoint, y, Radius, gw); // optimize these can be moved out of the loop
				DrawCrossSectionNoMarkers(bmd->hitPoint, z, Radius, gw); // optimize these can be moved out of the loop

				}
			}
//		else
		{
		ObjectState os;

		os = inode->EvalWorldState(t);
//loop through points checking for selection and then marking
		float r,g,b;

		BOOL isPatch = FALSE;
		int knots = 0;
		PatchMesh *pmesh;
		BitArray interiorVecs;

		Interval iv;
		Matrix3 atm = inode->GetObjTMAfterWSM(t,&iv);
		Matrix3 btm = inode->GetObjTMBeforeWSM(t,&iv);


		if (os.obj->IsSubClassOf(patchObjectClassID))
			{
			PatchObject *pobj = (PatchObject*)os.obj;
			pmesh = &(pobj->patch);
			isPatch = TRUE;
			knots = pmesh->numVerts;
			interiorVecs.SetSize(pmesh->numVecs);
			interiorVecs.ClearAll();
			for (int ipatch=0;ipatch<pmesh->numPatches;ipatch++)
				{
				int pc = 3;
				if (pmesh->patches[ipatch].type == PATCH_QUAD) pc = 4;
				for (int ivec = 0; ivec < pc; ivec++)
//need to check if manual interio and mark if the  manuaul interio bug gets fixed
					interiorVecs.Set(pmesh->patches[ipatch].interior[ivec]);
				}

			}

		for (int i=0;i<bmd->VertexDataCount;i++)
			{

			for (int j=0;j<bmd->VertexData[i]->d.Count();j++)
				{
				if ((bmd->VertexData[i]->d[j].Bones == tsel) && (bmd->VertexData[i]->d[j].Influences != 0.0f) &&
					 (DrawVertices ==1) )
					
					{
					Point3 pt;
					if (isWorldSpace)
						pt = os.obj->GetPoint(i) *Inverse(ctm);
					else pt = os.obj->GetPoint(i);
//					pt = bmd->VertexData[i]->LocalPos;
//gte red is strongest,green, blue is weakest based on influence
					float infl;
//					infl = VertexData[i].d[j].Influences;

					infl = RetrieveNormalizedWeight(bmd,i,j);
					Point3 selColor(0.0f,0.0f,0.0f);
					Point3 selSoft = GetUIColor(COLOR_SUBSELECTION_SOFT);
					Point3 selMedium = GetUIColor(COLOR_SUBSELECTION_MEDIUM);
					Point3 selHard = GetUIColor(COLOR_SUBSELECTION_HARD);

					if (infl > 0.0f)
						{
						if ( (infl<0.5) && (infl > 0.0f))
							{
							selColor = selSoft + ( (selMedium-selSoft) * (infl/0.5f));
//							r =0.0f;
//							g = 0.0f;
//							b = 1.0f;
							}
						else if (infl<1.0)
							{
							selColor = selMedium + ( (selHard-selMedium) * ((infl-0.5f)/0.5f));
//							r =0.0f;
//							g = 1.0f;
//							b = 0.0f;
							}
						else 
							{
							selColor = GetUIColor(COLOR_SUBSELECTION);
//							r =1.0f;
//							g = 0.0f;
//							b = 0.0f;
							}
						r = selColor.x;
						g = selColor.y;
						b = selColor.z;

						gw->setColor(LINE_COLOR, r,g,b);
						if (isPatch)
							{
							if (i< knots)
								{
								gw->marker(&pt,PLUS_SIGN_MRKR);
								if (bmd->selected[i] == FALSE)
									{
//it is a knot draw the handle
									PatchVert pv = pmesh->getVert(i);
									Point3 lp[3];
									lp[0] = pt;
									gw->setColor(LINE_COLOR, 0.8f,0.8f,0.8f);

									for (int vec_count = 0; vec_count < pv.vectors.Count(); vec_count++)
										{
										int	idv = pv.vectors[vec_count];
										if (isWorldSpace)
											lp[1] = pmesh->getVec(idv).p * Inverse(ctm);
										else lp[1] = pmesh->getVec(idv).p;
										gw->polyline(2, lp, NULL, NULL, 0);
		
										}
									}

								}
							else 
								{
								if (!interiorVecs[i-knots])
									gw->marker(&pt,SM_HOLLOW_BOX_MRKR);
								}
							}
						else gw->marker(&pt,PLUS_SIGN_MRKR);
						j = bmd->VertexData[i]->d.Count()+1;
						}
				
					}
				}
			if (bmd->selected[i] == TRUE)
				{
				Point3 pt;
				if (isWorldSpace)
					pt = os.obj->GetPoint(i) *Inverse(ctm);
				else pt = os.obj->GetPoint(i);
				gw->setColor(LINE_COLOR, 1.0f,1.0f,1.0f);
				gw->marker(&pt,HOLLOW_BOX_MRKR);

				if ((i< knots) && (isPatch))
					{
//it is a knot draw the handle
					PatchVert pv = pmesh->getVert(i);
					Point3 lp[3];
					lp[0] = pt;
					gw->setColor(LINE_COLOR, 0.8f,0.8f,0.8f);

					for (int vec_count = 0; vec_count < pv.vectors.Count(); vec_count++)
						{
						int idv = pv.vectors[vec_count];
						if (isWorldSpace)
							lp[1] = pmesh->getVec(idv).p * Inverse(ctm);
						else lp[1] = pmesh->getVec(idv).p;
						gw->polyline(2, lp, NULL, NULL, 0);
//						gw->marker(&pt,HOLLOW_BOX_MRKR);

						}
					}
				}

//kinda sucks need to load this up so the paint has an array of world psace points to work with
//			bmd->VertexData[i]->LocalPos = os.obj->GetPoint(i);

			}


//draw selected bone

		for (i =0;i<BoneData.Count();i++)
			{
			if (BoneData[i].Node != NULL)
				{

				if (i== tsel)
					{
					r = 1.0f;
					g = 1.0f;
					b = 0.0f;
					Point3 l1,l2;
					Interval v;
					BoneData[i].EndPoint1Control->GetValue(0,&l1,v);
					BoneData[i].EndPoint2Control->GetValue(0,&l2,v);

					Interval valid;
					Matrix3 ntm = BoneData[i].Node->GetObjTMBeforeWSM(t,&valid);

					Worldl1 = l1  * ntm;  
					Worldl2 = l2  * ntm;  

					}
				else
					{
					r = 0.3f;
					g = 0.3f;
					b = 0.3f;
					}

				Point3 pta, ptb;
				Point3 pta_tm,ptb_tm;
				Point3 plist[2];

				
				GetEndPointsLocal(bmd, t,pta, ptb, i);


				gw->setColor(LINE_COLOR, r,g,b);

				ObjectState os;
				ShapeObject *pathOb = NULL;

//				pta = (pta ) * bmd->tmCacheToObjectSpace[i];
//				ptb = (ptb ) * bmd->tmCacheToObjectSpace[i];


				if (BoneData[i].flags & BONE_SPLINE_FLAG)
					{


					ObjectState os = BoneData[i].Node->EvalWorldState(t);
					pathOb = (ShapeObject*)os.obj;

					float su = 0.0f;
					float eu = 0.1f;
					float inc = 0.1f;
					Point3 sp_line[10];
					
					Point3 l1,l2;
					l1 = pathOb->InterpPiece3D(t, 0,0 ,0.0f ) * bmd->tmCacheToObjectSpace[i];
					l2 = pathOb->InterpPiece3D(t, 0,0 ,1.0f ) * bmd->tmCacheToObjectSpace[i];

					pta = l1;
					ptb = l2;

					plist[0] = pta;
					plist[1] = ptb;


					for (int cid = 0; cid < pathOb->NumberOfCurves(); cid++)
						{
						for (int sid = 0; sid < pathOb->NumberOfPieces(t,cid); sid++)
							{
								
							for (int spid = 0; spid < 4; spid++)
								{
								sp_line[spid] = pathOb->InterpPiece3D(t, cid,sid ,su ) * bmd->tmCacheToObjectSpace[i];  //optimize reduce the count here 
								su += inc;
								}
							gw->polyline(4, sp_line, NULL, NULL, 0);

							}
						}
					}
				else
					{
					Point3 invA,invB;
	

					invA = (ptb-pta) *.1f;
					invB = (pta-ptb) *.1f;

					plist[0] = pta + invA;
					plist[1] = ptb + invB;

					gw->polyline(2, plist, NULL, NULL, 0);
					}

				if ((BoneData[i].end1Selected) && (i== tsel))
					gw->setColor(LINE_COLOR, 1.0f,0.0f,1.0f);
				else gw->setColor(LINE_COLOR, .3f,.3f,0.3f);


				gw->marker(&plist[0],BIG_BOX_MRKR);

				if ((BoneData[i].end2Selected) && (i== tsel))
					gw->setColor(LINE_COLOR, 1.0f,0.0f,1.0f);
				else gw->setColor(LINE_COLOR, .3f,.3f,0.3f);

				gw->marker(&plist[1],BIG_BOX_MRKR);

//Draw Cross Sections
				Tab<Point3> CList;
				Tab<float> InnerList, OuterList;

				for (int ccount = 0; ccount < BoneData[i].CrossSectionList.Count();ccount++)
					{
					Point3 m;
					float inner;
					float outer;
					Interval v;
					BoneData[i].CrossSectionList[ccount].InnerControl->GetValue(0,&inner,v);
					BoneData[i].CrossSectionList[ccount].OuterControl->GetValue(0,&outer,v);

					GetCrossSectionRanges(inner, outer, i, ccount);

					if (tsel == i)
						{
						gw->setColor(LINE_COLOR, 1.0f,0.0f,0.0f);
						if ( (ModeBoneEnvelopeIndex == ccount) && (ModeBoneEnvelopeSubType<4))
							gw->setColor(LINE_COLOR, 1.0f,0.0f,1.0f);
						}

					Point3 nvec;
					Matrix3 rtm;
					if ((DrawEnvelopes ==1) || (tsel == i) || (BoneData[i].flags & BONE_DRAW_ENVELOPE_FLAG))
						{
						Point3 vec;

						InnerList.Append(1,&inner,1);
						OuterList.Append(1,&outer,1);

						if (BoneData[i].flags & BONE_SPLINE_FLAG)
							{
							vec = pathOb->InterpCurve3D(t, 0,BoneData[i].CrossSectionList[ccount].u) * bmd->tmCacheToObjectSpace[i]; 

							CList.Append(1,&(vec),1);
							nvec = VectorTransform(bmd->tmCacheToObjectSpace[i],pathOb->TangentCurve3D(t, 0,BoneData[i].CrossSectionList[ccount].u));
							DrawCrossSection(vec, nvec, inner, BoneData[i].temptm, gw);  // optimize these can be moved out of the loop
							}
						else
							{
							nvec = (ptb-pta);
							vec = nvec * BoneData[i].CrossSectionList[ccount].u;
							CList.Append(1,&(pta+vec),1);
							DrawCrossSection(pta+vec, nvec, inner, BoneData[i].temptm, gw); // optimize these can be moved out of the loop
							}

						}
					if (tsel == i)
						{	
						gw->setColor(LINE_COLOR, 0.5f,0.0f,0.0f);
						if ( (ModeBoneEnvelopeIndex == ccount) && (ModeBoneEnvelopeSubType>=4))
							gw->setColor(LINE_COLOR, 1.0f,0.0f,1.0f);
						}

					if ((DrawEnvelopes ==1) || (tsel == i) || (BoneData[i].flags & BONE_DRAW_ENVELOPE_FLAG))
						{
						Point3 vec;
						if (BoneData[i].flags & BONE_SPLINE_FLAG)
							{
							vec = pathOb->InterpCurve3D(t, 0,BoneData[i].CrossSectionList[ccount].u) * bmd->tmCacheToObjectSpace[i];
							nvec = VectorTransform(bmd->tmCacheToObjectSpace[i],pathOb->TangentCurve3D(t, 0,BoneData[i].CrossSectionList[ccount].u));  // optimize these can be moved out of the loop
							DrawCrossSection(vec, nvec, outer, BoneData[i].temptm, gw);

							}
						else
							{

							nvec = (ptb-pta);
							vec = nvec * BoneData[i].CrossSectionList[ccount].u;
							DrawCrossSection(pta+vec, nvec, outer, BoneData[i].temptm, gw);
							}

						}
					}

				if ((DrawEnvelopes ==1) || (tsel == i) || (BoneData[i].flags & BONE_DRAW_ENVELOPE_FLAG))
					{
					if (!(BoneData[i].flags & BONE_SPLINE_FLAG))
						{
						gw->setColor(LINE_COLOR, 1.0f,0.0f,0.0f);

						DrawEnvelope(CList, InnerList, CList.Count(), BoneData[i].temptm,  gw);
						gw->setColor(LINE_COLOR, 0.5f,0.0f,0.0f);
						DrawEnvelope(CList, OuterList, CList.Count(), BoneData[i].temptm,  gw);
						}
					}




				}
			}

		}


		}
	gw->setRndLimits(savedLimits);

	return 0;

	}




void BonesDefMod::GetWorldBoundBox(
		TimeValue t,INode* inode, ViewExp *vpt, 
		Box3& box, ModContext *mc)
	{

	BoneModData *bmd = (BoneModData *) mc->localData;

	if (!bmd) return ;



	Matrix3 tm = CompMatrix(t,inode,mc);
	Point3 pt1, pt2;
	box.Init();

	if (ModeEdit == 1)
		{
		Interval iv;
		if ( (ModeBoneEndPoint == 0) || (ModeBoneEndPoint == 1))
			{
			p1Temp->GetValue(t,&pt1,FOREVER,CTRL_ABSOLUTE);
			box += pt1;// * BoneData[ModeBoneIndex].temptm * tm;
			}
		}	

	float l = 0.0f;
	for (int i =0;i<BoneData.Count();i++)
		{
		if (BoneData[i].Node != NULL)
			{


			Interval valid;
			Matrix3 ntm = BoneData[i].Node->GetObjTMBeforeWSM(t,&valid);
//			pta = pta * ntm  * bmd->InverseBaseTM;
//			ptb = ptb * ntm  * bmd->InverseBaseTM;


			Point3 pta;
			Interval v;
			BoneData[i].EndPoint1Control->GetValue(0,&pta,v);

			box += pta* ntm;//  * bmd->InverseBaseTM;;// * BoneData[i].temptm * tm;
			BoneData[i].EndPoint2Control->GetValue(0,&pta,v);
			box += pta* ntm;//  * bmd->InverseBaseTM;;//  * BoneData[i].temptm * tm;
			for (int k = 0; k < BoneData[i].CrossSectionList.Count();k++)
				{
				float outer;
				Interval v;
				BoneData[i].CrossSectionList[k].OuterControl->GetValue(0,&outer,v);

				if (outer > l) l = outer;
				}
			}
		}
	box.EnlargeBy(l+10.0f);  // this is a fudge since I am using large tick boxes
	
	}


void BonesDefMod::Move(TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin)
	{

//check of points
//check for envelopes

	if ( !ip ) return;

	ModContextList mcList;		
	INodeTab nodes;

	ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();

	for ( int i = 0; i < objects; i++ ) 
		{
		BoneModData *bmd = (BoneModData*)mcList[i]->localData;

		int mode = 1;
		if (mode >0 )
			{
			ModeEdit = 1;
			val = VectorTransform(tmAxis*Inverse(partm),val);



			if (ModeBoneEndPoint == 0)
				{
				val = VectorTransform(bmd->tmCacheToBoneSpace[ModeBoneIndex],val);

				bmd->CurrentCachePiece = -1;
				BoneData[ModeBoneIndex].EndPoint1Control->SetValue(0,&val,TRUE,CTRL_RELATIVE);

//				Interval iv;
//				BoneData[ModeBoneIndex].EndPoint1Control->GetValue(0,&bmd->localCenter,iv);
//				bmd->localCenter = bmd->localCenter *bmd->tmCacheToObjectSpace[ModeBoneIndex];

				}
			else if (ModeBoneEndPoint == 1)
				{
				val = VectorTransform(bmd->tmCacheToBoneSpace[ModeBoneIndex],val);

				bmd->CurrentCachePiece = -1;
				BoneData[ModeBoneIndex].EndPoint2Control->SetValue(0,&val,TRUE,CTRL_RELATIVE);

//				Interval iv;
//				BoneData[ModeBoneIndex].EndPoint2Control->GetValue(0,&bmd->localCenter,iv);

//				bmd->localCenter = bmd->localCenter *bmd->tmCacheToObjectSpace[ModeBoneIndex];

				}

			else
				{
				if ((ModeBoneEnvelopeIndex != -1) && (ModeBoneEnvelopeSubType != -1))
					{

					val = VectorTransform(bmd->tmCacheToBoneSpace[ModeBoneIndex],val);
					p1Temp->SetValue(0,val,TRUE,CTRL_RELATIVE);

					Interval v;
//					p1Temp->GetValue(0,bmd->localCenter,v);
//					bmd->localCenter = bmd->localCenter *bmd->tmCacheToObjectSpace[ModeBoneIndex];


					ObjectState os;
					ShapeObject *pathOb = NULL;
					Point3 nvec;
					Point3 vec;
					Point3 lp;
					Point3 l1,l2;
					BoneData[ModeBoneIndex].EndPoint1Control->GetValue(0,&l1,v);
					BoneData[ModeBoneIndex].EndPoint2Control->GetValue(0,&l2,v);


					Point3 p(0.0f,0.0f,0.0f);
					Interval iv = FOREVER;
					p1Temp->GetValue(0,&p,iv);
					 
//					p = val;


					if (BoneData[ModeBoneIndex].flags & BONE_SPLINE_FLAG)
						{
						ObjectState os = BoneData[ModeBoneIndex].Node->EvalWorldState(t);
						pathOb = (ShapeObject*)os.obj;
//						lp = pathOb->InterpCurve3D(t, 0,BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].u) * Inverse(BoneData[ModeBoneIndex].tm);					
						lp = pathOb->InterpCurve3D(t, 0,BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].u);					
						}
					else
						{
						nvec = l2-l1;
						lp = l1 + nvec * BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].u;
						}


					if (ModeBoneEnvelopeSubType<4)
						{
						lp = lp * Inverse(bmd->tmCacheToBoneSpace[ModeBoneIndex]);
						p = p * Inverse(bmd->tmCacheToBoneSpace[ModeBoneIndex]);
						float inner = Length(lp-p);

						BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].InnerControl->SetValue(0,&inner,TRUE,CTRL_ABSOLUTE);
						}
					else if (ModeBoneEnvelopeSubType<8)
						{
						lp = lp * Inverse(bmd->tmCacheToBoneSpace[ModeBoneIndex]);
						p = p * Inverse(bmd->tmCacheToBoneSpace[ModeBoneIndex]);

						float outer = Length(lp-p);
	
						BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].OuterControl->SetValue(0,&outer,TRUE,CTRL_ABSOLUTE);
						}
					}

				}

			}


//move the right controller		
		}

	}

void BonesDefMod::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,
		INode *node,ModContext *mc)
	{
	BoneModData *bmd = (BoneModData *) mc->localData;

	if (!bmd) return; 

	Matrix3 tm = CompMatrix(t,node,mc);
	Point3 pt(0,0,0), p;
	if (ModeBoneEndPoint == 0)
		{
		Interval iv;
		BoneData[ModeBoneIndex].EndPoint1Control->GetValue(0,&bmd->localCenter,iv,CTRL_ABSOLUTE);
		bmd->localCenter = bmd->localCenter *bmd->tmCacheToObjectSpace[ModeBoneIndex];
		}
	else if (ModeBoneEndPoint == 1)
		{
		Interval iv;
		BoneData[ModeBoneIndex].EndPoint2Control->GetValue(0,&bmd->localCenter,iv,CTRL_ABSOLUTE);

		bmd->localCenter = bmd->localCenter *bmd->tmCacheToObjectSpace[ModeBoneIndex];
		}

	else
		{
		if ((ModeBoneEnvelopeIndex != -1) && (ModeBoneEnvelopeSubType != -1))
			{
			Interval v;
			p1Temp->GetValue(0,bmd->localCenter,v,CTRL_ABSOLUTE);
			bmd->localCenter = bmd->localCenter *bmd->tmCacheToObjectSpace[ModeBoneIndex];
			}
		}
	pt = bmd->localCenter;
	tm.PreTranslate(pt);
	cb->Center(tm.GetTrans(),0);
	}

void BonesDefMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,
		INode *node,ModContext *mc)
	{
	Matrix3 tm = CompMatrix(t,node,mc);
	cb->TM(tm,0);
	}


void BonesDefMod::UpdatePropInterface()

{

if ( (ModeBoneIndex >= 0) && (ModeBoneIndex < BoneData.Count()) )
	{
	if (BoneData[ModeBoneIndex].flags & BONE_ABSOLUTE_FLAG)
		{
		iAbsolute->SetCheck(FALSE);

		pblock_param->SetValue(PB_ABSOLUTE_INFLUENCE,0,1);
		}
	else
		{
		iAbsolute->SetCheck(TRUE);
		pblock_param->SetValue(PB_ABSOLUTE_INFLUENCE,0,0);
		}


	if (BoneData[ModeBoneIndex].flags & BONE_DRAW_ENVELOPE_FLAG)
		{
		pblock_param->SetValue(PB_DRAW_BONE_ENVELOPE,0,1);
		iEnvelope->SetCheck(TRUE);
		}
	else
		{
		pblock_param->SetValue(PB_DRAW_BONE_ENVELOPE,0,0);
		iEnvelope->SetCheck(FALSE);
		}
	if (BoneData[ModeBoneIndex].FalloffType == BONE_FALLOFF_X_FLAG)
		iFalloff->SetCurFlyOff(0,FALSE);
	else if (BoneData[ModeBoneIndex].FalloffType == BONE_FALLOFF_SINE_FLAG)
		iFalloff->SetCurFlyOff(1,FALSE);
	else if (BoneData[ModeBoneIndex].FalloffType == BONE_FALLOFF_X3_FLAG)
		iFalloff->SetCurFlyOff(3,FALSE);
	else if (BoneData[ModeBoneIndex].FalloffType == BONE_FALLOFF_3X_FLAG)
		iFalloff->SetCurFlyOff(2,FALSE);
	}


}

void BonesDefMod::UpdateP(BoneModData* bmd)
{

Point3 align;
Point3 vec;

Point3 p_edge[8];
Point3 ept(0.0f,0.0f,0.0f);

ObjectState os;
ShapeObject *pathOb = NULL;

Interval valid;
Matrix3 ntm = BoneData[ModeBoneIndex].Node->GetObjTMBeforeWSM(ip->GetTime(),&valid);

if ((BoneData[ModeBoneIndex].flags & BONE_SPLINE_FLAG) && (BoneData[ModeBoneIndex].Node != NULL))
	{
	ObjectState os = BoneData[ModeBoneIndex].Node->EvalWorldState(ip->GetTime());
	pathOb = (ShapeObject*)os.obj;
	ept = pathOb->InterpCurve3D(ip->GetTime(), 0,BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].u);
	align = pathOb->TangentCurve3D(ip->GetTime(), 0,BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].u);
	ept = ept * bmd->tmCacheToObjectSpace[ModeBoneIndex];
	align = VectorTransform(bmd->tmCacheToObjectSpace[ModeBoneIndex],align);

	}
else
	{
	Point3 l1,l2;
	Interval v;
	GetEndPointsLocal(bmd,ip->GetTime(),l1,l2, ModeBoneIndex);

	align = l2-l1;
	Point3 nvec = align;
	ept = l1;
	ept = ept + nvec * BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].u;
	}

float inner, outer;
Interval v;
BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].InnerControl->GetValue(0,&inner,v);
BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].OuterControl->GetValue(0,&outer,v);
GetCrossSection(ept, align, inner,
				BoneData[ModeBoneIndex].temptm,  p_edge);
GetCrossSection(ept, align, outer,
				BoneData[ModeBoneIndex].temptm,  &p_edge[4]);

if (ModeBoneEnvelopeSubType < 4)
	{
	pblock_param->SetController(PB_ERADIUS, BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].InnerControl, FALSE);
	BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].innerSelected = TRUE;

	}
else{
	pblock_param->SetController(PB_ERADIUS, BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].OuterControl, FALSE);
	BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].outerSelected = TRUE;
	}
Point3 p = p_edge[ModeBoneEnvelopeSubType] * bmd->BaseTM * Inverse(ntm);
bmd->localCenter = p_edge[ModeBoneEnvelopeSubType];


p1Temp->SetValue(0,p,TRUE,CTRL_ABSOLUTE);

//NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
//ip->RedrawViews(ip->GetTime());

}


void BonesDefMod::SelectSubComponent(
		HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert)
	{
	//if (theHold.Holding()) theHold.Put(new SelRestore(this));
	ModeEdit = 0;

	Tab<BoneModData*> bmdList;
	HitRecord *head = hitRec;
	while (hitRec) 
		{
		BoneModData *tbmd = (BoneModData*)hitRec->modContext->localData;
		BOOL found = FALSE;
		for (int i = 0; i < bmdList.Count(); i++)
			{
			if (bmdList[i] == tbmd)
				{
				found = TRUE;
				i = bmdList.Count();

				}
			}	
		if (!found) bmdList.Append(1,&tbmd,1);
		hitRec = hitRec->Next();
		}
	hitRec = head;


	for (int i = 0; i < bmdList.Count(); i++)
		{
		if (theHold.Holding() ) theHold.Put(new SelectionRestore(this,bmdList[i]));
		}


	BOOL add = GetKeyState(VK_CONTROL)<0;
	BOOL sub = GetKeyState(VK_MENU)<0;

	if (!add && !sub) 
		{
		for (int j = 0; j < bmdList.Count(); j++)
			{
			for (int i =0;i<bmdList[j]->selected.GetSize();i++)
				bmdList[j]->selected.Set(i,FALSE);
			}
		}
	int Count = 0;
	BOOL state = selected;

	BoneHitDataClass *bhd;

	int mode = -1;


	while (hitRec) {
		state = hitRec->hitInfo;
		BoneModData *bmd = (BoneModData*)hitRec->modContext->localData;
		if (sub)
			{
			 if (state < bmd->selected.GetSize()) bmd->selected.Set(state,FALSE);
			}
		else 
			{
			
			bhd = (BoneHitDataClass *) hitRec->hitData;
			if (bhd->VertexId == -1)
				{
				mode = 1;
				if (ModeBoneIndex == bhd->BoneId)
					{
					ModeBoneIndex = bhd->BoneId;
					ModeBoneEnvelopeIndex = bhd->CrossId;
					ModeBoneEndPoint = bhd->EndPoint;
					ModeBoneEnvelopeIndex = bhd->CrossId;
					ModeBoneEnvelopeSubType = bhd->CrossHandleId;
		
					}
				else
					{
					ModeBoneIndex = bhd->BoneId;
					ModeBoneEnvelopeIndex = -1;
					ModeBoneEndPoint = -1;
					ModeBoneEnvelopeIndex = -1;
					ModeBoneEnvelopeSubType = -1;

					}
				UpdatePropInterface();

				}
			else bmd->selected.Set(state,TRUE);
			}

		
		hitRec = hitRec->Next();
		Count++;
		}	
	for (i = 0; i < bmdList.Count(); i++)
		{
		BoneModData *bmd = bmdList[i];
		
		if (bmd->selected.NumberSet() > 0)
			{
			EnableEffect(TRUE);
// JBW: macro-recorder
			macroRecorder->FunctionCall(_T("skinSelectVertices"), 2, 0, mr_reftarg, this, mr_bitarray, &bmd->selected);


			}
			else EnableEffect(FALSE);

	
		if (mode >0 )
			{
			Point3 p;
//clear selection flags;
			for (int bct = 0; bct < BoneData.Count(); bct++)
				{
				BoneData[bct].end1Selected = FALSE;
				BoneData[bct].end2Selected = FALSE;
				for (int cct = 0; cct < BoneData[bct].CrossSectionList.Count(); cct++)
					{
					BoneData[bct].CrossSectionList[cct].innerSelected = FALSE;
					BoneData[bct].CrossSectionList[cct].outerSelected = FALSE;
					}

				}
			if (ModeBoneEndPoint == 0)
				{
				BoneData[ModeBoneIndex].end1Selected = TRUE;
				Point3 tp;
				if (ip)
					GetEndPoints(bmd, ip->GetTime(), bmd->localCenter, tp, ModeBoneIndex);
//			macroRecorder->FunctionCall(_T("select"), 1, 0, mr_index, mr_prop, _T("endpoint1"), 
//						mr_reftarg, this, mr_bitarray, &bmd->selected);

				}
			else if (ModeBoneEndPoint == 1)
				{
				BoneData[ModeBoneIndex].end2Selected = TRUE;
				Point3 tp;
				if (ip)
					GetEndPoints(bmd, ip->GetTime(), tp, bmd->localCenter, ModeBoneIndex);

//			p = BoneData[ModeBoneIndex].l2;

				}
			else if (ModeBoneEnvelopeIndex>=0)
				{
//			EnableRadius(TRUE);



				Point3 align;
				Point3 vec;

				Point3 p_edge[8];
				Point3 ept(0.0f,0.0f,0.0f);

				ObjectState os;
				ShapeObject *pathOb = NULL;

				Interval valid;
				Matrix3 ntm = BoneData[ModeBoneIndex].Node->GetObjTMBeforeWSM(ip->GetTime(),&valid);

				if ((BoneData[ModeBoneIndex].flags & BONE_SPLINE_FLAG) && (BoneData[ModeBoneIndex].Node != NULL))
					{
					ObjectState os = BoneData[ModeBoneIndex].Node->EvalWorldState(ip->GetTime());
					pathOb = (ShapeObject*)os.obj;
					ept = pathOb->InterpCurve3D(ip->GetTime(), 0,BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].u);
					align = pathOb->TangentCurve3D(ip->GetTime(), 0,BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].u);
					ept = ept * bmd->tmCacheToObjectSpace[ModeBoneIndex];
					align = VectorTransform(bmd->tmCacheToObjectSpace[ModeBoneIndex],align);

					}
				else
					{
					Point3 l1,l2;
					Interval v;
					GetEndPointsLocal(bmd,ip->GetTime(),l1,l2, ModeBoneIndex);

					align = l2-l1;
					Point3 nvec = align;
					ept = l1;
					ept = ept + nvec * BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].u;
					}

				float inner, outer;
				Interval v;
				BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].InnerControl->GetValue(0,&inner,v);
				BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].OuterControl->GetValue(0,&outer,v);

				GetCrossSection(ept, align, inner,
							BoneData[ModeBoneIndex].temptm,  p_edge);
				GetCrossSection(ept, align, outer,
							BoneData[ModeBoneIndex].temptm,  &p_edge[4]);

				if (ModeBoneEnvelopeSubType < 4)
					{
					pblock_param->SetController(PB_ERADIUS, BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].InnerControl, FALSE);
					BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].innerSelected = TRUE;

					}
				else{
					pblock_param->SetController(PB_ERADIUS, BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].OuterControl, FALSE);
					BoneData[ModeBoneIndex].CrossSectionList[ModeBoneEnvelopeIndex].outerSelected = TRUE;
					}
				p = p_edge[ModeBoneEnvelopeSubType] * bmd->BaseTM * Inverse(ntm);
				bmd->localCenter = p_edge[ModeBoneEnvelopeSubType];

				}
		
		
			if  (ModeBoneEnvelopeIndex == -1) EnableRadius(FALSE);
			else EnableRadius(TRUE);


			p1Temp->SetValue(0,p,TRUE,CTRL_ABSOLUTE);

		
//select in list box also 
			int rsel = ConvertSelectedBoneToListID(ModeBoneIndex);

			SendMessage(GetDlgItem(hParam,IDC_LIST1),
					LB_SETCURSEL ,rsel,0);

			if (BoneData[ModeBoneIndex].flags & BONE_LOCK_FLAG)
				pblock_param->SetValue(PB_LOCK_BONE,0,1);
			else
				pblock_param->SetValue(PB_LOCK_BONE,0,0);
			if (BoneData[ModeBoneIndex].flags & BONE_ABSOLUTE_FLAG)
				pblock_param->SetValue(PB_ABSOLUTE_INFLUENCE,0,1);
			else
				pblock_param->SetValue(PB_ABSOLUTE_INFLUENCE,0,0);




			}

		UpdateEffectSpinner(bmd);

		int nset = bmd->selected.NumberSet();
		int total = bmd->selected.GetSize();

		NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
		}
	}



void BonesDefMod::UpdateEffectSpinner(BoneModData*bmd)
{
	if (bmd->selected.NumberSet() > 0)
//   if ((Count == 1) && (state<bmd->VertexDataCount))
		{
//get selected bone	
		int rsel = 0;
		rsel = SendMessage(GetDlgItem(hParam,IDC_LIST1),
					LB_GETCURSEL ,0,0);

		int tsel = ConvertSelectedListToBoneID(rsel);


		int sct = 0;
		float v = -1.0f;
		BOOL first = TRUE;
		BOOL idnt = FALSE;

		for (int i = 0; i < bmd->selected.GetSize(); i++)
			{
			if (bmd->selected[i])
				{
				BOOL match = FALSE;
				for (int ct =0 ; ct <bmd->VertexData[i]->d.Count(); ct++)
					{

					if (bmd->VertexData[i]->d[ct].Bones == ModeBoneIndex)
						{
						match = TRUE;
						if (first)
							{
							v = RetrieveNormalizedWeight(bmd,i,ct);
//							v = bmd->VertexData[i]->d[ct].Influences;
							first = FALSE;
							}
						else if (v != RetrieveNormalizedWeight(bmd,i,ct))
							{	
							idnt = TRUE;

							}
						}
					}
				 if (!match) 
					{
					if (first)
						{
						v = 0.0f;
						first = FALSE;
						}
					else if (v != 0.0f)
						{
						idnt = TRUE;
						}
					}


				}

			}

		if (idnt)
			{
			ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hParam,IDC_EFFECTSPIN));
			spin2->SetIndeterminate(TRUE);
			}
		else 
			{
			ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hParam,IDC_EFFECTSPIN));
			spin2->SetIndeterminate(FALSE);
			pblock_param->SetValue(PB_EFFECT,0,v);
			bmd->effect = v;
			}



		}

}

void BonesDefMod::ClearSelection(int selLevel)
	{
	//if (theHold.Holding()) theHold.Put(new SelRestore(this));

	if (selLevel == 1)
		{
		ModContextList mcList;		
		INodeTab nodes;

		ip->GetModContexts(mcList,nodes);
		int objects = mcList.Count();


		for ( int i = 0; i < objects; i++ ) 
			{
			BoneModData *bmd = (BoneModData*)mcList[i]->localData;

			if (theHold.Holding() ) theHold.Put(new SelectionRestore(this,bmd));

			for (int i =0;i<bmd->selected.GetSize();i++)
				bmd->selected.Set(i,FALSE);

			UpdateEffectSpinner(bmd);

			NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
			}
		}
	}

void BonesDefMod::SelectAll(int selLevel)
	{
	if (selLevel == 1)
		{
		ModContextList mcList;		
		INodeTab nodes;

		ip->GetModContexts(mcList,nodes);
		int objects = mcList.Count();

		for ( int i = 0; i < objects; i++ ) 
			{
			BoneModData *bmd = (BoneModData*)mcList[i]->localData;

			if (theHold.Holding() ) theHold.Put(new SelectionRestore(this,bmd));

			for (int i =0;i<bmd->selected.GetSize();i++)
				bmd->selected.Set(i,TRUE);

			UpdateEffectSpinner(bmd);
	
			NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
			}
		}
	}


int BonesDefMod::HoldWeights()
	{
	ModContextList mcList;		
	INodeTab nodes;


	theHold.SuperBegin();
	if (ip)
		{
		ip->GetModContexts(mcList,nodes);
		int objects = mcList.Count();
		theHold.Begin();
		for ( int i = 0; i < objects; i++ ) 
			{
			BoneModData *bmd = (BoneModData*)mcList[i]->localData;

			theHold.Put(new WeightRestore(this,bmd));


			}
		theHold.Accept(GetString(IDS_PW_WEIGHTCHANGE));
		
		}
	return 1;
	}

int BonesDefMod::AcceptWeights(BOOL accept)
	{

//	theHold.Accept(GetString(IDS_PW_WEIGHTCHANGE));
	if (accept) theHold.SuperAccept(GetString(IDS_PW_WEIGHTCHANGE));
	else theHold.SuperCancel();
	return 1;
	}


void BonesDefMod::InvertSelection(int selLevel)
	{
	if (selLevel == 1)
		{
		ModContextList mcList;		
		INodeTab nodes;

		ip->GetModContexts(mcList,nodes);
		int objects = mcList.Count();

		for ( int i = 0; i < objects; i++ ) 
			{
			BoneModData *bmd = (BoneModData*)mcList[i]->localData;

			for (int i =0;i<bmd->selected.GetSize();i++)
				{
				BOOL v = !bmd->selected[i];
				bmd->selected.Set(i,v);
				}

			UpdateEffectSpinner(bmd);

			NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
			}
		}
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}


void BonesDefMod::EnableRadius(BOOL enable)

{

if (enable)
	SpinnerOn(hParam,IDC_ERADIUSSPIN,IDC_ERADIUS);
else SpinnerOff(hParam,IDC_ERADIUSSPIN,IDC_ERADIUS);

}

void BonesDefMod::EnableEffect(BOOL enable)
{

if (enable)
	SpinnerOn(hParam,IDC_EFFECTSPIN,IDC_EFFECT);
else SpinnerOff(hParam,IDC_EFFECTSPIN,IDC_EFFECT);

}


void BonesDefMod::EnableButtons()
{

				if (iCrossSectionButton!=NULL)
					iCrossSectionButton->Enable();
				if (iPaintButton!=NULL)
					iPaintButton->Enable();
				EnableWindow(GetDlgItem(hParam,IDC_CREATE_REMOVE_SECTION),TRUE);


				EnableWindow(GetDlgItem(hParam,IDC_FILTER_VERTICES_CHECK),TRUE);
				EnableWindow(GetDlgItem(hParam,IDC_FILTER_BONES_CHECK),TRUE);
				EnableWindow(GetDlgItem(hParam,IDC_FILTER_ENVELOPES_CHECK),TRUE);
				EnableWindow(GetDlgItem(hParam,IDC_DRAWALL_ENVELOPES_CHECK),TRUE);
				EnableWindow(GetDlgItem(hParam,IDC_DRAW_VERTICES_CHECK),TRUE);

// bug fix 206160 9/8/99	watje
			if (iAbsolute!=NULL)
				iAbsolute->Enable();
			if (iEnvelope!=NULL)
				iEnvelope->Enable();
			if (iFalloff!=NULL)
				iFalloff->Enable();
			if (iCopy!=NULL)
				iCopy->Enable();
			if (iPaste!=NULL)
				iPaste->Enable();




}
void BonesDefMod::DisableButtons()
{

			if (iCrossSectionButton!=NULL)
				iCrossSectionButton->Disable();
			if (iPaintButton!=NULL)
				iPaintButton->Disable();

			EnableWindow(GetDlgItem(hParam,IDC_CREATE_REMOVE_SECTION),FALSE);


			EnableWindow(GetDlgItem(hParam,IDC_FILTER_VERTICES_CHECK),FALSE);
			EnableWindow(GetDlgItem(hParam,IDC_FILTER_BONES_CHECK),FALSE);
			EnableWindow(GetDlgItem(hParam,IDC_FILTER_ENVELOPES_CHECK),FALSE);
			EnableWindow(GetDlgItem(hParam,IDC_DRAWALL_ENVELOPES_CHECK),FALSE);
			EnableWindow(GetDlgItem(hParam,IDC_DRAW_VERTICES_CHECK),FALSE);


// bug fix 206160 9/8/99	watje
			if (iAbsolute!=NULL)
				iAbsolute->Disable();
			if (iEnvelope!=NULL)
				iEnvelope->Disable();
			if (iFalloff!=NULL)
				iFalloff->Disable();
			if (iCopy!=NULL)
				iCopy->Disable();
			if (iPaste!=NULL)
				iPaste->Disable();
			   

   
   


}

void BonesDefMod::ActivateSubobjSel(int level, XFormModes& modes)
	{
//	static BOOL isAnimating;
	switch (level) {
		case 0:
/*			GetCOREInterface()->EnableAnimateButton(TRUE);
			if (isAnimating) 
				{
				AnimateOn();
				GetCOREInterface()->SetAnimateButtonState(TRUE);
				}
*/
			DisableButtons();


			if ((ip) && (ip->GetCommandMode() == PaintMode)) {
				ip->SetStdCommandMode(CID_OBJMOVE);
				return;
				}


			if ((ip) && (ip->GetCommandMode() == CrossSectionMode)) {
				ip->SetStdCommandMode(CID_OBJMOVE);
				return;
				}


			break;
		case 1: // Points
			{
/*			isAnimating = Animating();
			GetCOREInterface()->EnableAnimateButton(FALSE);
			GetCOREInterface()->SetAnimateButtonState(FALSE);
			AnimateOff();
*/
			int bct = 0;
			for (int i =0; i < BoneData.Count(); i ++)
				{
				if (!(BoneData[i].flags &  BONE_DEAD_FLAG)) bct++;
				}
//			if (BoneData.Count() > 0)
			if (bct > 0)
				{
				EnableButtons();
				}

			if (ModeBoneEnvelopeIndex != -1)
				EnableRadius(TRUE);
			else EnableRadius(FALSE);


			modes = XFormModes(moveMode,NULL,NULL,NULL,NULL,NULL);
			break;		
			}
		}
	NotifyDependents(FOREVER,PART_DISPLAY,REFMSG_CHANGE);
	}


int BonesDefMod::SubNumToRefNum(int subNum)
	{
	return -1;
	}

RefTargetHandle BonesDefMod::GetReference(int i)

	{
	if (i==PBLOCK_PARAM_REF)
		{
		return (RefTargetHandle)pblock_param;
		}
	else if (i == POINT1_REF)
		{
		return (RefTargetHandle)p1Temp;
		}
	else 
		{
//		int id = i -2;
//		RefTargetHandle t;
		for (int ct = 0; ct < BoneData.Count(); ct++)
			{
			if (i == BoneData[ct].BoneRefID)
				{
				return (RefTargetHandle)BoneData[ct].Node;
				}
			else if (i == BoneData[ct].RefEndPt1ID)
				{
				return (RefTargetHandle)BoneData[ct].EndPoint1Control;
				}
			else if (i == BoneData[ct].RefEndPt2ID)
				{
				return (RefTargetHandle)BoneData[ct].EndPoint2Control;
				}
			else
				{
				for (int j=0;j<BoneData[ct].CrossSectionList.Count();j++)
					{
					if (i == BoneData[ct].CrossSectionList[j].RefInnerID)
						{
						return (RefTargetHandle)BoneData[ct].CrossSectionList[j].InnerControl;
						}
					else if (i == BoneData[ct].CrossSectionList[j].RefOuterID)
						{
						return (RefTargetHandle)BoneData[ct].CrossSectionList[j].OuterControl;
						}

					}
				}
			}
		
//		else return NULL;
		}
	return NULL;
	}

void BonesDefMod::SetReference(int i, RefTargetHandle rtarg)
	{
	if (i==PBLOCK_PARAM_REF)
		{
		pblock_param = (IParamBlock*)rtarg;
		}
	else if (i == POINT1_REF)
		{

		p1Temp     = (Control*)rtarg; 
		}
	else 
		{
//		int id = i -2;
		for (int ct = 0; ct < BoneData.Count(); ct++)
			{
			if (i == BoneData[ct].BoneRefID)
				{
				BoneData[ct].Node = (INode*)rtarg;
				}
			if (i == BoneData[ct].RefEndPt1ID)
				{
				BoneData[ct].EndPoint1Control = (Control*)rtarg;
				}
			if (i == BoneData[ct].RefEndPt2ID)
				{
				BoneData[ct].EndPoint2Control = (Control*)rtarg;

				}
			for (int j=0;j<BoneData[ct].CrossSectionList.Count();j++)
				{
				if (i == BoneData[ct].CrossSectionList[j].RefInnerID)
					{

					BoneData[ct].CrossSectionList[j].InnerControl  = (Control*)rtarg ;
					}
				if (i == BoneData[ct].CrossSectionList[j].RefOuterID)
					{
					BoneData[ct].CrossSectionList[j].OuterControl  = (Control*)rtarg ;
					}

				}
			}
		}
/*
		{

		int id = i-2;
		BoneData[id].Node = (INode*)rtarg;
		}
*/

	}

TSTR BonesDefMod::SubAnimName(int i)
	{
	return _T("");
	}

RefResult BonesDefMod::NotifyRefChanged(
		Interval changeInt,RefTargetHandle hTarget, 
		PartID& partID, RefMessage message)
	{
	int i;
	Interface *tip;


	switch (message) {
		case REFMSG_CHANGE:
			if (editMod==this && pmapParam) pmapParam->Invalidate();
			tip = GetCOREInterface();
			if (tip != NULL)
				{
				for (i =0;i<BoneData.Count();i++)
//				for (i =0;i<MAX_NUMBER_BONES;i++)
					{
					if ((BoneData[i].Node != NULL) && 
						(BoneData[i].Node == hTarget) && 
						(tip->GetTime() == RefFrame) )
						{
						BoneMoved = TRUE;
						}
					if ((BoneData[i].Node != NULL) && 
						(BoneData[i].Node == hTarget)  
						)
						{
//check if bone was spline 
						if (BoneData[i].flags & BONE_SPLINE_FLAG)
							{
							splineChanged = TRUE;
							whichSplineChanged = i;
							}

						}

					}
				}

			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_EFFECT:	 gpd->dim = stdNormalizedDim; break;
				case PB_REF_FRAME:	 gpd->dim = stdNormalizedDim; break;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;			
			switch (gpn->index) {

				case PB_EFFECT: gpn->name = GetString(IDS_RB_EFFECT); break;
				}
			return REF_STOP; 
			}
		case REFMSG_TARGET_DELETED: {
				for (int j =0;j<BoneData.Count();j++)
					{
					if (hTarget==BoneData[j].Node) 
						{
						RemoveBone(j);
						}
							
					}
				break;
				}

		}
	return REF_SUCCEED;
	}

IOResult BonesDefMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	IOResult res = IO_OK;
	int NodeID = 0;
	

//	VertexData= NULL;
/* FIX THIS move to local mod load
	for (int i = 0; i< bmd->VertexData.Count(); i++)
		{
		if (bmd->VertexData[i] != NULL)
			delete (bmd->VertexData[i]);
		bmd->VertexData[i] = NULL;
		}

	bmd->VertexData.ZeroCount();
	sel.ZeroCount();

*/
//	BoneData.ZeroCount();
	BoneData.New();
	int currentvt = -1;
	ULONG nb;
	int bonecount = 0;
	int MatrixCount = 0;
	reloadSplines = TRUE;

	int bct = 0;


	while (IO_OK==(res=iload->OpenChunk())) {
		int id = iload->CurChunkID();
		switch(id)  {

			case BASE_TM_CHUNK: 
				{
				OldBaseTM.Load(iload);
				OldInverseBaseTM = Inverse(OldBaseTM);
				break;
				}

			case BONE_COUNT_CHUNK: 
				{
				int c;
				iload->Read(&c,sizeof(c),&nb);
//				BoneData.SetCount(c);

				for (int i=0; i<c; i++)  
					{
					BoneDataClass t;
					BoneData.Append(t);
					BoneData[i].Node = NULL;
					BoneData[i].EndPoint1Control = NULL;
					BoneData[i].EndPoint2Control = NULL;
					BoneData[i].CrossSectionList.ZeroCount();
					}
				break;
				}
			case BONE_DATATM_CHUNK: 
				{
//				for (int i = 0; i < BoneData.Count(); i++)
				BoneData[MatrixCount++].tm.Load(iload);
				break;	
				}
			case BONE_NAME_CHUNK: 
				{
				NameTab names;
				int c = BoneData.Count();
				names.Load(iload);

				for (int i = 0; i < c; i++)
					{
					TSTR temp(names[i]);
					BoneData[i].name = temp;
					}

				break;	
				}

			case BONE_DATA_CHUNK: 
				{
				float load_f;
				Point3 load_p;
				int load_i;
				BYTE load_b;

				for (int i = 0; i < BoneData.Count(); i++)
					{
					iload->Read(&load_i,sizeof(load_i),&nb);
					BoneData[i].CrossSectionList.SetCount(load_i);
					for (int j=0;j<BoneData[i].CrossSectionList.Count();j++)
						{
//						iload->Read(&load_f,sizeof(load_f),&nb);
//						BoneData[i].CrossSectionList[j].Inner = load_f;
//						iload->Read(&load_f,sizeof(load_f),&nb);
//						BoneData[i].CrossSectionList[j].Outer = load_f;
						iload->Read(&load_f,sizeof(load_f),&nb);
						BoneData[i].CrossSectionList[j].u = load_f;
						iload->Read(&load_i,sizeof(load_i),&nb);
						BoneData[i].CrossSectionList[j].RefInnerID = load_i;
						iload->Read(&load_i,sizeof(load_i),&nb);
						BoneData[i].CrossSectionList[j].RefOuterID = load_i;

						BoneData[i].CrossSectionList[j].InnerControl = NULL;
						BoneData[i].CrossSectionList[j].OuterControl = NULL;

						BoneData[i].CrossSectionList[j].outerSelected = FALSE;
						BoneData[i].CrossSectionList[j].innerSelected = FALSE;
						BoneData[i].name.Resize(0);
						}
//					iload->Read(&load_p,sizeof(load_p),&nb);
//					BoneData[i].l1 = load_p;
//					iload->Read(&load_p,sizeof(load_p),&nb);
//					BoneData[i].l2 = load_p;
					
					iload->Read(&load_b,sizeof(load_b),&nb);
					BoneData[i].flags = load_b;

					iload->Read(&load_b,sizeof(load_b),&nb);
					BoneData[i].FalloffType = load_b;

					iload->Read(&load_i,sizeof(load_i),&nb);
					BoneData[i].BoneRefID = load_i;

					iload->Read(&load_i,sizeof(load_i),&nb);
					BoneData[i].RefEndPt1ID = load_i;

					iload->Read(&load_i,sizeof(load_i),&nb);
					BoneData[i].RefEndPt2ID = load_i;

					BoneData[i].end1Selected = FALSE;
					BoneData[i].end2Selected = FALSE;


					
					}

				break;
				}
			case BONE_SPLINE_CHUNK: 
				{
				reloadSplines = FALSE;
				for (int i = bct; i < BoneData.Count(); i++)
					{
					if (BoneData[i].flags & BONE_SPLINE_FLAG) 
						{
						BoneData[i].referenceSpline.Load(iload);
						bct= i+1;
						i = BoneData.Count();
						}
					}
				break;
				}



			case VERTEX_COUNT_CHUNK:
				{
				int c;
				iload->Read(&c,sizeof(c),&nb);
				OldVertexDataCount = c;
				OldVertexData.ZeroCount();
				OldVertexData.SetCount(c);
				for (int i=0; i<c; i++) {
					VertexListClass *vc;
					vc = new VertexListClass;
					OldVertexData[i] = vc;
					OldVertexData[i]->modified = FALSE;
					OldVertexData[i]->selected = FALSE;
 					OldVertexData[i]->d.ZeroCount();
					}

				break;

				}
			case VERTEX_DATA_CHUNK:
				{
				for (int i=0; i < OldVertexDataCount; i++)
					{
					int c;
					BOOL load_b;
					iload->Read(&c,sizeof(c),&nb);
					OldVertexData[i]->d.SetCount(c);

					iload->Read(&load_b,sizeof(load_b),&nb);
					OldVertexData[i]->modified = load_b;
					float load_f;
					int load_i;
					Point3 load_p;
					for (int j=0; j<c; j++) {
						iload->Read(&load_i,sizeof(load_i),&nb);
						iload->Read(&load_f,sizeof(load_f),&nb);
 						OldVertexData[i]->d[j].Bones = load_i;
						OldVertexData[i]->d[j].Influences =load_f;
						OldVertexData[i]->d[j].normalizedInfluences = -1.0f;

						iload->Read(&load_i,sizeof(load_i),&nb);
						OldVertexData[i]->d[j].SubCurveIds =load_i;
						iload->Read(&load_i,sizeof(load_i),&nb);
						OldVertexData[i]->d[j].SubSegIds =load_i;

						iload->Read(&load_f,sizeof(load_f),&nb);
 						OldVertexData[i]->d[j].u = load_f;

						iload->Read(&load_p,sizeof(load_p),&nb);
 						OldVertexData[i]->d[j].Tangents = load_p;

						iload->Read(&load_p,sizeof(load_p),&nb);
 						OldVertexData[i]->d[j].OPoints = load_p;


						}
					}

				break;

				}
			case BONE_BIND_CHUNK: 
				{
				initialXRefTM.Load(iload);
				ULONG id;
				iload->Read(&id,sizeof(ULONG), &nb);
				if (id!=0xffffffff)
					{
					iload->RecordBackpatch(id,(void**)&bindNode);
					}
				break;
				}

			case DELTA_COUNT_CHUNK: 
				{
				int c;
				iload->Read(&c,sizeof(c),&nb);
				endPointDelta.SetCount(c);
				break;
				}

			case DELTA_DATA_CHUNK: 
				{
				for (int i = 0; i < endPointDelta.Count();i++)
					{
					Point3 p;
					iload->Read(&p,sizeof(p),&nb);
					endPointDelta[i] = p;
					}
				break;
				}



			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}	


//build selection list now
//build selection space
/* FIX THIS move into local mod load

    int c = bmd->VertexDataCount+SELMOD*BoneData.Count();
//add m crossection
	for (int i=0;i < BoneData.Count();i++)
		c += BoneData[i].CrossSectionList.Count();
	sel.SetCount(c);
	for (i=0; i<c; i++) 
		sel[i] = FALSE;
*/

//build reftable
	int ref_size = 0;
	for (int i=0;i < BoneData.Count();i++)
		{
		if (BoneData[i].RefEndPt1ID > ref_size) ref_size = BoneData[i].RefEndPt1ID;
		if (BoneData[i].RefEndPt2ID > ref_size) ref_size = BoneData[i].RefEndPt2ID;
		if (BoneData[i].BoneRefID > ref_size) ref_size = BoneData[i].BoneRefID;
		for (int j=0;j < BoneData[i].CrossSectionList.Count();j++)
			{
			if (BoneData[i].CrossSectionList[j].RefInnerID > ref_size) ref_size = BoneData[i].CrossSectionList[j].RefInnerID;
			if (BoneData[i].CrossSectionList[j].RefOuterID > ref_size) ref_size = BoneData[i].CrossSectionList[j].RefOuterID;

			}

		}
	RefTable.SetCount(ref_size+2);
	for (i=0;i < RefTable.Count();i++)
		RefTable[i] = 0;
	for (i=0;i < BoneData.Count();i++)
		{
		if (BoneData[i].flags != BONE_DEAD_FLAG)
			{
			RefTable[BoneData[i].RefEndPt1ID-2] = 1;
			RefTable[BoneData[i].RefEndPt2ID-2] = 1;
			RefTable[BoneData[i].BoneRefID-2] = 1; 
			for (int j=0;j < BoneData[i].CrossSectionList.Count();j++)
				{
				RefTable[BoneData[i].CrossSectionList[j].RefInnerID-2] = 1;
				RefTable[BoneData[i].CrossSectionList[j].RefOuterID-2] = 1;
				}
			}

		}

//for (int k = 0;  k < RefTable.Count(); k++)
//	{
//	DebugPrint(" Load id %d  refid %d\n",k,RefTable[k]);
//	}



//	int s;

	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,PBLOCK_PARAM_REF));


	return IO_OK;
	}

IOResult BonesDefMod::Save(ISave *isave)
	{
	Modifier::Save(isave);
	ULONG nb;


/*
	isave->BeginChunk(BASE_TM_CHUNK);
	bmd->BaseTM.Save(isave);
	isave->EndChunk();
*/

	int c = BoneData.Count();
	isave->BeginChunk(BONE_COUNT_CHUNK);
	isave->Write(&c,sizeof(c),&nb);
	isave->EndChunk();


//write bone chunks

	for (int i = 0; i < c; i++)
		{
		isave->BeginChunk(BONE_DATATM_CHUNK);
		BoneData[i].tm.Save(isave);
		isave->EndChunk();
		}
	
	isave->BeginChunk(BONE_DATA_CHUNK);
	for (i = 0; i < c; i++)
		{
		Point3 save_pt;
		float save_f;
		BYTE save_b;
		int save_i;

		save_i = BoneData[i].CrossSectionList.Count();
		isave->Write(&save_i,sizeof(save_i),&nb);

		for (int j = 0; j < BoneData[i].CrossSectionList.Count(); j++)
			{
//			save_f = BoneData[i].CrossSectionList[j].Inner;
//			isave->Write(&save_f,sizeof(save_f),&nb);
//			save_f = BoneData[i].CrossSectionList[j].Outer;
//			isave->Write(&save_f,sizeof(save_f),&nb);
			save_f = BoneData[i].CrossSectionList[j].u;
			isave->Write(&save_f,sizeof(save_f),&nb);

			save_i = BoneData[i].CrossSectionList[j].RefInnerID;
			isave->Write(&save_i,sizeof(save_i),&nb);

			save_i = BoneData[i].CrossSectionList[j].RefOuterID;
			isave->Write(&save_i,sizeof(save_i),&nb);

			}

//		save_pt = BoneData[i].l1;
//		isave->Write(&save_pt,sizeof(save_pt),&nb);

//		save_pt = BoneData[i].l2;
//		isave->Write(&save_pt,sizeof(save_pt),&nb);

		save_b = BoneData[i].flags;
		isave->Write(&save_b,sizeof(save_b),&nb);

		save_b = BoneData[i].FalloffType;
		isave->Write(&save_b,sizeof(save_b),&nb);

		save_i = BoneData[i].BoneRefID;
		isave->Write(&save_i,sizeof(save_i),&nb);

		save_i = BoneData[i].RefEndPt1ID;
		isave->Write(&save_i,sizeof(save_i),&nb);

		save_i = BoneData[i].RefEndPt2ID;
		isave->Write(&save_i,sizeof(save_i),&nb);



		}
	isave->EndChunk();


	for (i = 0; i < c; i++)
		{
		if ((BoneData[i].flags & BONE_SPLINE_FLAG) && (BoneData[i].Node != NULL) )
			{
			isave->BeginChunk(BONE_SPLINE_CHUNK);
			BoneData[i].referenceSpline.Save(isave);
			isave->EndChunk();
			}
		}


	if (bindNode)
		{
		isave->BeginChunk(BONE_BIND_CHUNK);
		initialXRefTM.Save(isave);
		
		ULONG id = isave->GetRefID(bindNode);
		isave->Write(&id,sizeof(ULONG),&nb);

		isave->EndChunk();
		}


	NameTab names;
//	names.SetCount(c);
	for (i = 0; i < c; i++)
		{	
		TSTR temp(BoneData[i].name);
		names.AddName(temp);
		}

	isave->BeginChunk(BONE_NAME_CHUNK);
	names.Save(isave);
	isave->EndChunk();


	c = endPointDelta.Count();
	isave->BeginChunk(DELTA_COUNT_CHUNK);
	isave->Write(&c,sizeof(c),&nb);
	isave->EndChunk();

	isave->BeginChunk(DELTA_DATA_CHUNK);
	for (i = 0; i < c; i++)
		{	
		Point3 p = endPointDelta[i];
		isave->Write(&p,sizeof(p),&nb);
		}
	isave->EndChunk();

	return IO_OK;
	}

Interval BonesDefMod::LocalValidity(TimeValue t)
	{
	Interval valid = FOREVER;
//	p1Temp->GetValue(t,&pt,iv,CTRL_ABSOLUTE);
//	for (int i = 0; i<MAX_NUMBER_BONES;i++)
	for (int i =0;i<BoneData.Count();i++)
		{
		if (BoneData[i].Node != NULL) 
			{
			BoneData[i].Node->GetObjTMBeforeWSM(t,&valid);
			if (BoneData[i].flags & BONE_SPLINE_FLAG)
				{
				ObjectState osp = BoneData[i].Node->EvalWorldState (t);
				valid &= osp.obj->ObjectValidity (t);
				}

			}
		}
	return valid;
	}




Point3 BonesDefMod::VertexAnimation(TimeValue t, BoneModData * bmd, int vertex, int bone, Point3 p)
{
Point3 ps(0.0f,0.0f,0.0f),pr(0.0f,0.0f,0.0f),pdef(0.0f,0.0f,0.0f),pt(0.0f,0.0f,0.0f);
Point3 MovedU,MovedTan;

int bid = bmd->VertexData[vertex]->d[bone].Bones;
if (BoneData[bid].Node == NULL) return p;

ShapeObject *pathOb = NULL;
Interface *ip = GetCOREInterface();
//TimeValue t;
//t = ip->GetTime();
ObjectState os = BoneData[bid].Node->EvalWorldState(t);
pathOb = (ShapeObject*)os.obj;

int cid = bmd->VertexData[vertex]->d[bone].SubCurveIds;
int sid = bmd->VertexData[vertex]->d[bone].SubSegIds;
float u = bmd->VertexData[vertex]->d[bone].u;


Matrix3 ntm = BoneData[bid].Node->GetObjectTM(t);	
Matrix3 tm    = Inverse(bmd->BaseTM * Inverse(ntm));

//Matrix3 tm = bmd->BaseTM * Inverse(ntm);

MovedU = pathOb->InterpPiece3D(t, cid,sid ,u );
MovedU = MovedU * tm;
MovedTan = pathOb->TangentPiece3D(t, cid, sid, u);
MovedTan = VectorTransform(tm,MovedTan);

Point3 OPoint;
OPoint = bmd->VertexData[vertex]->d[bone].OPoints * tm;
Point3 OTan = VectorTransform(tm,bmd->VertexData[vertex]->d[bone].Tangents);

float s = 1.0f;  //scale 
float angle = 0.0f;
float influ = RetrieveNormalizedWeight(bmd,vertex,bone);

//float influ = VertexData[vertex].d[bone].Influences;

OTan = Normalize(OTan);
MovedTan = Normalize(MovedTan);
if ( OTan != MovedTan)
 angle = (float) acos(DotProd(OTan,MovedTan)) * influ;



Point3 perp = CrossProd(OTan,MovedTan);
Matrix3 RotateMe(1);

RotateMe = RotAngleAxisMatrix(Normalize(perp), angle);
//RotateMe.Translate(-OPoint);


ps = p-OPoint;
pr = ps * RotateMe + OPoint;
pt = (MovedU - OPoint) * influ;
pdef = pr + pt;
return pdef;

}

class BonesDefDeformer: public Deformer {
	public:
		BonesDefMod *Cluster;
		BoneModData *bmd;
		TimeValue t;
		BonesDefDeformer(BonesDefMod *C, BoneModData *bm, TimeValue tv){Cluster = C;bmd = bm; t= tv;}
		Point3 Map(int i, Point3 p) {
			
			if (bmd->VertexDataCount>0)
				{

				if (bmd->VertexData[i]->d.Count() > 0 )
					{

					Point3 tp(0.0f,0.0f,0.0f);
					float influence = 0.0f;
					if (bmd->VertexData[i]->d.Count()==1)
						{
						Point3 vec;
						float influ = Cluster->RetrieveNormalizedWeight(bmd,i,0);

						vec = (p*Cluster->BoneData[bmd->VertexData[i]->d[0].Bones].temptm);
						vec = vec - p;
						vec = vec * influ;//Cluster->VertexData[i].d[0].Influences;
						p += vec;
						int bid;
						bid = bmd->VertexData[i]->d[0].Bones;
						if ((Cluster->BoneData[bid].flags & BONE_SPLINE_FLAG) && (influ != 0.0f))
							{
							p = Cluster->VertexAnimation(t,bmd,i,0,p);
							}

						return p;
						}
					for (int j=0;j<bmd->VertexData[i]->d.Count();j++)
						{
						float influ = Cluster->RetrieveNormalizedWeight(bmd,i,j);

						if (influ != 0.0f)
							{
							tp  += (p*Cluster->BoneData[bmd->VertexData[i]->d[j].Bones].temptm)*influ;
							influence += influ;
							}
						}
//do vertex snimation if it is a splineanimation

					for (j=0;j<bmd->VertexData[i]->d.Count();j++)
						{
						int bid;
						bid = bmd->VertexData[i]->d[j].Bones;

						if (Cluster->BoneData[bid].flags & BONE_SPLINE_FLAG) 
							{
							float influ = Cluster->RetrieveNormalizedWeight(bmd,i,j);

							if (influ != 0.0f)
								
								{
								tp = Cluster->VertexAnimation(t,bmd,i,j,tp);
								}
							}
						}

					if (influence > 0.00001)
						return tp;
	
					}
				else return p;
				}
			return p;
			}
	};



class StaticBonesDefDeformer: public Deformer {
	public:
		BonesDefMod *Cluster;
		BoneModData *bmd;
		TimeValue t;
		StaticBonesDefDeformer(BonesDefMod *C, BoneModData *bm, TimeValue tv){Cluster = C;bmd = bm; t= tv;}
		Point3 Map(int i, Point3 p) {
			
			if (bmd->VertexDataCount>0)
				{
				if ( i <bmd->VertexData.Count())
					p = bmd->VertexData[i]->LocalPos;
				}
			return p;
			}
	};

void BonesDefMod::RecomputeAllBones(BoneModData *bmd, TimeValue t, ObjectState *os)

{

//watje 9-7-99  198721 
		bmd->reevaluate = FALSE;
		int nv = os->obj->NumPoints();
		if ( (bmd->VertexDataCount != nv) || (reset))
			{
			reset = FALSE;
			bmd->VertexDataCount = nv;
			for (int i = 0; i < bmd->VertexData.Count(); i++)
				{
				if (bmd->VertexData[i] != NULL)
					delete (bmd->VertexData[i]);
				bmd->VertexData[i] = NULL;
				}
			bmd->VertexData.ZeroCount();
			bmd->VertexData.SetCount(nv);
//new char[sizeof( str )];

			for (i=0; i<nv; i++) {
				VertexListClass *vc;
				vc = new VertexListClass;
				bmd->VertexData[i] = vc;
				bmd->VertexData[i]->modified = FALSE;
				bmd->VertexData[i]->selected = FALSE;
 				bmd->VertexData[i]->d.ZeroCount();;

				}
			}


		int bonecount = 0;
		int crosscount = 0;
		for (int i =0;i<BoneData.Count();i++)
			{
			if (BoneData[i].Node != NULL)
				{
				bonecount++;
				for (int ccount = 0; ccount < BoneData[i].CrossSectionList.Count();ccount++)
					crosscount++;
				}
			}

//build bounding box list for hit testing;
		Tab<Box3> BBoxList;
		BBoxList.ZeroCount();
		for ( i =0;i<BoneData.Count();i++) 
			{
			Point3 l1,l2;

	
			Box3 b;
			float Outer,l = 0.0f;
			if (BoneData[i].Node != NULL)
				{
				if ((BoneData[i].flags & BONE_SPLINE_FLAG) 	&& (BoneData[i].Node != NULL))

					{
					ObjectState tos;
					tos = BoneData[i].Node->EvalWorldState(RefFrame);
//get bounding box
					tos.obj->GetDeformBBox(RefFrame,b);
					
					Interval valid;
//watje 10-7-99 212059
					Matrix3 ntm = Inverse(BoneData[i].tm);
//					Matrix3 ntm = BoneData[i].Node->GetObjTMBeforeWSM(RefFrame,&valid);

//					Point3 pt = p * ntm  * bmd->InverseBaseTM;

//					b = b*Inverse(BoneData[i].tm);
					b = b * ntm * bmd->InverseBaseTM;

	
					}
				else
					{
	
//					GetEndPointsLocal(bmd,t,l1, l2, i);
					Interval valid;
//watje 3-11-99
					GetEndPoints(bmd,RefFrame,l1, l2, i);

//					BoneData[i].EndPoint1Control->GetValue(RefFrame,&l1,valid);
//					BoneData[i].EndPoint2Control->GetValue(RefFrame,&l2,valid);

//					Matrix3 ntm = BoneData[i].Node->GetObjTMBeforeWSM(RefFrame,&valid);

//					l1 = l1 * ntm * bmd->InverseBaseTM;
//					l2 = l2 * ntm * bmd->InverseBaseTM;
					b.Init();
					b.MakeCube(l1,1.0f);
					b += l2;

					}
				for (int ccount = 0; ccount < BoneData[i].CrossSectionList.Count();ccount++)
					{
					float inner;

					GetCrossSectionRanges(inner, Outer, i, ccount);
					if (inner>Outer) Outer  = inner;
					if (Outer > l ) l = Outer;
					}
				b.EnlargeBy(l);


				}

			BBoxList.Append(1,&b,1);

			}	

//Get largest radius

//New Fallof method
 		for (i=0; i<nv; i++) {
//get total distance

			float TotalDistance = 0.0f;
			Point3 p,BoneCenter;		
			if (!bmd->VertexData[i]->modified)
				{

//				VertexData[i]->d.ZeroCount();
				p = os->obj->GetPoint(i);

				int FullStrength =0;
				for (int j =0;j<BoneData.Count();j++) 
					{	
					if (BoneData[j].Node != NULL) 

						{
						if (BBoxList[j].Contains(p)) 
//						if (1) 
							{
							int Bone;
							float Influence = 1.0f;
							Bone = j;
							Point3 l1,l2;



							GetEndPoints(bmd,t,l1, l2, j);
						

							float LineU,SplineU = 0.0f;
							Point3 op,otan;
							int cid,sid;
							if ((BoneData[j].flags & BONE_SPLINE_FLAG) && (BoneData[j].Node != NULL))
								{
//3-29-99								ShapeObject *pathOb = NULL;
//								ObjectState os = BoneData[j].Node->EvalWorldState(RefFrame);
//								pathOb = (ShapeObject*)os.obj;

								Interval valid;
//watje 10-7-99 212059
								Matrix3 ntm = BoneData[j].tm;
//								Matrix3 ntm = BoneData[j].Node->GetObjTMBeforeWSM(RefFrame,&valid);

//watje 10-7-99 212059
								ntm =bmd->BaseTM * ntm;
//								ntm =bmd->BaseTM * Inverse(ntm);


//								Influence = SplineToPoint(p,pathOb,LineU,op,otan,cid,sid,ntm);
								Influence = SplineToPoint(p,
														  &BoneData[j].referenceSpline,
														  LineU,op,otan,cid,sid,ntm);

								SplineU = LineU;
								}
							else
								{

								Influence = LineToPoint(p,l1,l2,LineU);
								}

//find cross section that bound this point
							int StartCross = 0, EndCross = 0;
							float tu = ModifyU(t,LineU,  j, sid);

							for (int ccount = 0; ccount < BoneData[j].CrossSectionList.Count();ccount++)
								{
								if (BoneData[j].CrossSectionList[ccount].u>=tu)
									{
									EndCross =ccount;
									ccount = BoneData[j].CrossSectionList.Count();
									}
								}
							StartCross = EndCross -1;
	
							if (StartCross == -1)
								{
								StartCross = 0;
								EndCross++;
								}
							Influence = ComputeInfluence(t,Influence,LineU, j,StartCross, EndCross,sid);

							if (Influence != 0.0f)
								{
								VertexInfluenceListClass td;
								td.Bones = Bone;
								td.Influences = Influence;
								td.normalizedInfluences = -1.0f;

								td.u = SplineU;
								td.Tangents = otan;
								td.OPoints = op;
								td.SubCurveIds = cid;
								td.SubSegIds = sid;
								if (!(BoneData[Bone].flags & BONE_LOCK_FLAG))
									{
									int found = -1;
									for (int vdcount = 0; vdcount < bmd->VertexData[i]->d.Count();vdcount++)
										{
										if (bmd->VertexData[i]->d[vdcount].Bones == Bone)
											{
											bmd->VertexData[i]->d[vdcount] = td;
											found = bmd->VertexData[i]->d.Count();
											}
										}
									if (found == -1)
										bmd->VertexData[i]->d.Append(1,&td,1);

									}

								}
							else
								{
								for (int vdcount = 0; vdcount < bmd->VertexData[i]->d.Count();vdcount++)
									{
									if (bmd->VertexData[i]->d[vdcount].Bones == j)
										{
										bmd->VertexData[i]->d.Delete(vdcount,1);
										vdcount = bmd->VertexData[i]->d.Count();
										}
									}
								}


							}

						else
							{
							if (!(BoneData[j].flags & BONE_LOCK_FLAG))
								{
								for (int vdcount = 0; vdcount < bmd->VertexData[i]->d.Count();vdcount++)
									{
									if (bmd->VertexData[i]->d[vdcount].Bones == j)
										{
										bmd->VertexData[i]->d.Delete(vdcount,1);
										vdcount = bmd->VertexData[i]->d.Count();
										}
									}
								}

							}


						}
					else
						{
						for (int vdcount = 0; vdcount < bmd->VertexData[i]->d.Count();vdcount++)
							{
							if (bmd->VertexData[i]->d[vdcount].Bones == j)
								{
								bmd->VertexData[i]->d.Delete(vdcount,1);
								vdcount = bmd->VertexData[i]->d.Count();
								}
							}

						}
					}
				}

			}

}



void BonesDefMod::RecomputeBone(BoneModData *bmd, int BoneIndex, TimeValue t, ObjectState *os)

{

		if (BoneData[BoneIndex].Node == NULL) return;

		BuildCache(bmd, BoneIndex,  t, os);
//watje 9-7-99  198721 
		bmd->reevaluate = FALSE;
		int nv = os->obj->NumPoints();

			

//Get largest radius

//New Fallof method
 		for (int i=0; i<nv; i++) {
//get total distance
			float TotalDistance = 0.0f;
			Point3 p,BoneCenter;		
			if (!bmd->VertexData[i]->modified)
				{

				p = os->obj->GetPoint(i);

				int FullStrength =0;
				int j = BoneIndex;
					{	
					if ((j < BoneData.Count()) && (BoneData[j].Node != NULL))
						{
						int Bone;
						float Influence = 1.0f;
						Bone = j;
						Point3 l1,l2;

						GetEndPoints(bmd,t,l1, l2, j);

						float LineU,SplineU = 0.0f;
						Point3 op,otan;
						int cid,sid;
						if (1) 
							{
							Influence = bmd->DistCache[i].dist;
							LineU = bmd->DistCache[i].u;
							SplineU = LineU;
							cid = bmd->DistCache[i].SubCurveIds;
							sid = bmd->DistCache[i].SubSegIds;
							otan = bmd->DistCache[i].Tangents;
							op = bmd->DistCache[i].OPoints;
//find cross section that bound this point
							int StartCross = 0, EndCross = 0;
							float tu = ModifyU(t,LineU,  j, sid);

							for (int ccount = 0; ccount < BoneData[j].CrossSectionList.Count();ccount++)
								{
								if (BoneData[j].CrossSectionList[ccount].u>=tu)
									{
									EndCross =ccount;
									ccount = BoneData[j].CrossSectionList.Count();
									}
								}
							StartCross = EndCross -1;
	
							if (StartCross == -1)
								{
								StartCross = 0;
								EndCross++;
								}

							Influence = ComputeInfluence(t,Influence,LineU, j,StartCross, EndCross, sid);


							if (Influence != 0.0f)
								{
								VertexInfluenceListClass td;
								td.Bones = Bone;
								td.Influences = Influence;
								td.normalizedInfluences = -1.0f;
								td.u = SplineU;
								td.Tangents = otan;
								td.OPoints = op;
								td.SubCurveIds = cid;
								td.SubSegIds = sid;

								BOOL found = FALSE;
								if (!(BoneData[Bone].flags & BONE_LOCK_FLAG))
									{

									for (int bic = 0; bic < bmd->VertexData[i]->d.Count(); bic++)
										{
										if (bmd->VertexData[i]->d[bic].Bones == Bone)
											{
											bmd->VertexData[i]->d[bic] = td;
											found = TRUE;
											bic = bmd->VertexData[i]->d.Count();
											}
										}
		
									if (!found)
										bmd->VertexData[i]->d.Append(1,&td,1);
									}

								}
							else
								{
								if (!(BoneData[Bone].flags & BONE_LOCK_FLAG))
									{
									BOOL found = FALSE;
									for (int bic = 0; bic < bmd->VertexData[i]->d.Count(); bic++)
										{
										if (bmd->VertexData[i]->d[bic].Bones == Bone)
											{
											bmd->VertexData[i]->d.Delete(bic,1);
											found = TRUE;
											bic = bmd->VertexData[i]->d.Count();

											}
										}
									}

								}
							}
						else
							{
							for (int bic = 0; bic < bmd->VertexData[i]->d.Count(); bic++)
								{
								if (bmd->VertexData[i]->d[bic].Bones == j)
									{
									bmd->VertexData[i]->d.Delete(bic,1);
									bic = bmd->VertexData[i]->d.Count();
									}
								}
	
							}

						}

					}


				}

			}


}


void BonesDefMod::DumpVertexList()

{
/*
for (int i=0; i<bmd->VertexData.Count(); i++) 
	{
	DebugPrint("Vertex %d ",i);
	for (int j=0; j<bmd->VertexData[i]->d.Count(); j++) 
		{
//		int bid = VertexData[i]->d[j].Bones;
		float inf = RetrieveNormalizedWeight(bmd,i, j);
		DebugPrint("%d/%f ",bmd->VertexData[i]->d[j].Bones,inf);

		}
	DebugPrint("\n");

	}
*/
}
void BonesDefMod::LockThisBone(int bid)
{
/*
for (int i=0; i<bmd->VertexData.Count(); i++) 
	{
	for (int j=0; j<bmd->VertexData[i]->d.Count(); j++) 
		{
		if (bmd->VertexData[i]->d[j].Bones == bid)
			{
			bmd->VertexData[i]->d[j].Influences = RetrieveNormalizedWeight(bmd,i, j);
			bmd->VertexData[i]->d[j].normalizedInfluences = bmd->VertexData[i]->d[j].Influences;
			}

		}
	}
*/
}

float BonesDefMod::RetrieveNormalizedWeight(BoneModData *bmd, int vid, int bid)
{
//need to reqeight based on remainder
double tempdist=0.0f;
double w;

int bd = bmd->VertexData[vid]->d[bid].Bones;

if (BoneData[bd].Node == NULL)
	{
	bmd->VertexData[vid]->d[bid].normalizedInfluences = 0.0f;
	bmd->VertexData[vid]->d[bid].Influences = 0.0f;
	return 0.0f;
	}

if (bmd->VertexData[vid]->d[bid].normalizedInfluences != -1.0f) return bmd->VertexData[vid]->d[bid].normalizedInfluences;

//if more than one bone use a weigthed system
if (bmd->VertexData[vid]->d.Count() >1) 
	{
	double remainder = 0.0f; 
	double offset =0.0f;
	tempdist = 0.0f;
	for (int j=0; j<bmd->VertexData[vid]->d.Count(); j++) 
		{
		float infl = bmd->VertexData[vid]->d[j].Influences;
		int bone=bmd->VertexData[vid]->d[j].Bones;
		if (!(BoneData[bone].flags & BONE_LOCK_FLAG))
			tempdist += infl;
		else 
			offset += infl;

		}
	offset = 1.0f-offset;
	double vinflu = bmd->VertexData[vid]->d[bid].Influences;
	int bn=bmd->VertexData[vid]->d[bid].Bones;
	if 	(!(BoneData[bn].flags & BONE_LOCK_FLAG))
		w = ((bmd->VertexData[vid]->d[bid].Influences)/tempdist) *offset;
	else w = bmd->VertexData[vid]->d[bid].Influences;
	}
else if (bmd->VertexData[vid]->d.Count() == 1) 
	{
//if only one bone and absolute control set to it to max control
	if ( (BoneData[bmd->VertexData[vid]->d[0].Bones].flags & BONE_ABSOLUTE_FLAG) )
//		&& !(bmd->VertexData[vid]->modified) )
		{
//		VertexData[vid].d[0].Influences = 1.0f;
		w = 1.0f;
		}
	else w = bmd->VertexData[vid]->d[0].Influences;


	}
return (float)w;
}

void BonesDefMod::UnlockBone(BoneModData *bmd,TimeValue t, ObjectState *os)
	{
//loop through verts and remove and associations to thos bone
	for (int i=0;i<bmd->VertexDataCount;i++)
		{
		for (int bic = 0; bic < bmd->VertexData[i]->d.Count(); bic++)
			{
			if (bmd->VertexData[i]->d[bic].Bones == ModeBoneIndex)
				{
				bmd->VertexData[i]->d.Delete(bic,1);
				bic = bmd->VertexData[i]->d.Count();
				}
			}

		}
//loop through find all verts in radius and set them to unmodified

	if (BoneData[ModeBoneIndex].Node == NULL) return;

	cacheValid = FALSE;
	bmd->CurrentCachePiece = -1;


	BuildCache(bmd, ModeBoneIndex,  t, os);
//watje 9-7-99  198721 
	bmd->reevaluate=TRUE;
	int nv =  os->obj->NumPoints();


//Get largest radius

//New Fallof method
	for (i=0; i<nv; i++) {
//get total distance
		float TotalDistance = 0.0f;
		Point3 p,BoneCenter;		
		p = os->obj->GetPoint(i);

		int FullStrength =0;
		int j = ModeBoneIndex;
		if ((j < BoneData.Count()) && (BoneData[j].Node != NULL))
			{
			int Bone;
			float Influence = 1.0f;
			Bone = j;
			Point3 l1,l2;

			GetEndPoints(bmd,t,l1, l2, j);

			float LineU,SplineU = 0.0f;
			Point3 op,otan;
			int cid,sid;
			Influence = bmd->DistCache[i].dist;
			LineU = bmd->DistCache[i].u;
			SplineU = LineU;
			cid = bmd->DistCache[i].SubCurveIds;
			sid = bmd->DistCache[i].SubSegIds;
			otan = bmd->DistCache[i].Tangents;
			op = bmd->DistCache[i].OPoints;
//find cross section that bound this point
			int StartCross = 0, EndCross = 0;
			float tu = ModifyU(t,LineU,  j, sid);

			for (int ccount = 0; ccount < BoneData[j].CrossSectionList.Count();ccount++)
				{
				if (BoneData[j].CrossSectionList[ccount].u>=tu)
					{
					EndCross =ccount;
					ccount = BoneData[j].CrossSectionList.Count();
					}
				}
			StartCross = EndCross -1;
	
			if (StartCross == -1)
				{
				StartCross = 0;
				EndCross++;
				}

			Influence = ComputeInfluence(t,Influence,LineU, j,StartCross, EndCross, sid);
			if (Influence > 0.0f)
				{
				bmd->VertexData[i]->modified = FALSE;

				}
			}
		}


	}


void BonesDefMod::UpdateTMCacheTable(BoneModData *bmd, TimeValue t, Interval& valid)
{
	if (bmd == NULL) return;



	if (bmd->tempTableL1.Count() != BoneData.Count())
		bmd->tempTableL1.SetCount(BoneData.Count());

	if (bmd->tempTableL2.Count() != BoneData.Count())
		bmd->tempTableL2.SetCount(BoneData.Count());

	if (bmd->tempTableL1ObjectSpace.Count() != BoneData.Count())
		bmd->tempTableL1ObjectSpace.SetCount(BoneData.Count());

	if (bmd->tempTableL2ObjectSpace.Count() != BoneData.Count())
		bmd->tempTableL2ObjectSpace.SetCount(BoneData.Count());


	if (bmd->tmCacheToBoneSpace.Count() != BoneData.Count())
		bmd->tmCacheToBoneSpace.SetCount(BoneData.Count());

	if (bmd->tmCacheToObjectSpace.Count() != BoneData.Count())
		bmd->tmCacheToObjectSpace.SetCount(BoneData.Count());
	for (int j =0;j<BoneData.Count();j++)
		{
		if (BoneData[j].Node != NULL)
			{
			Point3 l1, l2;

			Interval v;
			BoneData[j].EndPoint1Control->GetValue(t,&l1,v);
			BoneData[j].EndPoint2Control->GetValue(t,&l2,v);
	

			bmd->tempTableL1[j] = l1* Inverse(BoneData[j].tm) * Inverse(bmd->BaseTM);
			bmd->tempTableL2[j] = l2* Inverse(BoneData[j].tm) * Inverse(bmd->BaseTM);


//if BID then 
			Matrix3 ntm;
			ntm = BoneData[j].Node->GetObjTMBeforeWSM(t,&valid);

			if (bindNode)
				{
				xRefTM = bindNode->GetObjectTM(t);

				BoneData[j].temptm = bmd->BaseTM * BoneData[j].tm * ntm * 
					initialXRefTM * Inverse(xRefTM) * bmd->InverseBaseTM;
				}
			else BoneData[j].temptm = bmd->BaseTM * BoneData[j].tm * ntm * bmd->InverseBaseTM; 

//			BoneData[j].temptm = bmd->BaseTM * BoneData[j].tm * ntm * bmd->InverseBaseTM;

//cache for for matrices
			bmd->tmCacheToBoneSpace[j] = bmd->BaseTM * Inverse(ntm);
			bmd->tmCacheToObjectSpace[j] = ntm * bmd->InverseBaseTM;

			bmd->tempTableL1ObjectSpace[j] = l1 * bmd->tmCacheToObjectSpace[j];
			bmd->tempTableL2ObjectSpace[j] = l2 * bmd->tmCacheToObjectSpace[j];

			}
		}


}




class XRefEnumProc : public DependentEnumProc 
	{
      public :
      virtual int proc(ReferenceMaker *rmaker); 
      INodeTab Nodes;              
	  BOOL nukeME;
	};

int XRefEnumProc::proc(ReferenceMaker *rmaker) 
	{ 
	if (rmaker->SuperClassID()==BASENODE_CLASS_ID)    
			{
            Nodes.Append(1, (INode **)&rmaker);            
			nukeME = TRUE;
			}
     return 0;              
	}	

BOOL RecurseXRefTree(INode *n, INode *target)
{
for (int i = 0; i < n->NumberOfChildren(); i++)
	{

	INode *child = n->GetChildNode(i);

	if (child == target) 
		{
		return TRUE;
		}
	else RecurseXRefTree(child,target);
	
	}
return FALSE;
}

void BonesDefMod::NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc) {
	if (!mc->localData) return;
//6-18-99
	BoneModData *bmd = (BoneModData *) mc->localData;			
	switch (message) {
		case REFMSG_OBJECT_CACHE_DUMPED:
			{
			if (partID & PART_TOPO)
//6-18-99
				if (!bmd->inputObjectIsNURBS)
//watje 9-7-99  198721 
					bmd->reevaluate=TRUE;
			}
		}

}


void BonesDefMod::UpdateEndPointDelta()
{
int deform;
Interval iv;
pblock_param->GetValue(PB_ALWAYS_DEFORM,0,deform,iv);
endPointDelta.SetCount(BoneData.Count());
if (!deform)
	{
	for (int j =0;j<BoneData.Count();j++)
		{
		if (BoneData[j].Node != NULL)
			{
			Class_ID bid(BONE_CLASS_ID,0);
			Matrix3 ntm =BoneData[j].Node->GetObjectTM(RefFrame);	
			BoneData[j].tm = Inverse(ntm);
//copy initial reference spline into our spline
			ObjectState sos = BoneData[j].Node->EvalWorldState(RefFrame);
			if (sos.obj->ClassID() == bid)  
				{
//now need to look at child and move
//loop through children looking for a matching name
				int childCount;
				childCount = BoneData[j].Node->NumberOfChildren();
				INode *childNode = NULL;
				for (int ci = 0; ci < childCount; ci++)
					{
					childNode = BoneData[j].Node->GetChildNode(ci);
					TSTR childName;
					childName = childNode->GetName();
					if (childName == BoneData[j].name)
						{
						Point3 l2(0.0f,0.0f,0.0f);
						Matrix3 ChildTM = childNode->GetObjectTM(RefFrame);
						l2 = l2 * ChildTM;
						l2 = l2 * BoneData[j].tm; 
						Point3 d;
						BoneData[j].EndPoint2Control->GetValue(0,&d,iv,CTRL_ABSOLUTE);
						ci = childCount;
						endPointDelta[j] = d-l2;

						}
							
					}
				}



			}
		}

	}	

}

void BonesDefMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	Interval valid = FOREVER;
	TimeValue tps = GetTicksPerFrame();


    XRefEnumProc dep;              
	dep.nukeME = FALSE;
	EnumDependents(&dep);
	
	INode *XRefNode = dep.Nodes[0];
	INode *rootNode = GetCOREInterface()->GetRootNode();
	int xct = rootNode->GetXRefFileCount();


	for (int xid = 0; xid < xct; xid++)
		{
		INode *xroot = rootNode->GetXRefTree(xid);
		BOOL amIanXRef = RecurseXRefTree(xroot,XRefNode);
		if (amIanXRef)
			{
			INode *tempBindNode = rootNode->GetXRefParent(xid);
			if ((tempBindNode) && (bindNode!=tempBindNode))
				{
				BOOL isThereAnInitialMatrix=FALSE;
				TSTR there("InitialMatrix");
				TSTR entry;
//check if inode has initial matricx property if use that else
				if (bindNode!=NULL)
					{
					bindNode->GetUserPropBool(there,isThereAnInitialMatrix);
					}
				tempBindNode->GetUserPropBool(there,isThereAnInitialMatrix);
				if (isThereAnInitialMatrix) 
					{
//GetUserPropFloat(const TSTR &key,float &val)
					Point3 r1,r2,r3,r4;
					entry.printf(_T("r1x"));
					tempBindNode->GetUserPropFloat(entry,r1.x);
					entry.printf(_T("r1y"));
					tempBindNode->GetUserPropFloat(entry,r1.y);
					entry.printf(_T("r1z"));
					tempBindNode->GetUserPropFloat(entry,r1.z);
					entry.printf(_T("r2x"));
					tempBindNode->GetUserPropFloat(entry,r2.x);
					entry.printf(_T("r2y"));
					tempBindNode->GetUserPropFloat(entry,r2.y);
					entry.printf(_T("r2z"));
					tempBindNode->GetUserPropFloat(entry,r2.z);
					entry.printf(_T("r3x"));
					tempBindNode->GetUserPropFloat(entry,r3.x);
					entry.printf(_T("r3y"));
					tempBindNode->GetUserPropFloat(entry,r3.y);
					entry.printf(_T("r3z"));
					tempBindNode->GetUserPropFloat(entry,r3.z);
					entry.printf(_T("r4x"));
					tempBindNode->GetUserPropFloat(entry,r4.x);
					entry.printf(_T("r4y"));
					tempBindNode->GetUserPropFloat(entry,r4.y);
					entry.printf(_T("rz"));
					tempBindNode->GetUserPropFloat(entry,r4.z);
					initialXRefTM.SetRow(0,r1);
					initialXRefTM.SetRow(1,r2);
					initialXRefTM.SetRow(2,r3);
					initialXRefTM.SetRow(3,r4);

					}
				else 
					{
					initialXRefTM = tempBindNode->GetObjectTM(t);
					tempBindNode->SetUserPropBool(there,TRUE);
					Point3 r1,r2,r3,r4;
					r1 = initialXRefTM.GetRow(0);
					r2 = initialXRefTM.GetRow(1);
					r3 = initialXRefTM.GetRow(2);
					r4 = initialXRefTM.GetRow(3);
					entry.printf(_T("r1x"));
					tempBindNode->SetUserPropFloat(entry,r1.x);
					entry.printf(_T("r1y"));
					tempBindNode->SetUserPropFloat(entry,r1.y);
					entry.printf(_T("r1z"));
					tempBindNode->SetUserPropFloat(entry,r1.z);
					entry.printf(_T("r2x"));
					tempBindNode->SetUserPropFloat(entry,r2.x);
					entry.printf(_T("r2y"));
					tempBindNode->SetUserPropFloat(entry,r2.y);
					entry.printf(_T("r2z"));
					tempBindNode->SetUserPropFloat(entry,r2.z);
					entry.printf(_T("r3x"));
					tempBindNode->SetUserPropFloat(entry,r3.x);
					entry.printf(_T("r3y"));
					tempBindNode->SetUserPropFloat(entry,r3.y);
					entry.printf(_T("r3z"));
					tempBindNode->SetUserPropFloat(entry,r3.z);
					entry.printf(_T("r4x"));
					tempBindNode->SetUserPropFloat(entry,r4.x);
					entry.printf(_T("r4y"));
					tempBindNode->SetUserPropFloat(entry,r4.y);
					entry.printf(_T("rz"));
					tempBindNode->SetUserPropFloat(entry,r4.z);

					}
				bindNode = tempBindNode;

				}
			}
		}




//loop through bone nodes to get new interval
	float ef;
	pblock_param->GetValue(PB_EFFECT,t,ef,valid);


	pblock_param->GetValue(PB_LOCK_BONE,t,LockBone,valid);
	pblock_param->GetValue(PB_ABSOLUTE_INFLUENCE,t,AbsoluteInfluence,valid);

	pblock_param->GetValue(PB_FILTER_VERTICES,t,FilterVertices,valid);
	pblock_param->GetValue(PB_FILTER_BONES,t,FilterBones,valid);
	pblock_param->GetValue(PB_FILTER_ENVELOPES,t,FilterEnvelopes,valid);

	FilterVertices = !FilterVertices;
	FilterBones = !FilterBones;
	FilterEnvelopes = !FilterEnvelopes;


	pblock_param->GetValue(PB_DRAW_ENVELOPES,t,DrawEnvelopes,valid);
	pblock_param->GetValue(PB_DRAW_VERTICES,t,DrawVertices,valid);


	pblock_param->GetValue(PB_RADIUS,t,Radius,valid);
	pblock_param->GetValue(PB_FEATHER,t,Feather,valid);

	pblock_param->GetValue(PB_PROJECT_THROUGH,t,ProjectThrough,valid);
	pblock_param->GetValue(PB_FALLOFF,t,Falloff,valid);

	pblock_param->GetValue(PB_REF_FRAME,t,RefFrame,valid);
	pblock_param->GetValue(PB_ALWAYS_DEFORM,t,AlwaysDeform,valid);


	RefFrame = RefFrame*tps;


//build each instance local data
	if (ip != NULL)
		{
		ModContextList mcList;
		INodeTab nodes;
		if (mc.localData == NULL)
			{
			ip->GetModContexts(mcList,nodes);

			for (int i = 0; i < nodes.Count(); i++)
				{
				BoneModData *d  = new BoneModData();
				d->BaseTM = nodes[i]->GetObjectTM(RefFrame);
				d->InverseBaseTM = Inverse(d->BaseTM);
				UpdateTMCacheTable(d,t,valid);

				if ((OldVertexDataCount != 0) && (i==0))
					{
					d->VertexDataCount = OldVertexDataCount;
					d->VertexData.SetCount(OldVertexDataCount);
					for (int j = 0; j < OldVertexDataCount; j++)
						{
						VertexListClass *vc;
						vc = new VertexListClass;
						d->VertexData[j] = vc;

						d->VertexData[j]->selected = OldVertexData[j]->selected;
						d->VertexData[j]->modified = OldVertexData[j]->modified;
						d->VertexData[j]->LocalPos = OldVertexData[j]->LocalPos;
						d->VertexData[j]->d = OldVertexData[j]->d;
						}
					for (j = 0; j < OldVertexDataCount; j++)
						delete (OldVertexData[j]);

					OldVertexData.ZeroCount();

					OldVertexDataCount = -1;
					}
				mcList[i]->localData = d;


				}
			NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
			valid.SetInstant(t);
			os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);	

			return;

			}
//create a back pointer to the container entry				
		}

	BoneModData *bmd = (BoneModData *) mc.localData;			


	if (bmd == NULL) return;

//6-18-99
	bmd->inputObjectIsNURBS = os->obj->ClassID() == EDITABLE_SURF_CLASS_ID;	


	if (BoneData.Count() == 0) return;

	UpdateTMCacheTable(bmd,t,valid);

//	DebugPrint("num verts %d bmd %d\n",os->obj->NumPoints(),bmd->VertexDataCount);


	if (os->obj->NumPoints()==0) 
		{
		os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);	
		return;
		}




	if ((!painting) || (bmd->forceUpdate))
		{


		bmd->forceUpdate = FALSE;	

		if (splineChanged)
			{
			if (whichSplineChanged < BoneData.Count())
				{
				if (BoneData[whichSplineChanged].Node)
					{

					ObjectState os = BoneData[whichSplineChanged].Node->EvalWorldState(t);
					if (os.obj->SuperClassID()!=SHAPE_CLASS_ID)
						{
//if not convert it to a regular node
						BoneData[whichSplineChanged].flags &= ~BONE_SPLINE_FLAG;
//watje 9-7-99  198721 
						bmd->reevaluate=TRUE;
						Point3 a,b;
						Interval v;
						BuildMajorAxis(BoneData[whichSplineChanged].Node,a,b); 

						BoneData[whichSplineChanged].EndPoint1Control->SetValue(0,a,TRUE,CTRL_ABSOLUTE);
						BoneData[whichSplineChanged].EndPoint2Control->SetValue(0,b,TRUE,CTRL_ABSOLUTE);
						cacheValid = FALSE;
						}
					else
						{
						ObjectState sos = BoneData[whichSplineChanged].Node->EvalWorldState(RefFrame);
						BezierShape bShape;
						ShapeObject *shape = (ShapeObject *)sos.obj;
						if (shape)
							{
							if(shape->CanMakeBezier())
//watje 9-7-99  195862 
								shape->MakeBezier(RefFrame, bShape);
//								shape->MakeBezier(t, bShape);
							else {
								PolyShape pShape;
//watje 9-7-99  195862 
								shape->MakePolyShape(RefFrame, pShape);
//								shape->MakePolyShape(t, pShape);
								bShape = pShape;	// UGH -- Convert it from a PolyShape -- not good!
								}
							}

						if ((shape) && (bShape.splineCount >0) &&
							(bShape.splines[0]->Segments() != BoneData[whichSplineChanged].referenceSpline.Segments()))
							{
							BoneData[whichSplineChanged].referenceSpline = *bShape.splines[0];
//watje 9-7-99  198721 
							bmd->reevaluate=TRUE;
							}

/*						ObjectState sos = BoneData[whichSplineChanged].Node->EvalWorldState(RefFrame);
						SplineShape *shape = (SplineShape *)sos.obj;
//check for a topo change is so recreate reference spline and recompuetall
						if ((shape) && (shape->shape.splines[0]->Segments() != BoneData[whichSplineChanged].referenceSpline.Segments()))
							{
							BoneData[whichSplineChanged].referenceSpline = *shape->shape.splines[0];
							reevaluate = TRUE;
							}
*/
						}

					}


				}
			splineChanged = FALSE;
			}




		if (unlockVerts)
			{
			unlockVerts = FALSE;
//watje 9-7-99  198721 
			bmd->reevaluate=TRUE;
			for (int i=0;i<bmd->VertexDataCount;i++)
				{
				if (bmd->selected[i])
					bmd->VertexData[i]->modified = FALSE;
				}
			}

		if (updateP)
			{
			updateP = FALSE;
			UpdateP(bmd);
			}

		if ((((t == (RefFrame)) && (BoneMoved)) && (!AlwaysDeform))  || forceRecomuteBaseNode)
//	if (((t == (RefFrame *tps)) && (BoneMoved)) )
			{
//readjust TMs for frame 0
			BoneMoved = FALSE;
//watje 9-7-99  198721 
			bmd->reevaluate=TRUE;
			cacheValid = FALSE;
			forceRecomuteBaseNode = FALSE;
			bmd->CurrentCachePiece = -1;

			if (ip != NULL)
				{
				ModContextList mcList;
				INodeTab nodes;
				ip->GetModContexts(mcList,nodes);

				for (int i = 0; i < nodes.Count(); i++)
					{
					BoneModData *d  = (BoneModData *) mcList[i]->localData;
					if (d)
						{
						d->BaseTM = nodes[i]->GetObjectTM(RefFrame);
						d->InverseBaseTM = Inverse(d->BaseTM);
						}
					}
				}

	
			for (int j =0;j<BoneData.Count();j++)
				{
				if (BoneData[j].Node != NULL)
					{
					Class_ID bid(BONE_CLASS_ID,0);
					Matrix3 ntm =BoneData[j].Node->GetObjectTM(RefFrame);	
					BoneData[j].tm = Inverse(ntm);
//copy initial reference spline into our spline
					ObjectState sos = BoneData[j].Node->EvalWorldState(RefFrame);
					if (BoneData[j].flags & BONE_SPLINE_FLAG)
						{
//						SplineShape *shape = (SplineShape *)sos.obj;
//						BoneData[j].referenceSpline = *shape->shape.splines[0];
						BezierShape bShape;
						ShapeObject *shape = (ShapeObject *)sos.obj;
						if (shape)
							{
							if(shape->CanMakeBezier())
								shape->MakeBezier(t, bShape);
							else {
								PolyShape pShape;
								shape->MakePolyShape(t, pShape);
								bShape = pShape;	// UGH -- Convert it from a PolyShape -- not good!
								}
							if (bShape.splineCount >0) 
								BoneData[j].referenceSpline = *bShape.splines[0];
							}

						}
//need to readjust the child endpoints for bone type objects also
					else if (sos.obj->ClassID() == bid)  
						{
//now need to look at child and move
//loop through children looking for a matching name
						int childCount;
						childCount = BoneData[j].Node->NumberOfChildren();
						INode *childNode = NULL;
						for (int ci = 0; ci < childCount; ci++)
							{
							childNode = BoneData[j].Node->GetChildNode(ci);
							TSTR childName;
							childName = childNode->GetName();
							if (childName == BoneData[j].name)
								{
								Point3 l2(0.0f,0.0f,0.0f);
								Matrix3 ChildTM = childNode->GetObjectTM(RefFrame);
								l2 = l2 * ChildTM;
								l2 = l2 * BoneData[j].tm; 
								if (j < endPointDelta.Count())
									{
									l2 = l2+endPointDelta[j];
									BoneData[j].EndPoint2Control->SetValue(0,&l2,TRUE,CTRL_ABSOLUTE);
									}
								else BoneData[j].EndPoint2Control->SetValue(0,&l2,TRUE,CTRL_ABSOLUTE);
								ci = childCount;

								}
							
							}
						}



					}
				}

			}
		if (reloadSplines)
			{
			for (int j =0;j<BoneData.Count();j++)
				{
				if (BoneData[j].Node != NULL)
					{
//copy initial reference spline into our spline
					if (BoneData[j].flags & BONE_SPLINE_FLAG)
						{
						ObjectState sos = BoneData[j].Node->EvalWorldState(RefFrame);
//						SplineShape *shape = (SplineShape *)sos.obj;
//						BoneData[j].referenceSpline = *shape->shape.splines[0];
						BezierShape bShape;
						ShapeObject *shape = (ShapeObject *)sos.obj;
						if (shape)
							{
							if(shape->CanMakeBezier())
								shape->MakeBezier(t, bShape);
							else {
								PolyShape pShape;
								shape->MakePolyShape(t, pShape);
								bShape = pShape;	// UGH -- Convert it from a PolyShape -- not good!
								}
							if (bShape.splineCount >0) 
								BoneData[j].referenceSpline = *bShape.splines[0];
							}

						}


					}
				}
			reloadSplines = FALSE;

			}

		if (bmd->selected.GetSize() != os->obj->NumPoints())
			bmd->selected.SetSize(os->obj->NumPoints(),TRUE);




//get selected bone	
		int rsel = 0;

		rsel = SendMessage(GetDlgItem(hParam,IDC_LIST1),
					LB_GETCURSEL ,0,0);
		int tsel = ConvertSelectedListToBoneID(rsel);


	


		if ( (tsel>=0) && (ip && ip->GetSubObjectLevel() == 1) )
			{
			ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hParam,IDC_EFFECTSPIN));
//			spin2->SetIndeterminate(TRUE);

			if ((!spin2->IsIndeterminate()) && (ef != bmd->effect))
				{
				bmd->effect = ef;
				SetSelectedVertices(bmd,tsel, bmd->effect);
				}
			}

//set validty based on TM's
		for (int i =0;i<BoneData.Count();i++)
			{
			if (BoneData[i].Node != NULL) 
				{
				BoneData[i].Node->GetObjectTM(t,&valid);
				if (BoneData[i].flags & BONE_SPLINE_FLAG)
					{
					ObjectState osp = BoneData[i].Node->EvalWorldState (t);
					valid &= osp.obj->ObjectValidity (t);
					}
				}

			}

//get selected bone	
		if (bmd->VertexDataCount != os->obj->NumPoints())
			{
//readjust vertices using nearest vertices as sample
//DebugPrint("    Reevaluating \n");
//watje 9-7-99  198721 
			bmd->reevaluate = TRUE;
			bmd->CurrentCachePiece = -1;
			}

		if (unlockBone)
			{
			unlockBone = FALSE;
//watje 9-7-99  198721 
			bmd->reevaluate = TRUE;
			UnlockBone(bmd,t,os);
			}



		if ((ip) || (bmd->reevaluate))
			{
			if ( (bmd->reevaluate) )
				{
				RecomputeAllBones(bmd,t,os);
				cacheValid = FALSE;
				bmd->CurrentCachePiece = -1;

				}	

			else if ( (ModeBoneIndex!=-1) && (ip && ip->GetSubObjectLevel() == 1))//&& (ModeEdit ==1) )
				{
				RecomputeBone(bmd,ModeBoneIndex,t,os);
				}
			}

		for (i = 0; i < os->obj->NumPoints(); i++)
			bmd->VertexData[i]->LocalPos = os->obj->GetPoint(i);

		}

	valid &= LocalValidity(t);



	if ((t == RefFrame) && (!AlwaysDeform))
		{
		}
	else
		{
		BonesDefDeformer deformer(this,bmd,t);
		os->obj->Deform(&deformer, TRUE);
		}

//		}
//		else
//		{
//		StaticBonesDefDeformer staticdeformer(this,bmd,t);
//		os->obj->Deform(&staticdeformer, TRUE);

//		}
	
	if ((inPaint) && (!painting))
		{
		bmd->hitState = os;
		if (os->obj->IsSubClassOf(triObjectClassID))
			{
			bmd->isMesh = TRUE;
			bmd->isPatch = FALSE;
			}
		else if (os->obj->IsSubClassOf(patchObjectClassID))
			{
			bmd->isMesh = FALSE;
			bmd->isPatch = TRUE;
			}

		else if (os->obj->IsParamSurface()) 
			{
			
			}
		else 

			{
//ask if can convert to mesh
			if (os->obj->CanConvertToType(triObjectClassID))
				{
				bmd->isMesh = TRUE;
				bmd->isPatch = FALSE;
				}
			else
				{
				bmd->isMesh = FALSE;
				bmd->isPatch = FALSE;
				}

			}
		}

//	DebugPrint("End bonesdef\n");

	os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);	

	}
	


#define ID_CHUNK 0x1000

IOResult BonesDefMod::SaveLocalData(ISave *isave, LocalModData *pld)
{

//IOResult	res;
ULONG		nb;

BoneModData *bmd = (BoneModData*)pld;

//isave->BeginChunk(ID_CHUNK);
//res = isave->Write(&p->id, sizeof(int), &nb);
//isave->EndChunk();

	isave->BeginChunk(BASE_TM_CHUNK);
	bmd->BaseTM.Save(isave);
	isave->EndChunk();



	int c = bmd->VertexDataCount;
//save vertex influence info
	isave->BeginChunk(VERTEX_COUNT_CHUNK);
	isave->Write(&c,sizeof(c),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(VERTEX_DATA_CHUNK);
	for (int i = 0; i < c; i++)
		{
//write number of influences
		int ic;
		ic = bmd->VertexData[i]->d.Count();
		isave->Write(&ic,sizeof(ic),&nb);
		int save_i;
		float save_f;
		BOOL save_b;
		save_b = bmd->VertexData[i]->modified;
		isave->Write(&save_b,sizeof(save_b),&nb);

		for (int j = 0; j < ic; j++)
			{
			save_i = bmd->VertexData[i]->d[j].Bones;
			save_f = bmd->VertexData[i]->d[j].Influences;
			isave->Write(&save_i,sizeof(save_i),&nb);
			isave->Write(&save_f,sizeof(save_f),&nb);

			save_i = bmd->VertexData[i]->d[j].SubCurveIds;
			isave->Write(&save_i,sizeof(save_i),&nb);
			save_i = bmd->VertexData[i]->d[j].SubSegIds;
			isave->Write(&save_i,sizeof(save_i),&nb);

			save_f = bmd->VertexData[i]->d[j].u;
			isave->Write(&save_f,sizeof(save_f),&nb);

			Point3 save_p;
			save_p = bmd->VertexData[i]->d[j].Tangents;
			isave->Write(&save_p,sizeof(save_p),&nb);

			save_p = bmd->VertexData[i]->d[j].OPoints;
			isave->Write(&save_p,sizeof(save_p),&nb);



			}

		}
	isave->EndChunk();


return IO_OK;
}

IOResult BonesDefMod::LoadLocalData(ILoad *iload, LocalModData **pld)

{
	IOResult	res;
	ULONG		nb;

	BoneModData *bmd = new BoneModData();
	*pld = bmd;
	bmd->effect = -1.0f;


//	int id;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
//			case ID_CHUNK:
//				iload->Read(&id,sizeof(int), &nb);
//				break;

			case BASE_TM_CHUNK: 
				{
				bmd->BaseTM.Load(iload);
				bmd->InverseBaseTM = Inverse(bmd->BaseTM);
				break;
				}


			case VERTEX_COUNT_CHUNK:
				{
				int c;
				iload->Read(&c,sizeof(c),&nb);
				bmd->VertexDataCount = c;
//				if (VertexData != NULL) delete VertexData;
//				VertexData = new VertexListClass[c]; 
				bmd->VertexData.ZeroCount();
				bmd->VertexData.SetCount(c);
				for (int i=0; i<c; i++) {
					VertexListClass *vc;
					vc = new VertexListClass;
					bmd->VertexData[i] = vc;
					bmd->VertexData[i]->modified = FALSE;
					bmd->VertexData[i]->selected = FALSE;
 					bmd->VertexData[i]->d.ZeroCount();
//					VertexData[i].Influences.ZeroCount();
					}

				break;

				}
			case VERTEX_DATA_CHUNK:
				{
				for (int i=0; i < bmd->VertexDataCount; i++)
					{
					int c;
					BOOL load_b;
					iload->Read(&c,sizeof(c),&nb);
					bmd->VertexData[i]->d.SetCount(c);

//					VertexData[i].Influences.SetCount(c);
					iload->Read(&load_b,sizeof(load_b),&nb);
					bmd->VertexData[i]->modified = load_b;
					float load_f;
					int load_i;
					Point3 load_p;
					for (int j=0; j<c; j++) {
						iload->Read(&load_i,sizeof(load_i),&nb);
						iload->Read(&load_f,sizeof(load_f),&nb);
 						bmd->VertexData[i]->d[j].Bones = load_i;
						bmd->VertexData[i]->d[j].Influences =load_f;
						bmd->VertexData[i]->d[j].normalizedInfluences = -1.0f;

						iload->Read(&load_i,sizeof(load_i),&nb);
						bmd->VertexData[i]->d[j].SubCurveIds =load_i;
						iload->Read(&load_i,sizeof(load_i),&nb);
						bmd->VertexData[i]->d[j].SubSegIds =load_i;

						iload->Read(&load_f,sizeof(load_f),&nb);
 						bmd->VertexData[i]->d[j].u = load_f;

						iload->Read(&load_p,sizeof(load_p),&nb);
 						bmd->VertexData[i]->d[j].Tangents = load_p;

						iload->Read(&load_p,sizeof(load_p),&nb);
 						bmd->VertexData[i]->d[j].OPoints = load_p;


						}
					}

				break;

				}

			}
		iload->CloseChunk();
		if (res!=IO_OK) return res;
		}


    int c = bmd->VertexDataCount;
//add m crossection
	bmd->selected.SetSize(c);
	bmd->selected.ClearAll();
	bmd->CurrentCachePiece = -1;

//	for (i=0; i<c; i++) 
//		sel[i] = FALSE;

return IO_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\BonesDef\DlgProc.cpp ===
/**********************************************************************
 
	FILE: DlgProc.cpp

	DESCRIPTION:  Main DLg proc to handle windows stuff mainly the list box and buttons

	CREATED BY: Peter Watje

	HISTORY: 8/5/98




 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"
#include "shape.h"
#include "spline3d.h"
#include "splshape.h"
#include "linshape.h"

// This uses the linked-list class templates
#include "linklist.h"
#include "bonesdef.h"


static HIMAGELIST hParamImages = NULL;


void BonesDefMod::RegisterClasses()
	{
	if (!hParamImages) {
		HBITMAP hBitmap, hMask;	
		hParamImages = ImageList_Create(16, 15, TRUE, 4, 0);
		hBitmap = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_PARAMS));
		hMask   = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_PARAMS_MASK));
		ImageList_Add(hParamImages,hBitmap,hMask);
		DeleteObject(hBitmap);
		DeleteObject(hMask);
		}
	}

extern BonesRightMenu rMenu;

void SpinnerOff(HWND hWnd,int SpinNum,int Winnum)
{	
	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	if (spin2 != NULL)
		{
		spin2->Enable(FALSE);
		EnableWindow(GetDlgItem(hWnd,Winnum),FALSE);
		ReleaseISpinner(spin2);
		}

};

void SpinnerOn(HWND hWnd,int SpinNum,int Winnum)
{
	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	if (spin2 != NULL)
		{
		spin2->Enable(TRUE);
		EnableWindow(GetDlgItem(hWnd,Winnum),TRUE);
		ReleaseISpinner(spin2);
		}

};


BOOL MapDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	int i;

	switch (msg) {
		case WM_INITDIALOG:
			{

			mod->hParam = hWnd;

			for (i=0;i<mod->BoneData.Count();i++)
				{
				TCHAR title[200];

				if (mod->BoneData[i].Node != NULL)
					{
					Class_ID bid(BONE_CLASS_ID,0);
					ObjectState os = mod->BoneData[i].Node->EvalWorldState(mod->RefFrame);

					if (( os.obj->ClassID() == bid) && (mod->BoneData[i].name.Length()) )
						{
						_tcscpy(title,mod->BoneData[i].name);
						}
					else _tcscpy(title,mod->BoneData[i].Node->GetName());

					SendMessage(GetDlgItem(hWnd,IDC_LIST1),
						LB_ADDSTRING,0,(LPARAM)(TCHAR*)title);



					}
				}

			mod->iCrossSectionButton = GetICustButton(GetDlgItem(hWnd, IDC_CREATE_CROSS_SECTION));
			mod->iCrossSectionButton->SetType(CBT_CHECK);
			mod->iCrossSectionButton->SetHighlightColor(GREEN_WASH);

			mod->iPaintButton = GetICustButton(GetDlgItem(hWnd, IDC_PAINT));
			mod->iPaintButton->SetType(CBT_CHECK);
			mod->iPaintButton->SetHighlightColor(GREEN_WASH);

			mod->iCrossSectionButton->Disable();
			mod->iPaintButton->Disable();
			EnableWindow(GetDlgItem(hWnd,IDC_CREATE_REMOVE_SECTION),FALSE);


			EnableWindow(GetDlgItem(hWnd,IDC_FILTER_VERTICES_CHECK),FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_FILTER_BONES_CHECK),FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_FILTER_ENVELOPES_CHECK),FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_DRAWALL_ENVELOPES_CHECK),FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_DRAW_VERTICES_CHECK),FALSE);


			SpinnerOff(hWnd,IDC_PAINT_STR_SPIN2,IDC_PAINT_STR2);
			SpinnerOff(hWnd,IDC_FEATHERSPIN,IDC_FEATHER);
			SpinnerOff(hWnd,IDC_SRADIUSSPIN,IDC_SRADIUS);
			SpinnerOff(hWnd,IDC_EFFECTSPIN,IDC_EFFECT);
			SpinnerOff(hWnd,IDC_ERADIUSSPIN,IDC_ERADIUS);

			SendMessage(GetDlgItem(mod->hParam,IDC_LIST1),
				LB_SETCURSEL ,mod->LastSelected,0);
			mod->ModeBoneIndex = mod->LastSelected;

  

				//set check
	
			rMenu.SetMod(mod);
			mod->ip->GetRightClickMenuManager()->Register(&rMenu);

			mod->RegisterClasses();
			mod->iParams = GetICustToolbar(GetDlgItem(hWnd,IDC_BONE_TOOLBAR));
			mod->iParams->SetBottomBorder(FALSE);	
			mod->iParams->SetImage(hParamImages);

			mod->iParams->AddTool(
					ToolButtonItem(CTB_CHECKBUTTON,
					13, 12, 13, 12, 16, 15, 23, 22, ID_ABSOLUTE));
			mod->iParams->AddTool(
					ToolButtonItem(CTB_CHECKBUTTON,
					14, 15, 14, 15, 16, 15, 23, 22, ID_DRAW_ENVELOPE));
			mod->iParams->AddTool(
					ToolButtonItem(CTB_PUSHBUTTON,
					0, 0, 1, 1, 16, 15, 23, 22, ID_FALLOFF));
			mod->iParams->AddTool(
					ToolButtonItem(CTB_PUSHBUTTON,
					16, 16, 16, 16, 16, 15, 23, 22, ID_COPY));
			mod->iParams->AddTool(
					ToolButtonItem(CTB_PUSHBUTTON,
					17, 17, 19, 19, 16, 15, 23, 22, ID_PASTE));

	
//			mod->iLock    = mod->iParams->GetICustButton(ID_LOCK);
			mod->iAbsolute= mod->iParams->GetICustButton(ID_ABSOLUTE);
			mod->iEnvelope= mod->iParams->GetICustButton(ID_DRAW_ENVELOPE);
			mod->iFalloff = mod->iParams->GetICustButton(ID_FALLOFF);
			mod->iCopy = mod->iParams->GetICustButton(ID_COPY);
			mod->iPaste = mod->iParams->GetICustButton(ID_PASTE);

//			mod->iLock->SetTooltip(TRUE,GetString(IDS_PW_LOCK));
			mod->iAbsolute->SetTooltip(TRUE,GetString(IDS_PW_ABSOLUTE));
			mod->iEnvelope->SetTooltip(TRUE,GetString(IDS_PW_ENVELOPE));
			mod->iFalloff->SetTooltip(TRUE,GetString(IDS_PW_FALLOFF));
			mod->iCopy->SetTooltip(TRUE,GetString(IDS_PW_COPY));
			mod->iPaste->SetTooltip(TRUE,GetString(IDS_PW_PASTE));

			if (mod->CopyBuffer.CList.Count() == 0) mod->iPaste->Enable(FALSE);

			FlyOffData fdata1[] = {
				{ 8,  8,  9,  9},
				{10, 10, 11, 11}
				};
			int lock=0;
//			mod->iLock->SetFlyOff(2,fdata1,mod->ip->GetFlyOffTime(),lock,FLY_DOWN);

//			FlyOffData fdata2[] = {
//				{13, 13, 13, 13},
//				{12, 12, 12, 12}
//				};
			int absolute=0;
//			mod->iAbsolute->SetFlyOff(2,fdata2,mod->ip->GetFlyOffTime(),absolute,FLY_DOWN);

			FlyOffData fdata3[] = {
				{14, 14, 14, 14},
				{15, 15, 15, 15}
				};
			int envelope=0;
//			mod->iEnvelope->SetFlyOff(2,fdata3,mod->ip->GetFlyOffTime(),envelope,FLY_DOWN);

			FlyOffData fdata4[] = {
				{ 0,  0,  1,  1},
				{ 2,  2,  3,  3},
				{ 4,  4,  5,  5},
				{ 6,  6,  7,  7},
				};
			int falloff=0;
			mod->iFalloff->SetFlyOff(4,fdata4,mod->ip->GetFlyOffTime(),falloff,FLY_DOWN);

			if (mod->ModeBoneIndex < (mod->BoneData.Count()-1))
				{
				mod->UpdatePropInterface();

				}
 // bug fix 206160 and 207093 9/8/99	watje
			if (mod->iAbsolute!=NULL)
				mod->iAbsolute->Disable();
			if (mod->iEnvelope!=NULL)
				mod->iEnvelope->Disable();
			if (mod->iFalloff!=NULL)
				mod->iFalloff->Disable();
			if (mod->iCopy!=NULL)
				mod->iCopy->Disable();
			if (mod->iPaste!=NULL)
				mod->iPaste->Disable();




			break;
			}
		case WM_CUSTEDIT_ENTER :
			switch (LOWORD(wParam)) {
			case IDC_ERADIUS:
				if (Animating())
					{
					Control *c = mod->pblock_param->GetController(PB_ERADIUS);
					IKeyControl *ikc = GetKeyControlInterface(c);
					float r;
					mod->pblock_param->GetValue(PB_ERADIUS,mod->ip->GetTime(),r,FOREVER);
					ikc->SetNumKeys(0);
					mod->pblock_param->SetValue(PB_ERADIUS,0,r);
					mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
					mod->ip->RedrawViews(mod->ip->GetTime());
					}
				else
					{
					mod->updateP = TRUE;
					mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
					mod->ip->RedrawViews(mod->ip->GetTime());
					}
				break;
			case IDC_EFFECT:
				{
				ModContextList mcList;		
				INodeTab nodes;

				mod->ip->GetModContexts(mcList,nodes);
				int objects = mcList.Count();
				for ( int i = 0; i < objects; i++ ) 
					{
					BoneModData *bmd = (BoneModData*)mcList[i]->localData;
					bmd->effect = -1.0f;
					}
				mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
				mod->ip->RedrawViews(mod->ip->GetTime());


				}
				break;

			}

		case CC_SPINNER_BUTTONDOWN:
			switch (LOWORD(wParam)) {
			case IDC_EFFECTSPIN:
				mod->HoldWeights();
				break;
/*			case IDC_ERADIUSSPIN:
				theHold.SuperBegin();
				break;
*/

			}
			break;

		case CC_SPINNER_CHANGE:
			switch( LOWORD(wParam) ) {
				case IDC_ERADIUSSPIN:
					if (Animating())
						{
						Control *c = mod->pblock_param->GetController(PB_ERADIUS);
						IKeyControl *ikc = GetKeyControlInterface(c);
						float r;
						mod->pblock_param->GetValue(PB_ERADIUS,mod->ip->GetTime(),r,FOREVER);
						ikc->SetNumKeys(0);
						mod->pblock_param->SetValue(PB_ERADIUS,0,r);
//					mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
//					mod->ip->RedrawViews(mod->ip->GetTime());
						}
					break;
				}

			break;


		case CC_SPINNER_BUTTONUP:
			switch( LOWORD(wParam) ) {
				case IDC_EFFECTSPIN:
					mod->AcceptWeights(HIWORD(wParam));
					break;
				case IDC_ERADIUSSPIN:
					if (HIWORD(wParam))
						{
						if (Animating())
							{
							Control *c = mod->pblock_param->GetController(PB_ERADIUS);
							IKeyControl *ikc = GetKeyControlInterface(c);
							float r;
							mod->pblock_param->GetValue(PB_ERADIUS,mod->ip->GetTime(),r,FOREVER);
							ikc->SetNumKeys(0);
							mod->pblock_param->SetValue(PB_ERADIUS,0,r);
							mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
							mod->ip->RedrawViews(mod->ip->GetTime());
							}
						else
							{
							mod->updateP = TRUE;
							mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
							mod->ip->RedrawViews(mod->ip->GetTime());
							}

						}
					break;



				}
			break;

		case WM_COMMAND:

			switch (LOWORD(wParam)) 
				{
				case IDC_ALWAYSDEFORM_CHECK:
//				block_param->GetValue(PB_ALWAYS_DEFORM,t,AlwaysDeform,valid);
				mod->forceRecomuteBaseNode = TRUE;
				mod->UpdateEndPointDelta();
				break;

	
				case IDC_CREATE_CROSS_SECTION:
					{
					mod->StartCrossSectionMode(0);
					break;
					}
				case IDC_PAINT:
					{

					mod->StartPaintMode();
					break;
					}

				case IDC_BUILD_FALLOFF:
					{
//					mod->BuildFalloff();
					break;
					}
				case IDC_SELECT_FLEX:
					{
//					mod->SelectFlexibleVerts();
					break;
					}
				case IDC_CREATE_REMOVE_SECTION:
					{
					mod->RemoveCrossSection();
					break;
					}
				case IDC_UNLOCK_VERTS:
					{
					mod->unlockVerts = TRUE;
					mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
/*
					for (i=0;i<mod->bmd->VertexDataCount;i++)
						{
						if (mod->sel[i])
							mod->bmd->VertexData[i]->modified = FALSE;
						}
*/
					break;


					}
				case IDC_RESET_ALL:
					{
					mod->unlockBone = TRUE;
					mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
					break;
					}
				case IDC_ADD:
					{
					mod->ip->DoHitByNameDialog(new DumpHitDialog(mod));

					break;
					}

				case ID_FALLOFF:
					{
					if (mod->BoneData.Count() > 0)
						{

//watje 9-7-99  198721 
						mod->Reevaluate(TRUE);
						int foff = mod->iFalloff->GetCurFlyOff();

						if (foff == 0)
							mod->BoneData[mod->ModeBoneIndex].FalloffType = BONE_FALLOFF_X_FLAG;
						else if (foff == 1)
							mod->BoneData[mod->ModeBoneIndex].FalloffType = BONE_FALLOFF_SINE_FLAG;
						else if (foff == 2)
							mod->BoneData[mod->ModeBoneIndex].FalloffType = BONE_FALLOFF_3X_FLAG;
						else if (foff == 3)
							mod->BoneData[mod->ModeBoneIndex].FalloffType = BONE_FALLOFF_X3_FLAG;
						mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);

						}

					break;
					}

				case ID_COPY:
					{
					mod->CopyBone();
					mod->iPaste->Enable(TRUE);
					break;
					}
				case ID_PASTE:
					{
					if (mod->BoneData.Count() > 0)
						{
						theHold.Begin();
						theHold.Put(new PasteRestore(mod));

						mod->PasteBone();
						theHold.Accept(GetString(IDS_PW_PASTE));
						}
					break;
					}



				case ID_ABSOLUTE:
					{
					int abso = mod->iAbsolute->IsChecked();
						//mod->iAbsolute->GetCurFlyOff();
					if (mod->BoneData.Count() > 0)
						{
						if (abso==0)

							mod->BoneData[mod->ModeBoneIndex].flags |= BONE_ABSOLUTE_FLAG;

							else mod->BoneData[mod->ModeBoneIndex].flags &= ~BONE_ABSOLUTE_FLAG;
						mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);

						}
					break;
					}
				case ID_DRAW_ENVELOPE:
//				case IDC_DISPLAY_ENVELOPE_CHECK:
					{
					if (mod->BoneData.Count() > 0)
						{

						int disp = mod->iEnvelope->IsChecked();//GetCurFlyOff();
						if (disp)
							{
							mod->BoneData[mod->ModeBoneIndex].flags |= BONE_DRAW_ENVELOPE_FLAG;
							}
							else 
							{
							mod->BoneData[mod->ModeBoneIndex].flags &= ~BONE_DRAW_ENVELOPE_FLAG;
							}
						mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);


						}
					break;
					}
				case IDC_REMOVE:
					{
					mod->RemoveBone();
					GetSystemSetting(SYSSET_CLEAR_UNDO);
					SetSaveRequiredFlag(TRUE);

					break;
					}
				case IDC_FILTER_VERTICES_CHECK:
					{
//					mod->ClearVertexSelections();
					break;
					}
				case IDC_FILTER_BONES_CHECK:
					{
					mod->ClearBoneEndPointSelections();
					break;
					}
				case IDC_FILTER_ENVELOPES_CHECK:
					{
					mod->ClearEnvelopeSelections();
					break;
					}
				case IDC_LIST1:
					{
					if (HIWORD(wParam)==LBN_SELCHANGE) {
						int fsel;

//						if (theHold.Holding() ) 
						if (mod->ip)
							{
							ModContextList mcList;		
							INodeTab nodes;

							mod->ip->GetModContexts(mcList,nodes);
							int objects = mcList.Count();

							for ( int i = 0; i < objects; i++ ) 
								{
								BoneModData *bmd = (BoneModData*)mcList[i]->localData;

								theHold.Begin();
								theHold.Put(new SelectionRestore(mod,bmd));
								theHold.Accept(GetString(IDS_PW_SELECT));
								}
							}

						fsel = SendMessage(
							GetDlgItem(hWnd,IDC_LIST1),
							LB_GETCURSEL,0,0);	
						int sel = mod->ConvertSelectedListToBoneID(fsel);

						mod->cacheValid = TRUE;
						mod->ModeBoneIndex = sel;
						mod->ModeBoneEndPoint = -1;
						mod->ModeBoneEnvelopeIndex = -1;
						mod->ModeBoneEnvelopeSubType = -1;
						mod->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
						mod->LastSelected = sel;

						mod->EnableRadius(FALSE);
						
						mod->UpdatePropInterface();


						}
					break;
					}



				}
			break;


		}
	return FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\BonesDef\DrawStuff.cpp ===
/**********************************************************************
 
	FILE: DrawStuff.cpp

	DESCRIPTION:  Stuff to draw bones and envelopes

	CREATED BY: Peter Watje

	HISTORY: 8/5/98




 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm.h"
#include "shape.h"
#include "spline3d.h"
#include "splshape.h"
#include "linshape.h"

// This uses the linked-list class templates
#include "linklist.h"
#include "bonesdef.h"


void BonesDefMod::LoadAxis(Point3 st, float dist, Matrix3 tm, Point3 *plist)
	{
	Point3 AxisStart,AxisEnd;

	AxisStart = st;
	AxisEnd = st;
	AxisStart.x -= dist;
	AxisEnd.x += dist;
	plist[0] = AxisStart * tm;
	plist[1] = AxisEnd * tm;

	AxisStart = st;
	AxisEnd = st;
	AxisStart.y -= dist;
	AxisEnd.y += dist;
	plist[2] = AxisStart * tm;
	plist[3] = AxisEnd * tm;

	AxisStart = st;
	AxisEnd = st;
	AxisStart.z -= dist;
	AxisEnd.z += dist;
	plist[4] = AxisStart * tm;
	plist[5] = AxisEnd * tm;


	}



void BonesDefMod::DrawCrossSection(Point3 a, Point3 align, float length,  Matrix3 tm, GraphicsWindow *gw)

{

#define NUM_SEGS	16

Point3 plist[NUM_SEGS+1];
Point3 mka,mkb,mkc,mkd;

align = Normalize(align);
	{
	int ct = 0;
	float angle = TWOPI/float(NUM_SEGS) ;
	Matrix3 rtm = RotAngleAxisMatrix(align, angle);
	Point3 p(0.0f,0.0f,0.0f);
	if (align.x == 1.0f)
		{
		p.z = length;
		}
	else if (align.y == 1.0f)
		{
		p.x = length;
		}
	else if (align.z == 1.0f)
		{
		p.y = length;
		}
	else if (align.x == -1.0f)
		{
		p.z = -length;
		}
	else if (align.y == -1.0f)
		{
		p.x = -length;
		}
	else if (align.z == -1.0f)
		{
		p.y = -length;
		}
	else 
		{
		p = Normalize(align^Point3(1.0f,0.0f,0.0f))*length;
		}

	for (int i=0; i<NUM_SEGS; i++) {
		p = p * rtm;
		plist[ct++] = p;
		}

	p = p * rtm;
	plist[ct++] = p;


	for (i=0; i<NUM_SEGS+1; i++) 
		{
		plist[i].x += a.x;
		plist[i].y += a.y;
		plist[i].z += a.z;
//		plist[i] = plist[i] * tm;
		}
	}
mka = plist[15];
mkb = plist[3];
mkc = plist[7];
mkd = plist[11];

gw->polyline(NUM_SEGS+1, plist, NULL, NULL, 0);
gw->marker(&mka,BIG_BOX_MRKR);
gw->marker(&mkb,BIG_BOX_MRKR);
gw->marker(&mkc,BIG_BOX_MRKR);
gw->marker(&mkd,BIG_BOX_MRKR);

}



void BonesDefMod::DrawCrossSectionNoMarkers(Point3 a, Point3 align, float length, GraphicsWindow *gw)

{

#define NNUM_SEGS	8

Point3 plist[NNUM_SEGS+1];
Point3 mka,mkb,mkc,mkd;

align = Normalize(align);
	{
	int ct = 0;
	float angle = TWOPI/float(NNUM_SEGS) ;
	Matrix3 rtm = RotAngleAxisMatrix(align, angle);
	Point3 p(0.0f,0.0f,0.0f);
	if (align.x == 1.0f)
		{
		p.z = length;
		}
	else if (align.y == 1.0f)
		{
		p.x = length;
		}
	else if (align.z == 1.0f)
		{
		p.y = length;
		}
	else if (align.x == -1.0f)
		{
		p.z = -length;
		}
	else if (align.y == -1.0f)
		{
		p.x = -length;
		}
	else if (align.z == -1.0f)
		{
		p.y = -length;
		}
	else 
		{
		p = Normalize(align^Point3(1.0f,0.0f,0.0f))*length;
		}

	for (int i=0; i<NNUM_SEGS; i++) {
		p = p * rtm;
		plist[ct++] = p;
		}

	p = p * rtm;
	plist[ct++] = p;


	for (i=0; i<NNUM_SEGS+1; i++) 
		{
		plist[i].x += a.x;
		plist[i].y += a.y;
		plist[i].z += a.z;
		}
	}
mka = plist[15];
mkb = plist[3];
mkc = plist[7];
mkd = plist[11];

gw->polyline(NNUM_SEGS+1, plist, NULL, NULL, 0);

}


void BonesDefMod::DrawEndCrossSection(Point3 a, Point3 align, float length,  Matrix3 tm, GraphicsWindow *gw)

{

#define NUM_SEGS	16
Point3 p_edge[4];
Point3 plist[NUM_SEGS+1];
GetCrossSectionLocal(a,align, length,  p_edge);



//align = Normalize(align);
	
int ct = 0;
float angle = TWOPI/float(NUM_SEGS) *.5f;

align = Normalize(p_edge[1]-a);

Matrix3 rtm = RotAngleAxisMatrix(align, angle);
Point3 p(0.0f,0.0f,0.0f);
p = p_edge[0]-a;

plist[0] = p;

for (int i=1; i<(NUM_SEGS+1); i++) 
	{
	p = p * rtm;
	plist[i] = p;
	}

for (i=0; i<(NUM_SEGS+1); i++) 
	{
	plist[i].x += a.x;
	plist[i].y += a.y;
	plist[i].z += a.z;
//	plist[i] = plist[i] * tm;
	}
	
gw->polyline((NUM_SEGS+1), plist, NULL, NULL, 0);


align = Normalize(p_edge[2]-a);

rtm = RotAngleAxisMatrix(align, angle);


p = p_edge[1]-a;

plist[0] = p;

for ( i=1; i<(NUM_SEGS+1); i++) 
	{
	p = p * rtm;
	plist[i] = p;
	}

for (i=0; i<(NUM_SEGS+1); i++) 
	{
	plist[i].x += a.x;
	plist[i].y += a.y;
	plist[i].z += a.z;
//	plist[i] = plist[i] * tm;
	}
	
gw->polyline((NUM_SEGS+1), plist, NULL, NULL, 0);


}

void BonesDefMod::GetCrossSectionLocal(Point3 a, Point3 align, float length, Point3 *p_edge)
{
#define GNUM_SEGS	4

Point3 plist[GNUM_SEGS];

align = Normalize(align);

	{
	int ct = 0;
	float angle = TWOPI/float(GNUM_SEGS) ;
	Matrix3 rtm = RotAngleAxisMatrix(align, angle);
	Point3 p(0.0f,0.0f,0.0f);
	if (align.x == 1.0f)
		{
		p.z = length;
		}
	else if (align.y == 1.0f)
		{
		p.x = length;
		}
	else if (align.z == 1.0f)
		{
		p.y = length;
		}
	else if (align.x == -1.0f)
		{
		p.z = -length;
		}
	else if (align.y == -1.0f)
		{
		p.x = -length;
		}
	else if (align.z == -1.0f)
		{
		p.y = -length;
		}
	else 
		{
		p = Normalize(align^Point3(1.0f,0.0f,0.0f))*length;
		}

	for (int i=0; i<GNUM_SEGS; i++) {
		p = p * rtm;
		plist[ct++] = p;
		}



	for (i=0; i<GNUM_SEGS; i++) 
		{
		plist[i].x += a.x;
		plist[i].y += a.y;
		plist[i].z += a.z;
		p_edge[i] = plist[i];
		}
	}
}

void BonesDefMod::GetCrossSection(Point3 a, Point3 align, float length,  Matrix3 tm,  Point3 *p_edge)

{

#define GNUM_SEGS	4

Point3 plist[GNUM_SEGS];

align = Normalize(align);

	{
	int ct = 0;
	float angle = TWOPI/float(GNUM_SEGS) ;
	Matrix3 rtm = RotAngleAxisMatrix(align, angle);
	Point3 p(0.0f,0.0f,0.0f);
	if (align.x == 1.0f)
		{
		p.z = length;
		}
	else if (align.y == 1.0f)
		{
		p.x = length;
		}
	else if (align.z == 1.0f)
		{
		p.y = length;
		}
	else if (align.x == -1.0f)
		{
		p.z = -length;
		}
	else if (align.y == -1.0f)
		{
		p.x = -length;
		}
	else if (align.z == -1.0f)
		{
		p.y = -length;
		}

	else 
		{
		p = Normalize(align^Point3(1.0f,0.0f,0.0f))*length;
		}

	for (int i=0; i<GNUM_SEGS; i++) {
		p = p * rtm;
		plist[ct++] = p;
		}



	for (i=0; i<GNUM_SEGS; i++) 
		{
		plist[i].x += a.x;
		plist[i].y += a.y;
		plist[i].z += a.z;
//		plist[i] = plist[i] * tm;
		p_edge[i] = plist[i];
		}
	}
}


void BonesDefMod::DrawEnvelope(Tab<Point3> a, Tab<float> length, int count, Matrix3 tm, GraphicsWindow *gw)
{
	
#define NUM_SEGS	16
Point3 plist[NUM_SEGS+1];
Point3 p_env[2];
Point3 pa_prev,pb_prev,pc_prev,pd_prev;

Point3 align = Normalize(a[1] - a[0]);

for (int j = 0; j < count; j++)
	{

	if (j == 0)
		{
//draw top arcs
		DrawEndCrossSection(a[j], align, length[j], tm, gw);
		}
	else if (j == (count -1))
		{
//draw bottom arcs
		Point3 align2 = Normalize(a[0] - a[1]);

		DrawEndCrossSection(a[j], align2, length[j], tm, gw);
		}

	Point3 p[4];

	GetCrossSection(a[j], align, length[j],  tm,  p);
	if (j == 0)
		{
		pa_prev =p[0];
		pb_prev =p[1];
		pc_prev =p[2];
		pd_prev =p[3];
		}
	else
		{
		p_env[0] = pa_prev;
		p_env[1] = p[0];
		gw->polyline(2, p_env, NULL, NULL, 0);
		pa_prev = p[0];

		p_env[0] = pb_prev;
		p_env[1] = p[1];
		gw->polyline(2, p_env, NULL, NULL, 0);
		pb_prev = p[1];

		p_env[0] = pc_prev;
		p_env[1] = p[2];
		gw->polyline(2, p_env, NULL, NULL, 0);
		pc_prev = p[2];


		p_env[0] = pd_prev;
		p_env[1] = p[3];
		gw->polyline(2, p_env, NULL, NULL, 0);
		pd_prev = p[3];

		

		}
	}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\BonesDef\MODS.H ===
/**********************************************************************
 *<
	FILE: mods.h

	DESCRIPTION:

	CREATED BY: Rolf Berteig (based on prim.h)

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __MODS__H
#define __MODS__H

#include "Max.h"
//#include "reslib.h"
#include "modsres.h"


TCHAR *GetString(int id);

extern ClassDesc* GetBonesDefModDesc();

// in mods.cpp
extern HINSTANCE hInstance;

// For 'Supports Object of Type' rollups
extern BOOL CALLBACK DefaultSOTProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

#define BIGFLOAT	float( 1.0e+37F )

#define NEWSWMCAT	_T("Modifiers")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\BonesDef\modsres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mods.rc
//
#define IDD_BENDPARAM                   101
#define IDC_TH_SELCURSOR                101
#define IDD_TAPERPARAM                  102
#define IDC_EXTRUDECUR                  102
#define IDD_SINWAVEPARAM                103
#define IDD_SINWAVEPARAM1               103
#define IDB_FACESELTYPES                103
#define IDC_CLOSECUR                    103
#define IDC_OUTLINECUR                  103
#define IDD_SINWAVEPARAM2               104
#define IDB_MASK_FACESELTYPES           104
#define IDC_SEGBREAKCUR                 104
#define IDD_SINWAVEMODPARAM             105
#define IDC_SEGREFINECUR                105
#define IDD_EDITMESHPARAM               106
#define IDD_EMPARAM_VERTEX              106
#define IDC_VERTCONNECTCUR              106
#define IDD_EMPARAM_FACE                107
#define IDC_VERTINSERTCUR               107
#define IDD_EMPARAM_EDGE                108
#define IDD_DETACH                      109
#define IDB_BOOLEANTYPES                110
#define IDD_EMPARAM_OBJECT              111
#define IDB_MASK_BOOLEANTYPES           111
#define IDD_ESPARAM_VERTEX              112
#define IDD_ESPARAM_OBJECT              113
#define IDD_ESPARAM_SEGMENT             114
#define IDD_ESPARAM_SPLINE              115
#define IDD_AUTHMSG                     116
#define IDD_AUTHORIZE                   117
#define IDB_MASK_BULBS                  117
#define IDD_TWISTPARAM                  118
#define IDB_BULBS                       118
#define IDD_ESPARAM_POLYGON             119
#define IDC_ADDVERTCUR                  119
#define IDB_MASK_MIRRORTYPES            119
#define IDD_EXTRUDEPARAM                120
#define IDB_MIRRORTYPES                 120
#define IDD_EPPARAM_VERTEX              121
#define IDD_EPPARAM_PATCH               122
#define IDD_EPPARAM_OBJECT              123
#define IDD_BOMBPARAMS                  124
#define IDD_ELPARAM_OBJECT              125
#define IDD_ELPARAM_PATH                126
#define IDD_ELPARAM_SECTION             127
#define IDD_AFFECTREGION                128
#define IDD_SKEWPARAM                   129
#define IDD_NOISEPARAM                  130
#define IDD_SINWAVEOMODPARAM            131
#define IDD_LINWAVEPARAM1               132
#define IDD_LINWAVEOMODPARAM            133
#define IDD_OPTIMIZEPARAM               134
#define IDD_DISPLACEPARAM               135
#define IDD_CLUSTNODEPARAM              136
#define IDD_EM_SELECTBYMAT              137
#define IDD_WINDPARAM                   138
#define IDD_GRAVITYPARAM                139
#define IDD_DEFLECTORPARAM              140
#define IDD_UVWMAPPARAM                 141
#define IDD_EMPARAM_SURFACE             142
#define IDD_EM_SELECTBYSMOOTH           143
#define IDD_DISPLACE_SOT                144
#define IDD_WINDRAIN_SOT                145
#define IDD_SINWAVE_SOT                 146
#define IDD_BOMB_SOT                    147
#define IDD_SELECTPARAM                 148
#define IDD_MATERIALPARAM               149
#define IDD_SMOOTHPARAM                 150
#define IDD_NORMALPARAM                 151
#define IDD_SURFREVPARAM                152
#define IDD_EPPARAM_EDGE                153
#define IDD_DISPLACEPARAM_WS            154
#define IDD_UNWRAP_FLOATER              155
#define IDB_UNWRAPTOOL                  156
#define IDB_MASK_UNWRAPTOOL             157
#define IDD_UNWRAP_PROP                 157
#define IDB_PARAMS                      161
#define IDB_PARAMS_MASK                 162
#define IDD_MAP_ACQUIRE                 201
#define IDD_RESETXFORM_PANEL            202
#define IDD_AFRPARAM                    203
#define IDD_BONESDEFPARAM               203
#define IDD_TESSPARAM                   204
#define IDD_BONESDEFADVANCED            204
#define IDD_MESHSEL_FACE                205
#define IDD_BONESDEFPAINT               205
#define IDD_MESHSEL_VERTEX              206
#define IDD_BONESDEFFILTER              206
#define IDD_MESHSEL_EDGE                207
#define IDD_MESHSEL_OBJECT              208
#define IDD_FACEEXTRUDEPARAM            209
#define IDD_UVWXFORMPARAM               210
#define IDD_MIRRORPARAM                 211
#define IDD_UNWRAP_PARAMS               212
#define IDD_PASTE_NAMEDSET              213
#define IDD_SEL_NAMEDSET                214
#define IDD_WINDGRAV_SOT                215
#define IDC_ANGLE                       1000
#define IDC_X                           1001
#define IDC_PHASE                       1001
#define IDC_Y                           1002
#define IDC_Z                           1003
#define IDC_RADIUS                      1004
#define IDC_DIR                         1004
#define IDC_TWIST_BIAS                  1004
#define IDC_REF_FRAME                   1004
#define IDC_ANGLESPINNER                1005
#define IDC_MODNOISE_SEED               1005
#define IDC_RADSPINNER                  1006
#define IDC_DIRSPINNER                  1006
#define IDC_TWIST_BIASSPIN              1006
#define IDC_CRV                         1007
#define IDC_PHASESPINNER                1007
#define IDC_MODNOISE_SEEDSPIN           1007
#define IDC_OPT_BIAS                    1007
#define IDC_DISP_UTILE                  1007
#define IDC_NS_LIST                     1007
#define IDC_AMT                         1008
#define IDC_DECAYSPINNER                1008
#define IDC_MODNOISE_ROUGHNESS          1008
#define IDC_OPT_BIASSPIN                1008
#define IDC_DISP_UTILESPIN              1008
#define IDC_SET_NAME                    1008
#define IDC_AMTSPINNER                  1009
#define IDC_DECAY                       1009
#define IDC_MODNOISE_ROUGHNESSSPIN      1009
#define IDC_DISP_VTILE                  1009
#define IDC_OPT_MAXEDGE                 1009
#define IDC_CRVSPINNER                  1010
#define IDC_MODNOISE_ITERATIONS         1010
#define IDC_DISP_VTILESPIN              1010
#define IDC_OPT_MAXEDGESPIN             1010
#define IDC_AMPLITUDE                   1011
#define IDC_TAPER_FROM                  1011
#define IDC_MODNOISE_ITERATIONSSPIN     1011
#define IDC_DISP_STRENGTH               1011
#define IDC_AMPSPINNER                  1012
#define IDC_TAPER_TO                    1012
#define IDC_DISP_STRENGTHSPIN           1012
#define IDC_WAVELEN                     1013
#define IDC_TAPER_FROMSPIN              1013
#define IDC_DISP_DECAY                  1013
#define IDC_WAVELENSPINNER              1014
#define IDC_TAPER_TOSPIN                1014
#define IDC_DISP_DECAYSPIN              1014
#define IDC_CIRCLES                     1015
#define IDC_DISP_BLUR                   1015
#define IDC_CIRCLESSPINNER              1016
#define IDC_DISP_BLURSPIN               1016
#define IDC_SEGS                        1017
#define IDC_DISP_CENTERL                1017
#define IDC_SEGSPINNER                  1018
#define IDC_DISP_CENTERLSPIN            1018
#define IDC_DIVISIONS                   1019
#define IDC_DIVSPINNER                  1020
#define IDC_FLEX                        1021
#define IDC_STRENGTH                    1021
#define IDC_AMPSPINNER2                 1021
#define IDC_FLEXSPINNER                 1022
#define IDC_STRENGTHSPIN                1022
#define IDC_AMPLITUDE2                  1022
#define IDC_AUTHORIZE                   1023
#define IDC_GRAVITYSPIN                 1023
#define IDC_LOCKID                      1024
#define IDC_GRAVITY                     1024
#define IDC_EDIT2                       1025
#define IDC_DETONATIONSPIN              1025
#define IDC_DETACH                      1026
#define IDC_DETONATION                  1026
#define IDC_TESSELLATE                  1027
#define IDC_BOMB_CHAOSSPIN              1027
#define IDC_AFFECTREGION                1028
#define IDC_EXPLODE                     1028
#define IDC_BOMB_CHAOS                  1028
#define IDC_BACKFACE_VERTS              1029
#define IDC_WELDTHRESH                  1030
#define IDC_THRESHSPINNER               1031
#define IDC_EXTRUDEAMOUNT               1033
#define IDC_EXTRUDESPINNER              1034
#define IDC_PLANARSPINNER               1035
#define IDC_SMOOTH_THRESHSPIN           1035
#define IDC_TES_EDGE                    1036
#define IDC_SMOOTH_THRESH               1036
#define IDC_TES_CENTER                  1037
#define IDC_NORMAL_SCALESPIN            1037
#define IDC_TENSIONSPINNER              1038
#define IDC_NORMAL_SCALE                1038
#define IDC_TENSION                     1039
#define IDC_MAT_IDSPIN                  1039
#define IDC_EXTRUDE                     1040
#define IDC_MAT_ID                      1040
#define IDC_WELD                        1041
#define IDC_PLANAR                      1041
#define IDC_COLLAPSE                    1042
#define IDC_EDITCURVE                   1042
#define IDC_INSERT                      1042
#define IDC_Break                       1043
#define IDC_VERTBREAK                   1043
#define IDC_LEVEL                       1043
#define IDC_MAKEPLANAR                  1043
#define IDC_REFINE                      1044
#define IDC_LEVELSPINNER                1044
#define IDC_BUILDFACE                   1044
#define IDC_MAKEFIRST                   1044
#define IDC_SELTYPE                     1045
#define IDC_VERTREFINE                  1045
#define IDC_TES_FACE_TRI                1045
#define IDC_CLOSE                       1046
#define IDC_ANGLETHRESHSPIN             1046
#define IDC_OUTLINE                     1047
#define IDC_ANGLETRESH                  1047
#define IDC_TES_FACE_POLY               1047
#define IDC_BOOLEAN                     1048
#define IDC_DELETEFACE                  1048
#define IDC_OUTCENTER                   1049
#define IDC_FACE_HIDE                   1049
#define IDC_DETACHCOPY                  1050
#define IDC_CONNECT                     1050
#define IDC_FACE_UNHIDEALL              1050
#define IDC_SEGBREAK                    1051
#define IDC_DELETE                      1051
#define IDC_DELETESPLINE                1051
#define IDC_ATTACH                      1052
#define IDC_SEGDELETE                   1052
#define IDC_ATTACHCUR                   1052
#define IDC_MIRROR                      1052
#define IDC_OUTLINEWIDTH                1053
#define IDC_CREATELINE                  1053
#define IDC_OUTLINESPINNER              1054
#define IDC_DETACH_NAME                 1055
#define IDC_ALIGNLEFT                   1055
#define IDC_ALIGNMIN                    1055
#define IDC_MIRRORCOPY                  1055
#define IDC_RETAIN_ORIENT               1056
#define IDC_GETSHAPE                    1056
#define IDC_CONST_ORIENT                1057
#define IDC_LOCK_HANDLES                1057
#define IDC_LOCKALIKE                   1058
#define IDC_ALIGNCENTER                 1058
#define IDC_LOCKALL                     1059
#define IDC_BOOLTYPE                    1059
#define IDC_ALIGNRIGHT                  1059
#define IDC_ALIGNMAX                    1059
#define IDC_ATTACHREORIENT              1060
#define IDC_MIRRORTYPE                  1060
#define IDC_DETACHREORIENT              1061
#define IDC_VERTDELETE                  1062
#define IDC_AMOUNT                      1063
#define IDC_AMOUNTSPINNER               1064
#define IDC_SMOOTH_GRP1                 1064
#define IDC_SEGMENTSPINNER              1065
#define IDC_SMOOTH_GRP2                 1065
#define IDC_ADDTRI                      1065
#define IDC_SEGMENTS                    1066
#define IDC_SMOOTH_GRP3                 1066
#define IDC_ADDQUAD                     1066
#define IDC_CAPSTART                    1067
#define IDC_SMOOTH_GRP4                 1067
#define IDC_CAPEND                      1068
#define IDC_SMOOTH_GRP5                 1068
#define IDC_SMOOTH_GRP6                 1069
#define IDC_SECDELETE                   1070
#define IDC_SMOOTH_GRP7                 1070
#define IDC_SHAPESTEPS                  1070
#define IDC_GETPATH                     1071
#define IDC_SECALIGN                    1071
#define IDC_SMOOTH_GRP8                 1071
#define IDC_SECCENTER                   1072
#define IDC_SMOOTH_GRP9                 1072
#define IDC_ALIGNTYPES                  1073
#define IDC_SMOOTH_GRP10                1073
#define IDC_SMOOTH_GRP11                1074
#define IDC_VERT_DELETE                 1075
#define IDC_SMOOTH_GRP12                1075
#define IDC_VERT_CREATE                 1076
#define IDC_SMOOTH_GRP13                1076
#define IDC_EXP_OBJECTS                 1077
#define IDC_VERT_COLLAPSE               1077
#define IDC_SMOOTH_GRP14                1077
#define IDC_EXP_ELEMENTS                1078
#define IDC_SMOOTH_GRP15                1078
#define IDC_VERT_DETACH                 1078
#define IDC_OBJ_ATTACH                  1079
#define IDC_SMOOTH_GRP16                1079
#define IDC_EDGE_DIVIDE                 1080
#define IDC_SMOOTH_GRP17                1080
#define IDC_EDGE_TURN                   1081
#define IDC_VERT_WELD                   1081
#define IDC_SMOOTH_GRP18                1081
#define IDC_EDGE_VIS                    1082
#define IDC_SMOOTH_GRP19                1082
#define IDC_VERT_WELDTOVERT             1082
#define IDC_EDGE_INVIS                  1083
#define IDC_SMOOTH_GRP20                1083
#define IDC_EDGE_AUTO                   1084
#define IDC_WELDTHRESHSPIN              1084
#define IDC_SMOOTH_GRP21                1084
#define IDC_EDGE_DELETE                 1085
#define IDC_FACE_DETACH                 1085
#define IDC_SMOOTH_GRP22                1085
#define IDC_EDGE_COLLAPSE               1086
#define IDC_FALLOFF                     1086
#define IDC_SMOOTH_GRP23                1086
#define IDC_FALLOFFSPIN                 1087
#define IDC_SMOOTH_GRP24                1087
#define IDC_EDGE_COPYNS                 1087
#define IDC_PINCHSPIN                   1088
#define IDC_SMOOTH_GRP25                1088
#define IDC_EDGE_PASTENS                1088
#define IDC_SPIN                        1088
#define IDC_PINCH                       1089
#define IDC_SMOOTH_GRP26                1089
#define IDC_SPINSPIN                    1089
#define IDC_BUBBLESPIN                  1090
#define IDC_SMOOTH_GRP27                1090
#define IDC_MINFRAG                     1090
#define IDC_BUBBLE                      1091
#define IDC_SMOOTH_GRP28                1091
#define IDC_MINFRAGSPIN                 1091
#define IDC_NEARLABEL                   1092
#define IDC_SMOOTH_GRP29                1092
#define IDC_MAXFRAG                     1092
#define IDC_FARLEFTLABEL                1093
#define IDC_SMOOTH_GRP30                1093
#define IDC_MAXFRAGSPIN                 1093
#define IDC_FARRIGHTLABEL               1094
#define IDC_SMOOTH_GRP31                1094
#define IDC_SEED                        1094
#define IDC_AR_GRAPH                    1095
#define IDC_SMOOTH_GRP32                1095
#define IDC_SEEDSPIN                    1095
#define IDC_TENSTEXT                    1096
#define IDC_TAPER_AFFECTREGION          1098
#define IDC_EFFECT_X                    1104
#define IDC_EFFECT_Y                    1105
#define IDC_EFFECT_BOTH                 1106
#define IDC_TAPER_SYMMETRY              1107
#define IDC_BEND_AFFECTREGION           1108
#define IDC_BEND_TO                     1109
#define IDC_BEND_TOSPIN                 1110
#define IDC_BEND_FROM                   1111
#define IDC_BEND_FROMSPIN               1112
#define IDC_TWIST_AFFECTREGION          1113
#define IDC_MODNOISE_FRACTAL            1113
#define IDC_TWIST_TO                    1114
#define IDC_MODNOISE_ANIMATE            1114
#define IDC_TWIST_TOSPIN                1115
#define IDC_TWIST_FROM                  1116
#define IDC_TWIST_FROMSPIN              1117
#define IDC_SKEW_AMOUNT                 1118
#define IDC_SKEW_AMOUNTSPIN             1119
#define IDC_SKEW_AFFECTREGION           1120
#define IDC_SKEW_TO                     1121
#define IDC_SKEW_TOSPIN                 1122
#define IDC_SKEW_FROM                   1123
#define IDC_SKEW_FROMSPIN               1124
#define IDC_MODNOISE_XSTRENGTH          1127
#define IDC_MODNOISE_XSTRENGTHSPIN      1128
#define IDC_MODNOISE_YSTRENGTH          1129
#define IDC_MODNOISE_YSTRENGTHSPIN      1130
#define IDC_MODNOISE_ZSTRENGTH          1131
#define IDC_MODNOISE_ZSTRENGTHSPIN      1132
#define IDC_MODNOISE_SCALE              1133
#define IDC_MODNOISE_SCALESPIN          1134
#define IDC_MODNOISE_ROUGHNESSLABEL     1135
#define IDC_MODNOISE_FREQ               1136
#define IDC_OPT_PRESERVEMAT             1136
#define IDC_MODNOISE_FREQSPIN           1137
#define IDC_OPT_RENDERL1                1137
#define IDC_OPT_RENDERL2                1138
#define IDC_MODNOISE_PHASE              1138
#define IDC_OPT_VIEWSL1                 1139
#define IDC_MODNOISE_PHASESPIN          1139
#define IDC_OPT_VIEWSL2                 1140
#define IDC_MODNOISE_ITERATIONSLABEL    1140
#define IDC_OPT_FACETHRESH              1141
#define IDC_OPT_FACETHRESHSPIN          1142
#define IDC_OPT_EDGETHRESH              1143
#define IDC_OPT_EDGETHRESHSPIN          1144
#define IDC_OPT_PRESERVESMOOTH          1145
#define IDC_OPT_AUTOEDGE                1146
#define IDC_OPT_VERTCOUNT               1147
#define IDC_OPT_FACECOUNT               1148
#define IDC_DISP_PLANAR                 1149
#define IDC_DISP_CYL                    1150
#define IDC_DISP_SPHERE                 1151
#define IDC_DISP_USEMAP                 1152
#define IDC_DISP_APPLYMAP               1153
#define IDC_DISP_CENTERLUM              1154
#define IDC_DISP_PICKIMAGE              1155
#define IDC_DISP_REMOVEIMAGE            1156
#define IDC_CLUST_PICKNODE              1157
#define IDC_DISP_PICKMAP                1157
#define IDC_CREATE_CROSS_SECTION        1157
#define IDC_CLUST_NODENAME              1158
#define IDC_DISP_REMOVEMAP              1158
#define IDC_CREATE_REMOVE_SECTION       1158
#define IDC_PAINT                       1159
#define IDC_DISPLENGTH                  1161
#define IDC_DISPLENGTHSPIN              1162
#define IDC_WIND_STRENGTH               1163
#define IDC_WIND_STRENGTHSPIN           1164
#define IDC_FORCE_PLANAR                1165
#define IDC_FORCE_SPHERICAL             1166
#define IDC_WIND_DECAYSPIN              1167
#define IDC_WIND_DECAY                  1168
#define IDC_WIND_TURBSPIN               1169
#define IDC_WIND_TURB                   1170
#define IDC_GRAV_STRENGTH               1171
#define IDC_WIND_FREQSPIN               1171
#define IDC_GRAV_STRENGTHSPIN           1172
#define IDC_WIND_FREQ                   1172
#define IDC_GRAV_DECAY                  1173
#define IDC_WIND_SCALESPIN              1173
#define IDC_GRAV_DECAYSPIN              1174
#define IDC_WIND_SCALE                  1174
#define IDC_DEFLECT_BOUNCE              1175
#define IDC_DEFLECT_BOUNCESPIN          1176
#define IDC_DEFLECT_WIDTH               1177
#define IDC_DEFLECT_WIDTHSPIN           1178
#define IDC_DEFLECT_HEIGHTSPIN          1179
#define IDC_MAP_PLANAR                  1179
#define IDC_DEFLECT_HEIGHT              1180
#define IDC_MAP_CYL                     1180
#define IDC_MAP_SPHERE                  1181
#define IDC_MAP_BALL                    1182
#define IDC_MAP_FIT                     1183
#define IDC_MAP_CENTER                  1184
#define IDC_MAP_VIEWALIGN               1185
#define IDC_MAP_NORMALALIGN             1186
#define IDC_MAP_BOX                     1187
#define IDC_MAP_FITREGION               1188
#define IDC_MAP_BITMAPFIT               1189
#define IDC_MAP_UFLIP                   1190
#define IDC_MAP_VFLIP                   1191
#define IDC_MAP_UTILESPIN               1192
#define IDC_MAP_VTILESPIN               1193
#define IDC_MAP_VTILE                   1194
#define IDC_MAP_UTILE                   1195
#define IDC_MAP_WTILE                   1196
#define IDC_SMOOTH_AUTO                 1196
#define IDC_MAP_WTILESPIN               1197
#define IDC_NORMAL_FLIP                 1197
#define IDC_SMOOTH_PREVENTINDIRECT      1197
#define IDC_MAP_WFLIP                   1198
#define IDC_NORMAL_UNIFY                1198
#define IDC_NORMAL_SHOW                 1199
#define IDC_MAP_UOFFSET                 1199
#define IDC_MAP_RESET2                  1199
#define IDC_MAP_RESET                   1199
#define IDC_SELECT_BYID                 1200
#define IDC_CLEARSELECTION              1200
#define IDC_MAP_VOFFSET                 1200
#define IDC_MAP_ACQUIRE2                1200
#define IDC_MAP_ACQUIRE                 1200
#define IDC_SELECTBYSMOOTH              1201
#define IDC_SEL_OBJECT                  1201
#define IDC_MAP_WOFFSET                 1201
#define IDC_MAP_FACE                    1201
#define IDC_SEL_VERTEX                  1202
#define IDC_MAP_UOFFSETSPIN             1202
#define IDC_MAP_LENGTH                  1202
#define IDC_SEL_FACE                    1203
#define IDC_MAP_VOFFSETSPIN             1203
#define IDC_MAP_WIDTH                   1203
#define IDC_SEL_ADD                     1204
#define IDC_MAP_WOFFSETSPIN             1204
#define IDC_MAP_HEIGHT                  1204
#define IDC_SEL_SUBTRACT                1205
#define IDC_MAP_LENGTHSPIN              1205
#define IDC_SEL_REPLACE                 1206
#define IDC_MAP_WIDTHSPIN               1206
#define IDC_SEL_WINDOW                  1207
#define IDC_MAP_HEIGHTSPIN              1207
#define IDC_SEL_CROSSING                1208
#define IDC_SEL_BOX                     1209
#define IDC_SEL_SPHERE                  1210
#define IDC_SEL_CYLINDER                1211
#define IDC_SEL_FIT                     1212
#define IDC_SEL_CENTER                  1213
#define IDC_SEL_RESET                   1214
#define IDC_MATID                       1215
#define IDC_MATIDSPIN                   1216
#define IDC_SEL_INVERT                  1218
#define IDC_NORM_UNIFY                  1219
#define IDC_NORM_FLIP                   1220
#define IDC_MAP_CAP                     1220
#define IDC_DEGREES                     1221
#define IDC_DEGREESSPINNER              1222
#define IDC_MORPHCAP                    1223
#define IDC_GRIDCAP                     1224
#define IDC_WELDCORE                    1226
#define IDC_DISPLATTICE                 1229
#define IDC_DISPSURFACE                 1230
#define IDC_DELETEPATCH                 1231
#define IDC_DISPCONTROL                 1232
#define IDC_DELETEVERT                  1232
#define IDC_SUBDIVIDE                   1233
#define IDC_PROPAGATE                   1235
#define IDC_ADAPTIVE                    1236
#define IDC_STEPS                       1237
#define IDC_STEPSSPINNER                1238
#define IDC_DISP_BALL                   1239
#define IDC_TESS_U_SPINNER              1239
#define IDC_TESS_U                      1240
#define IDC_TESS_V_SPINNER              1241
#define IDC_DISP_WTILE                  1242
#define IDC_TESS_V                      1242
#define IDC_DISP_WTILESPIN              1243
#define IDC_TESS_DIST_SPINNER           1243
#define IDC_DISP_WFLIP                  1244
#define IDC_TESS_DIST                   1244
#define IDC_DISP_VFLIP                  1245
#define IDC_TESS_ANG_SPINNER            1245
#define IDC_DISP_UFLIP                  1246
#define IDC_TESS_ANG                    1246
#define IDC_DISP_FIT                    1247
#define IDC_TESS_EDGE_SPINNER           1247
#define IDC_DISP_CENTER                 1248
#define IDC_TESS_EDGE                   1248
#define IDC_DISP_BITMAPFIT              1249
#define IDC_DISP_NORMALALIGN            1250
#define IDC_DISP_RESET                  1251
#define IDC_VERT_HIDE                   1252
#define IDC_DISP_ACQUIRE                1252
#define IDC_VERT_UNHIDEALL              1253
#define IDC_PATCH                       1254
#define IDC_MESH                        1255
#define IDC_FILTVERTS                   1255
#define IDC_FILTVECS                    1256
#define IDC_SEL_BYVERT                  1256
#define IDC_GENMAPPING                  1257
#define IDC_FLIPNORMALS                 1258
#define IDC_SPLINE_VERT_COUNT           1259
#define IDC_GEN_MATIDS                  1259
#define IDC_SPLINE_VERT_COUNT_TITLE     1260
#define IDC_RESETTM_SELECTED            1261
#define IDC_AFR_FALLOFF                 1262
#define IDC_AFR_EFFECT                  1262
#define IDC_EFFECT                      1262
#define IDC_AFR_FALLOFFSPIN             1263
#define IDC_AFR_EFFECTSPIN              1263
#define IDC_EFFECTSPIN                  1263
#define IDC_AFR_BACKFACE                1264
#define IDC_EXT_SCALE                   1264
#define IDC_AFR_ABSOLUTE                1264
#define IDC_ERADIUS                     1264
#define IDC_EXT_SCALESPIN               1265
#define IDC_LIST1                       1265
#define IDC_AFR_PINCH                   1266
#define IDC_TENSIONSPIN                 1266
#define IDC_AFR_STRENGTH                1266
#define IDC_AFR_INNER                   1266
#define IDC_ERADIUSSPIN                 1266
#define IDC_AFR_PINCHSPIN               1267
#define IDC_ITERATIONS1                 1267
#define IDC_AFR_STRENGTHSPIN            1267
#define IDC_AFR_INNERSPIN               1267
#define IDC_REF_FRAME_SPIN              1267
#define IDC_AFR_BUBBLE                  1268
#define IDC_ITERATIONS2                 1268
#define IDC_MESHSEL_GETVERT             1268
#define IDC_AFR_MULT                    1268
#define IDC_AFR_OUTER                   1268
#define IDC_SRADIUS                     1268
#define IDC_AFR_BUBBLESPIN              1269
#define IDC_ITERATIONS3                 1269
#define IDC_MESHSEL_GETFACE             1269
#define IDC_AFR_MULTSPIN                1269
#define IDC_AFR_OUTERSPIN               1269
#define IDC_SRADIUSSPIN                 1269
#define IDC_ITERATIONS4                 1270
#define IDC_MESHSEL_GETEDGE             1270
#define IDC_MESHSEL_SELOPEN             1270
#define IDC_ADD                         1270
#define IDC_EXT_CENTER                  1271
#define IDC_MESHSEL_SELBYMAT            1271
#define IDC_REMOVE                      1271
#define IDC_EXT_AMOUNT                  1272
#define IDC_RESET                       1272
#define IDC_PAINT_STR                   1272
#define IDC_PAINT_STR2                  1272
#define IDC_EXT_AMOUNTSPIN              1273
#define IDC_SAVE                        1273
#define IDC_DISP_VIEWALIGN              1274
#define IDC_MINUS                       1274
#define IDC_AFR_LINNER                  1274
#define IDC_RESET_ALL                   1274
#define IDC_DISP_FITREGION              1275
#define IDC_PLUS                        1275
#define IDC_AFR_LOUTER                  1275
#define IDC_UNLOCK_VERTS                1275
#define IDC_AFR_EFFECT_RELATIVE         1276
#define IDC_AFR_LINNERSPIN              1276
#define IDC_FEATHER                     1276
#define IDS_MIRROR_X                    1277
#define IDC_AFR_EFFECT_RELATIVESPIN     1277
#define IDC_AFR_LOUTERSPIN              1277
#define IDC_FEATHERSPIN                 1277
#define IDS_MIRROR_Y                    1278
#define IDC_BUILD_FALLOFF               1278
#define IDS_MIRROR_Z                    1279
#define IDC_SELECT_FLEX                 1279
#define IDS_MIRROR_XY                   1280
#define IDC_ERROR                       1280
#define IDC_PAINT_STR_SPIN              1280
#define IDC_PAINT_STR_SPIN2             1280
#define IDS_MIRROR_YZ                   1281
#define IDS_MIRROR_ZX                   1282
#define IDC_MIRROR_COPY                 1283
#define IDC_MIRROR_OFFSET               1284
#define IDC_MIRROR_OFFSETSPIN           1285
#define IDC_IGNORE_BACKFACES            1286
#define IDC_IGNORE_VISEDGE              1287
#define IDC_UNWRAP_EDIT                 1287
#define IDC_UNWARP_TOOLBAR              1288
#define IDC_UNWRAP_RESET                1288
#define IDC_BONE_TOOLBAR                1288
#define IDC_SCROLLBAR1                  1289
#define IDC_UNWRAP_VIEW                 1290
#define IDC_UNWRAP_LINECOLOR            1291
#define IDC_UNWRAP_XOR                  1292
#define IDC_UNWRAP_SELCOLOR             1293
#define IDC_UNWRAP_CONSTANTUPDATE       1294
#define IDC_UNWRAP_WIDTH                1295
#define IDC_UNWRAP_WIDTHSPIN            1296
#define IDC_UNWRAP_HEIGHT               1297
#define IDC_UNWRAP_HEIGHTSPIN           1298
#define IDC_UNWRAP_DEFAULTS             1299
#define IDC_FACE_COPYNS                 1301
#define IDC_TESS_VIEW                   1301
#define IDC_FACE_PASTENS                1302
#define IDC_TESS_RENDERER               1302
#define IDC_VERT_COPYNS                 1303
#define IDC_TESS_SET                    1303
#define IDC_VERT_PASTENS                1304
#define IDC_OPT_UPDATE                  1305
#define IDC_TESS_PARAM                  1305
#define IDC_OPT_MANUPDATE               1306
#define IDC_TESS_SPATIAL                1306
#define IDC_TESS_CURV                   1307
#define IDC_DISP_CAP                    1307
#define IDC_TESS_VIEW_DEP               1308
#define IDC_NUMSEL_LABEL                1309
#define IDC_MAP_CHAN1                   1310
#define IDC_LENGTH_LABEL                1311
#define IDC_MAP_CHAN2                   1312
#define IDC_WIDTH_LABEL                 1313
#define IDC_HEIGHT_LABEL                1314
#define IDC_MAP_X                       1315
#define IDC_MAP_Y                       1316
#define IDC_MAP_Z                       1317
#define IDC_DISP_LENGTH                 1318
#define IDC_DISP_LENGTHSPIN             1319
#define IDC_DISP_WIDTH                  1320
#define IDC_DISP_WIDTHSPIN              1321
#define IDC_DISP_HEIGHT                 1322
#define IDC_DISP_HEIGHTSPIN             1323
#define IDC_DISP_X                      1324
#define IDC_DISP_Y                      1325
#define IDC_DISP_Z                      1326
#define IDC_NURBS                       1327
#define IDC_UNWRAP_U                    1328
#define IDC_UNWRAP_USPIN                1329
#define IDC_UNWRAP_ULABEL               1330
#define IDC_UNWRAP_V                    1331
#define IDC_FALLOFF_ON                  1331
#define IDC_UNWRAP_VSPIN                1332
#define IDC_FILTER_VERTICES_CHECK       1332
#define IDC_UNWRAP_VLABEL               1333
#define IDC_FILTER_BONES_CHECK          1333
#define IDC_UNWRAP_W                    1334
#define IDC_FILTER_ENVELOPES_CHECK      1334
#define IDC_UNWRAP_WSPIN                1335
#define IDC_DRAWALL_ENVELOPES_CHECK     1335
#define IDC_UNWRAP_WLABEL               1336
#define IDC_DRAW_VERTICES_CHECK         1336
#define IDC_LOCK_BONE_CHECK             1337
#define IDC_ABSOLUTE_INFLUENCE_CHECK    1338
#define IDC_PROJECT_THROUGH_CHECK       1339
#define IDC_FALLOFF_CHECK               1340
#define IDC_RADIO1                      1341
#define IDC_RADIO2                      1342
#define IDC_INNER                       1342
#define IDC_RADIO3                      1343
#define IDC_OUTER                       1343
#define IDC_RADIO4                      1344
#define IDC_INNERSPIN                   1344
#define IDC_RADIO5                      1345
#define IDC_OUTERSPIN                   1345
#define IDC_INNERSPIN2                  1345
#define IDC_RADIO6                      1346
#define IDC_DISPLAY_ENVELOPE_CHECK      1347
#define IDC_ALWAYSDEFORM_CHECK          1348
#define IDC_AUTOENVELOPE_CHECK          1349
#define IDC_OUTER2                      1350
#define IDC_OUTERSPIN2                  1351
#define IDC_ACQUIRE_REL                 1552
#define IDC_ACQUIRE_ABS                 1553
#define IDC_SELSINGLE                   5000
#define IDC_SELPOLY                     5001
#define IDC_SELELEMENT                  5002
#define IDC_BOOLUNION                   5010
#define IDC_BOOLSUBTRACTION             5011
#define IDC_BOOLINTERSECTION            5012
#define IDS_DS_MOVE2                    10004
#define IDS_DS_SELECT                   10007
#define IDS_DS_CREATE                   10008
#define IDS_RB_EXTRUDE                  30001
#define IDS_RB_TAPER                    30003
#define IDS_RB_OBJECT                   30004
#define IDS_RB_EDITMESH                 30009
#define IDS_RB_EDITMESHTOOLS            30010
#define IDS_RB_VERTEX                   30011
#define IDS_RB_FACE                     30012
#define IDS_RB_EDGE                     30013
#define IDS_RB_CENTER                   30014
#define IDS_RB_APPARATUS                30015
#define IDS_RB_EDITVERTEX               30016
#define IDS_RB_EDITOBJECT               30017
#define IDS_RB_EDITFACE                 30018
#define IDS_RB_EDITEDGE                 30019
#define IDS_RB_EDITPOLY                 30020
#define IDS_RB_EDITELEMENT              30021
#define IDS_RB_EDITMESH_CLASS           30022
#define IDS_RB_PARAMETERS               30028
#define IDS_RB_ANGLE                    30029
#define IDS_RB_DIRECTION                30030
#define IDS_RB_AMOUNT                   30031
#define IDS_RB_AMOUNT2                  30032
#define IDS_RB_CURVITURE                30033
#define IDS_RB_AMPLITUDE                30034
#define IDS_RB_WAVELEN                  30035
#define IDS_RB_PHASE                    30036
#define IDS_RB_DECAY                    30037
#define IDS_RB_FLEXIBILITY              30038
#define IDS_RB_WIDTH                    30039
#define IDS_RB_HEIGHT                   30040
#define IDS_DB_EXTRUDE                  30041
#define IDS_RB_NONE                     30137
#define IDS_RB_RIPPLE                   30155
#define IDS_RB_RIPPLE_BINDING           30156
#define IDS_RB_DELETEVERT               30211
#define IDS_RB_DELETEFACE               30212
#define IDS_RB_ADDVERTS                 30213
#define IDS_RB_ATTACHOBJECT             30214
#define IDS_RB_FACECOLLAPSE             30215
#define IDS_RB_MAKEPLANAR               30216
#define IDS_RB_BUILDFACE                30217
#define IDS_RB_HIDEFACE                 30218
#define IDS_RB_UNHIDEALLFACES           30219
#define IDS_RB_EDGEVISIBLE              30220
#define IDS_RB_EDGEINVISIBLE            30221
#define IDS_RB_AUTOEDGE                 30222
#define IDS_RB_EDGEDIVIDE               30223
#define IDS_RB_EDGETURN                 30224
#define IDS_RB_DELETEEDGE               30225
#define IDS_RB_COLLAPSEEDGE             30226
#define IDS_RB_CLONE                    30227
#define IDS_RB_TESSELLATE               30228
#define IDS_RB_DELETEISOLATED           30229
#define IDS_RB_DEFDEFORMATIONS          30270
#define IDS_RB_DEFEDIT                  30271
#define IDS_RB_NODEXFORM                30276
#define IDS_RB_NODEXFORM_CLASS          30277
#define IDS_RB_XFORM_CLASS              30278
#define IDS_RB_EDITSURFACE              30279
#define IDS_RB_SETSMOOTHGROUP           30280
#define IDS_RB_ASSIGNMATID              30281
#define IDS_RB_FLIPNORMALS              30282
#define IDS_RB_UNIFYNORMALS             30283
#define IDS_RB_AUTOSMOOTH               30284
#define IDS_RB_SELECTBYMATID            30285
#define IDS_RB_SELECTBYSMOOTH           30286
#define IDS_RB_SOT                      30287
#define IDS_RB_DEFLECTOR_CLASS          30288
#define IDS_RB_HIDEVERT                 30294
#define IDS_RB_DEFSURFACE               30298
#define IDS_RB_SCALE                    30377
#define IDS_RB_NOISE                    30411
#define IDS_RB_ROTATION2                30521
#define IDS_RB_TWIST                    30522
#define IDS_RB_BENDMOD                  30543
#define IDS_RB_BEND2                    30544
#define IDS_RB_FROM                     30545
#define IDS_RB_TO                       30546
#define IDS_RB_BOMBOBJECT               30547
#define IDS_RB_BOMB                     30548
#define IDS_RB_BOMBMOD                  30549
#define IDS_RB_BOMBBINDING              30550
#define IDS_RB_CLUSTNODEMOD             30551
#define IDS_RB_XFORM                    30552
#define IDS_RB_DEFLECTOR                30553
#define IDS_RB_DEFLECTMOD               30554
#define IDS_RB_DEFLECTORBINDING         30555
#define IDS_RB_BOUNCE                   30556
#define IDS_RB_DISPMOD                  30557
#define IDS_RB_DISPLACE                 30558
#define IDS_RB_DISPLACEMOD              30559
#define IDS_RB_DISPLACEBINDING          30560
#define IDS_RB_SELECTDISPIMAGE          30561
#define IDS_RB_SELECTIMAGE              30562
#define IDS_RB_UTILE                    30563
#define IDS_RB_VTILE                    30564
#define IDS_RB_WTILE                    30565
#define IDS_RB_BLUR                     30566
#define IDS_RB_DOCREATENEWOBJECT        30567
#define IDS_RB_EDITMESH2                30568
#define IDS_RB_GRAVITY                  30569
#define IDS_RB_WIND                     30570
#define IDS_RB_GRAVITYMOD               30571
#define IDS_RB_GRAVITYBINDING           30572
#define IDS_RB_WINDMOD                  30573
#define IDS_RB_WINDBINDING              30574
#define IDS_RB_TURBULENCE               30575
#define IDS_RB_FREQUENCY                30576
#define IDS_RB_MAPMOD                   30577
#define IDS_RB_UVWMAPPING               30578
#define IDS_RB_UVWMAP                   30579
#define IDS_RB_NOISEMOD                 30580
#define IDS_RB_SEED                     30581
#define IDS_RB_FRACTAL                  30582
#define IDS_RB_ROUGH                    30583
#define IDS_RB_ITERATIONS               30584
#define IDS_RB_OPTMOD                   30585
#define IDS_RB_OPTIMIZE                 30586
#define IDS_RB_FACETHRESHL1             30587
#define IDS_RB_FACETHRESHL2             30588
#define IDS_RB_EDGETHRESHL1             30589
#define IDS_RB_EDGETHRESHL2             30590
#define IDS_RB_BIASL1                   30591
#define IDS_RB_BIASL2                   30592
#define IDS_RB_EDITMESHMOD              30593
#define IDS_RB_TWISTMOD                 30594
#define IDS_RB_TWIST2                   30595
#define IDS_RB_TWISTPLUGIN              30596
#define IDS_RB_BIAS                     30597
#define IDS_RB_INCORRECTSTRING          30598
#define IDS_RB_AUTHORIZATION            30599
#define IDS_RB_TAPERMOD                 30600
#define IDS_RB_SYMMETRY                 30601
#define IDS_RB_MATMOD                   30602
#define IDS_RB_MATERIAL3                30603
#define IDS_RB_MATERIALID               30604
#define IDS_RB_MATERIAL4                30605
#define IDS_RB_MATERIALID2              30606
#define IDS_RB_SMOOTHMOD                30607
#define IDS_RB_NORMALMOD                30608
#define IDS_RB_SKEWMOD                  30609
#define IDS_RB_SKEW                     30610
#define IDS_RB_SMOOTH2                  30611
#define IDS_RB_WAVE                     30612
#define IDS_RB_WAVEMOD                  30613
#define IDS_RB_WAVEBINDING              30614
#define IDS_RB_AMPLITUDE1               30615
#define IDS_RB_AMPLITUDE2               30616
#define IDS_RB_VOLSELECT                30617
#define IDS_RB_THRESHOLD                30618
#define IDS_RB_GIZMO                    30619
#define IDS_RB_NORMAL                   30620
#define IDS_RB_BEND_CLASS               30621
#define IDS_RB_DISPLACE_CLASS           30622
#define IDS_RB_VOLSELECT_CLASS          30623
#define IDS_RB_SKEW_CLASS               30624
#define IDS_RB_MATERIAL3_CLASS          30625
#define IDS_RB_SMOOTH2_CLASS            30626
#define IDS_RB_NORMAL_CLASS             30627
#define IDS_TH_LATHE_CLASS              30628
#define IDS_RB_EXPLODE                  30629
#define IDS_RB_COLLAPSE                 30630
#define IDS_RB_WELDVERTS                30631
#define IDS_RB_TAPER_CLASS              30632
#define IDS_RB_TWIST2_CLASS             30633
#define IDS_RB_TWIST_CLASS              30634
#define IDS_RB_BOMBOBJECT_CLASS         30635
#define IDS_RB_BOMB_CLASS               30636
#define IDS_RB_RIPPLE_CLASS             30637
#define IDS_RB_WAVE_CLASS               30638
#define IDS_RB_STRENGTH2                30646
#define IDS_DS_MOVE                     30647
#define IDS_RB_FACESEL                  30651
#define IDS_RB_POLYGONSEL               30652
#define IDS_RB_ELEMENTSEL               30653
#define IDS_RB_NOVERTSTOWELD            30680
#define IDS_RB_CHAOS                    30681
#define IDS_RB_DETONATION               30682
#define IDS_RB_BOMBPARAMS               30683
#define IDS_RB_EDITMESHTITLE            30684
#define IDS_RB_DUPFACEWARNING           30685
#define IDS_RB_NUMVERTSELP              30699
#define IDS_RB_NUMVERTSEL               30700
#define IDS_RB_NUMFACESELP              30701
#define IDS_RB_NUMFACESEL               30702
#define IDS_RB_NUMEDGESELP              30703
#define IDS_RB_NUMEDGESEL               30704
#define IDS_TH_EDITSPLINE               40025
#define IDS_TH_EDITSEGMENT              40026
#define IDS_TH_EDITVERTEX               40027
#define IDS_TH_SPLINE                   40028
#define IDS_TH_SEGMENT                  40029
#define IDS_TH_VERTEX                   40030
#define IDS_TH_EDITOBJECT               40031
#define IDS_TH_EDITPATCH_CLASS          40032
#define IDS_TH_EDITSPLINE_CLASS         40033
#define IDS_RB_EXTRUDE_CLASS            40034
#define IDS_RB_GRAVITY_CLASS            40035
#define IDS_RB_WIND_CLASS               40036
#define IDS_RB_UVWMAP_CLASS             40037
#define IDS_RB_NOISE_CLASS              40038
#define IDS_TH_CLOSESPLINE              40039
#define IDS_RB_OPTIMIZE_CLASS           40040
#define IDS_TH_DELETESPLINE             40041
#define IDS_TH_NOVALIDSPLINESSEL        40042
#define IDS_TH_NOSPLINESSEL             40043
#define IDS_TH_VERTBREAK                40044
#define IDS_TH_NOVALIDVERTSSEL          40045
#define IDS_TH_SEGDELETE                40046
#define IDS_TH_NOSEGSSEL                40047
#define IDS_TH_DETACHSPLINE             40048
#define IDS_TH_OUTLINE                  40049
#define IDS_TH_SEGDETACH                40050
#define IDS_TH_SHAPE                    40051
#define IDS_TH_REFINE                   40052
#define IDS_TH_SEGBREAK                 40053
#define IDS_TH_VERTCONNECT              40054
#define IDS_TH_VERTINSERT               40055
#define IDS_TH_VERTWELD                 40056
#define IDS_TH_NOWELDPERFORMED          40057
#define IDS_TH_SELECTONESPLINE          40058
#define IDS_TH_MORETHANONESPLINESEL     40059
#define IDS_TH_BOOLEAN                  40060
#define IDS_TH_UNION                    40061
#define IDS_TH_SUBTRACTION              40062
#define IDS_TH_INTERSECTION             40063
#define IDS_TH_BOOLWELDFAILED           40064
#define IDS_TH_COINCIDENTVERTEX         40065
#define IDS_TH_SPLINESMUSTOVERLAP       40066
#define IDS_TH_SELECTCLOSEDSPLINE       40067
#define IDS_TH_SPLINESELFINTERSECTS     40068
#define IDS_TH_ATTACH                   40069
#define IDS_TH_CANHAVEONLYONESHAPE      40070
#define IDS_TH_NOVERTSSEL               40071
#define IDS_TH_VERTCHANGE               40072
#define IDS_TH_SMOOTH                   40073
#define IDS_TH_CORNER                   40074
#define IDS_RB_RESETXFORM_CLASS         40075
#define IDS_TH_BEZIER                   40076
#define IDS_TH_SEGCHANGE                40077
#define IDS_TH_CURVE                    40078
#define IDS_TH_LINE                     40079
#define IDS_TH_VERTDELETE               40080
#define IDS_TH_BEZIERCORNER             40081
#define IDS_TH_AMOUNT                   40082
#define IDS_TH_EDITPATCH                40083
#define IDS_TH_PATCH                    40084
#define IDS_TH_SEGMENTS                 40085
#define IDS_TH_PATCHDELETE              40086
#define IDS_TH_NOPATCHESSEL             40087
#define IDS_TH_MAKEFIRST                40160
#define IDS_TH_EDITEDGE                 40170
#define IDS_TH_EDGE                     40171
#define IDS_TH_AUTOINTERIOR             40172
#define IDS_TH_MANUALINTERIOR           40173
#define IDS_TH_NOVALIDEDGESSEL          40174
#define IDS_TH_PATCHADD                 40175
#define IDS_TH_EDGESUBDIVIDE            40176
#define IDS_TH_PATCHSUBDIVIDE           40177
#define IDS_TH_CREATELINE               40178
#define IDS_TH_MIRROR_H                 40179
#define IDS_TH_MIRROR_V                 40180
#define IDS_TH_MIRROR_BOTH              40181
#define IDS_TH_MIRROR                   40182
#define IDS_TH_PATCHCHANGE              40186
#define IDS_TH_COPLANAR                 40187
#define IDS_TH_POLYCONNECT              40190
#define IDS_TH_CONNECT_COINCIDENT       40191
#define IDS_TH_CANHAVEONLYONEPATCH      40192
#define IDS_TH_DETACHPATCH              40193
#define IDS_TH_COPY_SPLINE              40196
#define IDS_TH_COPY_SEGMENT             40197
#define IDS_TH_SPLINECHANGE             40201
#define IDS_TH_MIRRORSPLINE             40279
#define IDS_TH_DEGREES                  40308
#define IDS_TH_AXIS                     40309
#define IDS_TH_LATHE                    40310
#define IDS_TH_VERTWELDRESULT           40316
#define IDS_RB_RESETXFORM               40317
#define IDS_RB_AFRMOD                   40318
#define IDS_RB_BONESDEFMOD              40318
#define IDS_RB_STARTPOINT               40319
#define IDS_RB_ENDPOINT                 40320
#define IDS_RB_AFRPOINTS                40321
#define IDS_RB_BONESDEFPOINTS           40321
#define IDS_AFR_FALLOFF                 40322
#define IDS_RB_INNER                    40322
#define IDS_AFR_PINCH                   40323
#define IDS_RB_LINNER                   40323
#define IDS_AFR_BUBBLE                  40324
#define IDS_RB_OUTER                    40324
#define IDS_RB_TESSMOD                  40325
#define IDS_RB_LOUTER                   40325
#define IDS_TESS_TENSION                40326
#define IDS_RB_EFFECT                   40326
#define IDS_RB_DELETEMOD                40327
#define IDS_PW_EFFECT                   40327
#define IDS_RB_MESHSELMOD               40328
#define IDS_PW_RADIUS                   40328
#define IDS_RB_FACEEXTRUDEMOD           40329
#define IDS_PW_LOCK                     40329
#define IDS_RB_EXTRUDECENT              40330
#define IDS_PW_ABSOLUTE                 40330
#define IDS_EXT_AMOUNT                  40331
#define IDS_PW_PARAMETER                40331
#define IDS_EXT_SCALE                   40332
#define IDS_PW_FALLOFF                  40332
#define IDS_RB_UVWXFORMMOD              40333
#define IDS_PW_DRAWENVELOPE             40333
#define IDS_RB_UOFFSET                  40334
#define IDS_PW_FEATHER                  40334
#define IDS_RB_VOFFSET                  40335
#define IDS_PW_FILTERVERTICES           40335
#define IDS_RB_WOFFSET                  40336
#define IDS_PW_FILTERBONES              40336
#define IDS_RB_MAXEDGE1                 40337
#define IDS_PW_FILTERENVELOPES          40337
#define IDS_RB_MAXEDGE2                 40338
#define IDS_PW_PAINT                    40338
#define IDS_RB_CENTERPOINT              40339
#define IDS_PW_FILTER                   40339
#define IDS_RB_MIRRORMOD                40340
#define IDS_PW_ADVANCE                  40340
#define IDS_RB_MIRRORCENTER             40341
#define IDS_PW_ENVELOPE                 40341
#define IDS_RB_OFFSET                   40342
#define IDS_PW_COPY                     40342
#define IDS_RB_SELVERTEX                40343
#define IDS_PW_PASTE                    40343
#define IDS_RB_SELFACE                  40344
#define IDS_PW_NOT_BONESDEF_ERROR       40344
#define IDS_RB_SELEDGE                  40345
#define IDS_PW_SKIN_NOT_SELECTED        40345
#define IDS_RB_SELOBJECT                40346
#define IDS_PW_EXCEEDED_VERTEX_COUNT    40346
#define IDS_RB_UNWRAPMOD                40347
#define IDS_PW_EXCEEDED_SUBVERTEX_COUNT 40347
#define IDS_AP_SDELETEMOD               40348
#define IDS_PW_INVALID_DATA             40348
#define IDS_RB_RESETUVWS                40349
#define IDS_PW_EXCEEDED_BONE_COUNT      40349
#define IDS_RB_SETCHANNEL               40350
#define IDS_PW_WEIGHT_BONE_COUNT        40350
#define IDS_RB_SHOULDRESET              40351
#define IDS_PW_ENVELOPEVIS              40351
#define IDS_RB_RESETUNWRAPUVWS          40352
#define IDS_PW_PARAMETERS               40352
#define IDS_RB_LENGTH                   40353
#define IDS_PW_SELECT                   40353
#define IDS_SA_TRIANGLE                 40354
#define IDS_PW_EDIT_ENVELOPE            40354
#define IDS_SA_POLYGON                  40355
#define IDS_PW_DRAWALLENVELOPES         40355
#define IDS_SA_TRI_POLY_RESTORE         40356
#define IDS_PW_COLORVERTS               40356
#define IDS_RB_SPIN                     40357
#define IDS_PW_DELETEBONE               40357
#define IDS_RB_FALLOFF                  40358
#define IDS_PW_WEIGHTCHANGE             40358
#define IDS_TH_PATCHMTLCHANGE           40359
#define IDS_PW_EXCEEDED_CROSS_COUNT     40359
#define IDS_RB_MOVE                     40360
#define IDS_PW_SELECTBONES              40360
#define IDS_RB_ROTATE                   40361
#define IDS_RB_PAN                      40362
#define IDS_RB_ZOOM                     40363
#define IDS_RB_PICKMAP                  40364
#define IDS_RB_UPDATE                   40365
#define IDS_RB_ZOOMEXT                  40366
#define IDS_RB_ZOOMREG                  40367
#define IDS_RB_UVW                      40368
#define IDS_RB_PROP                     40369
#define IDS_RB_SHOWMAP                  40370
#define IDS_RB_DEFMODS                  40371
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        163
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1346
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Flex\Lag.CPP ===
/**********************************************************************
 *<
	FILE: lag.cpp

	DESCRIPTION:  Lag modifier

	CREATED BY: Peter Watje
				Now fully supports param2 except the paint mode
	HISTORY: 8/13/98

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm2.h"
#include "tvnode.h"
#include "modstack.h"
#include "notify.h"

#include "Maxscrpt.h"
#include "Strings.h"
#include "arrays.h"
#include "3DMath.h"
#include "Numbers.h"
#include "definsfn.h"


#define PBLOCK_REF	0
#define POINT1_REF	1

#define A_RENDER			A_PLUGIN1


#define LAZYID 0xDE17A34f, 0x8A41E2B0

#define CID_CREATEPAINT CID_USER + 204


#define SPRINGMODEL

//defines to mark chunks so I can save the weights and the nail pieces

#define POS_WEIGHT_COUNT_CHUNK	100
#define POS_WEIGHT_CHUNK		150
#define NAIL_CHUNK				200
#define GRAVITY_COUNT_CHUNK		250

#define VERTLIMIT	2000
#define PATCHLIMIT	500


#define LAGCONTAINERMASTER_TVNODE_CLASS_ID Class_ID(0xe27e0f2b, 0x74fad494)
#define LAGCONTAINER_TVNODE_CLASS_ID Class_ID(0xe27e0f2b, 0x74fad483)
#define LAGNODE_TVNODE_CLASS_ID Class_ID(0xe27e0f2b, 0x74fad484)


class SpringClass
{
public:
	Point3 vel, pos, init_pos;
	float InheritVel;
	BOOL modified;
	Point3 LocalPt;
};

class CacheClass
{
public:
Point3 vel, pos;

};


class LagModData : public LocalModData {
	public:
		int id;
		INode *SelfNode;
		Tab<SpringClass> SpringList;
		Tab<CacheClass> WholeFrameCache;

		Tab<BYTE> esel;  //selection for edges vertices
		Tab<BYTE> wsel;		//vertex weight selection
		Tab<BYTE> psel;		
		Matrix3 InverseTM;


		BOOL isMesh;
		BOOL isPatch;

		Point3 hitPoint;
		BOOL isHit;
		TimeValue lastFrame;
		BOOL nukeRenderCache;
		Tab<Point3> pointCache;

		LagModData()
			{
			SelfNode = NULL;
			id = -1;
			isMesh = FALSE;
			isPatch = FALSE;
			lastFrame = 999999999;
			nukeRenderCache = TRUE;

			}
		LagModData(int i, INode *n)
			{
			id = i;
			SelfNode = n;
			isMesh = FALSE;
			isPatch = FALSE;
			lastFrame = 999999999;
			nukeRenderCache = TRUE;

			}
		~LagModData()
			{
			SelfNode = NULL;
			}	
		LocalModData*	Clone()
			{
			LagModData* d = new LagModData();
			d->id = id;
			d->SelfNode = NULL;
			isMesh = FALSE;
			isPatch = FALSE;



			return d;

			}	


	};

class LagNodeNotify;


class LagMod;

class LagValidatorClass : public PBValidator
{
public:
LagMod *mod;
private:
BOOL Validate(PB2Value &v) 
	{
	INode *node = (INode*) v.r;

	if (node->TestForLoop(FOREVER,(ReferenceMaker *) mod)!=REF_SUCCEED) return FALSE;

	const ObjectState& os = node->EvalWorldState(0);
	Object* ob = os.obj;
	if (ob!=NULL) 
			{	
			int id=(os.obj?os.obj->SuperClassID():SClass_ID(0));
			if (id==WSM_OBJECT_CLASS_ID)
				{
				WSMObject *obref=(WSMObject*)node->GetObjectRef();
				BOOL ShouldBeHere=obref->SupportsDynamics();

				return ShouldBeHere;
				}
			else return FALSE;
				  
			}
	return FALSE;

	};
};


class CreatePaintMode;

class LagMod : public Modifier {	
	public:

		BOOL inPaint;
		BOOL painting;

		IParamBlock2 *pblock2;

		ITrackViewNode *container;

		Control *p1;
		static HWND hParams;

		LagNodeNotify *notify;


// data cache
		LagValidatorClass validator;


		BYTE sel[1];    //seclection for center

		Tab<SpringClass> oldSpringList;
		Tab<BYTE> oldesel;  //selection for edges vertices


		float weightDelta;
		ApplyDelta() ;
	
		Point3 lagCenter;


		static IObjParam *ip;
		static IParamMap *pmapParam;
		static LagMod *editMod;
		static MoveModBoxCMode *moveMode;
		ISpinnerControl *iVWeight;
		
//Paint controlls
        float PaintStrength;
        float Radius;
        float Feather;
        int ProjectThrough;
		int absoluteWeight;
        static CreatePaintMode *PaintMode;
		void StartPaintMode();
        ICustButton* iPaintButton;
		BOOL updating;
		void ResetSprings();

		LagMod();
		~LagMod();
		Point3 GetForce(TimeValue t, Point3 p, Point3 v, Matrix3 tm);


		Tab<ForceField*> ff;
		Class_ID cid;
		void AddForceField();

		TimeValue ReferenceFrame;
		float falloff, strength, dampening;
		
		
										
// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock2; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock2->ID() == id) ? pblock2 : NULL; } // return id'd ParamBlock


		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_LAGMOD);}  
		virtual Class_ID ClassID() { return Class_ID(LAZYID);}		
		void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_LAGMOD);}

		// From modifier
		ChannelMask ChannelsUsed()  {return PART_GEOM|PART_SELECT|PART_SUBSEL_TYPE;}
//		ChannelMask ChannelsChanged() {return PART_GEOM|PART_TOPO;}
		ChannelMask ChannelsChanged() {return PART_GEOM;}
		Class_ID InputType() {return defObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);


		void DrawCrossSectionNoMarkers(Point3 a, Point3 align, float length, GraphicsWindow *gw);

		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flagst, ModContext *mc);
		void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);		
		void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void ActivateSubobjSel(int level, XFormModes& modes);
		void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE);
		void ClearSelection(int selLevel);
		void SelectAll(int selLevel);
		void InvertSelection(int selLevel);

		int NumRefs() {return 2 ;
//			+ GravityNode.Count();
						}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		int NumSubs() {return 2;}
		Animatable* SubAnim(int i); 
		TSTR SubAnimName(int i);

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);


		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);

		IOResult SaveLocalData(ISave *isave, LocalModData *pld);
		IOResult LoadLocalData(ILoad *iload, LocalModData **pld);

		Matrix3 CompMatrix(TimeValue t,INode *inode,ModContext *mc);


		int RenderBegin(TimeValue t, ULONG flags);		
		int RenderEnd(TimeValue t);
		BOOL nukeCache;
		HoldWeights(LagModData *lmd);

		BOOL updateWeights;
		void ComputeCenterFalloff(LagModData *lmd, TimeValue t, ObjectState *os);

		EnableModsAbove(LagModData *lmd, BOOL enable);
		Tab<BOOL> enableStates;
		Tab<BOOL> enableViewStates;
		BOOL aboutToRender;

		Tab<LagModData*> lmdData;

		int CheckCache(TimeValue t);

	};

// block IDs
enum { lag_params };
// lag_param param IDs
enum { lag_flex, lag_strength, lag_sway, lag_referenceframe, lag_paint_strength,
		lag_paint_radius,lag_paint_feather,lag_paint_backface, lag_force_node, lag_absolute };


class LagNodeNotify  : public TVNodeNotify 
{
public:
LagMod *s;
LagNodeNotify(LagMod *smod)
	{
	s = smod;
	}

RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message)
	{
	if (message == REFMSG_CHANGE) 
		{
		if (partID & PART_TM)
			{
			if (s->ip)
				s->pblock2->SetValue(lag_referenceframe,0,s->ReferenceFrame/GetTicksPerFrame());
			}
		}
	return REF_SUCCEED ;
	}
};



class LagDeformer : public Deformer {
	public:		

		LagModData *lmd;
		LagMod *mod;
		LagDeformer(LagMod *m, LagModData *l) {mod = m; lmd = l;}
		Point3 Map(int i, Point3 p);
	};


//--- ClassDescriptor and class vars ---------------------------------

IParamMap       *LagMod::pmapParam = NULL;
IObjParam       *LagMod::ip        = NULL;
LagMod          *LagMod::editMod   = NULL;
MoveModBoxCMode *LagMod::moveMode  = NULL;
HWND			LagMod::hParams  = NULL;
CreatePaintMode* LagMod::PaintMode   = NULL;
		

//class LagClassDesc:public ClassDesc {
class LagClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new LagMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_LAGMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(LAZYID); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}

// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("Flex"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

	};

static LagClassDesc lagDesc;
extern ClassDesc* GetLagModDesc() {return &lagDesc;}


//--- Parameter map/block descriptors -------------------------------
//new parm blocks
//
//
// Parameters

// JBW: Here follows the new parameter block descriptors.  There are now 3, 
//      two new STATIC ones to hold the old class var parameters, one for the main
//		per-instance parameters.  Apart from all the extra 
//      metadata you see in the definitions, one important new idea is the
//      folding of ParamMap description info into the parameter descriptor and
//      providing a semi-automatic rollout desipaly mechanism.
//      

// Parameter Block definitions

// JBW: First come the position and version independent IDs for each
//      of the blocks and the parameters in each block.  These IDs are used
//	    in subsequent Get/SetValue() parameter access, etc. and for version-independent
//      load and save



// JBW: this descriptor defines the main per-instance parameter block.  It is flagged as AUTO_CONSTRUCT which
//      means that the CreateInstance() will automatically create one of these blocks and set it to the reference
//      number given (0 in this case, as seen at the end of the line).

// per instance geosphere block
static ParamBlockDesc2 lag_param_blk ( lag_params, _T("FlexParameters"),  0, &lagDesc, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//rollout
	IDD_LAGPARAM, IDS_RB_PARAMETERS, 0, 0, NULL,
	// params
	lag_flex,  _T("flex"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_LAG_FALLOFF, 
		p_default, 		1.0,	
		p_range, 		0.0f, 1000.0f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_LAG_FALLOFF,IDC_LAG_FALLOFFSPIN, .1f, 
		end, 
	lag_strength, 	_T("strength"), 	TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_LAG_STRENGTH, 
		p_default, 		3.0f, 
		p_range, 		0.0f, 100.0f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_LAG_SETTLE, IDC_LAG_SETTLE_SPIN, 0.01f,  
		end, 

	lag_sway, 	_T("sway"), 	TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_LAG_SWAY, 
		p_default, 		7.0f, 
		p_range, 		0.0f, 100.0f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_LAG_WAVES, IDC_LAG_WAVES_SPIN, 0.01f,  
		end, 

	lag_referenceframe, 	_T("referenceFrame"), 	TYPE_INT, 	0, 	IDS_LAG_REFERENCEFRAME, 
		p_default, 		0, 
		p_range, 		-99999, 99999, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_REFERENCEFRAME, IDC_REFERENCEFRAME_SPIN, SPIN_AUTOSCALE,  
		end, 

	lag_paint_strength,  _T("paintStrength"),		TYPE_FLOAT, 	0, 	IDS_LAG_STRENGTH, 
		p_default, 		0.1,	
		p_range, 		-1.0f, 1.0f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_PAINT_STRENGTH,IDC_PAINTSTRENGTHSPIN, .1f, 
		end, 

	lag_paint_radius,  _T("paintRadius"),		TYPE_FLOAT, 	0, 	IDS_LAG_STRENGTH, 
		p_default, 		36.0f,	
		p_range, 		0.001f, 99999.0f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_RADIUS,IDC_RADIUSSPIN, 1.0f, 
		end, 

	lag_paint_feather,  _T("paintFeather"),	TYPE_FLOAT, 	0, 	IDS_LAG_STRENGTH, 
		p_default, 		0.70f,	
		p_range, 		0.001f, 1.0f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_FEATHER,IDC_FEATHERSPIN, SPIN_AUTOSCALE, 
		end, 

	lag_paint_backface, _T("paintBackface"),	TYPE_BOOL, 		0,	IDS_LAG_STRENGTH,
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_PROJECT_THROUGH_CHECK, 
		end, 
	lag_force_node,    _T("forceNode"),  TYPE_INODE_TAB,		0,	P_AUTO_UI,	IDS_LAG_FORCE_NODES,
		p_ui,			TYPE_NODELISTBOX, IDC_LIST1,IDC_GRAVITY_PICKNODE,0,IDC_REMOVE_GRAV,
		end,
	lag_absolute, _T("absolute"),	TYPE_BOOL, 		0,	IDS_LAG_ABSOLUTE,
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_ABSOLUTE, 
		end, 
	end
	);



class LagWeightRestore : public RestoreObj {
	public:
		LagMod *mod;
		LagModData *bmd;
		Tab<float> uInflu;
		Tab<float> rInflu;

		LagWeightRestore(LagMod *c, LagModData *md) 
			{
			mod = c;
			bmd = md;
			uInflu.SetCount(md->SpringList.Count());
			for (int i = 0; i < uInflu.Count(); i++)
				{
				uInflu[i] = md->SpringList[i].InheritVel;
				}

			}   		
		void Restore(int isUndo) 
			{
			if (isUndo) 
				{
				rInflu.SetCount(bmd->SpringList.Count());
				for (int i = 0; i < uInflu.Count(); i++)
					{
					rInflu[i] = bmd->SpringList[i].InheritVel;
					}

				}

			for (int i = 0; i < uInflu.Count(); i++)
				{
				bmd->SpringList[i].InheritVel = uInflu[i];
				}

			mod->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo()
			{
			for (int i = 0; i < uInflu.Count(); i++)
				{
				bmd->SpringList[i].InheritVel = rInflu[i];
				}

			mod->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}		
		void EndHold() 
			{ 
			mod->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T(GetString(IDS_PW_CHANGE_WEIGHT))); }
	};

LagMod::HoldWeights(LagModData *lmd)
{
//if (theHold.Holding()) 
	theHold.Put (new LagWeightRestore (this, lmd));

}

/*-------------------------------------------------------------------*/
/*																	*/
/*				Paint Command Mode									*/
/*																	*/
/*-------------------------------------------------------------------*/

class CreatePaintMouseProc : public MouseCallBack {
        private:
                LagMod *mod;
                IObjParam *iObjParams;
				IPoint2 lastPoint;
                IPoint2 om;
                Tab<float> FalloffList;
				Tab<IPoint2> mouseHitList;
        
        protected:
                BOOL HitTest(LagModData *lmd, ViewExp *vpt, IPoint2 *p, int type, int flags, Object *obj );
                BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }           
				BOOL BuildFalloffList( ViewExp *vpt, Tab<IPoint2> plist, 
											 LagModData *lmd, Object *obj);


        public:
                CreatePaintMouseProc(LagMod* bmod, IObjParam *i) { mod=bmod; iObjParams=i; }
                int proc( 
                        HWND hwnd, 
                        int msg, 
                        int point, 
                        int flags, 
                        IPoint2 m );
        };



class CreatePaintMode : public CommandMode {
        private:
                ChangeFGObject fgProc;
                CreatePaintMouseProc eproc;
                LagMod* mod;

        public:
                CreatePaintMode(LagMod* bmod, IObjParam *i) :
                        fgProc(bmod), eproc(bmod,i) {mod=bmod;}

                int Class() { return MODIFY_COMMAND; }
                int ID() { return CID_CREATEPAINT; }
                MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &eproc; }
                ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
                BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
                void EnterMode();
                void ExitMode();
        };





float LineToPoint(Point3 p1, Ray r, float &u)

{
Point3 VectorA,VectorB,VectorC;
float Angle;
float dist = 0.0f;

VectorA = r.dir;
VectorB = p1-r.p;
Angle = (float)acos(DotProd(Normalize(VectorA),Normalize(VectorB)));

float hyp;
hyp = Length(VectorB);
dist = (float) sin(Angle) * hyp;

u = (float) cos(Angle) * hyp;

return dist;

}



BOOL CreatePaintMouseProc::HitTest(LagModData *lmd, 
                ViewExp *vpt, IPoint2 *p, int type, int flags, Object *obj )

        {

		if (lmd == NULL ) return FALSE;

        Ray                     ray;
        BOOL res = FALSE;

        vpt->MapScreenToWorldRay((float)p->x, (float)p->y, ray);

//now map it to our local space
		float feather, ifeather;

        feather = 1.0f -  mod->Feather;
	    ifeather = mod->Feather;

		if (1)
			{
			ray.p   = lmd->InverseTM * ray.p;
			ray.dir = VectorTransform(lmd->InverseTM, ray.dir);	

			float at;
			Point3 norm;

		    for (int i = 0; i<lmd->psel.Count(); i++)
			        lmd->psel[i] = 0;


			if (obj->IntersectRay(mod->ip->GetTime(),ray, at, norm)) 
				{
				lmd->hitPoint = ray.p + ray.dir * at;
				float rad = mod->Radius * mod->Radius;
				Box3 boundingBox;
				boundingBox.Init();
				boundingBox += lmd->hitPoint;					
				boundingBox.EnlargeBy(rad);

		        if ((lmd->isMesh)&& (obj->NumPoints() < VERTLIMIT)) FalloffList.ZeroCount();
				else if ((lmd->isPatch)&& (obj->NumPoints() < PATCHLIMIT)) FalloffList.ZeroCount();

				for (i = 0; i<lmd->SpringList.Count(); i++)
		            {
					if (boundingBox.Contains(lmd->SpringList[i].LocalPt))
						{
					    float dist = LengthSquared(lmd->SpringList[i].LocalPt-lmd->hitPoint);
						if (dist <= rad)
			                {
				            lmd->psel[i] = 1;
							if( ( (lmd->isMesh) && (obj->NumPoints() < VERTLIMIT) ) ||
							    ( (lmd->isPatch) && (obj->NumPoints() < PATCHLIMIT) )
							  )
								{
                                float f;
								dist = (float) sqrt(dist);
                                if (dist < mod->Radius*feather)
									f = 1.0f;
                                else 
                                    {
                                    f = 1.0f - (dist-(mod->Radius*feather))/(mod->Radius*ifeather);
                                    }
								f = f * mod->PaintStrength;
                                FalloffList.Append(1,&f,1);

								}



							}
						}
					}


				return TRUE;
				}

		
			}

        return res;


        }


float LagLineToPoint(Point3 p1, Point3 l1, Point3 l2, float &u)
{
Point3 VectorA,VectorB,VectorC;
double Angle;
double dist = 0.0f;
VectorA = l2-l1;
VectorB = p1-l1;
Angle =  acos(DotProd(Normalize(VectorA),Normalize(VectorB)));
if (Angle > (3.14/2.0))
	{
	dist = Length(p1-l1);
	u = 0.0f;
	}
else
	{
	VectorA = l1-l2;
	VectorB = p1-l2;
	Angle = acos(DotProd(Normalize(VectorA),Normalize(VectorB)));
	if (Angle > (3.14/2.0))
		{
		dist = Length(p1-l2);
		u = 1.0f;
		}
		else
		{
		double hyp;
		hyp = Length(VectorB);
		dist =  sin(Angle) * hyp;
		double du =  (cos(Angle) * hyp);
		double a = Length(VectorA);
		if ( a== 0.0f)
			return 0.0f;
		else u = (float)((a-du) / a);

		}

	}

return (float) dist;

}


BOOL CreatePaintMouseProc::BuildFalloffList( ViewExp *vpt, Tab<IPoint2> plist, 
											 LagModData *lmd, Object *obj)

{
Box3 boundingBox;

if (lmd == NULL ) return FALSE;

Tab<Point3> hitList;

boundingBox.Init();

for (int pct = 0; pct < plist.Count(); pct++)
		{
        Ray ray;

		IPoint2 p = plist[pct];
        vpt->MapScreenToWorldRay((float)p.x, (float)p.y, ray);
		ray.p   = lmd->InverseTM * ray.p;
		ray.dir = VectorTransform(lmd->InverseTM, ray.dir);	

//now map it to our local space
		if (1)
			{

			float at;
			Point3 norm;

			if (obj->IntersectRay(mod->ip->GetTime(),ray, at, norm)) 
				{
				Point3 hitPoint;
				hitPoint = ray.p + ray.dir * at;
				hitList.Append(1,&hitPoint,1);
				boundingBox += hitPoint;					
				}
			}

		}
boundingBox.EnlargeBy(mod->Radius);
float feather, ifeather;
feather = 1.0f -  mod->Feather;
ifeather = mod->Feather;


if (hitList.Count() ==1 )
	{	
	for (int i = 0; i< lmd->SpringList.Count(); i++)
		{
		if (boundingBox.Contains(lmd->SpringList[i].LocalPt))
			{
			float dist = Length(lmd->SpringList[i].LocalPt-hitList[0]);
			if (dist < mod->Radius)
				{
				float f;
	            if (dist < mod->Radius*feather)
					f = 1.0f;
                else 
                   {
		           f = 1.0f - (dist-(mod->Radius*feather))/(mod->Radius*ifeather);
                   }
				f = f * mod->PaintStrength;
				if (f > FalloffList[i]) 
					FalloffList[i] = f;
				}
			}
		}

	}
else
	{
	for (pct = 1; pct < hitList.Count(); pct++)
		{
		for (int i = 0; i< lmd->SpringList.Count(); i++)
			{
			if (boundingBox.Contains(lmd->SpringList[i].LocalPt))
				{
				Point3 l1,l2;
				l1 = hitList[pct-1];
				l2 = hitList[pct];
				float u;
				float dist = LagLineToPoint(lmd->SpringList[i].LocalPt,l1, l2,u);

				if (dist < mod->Radius)
					{
					float f;
			        if (dist < (mod->Radius*feather))
			           f = 1.0f;
				    else 
					   {
						f = 1.0f - (dist-(mod->Radius*feather))/(mod->Radius*ifeather);
						}	
					f = f * mod->PaintStrength;
					if (f > FalloffList[i]) 
						FalloffList[i] = f;

					}
				}
			}
		}

	}
return 1;
}

static void LagXORDottedLine( HWND hwnd, IPoint2 p0, IPoint2 p1 )
	{
	HDC hdc;
	hdc = GetDC( hwnd );
	SetROP2( hdc, R2_XORPEN );
	SetBkMode( hdc, TRANSPARENT );
	SelectObject( hdc, CreatePen( PS_DOT, 0, RGB(255,255,255) ) );
	MoveToEx( hdc, p0.x, p0.y, NULL );
	LineTo( hdc, p1.x, p1.y );		
	DeleteObject( SelectObject( hdc, GetStockObject( BLACK_PEN ) ) );
	ReleaseDC( hwnd, hdc );
	}

int CreatePaintMouseProc::proc(
                        HWND hwnd, 
                        int msg, 
                        int point, 
                        int flags, 
                        IPoint2 m )
        {
        ViewExp *vpt = iObjParams->GetViewport(hwnd);   
        int res = TRUE;
        float st = 1.0f;
        int flip = 0;
		int i;

		ModContextList mcList;		
		INodeTab nodes;

		if (!mod->ip) return 0;

		mod->ip->GetModContexts(mcList,nodes);
		int objects = mcList.Count();

		for ( int k = 0; k < objects; k++ ) 
			{

			LagModData *lmd = (LagModData*)mcList[k]->localData;

			ObjectState os = nodes[k]->EvalWorldState(mod->ip->GetTime());
			Object *obj = os.obj;

			if (lmd)
				{

		        switch ( msg ) {
		            case MOUSE_PROPCLICK:
			                iObjParams->SetStdCommandMode(CID_OBJMOVE);
							if (mod->painting)
								theHold.Cancel();
							mod->painting = FALSE;
				            break;

					case MOUSE_POINT:
						if (point == 0)
							{
							mouseHitList.ZeroCount();
							mod->painting = TRUE;

							theHold.Begin();
							mod->HoldWeights(lmd);

							}
						else if (mouseHitList.Count() != 0)
							{
//compute hit list
							mod->painting = FALSE;

		                    st = 1.0f;
			                flip = 0;
				            if (flags & MOUSE_ALT) 
					            {
						        st = -1.0f;
							    flip = 1;
								}
		                    mod->pblock2->GetValue(lag_paint_strength,0,mod->PaintStrength,FOREVER);
			                mod->pblock2->GetValue(lag_paint_radius,0,mod->Radius,FOREVER);
				            mod->pblock2->GetValue(lag_paint_feather,0,mod->Feather,FOREVER);
							FalloffList.SetCount(lmd->SpringList.Count());
						
							for (int i = 0; i < lmd->SpringList.Count(); i++)
								FalloffList[i] = -10.0f;
							BuildFalloffList( vpt, mouseHitList,lmd,obj);
						    for (i=0;i<lmd->SpringList.Count();i++)
								{
								if (FalloffList[i] > 0.0f )
									{
									float currentv = FalloffList[i];
									if (st == 1.0f)
										lmd->SpringList[i].InheritVel -= currentv;
									else lmd->SpringList[i].InheritVel += currentv;
	
									lmd->SpringList[i].modified = TRUE;
									if (lmd->SpringList[i].InheritVel <0.0f) lmd->SpringList[i].InheritVel = 0.0f;
									if (lmd->SpringList[i].InheritVel >1.0f) lmd->SpringList[i].InheritVel = 1.0f;
									}
								}


							for (i = 1; i < mouseHitList.Count(); i++)
								LagXORDottedLine(hwnd, mouseHitList[i-1], mouseHitList[i]);	// Draw it!


			                mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
				            mod->ip->RedrawViews(mod->ip->GetTime());
							}
						
						theHold.Accept(GetString(IDS_PW_CHANGE_WEIGHT));

						break;



					case MOUSE_MOVE:
						if ( ((lmd->isMesh) && (obj->NumPoints() < VERTLIMIT)) ||
							  ((lmd->isPatch) && (obj->NumPoints() < PATCHLIMIT)) 
							  )
							{
	                        st = 1.0f;
		                    flip = 0;
			                if (flags & MOUSE_ALT) 
				                    {
					                st = -1.0f;
						            flip = 1;
							        }
	                        mod->pblock2->GetValue(lag_paint_strength,0,mod->PaintStrength,FOREVER);
		                    mod->pblock2->GetValue(lag_paint_radius,0,mod->Radius,FOREVER);
			                mod->pblock2->GetValue(lag_paint_feather,0,mod->Feather,FOREVER);
//change this to a radius type hit
				            if(HitTest(lmd, vpt,&m,HITTYPE_CIRCLE,0, obj) ) {

//transfrom mouse point to world
								int ct = 0;
							    for (i=0;i<lmd->SpringList.Count();i++)
									{
									if (lmd->psel[i] == 1 )
										{
										float currentv = FalloffList[ct++];
										if (st == 1.0f)
											lmd->SpringList[i].InheritVel -= currentv;
										else lmd->SpringList[i].InheritVel += currentv;

										lmd->SpringList[i].modified = TRUE;
										if (lmd->SpringList[i].InheritVel <0.0f) lmd->SpringList[i].InheritVel = 0.0f;
										if (lmd->SpringList[i].InheritVel >1.0f) lmd->SpringList[i].InheritVel = 1.0f;
										}
									}
								mod->painting = FALSE;

	                            mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
		                        mod->ip->RedrawViews(mod->ip->GetTime());

			                    }
							}
						else
							{
							if (mouseHitList.Count() > 1)
								{
								if (mouseHitList[mouseHitList.Count()-1] != m)
									{
									if (mouseHitList.Count() > 1)
										{
										LagXORDottedLine(hwnd, lastPoint, m);	// Draw it!
										}

		
									lastPoint = m;

							        if ( HitTest(lmd,vpt,&m,HITTYPE_CIRCLE,HIT_ABORTONHIT,obj) ) 
										{

				                        mod->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
										lmd->isHit = TRUE;
							            mod->ip->RedrawViews(mod->ip->GetTime());
	
										}
									else
										{
										if (lmd->isHit)
											{
											mod->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
											lmd->isHit = FALSE;
								            mod->ip->RedrawViews(mod->ip->GetTime());
											}
										else lmd->isHit = FALSE;

										}	

									mouseHitList.Append(1,&m,1);
									}

								}
							else {
								mouseHitList.Append(1,&m,1);
								lastPoint = m;
								}

							}
					       break;
                
	                case MOUSE_FREEMOVE:
                        if ( HitTest(lmd,vpt,&m,HITTYPE_CIRCLE,HIT_ABORTONHIT,obj) ) {
                                SetCursor(LoadCursor(NULL,IDC_CROSS ));
							lmd->isHit = TRUE;
							mod->painting = FALSE;

                             mod->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
                             mod->ip->RedrawViews(mod->ip->GetTime());

                             }
                        else {
                              SetCursor(LoadCursor(NULL,IDC_ARROW));

							  if (lmd->isHit)
								{
								  lmd->isHit = FALSE;
		                         mod->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	                             mod->ip->RedrawViews(mod->ip->GetTime());
								}
	
							  else lmd->isHit = FALSE;

								mod->painting = FALSE;
                              }
                        break;
					}
                        
                }
			}

        if ( vpt ) iObjParams->ReleaseViewport(vpt);

        return res;
        }



/*-------------------------------------------------------------------*/

void CreatePaintMode::EnterMode()
        {
        mod->iPaintButton->SetCheck(TRUE);
		mod->painting = FALSE;
		mod->inPaint = TRUE;

		BOOL en = mod->IsEnabled();
		BOOL env = mod->IsEnabledInViews();

		if ((!en) || (!env))
			{	
			ModContextList mcList;		
			INodeTab nodes;
			
			if (mod->ip)
				{


				mod->ip->GetModContexts(mcList,nodes);
				int objects = mcList.Count();
/*				BOOL en = TRUE;
				if (!mod->IsEnabled())
					en = FALSE;
*/

				for ( int k = 0; k < objects; k++ ) 
					{
					if (en)
						mod->EnableModInViews();	
					else mod->EnableMod();	
					ObjectState os = nodes[k]->EvalWorldState(mod->ip->GetTime());
					if (en)
						mod->DisableModInViews();	
					else mod->DisableMod();	
					}	
				}
			}

        }

void CreatePaintMode::ExitMode()
        {
        mod->iPaintButton->SetCheck(FALSE);
		mod->painting = FALSE;
		mod->inPaint = FALSE;

//nuke mesh
        }

//dialog stuff to get the Set Ref button
class MapDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		LagMod *mod;		
		MapDlgProc(LagMod *m) {mod = m;}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
	};


LagMod::ApplyDelta() 

{
ModContextList mcList;		
INodeTab nodes;

if (!ip) return 0;

ip->GetModContexts(mcList,nodes);
int objects = mcList.Count();

theHold.Begin();
for ( int k = 0; k < objects; k++ ) 
	{

	LagModData *lmd = (LagModData*)mcList[k]->localData;
	if (lmd)
		{
		HoldWeights(lmd);

		for (int i = 0; i < lmd->wsel.Count(); i++)
			{
			if (lmd->wsel[i] == 1)
				{
				if (absoluteWeight) 
					lmd->SpringList[i].InheritVel = 1.0f- weightDelta;
				else lmd->SpringList[i].InheritVel -= weightDelta ;
				if (lmd->SpringList[i].InheritVel < 0.0f) lmd->SpringList[i].InheritVel = 0.0f;
				if (lmd->SpringList[i].InheritVel > 1.0f) lmd->SpringList[i].InheritVel = 1.0f;
				lmd->SpringList[i].modified = TRUE;
				}

			}
		}
	}
theHold.Accept(GetString(IDS_PW_CHANGE_WEIGHT));

return 1;
}

BOOL MapDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG: {
			mod->hParams = hWnd;

			mod->iPaintButton = GetICustButton(GetDlgItem(hWnd,IDC_PAINT));
			mod->iPaintButton->SetType(CBT_CHECK);
			mod->iPaintButton->SetHighlightColor(GREEN_WASH);
			mod->iPaintButton->Enable(FALSE);

			mod->iVWeight = GetISpinner(GetDlgItem(hWnd,IDC_VWEIGHT_SPIN));
			mod->iVWeight->LinkToEdit(GetDlgItem(hWnd,IDC_VWEIGHT),EDITTYPE_FLOAT);
			mod->iVWeight->SetLimits(-100.0f, 100.0f, FALSE);

			
			break;
			}

		case CC_SPINNER_BUTTONDOWN:
			if (!mod->absoluteWeight) 
				{
				mod->iVWeight->SetValue(0.0f,TRUE);
				mod->weightDelta = 0.0f;
				}
			else mod->weightDelta = mod->iVWeight->GetFVal() * 0.01f;

			break;
		case CC_SPINNER_CHANGE:
			mod->weightDelta = mod->iVWeight->GetFVal() * 0.01f;
            mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
			break;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				{
				//apply

				mod->ApplyDelta();
				}
			else
				{
				mod->weightDelta = 0.0f;
				}
			if (!mod->absoluteWeight) 
				mod->iVWeight->SetValue(0.0f,TRUE);
            mod->ip->RedrawViews(mod->ip->GetTime());
            mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
			break;


		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{

				case IDC_ABSOLUTE:
					{
					Interval iv;
					mod->pblock2->GetValue(lag_absolute,0,mod->absoluteWeight,iv);

					if (!mod->absoluteWeight) 
						{
						mod->iVWeight->SetValue(0.0f,TRUE);
						mod->weightDelta = 0.0f;
						}
					break;

					}
				case IDC_SETREFERENCE_BUTTON:
					{
//set time to ref time
					Interface *ip = GetCOREInterface();
					TimeValue CurrentTime;
					Interval CurrentSeg,ReferenceSeg;
				
					CurrentTime = ip->GetTime();
					CurrentSeg = ip->GetAnimRange();
					ReferenceSeg = CurrentSeg;
//set new range to include reference frame
					ReferenceSeg.Set(mod->ReferenceFrame,mod->ReferenceFrame+GetTicksPerFrame());
					ip->SetAnimRange(ReferenceSeg);
					ip->SetTime(mod->ReferenceFrame,FALSE);

//set back old rangle
					ip->SetAnimRange(CurrentSeg);
//set back to original time
					ip->SetTime(CurrentTime,FALSE);
					break;
					}
				case IDC_RESET_BUTTON:
					{
					mod->ResetSprings();
//set time to ref time
					Interface *ip = GetCOREInterface();
					TimeValue CurrentTime;
					Interval CurrentSeg,ReferenceSeg;
				
					CurrentTime = ip->GetTime();
					CurrentSeg = ip->GetAnimRange();
					ReferenceSeg = CurrentSeg;
//set new range to include reference frame
					ReferenceSeg.Set(mod->ReferenceFrame,mod->ReferenceFrame+GetTicksPerFrame());
					ip->SetAnimRange(ReferenceSeg);
					ip->SetTime(mod->ReferenceFrame,FALSE);

//set back old rangle
					ip->SetAnimRange(CurrentSeg);
//set back to original time
					ip->SetTime(CurrentTime,FALSE);
                    mod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);

                    ip->RedrawViews(ip->GetTime());

					break;
					}
				case IDC_PAINT:
					{
					mod->StartPaintMode();
					break;
					}

				}
			break;


		}
	return FALSE;
	}


	class MyEnumProc : public DependentEnumProc 
	{
      public :
      virtual int proc(ReferenceMaker *rmaker); 
      INodeTab Nodes;              
	  BOOL nukeME;
	  BOOL xRefFound;
	  int count;
	};

int MyEnumProc::proc(ReferenceMaker *rmaker) 
	{ 
	if (rmaker->ClassID()==Class_ID(0x5c2417bd, 0x44050964))    
		{
		IParamBlock *pb;
		pb = (IParamBlock *) rmaker->GetReference(4);
		Interval ivalid;
		int anioff;
		pb->GetValue(32,0,anioff,ivalid);
		if (anioff != 0)
			nukeME = TRUE;
		}
//7-1-99
	if (rmaker->SuperClassID()==BASENODE_CLASS_ID)    
		{
		Nodes.Append(1, (INode **)&rmaker);  
		count++;
		}
	if (rmaker->ClassID()==Class_ID(XREFOBJ_CLASS_ID,0))    
		{
		xRefFound = TRUE;
		}


	return 0;
	}	



// Declare the callback function
static void RenderFrameStart(void *param, NotifyInfo *info) {
	// Handle the units changing...
	LagMod *mod =  (LagMod*) param;
	TimeValue *t = (TimeValue*) info->callParam;
	mod->CheckCache(*t);

}


//--- Lag mod methods -------------------------------

LagMod::LagMod() 
	{
	GetLagModDesc()->MakeAutoParamBlocks(this);
	p1 = NULL;
	ff.ZeroCount();
	MakeRefByID(FOREVER,POINT1_REF,NewDefaultPoint3Controller()); 
	sel[0] = 1;

	Point3 p(0.0f,0.0f,0.0f);
	p1->SetValue(
			0,p,
			TRUE,CTRL_ABSOLUTE);

	iPaintButton = NULL;
	iVWeight = NULL;
	ReferenceFrame = 0;
	absoluteWeight = 0;
	weightDelta = 0.0f;
	container = NULL;

	notify = new LagNodeNotify(this);

	validator.mod = this;
	painting = FALSE;
	inPaint = FALSE;
	updating = FALSE;
	nukeCache = FALSE;
	updateWeights = FALSE;
	aboutToRender = FALSE;
// Register the callback
	RegisterNotification(RenderFrameStart,this,	NOTIFY_RENDER_PREEVAL);


	}


LagMod::~LagMod() 
{
	DeleteAllRefsFromMe();
	for (int i = 0; i< ff.Count(); i++)
	{
		if (ff[i]) 
			ff[i]->DeleteThis();
	}

// mjm - begin - 5.10.99
	if (container && notify)
		{
		ITrackViewNode *tvr = GetCOREInterface()->GetTrackViewRootNode();
		ITrackViewNode *global = tvr->GetNode(Class_ID(0xb27e9f2a, 0x73fad370));
		ITrackViewNode *tvroot = global->GetNode(LAGCONTAINERMASTER_TVNODE_CLASS_ID);
		if (tvroot) 
			{
			int ct = tvroot->NumItems();
			for (int i = 0; i <ct; i++)
				{
				ITrackViewNode *n = tvroot->GetNode(i);
				if (container == n)
					container->UnRegisterTVNodeNotify(notify);
				}
			}
		else
			{
//			ITrackViewNode *tvroot = tvr->GetNode(LAGCONTAINER_TVNODE_CLASS_ID);
			int ct = tvr->NumItems();
			for (int i = 0; i <ct; i++)
				{
				ITrackViewNode *n = tvr->GetNode(i);
				if (container == n)
					container->UnRegisterTVNodeNotify(notify);
				}


			}	
		}
//		container->UnRegisterTVNodeNotify(notify);
	if (notify)
		delete notify;
// mjm - end


	if (iPaintButton)
		ReleaseICustButton(iPaintButton);
	if (iVWeight)
		ReleaseISpinner(iVWeight);
// When done, unregister the callback
	UnRegisterNotification(RenderFrameStart,this,	NOTIFY_RENDER_PREEVAL);

}



void LagMod::BeginEditParams(
		IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	this->ip = ip;
	editMod  = this;

	// Add our sub object type
	TSTR type1(GetString(IDS_RB_LAGPOINTS));
	TSTR type2(GetString(IDS_RB_LAG_EDGE));
	TSTR type3(GetString(IDS_LAG_WEIGHTS));
	const TCHAR *ptype[] = {type1,type2,type3};
	ip->RegisterSubObjectTypes(ptype, 3);

	// Create sub object editing modes.
	moveMode    = new MoveModBoxCMode(this,ip);
	PaintMode = new CreatePaintMode(this,ip);


	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);

	lagDesc.BeginEditParams(ip, this, flags, prev);
	lag_param_blk.SetUserDlgProc(new MapDlgProc(this));
	lag_param_blk.ParamOption(lag_force_node,p_validator,&validator);

	float f;
	Interval iv;
	pblock2->GetValue(lag_paint_strength,ip->GetTime(),f,iv);
	pblock2->SetValue(lag_paint_strength,ip->GetTime(),f);



	}

void LagMod::EndEditParams(
		IObjParam *ip,ULONG flags,Animatable *next)
	{
	this->ip = NULL;
	editMod  = NULL;

	TimeValue t = ip->GetTime();

	// NOTE: This flag must be cleared before sending the REFMSG_END_EDIT
	ClearAFlag(A_MOD_BEING_EDITED);

	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);

	ip->DeleteMode(moveMode);	
	if (moveMode) delete moveMode;
	moveMode = NULL;	

	ip->DeleteMode(PaintMode);	
	if (PaintMode) delete PaintMode;
	PaintMode = NULL;
	
	ip->ClearPickMode();

	lagDesc.EndEditParams(ip, this, flags, next);
	}

RefTargetHandle LagMod::Clone(RemapDir& remap)
	{
	LagMod *mod = new LagMod();
	mod->ReplaceReference(PBLOCK_REF,pblock2->Clone(remap));
	mod->ReplaceReference(POINT1_REF,p1->Clone(remap));

	return mod;
	}

class LagModEnumProc : public ModContextEnumProc {
public:
	LagMod *lm;
	LagModEnumProc(LagMod *l)
		{
		lm = l;
		lm->lmdData.ZeroCount();
		}
private:
	BOOL proc (ModContext *mc);
};

BOOL LagModEnumProc::proc (ModContext *mc) {
	if (mc->localData == NULL) return TRUE;

	LagModData *lmd = (LagModData *) mc->localData;

	BOOL found = FALSE;
	for (int i = 0; i < lm->lmdData.Count(); i++)
		{
		if (lmd == lm->lmdData[i])
			{
			found = TRUE;
			i = lm->lmdData.Count();
			}
		}
	if (!found)
		lm->lmdData.Append(1,&lmd,1);

	return TRUE;
}



int LagMod::CheckCache(TimeValue t)
{
//back step now if needed

	int tps = GetTicksPerFrame();
    MyEnumProc dep;              
	dep.nukeME = FALSE;
	dep.xRefFound = FALSE;
	dep.count = 0;
	EnumDependents(&dep);

	int instanced = dep.count;


	LagModEnumProc lmdproc(this);
	EnumModContexts(&lmdproc);

	for (int li = 0; li < lmdData.Count(); li++)
		{
		LagModData *lmd = lmdData[li];

		BOOL rebuildSystem = FALSE;
		
		if ((TestAFlag(A_RENDER)) && (aboutToRender))
			{
			lmd->lastFrame = 999999999;
			}

		if (t>=ReferenceFrame)
			{

			int fract ;
			int frames ;
			TimeValue StartFrame;
			if ( (t<lmd->lastFrame) )
//				||
//				 ( (t==lmd->lastFrame) && (rebuildSystem) )
//				)
				{

				fract = (t) % tps;
				frames =  t / tps;
				StartFrame = ReferenceFrame;
				int nv = lmd->SpringList.Count();
				for (int i=0;i<nv;i++)
					{
					Point3 v(0.0f,0.0f,0.0f);
					lmd->SpringList[i].pos = lmd->SpringList[i].init_pos;
					lmd->SpringList[i].vel = v;
					}
				}
			else
				{
				fract = t %tps;
				frames =  t / tps;
				StartFrame = lmd->lastFrame+tps;
				int nv = lmd->SpringList.Count();
				for (int i=0;i<nv;i++)
					{
					lmd->SpringList[i].pos = lmd->WholeFrameCache[i].pos;
					lmd->SpringList[i].vel = lmd->WholeFrameCache[i].vel;
					}

				}
//	DebugPrint("time t %d start frame %d\n",t,StartFrame);
			for (int i = StartFrame; i < (frames*tps); i+=tps)
				{
//				Matrix3 tm = lmd->SelfNode->GetObjectTM(i);



				Point3 pp,p,force;

				ObjectState tos;
				int nv = lmd->SpringList.Count();
				int tnv = nv;
				if (i != t)
					{
					if (TestAFlag(A_RENDER)) 
						{
						if (instanced==1)
							EnableModsAbove(lmd,FALSE);
						tos = lmd->SelfNode->EvalWorldState(i);
						if (instanced==1)
							EnableModsAbove(lmd,TRUE);
						}
					}
				}
			}
		}
	return 1;

}




int LagMod::RenderBegin(TimeValue t, ULONG flags)
	{
	SetAFlag(A_RENDER);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	nukeCache = TRUE;


/*
//back step now if needed

	int tps = GetTicksPerFrame();
    MyEnumProc dep;              
	dep.nukeME = FALSE;
	dep.xRefFound = FALSE;
	dep.count = 0;
	EnumDependents(&dep);

	int instanced = dep.count;


	LagModEnumProc lmdproc(this);
	EnumModContexts(&lmdproc);

	for (int li = 0; li < lmdData.Count(); li++)
		{
		LagModData *lmd = lmdData[li];

		BOOL rebuildSystem = FALSE;
		
//		if ((TestAFlag(A_RENDER)) && (aboutToRender))
//			{
			lmd->lastFrame = 999999999;
//			}

		if (t>=ReferenceFrame)
			{

			int fract ;
			int frames ;
			TimeValue StartFrame;
			if ( (t<lmd->lastFrame) )
//				||
//				 ( (t==lmd->lastFrame) && (rebuildSystem) )
//				)
				{

				fract = (t) % tps;
				frames =  t / tps;
				StartFrame = ReferenceFrame;
				int nv = lmd->SpringList.Count();
				for (int i=0;i<nv;i++)
					{
					Point3 v(0.0f,0.0f,0.0f);
					lmd->SpringList[i].pos = lmd->SpringList[i].init_pos;
					lmd->SpringList[i].vel = v;
					}
				}
			else
				{
				fract = t %tps;
				frames =  t / tps;
				StartFrame = lmd->lastFrame+tps;
				int nv = lmd->SpringList.Count();
				for (int i=0;i<nv;i++)
					{
					lmd->SpringList[i].pos = lmd->WholeFrameCache[i].pos;
					lmd->SpringList[i].vel = lmd->WholeFrameCache[i].vel;
					}

				}

			for (int i = StartFrame; i < (frames*tps); i+=tps)
				{
				Matrix3 tm = lmd->SelfNode->GetObjectTM(i);



				Point3 pp,p,force;

				ObjectState tos;
				int nv = lmd->SpringList.Count();
				int tnv = nv;
				if (i != t)
					{
					if (TestAFlag(A_RENDER)) 
						{
						if (instanced==1)
							EnableModsAbove(lmd,FALSE);
						tos = lmd->SelfNode->EvalWorldState(i);
						if (instanced==1)
							EnableModsAbove(lmd,TRUE);
						}
					}
				}
			}
		}
*/
	return 0;
	}

int LagMod::RenderEnd(TimeValue t)
	{
	ClearAFlag(A_RENDER);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	nukeCache = FALSE;

	return 0;
	}




Interval LagMod::LocalValidity(TimeValue t)
	{
	Interval iv = NEVER;
	iv.Set(t,t);
	return iv;
	}


Matrix3 LagMod::CompMatrix(TimeValue t,INode *inode,ModContext *mc)
	{
	Interval iv;
	Matrix3 tm(1);	
	if (inode) 
		tm = tm * inode->GetObjTMBeforeWSM(t,&iv);
	return tm;
	}

int LagMod::HitTest(
		TimeValue t, INode* inode, 
		int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt, ModContext* mc)
	{

	
	LagModData *lmd = (LagModData *) mc->localData;

	if (lmd == NULL) return 0;


	GraphicsWindow *gw = vpt->getGW();
	Point3 pt;
	HitRegion hr;
	int savedLimits, res = 0;
	Matrix3 tm = CompMatrix(t,inode,mc);

	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);	
	gw->setTransform(tm);

	// Hit test start point
	if (ip && ip->GetSubObjectLevel()==1) {

		if ((flags&HIT_SELONLY   &&  sel[0]) ||
			(flags&HIT_UNSELONLY && !sel[0]) ||
			!(flags&(HIT_UNSELONLY|HIT_SELONLY)) ) {
	
			gw->clearHitCode();
			p1->GetValue(t,&pt,FOREVER,CTRL_ABSOLUTE);
			gw->marker(&pt,HOLLOW_BOX_MRKR);
			if (gw->checkHitCode()) {
				vpt->LogHit(inode, mc, gw->getHitDistance(), 0, NULL); 
				res = 1;
				}
			}
		}
	else if ((ip && ip->GetSubObjectLevel()==2) )
		{


//		ObjectState os;

//		os = inode->EvalWorldState(t);
//loop through points checking for selection and then marking for points
//		int nv = os.obj->NumPoints(); 
		int nv = lmd->SpringList.Count();;
		for (int i=0;i<nv;i++)
			{
			if ((flags&HIT_SELONLY   &&  lmd->esel[i]) ||
				(flags&HIT_UNSELONLY && !lmd->esel[i]) ||
				!(flags&(HIT_UNSELONLY|HIT_SELONLY)) ) 
				{

				Point3 pt;
				gw->clearHitCode();
//				pt = os.obj->GetPoint(i);
				pt = lmd->SpringList[i].LocalPt;
				gw->setColor(LINE_COLOR, 1.0f,1.0f,1.0f);
				gw->marker(&pt,POINT_MRKR);
				if (gw->checkHitCode()) {
					vpt->LogHit(inode, mc, gw->getHitDistance(), i, NULL); 
					res = 1;
					}
				}
			}

		}
	else if ( (ip && ip->GetSubObjectLevel()==3) )
		{


//		ObjectState os;

//		os = inode->EvalWorldState(t);
//loop through points checking for selection and then marking for points
//		int nv = os.obj->NumPoints(); 
		int nv = lmd->SpringList.Count();;

		for (int i=0;i<nv;i++)
			{
			if ((flags&HIT_SELONLY   &&  lmd->wsel[i]) ||
				(flags&HIT_UNSELONLY && !lmd->wsel[i]) ||
				!(flags&(HIT_UNSELONLY|HIT_SELONLY)) ) 
				{

				Point3 pt;
				gw->clearHitCode();
				pt = lmd->SpringList[i].LocalPt;
//				pt = os.obj->GetPoint(i);
				gw->setColor(LINE_COLOR, 1.0f,1.0f,1.0f);
				gw->marker(&pt,POINT_MRKR);
				if (gw->checkHitCode()) {
					vpt->LogHit(inode, mc, gw->getHitDistance(), i, NULL); 
					res = 1;
					}
				}
			}

		}


	gw->setRndLimits(savedLimits);
	
	return res;

		return 0;
	}


void LagMod::DrawCrossSectionNoMarkers(Point3 a, Point3 align, float length, GraphicsWindow *gw)

{

#define NNUM_SEGS	8

Point3 plist[NNUM_SEGS+1];
Point3 mka,mkb,mkc,mkd;

align = Normalize(align);
	{
	int ct = 0;
	float angle = TWOPI/float(NNUM_SEGS) ;
	Matrix3 rtm = RotAngleAxisMatrix(align, angle);
	Point3 p(0.0f,0.0f,0.0f);
	if (align.x == 1.0f)
		{
		p.z = length;
		}
	else if (align.y == 1.0f)
		{
		p.x = length;
		}
	else if (align.z == 1.0f)
		{
		p.y = length;
		}
	else if (align.x == -1.0f)
		{
		p.z = -length;
		}
	else if (align.y == -1.0f)
		{
		p.x = -length;
		}
	else if (align.z == -1.0f)
		{
		p.y = -length;
		}
	else 
		{
		p = Normalize(align^Point3(1.0f,0.0f,0.0f))*length;
		}

	for (int i=0; i<NNUM_SEGS; i++) {
		p = p * rtm;
		plist[ct++] = p;
		}

	p = p * rtm;
	plist[ct++] = p;


	for (i=0; i<NNUM_SEGS+1; i++) 
		{
		plist[i].x += a.x;
		plist[i].y += a.y;
		plist[i].z += a.z;
		}
	}
mka = plist[15];
mkb = plist[3];
mkc = plist[7];
mkd = plist[11];

gw->polyline(NNUM_SEGS+1, plist, NULL, NULL, 0);

}



int LagMod::Display(
		TimeValue t, INode* inode, ViewExp *vpt, 
		int flagst, ModContext *mc)
	{

	if (inode)
		{
		if (ip)
			{
			int nodeCount = ip->GetSelNodeCount();
			BOOL found = FALSE;
			for (int nct =0; nct < nodeCount; nct++)
				{
				if (inode == ip->GetSelNode(nct))
					{
					found = TRUE;
					nct = nodeCount;
					}
				}
			if (!found) return 0;
			}

		}
	GraphicsWindow *gw = vpt->getGW();
	Point3 pt[4];
	Matrix3 tm = CompMatrix(t,inode,mc);
	int savedLimits;

	LagModData *lmd = (LagModData *) mc->localData;

	if (lmd == NULL) return 0;

	gw->setRndLimits((savedLimits = gw->getRndLimits()) & ~GW_ILLUM);
	gw->setTransform(tm);
	
	// Draw start point
	if (ip && ip->GetSubObjectLevel() == 1) {
		if (sel[0]) 
			 gw->setColor(LINE_COLOR, (float)1.0, (float)0.0, (float)0.0);			 
		 else 
			gw->setColor(LINE_COLOR,(float)0.0, (float)0.0, (float)1.0);
			
	
	
		p1->GetValue(t,&pt[0],FOREVER,CTRL_ABSOLUTE);
		gw->marker(&pt[0],HOLLOW_BOX_MRKR);
		}
	else if (ip && ip->GetSubObjectLevel() == 2) {
//		ObjectState os;

//		os = inode->EvalWorldState(t);
		int nv = lmd->SpringList.Count();;
		for (int i = 0; i<nv;i++)
			{
			if (lmd->esel[i] == 1)
				{
				Point3 pt;
				pt = lmd->SpringList[i].LocalPt;
//				pt = os.obj->GetPoint(i);
				gw->setColor(LINE_COLOR, 1.0f,0.0f,1.0f);
				gw->marker(&pt,HOLLOW_BOX_MRKR);

				}
			}

		}
	else if (ip && ip->GetSubObjectLevel() == 3) {
//		ObjectState os;

//		os = inode->EvalWorldState(t);
//		int nv = os.obj->NumPoints();
		int nv = lmd->SpringList.Count();;
		for (int i = 0; i<nv;i++)
			{
			if (lmd->wsel[i] == 1)
				{
				Point3 pt;
				pt = lmd->SpringList[i].LocalPt;
//				pt = os.obj->GetPoint(i);
				gw->setColor(LINE_COLOR, 1.0f,1.0f,1.0f);
				gw->marker(&pt,HOLLOW_BOX_MRKR);

				}
			}

		}

	if (ip && (ip->GetSubObjectLevel() != 0) ) 
		{

		if (inPaint)
			{

			if (lmd->isHit)
				{
//draw 3d cursor
				Point3 x(1.0f,0.0f,0.0f),y(0.0f,1.0f,0.0f),z(0.0f,0.0f,1.0f);
				gw->setColor(LINE_COLOR, 1.0f,1.0f,0.0f);

				DrawCrossSectionNoMarkers(lmd->hitPoint, x, Radius, gw); 
				DrawCrossSectionNoMarkers(lmd->hitPoint, y, Radius, gw); 
				DrawCrossSectionNoMarkers(lmd->hitPoint, z, Radius, gw); 

				}

			}
		}

	if ((ip && (ip->GetSubObjectLevel() != 0) ) && (this->IsEnabled()) && (this->IsEnabledInViews()))
		{


		ObjectState os;

		os = inode->EvalWorldState(t);
//loop through points checking for selection and then marking
		float r,g,b;

		for (int i=0;i<lmd->SpringList.Count();i++)
			{
			Point3 pt;
//			pt = os.obj->GetPoint(i);
			
			pt = lmd->SpringList[i].LocalPt;
//gte red is strongest,green, blue is weakest based on influence
			float infl;
			if (lmd->wsel[i]==1)
				{
				if (absoluteWeight)
					infl = weightDelta;
					else infl = 1.0f - lmd->SpringList[i].InheritVel + weightDelta;
				}
			else infl = 1.0f - lmd->SpringList[i].InheritVel;
			Point3 selColor(0.0f,0.0f,0.0f);
			Point3 selSoft = GetUIColor(COLOR_SUBSELECTION_SOFT);
			Point3 selMedium = GetUIColor(COLOR_SUBSELECTION_MEDIUM);
			Point3 selHard = GetUIColor(COLOR_SUBSELECTION_HARD);

			if (infl <= 0.0f) selColor = GetUIColor(COLOR_SUBSELECTION_SOFT);
			else if ( (infl<0.5) && (infl >= 0.0f))
				{
				selColor = selSoft + ( (selMedium-selSoft) * (infl/0.5f));
				}
			else if (infl<=1.0)
				{
				selColor = selMedium + ( (selHard-selMedium) * ((infl-0.5f)/0.5f));
				}
			else 
				{
				selColor = GetUIColor(COLOR_SUBSELECTION);
				}
			r = selColor.x;
			g = selColor.y;
			b = selColor.z;

			gw->setColor(LINE_COLOR, r,g,b);
			gw->marker(&pt,PLUS_SIGN_MRKR);

			if (inPaint)
				{
				if (lmd->psel[i] == 1)
					{
					gw->setColor(LINE_COLOR, 1.0f,1.0f,1.0f);
					gw->marker(&pt,HOLLOW_BOX_MRKR);
					}

				}



			}
		}

//	gw->marker(&pt[1],HOLLOW_BOX_MRKR);

	gw->setRndLimits(savedLimits);

	return 0;

	}

void LagMod::GetWorldBoundBox(
		TimeValue t,INode* inode, ViewExp *vpt, 
		Box3& box, ModContext *mc)
	{
	
	if (inPaint)
		{
		Matrix3 tm = CompMatrix(t,inode,mc);
		Point3 pt1, pt2;
		box.Init();
		LagModData *lmd = (LagModData *) mc->localData;
		if (lmd == NULL) return;

		pt1 = lmd->hitPoint;
		box += pt1 * tm;
		box.EnlargeBy(Radius*2.5f);
		}

	
	}

void LagMod::Move(TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin)
	{
	if (ip && ip->GetSubObjectLevel() == 1) {
		if (sel[0]) {
			p1->SetValue(
				ReferenceFrame,VectorTransform(tmAxis*Inverse(partm),val),
				TRUE,CTRL_RELATIVE);
			updateWeights = TRUE;
			}
		}
	else if (ip && ip->GetSubObjectLevel() == 2) {
		}
	else if (ip && ip->GetSubObjectLevel() == 3) {
		}

	}

void LagMod::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,
		INode *node,ModContext *mc)
	{

	Matrix3 tm = CompMatrix(t,node,mc);
	Point3 pt(0,0,0), p;
	int c=0;
	if (sel[0]) {
		p1->GetValue(t,&p,FOREVER,CTRL_ABSOLUTE);
		pt += p;
		c++;
		}
	if (c) pt /= float(c);
	tm.PreTranslate(pt);
	cb->Center(tm.GetTrans(),0);

	}

void LagMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,
		INode *node,ModContext *mc)
	{
	Matrix3 tm = CompMatrix(t,node,mc);
	cb->TM(tm,0);
	
	}


void LagMod::SelectSubComponent(
		HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert)
	{

	LagModData *lmd = (LagModData*)hitRec->modContext->localData;

	if (lmd == NULL) return;

	if (ip && ip->GetSubObjectLevel() == 1) {
	
		while (hitRec) {
			assert(hitRec->hitInfo<=1);
			BOOL state = selected;
			if (invert) state = !sel[hitRec->hitInfo];
			if (state) sel[hitRec->hitInfo] = 1;
			else       sel[hitRec->hitInfo] = 0;
			if (!all) break;
			hitRec = hitRec->Next();
			}	
		}
	else if ( (ip && ip->GetSubObjectLevel() == 2) || (ip && ip->GetSubObjectLevel() == 3)){
		BOOL add = GetKeyState(VK_CONTROL)<0;
		BOOL sub = GetKeyState(VK_MENU)<0;
		updateWeights = TRUE;

		if (!add && !sub) 
			{
			if (ip && ip->GetSubObjectLevel() == 2)
				{
				for (int i =0;i<lmd->esel.Count();i++)
					lmd->esel[i] = FALSE;
				}
			else
				{
				for (int i =0;i<lmd->wsel.Count();i++)
					lmd->wsel[i] = FALSE;
				}
			}

		int Count = 0;
		BOOL state = selected;
		while (hitRec) {
			state = hitRec->hitInfo;
			if (sub)
				{
				if (ip && ip->GetSubObjectLevel() == 2)
					lmd->esel[state] = FALSE;
				else lmd->wsel[state] = FALSE;
				}
			else 
				{
				if (ip && ip->GetSubObjectLevel() == 2)
					lmd->esel[state] = TRUE;
				else lmd->wsel[state] = TRUE;
				}

		
			hitRec = hitRec->Next();
			Count++;
			}	
		}

	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	
	}

void LagMod::ClearSelection(int selLevel)
	{
	ModContextList mcList;		
	INodeTab nodes;

	if (ip)
		{
		ip->GetModContexts(mcList,nodes);
		int objects = mcList.Count();

		for ( int i = 0; i < objects; i++ ) 
			{
			LagModData *lmd = (LagModData*)mcList[i]->localData;
			if (lmd)
				{
				if (ip->GetSubObjectLevel() == 2)
					{
					for (int i =0 ; i < lmd->esel.Count(); i++)
						lmd->esel[i] = 0;
					}
				else if (ip->GetSubObjectLevel() == 3)
					{
					for (int i =0 ; i < lmd->wsel.Count(); i++)
						lmd->wsel[i] = 0;
					}
				}	
			}
		}

	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void LagMod::SelectAll(int selLevel)
	{

	ModContextList mcList;		
	INodeTab nodes;

	if (ip)
		{
		ip->GetModContexts(mcList,nodes);
		int objects = mcList.Count();

		for ( int i = 0; i < objects; i++ ) 
			{
			LagModData *lmd = (LagModData*)mcList[i]->localData;
			if (lmd)
				{
				if (ip->GetSubObjectLevel() == 2)
					{
					for (int i =0 ; i < lmd->esel.Count(); i++)
						lmd->esel[i] = 1;
					}
				else if (ip->GetSubObjectLevel() == 3)
					{
					for (int i =0 ; i < lmd->wsel.Count(); i++)
						lmd->wsel[i] = 1;
					}
				}
			}
		}

	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void LagMod::InvertSelection(int selLevel)
	{
	ModContextList mcList;		
	INodeTab nodes;

	if (ip)
		{
		ip->GetModContexts(mcList,nodes);
		int objects = mcList.Count();

		for ( int i = 0; i < objects; i++ ) 
			{
			LagModData *lmd = (LagModData*)mcList[i]->localData;
			if (lmd)
				{
				if (ip->GetSubObjectLevel() == 2)
					{
					for (int i =0 ; i < lmd->esel.Count(); i++)
						lmd->esel[i] = !lmd->esel[i];
					}
				else if (ip->GetSubObjectLevel() == 3)
					{
					for (int i =0 ; i < lmd->wsel.Count(); i++)
						lmd->wsel[i] = !lmd->wsel[i];
					}
				}
			}
		}

	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void LagMod::ActivateSubobjSel(int level, XFormModes& modes)
	{
	switch (level) {
		case 0:
			if (ip->GetCommandMode() == PaintMode) {
				ip->SetStdCommandMode(CID_OBJMOVE);
				return;
				}
			iPaintButton->Enable(FALSE);

			break;
		case 1: // Center Point
			iPaintButton->Enable(TRUE);
			modes = XFormModes(moveMode,NULL,NULL,NULL,NULL,NULL);
			break;		
		case 2: // Edge
			iPaintButton->Enable(TRUE);
			modes = XFormModes(moveMode,NULL,NULL,NULL,NULL,NULL);
			break;		
		case 3: // weigths
			iPaintButton->Enable(TRUE);
			modes = XFormModes(moveMode,NULL,NULL,NULL,NULL,NULL);
			break;		
		}
	NotifyDependents(FOREVER,PART_DISPLAY,REFMSG_CHANGE);
	}


void LagMod::StartPaintMode()
{
if ( !ip ) return;
if (ip && ( (ip->GetSubObjectLevel()==1) || (ip->GetSubObjectLevel()==2) || (ip->GetSubObjectLevel()==3) ) )
	{

//get mesh
	if (ip->GetCommandMode() == PaintMode) {
		ip->SetStdCommandMode(CID_OBJMOVE);
		return;
		}

    ip->SetCommandMode(PaintMode);

    }
}


RefTargetHandle LagMod::GetReference(int i)
	{
	switch (i) {
		case PBLOCK_REF: return (RefTargetHandle)pblock2;

		case POINT1_REF: return (RefTargetHandle)p1;

		default : return NULL;
		}
	return NULL;
	}

void LagMod::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case PBLOCK_REF: pblock2 = (IParamBlock2*)rtarg; break;
		case POINT1_REF: p1     = (Control*)rtarg; break;
		}
	}


Animatable* LagMod::SubAnim(int i)
	{
	switch (i) {
		case PBLOCK_REF: 		return pblock2;
		case POINT1_REF: 		return p1;
		default: 			return NULL;   
		}
	}

TSTR LagMod::SubAnimName(int i)
	{
	if (i==POINT1_REF) return GetString(IDS_RB_LAGPOINTS);
	return _T(""); 

	}

RefResult LagMod::NotifyRefChanged(
		Interval changeInt,RefTargetHandle hTarget, 
		PartID& partID, RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:	
			{ 
			if (hTarget == pblock2)
				{
				ParamID changing_param = pblock2->LastNotifyParamID();

				lag_param_blk.InvalidateUI(changing_param);
				}

			break;
			}


		}
	return REF_SUCCEED;
	}


class TempStorageClass
{
public:
	Point3 pos;
	float IVel;
	BYTE sel;
	BOOL modified;
};


#define BACKPATCH_CHUNK		0x2120


IOResult LagMod::Save(ISave *isave)
	{
	Modifier::Save(isave);
	ULONG nb;

	ULONG id = isave->GetRefID(container);

	isave->BeginChunk(BACKPATCH_CHUNK);
	isave->Write(&id,sizeof(ULONG),&nb);
	isave->EndChunk();



	return IO_OK;
	}



class LagModPostLoad : public PostLoadCallback {
	public:
		LagMod *n;
		LagModPostLoad(LagMod *ns) {n = ns;}
		void proc(ILoad *iload) {  
			if (n->container != NULL)
				{
				n->container->RegisterTVNodeNotify(n->notify);
				}
			delete this; 


			} 
	};


IOResult LagMod::Load(ILoad *iload)
	{

	IOResult res = IO_OK;
	int NodeID = 0;
	ULONG nb;



	Modifier::Load(iload);

	TempStorageClass tsc;


	int ct = 0;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case BACKPATCH_CHUNK:
				ULONG id;
				iload->Read(&id,sizeof(ULONG), &nb);
				if (id!=0xffffffff)
					{
					iload->RecordBackpatch(id,(void**)&container);
					}

				break;
			case POS_WEIGHT_CHUNK:
				Point3 Zero(0.0f,0.0f,0.0f);
			
//read in data
				int ct;
				iload->Read(&ct, sizeof(ct), &nb);
				oldSpringList.SetCount(ct);
				oldesel.SetCount(ct);
				for (int i=0;i<ct;i++)
					{
					iload->Read(&tsc, sizeof(tsc), &nb);

					oldSpringList[i].pos = tsc.pos;
					oldSpringList[i].init_pos = tsc.pos;
					oldSpringList[i].vel = Zero;
					oldSpringList[i].InheritVel = tsc.IVel;
					oldSpringList[i].modified = tsc.modified;
					oldesel[i] = tsc.sel;
				
					}

				break;

			}


		iload->CloseChunk();
		if (res!=IO_OK)
			return res;
		

		}

	iload->RegisterPostLoadCallback(new LagModPostLoad(this));

	return IO_OK;
}

Point3 LagDeformer::Map(int i, Point3 p)
	{

	if (lmd)
		{
		if (i < lmd->SpringList.Count())
			{
			float IVel = 0.0f;
		
			if (lmd->wsel[i] == 1)
				{
				if (mod->absoluteWeight) 
					IVel = (1.0f-mod->weightDelta) * mod->falloff;
				else IVel = (lmd->SpringList[i].InheritVel-mod->weightDelta) * mod->falloff;
				}
			else IVel = lmd->SpringList[i].InheritVel * mod->falloff;
			p = (lmd->SpringList[i].pos * lmd->InverseTM * IVel)+(p *(1.0f-IVel));
			lmd->SpringList[i].LocalPt = p;
			}
		}
	return p;


	}

void LagMod::ResetSprings()

{
ModContextList mcList;		
INodeTab nodes;

if (!ip) return;

ip->GetModContexts(mcList,nodes);
int objects = mcList.Count();

for ( int k = 0; k < objects; k++ ) 
	{

	LagModData *lmd = (LagModData*)mcList[k]->localData;
	
	if (lmd)
		{

		for (int i = 0; i < lmd->SpringList.Count(); i++)
			lmd->SpringList[i].modified = FALSE;
		}
	}
}


void LagMod::AddForceField()

{
int ct = pblock2->Count(lag_force_node);
ff.SetCount(ct);
for (int i = 0; i < ct; i++)
	{
	INode *node = NULL;
	Interval iv;
	pblock2->GetValue(lag_force_node,0,node,iv, i);
	if (node != NULL)
		{
		WSMObject *obref=(WSMObject*)node->GetObjectRef();
		ff[i]=obref->GetForceField(node);
		}
	else ff[i]=NULL;
	}
}

Point3 LagMod::GetForce(TimeValue t, Point3 p, Point3 v, Matrix3 tm)
{

Point3 f(0.0f,0.0f,0.0f);
	


int ct = pblock2->Count(lag_force_node);
for (int i = 0; i < ct; i++)
	{
	INode *node = NULL;
	Interval iv;
	pblock2->GetValue(lag_force_node,0,node,iv, i);
	if ((node != NULL) && (ff[i] != NULL))
		f += 16000.0f * ff[i]->Force(t,p,v,0);
	}

return f;
}


void LagMod::ComputeCenterFalloff(LagModData *lmd, TimeValue t, ObjectState *os)
{
	Point3 Center;
	Interval iv;
	float Dist =0.0f;

	p1->GetValue(t,&Center,iv,CTRL_ABSOLUTE);
	int nv = os->obj->NumPoints(); 

//build a temp edge list here 
	Tab<Point3> EdgeList;
	EdgeList.Append(1,&Center,1);

	Tab<int> EdgeIndex;
	EdgeIndex.SetCount(nv);

	for (int i = 0; i< lmd->esel.Count();i++)
		{
		if (lmd->esel[i]==1)
			{
			Point3 ep = os->obj->GetPoint(i);
			EdgeList.Append(1,&ep,1);
			}

		}


	for (i=0;i<nv;i++)
		{
//loop through all edges find closest
		float temp = Length(EdgeList[0] - os->obj->GetPoint(i));
		EdgeIndex[i] = 0;
		for (int j = 1; j < EdgeList.Count(); j++)
			{
			float etemp;
			etemp = Length(EdgeList[j] - os->obj->GetPoint(i));
			if (etemp < temp) 
				{
				temp = etemp;
				EdgeIndex[i] = j;
				}
			}
//				temp = Length(Center - os->obj->GetPoint(i));
		if (temp>Dist)
			Dist = temp;
		}
	BOOL nuke = FALSE;

	for (i=0;i<nv;i++)
		{
		float temp;
		temp = Length(EdgeList[EdgeIndex[i]] - os->obj->GetPoint(i))/Dist;
		temp = (temp*temp);
		if (!lmd->SpringList[i].modified) 
			{
			lmd->SpringList[i].InheritVel = temp;
			}
					
		}
	EdgeList.ZeroCount();

}



LagMod::EnableModsAbove(LagModData *lmd, BOOL enable)
	{

	int				i;
	SClass_ID		sc;
	IDerivedObject* dobj;

// return the indexed modifier in the mod chain
	INode *node = lmd->SelfNode;
	BOOL found = FALSE;

// then osm stack
	Object* obj = node->GetObjectRef();
	int ct = 0;

	if ((sc = obj->SuperClassID()) == GEN_DERIVOB_CLASS_ID)
		{
		dobj = (IDerivedObject*)obj;
		if (!enable) 
			{
			enableStates.ZeroCount();
			enableViewStates.ZeroCount();
			}

		while (sc == GEN_DERIVOB_CLASS_ID)
			{
			for (i = 0; i < dobj->NumModifiers(); i++)
				{
				TSTR name;
				Modifier *m = dobj->GetModifier(i);
				m->GetClassName(name);
				if (this == dobj->GetModifier(i))
					found = TRUE;


				BOOL en = m->IsEnabled();
				BOOL env = m->IsEnabledInViews();
//				DebugPrint("%s enable state %d view %d\n",name,en,env);
				if (!enable)
					{
					if (!found)
						{
						enableStates.Append(1,&en,1);
						enableViewStates.Append(1,&env,1);
						m->DisableMod();
						m->DisableModInViews();
						}
					}
				else 
					{
					if (!found)
						{
						if (!enableStates[ct])
							m->DisableMod();
						else m->EnableMod();
						if (!enableViewStates[ct++])
							m->DisableModInViews();
						else m->EnableModInViews();
						}
					}

				}
			dobj = (IDerivedObject*)dobj->GetObjRef();
			sc = dobj->SuperClassID();
			}
		}

	if ((dobj = node->GetWSMDerivedObject()) != NULL)
		for (i = 0; i < dobj->NumModifiers(); i++)
			{
			Modifier *m = dobj->GetModifier(i);
			BOOL en = m->IsEnabled();
			BOOL env = m->IsEnabledInViews();
			if (!enable)
				{
				enableStates.Append(1,&en,1);
				enableViewStates.Append(1,&env,1);
				}
			else
				{
				if (!enableStates[ct])
					m->DisableMod();
				else m->EnableMod();
				if (!enableViewStates[ct++])
					m->DisableModInViews();
				else m->EnableModInViews();

				}

			}


	}

/*

LagMod::EnableModsAbove(LagModData *lmd, BOOL enable)
	{

	int				i;
	SClass_ID		sc;
	IDerivedObject* dobj;

// return the indexed modifier in the mod chain
	INode *node = lmd->SelfNode;
	BOOL found = FALSE;

// then osm stack
	Object* obj = node->GetObjectRef();
	int ct = 0;

	if ((sc = obj->SuperClassID()) == GEN_DERIVOB_CLASS_ID)
		{
		dobj = (IDerivedObject*)obj;
		if (!enable) enableStates.ZeroCount();

		while (sc == GEN_DERIVOB_CLASS_ID)
			{
			for (i = 0; i < dobj->NumModifiers(); i++)
				{
				TSTR name;
				Modifier *m = dobj->GetModifier(i);
				m->GetClassName(name);
				DebugPrint("%s\n",name);
				if (this == dobj->GetModifier(i))
					found = TRUE;


				BOOL en = m->IsEnabled();
				if (!enable)
					{
					enableStates.Append(1,&en,1);
					if (!found)
						m->DisableMod();
					}
				else 
					{
					if (enableStates[ct++])
						m->DisableMod();
					else m->EnableMod();
					}

				}
			dobj = (IDerivedObject*)dobj->GetObjRef();
			sc = dobj->SuperClassID();
			}
		}

	if ((dobj = node->GetWSMDerivedObject()) != NULL)
		for (i = 0; i < dobj->NumModifiers(); i++)
			{
			Modifier *m = dobj->GetModifier(i);
			BOOL en = m->IsEnabled();
			if (!enable)
				{
				enableStates.Append(1,&en,1);
				}
			else
				{
				if (enableStates[ct++])
					m->DisableMod();
				else m->EnableMod();

				}

			}


	}

*/

void LagMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{	


//this is a hack to handle if scatter is in my dependancy
//scatter and lag do not get along so when scatter using its animationn offset i turn my self off
//to prevent an infintie loop of lag and scatter trying to update themselves 
    MyEnumProc dep;              
	dep.nukeME = FALSE;
	dep.xRefFound = FALSE;
	dep.count = 0;
	EnumDependents(&dep);
	if (dep.nukeME) return;

	int instanced = dep.count;

	if (os->obj->IsWorldSpaceObject()) return;

	int nv = os->obj->NumPoints();

	int tps = GetTicksPerFrame();

//7-1-99
	BOOL isXRefObj = dep.xRefFound;

	
	if (ip != NULL && editMod == this)
		{
		ModContextList mcList;
		INodeTab nodes;
		if (mc.localData == NULL)
			{

			ip->GetModContexts(mcList,nodes);

//add a new inode to trackview
			ITrackViewNode *tvr = ip->GetTrackViewRootNode();
			ITrackViewNode *global = tvr->GetNode(Class_ID(0xb27e9f2a, 0x73fad370));
			ITrackViewNode *tvroot = global->GetNode(LAGCONTAINERMASTER_TVNODE_CLASS_ID);
			if (!tvroot) 
				{
				ITrackViewNode *mcontainer =  CreateITrackViewNode();
				global->AddNode(mcontainer,GetString(IDS_PW_FLEXDATA),LAGCONTAINERMASTER_TVNODE_CLASS_ID);
				tvroot = mcontainer;
				}

//add a new a container
			container =  CreateITrackViewNode(TRUE);
			tvroot->AddNode(container,GetString(IDS_PW_FLEXDATA),LAGCONTAINER_TVNODE_CLASS_ID);
			for (int i = 0; i < nodes.Count(); i++)
				{
				container->AddController(nodes[i]->GetTMController(),nodes[i]->GetName(),LAGNODE_TVNODE_CLASS_ID);
				LagModData *d  = new LagModData(i,nodes[i]);
				mcList[i]->localData = d;
				}
			container->RegisterTVNodeNotify(notify);
//load up old pre beta files
			if (oldSpringList.Count() != 0)
				{
				LagModData *d = (LagModData *) mcList[0]->localData;

				d->SpringList = oldSpringList;
				d->esel = oldesel;
				d->psel.SetCount(oldesel.Count());
				d->wsel.SetCount(oldesel.Count());
				for (int esel_index = 0; esel_index < nv; esel_index++)
					{
					d->psel[esel_index] = 0;
					d->wsel[esel_index] = 0;
	
					}


				}

			NotifyDependents(FOREVER, OBJ_CHANNELS, REFMSG_CHANGE);
			Interval valid;
			valid.SetEmpty();
			os->obj->UpdateValidity(GEOM_CHAN_NUM,valid); // Have to do this to get it to evaluate

			return;
					
			}
		else
			{

			LagModData *d = (LagModData *) mc.localData;
			if (d->SelfNode == NULL)
				{

				ip->GetModContexts(mcList,nodes);

//add a new inode to trackview
				ITrackViewNode *tvr = ip->GetTrackViewRootNode();
				ITrackViewNode *global = tvr->GetNode(Class_ID(0xb27e9f2a, 0x73fad370));
				ITrackViewNode *tvroot = global->GetNode(LAGCONTAINERMASTER_TVNODE_CLASS_ID);
				if (!tvroot) 
					{
					ITrackViewNode *mcontainer =  CreateITrackViewNode();
					global->AddNode(mcontainer,GetString(IDS_PW_FLEXDATA),LAGCONTAINERMASTER_TVNODE_CLASS_ID);
					tvroot = mcontainer;
					}
//add a new a container
				container = CreateITrackViewNode(TRUE);
				tvroot->AddNode(container,GetString(IDS_PW_FLEXDATA),LAGCONTAINER_TVNODE_CLASS_ID);
				for (int i = 0; i < nodes.Count(); i++)
					{
					container->AddController(nodes[i]->GetTMController(),nodes[i]->GetName(),LAGNODE_TVNODE_CLASS_ID);
					d->SelfNode = nodes[i];
					}
				container->RegisterTVNodeNotify(notify);

				NotifyDependents(FOREVER, OBJ_CHANNELS, REFMSG_CHANGE);
				Interval valid;
				valid.SetEmpty();
				os->obj->UpdateValidity(GEOM_CHAN_NUM,valid); // Have to do this to get it to evaluate
				return;
				}


					
			}

//		return;

		}



	LagModData *lmd = (LagModData *) mc.localData;

//7-1-99 special acase code to handle xrefs since xrefs don't save thus the backpointer is wrong
	if (isXRefObj)
		{
		lmd->SelfNode = NULL;
		if (dep.Nodes.Count() > 0)
			lmd->SelfNode = dep.Nodes[0];
		}
//this is here to handle a merge you will have a lmd nad self node but no container which must be recreated
	else if ((container == NULL) && (lmd) && (lmd->SelfNode))
		{
//add a new inode to trackview
		Interface *tip = ip;
		if (!tip) tip = GetCOREInterface();
		ITrackViewNode *tvr = tip->GetTrackViewRootNode();
		ITrackViewNode *global = tvr->GetNode(Class_ID(0xb27e9f2a, 0x73fad370));
		ITrackViewNode *tvroot = global->GetNode(LAGCONTAINERMASTER_TVNODE_CLASS_ID);
		if (!tvroot) 
			{
			ITrackViewNode *mcontainer =  CreateITrackViewNode();
			global->AddNode(mcontainer,GetString(IDS_PW_FLEXDATA),LAGCONTAINERMASTER_TVNODE_CLASS_ID);
			tvroot = mcontainer;
			}
//add a new a container
		container = CreateITrackViewNode(TRUE);
		tvroot->AddNode(container,GetString(IDS_PW_FLEXDATA),LAGCONTAINER_TVNODE_CLASS_ID);
		container->AddController(lmd->SelfNode->GetTMController(),lmd->SelfNode->GetName(),LAGNODE_TVNODE_CLASS_ID);
		container->RegisterTVNodeNotify(notify);
		}
	else 	if (container == NULL)
		{
		return;
		}


	if ((ip && editMod == this) && (lmd) && (lmd->SelfNode == NULL))
		{
		NotifyDependents(FOREVER, OBJ_CHANNELS, REFMSG_CHANGE);
		Interval valid;
		valid.SetEmpty();
		os->obj->UpdateValidity(GEOM_CHAN_NUM,valid); // Have to do this to get it to evaluate
		return;
		}


	Point3 Center;
	Interval iv = FOREVER;
	pblock2->GetValue(lag_absolute,t,absoluteWeight,iv);
	pblock2->GetValue(lag_flex,t,falloff,iv);
	
	pblock2->GetValue(lag_strength,t,strength,iv);

	pblock2->GetValue(lag_sway,t,dampening,iv);

	pblock2->GetValue(lag_paint_strength,t,PaintStrength,iv);
	pblock2->GetValue(lag_paint_radius,t,Radius,iv);
	pblock2->GetValue(lag_paint_feather,t,Feather,iv);
	pblock2->GetValue(lag_paint_backface,t,ProjectThrough,iv);



	strength = strength/100.0f;
	dampening = dampening/100.0f;

	pblock2->GetValue(lag_referenceframe,t,ReferenceFrame,iv);
	ReferenceFrame = ReferenceFrame * GetTicksPerFrame();


//check if SpringList is zero or does not match current vertex count nuke are and rebuild

	if (lmd != NULL)
		{
		}


	if ((lmd != NULL) && (lmd->SelfNode != NULL))
		{

		if (TestAFlag(A_RENDER)) 
			{
			if (lmd->nukeRenderCache)
				{
				lmd->lastFrame = 999999999;
				lmd->nukeRenderCache = FALSE;
				}
			}
		else
			{
			lmd->nukeRenderCache = TRUE;
			}

		if (lmd->esel.Count() != nv)
			{
			lmd->esel.ZeroCount();
			lmd->psel.ZeroCount();
			lmd->wsel.ZeroCount();
			lmd->esel.SetCount(nv);
			lmd->psel.SetCount(nv);
			lmd->wsel.SetCount(nv);

			for (int esel_index = 0; esel_index < nv; esel_index++)
				{
				lmd->esel[esel_index] = 0;
				lmd->psel[esel_index] = 0;
				lmd->wsel[esel_index] = 0;

				}
			}

		Point3 v(0.0f,0.0f,0.0f);
		lmd->InverseTM = Inverse(lmd->SelfNode->GetObjectTM(t));
		float Dist =0.0f;

		int ect = 0;
		for (int i = 0; i< lmd->esel.Count();i++)
			{
			if (lmd->esel[i]==1)
				ect++;
			}

		if ((nv == ect) || (updating)) 
			{
			if (updating)
				{
				if (lmd->pointCache.Count() != os->obj->NumPoints())
					lmd->pointCache.SetCount(os->obj->NumPoints());
				for (int i = 0; i < lmd->pointCache.Count(); i++)
					lmd->pointCache[i] = os->obj->GetPoint(i);
				}
			os->obj->UpdateValidity(GEOM_CHAN_NUM, LocalValidity(t));
//			os->obj->UpdateValidity(TOPO_CHAN_NUM, LocalValidity(t)); // Have to do this to get it to evaluate
			return;
			}

//		if ((TestAFlag(A_RENDER)) && (aboutToRender))
//			{
//			lmd->lastFrame = 999999999;
//			}



		BOOL rebuildSystem = FALSE;
		
		if (lmd->pointCache.Count() != os->obj->NumPoints())
			rebuildSystem = TRUE;
	
		if ((!rebuildSystem) && (t==lmd->lastFrame))
			{
			for (int i = 0; i < lmd->pointCache.Count(); i++)
				{
				if (lmd->pointCache[i] != os->obj->GetPoint(i))
					{
					rebuildSystem = TRUE;
					i = lmd->pointCache.Count();
					}
				}
			}

		Point3 tCenter;
		p1->GetValue(ReferenceFrame,&tCenter,iv,CTRL_ABSOLUTE);
		if (tCenter != lagCenter)
			updateWeights = TRUE;


		if ( (t==ReferenceFrame) || (lmd->SpringList.Count() == 0) || (lmd->SpringList.Count() != nv) || updateWeights)
			{    

			Matrix3 tm = lmd->SelfNode->GetObjectTM(ReferenceFrame);
			p1->GetValue(ReferenceFrame,&Center,iv,CTRL_ABSOLUTE);
			lagCenter = Center;

			updateWeights = FALSE;

//build a temp edge list here 
			Tab<Point3> EdgeList;
			EdgeList.Append(1,&Center,1);

			Tab<int> EdgeIndex;
			EdgeIndex.SetCount(nv);

			for (int i = 0; i< lmd->esel.Count();i++)
				{
				if (lmd->esel[i]==1)
					{
					Point3 ep = os->obj->GetPoint(i);
					EdgeList.Append(1,&ep,1);

					}

				}


			for (i=0;i<nv;i++)
				{
//loop through all edges find closest
				float temp = Length(EdgeList[0] - os->obj->GetPoint(i));
				EdgeIndex[i] = 0;
				for (int j = 1; j < EdgeList.Count(); j++)
					{
					float etemp;
					etemp = Length(EdgeList[j] - os->obj->GetPoint(i));
					if (etemp < temp) 
						{
						temp = etemp;
						EdgeIndex[i] = j;
						}
					}
//				temp = Length(Center - os->obj->GetPoint(i));
				if (temp>Dist)
					Dist = temp;
				}
			BOOL nuke = FALSE;
			if (lmd->SpringList.Count() != nv)
				{
				lmd->SpringList.ZeroCount();
				lmd->SpringList.SetCount(nv);
				lmd->WholeFrameCache.SetCount(nv);
				nuke = TRUE;
				}

 
// fix for bug 207988 9/8/99
 			if (lmd->pointCache.Count() != nv)
				lmd->pointCache.SetCount(nv);


			for (i=0;i<nv;i++)
				{
				float temp;
				temp = Length(EdgeList[EdgeIndex[i]] - os->obj->GetPoint(i))/Dist;
				temp = (temp*temp);
				SpringClass sc;
				sc.pos = os->obj->GetPoint(i) * tm;
				sc.init_pos = sc.pos;
				sc.vel = v;
				if ( (nuke) || (!lmd->SpringList[i].modified) )
					{
					sc.InheritVel = temp;// * falloff;
					sc.modified = FALSE;
					}
				else 
					{
					if (lmd->wsel[i] == 1)
						{
						if (absoluteWeight)
							sc.InheritVel = 1.0f-weightDelta;
						else sc.InheritVel = lmd->SpringList[i].InheritVel -weightDelta;
						}
					else sc.InheritVel = lmd->SpringList[i].InheritVel;// * falloff;
					sc.modified = lmd->SpringList[i].modified;
					
					}
				lmd->SpringList[i]=sc;
				lmd->WholeFrameCache[i].pos = sc.pos;
				lmd->WholeFrameCache[i].vel = sc.vel;
// fix for bug 207988 9/8/99
				lmd->pointCache[i] = os->obj->GetPoint(i);
				}
			EdgeList.ZeroCount();
			lmd->lastFrame = ReferenceFrame;
			}
//		else ComputeCenterFalloff(lmd,t,os);



//for now we will do no cacheing and recompute the system from the ref, frame everytime
//		char ts[200];
//		wsprintf(ts,"nv %d sp %d cach %d pcache %d\n",nv,lmd->SpringList.Count(),lmd->WholeFrameCache.Count(),lmd->pointCache.Count());
//		if ((TestAFlag(A_RENDER)) && (t==ReferenceFrame))
//			MessageBox(NULL,ts,"Error",MB_OK);


		if (t>=ReferenceFrame)
			{

			int fract ;
			int frames ;
			TimeValue StartFrame;
//			if ( (t<lmd->lastFrame) )
			if ( (t<lmd->lastFrame) ||
				 ( (t==lmd->lastFrame) && (rebuildSystem) )
				)
				{

				fract = (t) % tps;
				frames =  t / tps;
				StartFrame = ReferenceFrame;
				for (int i=0;i<nv;i++)
					{
					Point3 v(0.0f,0.0f,0.0f);
					lmd->SpringList[i].pos = lmd->SpringList[i].init_pos;
					lmd->SpringList[i].vel = v;
					}
				}
			else
				{
				fract = t %tps;
				frames =  t / tps;
				StartFrame = lmd->lastFrame+tps;
				for (int i=0;i<nv;i++)
					{
					lmd->SpringList[i].pos = lmd->WholeFrameCache[i].pos;
					lmd->SpringList[i].vel = lmd->WholeFrameCache[i].vel;
					}

				}

			for (int i = StartFrame; i <= (frames*tps); i+=tps)
				{
				Matrix3 tm = lmd->SelfNode->GetObjectTM(i);

				for (int k=0;k<ff.Count();k++)
					{
					if (ff[k]) 
						{
						ff[k]->DeleteThis();
						}

					ff[k] = NULL;
					}

//compute gravity
				AddForceField();

				Point3 pp,p,force;

				ObjectState tos;
				int tnv = nv;

				nv = lmd->SpringList.Count();
				for (int j=0;j<nv;j++)
					{
					Point3 g(0.0f,0.0f,0.0f);
					g = GetForce(i, lmd->SpringList[j].pos, lmd->SpringList[j].vel, tm);
			
					if (i != t)
						{
						if (TestAFlag(A_RENDER)) 
							{
							if (j < tnv) p = lmd->pointCache[j];
							}
						else 
							{
							if (j < nv) p = os->obj->GetPoint(j);
							}
						}
					else p = os->obj->GetPoint(j);
					force = lmd->SpringList[j].pos-(p * tm);
					lmd->SpringList[j].vel += g;
					lmd->SpringList[j].vel += ((-strength*force)-(dampening*lmd->SpringList[j].vel));
					lmd->SpringList[j].pos += lmd->SpringList[j].vel;

					}

				}
//copy that last whole frame to cache
			for (i=0;i<nv;i++)
				{
				lmd->WholeFrameCache[i].pos = lmd->SpringList[i].pos;
				lmd->WholeFrameCache[i].vel = lmd->SpringList[i].vel;
				}
			lmd->lastFrame = frames*tps;
			

//compute fraction incase of motion blur, fields, or realtime playback
			if (fract != 0)
				{
				float per = (float)fract/(float)tps;

				Matrix3 tm = lmd->SelfNode->GetObjectTM(t);
				Matrix3 itm = Inverse(tm);

				for (int k=0;k<ff.Count();k++)
					{
					if (ff[k]) 
						{
						ff[k]->DeleteThis();
						}

					ff[k] = NULL;
					}

				AddForceField();





				for (int j=0;j<nv;j++)
					{
					Point3 g(0.0f,0.0f,0.0f);
					g = GetForce(i, lmd->SpringList[j].pos, lmd->SpringList[j].vel, tm);
	
					Point3 p,force;
//					force = lmd->SpringList[j].pos-(tos.obj->GetPoint(j) * tm);
					force = lmd->SpringList[j].pos-(os->obj->GetPoint(j) * tm);

					lmd->SpringList[j].vel += g;
					lmd->SpringList[j].vel += ((-strength*force)-(dampening*(lmd->SpringList[j].vel)));

					lmd->SpringList[j].pos += lmd->SpringList[j].vel * per;

					}

				}


			}

		if (lmd->pointCache.Count() != os->obj->NumPoints())
			lmd->pointCache.SetCount(os->obj->NumPoints());
		for (i = 0; i < lmd->pointCache.Count(); i++)
			lmd->pointCache[i] = os->obj->GetPoint(i);
  
		if (t>=ReferenceFrame)
			{
			LagDeformer deformer(this,lmd);

			os->obj->Deform(&deformer, TRUE);
			}
		

		if ((inPaint) && (!painting))
			{
			if (os->obj->IsSubClassOf(triObjectClassID))
				{
				lmd->isMesh = TRUE;
				lmd->isPatch = FALSE;
				}
			else if (os->obj->IsSubClassOf(patchObjectClassID))
				{
				lmd->isMesh = FALSE;
				lmd->isPatch = TRUE;
				}


			else 

				{
//ask if can convert to mesh
				if (os->obj->CanConvertToType(triObjectClassID))
					{
					lmd->isMesh = TRUE;
					lmd->isPatch = FALSE;
					}
				else
					{
					lmd->isMesh = FALSE;
					lmd->isPatch = FALSE;
					}

				}
			}
		else if (!inPaint)
			{
			}
		}


	os->obj->UpdateValidity(GEOM_CHAN_NUM, LocalValidity(t));

//	os->obj->UpdateValidity(TOPO_CHAN_NUM, LocalValidity(t)); // Have to do this to get it to evaluate

	// Update our user interface parameter
	if (TestAFlag(A_RENDER)) 
		{
		aboutToRender = FALSE;

		}
	else aboutToRender = TRUE;

	}



#define ID_CHUNK 0x1000
#define NODE_CHUNK 0x1010

IOResult LagMod::SaveLocalData(ISave *isave, LocalModData *pld)
{
LagModData *p;
IOResult	res;
ULONG		nb;

p = (LagModData*)pld;

isave->BeginChunk(ID_CHUNK);
res = isave->Write(&p->id, sizeof(int), &nb);
isave->EndChunk();

ULONG id = isave->GetRefID(p->SelfNode);

isave->BeginChunk(NODE_CHUNK);
isave->Write(&id,sizeof(ULONG),&nb);
isave->EndChunk();



TempStorageClass tsc;
int ct = p->SpringList.Count();

isave->BeginChunk(POS_WEIGHT_CHUNK);
isave->Write(&ct, sizeof(ct), &nb);
for (int i =0;i<ct;i++)
		{
		tsc.pos = p->SpringList[i].init_pos;
		tsc.IVel = p->SpringList[i].InheritVel;
		tsc.sel = p->esel[i];
		tsc.modified = p->SpringList[i].modified;
		isave->Write(&tsc, sizeof(tsc), &nb);
		}

isave->EndChunk();



return IO_OK;
}

IOResult LagMod::LoadLocalData(ILoad *iload, LocalModData **pld)

{
	IOResult	res;
	ULONG		nb;
	LagModData *p= new LagModData();
	*pld = p;

//	lmdData.Append(1,&p,1);

	int id;
//	INode *n;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case ID_CHUNK:
				iload->Read(&id,sizeof(int), &nb);
				p->id = id;
				break;
			case NODE_CHUNK:
				ULONG id;
				iload->Read(&id,sizeof(ULONG), &nb);
				if (id!=0xffffffff)
					{
					iload->RecordBackpatch(id,(void**)&p->SelfNode);
					}
				break;

			case POS_WEIGHT_CHUNK:
				{
				Point3 Zero(0.0f,0.0f,0.0f);
			
//read in data
				int ct;
				iload->Read(&ct, sizeof(ct), &nb);
				p->SpringList.SetCount(ct);
				p->psel.ZeroCount();
				p->WholeFrameCache.SetCount(ct);
				p->esel.SetCount(ct);
				p->psel.SetCount(ct);
				p->wsel.SetCount(ct);
				for (int i=0;i<ct;i++)
					{
					TempStorageClass tsc;

					iload->Read(&tsc, sizeof(tsc), &nb);

					p->SpringList[i].pos = tsc.pos;
					p->SpringList[i].init_pos = tsc.pos;
					p->SpringList[i].vel = Zero;
					p->SpringList[i].InheritVel = tsc.IVel;
					p->SpringList[i].modified = tsc.modified;
					p->esel[i] = tsc.sel;
					p->psel[i] = 0;
					p->wsel[i] = 0;
				
					}
				break;

				}


			}
		iload->CloseChunk();
		if (res!=IO_OK) return res;
		}



return IO_OK;

}



/************************* scripter access stuff *****************************************/

#define get_lagdef_mod()																\
	Modifier *mod = arg_list[0]->to_modifier();										\
	Class_ID id = mod->ClassID();													\
	if ( id != Class_ID(LAZYID) )	\
		throw RuntimeError(GetString(IDS_PW_NOT_LAGDEF_ERROR), arg_list[0]);			\
	LagMod *lmod = (LagMod*)mod;			


// Maxscript stuff


//just returns the number of vertices in the system
def_struct_primitive( flexOps_getNumberVertices,flexOps, "GetNumberVertices" );
//SelectVertices number/array/bitarray
//selects the vertices specified
def_struct_primitive (flexOps_selectVerts, flexOps,			"SelectVertices" );
//GetVertexWeightCount vertexid
//returns the inlfuence of that vertex
def_struct_primitive (flexOps_getVertexWeight,flexOps,		"GetVertexWeight" );
//SetVertexWeights VerticesID  Weights
//assigns an array of vertices to an array of weights
//VerticesID and Weights can be arrays or just numbers but if they are arrays they need to be the same length
def_struct_primitive (flexOps_setVertWeights,flexOps,		"SetVertexWeights" );

//isVertexEdge vertid
//return is a vertex is an edge edge 
def_struct_primitive (flexOps_isVertEdge,flexOps,		"isEdgeVertex" );
//SetVertexEdges vertidlist
//sets the vertices to edge vertices
def_struct_primitive (flexOps_setVertEdges,flexOps,	"SetEdgeVertices" );
//ClearVertexEdges vertidlist
//clears the vertices to edge vertices
def_struct_primitive (flexOps_clearVertEdges,flexOps,	"ClearEdgeVertices" );




Value*
flexOps_getNumberVertices_cf(Value** arg_list, int count)
{
	check_arg_count(getNumberVertices, 1, count);
	get_lagdef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !lmod->ip ) throw RuntimeError(GetString(IDS_PW_LAG_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	lmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	int ct = 0;
	if (objects != 0)
		{
		LagModData *lmd = (LagModData*)mcList[0]->localData;
		ct = lmd->SpringList.Count();
		}
	return Integer::intern(ct);	
}


Value*
flexOps_selectVerts_cf(Value** arg_list, int count)
{
	check_arg_count(selectVerts, 2, count);
	get_lagdef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !lmod->ip ) throw RuntimeError(GetString(IDS_PW_LAG_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	lmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	int ct = 0;
	Value* ival = arg_list[1];

//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		LagModData *lmd = (LagModData*)mcList[0]->localData;
		for (int i = 0; i < lmd->wsel.Count(); i++)
			lmd->wsel[i] = 0;

		int index;
		if (is_number(ival))   // single index
			{
			index = ival->to_int()-1;
			if ((index <0) || (index >= lmd->wsel.Count()) )
				throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
			else lmd->wsel[index] = 1;
			}

		else if (is_array(ival))   // array of indexes
			{
			Array* aval = (Array*)ival;
			for (int i = 0; i < aval->size; i++)
				{
				ival = aval->data[i];
				if (is_number(ival))   // single index
					{
					index = ival->to_int()-1;
					if ((index <0) || (index >= lmd->wsel.Count()))
						throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
					else lmd->wsel[index] = 1;

					}
				}

			}
		else if (is_BitArrayValue(ival))   // array of indexes
			{
			BitArrayValue *list = (BitArrayValue *) ival;
			for (int index = 0; index < list->bits.GetSize(); index++)
				{
				if (list->bits[index])
					{
					if ((index <0) || (index >= lmd->wsel.Count()))
						throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
					else lmd->wsel[index] = 1;
					}
				}

			}



		}

	lmod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
	lmod->ip->RedrawViews(lmod->ip->GetTime());


	return &ok;	
}


Value*
flexOps_getVertexWeight_cf(Value** arg_list, int count)
{
	check_arg_count(getVertexWeight, 2, count);
	get_lagdef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !lmod->ip ) throw RuntimeError(GetString(IDS_PW_LAG_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	lmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	float w = 0;
	Value* ival = arg_list[1];

	if (objects != 0)
		{
		LagModData *lmd = (LagModData*)mcList[0]->localData;
		int index;
		if (is_number(ival))   // single index
			{
			index = ival->to_int()-1;
			if ((index <0) || (index >= lmd->SpringList.Count()) )
				throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
			else w =1.0f - lmd->SpringList[index].InheritVel;
			}

		}
	return Float::intern(w);	





}


Value*
flexOps_setVertWeights_cf(Value** arg_list, int count)
{
	check_arg_count(setVertWeights, 3, count);
	get_lagdef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !lmod->ip ) throw RuntimeError(GetString(IDS_PW_LAG_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	lmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	int ct = 0;

	Value* vertsval = arg_list[1];
	Value* weightsval = arg_list[2];



//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		LagModData *lmd = (LagModData*)mcList[0]->localData;
//		if (vertID >= bmd->VertexData.Count() ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);

		if (is_number(weightsval) && is_number(vertsval))  // single index
			{
			int vertID = vertsval->to_int()-1;
			float weight = weightsval->to_float();
			weight = 1.0f-weight;
			if (weight < 0.0f ) weight = 0.0f;
			if (weight > 1.0f ) weight = 1.0f;
			if (vertID >= lmd->SpringList.Count()) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
			lmd->SpringList[vertID].InheritVel = weight;
			lmd->SpringList[vertID].modified = TRUE;
			}

		else if (is_array(weightsval) && is_array(vertsval))   // array of indexes
			{

			Array* wval = (Array*)weightsval;
			Array* vval = (Array*)vertsval;
			if (wval->size != vval->size) throw RuntimeError(GetString(IDS_PW_ERROR_COUNT), arg_list[0]);

			for (int i = 0; i < wval->size; i++)
				{
				Value *vertval = vval->data[i];
				Value *weightval = wval->data[i];
				if ( (is_number(vertval)) && (is_number(weightval)))  // single index
					{
					int vertID = vertval->to_int()-1;
					float weight = weightval->to_float();
					weight = 1.0f - weight;
					if (weight < 0.0f ) weight = 0.0f;
					if (weight > 1.0f ) weight = 1.0f;

					if (vertID >= lmd->SpringList.Count()) throw RuntimeError(GetString(IDS_PW_ERROR_COUNT), arg_list[0]);
					lmd->SpringList[vertID].InheritVel = weight;
					lmd->SpringList[vertID].modified = TRUE;

					}
				}


			}



		}
	lmod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
	lmod->ip->RedrawViews(lmod->ip->GetTime());


	return &ok;	
}


Value*
flexOps_isVertEdge_cf(Value** arg_list, int count)
{
	check_arg_count(isVertEdge, 2, count);
	get_lagdef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !lmod->ip ) throw RuntimeError(GetString(IDS_PW_LAG_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	lmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	int ct = 0;
	Value* vertsval = arg_list[1];

	if (objects != 0)
		{

		LagModData *lmd = (LagModData*)mcList[0]->localData;
		if (is_number(vertsval))  // single index
			{
			int vertID = vertsval->to_int()-1;
			ct = lmd->esel[vertID];
			}
		}
	return Integer::intern(ct);	
}


Value*
flexOps_setVertEdges_cf(Value** arg_list, int count)
{
	check_arg_count(setVertEdges, 2, count);
	get_lagdef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !lmod->ip ) throw RuntimeError(GetString(IDS_PW_LAG_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	lmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	int ct = 0;

	Value* vertsval = arg_list[1];



//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		LagModData *lmd = (LagModData*)mcList[0]->localData;
//		if (vertID >= bmd->VertexData.Count() ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);

		if (is_number(vertsval))  // single index
			{
			int vertID = vertsval->to_int()-1;
			if (vertID >= lmd->SpringList.Count()) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
			lmd->esel[vertID] = 1;
			}

		else if (is_array(vertsval))   // array of indexes
			{

			Array* vval = (Array*)vertsval;

			for (int i = 0; i < vval->size; i++)
				{
				Value *vertval = vval->data[i];
				if ( (is_number(vertval)) )  // single index
					{
					int vertID = vertval->to_int()-1;
					if (vertID >= lmd->SpringList.Count()) throw RuntimeError(GetString(IDS_PW_ERROR_COUNT), arg_list[0]);
					lmd->esel[vertID] = 1;

					}
				}


			}



		}
	lmod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
	lmod->ip->RedrawViews(lmod->ip->GetTime());


	return &ok;	
}

Value*
flexOps_clearVertEdges_cf(Value** arg_list, int count)
{
	check_arg_count(clearVertEdges, 2, count);
	get_lagdef_mod();
//get first mod context not sure how this will work if multiple instanced are selected
//maybe should use COREinterface instead of local interface ????
	if ( !lmod->ip ) throw RuntimeError(GetString(IDS_PW_LAG_NOT_SELECTED), arg_list[0]);

	ModContextList mcList;		
	INodeTab nodes;

	lmod->ip->GetModContexts(mcList,nodes);
	int objects = mcList.Count();
	int ct = 0;

	Value* vertsval = arg_list[1];



//	BitArray selList = arg_list[1]->to_bitarray();
	if (objects != 0)
		{
		LagModData *lmd = (LagModData*)mcList[0]->localData;
//		if (vertID >= bmd->VertexData.Count() ) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);

		if (is_number(vertsval))  // single index
			{
			int vertID = vertsval->to_int()-1;
			if (vertID >= lmd->SpringList.Count()) throw RuntimeError(GetString(IDS_PW_EXCEEDED_VERTEX_COUNT), arg_list[0]);
			lmd->esel[vertID] = 0;
			}

		else if (is_array(vertsval))   // array of indexes
			{

			Array* vval = (Array*)vertsval;

			for (int i = 0; i < vval->size; i++)
				{
				Value *vertval = vval->data[i];
				if ( (is_number(vertval)) )  // single index
					{
					int vertID = vertval->to_int()-1;
					if (vertID >= lmd->SpringList.Count()) throw RuntimeError(GetString(IDS_PW_ERROR_COUNT), arg_list[0]);
					lmd->esel[vertID] = 0;

					}
				}


			}



		}
	lmod->NotifyDependents(FOREVER, GEOM_CHANNEL, REFMSG_CHANGE);
	lmod->ip->RedrawViews(lmod->ip->GetTime());


	return &ok;	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\BonesDef\MODS.CPP ===
/**********************************************************************
 *<
	FILE: mods.cpp

	DESCRIPTION:   DLL implementation of modifiers

	CREATED BY: Peter Watje

	HISTORY: 8/14/98

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "buildver.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

#ifdef OLD3DCONTROLS
		// initialize 3D controls
		Ctl3dRegister(hinstDLL);
		Ctl3dAutoSubclass(hinstDLL);
#endif
		
		// initialize Chicago controls
		InitCommonControls();
		}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return _T("Bones modifier (Kinetix)"); }


#ifndef DESIGN_VER

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 1;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetBonesDefModDesc();
		default: return 0;
		}

	}

#else

//
// DESIGN VERSION EXCLUDES SOME PLUG_INS
//

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 1;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetBonesDefModDesc();
		default: return 0;
		}

	}

#endif



// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

BOOL CALLBACK DefaultSOTProc(
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	IObjParam *ip = (IObjParam*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			if (ip) ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			return FALSE;

		default:
			return FALSE;
		}
	return TRUE;
	}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Flex\MODS.CPP ===
/**********************************************************************
 *<
	FILE: mods.cpp

	DESCRIPTION:   DLL implementation of modifiers

	CREATED BY: Peter Watje

	HISTORY: 8/13/98

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "buildver.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

#ifdef OLD3DCONTROLS
		// initialize 3D controls
		Ctl3dRegister(hinstDLL);
		Ctl3dAutoSubclass(hinstDLL);
#endif
		
		// initialize Chicago controls
		InitCommonControls();
		}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return _T("Flex modifier (Kinetix)"); }


#ifndef DESIGN_VER

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 1;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetLagModDesc();
		default: return 0;
		}

	}

#else

//
// DESIGN VERSION EXCLUDES SOME PLUG_INS
//

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 1;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetLagModDesc();
		default: return 0;
		}

	}

#endif



// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

BOOL CALLBACK DefaultSOTProc(
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	IObjParam *ip = (IObjParam*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			if (ip) ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			return FALSE;

		default:
			return FALSE;
		}
	return TRUE;
	}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Flex\MODS.H ===
/**********************************************************************
 *<
	FILE: mods.h

	DESCRIPTION:

	CREATED BY: Rolf Berteig (based on prim.h)

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __MODS__H
#define __MODS__H

#include "Max.h"
//#include "reslib.h"
#include "modsres.h"


TCHAR *GetString(int id);

#define EDITMESH_CLASS_ID			0x00050
#define EDITSPLINE_CLASS_ID			0x00060
#define EDITPATCH_CLASS_ID			0x00070
#define EDITLOFT_CLASS_ID			0x00080

#define CLUSTOSM_CLASS_ID			0x25215824

#define RESET_XFORM_CLASS_ID		0x8d562b81
#define CLUSTNODEOSM_CLASS_ID		0xc4d33

extern ClassDesc* GetLagModDesc();
// in mods.cpp
extern HINSTANCE hInstance;

// For 'Supports Object of Type' rollups
extern BOOL CALLBACK DefaultSOTProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

#define BIGFLOAT	float(999999)

#define NEWSWMCAT	_T("Modifiers")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\BonesDef\RightClickMenu.cpp ===
/**********************************************************************
 
	FILE: RightClickMenu.cpp

	DESCRIPTION:  Right Click menu stuff

	CREATED BY: Peter Watje

	HISTORY: 8/5/98




 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm.h"
#include "shape.h"
#include "spline3d.h"
#include "splshape.h"
#include "linshape.h"

// This uses the linked-list class templates
#include "linklist.h"
#include "bonesdef.h"


void BonesRightMenu::Init(RightClickMenuManager* manager, HWND hWnd, IPoint2 m) {
		
		int flags1,flags2,flags3,flags4,flags5,flags6,flags7,flags8,flags9,flags10;
		int flags11, flags12;

		flags1 = flags2 = flags3 = flags4 = flags5 = flags6 = flags7 = MF_STRING | MF_UNCHECKED;
		flags8 = flags1;
		flags9 = flags1;
		flags10 = flags1;
		flags11 = flags1;
		flags12 = flags1;

		if (ep->FilterVertices  == 0)
			flags2 |= MF_CHECKED;
		if (ep->FilterBones  == 0)
			flags3 |= MF_CHECKED;
		if (ep->FilterEnvelopes  == 0)
			flags4 |= MF_CHECKED;
		if (ep->DrawEnvelopes  == 1)
			flags5 |= MF_CHECKED;
		if (ep->DrawVertices  == 1)
			flags7 |= MF_CHECKED;
		if (ep->ip->GetSubObjectLevel() == 1)
			flags10 |= MF_CHECKED;

		
		manager->AddMenu(this, MF_SEPARATOR, 0, NULL);
		manager->AddMenu(this, flags10, 9, GetString(IDS_PW_EDIT_ENVELOPE));
		manager->AddMenu(this, MF_SEPARATOR, 0, NULL);
		manager->AddMenu(this, flags2, 1, GetString(IDS_PW_FILTERVERTICES));
		manager->AddMenu(this, flags3, 2, GetString(IDS_PW_FILTERBONES));
		manager->AddMenu(this, flags4, 3, GetString(IDS_PW_FILTERENVELOPES));
		manager->AddMenu(this, MF_SEPARATOR, 0, NULL);
		manager->AddMenu(this, flags5, 4, GetString(IDS_PW_DRAWALLENVELOPES));
		manager->AddMenu(this, flags7, 6, GetString(IDS_PW_COLORVERTS));
		manager->AddMenu(this, MF_SEPARATOR, 0, NULL);

		}
	

void BonesRightMenu::Selected(UINT id) {
//  Add Cross Section
	if (id ==  0)
		{
		ep->StartCrossSectionMode(0);
		}
//  Remove Cross Section
	else if (id ==  5)
		{
		ep->RemoveCrossSection();
		ep->ip->RedrawViews(ep->ip->GetTime());
		}
	else if (id ==  1)
		{
//		ep->FilterVertices  = !ep->FilterVertices;
		ep->pblock_param->SetValue(PB_FILTER_VERTICES,0,ep->FilterVertices);
		ep->FilterVertices = !ep->FilterVertices;

//		ep->ClearVertexSelections();
		}
	else if (id ==  2)
		{
//		ep->FilterBones  = !ep->FilterBones;
		ep->pblock_param->SetValue(PB_FILTER_BONES,0,ep->FilterBones);
		ep->FilterBones  = !ep->FilterBones;

		ep->ClearBoneEndPointSelections();

		}
	else if (id ==  3)
		{
//		ep->FilterEnvelopes  = !ep->FilterEnvelopes;
		ep->pblock_param->SetValue(PB_FILTER_ENVELOPES,0,ep->FilterEnvelopes);
		ep->FilterEnvelopes  = !ep->FilterEnvelopes;
		ep->ClearEnvelopeSelections();

		}	
	else if (id ==  4)
		{
		ep->DrawEnvelopes  = !ep->DrawEnvelopes;
		ep->pblock_param->SetValue(PB_DRAW_ENVELOPES,0,ep->DrawEnvelopes);
		ep->ip->RedrawViews(ep->ip->GetTime());
		}
	else if (id ==  6)
		{
		ep->DrawVertices  = !ep->DrawVertices;
		ep->pblock_param->SetValue(PB_DRAW_VERTICES,0,ep->DrawVertices);
		ep->ip->RedrawViews(ep->ip->GetTime());

		}
	else if (id ==  7)
		{
		ep->ip->DoHitByNameDialog(new DumpHitDialog(ep));
		}	
	else if (id == 9)
		{
		if (ep->ip->GetSubObjectLevel() == 1)
			ep->ip->SetSubObjectLevel(0);
		else ep->ip->SetSubObjectLevel(1);	


		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Flex\modsres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mods.rc
//
#define IDD_BENDPARAM                   101
#define IDC_TH_SELCURSOR                101
#define IDD_TAPERPARAM                  102
#define IDC_EXTRUDECUR                  102
#define IDD_SINWAVEPARAM                103
#define IDD_SINWAVEPARAM1               103
#define IDB_FACESELTYPES                103
#define IDC_CLOSECUR                    103
#define IDC_OUTLINECUR                  103
#define IDD_SINWAVEPARAM2               104
#define IDB_MASK_FACESELTYPES           104
#define IDC_SEGBREAKCUR                 104
#define IDD_SINWAVEMODPARAM             105
#define IDC_SEGREFINECUR                105
#define IDD_EDITMESHPARAM               106
#define IDD_EMPARAM_VERTEX              106
#define IDC_VERTCONNECTCUR              106
#define IDD_EMPARAM_FACE                107
#define IDC_VERTINSERTCUR               107
#define IDD_EMPARAM_EDGE                108
#define IDD_DETACH                      109
#define IDB_BOOLEANTYPES                110
#define IDD_EMPARAM_OBJECT              111
#define IDB_MASK_BOOLEANTYPES           111
#define IDD_ESPARAM_VERTEX              112
#define IDD_ESPARAM_OBJECT              113
#define IDD_ESPARAM_SEGMENT             114
#define IDD_ESPARAM_SPLINE              115
#define IDD_AUTHMSG                     116
#define IDD_AUTHORIZE                   117
#define IDB_MASK_BULBS                  117
#define IDD_TWISTPARAM                  118
#define IDB_BULBS                       118
#define IDD_ESPARAM_POLYGON             119
#define IDC_ADDVERTCUR                  119
#define IDB_MASK_MIRRORTYPES            119
#define IDD_EXTRUDEPARAM                120
#define IDB_MIRRORTYPES                 120
#define IDD_EPPARAM_VERTEX              121
#define IDD_EPPARAM_PATCH               122
#define IDD_EPPARAM_OBJECT              123
#define IDD_BOMBPARAMS                  124
#define IDD_ELPARAM_OBJECT              125
#define IDD_ELPARAM_PATH                126
#define IDD_ELPARAM_SECTION             127
#define IDD_AFFECTREGION                128
#define IDD_SKEWPARAM                   129
#define IDD_NOISEPARAM                  130
#define IDD_SINWAVEOMODPARAM            131
#define IDD_LINWAVEPARAM1               132
#define IDD_LINWAVEOMODPARAM            133
#define IDD_OPTIMIZEPARAM               134
#define IDD_DISPLACEPARAM               135
#define IDD_CLUSTNODEPARAM              136
#define IDD_EM_SELECTBYMAT              137
#define IDD_WINDPARAM                   138
#define IDD_GRAVITYPARAM                139
#define IDD_DEFLECTORPARAM              140
#define IDD_UVWMAPPARAM                 141
#define IDD_EMPARAM_SURFACE             142
#define IDD_EM_SELECTBYSMOOTH           143
#define IDD_DISPLACE_SOT                144
#define IDD_WINDRAIN_SOT                145
#define IDD_SINWAVE_SOT                 146
#define IDD_BOMB_SOT                    147
#define IDD_SELECTPARAM                 148
#define IDD_MATERIALPARAM               149
#define IDD_SMOOTHPARAM                 150
#define IDD_NORMALPARAM                 151
#define IDD_SURFREVPARAM                152
#define IDD_EPPARAM_EDGE                153
#define IDD_DISPLACEPARAM_WS            154
#define IDD_UNWRAP_FLOATER              155
#define IDB_UNWRAPTOOL                  156
#define IDB_MASK_UNWRAPTOOL             157
#define IDD_UNWRAP_PROP                 157
#define IDD_MAP_ACQUIRE                 201
#define IDD_RESETXFORM_PANEL            202
#define IDD_AFRPARAM                    203
#define IDD_LAGPARAM                    203
#define IDD_TESSPARAM                   204
#define IDD_MESHSEL_FACE                205
#define IDD_MESHSEL_VERTEX              206
#define IDD_MESHSEL_EDGE                207
#define IDD_MESHSEL_OBJECT              208
#define IDD_FACEEXTRUDEPARAM            209
#define IDD_UVWXFORMPARAM               210
#define IDD_MIRRORPARAM                 211
#define IDD_UNWRAP_PARAMS               212
#define IDD_PASTE_NAMEDSET              213
#define IDD_SEL_NAMEDSET                214
#define IDC_ANGLE                       1000
#define IDC_X                           1001
#define IDC_PHASE                       1001
#define IDC_Y                           1002
#define IDC_Z                           1003
#define IDC_RADIUS                      1004
#define IDC_DIR                         1004
#define IDC_TWIST_BIAS                  1004
#define IDC_ANGLESPINNER                1005
#define IDC_MODNOISE_SEED               1005
#define IDC_RADSPINNER                  1006
#define IDC_DIRSPINNER                  1006
#define IDC_TWIST_BIASSPIN              1006
#define IDC_CRV                         1007
#define IDC_PHASESPINNER                1007
#define IDC_MODNOISE_SEEDSPIN           1007
#define IDC_OPT_BIAS                    1007
#define IDC_DISP_UTILE                  1007
#define IDC_NS_LIST                     1007
#define IDC_AMT                         1008
#define IDC_DECAYSPINNER                1008
#define IDC_MODNOISE_ROUGHNESS          1008
#define IDC_OPT_BIASSPIN                1008
#define IDC_DISP_UTILESPIN              1008
#define IDC_SET_NAME                    1008
#define IDC_AMTSPINNER                  1009
#define IDC_DECAY                       1009
#define IDC_MODNOISE_ROUGHNESSSPIN      1009
#define IDC_DISP_VTILE                  1009
#define IDC_OPT_MAXEDGE                 1009
#define IDC_CRVSPINNER                  1010
#define IDC_MODNOISE_ITERATIONS         1010
#define IDC_DISP_VTILESPIN              1010
#define IDC_OPT_MAXEDGESPIN             1010
#define IDC_AMPLITUDE                   1011
#define IDC_TAPER_FROM                  1011
#define IDC_MODNOISE_ITERATIONSSPIN     1011
#define IDC_DISP_STRENGTH               1011
#define IDC_AMPSPINNER                  1012
#define IDC_TAPER_TO                    1012
#define IDC_DISP_STRENGTHSPIN           1012
#define IDC_WAVELEN                     1013
#define IDC_TAPER_FROMSPIN              1013
#define IDC_DISP_DECAY                  1013
#define IDC_WAVELENSPINNER              1014
#define IDC_TAPER_TOSPIN                1014
#define IDC_DISP_DECAYSPIN              1014
#define IDC_CIRCLES                     1015
#define IDC_DISP_BLUR                   1015
#define IDC_CIRCLESSPINNER              1016
#define IDC_DISP_BLURSPIN               1016
#define IDC_SEGS                        1017
#define IDC_DISP_CENTERL                1017
#define IDC_SEGSPINNER                  1018
#define IDC_DISP_CENTERLSPIN            1018
#define IDC_DIVISIONS                   1019
#define IDC_DIVSPINNER                  1020
#define IDC_FLEX                        1021
#define IDC_STRENGTH                    1021
#define IDC_AMPSPINNER2                 1021
#define IDC_FLEXSPINNER                 1022
#define IDC_STRENGTHSPIN                1022
#define IDC_AMPLITUDE2                  1022
#define IDC_AUTHORIZE                   1023
#define IDC_GRAVITYSPIN                 1023
#define IDC_LOCKID                      1024
#define IDC_GRAVITY                     1024
#define IDC_EDIT2                       1025
#define IDC_DETONATIONSPIN              1025
#define IDC_DETACH                      1026
#define IDC_DETONATION                  1026
#define IDC_TESSELLATE                  1027
#define IDC_BOMB_CHAOSSPIN              1027
#define IDC_AFFECTREGION                1028
#define IDC_EXPLODE                     1028
#define IDC_BOMB_CHAOS                  1028
#define IDC_BACKFACE_VERTS              1029
#define IDC_WELDTHRESH                  1030
#define IDC_THRESHSPINNER               1031
#define IDC_EXTRUDEAMOUNT               1033
#define IDC_EXTRUDESPINNER              1034
#define IDC_PLANARSPINNER               1035
#define IDC_SMOOTH_THRESHSPIN           1035
#define IDC_TES_EDGE                    1036
#define IDC_SMOOTH_THRESH               1036
#define IDC_TES_CENTER                  1037
#define IDC_NORMAL_SCALESPIN            1037
#define IDC_TENSIONSPINNER              1038
#define IDC_NORMAL_SCALE                1038
#define IDC_TENSION                     1039
#define IDC_MAT_IDSPIN                  1039
#define IDC_EXTRUDE                     1040
#define IDC_MAT_ID                      1040
#define IDC_WELD                        1041
#define IDC_PLANAR                      1041
#define IDC_COLLAPSE                    1042
#define IDC_EDITCURVE                   1042
#define IDC_INSERT                      1042
#define IDC_Break                       1043
#define IDC_VERTBREAK                   1043
#define IDC_LEVEL                       1043
#define IDC_MAKEPLANAR                  1043
#define IDC_REFINE                      1044
#define IDC_LEVELSPINNER                1044
#define IDC_BUILDFACE                   1044
#define IDC_MAKEFIRST                   1044
#define IDC_SELTYPE                     1045
#define IDC_VERTREFINE                  1045
#define IDC_TES_FACE_TRI                1045
#define IDC_CLOSE                       1046
#define IDC_ANGLETHRESHSPIN             1046
#define IDC_OUTLINE                     1047
#define IDC_ANGLETRESH                  1047
#define IDC_TES_FACE_POLY               1047
#define IDC_BOOLEAN                     1048
#define IDC_DELETEFACE                  1048
#define IDC_OUTCENTER                   1049
#define IDC_FACE_HIDE                   1049
#define IDC_DETACHCOPY                  1050
#define IDC_CONNECT                     1050
#define IDC_FACE_UNHIDEALL              1050
#define IDC_SEGBREAK                    1051
#define IDC_DELETE                      1051
#define IDC_DELETESPLINE                1051
#define IDC_ATTACH                      1052
#define IDC_SEGDELETE                   1052
#define IDC_ATTACHCUR                   1052
#define IDC_MIRROR                      1052
#define IDC_OUTLINEWIDTH                1053
#define IDC_CREATELINE                  1053
#define IDC_OUTLINESPINNER              1054
#define IDC_DETACH_NAME                 1055
#define IDC_ALIGNLEFT                   1055
#define IDC_ALIGNMIN                    1055
#define IDC_MIRRORCOPY                  1055
#define IDC_RETAIN_ORIENT               1056
#define IDC_GETSHAPE                    1056
#define IDC_CONST_ORIENT                1057
#define IDC_LOCK_HANDLES                1057
#define IDC_LOCKALIKE                   1058
#define IDC_ALIGNCENTER                 1058
#define IDC_LOCKALL                     1059
#define IDC_BOOLTYPE                    1059
#define IDC_ALIGNRIGHT                  1059
#define IDC_ALIGNMAX                    1059
#define IDC_ATTACHREORIENT              1060
#define IDC_MIRRORTYPE                  1060
#define IDC_DETACHREORIENT              1061
#define IDC_VERTDELETE                  1062
#define IDC_AMOUNT                      1063
#define IDC_AMOUNTSPINNER               1064
#define IDC_SMOOTH_GRP1                 1064
#define IDC_SEGMENTSPINNER              1065
#define IDC_SMOOTH_GRP2                 1065
#define IDC_ADDTRI                      1065
#define IDC_SEGMENTS                    1066
#define IDC_SMOOTH_GRP3                 1066
#define IDC_ADDQUAD                     1066
#define IDC_CAPSTART                    1067
#define IDC_SMOOTH_GRP4                 1067
#define IDC_CAPEND                      1068
#define IDC_SMOOTH_GRP5                 1068
#define IDC_SMOOTH_GRP6                 1069
#define IDC_SECDELETE                   1070
#define IDC_SMOOTH_GRP7                 1070
#define IDC_SHAPESTEPS                  1070
#define IDC_GETPATH                     1071
#define IDC_SECALIGN                    1071
#define IDC_SMOOTH_GRP8                 1071
#define IDC_SECCENTER                   1072
#define IDC_SMOOTH_GRP9                 1072
#define IDC_ALIGNTYPES                  1073
#define IDC_SMOOTH_GRP10                1073
#define IDC_SMOOTH_GRP11                1074
#define IDC_VERT_DELETE                 1075
#define IDC_SMOOTH_GRP12                1075
#define IDC_VERT_CREATE                 1076
#define IDC_SMOOTH_GRP13                1076
#define IDC_EXP_OBJECTS                 1077
#define IDC_VERT_COLLAPSE               1077
#define IDC_SMOOTH_GRP14                1077
#define IDC_EXP_ELEMENTS                1078
#define IDC_SMOOTH_GRP15                1078
#define IDC_VERT_DETACH                 1078
#define IDC_OBJ_ATTACH                  1079
#define IDC_SMOOTH_GRP16                1079
#define IDC_EDGE_DIVIDE                 1080
#define IDC_SMOOTH_GRP17                1080
#define IDC_EDGE_TURN                   1081
#define IDC_VERT_WELD                   1081
#define IDC_SMOOTH_GRP18                1081
#define IDC_EDGE_VIS                    1082
#define IDC_SMOOTH_GRP19                1082
#define IDC_VERT_WELDTOVERT             1082
#define IDC_EDGE_INVIS                  1083
#define IDC_SMOOTH_GRP20                1083
#define IDC_EDGE_AUTO                   1084
#define IDC_WELDTHRESHSPIN              1084
#define IDC_SMOOTH_GRP21                1084
#define IDC_EDGE_DELETE                 1085
#define IDC_FACE_DETACH                 1085
#define IDC_SMOOTH_GRP22                1085
#define IDC_EDGE_COLLAPSE               1086
#define IDC_FALLOFF                     1086
#define IDC_SMOOTH_GRP23                1086
#define IDC_FALLOFFSPIN                 1087
#define IDC_SMOOTH_GRP24                1087
#define IDC_EDGE_COPYNS                 1087
#define IDC_PINCHSPIN                   1088
#define IDC_SMOOTH_GRP25                1088
#define IDC_EDGE_PASTENS                1088
#define IDC_PINCH                       1089
#define IDC_SMOOTH_GRP26                1089
#define IDC_BUBBLESPIN                  1090
#define IDC_SMOOTH_GRP27                1090
#define IDC_BUBBLE                      1091
#define IDC_SMOOTH_GRP28                1091
#define IDC_NEARLABEL                   1092
#define IDC_SMOOTH_GRP29                1092
#define IDC_FARLEFTLABEL                1093
#define IDC_SMOOTH_GRP30                1093
#define IDC_FARRIGHTLABEL               1094
#define IDC_SMOOTH_GRP31                1094
#define IDC_AR_GRAPH                    1095
#define IDC_SMOOTH_GRP32                1095
#define IDC_TENSTEXT                    1096
#define IDC_TAPER_AFFECTREGION          1098
#define IDC_EFFECT_X                    1104
#define IDC_EFFECT_Y                    1105
#define IDC_EFFECT_BOTH                 1106
#define IDC_TAPER_SYMMETRY              1107
#define IDC_BEND_AFFECTREGION           1108
#define IDC_BEND_TO                     1109
#define IDC_BEND_TOSPIN                 1110
#define IDC_BEND_FROM                   1111
#define IDC_BEND_FROMSPIN               1112
#define IDC_TWIST_AFFECTREGION          1113
#define IDC_MODNOISE_FRACTAL            1113
#define IDC_TWIST_TO                    1114
#define IDC_MODNOISE_ANIMATE            1114
#define IDC_TWIST_TOSPIN                1115
#define IDC_TWIST_FROM                  1116
#define IDC_TWIST_FROMSPIN              1117
#define IDC_SKEW_AMOUNT                 1118
#define IDC_SKEW_AMOUNTSPIN             1119
#define IDC_SKEW_AFFECTREGION           1120
#define IDC_SKEW_TO                     1121
#define IDC_SKEW_TOSPIN                 1122
#define IDC_SKEW_FROM                   1123
#define IDC_SKEW_FROMSPIN               1124
#define IDC_MODNOISE_XSTRENGTH          1127
#define IDC_MODNOISE_XSTRENGTHSPIN      1128
#define IDC_MODNOISE_YSTRENGTH          1129
#define IDC_MODNOISE_YSTRENGTHSPIN      1130
#define IDC_MODNOISE_ZSTRENGTH          1131
#define IDC_MODNOISE_ZSTRENGTHSPIN      1132
#define IDC_MODNOISE_SCALE              1133
#define IDC_MODNOISE_SCALESPIN          1134
#define IDC_MODNOISE_ROUGHNESSLABEL     1135
#define IDC_MODNOISE_FREQ               1136
#define IDC_OPT_PRESERVEMAT             1136
#define IDC_MODNOISE_FREQSPIN           1137
#define IDC_OPT_RENDERL1                1137
#define IDC_OPT_RENDERL2                1138
#define IDC_MODNOISE_PHASE              1138
#define IDC_OPT_VIEWSL1                 1139
#define IDC_MODNOISE_PHASESPIN          1139
#define IDC_OPT_VIEWSL2                 1140
#define IDC_MODNOISE_ITERATIONSLABEL    1140
#define IDC_OPT_FACETHRESH              1141
#define IDC_OPT_FACETHRESHSPIN          1142
#define IDC_OPT_EDGETHRESH              1143
#define IDC_OPT_EDGETHRESHSPIN          1144
#define IDC_OPT_PRESERVESMOOTH          1145
#define IDC_OPT_AUTOEDGE                1146
#define IDC_OPT_VERTCOUNT               1147
#define IDC_OPT_FACECOUNT               1148
#define IDC_DISP_PLANAR                 1149
#define IDC_DISP_CYL                    1150
#define IDC_DISP_SPHERE                 1151
#define IDC_DISP_USEMAP                 1152
#define IDC_DISP_APPLYMAP               1153
#define IDC_DISP_CENTERLUM              1154
#define IDC_DISP_PICKIMAGE              1155
#define IDC_DISP_REMOVEIMAGE            1156
#define IDC_CLUST_PICKNODE              1157
#define IDC_DISP_PICKMAP                1157
#define IDC_GRAVITY_PICKNODE            1157
#define IDC_CLUST_NODENAME              1158
#define IDC_DISP_REMOVEMAP              1158
#define IDC_PAINT                       1158
#define IDC_DISPLENGTH                  1161
#define IDC_DISPLENGTHSPIN              1162
#define IDC_WIND_STRENGTH               1163
#define IDC_WIND_STRENGTHSPIN           1164
#define IDC_FORCE_PLANAR                1165
#define IDC_FORCE_SPHERICAL             1166
#define IDC_WIND_DECAYSPIN              1167
#define IDC_WIND_DECAY                  1168
#define IDC_WIND_TURBSPIN               1169
#define IDC_WIND_TURB                   1170
#define IDC_GRAV_STRENGTH               1171
#define IDC_WIND_FREQSPIN               1171
#define IDC_GRAV_STRENGTHSPIN           1172
#define IDC_WIND_FREQ                   1172
#define IDC_GRAV_DECAY                  1173
#define IDC_WIND_SCALESPIN              1173
#define IDC_GRAV_DECAYSPIN              1174
#define IDC_WIND_SCALE                  1174
#define IDC_DEFLECT_BOUNCE              1175
#define IDC_DEFLECT_BOUNCESPIN          1176
#define IDC_DEFLECT_WIDTH               1177
#define IDC_DEFLECT_WIDTHSPIN           1178
#define IDC_DEFLECT_HEIGHTSPIN          1179
#define IDC_MAP_PLANAR                  1179
#define IDC_DEFLECT_HEIGHT              1180
#define IDC_MAP_CYL                     1180
#define IDC_MAP_SPHERE                  1181
#define IDC_MAP_BALL                    1182
#define IDC_MAP_FIT                     1183
#define IDC_MAP_CENTER                  1184
#define IDC_MAP_VIEWALIGN               1185
#define IDC_MAP_NORMALALIGN             1186
#define IDC_MAP_BOX                     1187
#define IDC_MAP_FITREGION               1188
#define IDC_MAP_BITMAPFIT               1189
#define IDC_MAP_UFLIP                   1190
#define IDC_MAP_VFLIP                   1191
#define IDC_MAP_UTILESPIN               1192
#define IDC_MAP_VTILESPIN               1193
#define IDC_MAP_VTILE                   1194
#define IDC_MAP_UTILE                   1195
#define IDC_MAP_WTILE                   1196
#define IDC_SMOOTH_AUTO                 1196
#define IDC_MAP_WTILESPIN               1197
#define IDC_NORMAL_FLIP                 1197
#define IDC_MAP_WFLIP                   1198
#define IDC_NORMAL_UNIFY                1198
#define IDC_NORMAL_SHOW                 1199
#define IDC_MAP_UOFFSET                 1199
#define IDC_MAP_RESET2                  1199
#define IDC_MAP_RESET                   1199
#define IDC_SELECT_BYID                 1200
#define IDC_CLEARSELECTION              1200
#define IDC_MAP_VOFFSET                 1200
#define IDC_MAP_ACQUIRE2                1200
#define IDC_MAP_ACQUIRE                 1200
#define IDC_SELECTBYSMOOTH              1201
#define IDC_SEL_OBJECT                  1201
#define IDC_MAP_WOFFSET                 1201
#define IDC_MAP_FACE                    1201
#define IDC_SEL_VERTEX                  1202
#define IDC_MAP_UOFFSETSPIN             1202
#define IDC_MAP_LENGTH                  1202
#define IDC_SEL_FACE                    1203
#define IDC_MAP_VOFFSETSPIN             1203
#define IDC_MAP_WIDTH                   1203
#define IDC_SEL_ADD                     1204
#define IDC_MAP_WOFFSETSPIN             1204
#define IDC_MAP_HEIGHT                  1204
#define IDC_SEL_SUBTRACT                1205
#define IDC_MAP_LENGTHSPIN              1205
#define IDC_SEL_REPLACE                 1206
#define IDC_MAP_WIDTHSPIN               1206
#define IDC_SEL_WINDOW                  1207
#define IDC_MAP_HEIGHTSPIN              1207
#define IDC_SEL_CROSSING                1208
#define IDC_SEL_BOX                     1209
#define IDC_SEL_SPHERE                  1210
#define IDC_SEL_CYLINDER                1211
#define IDC_SEL_FIT                     1212
#define IDC_SEL_CENTER                  1213
#define IDC_SEL_RESET                   1214
#define IDC_MATID                       1215
#define IDC_MATIDSPIN                   1216
#define IDC_SEL_INVERT                  1218
#define IDC_NORM_UNIFY                  1219
#define IDC_NORM_FLIP                   1220
#define IDC_MAP_CAP                     1220
#define IDC_DEGREES                     1221
#define IDC_DEGREESSPINNER              1222
#define IDC_MORPHCAP                    1223
#define IDC_GRIDCAP                     1224
#define IDC_WELDCORE                    1226
#define IDC_DISPLATTICE                 1229
#define IDC_DISPSURFACE                 1230
#define IDC_DELETEPATCH                 1231
#define IDC_DISPCONTROL                 1232
#define IDC_DELETEVERT                  1232
#define IDC_SUBDIVIDE                   1233
#define IDC_PROPAGATE                   1235
#define IDC_ADAPTIVE                    1236
#define IDC_STEPS                       1237
#define IDC_STEPSSPINNER                1238
#define IDC_DISP_BALL                   1239
#define IDC_TESS_U_SPINNER              1239
#define IDC_TESS_U                      1240
#define IDC_TESS_V_SPINNER              1241
#define IDC_DISP_WTILE                  1242
#define IDC_TESS_V                      1242
#define IDC_DISP_WTILESPIN              1243
#define IDC_TESS_DIST_SPINNER           1243
#define IDC_DISP_WFLIP                  1244
#define IDC_TESS_DIST                   1244
#define IDC_DISP_VFLIP                  1245
#define IDC_TESS_ANG_SPINNER            1245
#define IDC_DISP_UFLIP                  1246
#define IDC_TESS_ANG                    1246
#define IDC_DISP_FIT                    1247
#define IDC_TESS_EDGE_SPINNER           1247
#define IDC_DISP_CENTER                 1248
#define IDC_TESS_EDGE                   1248
#define IDC_DISP_BITMAPFIT              1249
#define IDC_DISP_NORMALALIGN            1250
#define IDC_DISP_RESET                  1251
#define IDC_VERT_HIDE                   1252
#define IDC_DISP_ACQUIRE                1252
#define IDC_VERT_UNHIDEALL              1253
#define IDC_PATCH                       1254
#define IDC_MESH                        1255
#define IDC_FILTVERTS                   1255
#define IDC_FILTVECS                    1256
#define IDC_SEL_BYVERT                  1256
#define IDC_GENMAPPING                  1257
#define IDC_FLIPNORMALS                 1258
#define IDC_SPLINE_VERT_COUNT           1259
#define IDC_SPLINE_VERT_COUNT_TITLE     1260
#define IDC_RESETTM_SELECTED            1261
#define IDC_AFR_FALLOFF                 1262
#define IDC_LAG_FALLOFF                 1262
#define IDC_AFR_FALLOFFSPIN             1263
#define IDC_LAG_FALLOFFSPIN             1263
#define IDC_AFR_BACKFACE                1264
#define IDC_EXT_SCALE                   1264
#define IDC_AFR_SETTLE                  1264
#define IDC_LAG_SETTLE                  1264
#define IDC_EXT_SCALESPIN               1265
#define IDC_AFR_SETTLE_SPIN             1265
#define IDC_LAG_SETTLE_SPIN             1265
#define IDC_AFR_PINCH                   1266
#define IDC_TENSIONSPIN                 1266
#define IDC_AFR_WAVES                   1266
#define IDC_LAG_WAVES                   1266
#define IDC_AFR_PINCHSPIN               1267
#define IDC_ITERATIONS1                 1267
#define IDC_AFR_WAVES_SPIN              1267
#define IDC_LAG_WAVES_SPIN              1267
#define IDC_AFR_BUBBLE                  1268
#define IDC_ITERATIONS2                 1268
#define IDC_MESHSEL_GETVERT             1268
#define IDC_REFERENCEFRAME              1268
#define IDC_AFR_BUBBLESPIN              1269
#define IDC_ITERATIONS3                 1269
#define IDC_MESHSEL_GETFACE             1269
#define IDC_REFERENCEFRAME_SPIN         1269
#define IDC_ITERATIONS4                 1270
#define IDC_MESHSEL_GETEDGE             1270
#define IDC_MESHSEL_SELOPEN             1270
#define IDC_VWEIGHT                     1270
#define IDC_EXT_CENTER                  1271
#define IDC_MESHSEL_SELBYMAT            1271
#define IDC_GRAVITY_SPIN                1271
#define IDC_RADIUSSPIN                  1271
#define IDC_EXT_AMOUNT                  1272
#define IDC_PAINT_STRENGTH              1272
#define IDC_EXT_AMOUNTSPIN              1273
#define IDC_PAINTSTRENGTHSPIN           1273
#define IDC_DISP_VIEWALIGN              1274
#define IDC_VWEIGHT_SPIN                1274
#define IDC_DISP_FITREGION              1275
#define IDC_FEATHER                     1276
#define IDS_MIRROR_X                    1277
#define IDC_FEATHERSPIN                 1277
#define IDS_MIRROR_Y                    1278
#define IDS_MIRROR_Z                    1279
#define IDS_MIRROR_XY                   1280
#define IDS_MIRROR_YZ                   1281
#define IDS_MIRROR_ZX                   1282
#define IDC_MIRROR_COPY                 1283
#define IDC_MIRROR_OFFSET               1284
#define IDC_MIRROR_OFFSETSPIN           1285
#define IDC_IGNORE_BACKFACES            1286
#define IDC_IGNORE_VISEDGE              1287
#define IDC_UNWRAP_EDIT                 1287
#define IDC_UNWARP_TOOLBAR              1288
#define IDC_UNWRAP_RESET                1288
#define IDC_SCROLLBAR1                  1289
#define IDC_UNWRAP_VIEW                 1290
#define IDC_UNWRAP_LINECOLOR            1291
#define IDC_UNWRAP_XOR                  1292
#define IDC_UNWRAP_SELCOLOR             1293
#define IDC_UNWRAP_CONSTANTUPDATE       1294
#define IDC_UNWRAP_WIDTH                1295
#define IDC_UNWRAP_WIDTHSPIN            1296
#define IDC_UNWRAP_HEIGHT               1297
#define IDC_UNWRAP_HEIGHTSPIN           1298
#define IDC_UNWRAP_DEFAULTS             1299
#define IDC_FACE_COPYNS                 1301
#define IDC_TESS_VIEW                   1301
#define IDC_FACE_PASTENS                1302
#define IDC_TESS_RENDERER               1302
#define IDC_VERT_COPYNS                 1303
#define IDC_TESS_SET                    1303
#define IDC_VERT_PASTENS                1304
#define IDC_OPT_UPDATE                  1305
#define IDC_TESS_PARAM                  1305
#define IDC_OPT_MANUPDATE               1306
#define IDC_TESS_SPATIAL                1306
#define IDC_TESS_CURV                   1307
#define IDC_DISP_CAP                    1307
#define IDC_TESS_VIEW_DEP               1308
#define IDC_NUMSEL_LABEL                1309
#define IDC_MAP_CHAN1                   1310
#define IDC_LENGTH_LABEL                1311
#define IDC_MAP_CHAN2                   1312
#define IDC_WIDTH_LABEL                 1313
#define IDC_HEIGHT_LABEL                1314
#define IDC_MAP_X                       1315
#define IDC_MAP_Y                       1316
#define IDC_MAP_Z                       1317
#define IDC_DISP_LENGTH                 1318
#define IDC_DISP_LENGTHSPIN             1319
#define IDC_DISP_WIDTH                  1320
#define IDC_DISP_WIDTHSPIN              1321
#define IDC_DISP_HEIGHT                 1322
#define IDC_DISP_HEIGHTSPIN             1323
#define IDC_DISP_X                      1324
#define IDC_DISP_Y                      1325
#define IDC_DISP_Z                      1326
#define IDC_NURBS                       1327
#define IDC_UNWRAP_U                    1328
#define IDC_UNWRAP_USPIN                1329
#define IDC_UNWRAP_ULABEL               1330
#define IDC_UNWRAP_V                    1331
#define IDC_UNWRAP_VSPIN                1332
#define IDC_SETREFERENCE_BUTTON         1332
#define IDC_UNWRAP_VLABEL               1333
#define IDC_LIST1                       1333
#define IDC_UNWRAP_W                    1334
#define IDC_REMOVE_GRAV                 1334
#define IDC_UNWRAP_WSPIN                1335
#define IDC_RESET_BUTTON                1335
#define IDC_UNWRAP_WLABEL               1336
#define IDC_ABSOLUTE                    1336
#define IDC_PROJECT_THROUGH_CHECK       1339
#define IDC_ACQUIRE_REL                 1552
#define IDC_ACQUIRE_ABS                 1553
#define IDC_SELSINGLE                   5000
#define IDC_SELPOLY                     5001
#define IDC_SELELEMENT                  5002
#define IDC_BOOLUNION                   5010
#define IDC_BOOLSUBTRACTION             5011
#define IDC_BOOLINTERSECTION            5012
#define IDS_DS_MOVE2                    10004
#define IDS_DS_SELECT                   10007
#define IDS_DS_CREATE                   10008
#define IDS_RB_EXTRUDE                  30001
#define IDS_RB_TAPER                    30003
#define IDS_RB_OBJECT                   30004
#define IDS_RB_EDITMESH                 30009
#define IDS_RB_EDITMESHTOOLS            30010
#define IDS_RB_VERTEX                   30011
#define IDS_RB_FACE                     30012
#define IDS_RB_EDGE                     30013
#define IDS_RB_CENTER                   30014
#define IDS_RB_APPARATUS                30015
#define IDS_RB_EDITVERTEX               30016
#define IDS_RB_EDITOBJECT               30017
#define IDS_RB_EDITFACE                 30018
#define IDS_RB_EDITEDGE                 30019
#define IDS_RB_EDITPOLY                 30020
#define IDS_RB_EDITELEMENT              30021
#define IDS_RB_EDITMESH_CLASS           30022
#define IDS_RB_PARAMETERS               30028
#define IDS_RB_ANGLE                    30029
#define IDS_RB_DIRECTION                30030
#define IDS_RB_AMOUNT                   30031
#define IDS_RB_AMOUNT2                  30032
#define IDS_RB_CURVITURE                30033
#define IDS_RB_AMPLITUDE                30034
#define IDS_RB_WAVELEN                  30035
#define IDS_RB_PHASE                    30036
#define IDS_RB_DECAY                    30037
#define IDS_RB_FLEXIBILITY              30038
#define IDS_RB_WIDTH                    30039
#define IDS_RB_HEIGHT                   30040
#define IDS_DB_EXTRUDE                  30041
#define IDS_RB_NONE                     30137
#define IDS_RB_RIPPLE                   30155
#define IDS_RB_RIPPLE_BINDING           30156
#define IDS_RB_DELETEVERT               30211
#define IDS_RB_DELETEFACE               30212
#define IDS_RB_ADDVERTS                 30213
#define IDS_RB_ATTACHOBJECT             30214
#define IDS_RB_FACECOLLAPSE             30215
#define IDS_RB_MAKEPLANAR               30216
#define IDS_RB_BUILDFACE                30217
#define IDS_RB_HIDEFACE                 30218
#define IDS_RB_UNHIDEALLFACES           30219
#define IDS_RB_EDGEVISIBLE              30220
#define IDS_RB_EDGEINVISIBLE            30221
#define IDS_RB_AUTOEDGE                 30222
#define IDS_RB_EDGEDIVIDE               30223
#define IDS_RB_EDGETURN                 30224
#define IDS_RB_DELETEEDGE               30225
#define IDS_RB_COLLAPSEEDGE             30226
#define IDS_RB_CLONE                    30227
#define IDS_RB_TESSELLATE               30228
#define IDS_RB_DELETEISOLATED           30229
#define IDS_RB_DEFDEFORMATIONS          30270
#define IDS_RB_DEFEDIT                  30271
#define IDS_RB_NODEXFORM                30276
#define IDS_RB_NODEXFORM_CLASS          30277
#define IDS_RB_XFORM_CLASS              30278
#define IDS_RB_EDITSURFACE              30279
#define IDS_RB_SETSMOOTHGROUP           30280
#define IDS_RB_ASSIGNMATID              30281
#define IDS_RB_FLIPNORMALS              30282
#define IDS_RB_UNIFYNORMALS             30283
#define IDS_RB_AUTOSMOOTH               30284
#define IDS_RB_SELECTBYMATID            30285
#define IDS_RB_SELECTBYSMOOTH           30286
#define IDS_RB_SOT                      30287
#define IDS_RB_DEFLECTOR_CLASS          30288
#define IDS_RB_HIDEVERT                 30294
#define IDS_RB_DEFSURFACE               30298
#define IDS_RB_SCALE                    30377
#define IDS_RB_NOISE                    30411
#define IDS_RB_ROTATION2                30521
#define IDS_RB_TWIST                    30522
#define IDS_RB_BENDMOD                  30543
#define IDS_RB_BEND2                    30544
#define IDS_RB_FROM                     30545
#define IDS_RB_TO                       30546
#define IDS_RB_BOMBOBJECT               30547
#define IDS_RB_BOMB                     30548
#define IDS_RB_BOMBMOD                  30549
#define IDS_RB_BOMBBINDING              30550
#define IDS_RB_CLUSTNODEMOD             30551
#define IDS_RB_XFORM                    30552
#define IDS_RB_DEFLECTOR                30553
#define IDS_RB_DEFLECTMOD               30554
#define IDS_RB_DEFLECTORBINDING         30555
#define IDS_RB_BOUNCE                   30556
#define IDS_RB_DISPMOD                  30557
#define IDS_RB_DISPLACE                 30558
#define IDS_RB_DISPLACEMOD              30559
#define IDS_RB_DISPLACEBINDING          30560
#define IDS_RB_SELECTDISPIMAGE          30561
#define IDS_RB_SELECTIMAGE              30562
#define IDS_RB_UTILE                    30563
#define IDS_RB_VTILE                    30564
#define IDS_RB_WTILE                    30565
#define IDS_RB_BLUR                     30566
#define IDS_RB_DOCREATENEWOBJECT        30567
#define IDS_RB_EDITMESH2                30568
#define IDS_RB_GRAVITY                  30569
#define IDS_RB_WIND                     30570
#define IDS_RB_GRAVITYMOD               30571
#define IDS_RB_GRAVITYBINDING           30572
#define IDS_RB_WINDMOD                  30573
#define IDS_RB_WINDBINDING              30574
#define IDS_RB_TURBULENCE               30575
#define IDS_RB_FREQUENCY                30576
#define IDS_RB_MAPMOD                   30577
#define IDS_RB_UVWMAPPING               30578
#define IDS_RB_UVWMAP                   30579
#define IDS_RB_NOISEMOD                 30580
#define IDS_RB_SEED                     30581
#define IDS_RB_FRACTAL                  30582
#define IDS_RB_ROUGH                    30583
#define IDS_RB_ITERATIONS               30584
#define IDS_RB_OPTMOD                   30585
#define IDS_RB_OPTIMIZE                 30586
#define IDS_RB_FACETHRESHL1             30587
#define IDS_RB_FACETHRESHL2             30588
#define IDS_RB_EDGETHRESHL1             30589
#define IDS_RB_EDGETHRESHL2             30590
#define IDS_RB_BIASL1                   30591
#define IDS_RB_BIASL2                   30592
#define IDS_RB_EDITMESHMOD              30593
#define IDS_RB_TWISTMOD                 30594
#define IDS_RB_TWIST2                   30595
#define IDS_RB_TWISTPLUGIN              30596
#define IDS_RB_BIAS                     30597
#define IDS_RB_INCORRECTSTRING          30598
#define IDS_RB_AUTHORIZATION            30599
#define IDS_RB_TAPERMOD                 30600
#define IDS_RB_SYMMETRY                 30601
#define IDS_RB_MATMOD                   30602
#define IDS_RB_MATERIAL3                30603
#define IDS_RB_MATERIALID               30604
#define IDS_RB_MATERIAL4                30605
#define IDS_RB_MATERIALID2              30606
#define IDS_RB_SMOOTHMOD                30607
#define IDS_RB_NORMALMOD                30608
#define IDS_RB_SKEWMOD                  30609
#define IDS_RB_SKEW                     30610
#define IDS_RB_SMOOTH2                  30611
#define IDS_RB_WAVE                     30612
#define IDS_RB_WAVEMOD                  30613
#define IDS_RB_WAVEBINDING              30614
#define IDS_RB_AMPLITUDE1               30615
#define IDS_RB_AMPLITUDE2               30616
#define IDS_RB_VOLSELECT                30617
#define IDS_RB_THRESHOLD                30618
#define IDS_RB_GIZMO                    30619
#define IDS_RB_NORMAL                   30620
#define IDS_RB_BEND_CLASS               30621
#define IDS_RB_DISPLACE_CLASS           30622
#define IDS_RB_VOLSELECT_CLASS          30623
#define IDS_RB_SKEW_CLASS               30624
#define IDS_RB_MATERIAL3_CLASS          30625
#define IDS_RB_SMOOTH2_CLASS            30626
#define IDS_RB_NORMAL_CLASS             30627
#define IDS_TH_LATHE_CLASS              30628
#define IDS_RB_EXPLODE                  30629
#define IDS_RB_COLLAPSE                 30630
#define IDS_RB_WELDVERTS                30631
#define IDS_RB_TAPER_CLASS              30632
#define IDS_RB_TWIST2_CLASS             30633
#define IDS_RB_TWIST_CLASS              30634
#define IDS_RB_BOMBOBJECT_CLASS         30635
#define IDS_RB_BOMB_CLASS               30636
#define IDS_RB_RIPPLE_CLASS             30637
#define IDS_RB_WAVE_CLASS               30638
#define IDS_RB_STRENGTH2                30646
#define IDS_DS_MOVE                     30647
#define IDS_RB_FACESEL                  30651
#define IDS_RB_POLYGONSEL               30652
#define IDS_RB_ELEMENTSEL               30653
#define IDS_RB_NOVERTSTOWELD            30680
#define IDS_RB_CHAOS                    30681
#define IDS_RB_DETONATION               30682
#define IDS_RB_BOMBPARAMS               30683
#define IDS_RB_EDITMESHTITLE            30684
#define IDS_RB_DUPFACEWARNING           30685
#define IDS_RB_NUMVERTSELP              30699
#define IDS_RB_NUMVERTSEL               30700
#define IDS_RB_NUMFACESELP              30701
#define IDS_RB_NUMFACESEL               30702
#define IDS_RB_NUMEDGESELP              30703
#define IDS_RB_NUMEDGESEL               30704
#define IDS_TH_EDITSPLINE               40025
#define IDS_TH_EDITSEGMENT              40026
#define IDS_TH_EDITVERTEX               40027
#define IDS_TH_SPLINE                   40028
#define IDS_TH_SEGMENT                  40029
#define IDS_TH_VERTEX                   40030
#define IDS_TH_EDITOBJECT               40031
#define IDS_TH_EDITPATCH_CLASS          40032
#define IDS_TH_EDITSPLINE_CLASS         40033
#define IDS_RB_EXTRUDE_CLASS            40034
#define IDS_RB_GRAVITY_CLASS            40035
#define IDS_RB_WIND_CLASS               40036
#define IDS_RB_UVWMAP_CLASS             40037
#define IDS_RB_NOISE_CLASS              40038
#define IDS_TH_CLOSESPLINE              40039
#define IDS_RB_OPTIMIZE_CLASS           40040
#define IDS_TH_DELETESPLINE             40041
#define IDS_TH_NOVALIDSPLINESSEL        40042
#define IDS_TH_NOSPLINESSEL             40043
#define IDS_TH_VERTBREAK                40044
#define IDS_TH_NOVALIDVERTSSEL          40045
#define IDS_TH_SEGDELETE                40046
#define IDS_TH_NOSEGSSEL                40047
#define IDS_TH_DETACHSPLINE             40048
#define IDS_TH_OUTLINE                  40049
#define IDS_TH_SEGDETACH                40050
#define IDS_TH_SHAPE                    40051
#define IDS_TH_REFINE                   40052
#define IDS_TH_SEGBREAK                 40053
#define IDS_TH_VERTCONNECT              40054
#define IDS_TH_VERTINSERT               40055
#define IDS_TH_VERTWELD                 40056
#define IDS_TH_NOWELDPERFORMED          40057
#define IDS_TH_SELECTONESPLINE          40058
#define IDS_TH_MORETHANONESPLINESEL     40059
#define IDS_TH_BOOLEAN                  40060
#define IDS_TH_UNION                    40061
#define IDS_TH_SUBTRACTION              40062
#define IDS_TH_INTERSECTION             40063
#define IDS_TH_BOOLWELDFAILED           40064
#define IDS_TH_COINCIDENTVERTEX         40065
#define IDS_TH_SPLINESMUSTOVERLAP       40066
#define IDS_TH_SELECTCLOSEDSPLINE       40067
#define IDS_TH_SPLINESELFINTERSECTS     40068
#define IDS_TH_ATTACH                   40069
#define IDS_TH_CANHAVEONLYONESHAPE      40070
#define IDS_TH_NOVERTSSEL               40071
#define IDS_TH_VERTCHANGE               40072
#define IDS_TH_SMOOTH                   40073
#define IDS_TH_CORNER                   40074
#define IDS_RB_RESETXFORM_CLASS         40075
#define IDS_TH_BEZIER                   40076
#define IDS_TH_SEGCHANGE                40077
#define IDS_TH_CURVE                    40078
#define IDS_TH_LINE                     40079
#define IDS_TH_VERTDELETE               40080
#define IDS_TH_BEZIERCORNER             40081
#define IDS_TH_AMOUNT                   40082
#define IDS_TH_EDITPATCH                40083
#define IDS_TH_PATCH                    40084
#define IDS_TH_SEGMENTS                 40085
#define IDS_TH_PATCHDELETE              40086
#define IDS_TH_NOPATCHESSEL             40087
#define IDS_TH_MAKEFIRST                40160
#define IDS_TH_EDITEDGE                 40170
#define IDS_TH_EDGE                     40171
#define IDS_TH_AUTOINTERIOR             40172
#define IDS_TH_MANUALINTERIOR           40173
#define IDS_TH_NOVALIDEDGESSEL          40174
#define IDS_TH_PATCHADD                 40175
#define IDS_TH_EDGESUBDIVIDE            40176
#define IDS_TH_PATCHSUBDIVIDE           40177
#define IDS_TH_CREATELINE               40178
#define IDS_TH_MIRROR_H                 40179
#define IDS_TH_MIRROR_V                 40180
#define IDS_TH_MIRROR_BOTH              40181
#define IDS_TH_MIRROR                   40182
#define IDS_TH_PATCHCHANGE              40186
#define IDS_TH_COPLANAR                 40187
#define IDS_TH_POLYCONNECT              40190
#define IDS_TH_CONNECT_COINCIDENT       40191
#define IDS_TH_CANHAVEONLYONEPATCH      40192
#define IDS_TH_DETACHPATCH              40193
#define IDS_TH_COPY_SPLINE              40196
#define IDS_TH_COPY_SEGMENT             40197
#define IDS_TH_SPLINECHANGE             40201
#define IDS_TH_MIRRORSPLINE             40279
#define IDS_TH_DEGREES                  40308
#define IDS_TH_AXIS                     40309
#define IDS_TH_LATHE                    40310
#define IDS_TH_VERTWELDRESULT           40316
#define IDS_RB_RESETXFORM               40317
#define IDS_RB_AFRMOD                   40318
#define IDS_RB_LAGMOD                   40318
#define IDS_RB_STARTPOINT               40319
#define IDS_RB_ENDPOINT                 40320
#define IDS_RB_AFRPOINTS                40321
#define IDS_RB_LAGPOINTS                40321
#define IDS_AFR_FALLOFF                 40322
#define IDS_LAG_FALLOFF                 40322
#define IDS_AFR_PINCH                   40323
#define IDS_LAG_PINCH                   40323
#define IDS_AFR_BUBBLE                  40324
#define IDS_LAG_BUBBLE                  40324
#define IDS_RB_TESSMOD                  40325
#define IDS_NODE                        40325
#define IDS_TESS_TENSION                40326
#define IDS_LAG_STRENGTH                40326
#define IDS_RB_DELETEMOD                40327
#define IDS_LAG_SWAY                    40327
#define IDS_RB_MESHSELMOD               40328
#define IDS_LAG_REFERENCEFRAME          40328
#define IDS_RB_FACEEXTRUDEMOD           40329
#define IDS_RB_LAG_EDGE                 40329
#define IDS_RB_EXTRUDECENT              40330
#define IDS_LAG_GRAVITY                 40330
#define IDS_EXT_AMOUNT                  40331
#define IDS_LAG_WEIGHTS                 40331
#define IDS_EXT_SCALE                   40332
#define IDS_LAG_FORCE_NODES             40332
#define IDS_RB_UVWXFORMMOD              40333
#define IDS_LAG_ABSOLUTE                40333
#define IDS_RB_UOFFSET                  40334
#define IDS_PW_LAG_NOT_SELECTED         40334
#define IDS_RB_VOFFSET                  40335
#define IDS_PW_NOT_LAGDEF_ERROR         40335
#define IDS_RB_WOFFSET                  40336
#define IDS_PW_EXCEEDED_VERTEX_COUNT    40336
#define IDS_RB_MAXEDGE1                 40337
#define IDS_PW_ERROR_COUNT              40337
#define IDS_RB_MAXEDGE2                 40338
#define IDS_PW_CHANGE_WEIGHT            40338
#define IDS_RB_CENTERPOINT              40339
#define IDS_PW_FLEXDATA                 40339
#define IDS_RB_MIRRORMOD                40340
#define IDS_RB_MIRRORCENTER             40341
#define IDS_RB_OFFSET                   40342
#define IDS_RB_SELVERTEX                40343
#define IDS_RB_SELFACE                  40344
#define IDS_RB_SELEDGE                  40345
#define IDS_RB_SELOBJECT                40346
#define IDS_RB_UNWRAPMOD                40347
#define IDS_AP_SDELETEMOD               40348
#define IDS_RB_RESETUVWS                40349
#define IDS_RB_SETCHANNEL               40350
#define IDS_RB_SHOULDRESET              40351
#define IDS_RB_RESETUNWRAPUVWS          40352
#define IDS_RB_LENGTH                   40353
#define IDS_SA_TRIANGLE                 40354
#define IDS_SA_POLYGON                  40355
#define IDS_SA_TRI_POLY_RESTORE         40356
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        159
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1337
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wM3.rc
//
#define IDS_LIBDESCRIPTION              1
#define IDS_CLASS_NAME                  3
#define IDS_GLOBAL_PARAMS               4
#define IDS_CHANNEL_PARAMS              5
#define IDS_CHANNEL_LIST                6
#define IDS_ADVANCED                    7
#define IDS_EMPTY_CHANNEL               8
#define IDS_MXCATEGORY                  9
#define IDS_SUBANIMPARAM                10
#define IDS_UPD_ON                      11
#define IDS_UPD_OFF                     12
#define IDS_DEL_ON                      13
#define IDS_DEL_OFF                     14
#define IDS_PC_MORPH                    15
#define IDS_NOCON                       16
#define IDS_ONCON                       17
#define IDS_MENUITEM1_PS                18
#define IDS_MENUITEM2_DC                19
#define IDS_MENUITEM3_RT                20
#define IDS_CAPTURED                    21
#define IDS_ACTIVE                      22
#define IDS_MENUNAME                    23
#define IDS_FREE                        24
#define IDS_CHANSEL                     25
#define IDS_OPMOVE                      26
#define IDS_OPSWAP                      28
#define IDS_OPOKAY                      29
#define IDS_OPWARN                      30
#define IDS_OPCANT                      31
#define IDS_LOADMULTI                   32
#define IDS_MULTIBTN                    33
#define IDS_NOFREE                      34
#define IDS_CANNOT                      35
#define IDS_LEGEND_DLG                  36
#define IDS_EXTRACT_GRAB_ERROR          37
#define IDS_EXTRACT_MOD_ERROR           38
#define IDS_MORPHMTL                    39
#define IDS_MTL_PARAM                   41
#define IDS_DS_NONE                     42
#define IDS_MTL_CNAME                   43
#define IDS_MTL_BASE                    44
#define IDS_MTL_MAPNAME                 45
#define IDS_MTL_BASENAME                46
#define IDS_MTL_MAPNAMEDOTS             47
#define IDS_MTL_NOTARG                  48
#define IDS_MTL_NOOBJ                   49
#define IDS_UNDOMCDEL                   50
#define IDS_PBN_USELIMITS               51
#define IDS_PBN_SPINMIN                 52
#define IDS_PBN_SPINMAX                 53
#define IDS_PBN_USESEL                  54
#define IDS_PBN_VALUEINC                55
#define IDS_PBN_AUTOLOAD                56
#define IDD_GLOBAL_PARAMS               101
#define IDD_CHANNEL_PARAMS              103
#define IDD_CHANNEL_LIST                108
#define IDD_LEGEND                      109
#define IDR_CHANSUB                     112
#define IDD_MC_EXPORT                   113
#define IDD_MC_IMPORT                   114
#define IDD_ADVANCED                    115
#define IDD_CHANOP                      116
#define IDD_BINDMORPH                   117
#define IDD_NAMECAP                     119
#define IDB_SV_MORPH32_MASK             159
#define IDB_SV_MORPH16                  167
#define IDB_SV_MORPH16_MASK             168
#define IDB_SV_MORPH32                  169
#define IDC_MEMAPPOX                    1002
#define IDC_UPDATETARGS                 1003
#define IDC_LOADMULT                    1005
#define IDC_P1                          1012
#define IDC_P2                          1013
#define IDC_P3                          1014
#define IDC_P4                          1015
#define IDC_P5                          1016
#define IDC_P6                          1017
#define IDC_P7                          1018
#define IDC_P8                          1019
#define IDC_P9                          1020
#define IDC_COMPACT                     1020
#define IDC_P10                         1021
#define IDC_MEMSIZE                     1021
#define IDC_COMPACTSTAT                 1022
#define IDC_LISTSCROLL                  1027
#define IDC_LISTFRAME                   1028
#define IDC_I1                          1031
#define IDC_I2                          1032
#define IDC_I3                          1033
#define IDC_LIMIT                       1034
#define IDC_I4                          1034
#define IDC_I5                          1035
#define IDC_I6                          1036
#define IDC_I7                          1037
#define IDC_I8                          1038
#define IDC_I9                          1039
#define IDC_I10                         1040
#define IDC_IC1                         1045
#define IDC_IC2                         1046
#define IDC_IC3                         1047
#define IDC_IC4                         1048
#define IDC_IC5                         1049
#define IDC_CHANNUM                     1051
#define IDC_LOAD                        1053
#define IDC_SAVE                        1054
#define IDC_CANCEL                      1055
#define IDD_MORPHMTL                    1055
#define IDC_DOSAVE                      1056
#define IDC_CMAP                        1058
#define IDC_ADD                         1059
#define IDC_ADD2                        1060
#define IDC_MARKERLIST                  1060
#define IDC_SAVEMARKER                  1061
#define IDC_DELMARKER                   1062
#define IDC_CHANNAME                    1063
#define IDC_PERFORMOP                   1064
#define IDC_ALL_DEACTIVATE              1064
#define IDC_PICK                        1066
#define IDC_CLIST                       1066
#define IDC_MAKE                        1067
#define IDC_CIMP                        1067
#define IDC_USESEL                      1068
#define IDC_SEL                         1068
#define IDC_UPDATETARGET                1069
#define IDC_SELNONE                     1069
#define IDC_DELETE                      1070
#define IDC_SELALL                      1070
#define IDC_STAT                        1070
#define IDC_EXTRACT                     1071
#define IDC_SELUSED                     1071
#define IDC_ZEROOTHERS                  1072
#define IDC_SELINVERT                   1072
#define IDC_AUTOLOAD                    1074
#define IDC_BIND                        1075
#define IDC_REFRESH                     1076
#define IDC_MORPHNAME                   1078
#define IDC_MODLIST                     1079
#define IDC_UPDATE1                     1082
#define IDC_UPDATE2                     1083
#define IDC_MTLASSIGN                   1083
#define IDC_UPDATE3                     1084
#define IDC_NEWNAME                     1085
#define IDC_USECHAN                     1086
#define IDC_ALL_ACTIVATE                1087
#define IDC_BASE                        1096
#define IDC_MAX_EDIT                    1135
#define IDC_MAX_SPIN                    1136
#define IDC_MIN_EDIT                    1137
#define IDC_MIN_SPIN                    1138
#define IDC_PAGE                        1168
#define IDC_FE1                         1401
#define IDC_FE2                         1402
#define IDC_FE3                         1403
#define IDC_FE4                         1404
#define IDC_FE5                         1405
#define IDC_FE6                         1406
#define IDC_FE7                         1407
#define IDC_FE8                         1408
#define IDC_FE9                         1409
#define IDC_FE10                        1410
#define IDC_FS1                         1421
#define IDC_FS2                         1422
#define IDC_FS3                         1423
#define IDC_FS4                         1424
#define IDC_FS5                         1425
#define IDC_FS6                         1426
#define IDC_FS7                         1427
#define IDC_FS8                         1428
#define IDC_FS9                         1429
#define IDC_FS10                        1430
#define IDC_MORPH_MAT1                  1521
#define IDC_MORPH_MAT2                  1522
#define IDC_MORPH_MAT3                  1523
#define IDC_MORPH_MAT4                  1524
#define IDC_MORPH_MAT5                  1525
#define IDC_MORPH_MAT6                  1526
#define IDC_MORPH_MAT7                  1527
#define IDC_MORPH_MAT8                  1528
#define IDC_MORPH_MAT9                  1529
#define IDC_MORPH_MAT10                 1530
#define IDC_MORPH_BASE                  1531
#define IDC_V1                          1601
#define IDC_V2                          1602
#define IDC_V3                          1603
#define IDC_TEXON1                      9001
#define IDC_TEXON2                      9002
#define IDC_TEXON3                      9003
#define IDC_TEXON4                      9004
#define IDC_TEXON5                      9005
#define IDC_TEXON6                      9006
#define IDC_TEXON7                      9007
#define IDC_TEXON8                      9008
#define IDC_TEXON9                      9009
#define IDC_TEXON10                     9010
#define IDC_MNAME1                      9101
#define IDC_MNAME2                      9102
#define IDC_MNAME3                      9103
#define IDC_MNAME4                      9104
#define IDC_MNAME5                      9105
#define IDC_MNAME6                      9106
#define IDC_MNAME7                      9107
#define IDC_MNAME8                      9108
#define IDC_MNAME9                      9109
#define IDC_MNAME10                     9110
#define ID_CSM_MOVE                     40003
#define ID_CSM_SWAP                     40004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         40007
#define _APS_NEXT_CONTROL_VALUE         1088
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3.h ===
/*===========================================================================*\
 | 
 |  FILE:	wM3.h
 |			Weighted Morpher for MAX R3
 |			Main header file
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 22-5-98
 | 
\*===========================================================================*/


#ifndef __MORPHR3__H
#define __MORPHR3__H

#define MorphExport __declspec( dllexport )


#include <Max.h>
#include <istdplug.h>
#include <meshadj.h>
#include <modstack.h>
#include <imtl.h>
#include <texutil.h>
#include <stdmat.h>
#include <macrorec.h>


#include "resource.h"

static Class_ID M3MatClassID(0x4b9937e0, 0x3a1c3da4);
#define MR3_CLASS_ID		Class_ID(0x17bb6854, 0xa5cba2a3)
#define MR3_NUM_CHANNELS	100

#define MR3_MORPHERVERSION	010


// Save codes for the morphChannel class
#define MR3_POINTCOUNT		0x0100
#define MR3_SELARRAY		0x0110
#define MR3_NAME			0x0120
#define MR3_PARAMS			0x0130
#define MR3_POINTDATA_MP	0x0140
#define MR3_POINTDATA_MW	0x0150
#define MR3_POINTDATA_MD	0x0160
#define MR3_POINTDATA_MO	0x0170

// Save codes for the MorphR3 class
#define MR3_MARKERNAME		0x0180
#define MR3_MARKERINDEX		0x0185
#define MR3_MC_CHUNK		0x0190
#define MR3_MC_SUBCHUNK		0x0200
#define MR3_FLAGS			0x0210



// paramblock index table
#define PB_OV_USELIMITS		0
#define PB_OV_SPINMIN		1
#define PB_OV_SPINMAX		2
#define PB_OV_USESEL		3
#define PB_AD_VALUEINC		4
#define PB_CL_AUTOLOAD		5


// Channel operation flags
#define OP_MOVE				0
#define OP_SWAP				1


// two handy macros to set cursors for busy or normal operation
#define UI_MAKEBUSY			SetCursor(LoadCursor(NULL, IDC_WAIT));
#define UI_MAKEFREE			SetCursor(LoadCursor(NULL, IDC_ARROW));
			

// Morph Material ui defines
#define NSUBMTL 10

// Updater flags
#define UD_NORM				0
#define UD_LINK				1


extern ClassDesc* GetMorphR3Desc();
extern ClassDesc* GetM3MatDesc();
extern HINSTANCE hInstance;

TCHAR *GetString(int id);

//   SV Integration
// *----------------*
extern HIMAGELIST hIcons32, hIcons16;
extern COLORREF bkColor;
enum IconIndex {II_MORPHER};
void LoadIcons(COLORREF bkColor);
// *----------------*

class MorphR3;
class M3Mat;
class M3MatDlg;
class MCRestore;

// Dialog handlers
BOOL CALLBACK Legend_DlgProc		(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK Globals_DlgProc		(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK Advanced_DlgProc		(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK ChannelParams_DlgProc	(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK ChannelList_DlgProc	(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

BOOL CALLBACK IMPORT_DlgProc		(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EXPORT_DlgProc		(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK ChannelOpDlgProc		(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

BOOL CALLBACK BindProc				(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK NameDlgProc			(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);


/*===========================================================================*\
 | Morph channel manager class
 | Storage for all the morph data needed
\*===========================================================================*/

class morphChannel
{
public:

	// Construct/Destruct
	~morphChannel();
	morphChannel();

	MorphR3		*mp;

	// Number of points and morphable points
	int			nPts;
	int			nmPts;

	// Actual morphable points
	Point3*		mPoints;
	Point3*		mDeltas;
	double*		mWeights;
	// Point indicies that are different from the host
	// mesh. This is a simple but efficient way to speed up the
	// morphing process.
	int*		mOptdata;
	// BitArray to check against for point selection
	BitArray	mSel;
	// INode that we use to update and reload from, if possible
	INode*		mConnection;
	// Name for the morph channel
	TSTR		mName;

	// Various, non-animatable stuff
	// mActive is TRUE if the channel has data in it in some form
	// mModded is TRUE if the channel has been changed in SOME form,
	//		ie, had its name changed or similar
	BOOL		mActive, mModded, mUseLimit, mUseSel;
	float		mSpinmin,mSpinmax;

	// TRUE if the channel has been marked as bad. It will not be 
	// considered when building the morph results.
	BOOL		mInvalid;

	// Channel enabled/disabled
	BOOL		mActiveOverride;

	// paramblock for the morph channels values
	IParamBlock* cblock;
	

	// Delete and reset channel
	MorphExport void ResetMe();


	MorphExport void AllocBuffers( int sizeA, int sizeB );

	// Do some rough calculations about how much space this channel
	// takes up
	// This isn't meant to be fast or terribly accurate!
	MorphExport float getMemSize();


	// The rebuildChannel call will recalculate the optimization data
	// and refill the mSel selection array. This will be called each time a
	// targeted node is changed, or any of the 'Update Target' buttons is
	// pressed on the UI
	MorphExport void rebuildChannel();

	// Initialize a channel using a scene node
	MorphExport void buildFromNode( INode *node , BOOL resetTime=TRUE , TimeValue t=0 );

	// Transfer data to another channel
	MorphExport morphChannel& operator=(morphChannel& from);

	// Load/Save channel to stream
	MorphExport IOResult Save(ISave* isave);
	MorphExport IOResult Load(ILoad* iload);
};


// Used for picking a morph target from the scene
class GetMorphNode : 
		public PickModeCallback,
		public PickNodeCallback {
	public:				
		MorphR3 *mp;

		BOOL isPicking;

		GetMorphNode() {
			mp=NULL;
			isPicking=FALSE;
		}

		BOOL  HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);		
		BOOL  Pick(IObjParam *ip,ViewExp *vpt);		
		BOOL  Filter(INode *node);
		BOOL  RightClick(IObjParam *ip,ViewExp *vpt) {return TRUE;}

		void  EnterMode(IObjParam *ip);
		void  ExitMode(IObjParam *ip);		

		PickNodeCallback *GetFilter() {return this;}
		
	};

static GetMorphNode thePickMode;


// Internally-used local object morph cache
class morphCache
{

public:

	BOOL CacheValid;

	Point3*		oPoints;
	double*		oWeights;
	BitArray	sel;

	int		Count;

	morphCache ();
	~morphCache () { NukeCache(); }

	MorphExport void MakeCache(Object *obj);
	MorphExport void NukeCache();

	MorphExport BOOL AreWeCached();
};



/*===========================================================================*\
 | Morph Channel restore object
\*===========================================================================*/

class MCRestore : public RestoreObj {

public:
	MorphR3 *mp;
	morphChannel undoMC;
	int mcIndex;

	// Constructor
	MCRestore(MorphR3 *mpi, int idx);

	// Called when Undo is selected
	void Restore(int isUndo);

	// Called when Redo is selected
	void Redo();

	// Called to return the size in bytes of this RestoreObj
	int Size();
};


/*===========================================================================*\
 | Modifer class definition
\*===========================================================================*/
class MorphR3 : public Modifier, TimeChangeCallback {
	public:

		// Access to the interface
		static IObjParam *ip;
		
		// Pointer to the morph channels
		morphChannel		*chanBank;
		
		// Currently selected channel (0-9)
		int					chanSel;
		
		// Currently viewable channel banks (0-99)
		int					chanNum;

		// Spinners from main page
		ISpinnerControl		*chanSpins[10];

		// Spinners from global settings page
		ISpinnerControl		*glSpinmin,*glSpinmax;

		// Spinners from the channel params dlg
		ISpinnerControl		*cSpinmin,*cSpinmax;

		// Global parameter block
		IParamBlock			*pblock;

		// The window handles for the 4 rollout pages
		HWND hwGlobalParams, hwChannelList,	hwChannelParams, hwAdvanced, hwLegend;

		// For the namer dialog
		ICustEdit			*newname;

		// Morph Cache
		morphCache MC_Local;

		BOOL tccI;
		char trimD[50];

		// 'Save as Current' support
		BOOL recordModifications;
		int recordTarget;


		// Marker support
		Tab<int>			markerIndex;
		NameTab				markerName;
		int					markerSel;


		// Channel operation flag for dialog use
		int					cOp;
		int					srcIdx;


		//Constructor/Destructor
		MorphR3();
		~MorphR3();


		// TimeChangeCallback
		void TimeChanged(TimeValue t) {
			if(hwChannelList) Update_channelValues();

			Interval valid=FOREVER;	int itmp; 
			Interface *Cip = GetCOREInterface();

			if(pblock&&Cip)
			{
				pblock->GetValue(PB_CL_AUTOLOAD, 0, itmp, valid);
				if(itmp==1) NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
			}

		}


		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= TSTR(GetString(IDS_CLASS_NAME)); }  
		virtual Class_ID ClassID() { return MR3_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_CLASS_NAME); }

		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);

		//From Modifier
		ChannelMask ChannelsUsed()  { return PART_GEOM|PART_TOPO|SELECT_CHANNEL; }
		ChannelMask ChannelsChanged() { return PART_GEOM; }
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Class_ID InputType() {
			// removed the following
			// it was screwing with modstack evaluation severely!
			//Interface *ip = GetCOREInterface();
			//if(ip&&ip->GetSelNodeCount()>1) return Class_ID(0,0);
			return defObjectClassID;
		}
		Interval LocalValidity(TimeValue t);
		void NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc);

		// From BaseObject
		BOOL ChangeTopology() {return FALSE;}
		int GetParamBlockIndex(int id) {return id;}

		//From ReferenceMaker
		int NumRefs();
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		
		int NumSubs();
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);

		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		// Handles the scroll bar on the channel list UI
		MorphExport void VScroll(int code, short int cpos );
		// Clamps channel number to valid range
		MorphExport void Clamp_chanNum();

		
		MorphExport void ChannelOp(int src, int targ, int flags);


		MorphExport void Update_globalParams();
		MorphExport void Update_advancedParams();	
		MorphExport void Update_channelParams();


		// evaluate the value increments setting
		MorphExport float GetIncrements();
		// SetScale on the channel list spinners
		MorphExport void Update_SpinnerIncrements();

		// Functions to update the channel list dialog box:
		MorphExport void Update_colorIndicators();
		MorphExport void Update_channelNames();
		MorphExport void Update_channelValues();
		MorphExport void Update_channelLimits();
		MorphExport void Update_channelInfo();
		MorphExport void Update_channelMarkers();
		// Seperated cause this function is pretty expensive
		// Lots done, complete update - calls all functions above
		MorphExport void Update_channelFULL();
		
		// Used to trim fp values to a number of decimal points
		MorphExport float TrimDown(float value, int decimalpts);



		BOOL inRender;

		int RenderBegin(TimeValue t, ULONG flags) {	
			inRender = TRUE;
			return 1; 	
			}
		int RenderEnd(TimeValue t) { 	
			inRender = FALSE;	
			return 1; 	
			}
};



/*===========================================================================*\
 |
 | Morph Material definitions
 |
\*===========================================================================*/

class M3MatDlg : public ParamDlg {
	public:		
		HWND hwmedit;

		IMtlParams *ip;

		M3Mat *theMtl;

		HWND hPanel; 

		ICustButton *iBut[NSUBMTL];
		ICustButton *bBut;
		ICustButton *pickBut;

		MtlDADMgr dadMgr;

		BOOL valid;

		M3MatDlg(HWND hwMtlEdit, IMtlParams *imp, M3Mat *m); 
		~M3MatDlg();
		
		BOOL WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);				
		void Invalidate();		
		void DragAndDrop(int ifrom, int ito);
		void UpdateSubMtlNames();
		void ActivateDlg(BOOL onOff) {}
		
		// methods inherited from ParamDlg:		
		void ReloadDialog();
		Class_ID ClassID() {return M3MatClassID;}
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing() { return (ReferenceTarget *)theMtl; }
		void DeleteThis() { delete this;  }	
		void SetTime(TimeValue t) {Invalidate();}

		int FindSubMtlFromHWND(HWND hw);

		MorphExport void VScroll(int code, short int cpos );
		MorphExport void Clamp_listSel();

		MorphExport void UpdateMorphInfo(int upFlag);
};

class M3Mat : public Mtl {	
	public:
		M3MatDlg *dlg;

		// 100 materials for 100 morph channels, plus 1 base material
		Mtl *mTex[101];
		BOOL mapOn[100];

		BOOL inRender;

		// Morph mod pointer
		MorphR3	*morphp;
		TSTR obName;

		// Temp node pointer used in the mtl pickmode
		INode *Wnode;

		IParamBlock *pblock;

		Interval ivalid;
		int listSel;

		M3Mat(BOOL loading);

		void NotifyChanged() {NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);}
		

		// From MtlBase and Mtl
		void SetAmbient(Color c, TimeValue t) {}		
		void SetDiffuse(Color c, TimeValue t) {}		
		void SetSpecular(Color c, TimeValue t) {}
		void SetShininess(float v, TimeValue t) {}				
		
		Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE);
	    Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE);
		Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE);
		float GetXParency(int mtlNum=0, BOOL backFace=FALSE);
		float GetShininess(int mtlNum=0, BOOL backFace=FALSE);		
		float GetShinStr(int mtlNum=0, BOOL backFace=FALSE);
		float WireSize(int mtlNum=0, BOOL backFace=FALSE);
				
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		
		void Shade(ShadeContext& sc);
		float EvalDisplacement(ShadeContext& sc); 
		Interval DisplacementValidity(TimeValue t); 
		void Update(TimeValue t, Interval& valid);
		void Reset();
		Interval Validity(TimeValue t);
		
		Class_ID ClassID() {return M3MatClassID; }
		SClass_ID SuperClassID() {return MATERIAL_CLASS_ID;}
		void GetClassName(TSTR& s) {s=GetString(IDS_MORPHMTL);}  

		void DeleteThis() {delete this;}	

		// Methods to access sub-materials of meta-materials
	   	int NumSubMtls() {return 101;}
		Mtl* GetSubMtl(int i) {return mTex[i];}
		void SetSubMtl(int i, Mtl *m) {
			ReplaceReference(i,m);
			if (dlg) dlg->UpdateSubMtlNames();
			}

		TSTR GetSubMtlSlotName(int i) {
			if(i==100) return GetString(IDS_MTL_BASENAME);

			char s[25];
			if(morphp) sprintf(s,"Mtl %i (%s)",i+1,morphp->chanBank[i].mName);
			else sprintf(s,GetString(IDS_MTL_MAPNAME),i+1);
			if(i<101) return s;

			return _T("x");
		}


		int NumSubs() {return 101;} 
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;}

		// From ref
 		int NumRefs() {return 103;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		
		int RenderBegin(TimeValue t, ULONG flags) {	
			if(flags!=RENDERBEGIN_IN_MEDIT) inRender = TRUE;
			return 1; 	
			}
		int RenderEnd(TimeValue t) { 	
			inRender = FALSE;	
			return 1; 	
			}


		// IO
		IOResult Save(ISave *isave); 
		IOResult Load(ILoad *iload); 
	};

// Used for picking a morph modifier from the Morph Material
class GetMorphMod : 
		public PickObjectProc
{
	public:				
		M3Mat *mp;

		BOOL isPicking;

		GetMorphMod() {
			mp=NULL;
			isPicking=FALSE;
		}

		BOOL  Pick(INode *node);		
		BOOL  Filter(INode *node);

		void  EnterMode();
		void  ExitMode();		
	};

static GetMorphMod theModPickmode;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_channel.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_channel.cpp
 |			Weighted Morpher for MAX R3
 |			Stuff for channel management
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 15-10-98
 | 
\*===========================================================================*/

#include "wM3.h"

// Construct the class with defaults
morphChannel::morphChannel()
{
	nPts = 0;
	nmPts = 0;
	mPoints = NULL;
	mWeights = NULL;
	mDeltas = NULL;
	mOptdata = NULL;
	mSel.ClearAll();
	//mSel.SetSize(0,0);
	mSel = NULL;
	mConnection = NULL;
	// default name '-empty-'
	mName = _T(GetString(IDS_EMPTY_CHANNEL));
	// channel starts 'inactive'
	mActive = FALSE;
	// channel value limits defaults
	mSpinmin = 0.0f;
	mSpinmax = 100.0f;
	mUseLimit = FALSE;
	mUseSel = FALSE;
	cblock = NULL;
	mModded = FALSE;
	mInvalid = FALSE;
	mActiveOverride = TRUE;
}

morphChannel::~morphChannel()
{
	if(mPoints) delete [] mPoints;
	if(mWeights) delete [] mWeights;
	if(mOptdata) delete [] mOptdata;
	if(mDeltas) delete [] mDeltas;
	mConnection = NULL;
	cblock = NULL;

	mSel.ClearAll();
//	mSel.SetSize(0,0);
}


void morphChannel::ResetMe()
{
	if(mPoints) delete [] mPoints;
	if(mWeights) delete [] mWeights;
	if(mOptdata) delete [] mOptdata;
	if(mDeltas) delete [] mDeltas;
	nPts = 0;
	nmPts = 0;
	mPoints = NULL;
	mWeights = NULL;
	mDeltas = NULL;
	mOptdata = NULL;
	mSel.ClearAll();
//	mSel.SetSize(0,0);
	mConnection = NULL;
	mName = _T(GetString(IDS_EMPTY_CHANNEL));
	mActive = FALSE;
	mSpinmin = 0.0f;
	mSpinmax = 100.0f;
	mUseLimit = FALSE;
	mUseSel = FALSE;
	cblock = NULL;
	mModded = FALSE;
	mInvalid = FALSE;
	mActiveOverride = TRUE;
}


void morphChannel::AllocBuffers( int sizeA, int sizeB )
{
	if(mPoints) delete [] mPoints;
	if(mWeights) delete [] mWeights;
	if(mDeltas) delete [] mDeltas;

	if(mOptdata) delete [] mOptdata;

	mPoints = new Point3[sizeA];
	mWeights = new double[sizeA];
	mDeltas = new Point3[sizeA];

	mOptdata = new int[sizeB];
}


// Do some rough calculations about how much space this channel
// takes up
// This isn't meant to be fast or terribly accurate!
float morphChannel::getMemSize()
{
	float msize = 0.0f;
	msize += (sizeof(Point3)*nPts);	// morphable points
	msize += (sizeof(Point3)*nPts);	// delta points
	msize += (sizeof(double)*nPts);	// Weighting points
	msize += (sizeof(int)*nmPts);	// Optimization data
	return msize;
}


// This = operator does everythinig BUT transfer paramblock references
morphChannel& morphChannel::operator=(morphChannel& from)
{
	// Don't allow self->self assignment
	if(&from == this)
		return (*this);

	int i;
	int s_nPts,s_nmPts;

	s_nPts = from.nPts;
	s_nmPts = from.nmPts;

	nPts = s_nPts;
	nmPts = s_nmPts;

	// Delete and reassign arrays
	if(mPoints) delete [] mPoints;
	if(mDeltas) delete [] mDeltas;
	if(mWeights) delete [] mWeights;
	if(mOptdata) delete [] mOptdata;

	mPoints = new Point3[s_nPts];
	mDeltas = new Point3[s_nPts];
	mWeights = new double[s_nPts];
	mOptdata = new int[s_nmPts];

	for(i = 0;i<s_nPts;i++)
	{
		mPoints[i] = from.mPoints[i];
		mDeltas[i] = from.mDeltas[i];
		mWeights[i] = from.mWeights[i];
	}
	for(i = 0;i<s_nmPts;i++)
	{
		mOptdata[i] = from.mOptdata[i];
	}

	mSel = from.mSel;
	mConnection = from.mConnection;

	mActive = from.mActive;
	mModded = from.mModded;
	mUseLimit = from.mUseLimit;
	mUseSel = from.mUseSel;
	mSpinmin = from.mSpinmin;
	mSpinmax = from.mSpinmax;
	mInvalid = from.mInvalid;
	mActiveOverride = from.mActiveOverride;

	TSTR trans3Name (from.mName);
	mName = trans3Name;

	mp = mp;

	return (*this);
}



// Reconstruct the optimization malarky using the current channel's point info
void morphChannel::rebuildChannel()
{
	int x,id = 0;
	Point3 DeltP;
	double wtmp;
	Point3 tVert;

	int tPc = nPts;
	if(tPc!=mp->MC_Local.Count) goto CantLoadThis;
	if(!mp->MC_Local.CacheValid) goto CantLoadThis;

	mInvalid = FALSE;

	nmPts = 0;

	for(x=0;x<tPc;x++)
	{
		tVert = mPoints[x];
		wtmp = mWeights[x];

		// Is this vertex different from the original mesh?
		if(
			(tVert.x!=mp->MC_Local.oPoints[x].x)||
			(tVert.y!=mp->MC_Local.oPoints[x].y)||
			(tVert.z!=mp->MC_Local.oPoints[x].z)||
			(wtmp!=mp->MC_Local.oWeights[x])
			)
		{
			mOptdata[id] = x;
			nmPts++;
			id++;
		}

			// calculate the delta cache
			DeltP.x=(tVert.x-mp->MC_Local.oPoints[x].x)/100.0f;
			DeltP.y=(tVert.y-mp->MC_Local.oPoints[x].y)/100.0f;
			DeltP.z=(tVert.z-mp->MC_Local.oPoints[x].z)/100.0f;
			mDeltas[x] = DeltP;

	}

	CantLoadThis:
	tPc=0;
}

// Generate all the optimzation and geometry data
void morphChannel::buildFromNode( INode *node , BOOL resetTime, TimeValue t )
{
	if(resetTime) t = GetCOREInterface()->GetTime();

	ObjectState os = node->EvalWorldState(t);

	int tPc = os.obj->NumPoints();
	int x,id = 0;
	Point3 DeltP;
	double wtmp;
	Point3 tVert;

	if(tPc!=mp->MC_Local.Count) goto CantLoadThis;
	if(!mp->MC_Local.CacheValid) goto CantLoadThis;


	mInvalid = FALSE;

	// if the channel hasn't been edited yet, change the 'empty'
	// name to that of the chosen object.
	if( !mModded ) mName = node->GetName();

	// Set the data into the morphChannel
	mActive = TRUE;
	mModded = TRUE;

	
	// Prepare the channel
	AllocBuffers(tPc, tPc);
	mSel.SetSize(tPc);
	mSel.ClearAll();

	nPts = 0;
	nmPts = 0;


	for(x=0;x<tPc;x++)
	{
		tVert = os.obj->GetPoint(x);
		wtmp = os.obj->GetWeight(x);

		// Is this vertex different from the original mesh?
		if(
			(tVert.x!=mp->MC_Local.oPoints[x].x)||
			(tVert.y!=mp->MC_Local.oPoints[x].y)||
			(tVert.z!=mp->MC_Local.oPoints[x].z)||
			(wtmp!=mp->MC_Local.oWeights[x])
			)
		{
			mOptdata[id] = x;
			nmPts++;
			id++;
		}

			// calculate the delta cache
			DeltP.x=(tVert.x-mp->MC_Local.oPoints[x].x)/100.0f;
			DeltP.y=(tVert.y-mp->MC_Local.oPoints[x].y)/100.0f;
			DeltP.z=(tVert.z-mp->MC_Local.oPoints[x].z)/100.0f;
			mDeltas[x] = DeltP;

			mWeights[x] = os.obj->GetWeight(x);
			mSel.Set( x, os.obj->IsPointSelected(x)?1:0);

			mPoints[x] = tVert;
			nPts++;
	}


	// Update *everything*
	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	mp->Update_channelFULL();
	mp->Update_channelParams();

	CantLoadThis:
	tPc=0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_core.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_core.cpp
 |			Weighted Morpher for MAX R3
 |			ModifyObject
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 27-8-98
 | 
\*===========================================================================*/

#include "wM3.h"

void MorphR3::ModifyObject(TimeValue t, ModContext &mc, ObjectState * os, INode *node) 
{
	// This will see if the local cached object is valid and update it if not
	// It will now also call a full channel rebuild to make sure their deltas are
	// accurate to the new cached object
	if(!MC_Local.AreWeCached())
	{
		UI_MAKEBUSY

		MC_Local.MakeCache(os->obj);

		for(int i=0;i<100;i++)
		{
			if(chanBank[i].mActive)
			{
				chanBank[i].rebuildChannel();
			}
		}

		UI_MAKEFREE
	}

	Interval valid=FOREVER;


	// AUTOLOAD
	int itmp; 
	pblock->GetValue(PB_CL_AUTOLOAD, 0, itmp, valid);

	if(itmp==1)
	{
			for(int k=0;k<100;k++)
			{
				if(chanBank[k].mConnection)
					chanBank[k].buildFromNode(chanBank[k].mConnection,FALSE,t);
			}
	}



	// Get count from host
	int hmCount = os->obj->NumPoints();

	int i,x,k,mIndex;
	// to hold percentage
	float mPct;

	// some worker variables
	float deltX,deltY,deltZ;
	float tmX,tmY,tmZ;
	Point3 vert,mVert,fVert;
	double weight,deltW,decay;

	// These are our morph deltas / point
	// They get built by cycling through the points and generating
	// the difference data, summing it into these tables and then
	// appling the changes at the end.
	// This will leave us with the total differences per point on the 
	// local mesh. We can then rip through and apply them quickly
	float *difX = new float[hmCount];
	float *difY = new float[hmCount];
	float *difZ = new float[hmCount];
	double *wgts = new double[hmCount];

	// this is the indicator of what points on the host
	// to update after all deltas have been summed
	BitArray PointsMOD(hmCount);
	PointsMOD.ClearAll();

	int glUsesel;
	pblock->GetValue( PB_OV_USESEL, t, glUsesel, valid);

	BOOL glUseLimit; float glMAX,glMIN;
	pblock->GetValue( PB_OV_USELIMITS, t, glUseLimit, valid);
	pblock->GetValue( PB_OV_SPINMAX, t, glMAX, valid);
	pblock->GetValue( PB_OV_SPINMIN, t, glMIN, valid);

	// --------------------------------------------------- MORPHY BITS
	// cycle through channels, searching for ones to use
	for(i=0;i<100;i++){

		if( chanBank[i].mActive )
		{
			// temp fix for diff. pt counts
			if(chanBank[i].nPts!=hmCount) 
			{
				chanBank[i].mInvalid = TRUE;
				continue;
			};

			
			// This channel is considered okay to use
			chanBank[i].mInvalid = FALSE;

			
			// Is this channel flagged as inactive?
			if(chanBank[i].mActiveOverride==FALSE) continue;


			// get morph percentage for this channel
			chanBank[i].cblock->GetValue(0,t,mPct,valid);

			// Clamp the channel values to the limits
			if(chanBank[i].mUseLimit||glUseLimit)
			{
				int Pmax;
				int Pmin;
				if(glUseLimit)
				{
					Pmax = glMAX; Pmin = glMIN;
				}
				else
				{
					Pmax = chanBank[i].mSpinmax;
					Pmin = chanBank[i].mSpinmin;
				}
				

				if(mPct>Pmax) mPct = Pmax;
				if(mPct<Pmin) mPct = Pmin;
			}

			// cycle through all morphable points, build delta arrays
			for(x=0;x<chanBank[i].nmPts;x++)
			{
				// this is the point to morph on the object
				mIndex = chanBank[i].mOptdata[x];
				
				if(chanBank[i].mSel[mIndex]||(!chanBank[i].mUseSel&&glUsesel==0))
				{

					// get the points to morph between
					//vert = os->obj->GetPoint(mIndex);
					//weight = os->obj->GetWeight(mIndex);
					vert = MC_Local.oPoints[mIndex];
					weight = MC_Local.oWeights[mIndex];

					// Get softselection, if applicable
					decay = 1.0f;
					if(os->obj->GetSubselState()!=0) decay = os->obj->PointSelection(mIndex);

					tmX = vert.x;
					tmY = vert.y;
					tmZ = vert.z;

					mVert = chanBank[i].mPoints[mIndex];

					// Add the previous point data into the delta table
					// if its not already been done
					if(!PointsMOD[mIndex])
					{
						difX[mIndex]=vert.x;
						difY[mIndex]=vert.y;
						difZ[mIndex]=vert.z;
						wgts[mIndex]=weight;
					}
		
					// calculate the differences
					// decay by the weighted vertex amount, to support soft selection
					deltX=((chanBank[i].mDeltas[mIndex].x)*mPct)*decay;
					deltY=((chanBank[i].mDeltas[mIndex].y)*mPct)*decay;
					deltZ=((chanBank[i].mDeltas[mIndex].z)*mPct)*decay;
					deltW=(chanBank[i].mWeights[mIndex]-weight)/100.0f*(double)mPct;

					difX[mIndex]+=deltX;
					difY[mIndex]+=deltY;
					difZ[mIndex]+=deltZ;
					wgts[mIndex]+=deltW;

					// We've modded this point
					PointsMOD.Set(mIndex);

				} // msel check

			} // nmPts cycle

		}

	}


	// Cycle through all modified points and apply delta arrays
	for(k=0;k<hmCount;k++)
	{
		if(PointsMOD[k]&&(MC_Local.sel[k]||os->obj->GetSubselState()==0))
		{
			fVert.x = difX[k];
			fVert.y = difY[k];
			fVert.z = difZ[k];
			os->obj->SetPoint(k,fVert);
			os->obj->SetWeight(k,wgts[k]);
		}


		// Captain Hack Returns...
		// Support for saving of modifications to a channel
		// Most of this is just duped from buildFromNode (delta/point/calc)
		if (recordModifications)
		{
			int tChan = recordTarget;

			int tPc = hmCount;

			// Prepare the channel
			chanBank[tChan].AllocBuffers(tPc, tPc);
			chanBank[tChan].nPts = 0;
			chanBank[tChan].nmPts = 0;

			int id = 0;
			Point3 DeltP;
			double wtmp;
			Point3 tVert;

			for(int x=0;x<tPc;x++)
			{

				if(PointsMOD[x])
				{
					tVert.x = difX[x];
					tVert.y = difY[x];
					tVert.z = difZ[x];

					wtmp = wgts[x];
				}
				else
				{
					tVert = os->obj->GetPoint(x);
					wtmp = os->obj->GetWeight(x);
				}


				// Is this vertex different from the original mesh?
				if(
					(tVert.x!=MC_Local.oPoints[x].x)||
					(tVert.y!=MC_Local.oPoints[x].y)||
					(tVert.z!=MC_Local.oPoints[x].z)||
					(wtmp!=MC_Local.oWeights[x])
					)
				{
					chanBank[tChan].mOptdata[id] = x;
					chanBank[tChan].nmPts++;
					id++;
				}

					// calculate the delta cache
					DeltP.x=(tVert.x-MC_Local.oPoints[x].x)/100.0f;
					DeltP.y=(tVert.y-MC_Local.oPoints[x].y)/100.0f;
					DeltP.z=(tVert.z-MC_Local.oPoints[x].z)/100.0f;
					chanBank[tChan].mDeltas[x] = DeltP;

					chanBank[tChan].mWeights[x] = wtmp;

					chanBank[tChan].mPoints[x] = tVert;
					chanBank[tChan].nPts++;
			}

			recordModifications = FALSE;
			recordTarget = 0;
			chanBank[tChan].mInvalid = FALSE;

		}
		// End of record

	}

	// clean up
	if(difX) delete [] difX;
	if(difY) delete [] difY;
	if(difZ) delete [] difZ;
	if(wgts) delete [] wgts;

	if(itmp==1) valid = Interval(t,t);

	// Update all the caches etc
	os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);
	os->obj->PointsWereChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_cache.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_cache.cpp
 |			Weighted Morpher for MAX R3
 |			MorphCache class
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 3-10-98
 | 
\*===========================================================================*/

#include "wM3.h"


void morphCache::NukeCache()
{
	if(oPoints) delete [] oPoints;
	oPoints = NULL;
	if(oWeights) delete [] oWeights;
	oWeights = NULL;

	sel.SetSize(0,0);
	sel.ClearAll();

	CacheValid = FALSE;
}

void morphCache::MakeCache(Object *obj)
{
	Count = obj->NumPoints();
	oPoints = new Point3[Count];
	oWeights = new double[Count];

	sel.SetSize(Count);
	sel.ClearAll();

	for(int t=0;t<Count;t++)
	{
		oPoints[t] = obj->GetPoint(t);
		oWeights[t] = obj->GetWeight(t);
		
		sel.Set( t, (obj->PointSelection(t)>0.0f)?1:0 );
	}

	CacheValid = TRUE;
}

BOOL morphCache::AreWeCached()
{
	return CacheValid;
}

morphCache::morphCache()
{
	CacheValid	= FALSE;
	oPoints		= NULL;
	oWeights	= NULL;
	Count = 0;
	sel.SetSize(0,0);
	sel.ClearAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_dlg-fns.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_dlg-fns.cpp
 |			Weighted Morpher for MAX R3
 |			Functions to update and refresh chunks of the UI
 |			Seperated here to make my job easier to maintain 'em!
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 16-9-98
 | 
\*===========================================================================*/

#include "wM3.h"


// Clamp the channel number (0-90)
void MorphR3::Clamp_chanNum()
{
	if(chanNum<0) chanNum = 0;
	if(chanNum>=90) chanNum = 90;
}

// Handle the scroll bar
void MorphR3::VScroll(int code, short int cpos ) {
	switch (code) {
		case SB_LINEUP: 	chanNum--;		break;
		case SB_LINEDOWN:	chanNum++;		break;
		case SB_PAGEUP:		chanNum -= 10;	break;
		case SB_PAGEDOWN:	chanNum += 10;	break;
		
		case SB_THUMBPOSITION: 
		case SB_THUMBTRACK:
			chanNum = cpos;
			break;
		}

	// Check for out-of-bounds values
	Clamp_chanNum();
	
	// Reposition the scrollbar
	HWND vScr = GetDlgItem(hwChannelList,IDC_LISTSCROLL);
	SetScrollPos((HWND)vScr, SB_CTL, chanNum, TRUE); 

	markerSel = -1;

	// Update everything
	Update_channelFULL();
	Update_channelParams();
	}


void MorphR3::Update_colorIndicators()
{
	if(hwChannelList)
	{
		Rect rect;
		RECT out;
		GetClientRectP(GetDlgItem(hwChannelList,IDC_I1),&rect);
		out.left = rect.left-1;
		out.top = rect.top-1;
		GetClientRectP(GetDlgItem(hwChannelList,IDC_I10),&rect);
		out.right = rect.left+rect.w()+1;
		out.bottom = rect.top+rect.h()+1;

		InvalidateRect(hwChannelList,&out,FALSE);
	}
}

// Update the names of all the morph channels
void MorphR3::Update_channelNames()
{
	if(hwChannelList)
	{
		ICustButton *iTmp;
		int i,tIdx = 0;

		for( i=IDC_P1;i<IDC_P10+1;i++){
			iTmp = GetICustButton(GetDlgItem(hwChannelList,i));
			iTmp->SetText(chanBank[chanNum+tIdx].mName);
			iTmp->SetCheck( (i-IDC_P1 == chanSel) );
			ReleaseICustButton(iTmp);
			tIdx++;
		}
		iTmp = NULL;
	}
}



float MorphR3::TrimDown( float value, int decimalpts )
{
	// changed to sprintf conversion, for consistency
	// my original method was slower and introduced ~0.01 rounding errors
	// which make the values flicker during animation playback
	sprintf(trimD," %.1f    ",value);
	return atof(trimD);
	/*
	float tempfl;
	float powC = (float)pow(10,decimalpts);
	value*=powC;
	tempfl=(float)floor(value);
	tempfl/=powC;
	return tempfl;
	*/
}

// Update the spinners for each channel
void MorphR3::Update_channelValues()
{
	if(hwChannelList)
	{
		TimeValue t = ip->GetTime();

		float tmp; Interval valid = FOREVER; int i;
		for( i=0; i<10; i++ )
		{
			chanBank[chanNum+i].cblock->GetValue(0, t, tmp, valid);
			BOOL kbON = chanBank[chanNum+i].cblock->KeyFrameAtTime(0,t);
			chanSpins[i]->SetKeyBrackets(kbON);
			chanSpins[i]->SetValue(TrimDown(tmp,1),FALSE);
		}
	}
}

// Update the channel bank range
void MorphR3::Update_channelInfo()
{
	if(hwChannelList)
	{
		char s[15];
		sprintf(s, "%d - %d", chanNum+1,chanNum+10);
		SetWindowText(GetDlgItem(hwChannelList,IDC_PAGE),s);

		int tmp; Interval valid = FOREVER;

		pblock->GetValue(PB_CL_AUTOLOAD, 0, tmp, valid);
		SetCheckBox(hwChannelList,IDC_AUTOLOAD,tmp?TRUE:FALSE);
	}
}

void MorphR3::Update_channelLimits()
{
	if(hwChannelList)
	{
		TimeValue t = ip->GetTime();
		float tmp,min,max; Interval valid = FOREVER;
		float gmin,gmax; int i;

		pblock->GetValue(PB_OV_SPINMIN, t, gmin, valid);
		pblock->GetValue(PB_OV_SPINMAX, t, gmax, valid);

		for( i=0; i<10; i++ )
		{
			min = -999.0f;
			max = 999.0f;

			if(chanBank[chanNum+i].mUseLimit)
			{
				min = chanBank[chanNum+i].mSpinmin;
				max = chanBank[chanNum+i].mSpinmax;
			}

			pblock->GetValue(PB_OV_USELIMITS, t, tmp, valid);
			if(tmp)
			{
				// Set to globals
				min = gmin;
				max = gmax;
			}

			chanSpins[i]->SetLimits(min,max,FALSE);
		}
	}
}

// Update the markers list
void MorphR3::Update_channelMarkers()
{
	if(hwChannelList)
	{
		HWND hwMarker	= GetDlgItem(hwChannelList,IDC_MARKERLIST);
		HWND hwSave		= GetDlgItem(hwChannelList,IDC_SAVEMARKER);
		HWND hwDel		= GetDlgItem(hwChannelList,IDC_DELMARKER);

		// Reset the channel marker
		SendMessage(hwMarker,CB_RESETCONTENT,0,0);

		// Add the bookmark names to the dropdown
		for( int i=0; i<markerName.Count(); i++ )
		{
			SendMessage(hwMarker,CB_ADDSTRING,0,(LPARAM) (LPCTSTR) markerName[i]);
		}

		// Set the current selection
		SendMessage(hwMarker,CB_SETCURSEL ,(WPARAM)markerSel,0);

		BOOL sEn = FALSE;
		BOOL dEn = FALSE;

		char tm[256];
		GetWindowText(hwMarker,tm,255);
		if(stricmp(tm,"")!=0)
		{	
			sEn=TRUE;
			dEn=FALSE;
		}

		if( markerSel != -1 )
		{
			dEn = TRUE;		
			sEn = FALSE;
		}

		EnableWindow(hwSave,sEn);
		EnableWindow(hwDel,dEn);
	}
}

// Call all the above
void MorphR3::Update_channelFULL()
{
	if(hwChannelList)
	{
		Clamp_chanNum();

		Update_colorIndicators();
		Update_channelNames();
		Update_channelValues();
		Update_channelInfo();
		Update_channelLimits();
		Update_channelMarkers();

		// Reposition the scrollbar
		HWND vScr = GetDlgItem(hwChannelList,IDC_LISTSCROLL);
		SetScrollPos((HWND)vScr, SB_CTL, chanNum, TRUE); 
	}
}

// Evalulate the increments value to a fp value
float MorphR3::GetIncrements()
{
	int idTmp; float flRes;
	pblock->GetValue(PB_AD_VALUEINC, 0, idTmp, FOREVER);
	if(idTmp==0) flRes = 5.0f;
	if(idTmp==1) flRes = 1.0f;
	if(idTmp==2) flRes = 0.1f;

	return flRes;
}


// Updates the scaling on all relevent spinners
void MorphR3::Update_SpinnerIncrements()
{
	if(hwChannelParams)
	{
		float flRes = GetIncrements();

		cSpinmin->SetScale(flRes);
		cSpinmax->SetScale(flRes);

		for(int i=0;i<10;i++)
			chanSpins[i]->SetScale(flRes);

		glSpinmax->SetScale(flRes);
		glSpinmin->SetScale(flRes);
	}
}


// Update the channel parameters page
void MorphR3::Update_channelParams()
{
	if(hwChannelParams)
	{
		Interval valid = FOREVER; int tempV2,tempV3; 
		TimeValue t = ip->GetTime();

		pblock->GetValue(PB_OV_USELIMITS,t,tempV2,valid);
		pblock->GetValue(PB_OV_USESEL,t,tempV3,valid);


		ICustEdit *cName = NULL;

		cName = GetICustEdit(GetDlgItem(hwChannelParams,IDC_CHANNAME));
		cName->SetText( chanBank[chanNum+chanSel].mName );

		char s[5]; sprintf(s,"%i",chanNum+chanSel+1);
		SetWindowText( GetDlgItem(hwChannelParams,IDC_CHANNUM), s);

		// load the current channel
		morphChannel *curTmp = &chanBank[chanNum+chanSel];

		// Setup the min/max stuff
		SetCheckBox(hwChannelParams,IDC_LIMIT, curTmp->mUseLimit );
		EnableWindow(GetDlgItem(hwChannelParams,IDC_LIMIT),!tempV2);

		cSpinmin->SetLimits(-999.9f,curTmp->mSpinmax,FALSE);
		cSpinmax->SetLimits(curTmp->mSpinmin,999.9f,FALSE);

		cSpinmin->SetValue(curTmp->mSpinmin,FALSE);
		cSpinmin->SetScale(GetIncrements());

		cSpinmax->SetValue(curTmp->mSpinmax,FALSE);
		cSpinmax->SetScale(GetIncrements());

		if(tempV2) cSpinmax->Disable();
		else cSpinmax->Enable();
		if(tempV2) cSpinmin->Disable();
		else cSpinmin->Enable();


		ReleaseICustEdit(cName);
	
		// Use selection button
		ICustButton *iTmp;

		iTmp = GetICustButton(GetDlgItem(hwChannelParams,IDC_USESEL));

		if(curTmp->mUseSel) iTmp->SetCheck(TRUE);
		else iTmp->SetCheck(FALSE);

		ReleaseICustButton(iTmp);


		// Update target button
		HWND updTmp = GetDlgItem(hwChannelParams,IDC_UPDATETARGET);
		HWND delTmp = GetDlgItem(hwChannelParams,IDC_DELETE);
		HWND makeTmp = GetDlgItem(hwChannelParams,IDC_MAKE);
		HWND vselTmp = GetDlgItem(hwChannelParams,IDC_USESEL);
		HWND xtractTmp = GetDlgItem(hwChannelParams,IDC_EXTRACT);


		SetCheckBox(hwChannelParams,IDC_USECHAN, curTmp->mActiveOverride );



		// Is channel active?
		if( curTmp->mActive ) 
		{
			SetWindowText( delTmp,GetString(IDS_DEL_ON) );
			EnableWindow( delTmp, TRUE);
			EnableWindow( xtractTmp, TRUE);

			iTmp = GetICustButton(vselTmp);
			iTmp->Enable();
			ReleaseICustButton(iTmp);

			iTmp = GetICustButton(makeTmp);
			iTmp->Disable();
			ReleaseICustButton(iTmp);
		}
		else {
			SetWindowText( delTmp,GetString(IDS_DEL_OFF) );
			EnableWindow( delTmp, FALSE);
			EnableWindow( xtractTmp, FALSE);

			iTmp = GetICustButton(vselTmp);
			iTmp->Disable();
			ReleaseICustButton(iTmp);

			iTmp = GetICustButton(makeTmp);
			iTmp->Enable();
			ReleaseICustButton(iTmp);
		}

		// Have we got a connection?
		if( curTmp->mConnection != NULL ) 
		{
			SetWindowText( updTmp, GetString(IDS_UPD_ON) );
			EnableWindow( updTmp, TRUE);
			EnableWindow( xtractTmp, FALSE);

			iTmp = GetICustButton(makeTmp);
			iTmp->Disable();
			ReleaseICustButton(iTmp);
		}
		else {
			SetWindowText( updTmp, GetString(IDS_UPD_OFF) );
			EnableWindow( updTmp, FALSE);
		}


		iTmp = GetICustButton(GetDlgItem(hwChannelParams,IDC_USESEL));
		if(tempV3) iTmp->Disable();
		else iTmp->Enable();
		ReleaseICustButton(iTmp);

	}
}


// swap/move a channel
void MorphR3::ChannelOp(int targ, int src, int flags)
{
	if(flags==OP_MOVE)
	{
		chanBank[targ].ResetMe();
		chanBank[targ] = chanBank[src];
		
		ReplaceReference(1+targ,chanBank[src].cblock->Clone());
		/*-----------------------------------------------------*/

		morphChannel mChan;
		mChan.ResetMe();

		chanBank[src] = mChan;

		// Reassign paramblock info
		ParamBlockDescID *channelParams = new ParamBlockDescID[1];

		ParamBlockDescID add;
		add.type=TYPE_FLOAT;
		add.user=NULL;
		add.animatable=TRUE;
		add.id=1;
		channelParams[0] = add;

		MakeRefByID(FOREVER, 1+src, CreateParameterBlock(channelParams,1,1));	
		assert(chanBank[src].cblock);

		Control *c = (Control*)CreateInstance(CTRL_FLOAT_CLASS_ID,GetDefaultController(CTRL_FLOAT_CLASS_ID)->ClassID());

		chanBank[src].cblock->SetValue(0,0,0.0f);
		chanBank[src].cblock->SetController(0,c);

		delete channelParams;
	}

	if(flags==OP_SWAP)
	{
		IParamBlock *tempBlock = (IParamBlock*)chanBank[targ].cblock->Clone();

		morphChannel mcTmp;
		mcTmp = chanBank[targ];
		
		chanBank[targ] = chanBank[src];
		ReplaceReference(1+targ,chanBank[src].cblock->Clone());

		chanBank[src] = mcTmp;
		ReplaceReference(1+src,tempBlock);
	}

	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_dlg.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_dlg.cpp
 |			Weighted Morpher for MAX R3
 |			UI Handler and management code for main dialogs
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 22-5-98
 | 
\*===========================================================================*/

#include "wM3.h"



/*===========================================================================*\
 |
 | Channel List Rollout
 |
\*===========================================================================*/

class getMulti : public HitByNameDlgCallback
{
public:
	MorphR3 *mp;

	getMulti(MorphR3 *mpi) {mp=mpi;}

	TCHAR		*dialogTitle()			{ return GetString(IDS_LOADMULTI);	}
	TCHAR		*buttonText() 			{ return GetString(IDS_MULTIBTN);	}
	BOOL		singleSelect()			{ return FALSE;						}	
	BOOL		useFilter()				{ return TRUE;						}	
	BOOL		useProc()				{ return TRUE;						}
	BOOL		doCustomHilite()		{ return TRUE;						}
	BOOL		doHilite(INode *node)	{ return FALSE;						}
	BOOL		showHiddenAndFrozen()	{ return TRUE;						}

	void proc(INodeTab &nodeTab)
	{
		int i;
		Tab<int>	freeC;
		freeC.ZeroCount();


		// find available channels
		for(i=0;i<100;i++)
		{
			int tI = i;
			if(!mp->chanBank[i].mModded) freeC.Append(1,&tI,0);
		}

		// If there are less channels than incoming targets, tell the user and quit out
		if(nodeTab.Count()>freeC.Count())
		{
			TSTR buf1(GetString(IDS_NOFREE));
			TSTR buf2(GetString(IDS_CANNOT));
			MessageBox(mp->hwChannelList,buf1,buf2,MB_ICONSTOP | MB_OK);
			goto leapOut;
		}

		// Do the assignment of nodes
		for(i=0;i<nodeTab.Count();i++)
		{
			UI_MAKEBUSY

			mp->ReplaceReference(101+freeC[i],nodeTab[i]);
			mp->chanBank[freeC[i]].buildFromNode(nodeTab[i]);

			UI_MAKEFREE
		}

		leapOut:
		i=0;
	}

	int filter(INode *node)
	{
		Interval valid; 
		
		ObjectState os = node->GetObjectRef()->Eval(mp->ip->GetTime());

		if( os.obj->IsDeformable() == FALSE ) return FALSE;

		// Check for same-num-of-verts-count
		if( os.obj->NumPoints()!=mp->MC_Local.Count) return FALSE;

		node->BeginDependencyTest();
		mp->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if (node->EndDependencyTest()) {		
			return FALSE;
		} else {
			return TRUE;
			
			}
	}
};

// menu ID commands for dynamic popup
#define ID_PICKFROMSCENE 5
#define ID_DELETECHANNEL 6
#define ID_RELOADCHANNEL 7

BOOL CALLBACK ChannelList_DlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	MorphR3 *mp = (MorphR3*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mp && msg!=WM_INITDIALOG) return FALSE;
	int id = LOWORD(wParam);
	int notify = HIWORD(wParam);


	switch (msg) {
	
		// Paint the little color boxes next to the buttons (color indicators)
		case WM_PAINT:
		{
			PAINTSTRUCT ps;
			BeginPaint(hWnd,&ps);
			int q;
			for( q=0;q<10;q++ )
			{
				// Get next CI
				HWND item = GetDlgItem(hWnd,(IDC_I1+q));
				Rect rect;
				GetClientRect(item,&rect);
				HDC hdc = GetDC(item);
				
				// choose the indicator colour
				COLORREF FilCol;
				FilCol = GetSysColor(COLOR_3DFACE);
				if(mp->chanBank[q+mp->chanNum].mModded==TRUE) FilCol = RGB(255,160,0);
				if(mp->chanBank[q+mp->chanNum].mActive==TRUE) FilCol = RGB(0,255,0);
				if(mp->chanBank[q+mp->chanNum].mActive==TRUE&&mp->chanBank[q+mp->chanNum].mConnection==FALSE) FilCol = RGB(10,10,255);
	
				if(mp->chanBank[q+mp->chanNum].mInvalid==TRUE||mp->chanBank[q+mp->chanNum].mActiveOverride==FALSE) FilCol = RGB(90,90,90);


				// Draw the button-y outline around the colour indicator
				Rect tR = rect;
				tR.right--;
				tR.bottom--;
				if( q == mp->chanSel ) Rect3D(hdc,tR,TRUE);
				else Rect3D(hdc,tR,FALSE);


				HPEN Pen = CreatePen( PS_SOLID , 1 , FilCol );
				SelectObject(hdc,Pen);
				LOGBRUSH BR;
				BR.lbStyle = BS_SOLID;
				BR.lbColor = FilCol;
				
				HBRUSH Brush = CreateBrushIndirect(&BR);
				SelectObject(hdc,Brush);


				Rectangle( hdc, 1,1,rect.w()-2,rect.h()-2);

				DeleteObject(Pen);
				DeleteObject(Brush);

			ReleaseDC(item,hdc);
			}

			EndPaint(hWnd,&ps);
		break;}

		case WM_INITDIALOG:{

			// Update the class pointer
			mp = (MorphR3*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mp->hwChannelList = hWnd;


			ICustButton *iTmp; ICustEdit *eTmp;
			int i,tIdx = 0;

			// Assign button configuration to the channel buttons
			for( i=IDC_P1;i<IDC_P10+1;i++){
				iTmp = GetICustButton(GetDlgItem(hWnd,i));
				iTmp->SetType(CBT_CHECK);
				iTmp->SetHighlightColor(RGB(210,210,210));
				iTmp->SetRightClickNotify(TRUE);

				if(tIdx==mp->chanSel) iTmp->SetCheck(TRUE);
				else iTmp->SetCheck(FALSE);

				iTmp->SetText(mp->chanBank[mp->chanNum+tIdx].mName);
				ReleaseICustButton(iTmp);
				tIdx++;
			}
			iTmp = NULL;


			// Print the channel range
			char s[15];
			sprintf(s, "%d - %d", mp->chanNum+1,mp->chanNum+10);
			SetWindowText(GetDlgItem(hWnd,IDC_PAGE),s);

			int itmp; Interval valid = FOREVER;

			mp->pblock->GetValue(PB_CL_AUTOLOAD, 0, itmp, valid);
			SetCheckBox(hWnd,IDC_AUTOLOAD,itmp?TRUE:FALSE);

			// Initialize the spinners
			// Get the value incrementation index, evaluate it and set the scale
			// when building the spinners
			float tmp; 
			for( i=0; i<10; i++ )
			{
				mp->chanBank[mp->chanNum+i].cblock->GetValue(0, mp->ip->GetTime(), tmp, valid);
				mp->chanSpins[i] = SetupFloatSpinner(hWnd, IDC_FS1+i, IDC_FE1+i, -999.9f, 999.9f, (float)tmp);
				mp->chanSpins[i]->SetScale(mp->GetIncrements());

				// Hack the leading values for the spinners (asthetics!)
				eTmp = GetICustEdit(GetDlgItem(hWnd,IDC_FE1+i));
				eTmp->SetLeading(1);
				ReleaseICustEdit(eTmp);
				eTmp=NULL;

				// Make those colour indicators ownerdraw only
				LONG style = GetWindowLong(GetDlgItem(hWnd,IDC_I1+i),GWL_STYLE);
				style &= ~(SS_BLACKFRAME);
				style |= SS_OWNERDRAW;
				SetWindowLong(GetDlgItem(hWnd,IDC_I1+i),GWL_STYLE,style);
			}


			// Setup the scroll bar to move the list
			HWND vScr = GetDlgItem(hWnd,IDC_LISTSCROLL);

			SCROLLINFO	si;
			memset(&si,0,sizeof(si)); 
			si.cbSize = sizeof(si); 
			si.fMask  = SIF_RANGE | SIF_POS; 
			si.nMin   = 0; 
			si.nMax   = 90; 
			si.nPos   = mp->chanNum; 
			SetScrollInfo((HWND)vScr, SB_CTL, &si, TRUE);    

			// do the channel limits & markers
			mp->Update_channelLimits();
			mp->Update_channelMarkers();

			break;
			}

		case WM_DESTROY:
			{
			for( int i=0; i<10; i++ ) ReleaseISpinner(mp->chanSpins[i]);
			break;
			}

		// Handle the scrolling
		case WM_VSCROLL:
				mp->VScroll(LOWORD(wParam),(short int)HIWORD(wParam));
			break;

		// Spinner change handling
		case CC_SPINNER_CHANGE:
			if (!theHold.Holding()) theHold.Begin();
			switch (LOWORD(wParam)) {

				// user changes a channel value
				case IDC_FS1: 
				case IDC_FS2: 
				case IDC_FS3: 
				case IDC_FS4: 
				case IDC_FS5: 
				case IDC_FS6: 
				case IDC_FS7: 
				case IDC_FS8: 
				case IDC_FS9: 
				case IDC_FS10: 
					int tIdx = LOWORD(wParam) - IDC_FS1;
					mp->chanBank[mp->chanNum+tIdx].cblock->SetValue( 0, mp->ip->GetTime(), mp->chanSpins[tIdx]->GetFVal() );

					/* mModded-ify this channel, if it isn't already
					if(!mp->chanBank[mp->chanNum+tIdx].mModded) 
					{
						mp->chanBank[mp->chanNum+tIdx].mModded = TRUE;
						mp->Update_colorIndicators();
					}*/

					mp->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
					mp->ip->RedrawViews(mp->ip->GetTime(),REDRAW_INTERACTIVE,NULL);
					break;
			}
			break;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			mp->ip->RedrawViews(mp->ip->GetTime(),REDRAW_BEGIN,NULL);
			break;	

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) theHold.Accept(GetString(IDS_PC_MORPH));
			else theHold.Cancel();
			mp->ip->RedrawViews(mp->ip->GetTime(),REDRAW_END,NULL);
			mp->Update_channelValues();
			break;



		case WM_COMMAND:
			switch(HIWORD(wParam)){

				// User clicks on marker window - disable or enable
				// the max keyboard accelerators
				case CBN_SETFOCUS :
					DisableAccelerators();
					break;
				case CBN_KILLFOCUS :
					EnableAccelerators();
					break;

				// User is changing a marker's name, or adding a new one
				case CBN_EDITCHANGE:
					mp->markerSel = -1;

					HWND hwMarker	= GetDlgItem(hWnd,IDC_MARKERLIST);
					HWND hwSave		= GetDlgItem(hWnd,IDC_SAVEMARKER);
					HWND hwDel		= GetDlgItem(hWnd,IDC_DELMARKER);

					BOOL sEn = FALSE;
					BOOL dEn = FALSE;

					char tm[256];
					GetWindowText(hwMarker,tm,255);
					if(stricmp(tm,"")!=0)
					{	
						sEn=TRUE;
						dEn=FALSE;
					}

					EnableWindow(hwSave,sEn);
					EnableWindow(hwDel,dEn);

					break;

			}

			if (notify==CBN_SELENDOK){
				if(id==IDC_MARKERLIST){
					int mkSel = SendMessage(GetDlgItem(hWnd, IDC_MARKERLIST), CB_GETCURSEL, 0, 0);
					if(mkSel>=0){
						mp->chanSel = 0;
						mp->chanNum = (mp->markerIndex[mkSel]);
						mp->markerSel = mkSel;

						// Refresh everything!
						mp->Update_channelFULL();
						mp->Update_channelParams();
					}
				}
			}

			switch (LOWORD(wParam)) {

			// Channel menu handlers
			// *---------------------------------------------*
			case ID_PICKFROMSCENE:
				thePickMode.mp  = mp;					
				mp->ip->SetPickMode(&thePickMode);
				break;

			case ID_DELETECHANNEL:{
					int cIndex = mp->chanNum+mp->chanSel;

					if (!theHold.Holding()) theHold.Begin();
					theHold.Put(new MCRestore(mp, cIndex));
					if(mp->chanBank[cIndex].mConnection) 
						mp->DeleteReference(101+cIndex);
						//mp->DeleteReference(1+cIndex);
					theHold.Accept(GetString(IDS_UNDOMCDEL));

					// Ask channel to reset itself
					mp->chanBank[cIndex].ResetMe();

					// Reassign paramblock info
					ParamBlockDescID *channelParams = new ParamBlockDescID[1];

					ParamBlockDescID add;
					add.type=TYPE_FLOAT;
					add.user=NULL;
					add.animatable=TRUE;
					add.id=1;
					channelParams[0] = add;

					mp->MakeRefByID(FOREVER, 1+cIndex, CreateParameterBlock(channelParams,1,1));	
					assert(mp->chanBank[cIndex].cblock);

					Control *c = (Control*)CreateInstance(CTRL_FLOAT_CLASS_ID,GetDefaultController(CTRL_FLOAT_CLASS_ID)->ClassID());

					mp->chanBank[cIndex].cblock->SetValue(0,0,0.0f);
					mp->chanBank[cIndex].cblock->SetController(0,c);

					delete channelParams;

					// Refresh system
					mp->Update_channelFULL();
					mp->Update_channelParams();	
					mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);
					mp->ip->RedrawViews(mp->ip->GetTime());
				break;}


			case ID_RELOADCHANNEL:
				{
				int idx = mp->chanNum+mp->chanSel;

				UI_MAKEBUSY

				if(mp->chanBank[idx].mConnection)
				{
					mp->chanBank[idx].buildFromNode(mp->chanBank[idx].mConnection);
				}
				else if(mp->chanBank[idx].mActive)
				{
					mp->chanBank[idx].rebuildChannel();
				}

				mp->NotifyDependents(FOREVER,PART_OBJ,REFMSG_CHANGE);
				mp->ip->RedrawViews(mp->ip->GetTime());

				UI_MAKEFREE
				break;}

			// *---------------------------------------------*


			// Save a channel list marker
			case IDC_SAVEMARKER:
				{
					HWND hwMarker	= GetDlgItem(hWnd,IDC_MARKERLIST);
					char tm[256];
					GetWindowText(hwMarker,tm,255);

					mp->markerName.AddName(tm);

					int tmp;
					tmp = mp->chanNum;
					mp->markerIndex.Append(1,&tmp,0);

					mp->markerSel = mp->markerName.Count()-1;
					mp->Update_channelMarkers();
				}
				break;
			// Delete a channel list marker
			case IDC_DELMARKER:
				{
					mp->markerName.Delete(mp->markerSel,1);
					mp->markerIndex.Delete(mp->markerSel,1);
					mp->Update_channelMarkers();
				}
				break;



			case IDC_LOADMULT:
				{
				getMulti ChooseMultiple((MorphR3*)mp);
				mp->ip->DoHitByNameDialog(&ChooseMultiple);

				// Refresh system
				mp->Update_channelFULL();
				mp->Update_channelParams();	
				mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
				mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);
				mp->ip->RedrawViews(mp->ip->GetTime());

				break;}


			case IDC_UPDATETARGS:
				{

				UI_MAKEBUSY

				for(int i=0;i<100;i++)
				{
					if(mp->chanBank[i].mConnection)
					{
						mp->chanBank[i].buildFromNode(mp->chanBank[i].mConnection);
					}
					else if(mp->chanBank[i].mActive)
					{
						mp->chanBank[i].rebuildChannel();
					}
				}

				mp->NotifyDependents(FOREVER,PART_OBJ,REFMSG_CHANGE);
				mp->ip->RedrawViews(mp->ip->GetTime());

				UI_MAKEFREE

				break;}


			case IDC_AUTOLOAD:
				{
					mp->pblock->SetValue(PB_CL_AUTOLOAD, 0, GetCheckBox(hWnd,IDC_AUTOLOAD));
					mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
				break;}


			case IDC_ZEROOTHERS:{
				int i;
				TimeValue t = mp->ip->GetTime();

					for(i=0;i<100;i++)
					{
						if(mp->chanBank[i].mModded&&mp->chanBank[i].mActiveOverride) mp->chanBank[i].cblock->SetValue(0,t,0.0f);
					}

				mp->Update_channelFULL();
				mp->Update_channelParams();	
				mp->NotifyDependents(FOREVER,PART_OBJ,REFMSG_CHANGE);
				mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);
				mp->ip->RedrawViews(mp->ip->GetTime());
				break;}


			// user clicks on a channel button
			case IDC_P1:
			case IDC_P2:
			case IDC_P3:
			case IDC_P4:
			case IDC_P5:
			case IDC_P6:
			case IDC_P7:
			case IDC_P8:
			case IDC_P9:
			case IDC_P10:{

				mp->chanSel = LOWORD(wParam) - IDC_P1;

				// Just rebuild all the buttons now
				int tIdx = 0,i;
				ICustButton *iTmp;
				for( i=IDC_P1;i<IDC_P10+1;i++){
					iTmp = GetICustButton(GetDlgItem(hWnd,i));
					if(tIdx==mp->chanSel) iTmp->SetCheck(TRUE);
					else iTmp->SetCheck(FALSE);
					ReleaseICustButton(iTmp);
					tIdx++;
				}
				mp->Update_channelParams();
				mp->Update_colorIndicators();

				if(!thePickMode.isPicking)
				{
					ICustEdit *cName = GetICustEdit(GetDlgItem(mp->hwChannelParams,IDC_CHANNAME));
					cName->GiveFocus();
					ReleaseICustEdit(cName);
				}

				// User has right-clicked on channel buttton
				// Do a mini popup menu that lets them
				// put an object into a channel or delete it
				if (HIWORD(wParam)==BN_RIGHTCLICK) {

					HMENU hMCM = CreatePopupMenu();
					MENUITEMINFO minfo;
					memset(&minfo,sizeof(minfo),0);
					minfo.cbSize = sizeof(minfo);

					minfo.fMask = MIIM_TYPE|MIIM_ID|MIIM_STATE;
					minfo.fType = MFT_STRING;

					minfo.wID = ID_PICKFROMSCENE;
					minfo.dwTypeData = GetString(IDS_MENUITEM1_PS);
					minfo.fState = thePickMode.isPicking?MFS_CHECKED:MFS_UNCHECKED;
					InsertMenuItem(hMCM,1,TRUE,&minfo);

					// If channel == active, allow deletion
					if(mp->chanBank[mp->chanNum+mp->chanSel].mActive)
					{
						minfo.wID = ID_DELETECHANNEL;
						minfo.dwTypeData = GetString(IDS_MENUITEM2_DC);
						minfo.fState = MFS_UNCHECKED;
						InsertMenuItem(hMCM,2,TRUE,&minfo);
					}

					// If Node == alive, allow reload
					if(mp->chanBank[mp->chanNum+mp->chanSel].mConnection)
					{
						minfo.wID = ID_RELOADCHANNEL;
						minfo.dwTypeData = GetString(IDS_MENUITEM3_RT);
						minfo.fState = MFS_UNCHECKED;
						InsertMenuItem(hMCM,3,TRUE,&minfo);
					}


					// Show our popup
					POINT lpPt; GetCursorPos(&lpPt);
					TrackPopupMenu(hMCM, TPM_LEFTBUTTON | TPM_RIGHTBUTTON, 
						lpPt.x, lpPt.y, 0, hWnd, NULL);	

					DestroyMenu(hMCM);
				}

			break;}

			}

			break;


		default:
			return FALSE;
	}
	return TRUE;
}






/*===========================================================================*\
 |
 | Channel Parameters Rollout
 |
\*===========================================================================*/


BOOL CALLBACK ChannelParams_DlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	MorphR3 *mp = (MorphR3*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mp && msg!=WM_INITDIALOG) return FALSE;

	ICustEdit *cName = NULL;
	float xtmp,ntmp;

	switch (msg) {
		case WM_INITDIALOG:{

			// Update the class pointer
			mp = (MorphR3*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mp->hwChannelParams = hWnd;

			cName = GetICustEdit(GetDlgItem(hWnd,IDC_CHANNAME));
			cName->SetLeading(2);

			// load the current channel
			morphChannel *curTmp = &mp->chanBank[mp->chanNum+mp->chanSel];

			// Setup the min/max stuff
			mp->cSpinmin = SetupFloatSpinner(hWnd, IDC_MIN_SPIN, IDC_MIN_EDIT, -999.9f, 999.9f, curTmp->mSpinmin);
			mp->cSpinmin->SetScale(mp->GetIncrements());
			mp->cSpinmax = SetupFloatSpinner(hWnd, IDC_MAX_SPIN, IDC_MAX_EDIT, -999.9f, 999.9f, curTmp->mSpinmax);
			mp->cSpinmax->SetScale(mp->GetIncrements());

			mp->cSpinmin->SetLimits(-999.9f,curTmp->mSpinmax,FALSE);
			mp->cSpinmax->SetLimits(curTmp->mSpinmin,999.9f,FALSE);

			SetCheckBox(hWnd,IDC_LIMIT, curTmp->mUseLimit );

			// Use Channel button
			SetCheckBox(hWnd,IDC_USECHAN, curTmp->mActiveOverride );

			// Use selection button
			ICustButton *iTmp;

			iTmp = GetICustButton(GetDlgItem(hWnd,IDC_USESEL));
			iTmp->SetType(CBT_CHECK);
			iTmp->SetHighlightColor(BLUE_WASH);
			ReleaseICustButton(iTmp);
				

			// channel assignment buttons
			iTmp = GetICustButton(GetDlgItem(hWnd,IDC_PICK));
			iTmp->SetType(CBT_CHECK);
			iTmp->SetHighlightColor(GREEN_WASH);
			iTmp = GetICustButton(GetDlgItem(hWnd,IDC_MAKE));
			iTmp->SetType(CBT_PUSH);
			ReleaseICustButton(iTmp);
			
			mp->Update_channelParams();

			break;}


		case WM_DESTROY:
			ReleaseICustEdit(cName);
			ReleaseISpinner(mp->cSpinmin);
			ReleaseISpinner(mp->cSpinmax);
			break;
		

		// Spinner change handling
		// Knock the channel into Modded if it isn't already
		case CC_SPINNER_CHANGE:
			if (!theHold.Holding()) theHold.Begin();
			switch (LOWORD(wParam)) {
				case IDC_MIN_SPIN: 
					ntmp = mp->cSpinmin->GetFVal();
					mp->cSpinmax->SetLimits(ntmp,999.9f,FALSE);
					mp->chanBank[mp->chanNum+mp->chanSel].mSpinmin = ntmp;

					if (mp->chanBank[mp->chanNum+mp->chanSel].mModded == FALSE)
					{
						mp->chanBank[mp->chanNum+mp->chanSel].mModded = TRUE;
						mp->Update_colorIndicators();
					}
					break;
				case IDC_MAX_SPIN: 
					xtmp = mp->cSpinmax->GetFVal();
					mp->cSpinmin->SetLimits(-999.9f,xtmp,FALSE);
					mp->chanBank[mp->chanNum+mp->chanSel].mSpinmax = xtmp;

					if (mp->chanBank[mp->chanNum+mp->chanSel].mModded == FALSE)
					{
						mp->chanBank[mp->chanNum+mp->chanSel].mModded = TRUE;
						mp->Update_colorIndicators();
					}
					break;
			}
			break;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;	

		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) theHold.Accept(GetString(IDS_PC_MORPH));
			else theHold.Cancel();

			// Update those limit changes
			mp->Update_channelLimits();
			break;


		case WM_CUSTEDIT_ENTER:
			switch (LOWORD(wParam)) {
				case IDC_CHANNAME:{ 
					TCHAR strTmp[256];
					ICustEdit *icT = GetICustEdit(GetDlgItem(hWnd,IDC_CHANNAME));
					icT->GetText( strTmp, 255 );

					if(strcmp(strTmp,mp->chanBank[mp->chanNum+mp->chanSel].mName)!=0)
					{
						// Set channel name and channel 'dirty/changed' bit
						mp->chanBank[mp->chanNum+mp->chanSel].mName = TSTR(strTmp);
						mp->chanBank[mp->chanNum+mp->chanSel].mModded = TRUE;
					}
					icT->SetText( strTmp );

					ReleaseICustEdit(icT);
					mp->Update_channelNames();
					mp->Update_colorIndicators();
					break;}

				default:
					{
					if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) theHold.Accept(GetString(IDS_PC_MORPH));
					else theHold.Cancel();

					// Update those limit changes
					mp->Update_channelLimits();
					break;
					}
				}
			break;


		case WM_COMMAND:{

			// Jump to channel
			int idCode = LOWORD(wParam);
			if(idCode>=5000&&idCode<=5200)
			{
				int id = idCode-5000;

				mp->chanNum = id;
				mp->Clamp_chanNum();

				int difSel = mp->chanSel + (id-(mp->chanNum + mp->chanSel));

				mp->chanSel = difSel;

				// Rebuild all the buttons
				int tIdx = 0,i;
				ICustButton *iTmp;
				for( i=IDC_P1;i<IDC_P10+1;i++){
					iTmp = GetICustButton(GetDlgItem(mp->hwChannelList,i));
					if(tIdx==mp->chanSel) iTmp->SetCheck(TRUE);
					else iTmp->SetCheck(FALSE);
					ReleaseICustButton(iTmp);
					tIdx++;
				}
				mp->Update_channelParams();
				mp->Update_colorIndicators();

				ICustEdit *cName = GetICustEdit(GetDlgItem(mp->hwChannelParams,IDC_CHANNAME));
				cName->GiveFocus();
				ReleaseICustEdit(cName);

				mp->Update_channelFULL();
				mp->Update_channelParams();
			}



			switch (LOWORD(wParam)) {


			// Support the channel management dialog
			case ID_CSM_SWAP:
			case ID_CSM_MOVE:
				{
					mp->cOp = LOWORD(wParam)-ID_CSM_MOVE;
					mp->srcIdx = (mp->chanNum+mp->chanSel);
					int res = DialogBoxParam( 
					hInstance, 
					MAKEINTRESOURCE( IDD_CHANOP ),
					hWnd,
					(DLGPROC)ChannelOpDlgProc,
					(LPARAM)(MorphR3*)mp);

					mp->Update_channelFULL();
					mp->Update_channelParams();

			break;}



			case IDC_MAKE:{
					UI_MAKEBUSY

					mp->recordModifications = TRUE;
					mp->recordTarget = mp->chanNum+mp->chanSel;
					mp->chanBank[mp->recordTarget].mActive = TRUE;
					mp->chanBank[mp->recordTarget].mModded = TRUE;
					mp->chanBank[mp->recordTarget].mInvalid = FALSE;

					int res = DialogBoxParam( 
					hInstance, 
					MAKEINTRESOURCE( IDD_NAMECAP ),
					hWnd,
					(DLGPROC)NameDlgProc,
					(LPARAM)(MorphR3*)mp);

					mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);
					mp->ip->RedrawViews(mp->ip->GetTime());

					mp->Update_channelFULL();
					mp->Update_channelParams();

					UI_MAKEFREE
					break;}


			case IDC_CHANNUM:{

					HMENU hCi = CreatePopupMenu();
					MENUITEMINFO minfo;
					memset(&minfo,sizeof(minfo),0);
					minfo.cbSize = sizeof(minfo);

					minfo.fMask = MIIM_TYPE|MIIM_ID;
					minfo.fType = MFT_STRING;

					int mID = 0;
					char s[255];

					for(int x=0;x<100;x++)
					{
						if(mp->chanBank[x].mModded)
						{
							sprintf(s,"[%i]  %s",(x+1),mp->chanBank[x].mName);
							minfo.wID = 5000+x;
							minfo.dwTypeData = s;
							InsertMenuItem(hCi,mID,TRUE,&minfo);
							mID++;
						}
					}

					HMENU mainMenu = GetSubMenu(LoadMenu(hInstance,MAKEINTRESOURCE(IDR_CHANSUB)),0);

					AppendMenu(mainMenu, MF_BYCOMMAND | MF_POPUP, (UINT)hCi,GetString(IDS_ACTIVE));

					// Show our popup
					POINT lpPt; GetCursorPos(&lpPt);
					TrackPopupMenu(mainMenu, TPM_LEFTBUTTON | TPM_RIGHTBUTTON, 
						lpPt.x, lpPt.y, 0, hWnd, NULL);	

					break;}



			// Another monster hack. This time, i gotta somehow extract a list of points and 
			// apply those deltas to the current object, at the point in the stack just below
			// the current modifier. 
			//
			// This is what i do:
			//	[] Get the current INode from calling a GetSelNode. This relies on the UI
			//		only ever being open when the mod is selected, and therefore there will
			//		only ever be one object legally selected.
			//
			//	[] Get the derived object, and start traversing the WSM modifier list.
			//
			//	[] As i cycle through 'em, store the enabled state, and turn 'em off.
			//
			//	[] When i reach myself, STOP! I want to disable myself, of course.
			//
			//  [] Invalidate the stack, causing the node to rebuild. Then, take a snapshot
			//		of the state. (ie, up to the point in the stack just below the morpher)
			//
			//	[] We then have a new Object and therefore a buildable copy. 
			//
			//  [] Apply the current channel's mPoints array. Build a new node from this.
			//
			//	[] Recycle through the mod list, appling the saved enabled states to the mods.
			//
			//  [] clean up!
			//
			// And it seems to work! :o)
			//
			case IDC_EXTRACT:{
				UI_MAKEBUSY

				if(mp->ip->GetSelNodeCount()==1) 
				{
					INode *node = mp->ip->GetSelNode(0);

					int cIndex = mp->chanNum+mp->chanSel;
					TimeValue t = mp->ip->GetTime();

					Object *pObj = node->GetObjectRef();
					IDerivedObject *pDerObj = NULL;
					Modifier *pMod = NULL;

					if( pObj->SuperClassID() == GEN_DERIVOB_CLASS_ID) 
					{
						pDerObj = (IDerivedObject *) pObj;

						// for saving enabled state of modifiers
						BOOL *onOff = new BOOL[pDerObj->NumModifiers()];
						
						for(int i = 0 ; i < pDerObj->NumModifiers() ; i++ )
						{
							pMod = pDerObj->GetModifier(i);	

							if(pMod->IsEnabled()>0) onOff[i]=TRUE;
							else onOff[i]=FALSE;

							pMod->DisableMod();

							if(pMod == mp )	goto DoneDisabling;
						}

						DoneDisabling:
						node->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
						node->InvalidateWS();

						ObjectState osp = node->EvalWorldState(t);

						Object *osMr = ((Object*)osp.obj->Clone())->ConvertToType(t,defObjectClassID);


						for(int z=0;z<mp->chanBank[cIndex].nPts;z++)
						{
							osMr->SetPoint(z,mp->chanBank[cIndex].mPoints[z]);
							osMr->SetWeight(z,mp->chanBank[cIndex].mWeights[z]);
						}

						// nuke seven bells out of the validity intervals
						// this was the only way to get patches to properly update
						osMr->UpdateValidity(GEOM_CHAN_NUM,FOREVER);
						osMr->UpdateValidity(TOPO_CHAN_NUM,FOREVER);
						osMr->UpdateValidity(SELECT_CHAN_NUM,FOREVER);
						osMr->UpdateValidity(SUBSEL_TYPE_CHAN_NUM,FOREVER);
						osMr->UpdateValidity(DISP_ATTRIB_CHAN_NUM,FOREVER);
						osMr->UpdateValidity(TEXMAP_CHAN_NUM, FOREVER);
						osMr->UpdateValidity(MTL_CHAN_NUM, FOREVER);
						osMr->LockObject();

						INode *newnode = mp->ip->CreateObjectNode(osMr);

						for(i = 0 ; i < pDerObj->NumModifiers() ; i++ )
						{
							pMod = pDerObj->GetModifier(i);	
							if(onOff[i]) pMod->EnableMod();

							if(pMod == mp )	goto DoneRestoring;
						}

						DoneRestoring:

						// clean up
						delete [] onOff;

						// Set the new node's properties (TM, name, etc)
						TSTR nodename = mp->chanBank[cIndex].mName;
						//mp->ip->MakeNameUnique (nodename);
						newnode->SetName(nodename);

						SuspendAnimate();
						AnimateOff();
						newnode->SetNodeTM(t,node->GetNodeTM(t));
						ResumeAnimate();

						// Make sure everything is up to date
						newnode->InvalidateTM();
						newnode->InvalidateWS();
						newnode->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);

						mp->ip->RedrawViews(t);

					}
					else
					{
						// there should be no way to push this button without having the morph modifier
						// applied to the object...
						MessageBox(hWnd,GetString(IDS_EXTRACT_MOD_ERROR),GetString(IDS_CLASS_NAME),MB_OK);
					}
				}	// node sel count check
				else
				{
					// this will only happen if the mod stack is 'pinned'
					MessageBox(hWnd,GetString(IDS_EXTRACT_GRAB_ERROR),GetString(IDS_CLASS_NAME),MB_OK);
				}
				
				UI_MAKEFREE
				break;}


			case IDC_DELETE:{
					int cIndex = mp->chanNum+mp->chanSel;

					if (!theHold.Holding()) theHold.Begin();
					theHold.Put(new MCRestore(mp, cIndex));
					if(mp->chanBank[cIndex].mConnection) 
						mp->DeleteReference(101+cIndex);
						mp->DeleteReference(1+cIndex);
					theHold.Accept(GetString(IDS_UNDOMCDEL));

					// Ask channel to reset itself
					mp->chanBank[cIndex].ResetMe();

					// Reassign paramblock info
					ParamBlockDescID *channelParams = new ParamBlockDescID[1];

					ParamBlockDescID add;
					add.type=TYPE_FLOAT;
					add.user=NULL;
					add.animatable=TRUE;
					add.id=1;
					channelParams[0] = add;

					mp->MakeRefByID(FOREVER, 1+cIndex, CreateParameterBlock(channelParams,1,1));	
					assert(mp->chanBank[cIndex].cblock);

					Control *c = (Control*)CreateInstance(CTRL_FLOAT_CLASS_ID,GetDefaultController(CTRL_FLOAT_CLASS_ID)->ClassID());

					mp->chanBank[cIndex].cblock->SetValue(0,0,0.0f);
					mp->chanBank[cIndex].cblock->SetController(0,c);

					delete channelParams;

					// Refresh system
					mp->Update_channelFULL();
					mp->Update_channelParams();	
					mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);
					mp->ip->RedrawViews(mp->ip->GetTime());
					break;}


			case IDC_USESEL:{
				ICustButton *iTmp;
					iTmp = GetICustButton(GetDlgItem(hWnd,IDC_USESEL));
					mp->chanBank[mp->chanNum+mp->chanSel].mUseSel = iTmp->IsChecked();
				ReleaseICustButton(iTmp);
				mp->chanBank[mp->chanNum+mp->chanSel].mModded = TRUE;
				mp->Update_colorIndicators();
				mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
				mp->ip->RedrawViews(mp->ip->GetTime());
				break;}


			case IDC_USECHAN:{
				mp->chanBank[mp->chanNum+mp->chanSel].mActiveOverride = GetCheckBox(hWnd,IDC_USECHAN);
				mp->Update_colorIndicators();
				mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
				mp->ip->RedrawViews(mp->ip->GetTime());
				break;}


			case IDC_LIMIT:
				mp->chanBank[mp->chanNum+mp->chanSel].mUseLimit = GetCheckBox(hWnd,IDC_LIMIT);
				mp->Update_channelLimits();
				mp->chanBank[mp->chanNum+mp->chanSel].mModded = TRUE;
				mp->Update_colorIndicators();
				break;


			// Ask the channel to update itself
			case IDC_UPDATETARGET:
				{
				int idx = mp->chanNum+mp->chanSel;

				UI_MAKEBUSY

				if(mp->chanBank[idx].mConnection)
				{
					mp->chanBank[idx].buildFromNode(mp->chanBank[idx].mConnection);
				}
				else if(mp->chanBank[idx].mActive)
				{
					mp->chanBank[idx].rebuildChannel();
				}

				mp->NotifyDependents(FOREVER,PART_OBJ,REFMSG_CHANGE);
				mp->ip->RedrawViews(mp->ip->GetTime());

				UI_MAKEFREE

				break;}
			


			case IDC_PICK:
				thePickMode.mp  = mp;					
				mp->ip->SetPickMode(&thePickMode);
				break;

			}
			break;
		}


		default:
			return FALSE;
	}
	return TRUE;
}






/*===========================================================================*\
 | RightClick Menu Stuff
\*===========================================================================*/

class MRCMenu : public RightClickMenu
{
private:
	Interface	*ip;
	MorphR3		*mp; 
	INode		*Sel;

public:
	BOOL Installed;

	MRCMenu(){Installed=FALSE;}
	~MRCMenu(){}

	void Bind(Interface *ipi, MorphR3 *cpi){
		ip=ipi; 
		mp=cpi;
	}

	void Init(RightClickMenuManager* manager, HWND hWnd, IPoint2 m){

		Installed=TRUE;
		BOOL UsedObject = FALSE;

		char s[255];
		int indexer;
		Interval valid = FOREVER;
		float tmp;

		NameTab ListEm;
		ListEm.ZeroCount();

		Tab<int> indexTab;
		indexTab.ZeroCount();

		Sel = ip->PickNode(hWnd,m);

		if(Sel){

			for(int x=0;x<100;x++)
			{
				if(mp->chanBank[x].mConnection == Sel) 
				{
					mp->chanBank[x].cblock->GetValue(0, ip->GetTime(), tmp, valid);

					indexer = (x+1);

					sprintf(s,"[%i] %s  :  %.1f%%",indexer,mp->chanBank[x].mName,tmp);
					ListEm.AddName(s);
					indexTab.Append(1,&indexer,0);

					UsedObject = TRUE;
				}
			}

			if(UsedObject)
			{
				manager->AddMenu(this, MF_SEPARATOR, 0, NULL);
				manager->BeginSubMenu(GetString(IDS_MENUNAME));
				for(int x=0;x<ListEm.Count();x++)
				{
					manager->AddMenu(this, MF_STRING, indexTab[x], ListEm[x]);
				}
				manager->EndSubMenu();
			}
		}

	}

	void Selected(UINT id){	
		mp->chanNum = id-1;
		mp->Clamp_chanNum();

		int difSel = mp->chanSel + (id-(mp->chanNum + mp->chanSel)) - 1;

		mp->chanSel = difSel;

		// Rebuild all the buttons
		int tIdx = 0,i;
		ICustButton *iTmp;
		for( i=IDC_P1;i<IDC_P10+1;i++){
			iTmp = GetICustButton(GetDlgItem(mp->hwChannelList,i));
			if(tIdx==mp->chanSel) iTmp->SetCheck(TRUE);
			else iTmp->SetCheck(FALSE);
			ReleaseICustButton(iTmp);
			tIdx++;
		}
		mp->Update_channelParams();
		mp->Update_colorIndicators();

		ICustEdit *cName = GetICustEdit(GetDlgItem(mp->hwChannelParams,IDC_CHANNAME));
		cName->GiveFocus();
		ReleaseICustEdit(cName);

		mp->Update_channelFULL();
		mp->Update_channelParams();
	}

};

MRCMenu rcdd;


/*===========================================================================*\
 | Load and display the interfaces
\*===========================================================================*/

void MorphR3::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
{
	this->ip = ip;
	if(!tccI) { ip->RegisterTimeChangeCallback(this); tccI = TRUE; }

	hwLegend = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_LEGEND),
				Legend_DlgProc, 
				GetString(IDS_LEGEND_DLG), 
				(LPARAM)this,
				APPENDROLL_CLOSED);		
	ip->RegisterDlgWnd(hwLegend);
	SetWindowLong(hwLegend,GWL_USERDATA,(LONG)this);

	hwGlobalParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_GLOBAL_PARAMS),
				Globals_DlgProc, 
				GetString(IDS_GLOBAL_PARAMS), 
				(LPARAM)this,
				APPENDROLL_CLOSED);		
	ip->RegisterDlgWnd(hwGlobalParams);
	SetWindowLong(hwGlobalParams,GWL_USERDATA,(LONG)this);

	hwChannelList = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_CHANNEL_LIST),
				ChannelList_DlgProc, 
				GetString(IDS_CHANNEL_LIST), 
				(LPARAM)this);		
	ip->RegisterDlgWnd(hwChannelList);
	SetWindowLong(hwChannelList,GWL_USERDATA,(LONG)this);

	hwChannelParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_CHANNEL_PARAMS),
				ChannelParams_DlgProc, 
				GetString(IDS_CHANNEL_PARAMS), 
				(LPARAM)this);		
	ip->RegisterDlgWnd(hwChannelParams);
	SetWindowLong(hwChannelParams,GWL_USERDATA,(LONG)this);

	hwAdvanced = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_ADVANCED),
				Advanced_DlgProc, 
				GetString(IDS_ADVANCED), 
				(LPARAM)this,
				APPENDROLL_CLOSED);		
	ip->RegisterDlgWnd(hwAdvanced);
	SetWindowLong(hwAdvanced,GWL_USERDATA,(LONG)this);

	// Load our RCMenu Callback
	RightClickMenuManager *rcm = ip->GetRightClickMenuManager();
	rcdd.Bind(ip,this);
	rcm->Register(&rcdd);
}

/*===========================================================================*\
 | Remove all the pages
\*===========================================================================*/

void MorphR3::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next)
{
	ip->UnRegisterDlgWnd(hwLegend);
	ip->DeleteRollupPage(hwLegend);
	hwLegend = NULL;

	ip->UnRegisterDlgWnd(hwGlobalParams);
	ip->DeleteRollupPage(hwGlobalParams);
	hwGlobalParams = NULL;

	ip->UnRegisterDlgWnd(hwChannelList);
	ip->DeleteRollupPage(hwChannelList);
	hwChannelList = NULL;

	ip->UnRegisterDlgWnd(hwChannelParams);
	ip->DeleteRollupPage(hwChannelParams);
	hwChannelParams = NULL;

	ip->UnRegisterDlgWnd(hwAdvanced);
	ip->DeleteRollupPage(hwAdvanced);
	hwAdvanced = NULL;


	RightClickMenuManager *rcm = ip->GetRightClickMenuManager();
	rcm->Unregister(&rcdd);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_impexp.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_impexp.cpp
 |			Weighted Morpher for MAX R3
 |			Import and Export code
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 25-11-98
 | 
\*===========================================================================*/

#include "wM3.h"

// WORK IN PROGRESS
// I ran out of time :)
//
// Something for the future... unless you want to impliment your own impexp
//
// Did a load of work on the xport interface, letting the user choose specific 
// channels. UIs are built, just no code to export as yet.
//


/*===========================================================================*\
 |
 | Import and Export mappings dialog handlers
 |
\*===========================================================================*/



BOOL CALLBACK IMPORT_DlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	MorphR3 *mp = (MorphR3*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mp && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:{
			mp = (MorphR3*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,(LONG)mp);

			HWND maxWnd = mp->ip->GetMAXHWnd();
			CenterWindow(hWnd,maxWnd);
			EnableWindow(maxWnd,FALSE);
			break;
			}

		case WM_CLOSE:
			break;

		case WM_DESTROY:
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CANCEL:
					EnableWindow(mp->ip->GetMAXHWnd(),TRUE);
					EndDialog(hWnd,1);
					break;
			}

			break;

		default:
			return FALSE;
	}
	return TRUE;
}






void ValidateExportDlg( HWND hWnd, HWND clist )
{
	int sCount = SendMessage(clist,LB_GETSELCOUNT,0,0);
	char s[255];
	sprintf(s,"%i %s",sCount,GetString(IDS_CHANSEL));
	SetWindowText(GetDlgItem(hWnd,IDC_SEL),s);

	if(sCount<1) EnableWindow(GetDlgItem(hWnd,IDC_DOSAVE),FALSE);
	else EnableWindow(GetDlgItem(hWnd,IDC_DOSAVE),TRUE);
}


BOOL CALLBACK EXPORT_DlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	MorphR3 *mp = (MorphR3*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mp && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:{
			mp = (MorphR3*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,(LONG)mp);

			HWND maxWnd = mp->ip->GetMAXHWnd();
			CenterWindow(hWnd,maxWnd);
			EnableWindow(maxWnd,FALSE);

			HWND clist = GetDlgItem(hWnd,IDC_CLIST);
			SendMessage(clist,LB_RESETCONTENT,0,0);

			for(int i=0;i<100;i++)
			{
				char tmp[255];
				int Cind = i+1;

				sprintf(tmp, "%i : %s", Cind, mp->chanBank[i].mName );
				SendMessage(clist,LB_ADDSTRING,0,(LPARAM)tmp);
			}
			break;
			}

		case WM_CLOSE:
		case WM_DESTROY:
			break;

		case WM_COMMAND:
			if ( HIWORD(wParam) == LBN_SELCHANGE ) {
				HWND clist = GetDlgItem(hWnd,IDC_CLIST);
				ValidateExportDlg(hWnd,clist);
			}

			switch (LOWORD(wParam)) {
				case IDC_CANCEL:
					EnableWindow(mp->ip->GetMAXHWnd(),TRUE);
					EndDialog(hWnd,1);
					break;

				case IDC_SELUSED:{
					HWND clist = GetDlgItem(hWnd,IDC_CLIST);
					SendMessage(clist,LB_SELITEMRANGE,FALSE,MAKELPARAM(0,100));

					int caret = SendMessage(clist,LB_GETCARETINDEX,0,0);

					for(int i=0;i<100;i++)
					{
						if(mp->chanBank[i].mModded) SendMessage(clist,LB_SETSEL,TRUE,(LPARAM)i);
					}
					SendMessage(clist,LB_SETCARETINDEX,caret,MAKELPARAM(TRUE,0));

					ValidateExportDlg(hWnd,clist);

					break;}

				case IDC_SELINVERT:{
					HWND clist = GetDlgItem(hWnd,IDC_CLIST);
					int caret = SendMessage(clist,LB_GETCARETINDEX,0,0);

					for(int i=0;i<100;i++)
					{
						SendMessage(clist,LB_SETSEL,!(SendMessage(clist,LB_GETSEL,i,0)),(LPARAM)i);
					}
					SendMessage(clist,LB_SETCARETINDEX,caret,MAKELPARAM(TRUE,0));

					ValidateExportDlg(hWnd,clist);

					break;}

				case IDC_SELNONE:{
					HWND clist = GetDlgItem(hWnd,IDC_CLIST);

					SendMessage(clist,LB_SELITEMRANGE,FALSE,MAKELPARAM(0,100));
					ValidateExportDlg(hWnd,clist);
					break;}

				case IDC_SELALL:{
					HWND clist = GetDlgItem(hWnd,IDC_CLIST);

					SendMessage(clist,LB_SELITEMRANGE,TRUE,MAKELPARAM(0,100));
					ValidateExportDlg(hWnd,clist);
					break;}
			}

			break;

		default:
			return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_io.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_io.cpp
 |			Weighted Morpher for MAX R3
 |			Handles loading / saving
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 21-9-98	
 |			BitArray native save, 3-3-99 HD
 | 
\*===========================================================================*/

#include "wM3.h"


IOResult morphChannel::Save(ISave* isave)
{
	ULONG nb;

	// Size of morph data arrays
	isave->BeginChunk(MR3_POINTCOUNT);
	isave->Write(&nPts,sizeof(int),&nb);
	isave->Write(&nmPts,sizeof(int),&nb);
	isave->EndChunk();


	// Save out the morph point data
	isave->BeginChunk(MR3_POINTDATA_MP);
	isave->Write(mPoints,sizeof(Point3)*nPts,&nb);
	isave->EndChunk();

	isave->BeginChunk(MR3_POINTDATA_MW);
	isave->Write(mWeights,sizeof(double)*nPts,&nb);
	isave->EndChunk();

	isave->BeginChunk(MR3_POINTDATA_MD);
	isave->Write(mDeltas,sizeof(Point3)*nPts,&nb);
	isave->EndChunk();

	isave->BeginChunk(MR3_POINTDATA_MO);
	isave->Write(mOptdata,sizeof(int)*nmPts,&nb);
	isave->EndChunk();


	// Misc stuff saving
	isave->BeginChunk(MR3_SELARRAY);
	mSel.Save(isave);
	//isave->Write(&mSel,sizeof(BitArray),&nb);
	isave->EndChunk();

	isave->BeginChunk(MR3_NAME);
	isave->WriteWString(mName.data());
	isave->EndChunk();

	isave->BeginChunk(MR3_PARAMS);
	isave->Write(&mActive,sizeof(BOOL),&nb);
	isave->Write(&mModded,sizeof(BOOL),&nb);
	isave->Write(&mUseLimit,sizeof(BOOL),&nb);
	isave->Write(&mUseSel,sizeof(BOOL),&nb);
	isave->Write(&mSpinmin,sizeof(float),&nb);
	isave->Write(&mSpinmax,sizeof(float),&nb);
	isave->Write(&mActiveOverride,sizeof(BOOL),&nb);
	isave->EndChunk();

	return IO_OK;
}

IOResult morphChannel::Load(ILoad* iload)
{
	ULONG nb;
	IOResult res = IO_OK;
	int tnPts, tnmPts;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case MR3_POINTCOUNT:
				res = iload->Read(&tnPts,sizeof(int),&nb);
				res = iload->Read(&tnmPts,sizeof(int),&nb);
				nPts = tnPts;
				nmPts = tnmPts;
			break;

			case MR3_POINTDATA_MP:
			if(mPoints) delete [] mPoints;
			mPoints = new Point3[nPts];
			res = iload->Read(mPoints,sizeof(Point3)*nPts,&nb);
			break;

			case MR3_POINTDATA_MW:
			if(mWeights) delete [] mWeights;
			mWeights = new double[nPts];
			res = iload->Read(mWeights,sizeof(double)*nPts,&nb);
			break;
			
			case MR3_POINTDATA_MD:
			if(mDeltas) delete [] mDeltas;
			mDeltas = new Point3[nPts];
			res = iload->Read(mDeltas,sizeof(Point3)*nPts,&nb);
			break;

			case MR3_POINTDATA_MO:
			if(mOptdata) delete [] mOptdata;
//			mOptdata = new int[nmPts];
			mOptdata = new int[nPts]; // mjm - 11.8.99
			res = iload->Read(mOptdata,sizeof(int)*nmPts,&nb);
			break;

			case MR3_SELARRAY:
				mSel.Load(iload);
				//res = iload->Read(&mSel,sizeof(BitArray),&nb);
			break;

			case MR3_NAME:{
				TCHAR *buf;
				res = iload->ReadWStringChunk(&buf);
				mName = TSTR(buf);
			break;}
		
			case MR3_PARAMS:
				res = iload->Read(&mActive,sizeof(BOOL),&nb);
				res = iload->Read(&mModded,sizeof(BOOL),&nb);
				res = iload->Read(&mUseLimit,sizeof(BOOL),&nb);
				res = iload->Read(&mUseSel,sizeof(BOOL),&nb);
				res = iload->Read(&mSpinmin,sizeof(float),&nb);
				res = iload->Read(&mSpinmax,sizeof(float),&nb);
				res = iload->Read(&mActiveOverride,sizeof(BOOL),&nb);
			break;
		}

		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	return IO_OK;
}

IOResult MorphR3::Load(ILoad *iload)
{
	Modifier::Load(iload);

	ULONG nb;

	IOResult res = IO_OK;

	while (IO_OK==(res=iload->OpenChunk())) {

		if((iload->CurChunkID()>=MR3_MC_SUBCHUNK) && (iload->CurChunkID()<MR3_MC_SUBCHUNK+100 ))
		{
			int mID = iload->CurChunkID()-MR3_MC_SUBCHUNK;
			res = chanBank[mID].Load(iload);
		}

		switch (iload->CurChunkID()) {
			case MR3_MARKERNAME:
				markerName.Load(iload);
				break;

			case MR3_MARKERINDEX:
				int n;
				res = iload->Read(&n,sizeof(int), &nb);
				markerIndex.SetCount(n);

				for(int x=0;x<n;x++)
				{
					res = iload->Read(&markerIndex[x],sizeof(int), &nb);
				}
				break;

		}

		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}	

	return IO_OK;
}

IOResult MorphR3::Save(ISave *isave)
{
	Modifier::Save(isave);

	ULONG nb;
	int n;

	for(int i=0;i<100;i++)
	{
		isave->BeginChunk(MR3_MC_SUBCHUNK+i);
		chanBank[i].Save(isave);
		isave->EndChunk();	
	}

	isave->BeginChunk(MR3_MARKERNAME);
	markerName.Save(isave);
	isave->EndChunk();

	isave->BeginChunk(MR3_MARKERINDEX);
	n = markerIndex.Count();
	isave->Write(&n,sizeof(int), &nb);

	for(int x=0;x<n;x++)
	{
		isave->Write(&markerIndex[x],sizeof(int), &nb);
	}
	isave->EndChunk();

	return IO_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_material_pick.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_material_pick.cpp
 |			Weighted Morpher for MAX R3
 |			Pickmode for the morph material
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1998
 |			All Rights Reserved.
 |
 |  HIST:	Started 23-12-98
 | 
\*===========================================================================*/

#include "wM3.h"



/*===========================================================================*\
 |
 | The mini-mod stack window handler, for picking a morph modifier
 |
\*===========================================================================*/


BOOL CALLBACK BindProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	M3Mat *mp = (M3Mat*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mp && msg!=WM_INITDIALOG) return FALSE;

	int id = LOWORD(wParam);
	int notify = HIWORD(wParam);


	switch (msg) {
		case WM_INITDIALOG:{
			mp = (M3Mat*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,(LONG)mp);

			HWND modList = GetDlgItem(hWnd,IDC_MODLIST);

			SendMessage(modList,LB_RESETCONTENT,0,0);

			POINT lpPt; GetCursorPos(&lpPt);
			SetWindowPos(hWnd, NULL, lpPt.x, lpPt.y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

			Object *pObj = mp->Wnode->GetObjectRef();
			IDerivedObject *pDerObj = NULL;
			Modifier *pMod = NULL;

			if( pObj->SuperClassID() == GEN_DERIVOB_CLASS_ID) 
			{
				pDerObj = (IDerivedObject *) pObj;

				for(int i = 0 ; i < pDerObj->NumModifiers() ; i++ )
				{
					pMod = pDerObj->GetModifier(i);	
					SendMessage(modList,LB_ADDSTRING,0,(LPARAM) (LPCTSTR) pMod->GetName());
				}
			}

			SendMessage(modList,LB_SETCURSEL ,(WPARAM)-1,0);

			break;}


		case WM_COMMAND:

			if (notify==LBN_SELCHANGE){
				if(id==IDC_MODLIST){
					int mkSel = SendMessage(GetDlgItem(hWnd, IDC_MODLIST), LB_GETCURSEL, 0, 0);
					if(mkSel>=0){

						Object *pObj = mp->Wnode->GetObjectRef();
						IDerivedObject *pDerObj = NULL;
						Modifier *pMod = NULL;

						if( pObj->SuperClassID() == GEN_DERIVOB_CLASS_ID) 
						{
							pDerObj = (IDerivedObject *) pObj;
							pMod = pDerObj->GetModifier(mkSel);	
							if(pMod->ClassID() == MR3_CLASS_ID) EnableWindow(GetDlgItem(hWnd,IDOK),TRUE);
							else EnableWindow(GetDlgItem(hWnd,IDOK),FALSE);
						}


					}
				}
			}

			switch (id) {
				case IDOK:
				{
					int mkSel = SendMessage(GetDlgItem(hWnd, IDC_MODLIST), LB_GETCURSEL, 0, 0);
					if(mkSel>=0){

						Object *pObj = mp->Wnode->GetObjectRef();
						IDerivedObject *pDerObj = NULL;
						Modifier *pMod = NULL;

						if( pObj->SuperClassID() == GEN_DERIVOB_CLASS_ID) 
						{
							pDerObj = (IDerivedObject *) pObj;
							pMod = pDerObj->GetModifier(mkSel);	

							mp->ReplaceReference(102,(MorphR3*)pMod);
							mp->obName = mp->Wnode->GetName();

							mp->dlg->UpdateMorphInfo(UD_LINK);
							mp->dlg->ReloadDialog();
						}


					}
				}
				case IDCANCEL:
					EndDialog(hWnd,1);
				break;
				}
			break;
		
		

		default:
			return FALSE;
		}
	return TRUE;
	}



/*===========================================================================*\
 |
 | Pickmode support
 |
\*===========================================================================*/


BOOL  GetMorphMod::Filter(INode *node)
{
	Interval valid; 
	
	ObjectState os = node->GetObjectRef()->Eval(mp->dlg->ip->GetTime());

	if( os.obj->IsDeformable() == FALSE ) return FALSE;

	return TRUE;
}


BOOL  GetMorphMod::Pick(INode *node)
	{
	if (node) {

		mp->Wnode = node;

		int res = DialogBoxParam( 
			hInstance, 
			MAKEINTRESOURCE( IDD_BINDMORPH ),
			GetDlgItem(mp->dlg->hPanel,IDC_BIND),
			(DLGPROC)BindProc,
			(LPARAM)(M3Mat*)mp
			);

	}
	
	return TRUE;
}


void  GetMorphMod::EnterMode()
{
	isPicking=TRUE;
	if (mp->dlg->pickBut) mp->dlg->pickBut->SetCheck(TRUE);
}

void  GetMorphMod::ExitMode()
{
	isPicking=FALSE;
	if (mp->dlg->pickBut) mp->dlg->pickBut->SetCheck(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_plugin.cpp
 |			Weighted Morpher for MAX R3
 |			Plugin Init
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 22-5-98
 | 
\*===========================================================================*/

#include "wM3.h"

HINSTANCE hInstance;
static int controlsInit = FALSE;


/*===========================================================================*\
 | Class Descriptor
\*===========================================================================*/

class MorphR3ClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new MorphR3();}
	const TCHAR *	ClassName() {return GetString(IDS_CLASS_NAME);}
	SClass_ID		SuperClassID() {return OSM_CLASS_ID;}
	Class_ID		ClassID() {return MR3_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(IDS_MXCATEGORY);}

	// SView
	bool DrawRepresentation(COLORREF bkColor, HDC hDC, Rect &rect)
		{
		LoadIcons(bkColor);
		DrawMAXIcon(hDC, rect, hIcons32, hIcons16, II_MORPHER);
		return TRUE;
		}
};

static MorphR3ClassDesc MorphR3Desc;
ClassDesc* GetMorphR3Desc() {return &MorphR3Desc;}


/*===========================================================================*\
 | DLLMain and the standard plugin stuff
\*===========================================================================*/

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved)
{
	hInstance = hinstDLL;

	if (!controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}
			
	return (TRUE);
}

__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESCRIPTION);
}

__declspec( dllexport ) int LibNumberClasses()
{
	return 2;
}

__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i) {
		case 0: return GetMorphR3Desc();
		case 1: return GetM3MatDesc();
		default: return 0;
	}
}

__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}

// Let the plug-in register itself for deferred loading
// Morpher can't because its inputType is dynamic, and based on scene state
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 0;
}

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}


HIMAGELIST hIcons32, hIcons16;
COLORREF currentBkColor;

void LoadIcons(COLORREF bkColor)
	{
	static BOOL iconsLoaded = FALSE;
	if (!iconsLoaded || bkColor != currentBkColor)
		{
		hIcons32 = ImageList_Create(32, 32, ILC_COLORDDB | ILC_MASK, 1, 0);
		hIcons16 = ImageList_Create(16, 16, ILC_COLORDDB | ILC_MASK, 1, 0);
		LoadMAXIcon(hInstance, MAKEINTRESOURCE(IDB_SV_MORPH32), MAKEINTRESOURCE(IDB_SV_MORPH32_MASK),
			bkColor,	hIcons32, -1);
		LoadMAXIcon(hInstance, MAKEINTRESOURCE(IDB_SV_MORPH16), MAKEINTRESOURCE(IDB_SV_MORPH16_MASK),
			bkColor,	hIcons16, -1);

		iconsLoaded = TRUE;
		currentBkColor = bkColor;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_material_dlg.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_material_dlg.cpp
 |			Weighted Morpher for MAX R3
 |			Morph Material dialog code
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1998
 |			All Rights Reserved.
 |
 |  HIST:	Started 23-12-98
 | 
\*===========================================================================*/


#include "wM3.h"



static BOOL CALLBACK PanelDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	M3MatDlg *dlg = (M3MatDlg*)GetWindowLong(hWnd,GWL_USERDATA);
	switch (msg) {
		case WM_INITDIALOG:
			dlg = (M3MatDlg*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;
		}
	if (dlg) return dlg->WndProc(hWnd,msg,wParam,lParam);
	else return FALSE;
	}


M3MatDlg::M3MatDlg(HWND hwMtlEdit, IMtlParams *imp, M3Mat *m)
	{
	dadMgr.Init(this);

	hwmedit = hwMtlEdit;
	ip      = imp;
	theMtl  = m;
	valid   = FALSE;

	for (int i=0; i<NSUBMTL; i++) iBut[i] = NULL;
	bBut = NULL;
	pickBut = NULL;
	m->listSel = 0;

	hPanel = ip->AddRollupPage( 
		hInstance,
		MAKEINTRESOURCE(IDD_MORPHMTL),
		PanelDlgProc,
		GetString(IDS_MTL_PARAM),
		(LPARAM)this);
	}


int M3MatDlg::FindSubMtlFromHWND(HWND hw){
	for (int i=0; i<NSUBMTL; i++) {
		if (hw == iBut[i]->GetHwnd()) return i+theMtl->listSel;
		}
	if(hw == bBut->GetHwnd()) return 100;
	return -1;
	}

void M3MatDlg::UpdateSubMtlNames() {
	TSTR nm;
	HWND label;
	char s[30];

	for (int i=0; i<NSUBMTL; i++) {
		Mtl *m = theMtl->GetSubMtl(i+theMtl->listSel);
		if (m) 	nm = m->GetFullName();
		else 	nm = GetString(IDS_DS_NONE);
		iBut[i]->SetText(nm.data());

		label = GetDlgItem(hPanel,IDC_MNAME1+i);
		sprintf(s,GetString(IDS_MTL_MAPNAMEDOTS),i+1+theMtl->listSel);
		SetWindowText(label,s);
		}

		Mtl *mb = theMtl->GetSubMtl(100);
		if (mb) 	nm = mb->GetFullName();
		else 	nm = GetString(IDS_DS_NONE);
		bBut->SetText(nm.data());

	}



void M3MatDlg::DragAndDrop(int ifrom, int ito) {
	theMtl->CopySubMtl(hPanel,ifrom, ito);
	theMtl->NotifyChanged();
	}


M3MatDlg::~M3MatDlg()
	{
	theMtl->dlg = NULL;	
	SetWindowLong(hPanel, GWL_USERDATA, NULL);
	for (int i=0; i<NSUBMTL; i++) {
		ReleaseICustButton(iBut[i]);
		iBut[i] = NULL; 
		}

	ReleaseICustButton(bBut);
	ReleaseICustButton(pickBut);
	bBut = NULL; 
	pickBut = NULL;

	}


void M3MatDlg::SetThing(ReferenceTarget *m) {
	theMtl = (M3Mat*)m;
	ReloadDialog();
	}

static int subMtlId[10] = {
IDC_MORPH_MAT1, IDC_MORPH_MAT2,
IDC_MORPH_MAT3, IDC_MORPH_MAT4, 
IDC_MORPH_MAT5, IDC_MORPH_MAT6, 
IDC_MORPH_MAT7, IDC_MORPH_MAT8, 
IDC_MORPH_MAT9, IDC_MORPH_MAT10 
};


// Clamp the channel number (0-90)
void M3MatDlg::Clamp_listSel()
{
	if(theMtl->listSel<0) theMtl->listSel = 0;
	if(theMtl->listSel>=90) theMtl->listSel = 90;
}


// Handle the scroll bar
void M3MatDlg::VScroll(int code, short int cpos ) {
	switch (code) {
		case SB_LINEUP: 	theMtl->listSel--;		break;
		case SB_LINEDOWN:	theMtl->listSel++;		break;
		case SB_PAGEUP:		theMtl->listSel -= 10;	break;
		case SB_PAGEDOWN:	theMtl->listSel += 10;	break;
		
		case SB_THUMBPOSITION: 
		case SB_THUMBTRACK:
			theMtl->listSel = cpos;
			break;
		}

	// Check for out-of-bounds values
	Clamp_listSel();
	
	// Reposition the scrollbar
	HWND vScr = GetDlgItem(hPanel,IDC_LISTSCROLL);
	SetScrollPos((HWND)vScr, SB_CTL, theMtl->listSel, TRUE); 

	ReloadDialog();
	}



void M3MatDlg::UpdateMorphInfo(int upFlag)
{
	macroRecorder->Disable();

	int i;

	if(theMtl->morphp)
	{
		SetWindowText(GetDlgItem(hPanel,IDC_MORPHNAME),theMtl->obName);
		EnableWindow(GetDlgItem(hPanel,IDC_REFRESH),TRUE);
		EnableWindow(GetDlgItem(hPanel,IDC_MARKERLIST),TRUE);


		HWND hwMarker	= GetDlgItem(hPanel,IDC_MARKERLIST);
		SendMessage(hwMarker,CB_RESETCONTENT,0,0);

		// Add the bookmark names to the dropdown
		for( i=0; i<theMtl->morphp->markerName.Count(); i++ )
		{
			SendMessage(hwMarker,CB_ADDSTRING,0,(LPARAM) (LPCTSTR) theMtl->morphp->markerName[i]);
		}

		// Set the current selection
		SendMessage(hwMarker,CB_SETCURSEL ,(WPARAM)-1,0);

		for( i=0;i<100;i++)
		{
			if(theMtl->mTex[i]) theMtl->mTex[i]->SetName(theMtl->morphp->chanBank[i].mName);
		}

		if(upFlag==UD_LINK)
		{
			for( i=0;i<100;i++)
			{
				Control *c = theMtl->morphp->chanBank[i].cblock->GetController(0);
				theMtl->pblock->SetController(i,c);
			}
		}

	}
	else
	{
		SetWindowText(GetDlgItem(hPanel,IDC_MORPHNAME),GetString(IDS_MTL_NOTARG));
		EnableWindow(GetDlgItem(hPanel,IDC_REFRESH),FALSE);
		EnableWindow(GetDlgItem(hPanel,IDC_MARKERLIST),FALSE);

		HWND hwMarker	= GetDlgItem(hPanel,IDC_MARKERLIST);
		SendMessage(hwMarker,CB_RESETCONTENT,0,0);
	}

	macroRecorder->Enable();
}


BOOL M3MatDlg::WndProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	int id = LOWORD(wParam);
	int notify = HIWORD(wParam);


	switch (msg) {
		case WM_INITDIALOG:{
			for (int i=0; i<NSUBMTL; i++) {
				iBut[i] = GetICustButton(GetDlgItem(hWnd,subMtlId[i]));
				iBut[i]->SetDADMgr(&dadMgr);
				}

				bBut = GetICustButton(GetDlgItem(hWnd,IDC_MORPH_BASE));
				bBut->SetDADMgr(&dadMgr);

				pickBut = GetICustButton(GetDlgItem(hWnd,IDC_BIND));
				pickBut->SetHighlightColor(GREEN_WASH);
				pickBut->SetType(CBT_CHECK);

			for (i=0; i<10; i++) 
				SetCheckBox(hWnd, IDC_TEXON1+i, theMtl->mapOn[i+theMtl->listSel]);

			
			// Setup the scroll bar to move the list
			HWND vScr = GetDlgItem(hWnd,IDC_LISTSCROLL);

			SCROLLINFO	si;
			memset(&si,0,sizeof(si)); 
			si.cbSize = sizeof(si); 
			si.fMask  = SIF_RANGE | SIF_POS; 
			si.nMin   = 0; 
			si.nMax   = 90; 
			si.nPos   = theMtl->listSel; 
			SetScrollInfo((HWND)vScr, SB_CTL, &si, TRUE);    
			
			break;}

		case WM_PAINT:
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;


		// Handle the scrolling
		case WM_VSCROLL:
				VScroll(LOWORD(wParam),(short int)HIWORD(wParam));
			break;



		case WM_COMMAND:
			
			if (notify==CBN_SELENDOK){
				if(id==IDC_MARKERLIST){
					int mkSel = SendMessage(GetDlgItem(hWnd, IDC_MARKERLIST), CB_GETCURSEL, 0, 0);
					if(mkSel>=0){
						theMtl->listSel = theMtl->morphp->markerIndex[mkSel];
						Clamp_listSel();

						for (int i=0; i<10; i++) 
							SetCheckBox(hWnd, IDC_TEXON1+i, theMtl->mapOn[i+theMtl->listSel]);

						UpdateSubMtlNames();
	
						HWND vScr = GetDlgItem(hWnd,IDC_LISTSCROLL);
						SetScrollPos((HWND)vScr, SB_CTL, theMtl->listSel, TRUE); 
					}
				}
			}

			switch (id) {
				case IDC_MORPH_MAT1:
				case IDC_MORPH_MAT2:
				case IDC_MORPH_MAT3:
				case IDC_MORPH_MAT4:
				case IDC_MORPH_MAT5:
				case IDC_MORPH_MAT6:
				case IDC_MORPH_MAT7:
				case IDC_MORPH_MAT8:
				case IDC_MORPH_MAT9:
				case IDC_MORPH_MAT10:
					PostMessage(hwmedit,WM_SUB_MTL_BUTTON, 
						(id-IDC_MORPH_MAT1)+theMtl->listSel ,(LPARAM)theMtl);
					break;


				case IDC_MORPH_BASE:
					PostMessage(hwmedit,WM_SUB_MTL_BUTTON, 
						100 ,(LPARAM)theMtl);
					break;


				case IDC_BIND:{
						theModPickmode.mp = theMtl;
						ip->SetPickMode(&theModPickmode);
					break;}


				case IDC_UPDATE1:
				case IDC_UPDATE2:
				case IDC_UPDATE3:
					{
						int idU = id-IDC_UPDATE1;
						theMtl->pblock->SetValue(100,ip->GetTime(),idU);
						theMtl->NotifyChanged();
					break;}


				case IDC_REFRESH:
						ReloadDialog();
					break;


				case IDC_TEXON1:
				case IDC_TEXON2:
				case IDC_TEXON3:
				case IDC_TEXON4:
				case IDC_TEXON5:
				case IDC_TEXON6:
				case IDC_TEXON7:
				case IDC_TEXON8:
				case IDC_TEXON9:
				case IDC_TEXON10:
					theMtl->mapOn[(id-IDC_TEXON1)+theMtl->listSel] = GetCheckBox(hWnd,id);
					Invalidate();
					theMtl->NotifyChanged();
		    		ip->MtlChanged();
					break;
				}
			break;
		
		

		default:
			return FALSE;
		}
	return TRUE;
	}

void M3MatDlg::Invalidate()
	{
	valid = FALSE;
	InvalidateRect(hPanel,NULL,FALSE);	
	}

		
void M3MatDlg::ReloadDialog()
	{
	UpdateMorphInfo(UD_NORM);

	for (int i=0; i<10; i++) 
		SetCheckBox(hPanel, IDC_TEXON1+i, theMtl->mapOn[i+theMtl->listSel]);

	UpdateSubMtlNames();

	SetCheckBox(hPanel,IDC_UPDATE1,FALSE);
	SetCheckBox(hPanel,IDC_UPDATE2,FALSE);
	SetCheckBox(hPanel,IDC_UPDATE3,FALSE);

	int q;
	theMtl->pblock->GetValue(100,ip->GetTime(),q,FOREVER);

	if(q==0) SetCheckBox(hPanel,IDC_UPDATE1,TRUE);
	if(q==1) SetCheckBox(hPanel,IDC_UPDATE2,TRUE);
	if(q==2) SetCheckBox(hPanel,IDC_UPDATE3,TRUE);

	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_undo.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_undo.cpp
 |			Weighted Morpher for MAX R3
 |			RestoreObj for deleting morph channels
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 17-2-99
 | 
\*===========================================================================*/

#include "wM3.h"



/*===========================================================================*\
 | MCRestore Class
\*===========================================================================*/

// Constructor
MCRestore::MCRestore(MorphR3 *mpi, int idx) 
{ 
	mp = mpi;
	mcIndex = idx;
	undoMC = mp->chanBank[idx];
}


// Called when Undo is selected
void MCRestore::Restore(int isUndo) 
{

	// This is NOT an undo operation ... we shouldn't get any of these
	// (but if we do, I'd like to know about it <g>)
	if (!isUndo) assert(0);

	mp->chanBank[mcIndex] = undoMC;

	// Update the rollups and the viewports
	mp->Update_channelFULL();
	mp->Update_channelParams();

	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	mp->ip->RedrawViews(mp->ip->GetTime());
}



// Called when Redo is selected
// since my undo-er is only for deleting channels
// if you redo, you're deleting a channel. So i do that here.
void MCRestore::Redo() 
{
	mp->chanBank[mcIndex].ResetMe();

	// Reassign paramblock info
	ParamBlockDescID *channelParams = new ParamBlockDescID[1];

	ParamBlockDescID add;
	add.type=TYPE_FLOAT;
	add.user=NULL;
	add.animatable=TRUE;
	add.id=1;
	channelParams[0] = add;

	mp->MakeRefByID(FOREVER, 1+mcIndex, CreateParameterBlock(channelParams,1,1));	
	assert(mp->chanBank[mcIndex].cblock);

	Control *c = (Control*)CreateInstance(CTRL_FLOAT_CLASS_ID,GetDefaultController(CTRL_FLOAT_CLASS_ID)->ClassID());

	mp->chanBank[mcIndex].cblock->SetValue(0,0,0.0f);
	mp->chanBank[mcIndex].cblock->SetController(0,c);

	delete channelParams;

	// Update the rollups and the viewports
	mp->Update_channelFULL();
	mp->Update_channelParams();

	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	mp->ip->RedrawViews(mp->ip->GetTime());
}


// Called to return the size in bytes of this RestoreObj
int MCRestore::Size() {
	return sizeof(MCRestore);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_pick.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_pick.cpp
 |			Weighted Morpher for MAX R3
 |			Pick mode methods
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 27-9-98
 | 
\*===========================================================================*/

#include "wM3.h"


BOOL  GetMorphNode::Filter(INode *node)
{
	Interval valid; 
	
	ObjectState os = node->GetObjectRef()->Eval(mp->ip->GetTime());

	if( os.obj->IsDeformable() == FALSE ) return FALSE;

	// Check for same-num-of-verts-count
	if( os.obj->NumPoints()!=mp->MC_Local.Count) return FALSE;

//	if (os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) {
//		return FALSE;
//		}

	node->BeginDependencyTest();
	mp->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
	if (node->EndDependencyTest()) {		
		return FALSE;
	} else {
		return TRUE;
		
		}
}


BOOL  GetMorphNode::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
{	
	if (ip->PickNode(hWnd,m,this)) {
		return TRUE;
	} else {
		return FALSE;
		}
}

BOOL  GetMorphNode::Pick(IObjParam *ip,ViewExp *vpt)
	{
	
	INode *node = vpt->GetClosestHit();
	if (node) {
		// Make the node reference, and then ask the channel to load itself

		UI_MAKEBUSY

		mp->ReplaceReference(101+mp->chanSel+mp->chanNum,node);
		mp->chanBank[mp->chanSel+mp->chanNum].buildFromNode(node);

		UI_MAKEFREE
	}
	
	return TRUE;
}


void  GetMorphNode::EnterMode(IObjParam *ip)
{
	// FIX: select the currently active viewport so that
	// the user can use the H shortcut
	ViewExp *ve = mp->ip->GetActiveViewport();
	SetFocus(ve->GetHWnd());
	mp->ip->ReleaseViewport(ve);

	// flag that we are infact picking
	isPicking=TRUE;

	ICustButton *iBut;

	iBut = GetICustButton(GetDlgItem(mp->hwChannelParams,IDC_PICK));
		if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);

	for( int i=IDC_P1;i<IDC_P10+1;i++){
	HWND button = GetDlgItem(mp->hwChannelList,i);
	iBut = GetICustButton(button);
		if (iBut) 
		{
			iBut->SetHighlightColor(GREEN_WASH);
			InvalidateRect(button, NULL, FALSE);
		}
	ReleaseICustButton(iBut);
	}
}

void  GetMorphNode::ExitMode(IObjParam *ip)
{
	isPicking=FALSE;

	ICustButton *iBut;

	iBut = GetICustButton(GetDlgItem(mp->hwChannelParams,IDC_PICK));
		if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);

	for( int i=IDC_P1;i<IDC_P10+1;i++){
	HWND button = GetDlgItem(mp->hwChannelList,i);
	iBut = GetICustButton(button);
		if (iBut) 
		{
			iBut->SetHighlightColor(RGB(210,210,210));
			InvalidateRect(button, NULL, FALSE);
		}
	ReleaseICustButton(iBut);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_main.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_main.cpp
 |			Weighted Morpher for MAX R3
 |			Main class and plugin code
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 22-5-98
 | 
\*===========================================================================*/


/*===========================================================================*\
 | Includes and global/macro setup
\*===========================================================================*/
#include "wM3.h"

ClassDesc* GetMorphR3Desc();

IObjParam *MorphR3::ip			= NULL;


/*===========================================================================*\
 | Parameter Blocks
\*===========================================================================*/


// Global parameter description
static ParamBlockDescID GlobalParams[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	// overrides: Use Limits
	{ TYPE_FLOAT, NULL, FALSE, 1 },	// overrides: Spinner Min
	{ TYPE_FLOAT, NULL, FALSE, 2 },	// overrides: Spinner Max
	{ TYPE_INT, NULL, FALSE, 3 },	// overrides: Use Selection
	{ TYPE_INT, NULL, FALSE, 4 },	// advanced:  Value increments
	{ TYPE_INT, NULL, FALSE, 5 },	// clist:	  Auto load
};
#define MR3_SIZE_GLOBALS	6


MorphR3::MorphR3()
{
	// Load the channels
	chanBank = new morphChannel[MR3_NUM_CHANNELS];
	chanNum = 0;
	chanSel = 0;

	for(int q=0;q<100;q++) chanBank[q].mp = this;

	newname = NULL;
	tccI = FALSE;

	// Zero and init the marker system
	markerName.ZeroCount();
	markerIndex.ZeroCount();
	markerSel		= -1;

	hwLegend = hwGlobalParams = hwChannelList = hwChannelParams = hwAdvanced = NULL;

	// Don't record anything yet!
	recordModifications = FALSE;
	recordTarget = 0;


	// Create the parameter block
	MakeRefByID(FOREVER, 0,CreateParameterBlock(GlobalParams,MR3_SIZE_GLOBALS,1));	
	assert(pblock);	


	// Assign some global defaults
	pblock->SetValue(PB_OV_USELIMITS,	0,	1);
	pblock->SetValue(PB_OV_SPINMIN,		0,	0.0f);
	pblock->SetValue(PB_OV_SPINMAX,		0,	100.0f);
	pblock->SetValue(PB_OV_USESEL,		0,	0);
	pblock->SetValue(PB_AD_VALUEINC,	0,	1);
	pblock->SetValue(PB_CL_AUTOLOAD,	0,	0);


	// Build the multiple set of pblocks
	for( int a=0;a<MR3_NUM_CHANNELS;a++){
	
		// Paramblock / morph channel so we have more organised TV support
		ParamBlockDescID *channelParams = new ParamBlockDescID[1];

		ParamBlockDescID add;
		add.type=TYPE_FLOAT;
		add.user=NULL;
		add.animatable=TRUE;
		add.id=1;
		channelParams[0] = add;

		MakeRefByID(FOREVER, 1+a, CreateParameterBlock(channelParams,1,1));	
		assert(chanBank[a].cblock);

		// TCB controller as default
		// This helps with the very erratic curve results you get when
		// animating with normal bezier float controllers
		Control *c = (Control*)CreateInstance(CTRL_FLOAT_CLASS_ID,GetDefaultController(CTRL_FLOAT_CLASS_ID)->ClassID());

		chanBank[a].cblock->SetValue(0,0,0.0f);
		chanBank[a].cblock->SetController(0,c);

		delete channelParams;
	}
}

MorphR3::~MorphR3()
{
	markerName.ZeroCount();
	markerIndex.ZeroCount();
	DeleteAllRefsFromMe();

	if(chanBank) delete [] chanBank;
	chanBank = NULL;

	Interface *Cip = GetCOREInterface();
	if(Cip&&tccI) { Cip->UnRegisterTimeChangeCallback(this); tccI=FALSE; }
}

void MorphR3::NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc)
{
	if( (partID&PART_TOPO) || (partID&PART_GEOM) || (partID&PART_SELECT) )
	{
		if(MC_Local.AreWeCached()) MC_Local.NukeCache();
		NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}
}

Interval MorphR3::LocalValidity(TimeValue t)
{
	Interval iv = FOREVER;
	float ftmp=0;
	int itmp=0;

	for(int i=0;i<100;i++)
	{
		chanBank[i].cblock->GetValue(0,t,ftmp,iv);	

		if(chanBank[i].mConnection)
		{
			chanBank[i].mConnection->GetNodeTM(t,&iv);
		}
	}

	int ALoad; 
	pblock->GetValue(PB_CL_AUTOLOAD, 0, ALoad, iv);
	if(ALoad==1) iv = Interval(t,t);

	return iv; 
}

RefTargetHandle MorphR3::Clone(RemapDir& remap)
{
	int x;

	MorphR3* newmod = new MorphR3();	

	if (pblock) newmod->ReplaceReference (0, pblock->Clone());

	for(x=1;x<=100;x++)		
	{
		newmod->ReplaceReference (x, chanBank[x-1].cblock->Clone());
		newmod->chanBank[x-1] = chanBank[x-1];
	}
	for(x=101;x<=200;x++)	newmod->ReplaceReference (x, chanBank[x-101].mConnection);

	newmod->markerName = markerName;
	newmod->markerIndex = markerIndex;

	return(newmod);
}



//From ReferenceMaker 
RefResult MorphR3::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	TSTR outputStr;

	switch (message) {


		/* AUTOLOAD
		case REFMSG_CHANGE:
		{
			if(pblock)
			{
			int itmp; Interval valid = FOREVER;
			pblock->GetValue(PB_CL_AUTOLOAD, 0, itmp, valid);

			if(itmp==1)
			{
					for(int k=0;k<100;k++)
					{
						if((INode*)hTarget==(INode*)chanBank[k].mConnection) 
						{
							chanBank[k].buildFromNode((INode*)hTarget);
						}
					}
			}
			}
			break;
		}*/


		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = defaultDim; 
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;

			switch (gpn->index) {

			case 0:	{		
					if(hTarget==pblock) gpn->name = TSTR(GetString(IDS_PBN_USELIMITS+gpn->index));

					for(int k=0;k<100;k++)
					{
						if(hTarget==chanBank[k].cblock&&chanBank[k].mActive!=FALSE) {	
							outputStr.printf(_T("[%d] %s  (%s)"), 
								k+1,
								chanBank[k].mName,
								chanBank[k].mConnection?GetString(IDS_ONCON):GetString(IDS_NOCON)
								);
							gpn->name = outputStr;
						}
					}
					break;}

			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
				{
				gpn->name = TSTR(GetString(IDS_PBN_USELIMITS+gpn->index));
				break;}


				default:
					{
						// 'should' never show up. catch what index it is asking
						// for if it ever does
						char s[25];
						sprintf(s,"debug_bad_index [%i]",gpn->index);
						gpn->name = TSTR(_T(s)); 
						break;
					}
				}
			return REF_STOP; 
			}

		// Handle the deletion of a morph target
		case REFMSG_TARGET_DELETED:{
			for(int u=0;u<100;u++){
			if (hTarget==chanBank[u].mConnection) {
				DeleteReference(101+u);
				chanBank[u].mConnection = NULL;
				}
			}
			Update_channelFULL();
			Update_channelParams();
			NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			NotifyDependents(FOREVER, PART_ALL, REFMSG_SUBANIM_STRUCTURE_CHANGED);
			break;
		}
	}

	return REF_SUCCEED;
}



// =====================================================================================
// SCARY REFERENCE AND SUBANIM STUFF




int MorphR3::NumRefs() 
{
	return 1+(MR3_NUM_CHANNELS*2);
}


// TODO: link this to the MR3_ defines

RefTargetHandle MorphR3::GetReference(int i) 
{
	if(i==0) return pblock;
	else if(i>0&&i<=100) return chanBank[i-1].cblock;
	else if(i>100&&i<=200) return chanBank[i-101].mConnection;
	else return NULL;
}

void MorphR3::SetReference(int i, RefTargetHandle rtarg)
{
	if(i==0) pblock = (IParamBlock*)rtarg;
	if(i>0&&i<=100) chanBank[i-1].cblock = (IParamBlock*)rtarg;
	if(i>100&&i<=200) chanBank[i-101].mConnection = (INode*)rtarg;
}



int MorphR3::NumSubs() 
{ 
	return 1+(MR3_NUM_CHANNELS);
}  
Animatable* MorphR3::SubAnim(int i) 
{ 
	if(i==0) return pblock;
	else if( chanBank[i-1].mActive == TRUE ) return chanBank[i-1].cblock;
	else return NULL; 
}

TSTR MorphR3::SubAnimName(int i) 
{ 
	if(i==0) return GetString(IDS_SUBANIMPARAM);
	else return _T(chanBank[i-1].mName);
}


class MorphR3PostLoadCallback : public PostLoadCallback {
	public:
		MorphR3PostLoadCallback(ParamBlockPLCB *c) {};
		void proc(ILoad *iload) {};
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_material.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_material.cpp
 |			Weighted Morpher for MAX R3
 |			Morph Material plugin component
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1998
 |			All Rights Reserved.
 |
 |  HIST:	Started 21-12-98
 | 
\*===========================================================================*/


#include "wM3.h"


extern HINSTANCE hInstance;

class M3MatClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new M3Mat(loading);}
	const TCHAR *	ClassName() {return GetString(IDS_MORPHMTL);}
	SClass_ID		SuperClassID() {return MATERIAL_CLASS_ID;}
	Class_ID 		ClassID() {return M3MatClassID;}
	const TCHAR* 	Category() {return _T("");}
	};
static M3MatClassDesc M3MatCD;
ClassDesc* GetM3MatDesc() {return &M3MatCD;}




M3Mat::M3Mat(BOOL loading)
	{	
	pblock = NULL;
	dlg = NULL;
	morphp = NULL;
	listSel = 0;

	int i;
	
	for(i=0;i<101;i++)
	{
		mTex[i] = NULL;
	}

	ivalid.SetEmpty();

	for (i=0; i<100; i++) 
		mapOn[i] = 1;

	if (!loading) 
		Reset();
	}

void M3Mat::Reset()
	{

//		char s[25];

		for(int i=0;i<100;i++)
		{
			DeleteReference(i);
			mTex[i] = NULL;
	//		ReplaceReference(i,NewDefaultStdMat());
	//		sprintf(s,GetString(IDS_MTL_CNAME),i+1);
	//		mTex[i]->SetName(s);
		}

		ReplaceReference(100,NewDefaultStdMat());
		mTex[100]->SetName(GetString(IDS_MTL_BASE));


	ParamBlockDescID *descVer = new ParamBlockDescID[101];

	for(int x=0;x<100;x++){

		ParamBlockDescID add;

		add.type=TYPE_FLOAT;

		add.user=NULL;

		add.animatable=TRUE;

		add.id=x;

	 descVer[x] = add;

	}

	ParamBlockDescID add;
	add.type=TYPE_INT;
	add.user=NULL;
	add.animatable=FALSE;
	add.id=x;
	descVer[x] = add;

	IParamBlock *pblock = (IParamBlock*)CreateParameterBlock(descVer,101,1);

	ReplaceReference(101,pblock);	
	//ReplaceReference(102,NULL);

	delete [] descVer;

	pblock->SetValue(100,0,0);

	}


static Color black(0,0,0);

Color M3Mat::GetAmbient(int mtlNum, BOOL backFace) { 
	return mTex[100]?mTex[100]->GetAmbient(mtlNum,backFace):black;
	}		
Color M3Mat::GetDiffuse(int mtlNum, BOOL backFace){ 
	return mTex[100]?mTex[100]->GetDiffuse(mtlNum,backFace):black;
	}				
Color M3Mat::GetSpecular(int mtlNum, BOOL backFace){
	return mTex[100]?mTex[100]->GetSpecular(mtlNum,backFace):black;
	}		
float M3Mat::GetXParency(int mtlNum, BOOL backFace) {
	return mTex[100]?mTex[100]->GetXParency(mtlNum,backFace):0.0f;
	}
float M3Mat::GetShininess(int mtlNum, BOOL backFace) {
	return mTex[100]?mTex[100]->GetXParency(mtlNum,backFace):0.0f;
	}		
float M3Mat::GetShinStr(int mtlNum, BOOL backFace) {
	return mTex[100]?mTex[100]->GetXParency(mtlNum,backFace):0.0f;
	}
float M3Mat::WireSize(int mtlNum, BOOL backFace) {
	return mTex[100]?mTex[100]->WireSize(mtlNum,backFace):0.0f;
	}
		
ParamDlg* M3Mat::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp)
	{
	dlg = new M3MatDlg(hwMtlEdit, imp, this);
	return dlg;
	}



void M3Mat::Shade(ShadeContext& sc) {
	int i; 

	TimeValue t = sc.CurTime();
	Interval valid = FOREVER;

	pblock->GetValue(100,t,i,FOREVER);

	Mtl *sm1 = mTex[100];

	// handle no base mat
	if(!sm1) 
	{
		sc.ResetOutput();
		sc.out.c = black;
		sc.out.t = black;
		return;
	}

	if(i==0||(i==1&&inRender))
	{

		ShadeOutput	sDatabase[100];
		float u[100];

		for( i=0;i<100;i++)
		{
			pblock->GetValue(i,t,u[i],valid);

			if(mTex[i]!=NULL&&u[i]!=0&&mapOn[i])
			{
				Mtl *comb = mTex[i];
				comb->Shade(sc);
				sDatabase[i] = sc.out;
				sc.ResetOutput();
			}
		}

		sc.ResetOutput();
		sm1->Shade(sc);

		for( i=0;i<100;i++)
		{
			if(mTex[i]!=NULL&&u[i]!=0&&mapOn[i])
			{
				float mI = u[i]/100.0f;

				// the old 'mix' fn that doesn't work for >2 mtls
				//sc.out.MixIn(sDatabase[i],1.0f-mI);

				float s = mI;
				sc.out.flags |= sDatabase[i].flags;
				sc.out.c = sc.out.c+ (s*sDatabase[i].c); 
				sc.out.t = sc.out.t+ (s*sDatabase[i].t); 

			}
		}

	}
	else sm1->Shade(sc);
}



void M3Mat::Update(TimeValue t, Interval& valid)
	{	
	ivalid = FOREVER;
	for(int i=0;i<101;i++)
	{
		if (mTex[i]) mTex[i]->Update(t,valid);
	}
	valid &= ivalid;
	}

Interval M3Mat::Validity(TimeValue t)
	{
	Interval valid = FOREVER;
	float f;
	int i;

	for(i=0;i<101;i++)
	{
		if (mTex[i]) valid &= mTex[i]->Validity(t);
	}
	for(i=0;i<101;i++)
	{
		pblock->GetValue(i,t,f,valid);
	}

	return valid;
	}




/*===========================================================================*\
 | Subanims and References setup
\*===========================================================================*/

Animatable* M3Mat::SubAnim(int i)
	{
	if(i<101) return mTex[i];
	return NULL;
	}

TSTR M3Mat::SubAnimName(int i)
	{
	 return GetSubMtlSlotName(i);
	}

RefTargetHandle M3Mat::GetReference(int i)
	{
	if(i<101) return mTex[i];
	if(i==101) return pblock;
	if(i==102) return morphp;
	return NULL;
	}

void M3Mat::SetReference(int i, RefTargetHandle rtarg)
	{
	if(i<101) mTex[i] = (Mtl*)rtarg;
	if(i==101) pblock = (IParamBlock*)rtarg;
	if(i==102) morphp = (MorphR3*)rtarg;
	}



/*===========================================================================*\
 | Duplicate myself
\*===========================================================================*/

RefTargetHandle M3Mat::Clone(RemapDir &remap)
	{
	M3Mat *mtl = new M3Mat(FALSE);
	*((MtlBase*)mtl) = *((MtlBase*)this);

	int i;

	for(i=0;i<101;i++)
	{
		if (mTex[i]) mtl->ReplaceReference(i,remap.CloneRef(mTex[i]));
	}

	for (i=0; i<100; i++)
		mtl->mapOn[i] = mapOn[i];

	//mtl->morphp = morphp;
	mtl->ReplaceReference(101,remap.CloneRef(pblock));
	mtl->ReplaceReference(102,remap.CloneRef(morphp));

	mtl->obName = obName;

	return (RefTargetHandle)mtl;
	}



/*===========================================================================*\
 | NotifyRefChanged
\*===========================================================================*/

RefResult M3Mat::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			if (dlg && dlg->theMtl==this) dlg->Invalidate();
			break;
				
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = stdPercentDim;
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			char s[50];
			sprintf(s,GetString(IDS_MTL_CNAME),gpn->index);
			gpn->name = s;
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}



/*===========================================================================*\
 | Displacement support
\*===========================================================================*/

float M3Mat::EvalDisplacement(ShadeContext& sc) {

	int i; 

	TimeValue t = sc.CurTime();
	Interval valid = FOREVER;

	pblock->GetValue(100,t,i,FOREVER);

	Mtl *sm1 = mTex[100];

	int counter = 0;
	float final = 0.0f;

	// handle no base mat
	if(sm1==NULL) 
	{
		return 0.0f;
	}

	if(i==0||(i==1&&inRender))
	{

		float u[100];

		for( i=0;i<100;i++)
		{
			pblock->GetValue(i,t,u[i],valid);

			if(mTex[i]!=NULL&&u[i]!=0&&mapOn[i])
			{
				Mtl *comb = mTex[i];
				float mI = u[i]/100.0f;
				final += (comb->EvalDisplacement(sc)*mI);
				counter++;
			}
		}

		float tF = final;
		if(counter>0) tF /= (float)counter;

		return final;

	}
	else 
	{
		return sm1->EvalDisplacement(sc);
	}

}

Interval M3Mat::DisplacementValidity(TimeValue t) 
{
	
	Interval iv; iv.SetInfinite();

	Mtl *sm1 = mTex[100];
	if(sm1) iv &= sm1->DisplacementValidity(t);

	for( int i=0;i<100;i++)
	{
		if(mTex[i]!=NULL&&mapOn[i])
		{
			Mtl *comb = mTex[i];
			iv &= comb->DisplacementValidity(t);
		}
	}

	return iv;	
} 



/*===========================================================================*\
 | Loading and Saving of material data
\*===========================================================================*/

#define MTL_HDR_CHUNK 0x4000
#define MAPOFF_CHUNK 0x1000

IOResult M3Mat::Save(ISave *isave) { 
	IOResult res;
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	for (int i=0; i<100; i++) {
		if (mapOn[i]==0) {
			isave->BeginChunk(MAPOFF_CHUNK+i);
			isave->EndChunk();
			}
		}

	return IO_OK;
	}	
	  

IOResult M3Mat::Load(ILoad *iload) { 
	int id;
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			}

		for(int i=0;i<100;i++)
		{
			if(id==MAPOFF_CHUNK+i) mapOn[id-MAPOFF_CHUNK] = 0;
		}

		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\Morpher\wM3_subdlg.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	wM3_subdlg.cpp
 |			Weighted Morpher for MAX R3
 |			UI Handler and management code for minor dialogs
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 24-11-98
 | 
\*===========================================================================*/

#include "wM3.h"



/*===========================================================================*\
 |
 | Name Captured object page
 |
\*===========================================================================*/


BOOL CALLBACK NameDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	MorphR3 *mp = (MorphR3*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mp && msg!=WM_INITDIALOG) return FALSE;


	switch (msg) {
		case WM_INITDIALOG:{
			mp = (MorphR3*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,(LONG)mp);

			HWND maxWnd = mp->ip->GetMAXHWnd();
			CenterWindow(hWnd,maxWnd);
			EnableWindow(maxWnd,FALSE);

			mp->newname = GetICustEdit(GetDlgItem(hWnd,IDC_NEWNAME));
			mp->newname->SetText(GetString(IDS_CAPTURED));
			mp->newname->SetLeading(3);

			SetFocus(GetDlgItem(hWnd,IDOK));

			break;
			}

		case WM_CLOSE:
			break;

		case WM_DESTROY:
			ReleaseICustEdit(mp->newname);
			mp->newname = NULL;
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:

					TCHAR nametoUse[256];
					mp->newname->GetText(nametoUse,255);

					mp->chanBank[mp->recordTarget].mName = nametoUse;

					EnableWindow(mp->ip->GetMAXHWnd(),TRUE);
					EndDialog(hWnd,1);
					break;
			}

			break;

		default:
			return FALSE;
	}
	return TRUE;
}



/*===========================================================================*\
 |
 | Legend page showing colour indicators
 |
\*===========================================================================*/


BOOL CALLBACK Legend_DlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	MorphR3 *mp = (MorphR3*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mp && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {

		case WM_PAINT:
		{
			PAINTSTRUCT ps;
			BeginPaint(hWnd,&ps);

			int q;
			for( q=0;q<5;q++ )
			{
				// Get next CI
				HWND item = GetDlgItem(hWnd,(IDC_IC1+q));
				Rect rect;
				GetClientRect(item,&rect);
				HDC hdc = GetDC(item);
				
				// choose the indicator colour
				COLORREF FilCol;
				FilCol = GetSysColor(COLOR_3DFACE);
				if(q==1) FilCol = RGB(255,160,0);
				if(q==2) FilCol = RGB(0,255,0);
				if(q==3) FilCol = RGB(10,10,255);
				if(q==4) FilCol = RGB(90,90,90);


				// Draw the button-y outline around the colour indicator
				Rect tR = rect;
				tR.right--;
				tR.bottom--;
				Rect3D(hdc,tR,FALSE);

				HPEN Pen = CreatePen( PS_SOLID , 1 , FilCol );
				SelectObject(hdc,Pen);
				LOGBRUSH BR;
				BR.lbStyle = BS_SOLID;
				BR.lbColor = FilCol;
				
				HBRUSH Brush = CreateBrushIndirect(&BR);
				SelectObject(hdc,Brush);


				Rectangle( hdc, 1,1,rect.w()-2,rect.h()-2);

				DeleteObject(Pen);
				DeleteObject(Brush);

			ReleaseDC(item,hdc);
			}
			
			EndPaint(hWnd,&ps);
		break;}


		case WM_INITDIALOG:{

			// Update the class pointer
			mp = (MorphR3*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mp->hwLegend = hWnd;

			for(int i=0;i<5;i++)
			{
				LONG style = GetWindowLong(GetDlgItem(hWnd,IDC_IC1+i),GWL_STYLE);
				style &= ~(SS_BLACKFRAME);
				style |= SS_OWNERDRAW;
				SetWindowLong(GetDlgItem(hWnd,IDC_IC1+i),GWL_STYLE,style);
			}

			break;}


		default:
			return FALSE;
	}
	return TRUE;
}

/*===========================================================================*\
 |
 | Globals Page Rollout
 |
\*===========================================================================*/


BOOL CALLBACK Globals_DlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	MorphR3 *mp = (MorphR3*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mp && msg!=WM_INITDIALOG) return FALSE;
	Interval valid=FOREVER;
	int tmp; float ntmp;

	switch (msg) {

		case WM_PAINT:
		{
			PAINTSTRUCT ps;
			BeginPaint(hWnd,&ps);

			int q;
			for( q=0;q<4;q++ )
			{
				// Get next CI
				HWND item = GetDlgItem(hWnd,(IDC_IC1+q));
				Rect rect;
				GetClientRect(item,&rect);
				HDC hdc = GetDC(item);
				
				// choose the indicator colour
				COLORREF FilCol;
				FilCol = GetSysColor(COLOR_3DFACE);
				if(q==1) FilCol = RGB(255,160,0);
				if(q==2) FilCol = RGB(0,255,0);
				if(q==3) FilCol = RGB(10,10,255);


				// Draw the button-y outline around the colour indicator
				Rect tR = rect;
				tR.right--;
				tR.bottom--;
				Rect3D(hdc,tR,FALSE);

				HPEN Pen = CreatePen( PS_SOLID , 1 , FilCol );
				SelectObject(hdc,Pen);
				LOGBRUSH BR;
				BR.lbStyle = BS_SOLID;
				BR.lbColor = FilCol;
				
				HBRUSH Brush = CreateBrushIndirect(&BR);
				SelectObject(hdc,Brush);


				Rectangle( hdc, 1,1,rect.w()-2,rect.h()-2);

				DeleteObject(Pen);
				DeleteObject(Brush);

			ReleaseDC(item,hdc);
			}
			
			EndPaint(hWnd,&ps);
		break;}


		case WM_INITDIALOG:{

			// Update the class pointer
			mp = (MorphR3*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mp->hwGlobalParams = hWnd;

			// Load the values from the pblock

			// MAX/MIN spinners
			float smin,smax;
			mp->pblock->GetValue(PB_OV_SPINMIN, mp->ip->GetTime(), smin, valid);
			mp->pblock->GetValue(PB_OV_SPINMAX, mp->ip->GetTime(), smax, valid);

			mp->glSpinmin = SetupFloatSpinner(hWnd, IDC_MIN_SPIN, IDC_MIN_EDIT, -999.9f, smax, smin);
			mp->glSpinmin->SetScale(mp->GetIncrements());

			mp->glSpinmax = SetupFloatSpinner(hWnd, IDC_MAX_SPIN, IDC_MAX_EDIT, smin, 999.9f, smax);
			mp->glSpinmax->SetScale(mp->GetIncrements());

			// USELIMITS checkbox
			mp->pblock->GetValue(PB_OV_USELIMITS, mp->ip->GetTime(), tmp, valid);
			SetCheckBox(hWnd,IDC_LIMIT, tmp );

			// USESEL button
			mp->pblock->GetValue(PB_OV_USESEL, mp->ip->GetTime(), tmp, valid);
			ICustButton *iTmp;
				iTmp = GetICustButton(GetDlgItem(hWnd,IDC_USESEL));
				iTmp->SetType(CBT_CHECK);
				iTmp->SetHighlightColor(BLUE_WASH);
				
				if(tmp) iTmp->SetCheck(TRUE);
				else iTmp->SetCheck(FALSE);

			ReleaseICustButton(iTmp);


			for(int i=0;i<4;i++)
			{
				LONG style = GetWindowLong(GetDlgItem(hWnd,IDC_IC1+i),GWL_STYLE);
				style &= ~(SS_BLACKFRAME);
				style |= SS_OWNERDRAW;
				SetWindowLong(GetDlgItem(hWnd,IDC_IC1+i),GWL_STYLE,style);
			}

			break;}


		case WM_DESTROY:
			ReleaseISpinner(mp->glSpinmin);
			ReleaseISpinner(mp->glSpinmax);
			break;



		// Spinner change handling
		case CC_SPINNER_CHANGE:
			if (!theHold.Holding()) theHold.Begin();
			switch (LOWORD(wParam)) {
				case IDC_MIN_SPIN: 
					ntmp = mp->glSpinmin->GetFVal();
					mp->glSpinmax->SetLimits(ntmp,999.9f,FALSE);
					mp->pblock->SetValue( PB_OV_SPINMIN, 0, ntmp );
					break;
				case IDC_MAX_SPIN: 
					ntmp = mp->glSpinmax->GetFVal();
					mp->glSpinmin->SetLimits(-999.9f,ntmp,FALSE);
					mp->pblock->SetValue( PB_OV_SPINMAX, 0, ntmp );
					break;

			}
			break;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;	

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) theHold.Accept(GetString(IDS_PC_MORPH));
			else theHold.Cancel();

			// Update those limit changes
			mp->Update_channelLimits();
			break;



		case WM_COMMAND:
			switch (LOWORD(wParam)) {

			case IDC_USESEL:
				if (!theHold.Holding()) theHold.Begin();
					ICustButton *iTmp;
						iTmp = GetICustButton(GetDlgItem(hWnd,IDC_USESEL));
						mp->pblock->SetValue(PB_OV_USESEL, 0, iTmp->IsChecked());
					ReleaseICustButton(iTmp);
				theHold.Accept(GetString(IDS_PC_MORPH));
				mp->Update_channelParams();
				mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
				mp->ip->RedrawViews(mp->ip->GetTime());
				break;

			case IDC_LIMIT:
				if (!theHold.Holding()) theHold.Begin();
					mp->pblock->SetValue(PB_OV_USELIMITS, 0, GetCheckBox(hWnd,IDC_LIMIT));
				theHold.Accept(GetString(IDS_PC_MORPH));
					mp->Update_channelLimits();
					mp->Update_channelParams();
				break;


			case IDC_ALL_ACTIVATE:
				{
					for(int i=0;i<100;i++) mp->chanBank[i].mActiveOverride = TRUE;
					mp->Update_colorIndicators();
					mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mp->ip->RedrawViews(mp->ip->GetTime());
					break;}

			case IDC_ALL_DEACTIVATE:
				{
					for(int i=0;i<100;i++) mp->chanBank[i].mActiveOverride = FALSE;
					mp->Update_colorIndicators();
					mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					mp->ip->RedrawViews(mp->ip->GetTime());
					break;}


/*
			case IDC_LOAD:{
				int res = DialogBoxParam( 
					hInstance, 
					MAKEINTRESOURCE( IDD_MC_IMPORT ),
					hWnd,
					(DLGPROC)IMPORT_DlgProc,
					(LPARAM)(MorphR3*)mp);
				break;}


			case IDC_SAVE:{
				int res = DialogBoxParam( 
					hInstance, 
					MAKEINTRESOURCE( IDD_MC_EXPORT ),
					hWnd,
					(DLGPROC)EXPORT_DlgProc,
					(LPARAM)(MorphR3*)mp);
				break;}
*/



			case IDC_MTLASSIGN:{
				if(mp->ip->GetSelNodeCount()==1) 
				{
					INode *node = mp->ip->GetSelNode(0);
					M3Mat *mmtl = (M3Mat*)CreateInstance(MATERIAL_CLASS_ID,M3MatClassID);
					mmtl->morphp = (MorphR3*)mp;
					mmtl->obName = node->GetName();

					// Wire up our pblock to mtl
					for(int i=0;i<100;i++)
					{
						Control *c = mp->chanBank[i].cblock->GetController(0);
						mmtl->pblock->SetController(i,c);
					}

					node->SetMtl(mmtl);
					mp->ip->RedrawViews(mp->ip->GetTime());
				}
				else
				{
					MessageBox(hWnd,GetString(IDS_MTL_NOOBJ),GetString(IDS_CLASS_NAME),MB_OK);
				}

				break;}

			}
			break;

		default:
			return FALSE;
	}
	return TRUE;
}



/*===========================================================================*\
 |
 | Advanced Settings Rollout
 |
\*===========================================================================*/


BOOL CALLBACK Advanced_DlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	MorphR3 *mp = (MorphR3*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mp && msg!=WM_INITDIALOG) return FALSE;
	Interval valid=FOREVER;
	int tmp;

	switch (msg) {
		case WM_INITDIALOG:{

			// Update the class pointer
			mp = (MorphR3*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mp->hwAdvanced = hWnd;

			// VALUEINC radio button
			mp->pblock->GetValue(PB_AD_VALUEINC, mp->ip->GetTime(), tmp, valid);

			ICustButton *iTmp;
			int bIdx = 0;
			for( int i=IDC_V1; i<IDC_V3+1; i++)
			{
				iTmp = GetICustButton(GetDlgItem(hWnd,i));
				iTmp->SetType(CBT_CHECK);
				iTmp->SetHighlightColor(BLUE_WASH);
				
				if(bIdx==tmp) iTmp->SetCheck(TRUE);
				else iTmp->SetCheck(FALSE);

			ReleaseICustButton(iTmp);
			bIdx++;
			}

			break;
			}

		case WM_DESTROY:
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
			case IDC_V1:{
					ICustButton *iTmp;
					iTmp = GetICustButton(GetDlgItem(hWnd,IDC_V1));
					iTmp->SetCheck(TRUE);

					iTmp = GetICustButton(GetDlgItem(hWnd,IDC_V2));
					iTmp->SetCheck(FALSE);
					iTmp = GetICustButton(GetDlgItem(hWnd,IDC_V3));
					iTmp->SetCheck(FALSE);
					ReleaseICustButton(iTmp);
					mp->pblock->SetValue(PB_AD_VALUEINC, 0, 0);

					// Now update the UIs
					mp->Update_SpinnerIncrements();

					break;}
			case IDC_V2:{
					ICustButton *iTmp;
					iTmp = GetICustButton(GetDlgItem(hWnd,IDC_V2));
					iTmp->SetCheck(TRUE);

					iTmp = GetICustButton(GetDlgItem(hWnd,IDC_V1));
					iTmp->SetCheck(FALSE);
					iTmp = GetICustButton(GetDlgItem(hWnd,IDC_V3));
					iTmp->SetCheck(FALSE);
					ReleaseICustButton(iTmp);
					mp->pblock->SetValue(PB_AD_VALUEINC, 0, 1);

					// Now update the UIs
					mp->Update_SpinnerIncrements();

					break;}
			case IDC_V3:{
					ICustButton *iTmp;
					iTmp = GetICustButton(GetDlgItem(hWnd,IDC_V3));
					iTmp->SetCheck(TRUE);

					iTmp = GetICustButton(GetDlgItem(hWnd,IDC_V2));
					iTmp->SetCheck(FALSE);
					iTmp = GetICustButton(GetDlgItem(hWnd,IDC_V1));
					iTmp->SetCheck(FALSE);
					ReleaseICustButton(iTmp);
					mp->pblock->SetValue(PB_AD_VALUEINC, 0, 2);

					// Now update the UIs
					mp->Update_SpinnerIncrements();

					break;}


			// Compress all fringe channels into one solid block
			case IDC_COMPACT:{
					UI_MAKEBUSY

					Tab<int>	activeInd;
					activeInd.ZeroCount();

					int i,flag,numMoved=0;

					// Gather a list of all modified channels
					for(i=0;i<100;i++)
					{
						int n = i;
						if(mp->chanBank[i].mModded) activeInd.Append(1,&n,0);
					}


					// For each modified channel, search the 100 channel entries
					// If it is empty, and lies below the source channel's index
					// Then copy. If not, leave it there.
					for(int x=0;x<activeInd.Count();x++)
					{
						for(i=0;i<100;i++)
						{
							if(!mp->chanBank[i].mModded) 
							{
								int targIdx = i;
								int srcIdx = activeInd[x];

								if(targIdx<srcIdx)
								{
									mp->ChannelOp(i,activeInd[x],OP_MOVE);
									numMoved++;
									goto jumpStart;
								}
							}
						}
						jumpStart:
						flag = 0;
					}

					mp->Update_channelFULL();
					mp->Update_channelParams();

					char s[50];
					sprintf(s,"%i Channels Moved",numMoved);
					SetWindowText(GetDlgItem(hWnd,IDC_COMPACTSTAT),s);

					UI_MAKEFREE
					break;}


			// Ask the channels for a memory approximation
			case IDC_MEMAPPOX:{
					float tmSize = 0.0f;
					for(int i=0;i<100;i++) tmSize += mp->chanBank[i].getMemSize();
					char s[20];
					sprintf(s,"%i KB", (int)tmSize/1000);
					SetWindowText(GetDlgItem(hWnd,IDC_MEMSIZE),s);					
					break;}
			}

			break;

		default:
			return FALSE;
	}
	return TRUE;
}





BOOL CALLBACK ChannelOpDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	MorphR3 *mp = (MorphR3*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mp && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:{
			mp = (MorphR3*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,(LONG)mp);

			HWND maxWnd = mp->ip->GetMAXHWnd();
			CenterWindow(hWnd,maxWnd);
			EnableWindow(maxWnd,FALSE);
			

			// Load active channels
			HWND clist = GetDlgItem(hWnd,IDC_CLIST);
			SendMessage(clist,LB_RESETCONTENT,0,0);

			for(int i=0;i<100;i++)
			{
				char tmp[255];
				int Cind = i+1;

				sprintf(tmp, "%i : %s", Cind, mp->chanBank[i].mName );
				SendMessage(clist,LB_ADDSTRING,0,(LPARAM)tmp);
			}


			// Set the 'perform operation' button to appropriate text
			HWND opWnd = GetDlgItem(hWnd,IDC_PERFORMOP);
			if(mp->cOp == OP_MOVE) SetWindowText(opWnd,GetString(IDS_OPMOVE));
			if(mp->cOp == OP_SWAP) SetWindowText(opWnd,GetString(IDS_OPSWAP));

			break;
			}

		case WM_CLOSE:
			break;

		case WM_DESTROY:
			break;

		case WM_COMMAND:

			// Status of operation
			if ( HIWORD(wParam) == LBN_SELCHANGE ) {
				HWND clist = GetDlgItem(hWnd,IDC_CLIST);
				HWND statWnd = GetDlgItem(hWnd,IDC_STAT);
				int targIdx = SendMessage(clist,LB_GETCURSEL,0,0);

				SetWindowText(statWnd,GetString(IDS_OPOKAY));
				EnableWindow(GetDlgItem(hWnd,IDC_PERFORMOP),TRUE);
				if(mp->cOp == OP_MOVE)
				{
					if(mp->chanBank[targIdx].mModded) SetWindowText(statWnd,GetString(IDS_OPWARN));
				}
				if(targIdx == mp->srcIdx) 
				{
					SetWindowText(statWnd,GetString(IDS_OPCANT));
					EnableWindow(GetDlgItem(hWnd,IDC_PERFORMOP),FALSE);
				}
			}

			switch (LOWORD(wParam)) {
				case IDC_CANCEL:
					EnableWindow(mp->ip->GetMAXHWnd(),TRUE);
					EndDialog(hWnd,1);
					break;

				case IDC_PERFORMOP:
					int targIdx = SendMessage(GetDlgItem(hWnd,IDC_CLIST),LB_GETCURSEL,0,0);
					mp->ChannelOp(targIdx,mp->srcIdx,mp->cOp);
					EnableWindow(mp->ip->GetMAXHWnd(),TRUE);
					EndDialog(hWnd,1);
					break;
			}

			break;

		default:
			return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\VertexPaint\dllmain.cpp ===
#include "VertexPaint.h"


HINSTANCE hInstance;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved)
	{
	hInstance = hinstDLL;				// Hang on to this DLL's instance handle.

	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			InitCustomControls(hInstance);	// Initialize MAX's custom controls
			InitCommonControls();			// Initialize Win95 controls
			break;
		}
			
	return (TRUE);
	}

__declspec( dllexport ) const TCHAR* LibDescription()
	{
	return GetString(IDS_LIBDESCRIPTION);
	}


__declspec( dllexport ) int LibNumberClasses()
	{
	return 1;
	}

__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
	{
	switch(i) {
		case 0: return GetVertexPaintDesc();
		default: return 0;
		}
	}

__declspec( dllexport ) ULONG LibVersion()
	{
	return VERSION_3DSMAX;
	}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\VertexPaint\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VertexPaint.rc
//
#define IDS_LIBDESCRIPTION              1
#define IDS_CATEGORY                    2
#define IDS_CLASS_NAME                  3
#define IDS_PARAMS                      4
#define IDS_PAINTPROMPT                 5
#define IDS_RESTORE                     6
#define IDS_PAINT                       7
#define IDS_PICK                        8
#define IDD_PANEL                       101
#define IDB_BUTTONS                     101
#define IDB_BUTTON_MASK                 102
#define IDC_PAINTCURSOR                 103
#define IDC_DROPPER_CURSOR              121
#define IDC_CLOSEBUTTON                 1000
#define IDC_DOSTUFF                     1000
#define IDC_PAINT                       1001
#define IDC_PICK                        1002
#define IDC_VC_ON                       1004
#define IDC_SHADED                      1005
#define IDC_COLOR                       1456
#define IDC_PALETTE_1                   1457
#define IDC_PALETTE_2                   1458
#define IDC_PALETTE_3                   1459
#define IDC_PALETTE_4                   1460
#define IDC_PALETTE_5                   1461
#define IDC_PALETTE_6                   1462
#define IDC_PALETTE_7                   1463
#define IDC_PALETTE_8                   1464
#define IDC_PALETTE_9                   1465
#define IDC_PALETTE_10                  1466
#define IDC_PALETTE_11                  1467
#define IDC_PALETTE_12                  1468
#define IDC_PALETTE_13                  1469
#define IDC_PALETTE_14                  1470
#define IDC_PALETTE_15                  1471
#define IDC_PALETTE_16                  1472
#define IDC_EDIT                        1490
#define IDC_SPIN                        1496
#define IDC_TINT                        3023
#define IDC_TINT_SPIN                   3028

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\VertexPaint\VertexPaint.cpp ===
/**********************************************************************
 *<
	FILE: VertexPaint.cpp

	DESCRIPTION:	Modifier implementation	

	CREATED BY: Christer Janson, Nikolai Sander

	HISTORY: 

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "VertexPaint.h"
#include "meshdelta.h"

// flags:
#define VP_DISP_END_RESULT 0x01

static WNDPROC colorSwatchOriginalWndProc;

static	HIMAGELIST hButtonImages = NULL;

static void LoadImages() {
	if (hButtonImages) return;
	HBITMAP hBitmap, hMask;
	hButtonImages = ImageList_Create(15, 14, ILC_MASK, 2, 0);	// 17 is kluge to center square. -SA
	hBitmap     = LoadBitmap (hInstance,MAKEINTRESOURCE(IDB_BUTTONS));
	hMask       = LoadBitmap (hInstance,MAKEINTRESOURCE(IDB_BUTTON_MASK));
	ImageList_Add(hButtonImages, hBitmap, hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
}

ClassDesc* GetVertexPaintDesc();


class VertexPaintClassDesc:public ClassDesc {
	public:
	int 			IsPublic()					{return 1;}
	void *			Create(BOOL loading = FALSE){return new VertexPaint();}
	const TCHAR *	ClassName()					{return GetString(IDS_CLASS_NAME);}
	SClass_ID		SuperClassID()				{return OSM_CLASS_ID;}
	Class_ID		ClassID()					{return VERTEXPAINT_CLASS_ID;}
	const TCHAR* 	Category()					{return GetString(IDS_CATEGORY);}
	void			ResetClassParams(BOOL fileReset) {}
	};

static VertexPaintClassDesc VertexPaintDesc;
ClassDesc* GetVertexPaintDesc() {return &VertexPaintDesc;}

static BOOL CALLBACK VertexPaintDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	int numPoints;
	VertexPaint *mod = (VertexPaint*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mod && msg!=WM_INITDIALOG) return FALSE;

	
	if (((msg==CC_SPINNER_BUTTONUP) && HIWORD(wParam)) ||
		((msg==CC_SPINNER_CHANGE) ))
	{
		ISpinnerControl *spin;
		spin = (ISpinnerControl *) lParam;
		
		switch (LOWORD(wParam)) 
		{
		case IDC_TINT_SPIN:
			if ((msg == CC_SPINNER_CHANGE))
			{
				mod->fTint = spin->GetFVal()/100;
			}
			break;
		}
	}

	switch (msg) {
		case WM_INITDIALOG:
			LoadImages();
			mod = (VertexPaint*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mod->hParams = hWnd;
			mod->iPaintButton = GetICustButton(GetDlgItem(hWnd, IDC_PAINT));
			mod->iPaintButton->SetType(CBT_CHECK);
			mod->iPaintButton->SetHighlightColor(GREEN_WASH);
			mod->iPaintButton->SetCheck(mod->ip->GetCommandMode()->ID() == CID_PAINT && 
				!((PaintMouseProc *)mod->ip->GetCommandMode()->MouseProc(&numPoints))->GetPickMode());
			mod->iPaintButton->SetImage(hButtonImages,0,0,0,0,15,14);
			mod->iPaintButton->SetTooltip (TRUE, GetString (IDS_PAINT));

			mod->iPickButton = GetICustButton(GetDlgItem(hWnd, IDC_PICK));
			mod->iPickButton->SetType(CBT_CHECK);
			mod->iPickButton->SetHighlightColor(GREEN_WASH);
			mod->iPickButton->SetCheck(mod->ip->GetCommandMode()->ID() == CID_PAINT && 
				((PaintMouseProc *)mod->ip->GetCommandMode()->MouseProc(&numPoints))->GetPickMode());
			mod->iPickButton->SetImage(hButtonImages,1,1,1,1,15,14);
			mod->iPickButton->SetTooltip (TRUE, GetString (IDS_PICK));


			mod->iColor = GetIColorSwatch(GetDlgItem(hWnd, IDC_COLOR));
			mod->iColor->SetColor(mod->lastColor);
			break;

		case WM_POSTINIT:
			mod->InitPalettes();
			break;

		case CC_COLOR_CHANGE:
			if (LOWORD(wParam) == IDC_COLOR) {
				IColorSwatch* iCol = (IColorSwatch*)lParam;
				mod->lastColor = iCol->GetColor();
				}
			break;
		case WM_DESTROY:
			mod->SavePalettes();
			mod->iPaintButton = NULL;
			mod->iPickButton = NULL;
			mod->iColor = NULL;
			break;

		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDC_PAINT:
					mod->ActivatePaint(mod->iPaintButton->IsChecked());
					break;
				case IDC_PICK:
					mod->ActivatePaint(mod->iPickButton->IsChecked(),TRUE);
					break;

				case IDC_VC_ON:
					mod->TurnVCOn(FALSE);
					break;
				case IDC_SHADED:
					mod->TurnVCOn(TRUE);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

// Subclass procedure 
LRESULT APIENTRY colorSwatchSubclassWndProc(
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam) 
{
	switch (uMsg) {
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_LBUTTONDBLCLK: {
			HWND hPanel = GetParent(hwnd);
			LONG mod = GetWindowLong(hPanel,GWL_USERDATA);
			if (mod) {
				((VertexPaint*)mod)->PaletteButton(hwnd);
				}
			}
			break;
		case WM_DESTROY:
			SetWindowLong(hwnd, GWL_WNDPROC, (LONG) colorSwatchOriginalWndProc); 
			// Fallthrough...
		default:
			return CallWindowProc(colorSwatchOriginalWndProc, hwnd, uMsg, wParam, lParam); 
			break;
		}
	return 0;
	}
 

IObjParam *VertexPaint::ip			= NULL;
HWND VertexPaint::hParams			= NULL;		
VertexPaint* VertexPaint::editMod	= NULL;
ICustButton* VertexPaint::iPaintButton	= NULL;
ICustButton* VertexPaint::iPickButton	= NULL;
IColorSwatch* VertexPaint::iColor	= NULL;
COLORREF VertexPaint::lastColor		= RGB(255,255,255);
COLORREF VertexPaint::palColors[]	= {
	RGB(255,  0,  0),	RGB(  0,255,  0),	RGB(  0,  0,255),	RGB(255,255,255),
	RGB(255,255,  0),	RGB(  0,255,255),	RGB(255,  0,255),	RGB(170,170,170),
	RGB(128,  0,  0),	RGB(  0,128,  0),	RGB(  0,  0,128),	RGB( 85, 85, 85),
	RGB(128,128,  0),	RGB(  0,128,128),	RGB(128,  0,128),	RGB(  0,  0,  0)
	};


//--- VertexPaint -------------------------------------------------------
VertexPaint::VertexPaint() : iTint(NULL), fTint(1.0f)
	{
	flags = 0x0;
	}

VertexPaint::~VertexPaint()
	{
	}

Interval VertexPaint::LocalValidity(TimeValue t)
	{
	return FOREVER;
	}

BOOL VertexPaint::DependOnTopology(ModContext &mc)
	{
	return TRUE;
	}

RefTargetHandle VertexPaint::Clone(RemapDir& remap)
	{
	VertexPaint* newmod = new VertexPaint();	
	return(newmod);
	}

void VertexPaint::NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc)
	{
	if (!mc->localData) return;
	((VertexPaintData*)mc->localData)->FreeCache();

	}

void VertexPaint::ModifyObject(TimeValue t, ModContext &mc, ObjectState * os, INode *node) 
	{
	if (!os->obj->IsSubClassOf(triObjectClassID)) return;
	
	os->obj->ReadyChannelsForMod(GEOM_CHANNEL|TOPO_CHANNEL|VERTCOLOR_CHANNEL|TEXMAP_CHANNEL);
	
	TriObject *tobj = (TriObject*)os->obj;
	VertexPaintData *d  = (VertexPaintData*)mc.localData;
		
	Mesh* mesh = &tobj->GetMesh();
	
	if (mesh) 
	{
		// We don't have any VColors yet, so we allocate the vcfaces
		// and set all vcolors to black (index 0)

		if (!mesh->vcFace) 
		{
			mesh->setNumVCFaces(mesh->getNumFaces());
			mesh->setNumVertCol(1);
			
			mesh->vertCol[0] = Color(1,1,1);

			for (int f=0; f<mesh->getNumFaces(); f++) 
			{
				mesh->vcFace[f].t[0] = 0;
				mesh->vcFace[f].t[1] = 0;
				mesh->vcFace[f].t[2] = 0;
			}
		}

		if (!d) mc.localData = d = new VertexPaintData(tobj->GetMesh());	
		if (!d->GetMesh()) d->SetCache(*mesh);	
		
		// If we're not in face SO mode, it's easier !

		if(mesh->selLevel == MESH_OBJECT || mesh->selLevel == MESH_VERTEX )
		{
			MeshDelta md(*mesh);
			//MeshDelta mdc;
			//if(cache) mdc.InitToMesh(*cache);

			// If the incoming Mesh had no vertex colors, this will add a default map to start with.
			// The default map has the same topology as the Mesh (so one color per vertex),
			// with all colors set to white.
			if (!mesh->mapSupport(0)) md.AddVertexColors ();
			//if (cache && !cache->mapSupport(0)) mdc.AddVertexColors ();
			
			// We used two routines -- VCreate to add new map vertices, and FRemap to make the
			// existing map faces use the new verts.  frFlags tell FRemap which vertices on a face
			// should be "remapped", and the ww array contains the new locations.			
			VertColor nvc;
			int j;
			for (int v=0; v < d->GetNumColors(); v++) 
			{
				ColorData cd = d->GetColorData(v);
				
				
				if(  cd.color == 0xffffffff )
					continue;

				if(mesh->selLevel == MESH_VERTEX && !mesh->VertSel()[v] )
					continue;
				
				// Blend it together with the VertexColor of the incoming mesh
				nvc = (1.0f-cd.bary)*mesh->vertCol[mesh->vcFace[cd.fi].t[cd.vi]] + cd.bary*Color(cd.color);

				DWORD ww[3], frFlags;
				
				md.map->VCreate (&nvc);
				
				// increase the number of vcol's and set the vcfaces as well	
				for(int i = 0 ; i < d->GetNVert(v).faces.Count() ; i++)
				{		
					j = d->GetNVert(v).whichVertex[i];
					frFlags = (1<<j);
					ww[j] = md.map->outVNum()-1;
					md.map->FRemap(d->GetNVert(v).faces[i], frFlags, ww);
					
				}
			} 

			md.Apply(*mesh);
		}

		else if(mesh->selLevel == MESH_FACE)
		{			
			MeshDelta md(*mesh);
			MeshDelta mdc;

			// If the incoming Mesh had no vertex colors, this will add a default map to start with.
			// The default map has the same topology as the Mesh (so one color per vertex),
			// with all colors set to white.
			if (!mesh->mapSupport(0)) md.AddVertexColors ();
			
			// We used two routines -- VCreate to add new map vertices, and FRemap to make the
			// existing map faces use the new verts.  frFlags tell FRemap which vertices on a face
			// should be "remapped", and the ww array contains the new locations.			
			VertColor nvc;
			int j;	
			for (int v=0; v < d->GetNumColors(); v++) 
			{
				ColorData cd = d->GetColorData(v);
				
				if(  cd.color == 0xffffffff )
					continue;
				
				if(!mesh->FaceSel()[cd.fi] )
					continue;
				
				// Blend it together with the VertexColor of the incoming mesh
				nvc = (1.0f-cd.bary)*mesh->vertCol[mesh->vcFace[cd.fi].t[cd.vi]] + cd.bary*Color(cd.color);

				DWORD ww[3], frFlags;
				DWORD ivc;
				BOOL firstround = TRUE;
				BOOL fsel = FALSE;
				
				Tab<DWORD> selFaceTab;
				Tab<DWORD> unselFaceTab;
				Tab<DWORD> vcSelTab;
				Tab<DWORD> vcSelOnlyTab;
				
				BOOL NoFaceSelected = TRUE;
				
				// Check, if any of the faces is selected, if not continue
				for(int fc = 0; fc < d->GetNVert(v).faces.Count() && NoFaceSelected; fc++)
				{		
						if(mesh->FaceSel()[d->GetNVert(v).faces[fc]])
							NoFaceSelected = FALSE;
				}
				
				if(NoFaceSelected)
					continue;		
				
				
				fsel = TRUE;
				DWORD ivtx;
				BOOL SelFaceColsAllSame = TRUE;

				// For all selected faces, that reference this vertex
				for(fc = 0; fc < d->GetNVert(v).faces.Count() && SelFaceColsAllSame ; fc++)
				{
					if(!mesh->FaceSel()[d->GetNVert(v).faces[fc]])
						continue;
					
					int face = d->GetNVert(v).faces[fc];
					
					// get the vertex color of this face
					ivtx = mesh->vcFace[face].t[d->GetNVert(v).whichVertex[fc]];
					
					if(firstround)
					{
						// Just store the vertex color
						ivc = ivtx;
						firstround = FALSE;
					}
					else
					{
						// Are the vertex colors the same ?
						if(ivc != ivtx)
						{
							// No they are not.
							SelFaceColsAllSame = FALSE;
						}
					}
					vcSelTab.Append(1,&ivtx);
				}// End For all selected faces, that reference this vertex

				if(SelFaceColsAllSame)
				{
					BOOL CreateNewColor = FALSE;
					
					// Check, if the ivc is referenced by any face, that is not selected
					// and shares the vertex, or does not share the vertex at all
					
					for(int vcfc = 0; vcfc < d->GetNVCVert(ivc).faces.Count() && CreateNewColor == FALSE; vcfc++)
					{
						BOOL shared = FALSE;
						
						// Is one of faces that reference the physical vertex equal to the faces, 
						// that reference the vc vertex ?
						for(fc = 0; fc < d->GetNVert(v).faces.Count() && CreateNewColor == FALSE ; fc++)
						{
							if(d->GetNVert(v).faces[fc] == d->GetNVCVert(ivc).faces[vcfc])
							{
								if(!mesh->FaceSel()[d->GetNVCVert(ivc).faces[vcfc]])
									CreateNewColor = TRUE;
							}
							else
								CreateNewColor = TRUE;

						}
					}
						
					if(CreateNewColor)
					{
						// Create a new Color
						md.map->VCreate (&nvc);
										
						// Assign the color of the selected faces to the new color
						for(fc = 0;  fc < d->GetNVert(v).faces.Count() ; fc++)
						{
							if(!mesh->FaceSel()[d->GetNVert(v).faces[fc]])
								continue;

							j = d->GetNVert(v).whichVertex[fc];
							frFlags = (1<<j);
							ww[j] = md.map->outVNum()-1;
							md.map->FRemap(d->GetNVert(v).faces[fc], frFlags, ww);
						}

					}
					else // OneUnselFaceHasSameColor
					{
						// Set the vcolor to the new value
						mesh->vertCol[ivtx] = nvc;
					}
				}
				else // (SelFaceColsAllSame) Not all selected faces have the same color
				{
					// Collect all vcolors, that are only referenced by selected faces
					BOOL VColorIsReferencedByUnselectedFace = FALSE;
					
					// For all VColors, that are on selected faces
					for(int v2 = 0 ; v2 < vcSelTab.Count() ; v2++)
					{
						DWORD ivcv = vcSelTab[v2];
						// Check these vertex colors, if they are on any face, that 
						// is not selected
						for(int vfc = 0 ; vfc < d->GetNVCVert(ivcv).faces.Count() && !VColorIsReferencedByUnselectedFace ; vfc++)
						{							
							if(mesh->FaceSel()[d->GetNVCVert(ivcv).faces[vfc]])
								VColorIsReferencedByUnselectedFace = TRUE;		
								
						}
						if(!VColorIsReferencedByUnselectedFace)
							vcSelOnlyTab.Append(1,&ivcv);
					}

					if(vcSelOnlyTab.Count() > 0)
					{
						// Set the vcolor to the new value
						mesh->vertCol[ivtx] = nvc;
						
						for(fc = 0;  fc < d->GetNVert(v).faces.Count() ; fc++)
						{
							if(!mesh->FaceSel()[d->GetNVert(v).faces[fc]])
							continue;
							
							j = d->GetNVert(v).whichVertex[fc];
							frFlags = (1<<j);

							ww[j] = ivtx;
							md.map->FRemap(d->GetNVert(v).faces[fc], frFlags, ww);
						}
					}
					else
					{
						// Create a new Color
						md.map->VCreate (&nvc);
											
						// Assign the color of the selected faces to the new color
						for(fc = 0;  fc < d->GetNVert(v).faces.Count() ; fc++)
						{
							if(!mesh->FaceSel()[d->GetNVert(v).faces[fc]])
								continue;

							j = d->GetNVert(v).whichVertex[fc];
							frFlags = (1<<j);
							ww[j] = md.map->outVNum()-1;

							md.map->FRemap(d->GetNVert(v).faces[fc], frFlags, ww);
						}
					}
				}
			}	
			md.Apply(*mesh);
		}// end if(mesh->selLevel == MESH_FACE)
	
		NotifyDependents(FOREVER, PART_VERTCOLOR, REFMSG_CHANGE);
		os->obj->UpdateValidity(VERT_COLOR_CHAN_NUM, Interval(t,t));
	}
}

static bool oldShowEnd;

void VertexPaint::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	
	this->ip = ip;
	editMod = this;
	if (!hParams) {
		hParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_PANEL),
				VertexPaintDlgProc, 
				GetString(IDS_PARAMS), 
				(LPARAM)this);

		// Subclass the palette controls
		hPaletteWnd[ 0] = GetDlgItem(hParams, IDC_PALETTE_1);
		hPaletteWnd[ 1] = GetDlgItem(hParams, IDC_PALETTE_2);
		hPaletteWnd[ 2] = GetDlgItem(hParams, IDC_PALETTE_3);
		hPaletteWnd[ 3] = GetDlgItem(hParams, IDC_PALETTE_4);
		hPaletteWnd[ 4] = GetDlgItem(hParams, IDC_PALETTE_5);
		hPaletteWnd[ 5] = GetDlgItem(hParams, IDC_PALETTE_6);
		hPaletteWnd[ 6] = GetDlgItem(hParams, IDC_PALETTE_7);
		hPaletteWnd[ 7] = GetDlgItem(hParams, IDC_PALETTE_8);
		hPaletteWnd[ 8] = GetDlgItem(hParams, IDC_PALETTE_9);
		hPaletteWnd[ 9] = GetDlgItem(hParams, IDC_PALETTE_10);
		hPaletteWnd[10] = GetDlgItem(hParams, IDC_PALETTE_11);
		hPaletteWnd[11] = GetDlgItem(hParams, IDC_PALETTE_12);
		hPaletteWnd[12] = GetDlgItem(hParams, IDC_PALETTE_13);
		hPaletteWnd[13] = GetDlgItem(hParams, IDC_PALETTE_14);
		hPaletteWnd[14] = GetDlgItem(hParams, IDC_PALETTE_15);
		hPaletteWnd[15] = GetDlgItem(hParams, IDC_PALETTE_16);

		for (int i=0; i<NUMPALETTES; i++) {
			colorSwatchOriginalWndProc = (WNDPROC) SetWindowLong(hPaletteWnd[i], GWL_WNDPROC, (LONG) colorSwatchSubclassWndProc); 
			}

		SendMessage(hParams, WM_POSTINIT, 0, 0);
		}
	else {
		SetWindowLong(hParams,GWL_USERDATA,(LONG)this);
		}
	iTint = SetupIntSpinner (hParams, IDC_TINT_SPIN, IDC_TINT, 0, 100, (int) (fTint*100.0f));

	// Set show end result.
	oldShowEnd = ip->GetShowEndResult() ? TRUE : FALSE;
	ip->SetShowEndResult (GetFlag (VP_DISP_END_RESULT));

	// Force an eval to update caches.
	NotifyDependents(FOREVER, PART_VERTCOLOR, REFMSG_CHANGE);
	}

void VertexPaint::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next)
	{
	ActivatePaint(FALSE);
	
	ReleaseISpinner (iTint);
	
	ModContextList list;
	INodeTab nodes;
	ip->GetModContexts(list,nodes);
	for (int i=0; i<list.Count(); i++) {
		VertexPaintData *vd = (VertexPaintData*)list[i]->localData;
		if (vd) vd->FreeCache();
	}
	nodes.DisposeTemporary();

	// Reset show end result
	SetFlag (VP_DISP_END_RESULT, ip->GetShowEndResult() ? TRUE : FALSE);
	ip->SetShowEndResult(oldShowEnd);


	ip->DeleteRollupPage(hParams);
	hParams = NULL;
	editMod = NULL;
	iTint = NULL;
	this->ip = NULL;
	}


//From ReferenceMaker 
RefResult VertexPaint::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
	{
	return REF_SUCCEED;
	}

int VertexPaint::NumRefs() 
	{
	return 0;
	}

RefTargetHandle VertexPaint::GetReference(int i) 
	{
	return NULL;
	}

void VertexPaint::SetReference(int i, RefTargetHandle rtarg)
	{
	}

int VertexPaint::NumSubs() 
	{ 
	return 0;
	}  

Animatable* VertexPaint::SubAnim(int i) 
	{ 
	return NULL; 
	}

TSTR VertexPaint::SubAnimName(int i) 
	{ 
	return _T("");
	}


#define VERSION_CHUNKID			0x100
#define COLORLIST_CHUNKID		0x120

static int currentVersion = 1;

IOResult VertexPaint::Load(ILoad *iload)
	{
	IOResult res;
	ULONG nb;
	int version = 1;
	Modifier::Load(iload);

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VERSION_CHUNKID:
				iload->Read (&version, sizeof(version), &nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) return res;
		}

	return IO_OK;
	}

IOResult VertexPaint::Save(ISave *isave)
	{
	IOResult res;
	ULONG nb;

	Modifier::Save(isave);

	isave->BeginChunk(VERSION_CHUNKID);
	res = isave->Write (&currentVersion, sizeof(int), &nb);
	isave->EndChunk();

	return IO_OK;
	}

IOResult VertexPaint::SaveLocalData(ISave *isave, LocalModData *ld)
	{
	VertexPaintData*	d = (VertexPaintData*)ld;
	IOResult	res;
	ULONG		nb;
	int			numColors;
	int			maxNumColors;
	ColorData	col;
	
	isave->BeginChunk(VERSION_CHUNKID);
	res = isave->Write (&currentVersion, sizeof(int), &nb);
	isave->EndChunk();
	
	isave->BeginChunk(COLORLIST_CHUNKID);
	numColors = d->GetNumColors();
	res = isave->Write(&numColors, sizeof(int), &nb);
	maxNumColors = d->GetMaxNumColors();
	res = isave->Write(&maxNumColors, sizeof(int), &nb);
	for (int i=0; i<maxNumColors; i++) {
		col = d->GetColorData(i);
		isave->Write(&col.color,sizeof(col.color),&nb);
		isave->Write(&col.bary,sizeof(col.bary),&nb);
		isave->Write(&col.fi,sizeof(col.fi),&nb);
		isave->Write(&col.vi,sizeof(col.vi),&nb);
		}

	isave->EndChunk();
	return IO_OK;
	}

IOResult VertexPaint::LoadLocalData(ILoad *iload, LocalModData **pld) {
	VertexPaintData *d = new VertexPaintData;
	IOResult	res;	
	ULONG		nb;
	int			version = 1;
	int			numColors;
	int			maxNumColors;
	ColorData	col;

	*pld = d;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
		case VERSION_CHUNKID:
				iload->Read (&version, sizeof(version), &nb);
				break;
		case COLORLIST_CHUNKID:
				{
					iload->Read(&numColors,sizeof(int), &nb);
					iload->Read(&maxNumColors,sizeof(int), &nb);
					d->AllocColorData(maxNumColors);
					for (int i=0; i<maxNumColors; i++) {
						iload->Read(&col.color,sizeof(col.color), &nb);
						iload->Read(&col.bary,sizeof(col.bary), &nb);
						iload->Read(&col.fi,sizeof(col.fi), &nb);
						iload->Read(&col.vi,sizeof(col.vi), &nb);
						d->SetColor(i, col.bary, col.fi,col.vi,col.color);
					}
					d->AllocColorData(numColors);
				}
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) return res;
		}
	return IO_OK;
	}

void VertexPaint::PaletteButton(HWND hWnd)
	{
	IColorSwatch* iPal = GetIColorSwatch(hWnd);
	if (iPal && iColor) {
		iColor->SetColor(iPal->GetColor(), TRUE);
		}
	}

void VertexPaint::InitPalettes()
	{
	IColorSwatch* c;
	for (int i=0; i<NUMPALETTES; i++) {
		c = GetIColorSwatch(hPaletteWnd[i]);
		c->SetColor(palColors[i]);
		ReleaseIColorSwatch(c);
		}
	}

void VertexPaint::SavePalettes()
	{
	IColorSwatch* c;
	for (int i=0; i<NUMPALETTES; i++) {
		c = GetIColorSwatch(hPaletteWnd[i]);
		palColors[i] = c->GetColor();
		ReleaseIColorSwatch(c);
		}
	}

void VertexPaint::TurnVCOn(BOOL shaded)
{
	ModContextList list;
	INodeTab NodeTab;
	
	// Only the selected nodes will be affected
	ip->GetModContexts(list,NodeTab);

	for( int i = 0 ; i < NodeTab.Count() ; i++)
	{
		if(shaded)
			NodeTab[i]->SetShadeCVerts(!NodeTab[i]->GetShadeCVerts());
		else
			NodeTab[i]->SetCVertMode(!NodeTab[i]->GetCVertMode());	
		
	}
	NotifyDependents(FOREVER, PART_VERTCOLOR, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
}

VertexPaintData::VertexPaintData(Mesh& m) : mesh(NULL), colordata(NULL), nverts(NULL), 
nvcverts(NULL), numColors(0), numnverts(0), numnvcverts(0), maxNumColors(0)
{
	SetCache(m);
}

VertexPaintData::VertexPaintData() : mesh(NULL), colordata(NULL), nverts(NULL), 
nvcverts(NULL), numColors(0), numnverts(0), numnvcverts(0), maxNumColors(0)
{

}

VertexPaintData::~VertexPaintData()
	{
	FreeCache();

	if (colordata) delete [] colordata;
	if(nverts) delete [] nverts;
	if(nvcverts) delete [] nvcverts;

	nverts = NULL;
	nvcverts = NULL;
	colordata = NULL;
	
	maxNumColors = 0;
	numColors = 0;
	numnverts = 0;
	numnvcverts = 0;
	}

void VertexPaintData::SetCache(Mesh& m)
{
	FreeCache();
	mesh = new Mesh(m);
	SynchVerts(m);
	AllocColorData(mesh->getNumVerts());
				
}

void VertexPaintData::FreeCache()
	{
	if (mesh) delete mesh;
	if(nverts) delete [] nverts;			 
	if(nvcverts) delete [] nvcverts;

	mesh = NULL;
	nverts = NULL;
	nvcverts = NULL;
	numnverts = 0;
	numnvcverts = 0;
	}

Mesh* VertexPaintData::GetMesh()
	{
	return mesh;
	}

NVert&  VertexPaintData::GetNVert(int i)
{
	static NVert nv;
	
	if (numnverts > i)
		return nverts[i];
	else
		return nv;
}

NVert& VertexPaintData::GetNVCVert(int i)
{
	static NVert nv;
	
	if (numnvcverts > i)
		return nvcverts[i];
	else
		return nv;
}

COLORREF& VertexPaintData::GetColor(int i)
	{
	static COLORREF c = RGB(1,1,1);
	if (maxNumColors > i)
		return colordata[i].color;
	else
		return c;
	}

ColorData& VertexPaintData::GetColorData(int i)
	{
	static ColorData c;

	if (maxNumColors > i)
		return colordata[i];
	else
		return c;
	}

void VertexPaintData::SetColor(int i, float bary, DWORD fi, int vi, COLORREF c)
{
	
	if (colordata && maxNumColors > i) 
	{
		
		if(colordata[i].color != 0xffffffff)
		{
			// This color was set before !
			
			float oldbary = colordata[i].bary;
			float alpha = (1.0f-bary);
			
			float weight;
			
			if(bary+(alpha*oldbary) > 0)
				weight = 1/(bary+(alpha*oldbary));
			else
				weight = 0;

			colordata[i].color = (DWORD) (weight*alpha*oldbary*Color(colordata[i].color) + weight*bary*Color(c));
			colordata[i].bary = alpha*oldbary+bary;

			colordata[i].fi = fi;
			colordata[i].vi = vi;
		}
		else
		{
			colordata[i].color = c;
			colordata[i].bary = bary;
			colordata[i].fi = fi;
			colordata[i].vi = vi;
		}
	}
}

int VertexPaintData::GetNumColors()
	{
	return numColors;
	}

int VertexPaintData::GetMaxNumColors()
	{
	return maxNumColors;
	}

void VertexPaintData::AllocColorData(int numcols)
	{
	ColorData* newColorData;

	// Colors already exist.
	if (numColors == numcols)
		return;
	
	if (numColors > 0 ) 
	{
		// If the new number of colors is bigger than what we have in the colordata array
		if(numcols > maxNumColors)
		{
			// Allocate a new color list and fill in as many as
			// we have from the previous set
			newColorData = new ColorData[numcols];
			
			for (int i=0; i<numcols; i++) 
			{
				if (i < maxNumColors) 
				{
					newColorData[i] = colordata[i];
					
					if(mesh && newColorData[i].fi >= (DWORD) mesh->getNumFaces())
					{
						BOOL found = FALSE;
						for(int j = 0 ; j < nverts[i].faces.Count() && !found; j++)
						{
							if(nverts[i].faces[j] < mesh->getNumFaces())
							{
								newColorData[i].fi = nverts[i].faces[j];
								newColorData[i].vi = nverts[i].whichVertex[j];
							}
							
						}
						if(!found)
							newColorData[i].vi = 0;
					}
				}
			}
			delete [] colordata;
			
			colordata = newColorData;
			
			maxNumColors = numColors = numcols;
			
		}
		else
		{
			// If the new number of colors is smaller than what we have in the colordata array
			for (int i=0; i<numcols; i++) 
			{
				if(mesh && colordata[i].fi >= (DWORD) mesh->getNumFaces())
				{
					BOOL found = FALSE;
					for(int j = 0 ; j < nverts[i].faces.Count() && !found; j++)
					{
						if(nverts[i].faces[j] < mesh->getNumFaces())
						{
							colordata[i].fi = nverts[i].faces[j];
							colordata[i].vi = nverts[i].whichVertex[j];
						}
						
					}
					if(!found)
						colordata[i].vi = 0;
				}
			}
			numColors = numcols;
		}
	}
	else
	{
		// Allocate a complete new set of colors
		numColors = numcols;
		maxNumColors = numColors;
		colordata = new ColorData[numColors];
		

	}
}

LocalModData* VertexPaintData::Clone()
	{
	VertexPaintData* d = new VertexPaintData();

	if (colordata) {
		d->colordata = new ColorData[maxNumColors];
		d->numColors = numColors;
		d->maxNumColors = maxNumColors;
		for (int i=0; i<maxNumColors; i++) {
			d->colordata[i] = colordata[i];
			}
		}
	if(nverts)
	{
		d->nverts = new NVert[numnverts];
		for(int i = 0 ; i < numnverts ; i++ ) {
			d->nverts[i] = nverts[i];
		}

	}
	if(nvcverts)
	{
		d->nvcverts = new NVert[numnvcverts];
		for(int i = 0 ; i < numnvcverts ; i++ ) {
			d->nvcverts[i] = nvcverts[i];
		}

	}

	return d;
	}


void VertexPaintData::SynchVerts(Mesh &m)
{

	if(nverts)
		delete [] nverts;
	
	numnverts = m.getNumVerts();
	
	nverts = new NVert[numnverts];

	if(nvcverts)
		delete [] nvcverts;
	
	numnvcverts = m.getNumVertCol();

	nvcverts = new NVert[numnvcverts];
	
	for(int i = 0 ; i < mesh->getNumFaces() ; i++)
	{	
		// for each vertex of each face
		for(int j = 0 ; j < 3 ; j++)
		{		
			int iCur = nverts[mesh->faces[i].v[j]].faces.Count();
			
			// Tell the vertex, which to which face it belongs and which 
			// of the three face v-indices corresponds to the vertex
			
			nverts[mesh->faces[i].v[j]].faces.SetCount(iCur+1);
			nverts[mesh->faces[i].v[j]].whichVertex.SetCount(iCur+1);

			nverts[mesh->faces[i].v[j]].faces[iCur] = i;
			nverts[mesh->faces[i].v[j]].whichVertex[iCur] = j;
			
			
			if(mesh->vcFace)
			{
				// Do the same for texture vertices
			iCur = nvcverts[mesh->vcFace[i].t[j]].faces.Count();
			
			nvcverts[mesh->vcFace[i].t[j]].faces.SetCount(iCur+1);
			nvcverts[mesh->vcFace[i].t[j]].whichVertex.SetCount(iCur+1);
			
			nvcverts[mesh->vcFace[i].t[j]].faces[iCur] = i;
			nvcverts[mesh->vcFace[i].t[j]].whichVertex[iCur] = j;

			}
			else
				assert(0);
		}
	}
}


//***************************************************************************
//**
//** NVert
//**
//***************************************************************************



NVert::NVert()
{
	faces.SetCount(0);
	whichVertex.SetCount(0);
}

NVert& NVert::operator= (NVert &nvert)
{
	faces = nvert.faces;
	whichVertex = nvert.whichVertex;
	return *this;
}

//***************************************************************************
//**
//** ColorData 
//**
//***************************************************************************


ColorData::ColorData(DWORD col) : color(col), bary(0.0f), fi(0), vi(0)
{
}

ColorData::ColorData() : color(0xffffffff), bary(0.0f), fi(0), vi(0)
{
}

//***************************************************************************
//**
//** VertexPaintRestore : public RestoreObj
//**
//***************************************************************************

VertexPaintRestore::VertexPaintRestore(VertexPaintData *pLocalData, VertexPaint *pVPaint) 
: pMod(pVPaint), pPaintData(pLocalData), redoColordata(NULL)
{
	colordata = new ColorData[pPaintData->maxNumColors];
	for(int i = 0; i < pPaintData->maxNumColors ; i++)
	{
		colordata[i] = pPaintData->colordata[i];
	}
	numcolors = pPaintData->numColors;
	maxnumcolors = pPaintData->maxNumColors;

}

VertexPaintRestore::~VertexPaintRestore()
{
	if(colordata)
		delete [] colordata;
	
	if(redoColordata)
		delete [] redoColordata;
}

void VertexPaintRestore::Restore(int isUndo)
{
	if(isUndo)
	{
		assert(pPaintData->colordata);

		redoColordata = pPaintData->colordata;
		redonumcolors = pPaintData->numColors;
		redomaxnumcolors = pPaintData->maxNumColors;

		pPaintData->colordata = colordata;
		pPaintData->numColors = numcolors;
		pPaintData->maxNumColors = maxnumcolors;

		colordata = NULL;
		
		pMod->NotifyDependents(FOREVER, PART_VERTCOLOR, REFMSG_CHANGE);
		GetCOREInterface()->RedrawViews(GetCOREInterface()->GetTime());
	}
}

void VertexPaintRestore::Redo()
{
	assert(pPaintData->colordata);
	
	colordata = pPaintData->colordata;
	numcolors = pPaintData->numColors;
	maxnumcolors = pPaintData->maxNumColors;
	
	pPaintData->colordata = redoColordata;
	pPaintData->numColors = redonumcolors;
	pPaintData->maxNumColors = redomaxnumcolors;
	
	redoColordata = NULL;

	pMod->NotifyDependents(FOREVER, PART_VERTCOLOR, REFMSG_CHANGE);
	GetCOREInterface()->RedrawViews(GetCOREInterface()->GetTime());
	
}

int  VertexPaintRestore::Size()
{
	int iSize = 0;
	
	if(colordata)
		iSize += sizeof(ColorData) * maxnumcolors;
	
	if(redoColordata)
		iSize += sizeof(ColorData) * redonumcolors;

	return iSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\VertexPaint\Paint.cpp ===
#include "VertexPaint.h"

static	PaintCommandMode thePaintCommandMode;
static	HCURSOR hPaintCursor = NULL;	// Paint cursor
static	HCURSOR hDropperCursor = NULL;	// Paint cursor
static	HCURSOR hNoPaintCursor = NULL;	// NoPaint cursor

TriObject *GetTriObjectFromNode(INode *node, TimeValue t, int &deleteIt);

void NukePaintCommandMode()
{
	CommandMode* cmdMode = GetCOREInterface()->GetCommandMode();
	if (!cmdMode || cmdMode->ID() == thePaintCommandMode.ID()) {
		// Our command mode is at the top of the stack.
		// Set selection mode and remove our mode
		// We need to make sure some kind of command mode is set, so
		// we set selection mode to be the default.
		GetCOREInterface()->SetStdCommandMode(CID_OBJSELECT);
		GetCOREInterface()->DeleteMode(&thePaintCommandMode);
	}
	else {
		// Our command mode is not at the top of the stack,
		// so we can safely remove our mode.
		GetCOREInterface()->DeleteMode(&thePaintCommandMode);
	}
}

BOOL VertexPaint::ActivatePaint(BOOL bOnOff, BOOL bPick)
	{
	
	if (bOnOff) {
		
		thePaintCommandMode.mouseProc.SetPickMode(bPick);
		
		if (!hPaintCursor) {
			hPaintCursor = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_PAINTCURSOR));
		}
		if (!hNoPaintCursor) {
			hNoPaintCursor = LoadCursor(NULL,IDC_CROSS);
		}
		if (!hDropperCursor) {
			hDropperCursor = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_DROPPER_CURSOR));
		}

		thePaintCommandMode.SetInterface(GetCOREInterface());
		thePaintCommandMode.SetModifier(this);
		ip->SetCommandMode(&thePaintCommandMode);
		}
	else {
		NukePaintCommandMode();
		}

	return TRUE;
	}

ModContext* VertexPaint::ModContextFromNode(INode* node)
	{
	Object* obj = node->GetObjectRef();

	if (!obj)	return FALSE;

    while (obj && (obj->SuperClassID() == GEN_DERIVOB_CLASS_ID)) {
		IDerivedObject* dobj = (IDerivedObject*)obj;
		int m;
		int numMods = dobj->NumModifiers();

		for (m=0; m<numMods; m++) {
			ModContext* mc = dobj->GetModContext(m);
			for (int i=0; i<modContexts.Count(); i++) {
				if (mc == modContexts[i]) {
					return mc;
					}
				}
			}

		obj = dobj->GetObjRef();
		}

	return NULL;
	}

void PaintMouseProc::DoPainting(HWND hWnd, IPoint2 m)
	{
	INode*		node = GetCOREInterface()->PickNode(hWnd,m,NULL);
	TimeValue	t = GetCOREInterface()->GetTime();
	Ray			ray;

	if (pModifier->IsValidNode(node)) {
		SetCursor(hPaintCursor);
		ModContext* mc = pModifier->ModContextFromNode(node);
		
		// If we got an instanced modifier but the second node is not selected
		// it mght be valid, but it will return NULL for the ModContext
		if(!mc || !mc->localData)
		{
			return;
		}

		VertexPaintData* d = (VertexPaintData*)mc->localData;
		ViewExp*	pView = GetCOREInterface()->GetViewport(hWnd);
		Mesh*		mesh = 	d->GetMesh();

		if (mesh) {
			pView->MapScreenToWorldRay((float)m.x, (float)m.y, ray);
			Matrix3 obtm  = node->GetObjTMAfterWSM(t);
			Matrix3 iobtm = Inverse(obtm);
			ray.p   = iobtm * ray.p;
			ray.dir = VectorTransform(iobtm, ray.dir);	

			float at;
			Point3 norm;
			DWORD fi;
			Point3 bary;
			float opacity;

			if (mesh->IntersectRay(ray, at, norm, fi, bary)) 
			{
				if (mesh->vertCol) 
				{
					TVFace* tvf = &mesh->vcFace[fi];
					Face* f = &mesh->faces[fi];
					for (int i=0; i<3; i++) 
					{
						opacity = bary[i]*pModifier->fTint;
						
						if(opacity > 1)
							opacity = 1;
						if(opacity < 0)
							opacity = 0;
						//d->SetColor(f->v[i], (1.0f-bary[i])*mesh->vertCol[tvf->t[i]] + bary[i]*pModifier->GetActiveColor());
						if(mesh->selLevel != MESH_FACE || mesh->FaceSel()[fi])
							d->SetColor(f->v[i],  opacity ,fi,i, pModifier->GetActiveColor());
					}
					pModifier->NotifyDependents(FOREVER, PART_VERTCOLOR, REFMSG_CHANGE);
					//pModifier->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
					GetCOREInterface()->RedrawViews(t);
				}
			}

			GetCOREInterface()->ReleaseViewport(pView);
			}
		else {
			SetCursor(hNoPaintCursor);
			}
		}
	return;
	}

void PaintMouseProc::DoPickColor(HWND hWnd, IPoint2 m)
	{
	INode*		node = GetCOREInterface()->PickNode(hWnd,m,NULL);
	TimeValue	t = GetCOREInterface()->GetTime();
	Ray			ray;

	if(!node) 
	{
		SetCursor(hNoPaintCursor);
		return;
	}

	ObjectState os = node->EvalWorldState(t);
	
	if(os.obj->ClassID() == Class_ID(EDITTRIOBJ_CLASS_ID,0))
	{
		SetCursor(hDropperCursor);
		TriObject *pTri = (TriObject *) os.obj;

		ViewExp*	pView = GetCOREInterface()->GetViewport(hWnd);
		Mesh*		mesh = &pTri->mesh;

		if (mesh) {
			pView->MapScreenToWorldRay((float)m.x, (float)m.y, ray);
			Matrix3 obtm  = node->GetObjTMAfterWSM(t);
			Matrix3 iobtm = Inverse(obtm);
			ray.p   = iobtm * ray.p;
			ray.dir = VectorTransform(iobtm, ray.dir);	

			float at;
			Point3 norm;
			DWORD fi;
			Point3 bary;
			float opacity = 0;

			if (mesh->IntersectRay(ray, at, norm, fi, bary)) 
			{
				if (mesh->vertCol) 
				{
					TVFace* tvf = &mesh->vcFace[fi];
					Face* f = &mesh->faces[fi];
					Color PickCol(0,0,0);

					for (int i=0; i<3; i++) 
					{
						PickCol += (bary[i])*mesh->vertCol[tvf->t[i]];
					}
					
					pModifier->iColor->SetColor((DWORD)PickCol);
				}
			}

			GetCOREInterface()->ReleaseViewport(pView);
			}
		}
	else {
			pModifier->iColor->SetColor(node->GetWireColor());
			}
		
	return;
	}

int PaintMouseProc::proc(HWND hWnd, int msg, int point, int flags, IPoint2 m)
{
	int			nRetval = FALSE;

	BOOL		bButtonDown = flags & MOUSE_LBUTTON;

	switch (msg) {
		case MOUSE_POINT:
			
			if( flags & MOUSE_CTRL || bPickMode )
				DoPickColor(hWnd, m);
			else
			{
				if(bButtonDown)
					MaybeStartHold();
				
				DoPainting(hWnd, m);
				
				if(!bButtonDown)
					MaybeEndHold();
			}

			break;
		case MOUSE_MOVE:
			if(flags & MOUSE_CTRL || bPickMode)
				DoPickColor(hWnd, m);
			else
				DoPainting(hWnd, m);
			break;
		case MOUSE_ABORT:
			if(wasHolding)
				theHold.Cancel();
			
			GetCOREInterface()->SetStdCommandMode(CID_OBJSELECT);
			break;
		case MOUSE_PROPCLICK:
			GetCOREInterface()->SetStdCommandMode(CID_OBJSELECT);
			break;
		case MOUSE_FREEMOVE:
			{				
				INode* node = GetCOREInterface()->PickNode(hWnd,m,NULL);

				if(flags & MOUSE_CTRL || bPickMode)
				{
					if(node)
						SetCursor(hDropperCursor);
					else
						SetCursor(hNoPaintCursor);
				}
				else
				{
					if (pModifier->IsValidNode(node)) {
						SetCursor(hPaintCursor);
					}
					else {
						SetCursor(hNoPaintCursor);
					}
				}
			}
			break;
	}
		
	return TRUE;
}

void PaintMouseProc::MaybeStartHold()
{
	if(!theHold.Holding())
	{
		theHold.Begin();
		wasHolding = TRUE;
	}
	else
		wasHolding = FALSE;
	
	ModContextList	modContexts;
	INodeTab		nodeTab;
	
	GetCOREInterface()->GetModContexts(modContexts, nodeTab);
	
	for (int i=0; i<modContexts.Count(); i++) 
	{
		ModContext *mc = modContexts[i];
		if(mc && mc->localData)
			theHold.Put(new VertexPaintRestore((VertexPaintData*)mc->localData,pModifier));
	}
}

void PaintMouseProc::MaybeEndHold()
{
	if(wasHolding)
		theHold.Accept(GetString(IDS_RESTORE));

}

//=====================================

PaintCommandMode::PaintCommandMode()
{
	iInterface	= NULL;
}

int PaintCommandMode::Class()
{
	return PICK_COMMAND;
}

int PaintCommandMode::ID()
{
	return CID_PAINT;
}

MouseCallBack* PaintCommandMode::MouseProc(int *numPoints)
{
	*numPoints = 2; return &mouseProc;
}

ChangeForegroundCallback* PaintCommandMode::ChangeFGProc()
{
	return CHANGE_FG_SELECTED;
}

BOOL PaintCommandMode::ChangeFG( CommandMode *oldMode )
{
	return FALSE;
}

void PaintCommandMode::EnterMode() 
{
	iInterface->PushPrompt(GetString(IDS_PAINTPROMPT));
	pModifier->EnterMode();

}

void PaintCommandMode::ExitMode() 
{
	iInterface->PopPrompt();
	pModifier->ExitMode();

}

void VertexPaint::EnterMode()
	{
		int numPoints;
		iPaintButton->SetCheck(ip->GetCommandMode()->ID() == CID_PAINT && 
				!((PaintMouseProc *)ip->GetCommandMode()->MouseProc(&numPoints))->GetPickMode());
		iPickButton->SetCheck(ip->GetCommandMode()->ID() == CID_PAINT && 
				((PaintMouseProc *)ip->GetCommandMode()->MouseProc(&numPoints))->GetPickMode());
		ip->GetModContexts(modContexts, nodeTab);
	}

void VertexPaint::ExitMode()
	{
		iPaintButton->SetCheck(FALSE);
		iPickButton->SetCheck(FALSE);

		nodeTab.DisposeTemporary();
		modContexts.ZeroCount();
		modContexts.Shrink();
	}

BOOL VertexPaint::IsValidNode(INode* node)
	{
	if (!node) return FALSE;

	for (int i=0; i<nodeTab.Count(); i++) {
		if (nodeTab[i] == node) {
			return TRUE;
			}
		}
	return FALSE;
	}

COLORREF VertexPaint::GetActiveColor()
	{
	return iColor->GetColor();
	}

// ------------- Convert object to TriObject -----------------------

// Return a pointer to a TriObject given an INode or return NULL
// if the node cannot be converted to a TriObject
TriObject *GetTriObjectFromNode(INode *node, TimeValue t, int &deleteIt)
{
	deleteIt = FALSE;
	Object *obj = node->EvalWorldState(t).obj;
	if (obj->CanConvertToType(Class_ID(TRIOBJ_CLASS_ID, 0))) { 
		TriObject *tri = (TriObject *) obj->ConvertToType(0, 
			Class_ID(TRIOBJ_CLASS_ID, 0));
		// Note that the TriObject should only be deleted
		// if the pointer to it is not equal to the object

		// pointer that called ConvertToType()
		if (obj != tri) deleteIt = TRUE;
		return tri;
		}
	else {
		return NULL;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\VertexPaint\VertexPaint.h ===
/**********************************************************************
 *<
	FILE: VertexPaint.h

	DESCRIPTION: Modifier definition

	CREATED BY:  Christer Janson, Nikolai Sander

	HISTORY:

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#ifndef __VERTEXPAINT__H
#define __VERTEXPAINT__H

#include "Max.h"
#include "resource.h"
#include "istdplug.h"
#include "modstack.h"


#define VERTEXPAINT_CLASS_ID	Class_ID(0x663b6fab, 0x73f47385)
#define CID_PAINT				(CID_USER+0x439c)
#define NUMPALETTES				16
#define WM_POSTINIT				(WM_USER+0x1177)

extern TCHAR *GetString(int id);
extern ClassDesc* GetVertexPaintDesc();
extern HINSTANCE hInstance;

class NVert
{
public:
	NVert();
	NVert& operator= (NVert &nvert);
	Tab<int> faces;
	Tab<int> whichVertex;
};

class ColorData
{
public:
	ColorData(DWORD col);
	ColorData();

	COLORREF color;
	float	 bary;
	DWORD    fi;
	int		 vi;
};


class VertexPaintData : public LocalModData {
	
	friend class VertexPaintRestore;

public:

		VertexPaintData(Mesh& m);
		VertexPaintData();
		~VertexPaintData();
		LocalModData*	Clone();

		Mesh*	GetMesh();
		NVert&  GetNVert(int i);
		NVert&  GetNVCVert(int i)  ;
		void	SetCache(Mesh& m);
		void	FreeCache();

		COLORREF&	GetColor(int i);
		ColorData&  GetColorData(int i);
		void		SetColor(int i,float bary,DWORD fi, int vi, COLORREF c);
		int			GetNumColors();
		int			GetMaxNumColors();
		void		AllocColorData(int numcols);
		void		SynchVerts(Mesh &m);

	private:
		Mesh*	mesh;
		ColorData* colordata;
		int		maxNumColors;
		int		numColors;
		NVert    *nverts;
		int      numnverts;
		NVert    *nvcverts;
		int      numnvcverts;

	};

class VertexPaint : public Modifier {
	
	friend class PaintMouseProc;
	friend BOOL CALLBACK VertexPaintDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
public:

		static IObjParam*		ip;
		static VertexPaint*		editMod;
		static HWND				hParams;
		static ICustButton*		iPaintButton;
		static ICustButton*		iPickButton;
		static IColorSwatch*	iColor;
		static COLORREF			lastColor;
		static COLORREF			palColors[NUMPALETTES];

		//Constructor/Destructor
		VertexPaint();
		~VertexPaint();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= TSTR(GetString(IDS_CLASS_NAME)); }  
		virtual Class_ID ClassID() { return VERTEXPAINT_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_CLASS_NAME); }
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		IOResult LoadLocalData(ILoad *iload, LocalModData **pld);
		IOResult SaveLocalData(ISave *isave, LocalModData *ld);

		//From Modifier
		ChannelMask ChannelsUsed()  { return GEOM_CHANNEL|TOPO_CHANNEL|VERTCOLOR_CHANNEL|PART_SUBSEL_TYPE|SELECT_CHANNEL|PART_DISPLAY|TEXMAP_CHANNEL; }
		ChannelMask ChannelsChanged() { return VERTCOLOR_CHANNEL|TOPO_CHANNEL|GEOM_CHANNEL; }
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Class_ID InputType() {return triObjectClassID;}
		Interval LocalValidity(TimeValue t);
		void NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc);


		// From BaseObject
		BOOL ChangeTopology() {return FALSE;}
		BOOL DependOnTopology(ModContext &mc);

		int GetParamBlockIndex(int id) {return id;}

		//From ReferenceMaker
		int NumRefs();
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		
		int NumSubs();
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);

		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		BOOL	ActivatePaint(BOOL bOnOff, BOOL bPick = FALSE);
		void	EnterMode();
		void	ExitMode();
		BOOL	IsValidNode(INode* node);
		ModContext* ModContextFromNode(INode* node);
		COLORREF GetActiveColor();
		void	TurnVCOn(BOOL shaded);



		void	PaletteButton(HWND hWnd);
		void	InitPalettes();
		void	SavePalettes();
	
	private :

		void SetFlag (DWORD fl) { flags |= fl; }
		void ClearFlag (DWORD fl) { flags &= ~fl; }
		void SetFlag (DWORD fl, bool set) { if (set) SetFlag (fl); else ClearFlag (fl); }
		bool GetFlag (DWORD fl) { return (fl&flags) ? TRUE : FALSE; }

	private:
		ModContextList	modContexts;
		INodeTab		nodeTab;
		HWND			hPaletteWnd[NUMPALETTES];
		float			fTint;
		ISpinnerControl *iTint;
		DWORD flags;

	};

/****************************************************************************
 *
 * 3D Paint Implementation
 *
 ***************************************************************************/

// Mouse proc
class PaintMouseProc : public MouseCallBack {
public:
	int		proc(HWND hWnd, int msg, int point, int flags, IPoint2 m); // Mouse callback
	void	SetModifier(VertexPaint* pMod) { pModifier = pMod; }
	void	SetPickMode(BOOL bPick){bPickMode = bPick;}
	BOOL	GetPickMode(){return bPickMode;}
	void	DoPainting(HWND hWnd, IPoint2 m);
	void	DoPickColor(HWND hWnd, IPoint2 m);
	void	MaybeStartHold();
	void	MaybeEndHold();
	BOOL	IsValidPickNode(INode *node);


private:
	VertexPaint*	pModifier;
	BOOL			wasHolding;
	BOOL			bPickMode;
};


class PaintCommandMode : public CommandMode {
	public:
		PaintCommandMode();

		PaintMouseProc mouseProc;

		int							Class();
		virtual int					ID();
		MouseCallBack*				MouseProc(int *numPoints);
		BOOL						ChangeFG(CommandMode *oldMode);
		ChangeForegroundCallback*	ChangeFGProc();
		void						EnterMode();
		void						ExitMode();

		void						SetInterface(Interface* ip) { iInterface = ip; }
		void						SetModifier(VertexPaint* pMod)		{ pModifier = pMod; mouseProc.SetModifier(pMod); }

private:
		Interface*					iInterface;
		VertexPaint*				pModifier;
};

class VertexPaintRestore : public RestoreObj
{
private:
	VertexPaintData *pPaintData;
	VertexPaint *pMod;

	ColorData *colordata;
	ColorData *redoColordata;
	int numcolors;
	int maxnumcolors;
	int redonumcolors;
	int redomaxnumcolors;

public:	

	VertexPaintRestore(VertexPaintData *pLocalData, VertexPaint *pVPaint);
	~VertexPaintRestore();
	void Restore(int isUndo);
	void Redo();
	int  Size();
};


#endif // __VERTEXPAINT__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\mcdevice.cpp ===
/**********************************************************************
 *<
	FILE: mcdevice.cpp

	DESCRIPTION: Devices for the motion manager

	CREATED BY: Rolf Berteig

	HISTORY: October 30, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "motion.h"
#include "mcapdev.h"
//#include "mmanager.h"

#define MC_MOUSE_X	0
#define MC_MOUSE_Y	1

#define MOUSE_DEVICE_CLASS_ID	0xbb387ff1

static MCInputDevice *GetMouseDevice();

class MouseDeviceBinding : public MCDeviceBinding {
	public:
		int which, invert;
		float scale;
		MouseDeviceBinding() {which=MC_MOUSE_X; scale=1.0f; invert=FALSE;}
		MCInputDevice *GetDevice() {return GetMouseDevice();}
		TSTR BindingName() {return GetString(which==MC_MOUSE_X?IDS_RB_MOUSEX:IDS_RB_MOUSEY);}
		float Eval(TimeValue t);
		void DeleteThis() {delete this;}
		Class_ID ClassID() {return Class_ID(MOUSE_DEVICE_CLASS_ID,0);}
		RefTargetHandle Clone(RemapDir& remap);

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		void AddRollup(IMCParamDlg *dlg);
		void UpdateRollup(IRollupWindow *iRoll);
		void BeginActivate(BOOL reset);
	};

class MouseDevice : public MCInputDevice {
	public:
		int xbase, ybase;

		TSTR DeviceName() {return GetString(IDS_RB_MOUSEDEVICE);}
		MCDeviceBinding *CreateBinding() {return new MouseDeviceBinding;}

		void ZeroMouse();
		float DX();
		float DY();
		void CheckForWrap();
	};

//--- Class Descriptor -----------------------------------------------

// This is only here to support old files. Before the motion capture
// device interface was made plug-able the general REF_TARGET_CLASS_ID was used.
class MouseDeviceClassDescOld:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading) {return new MouseDeviceBinding;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_MOUSEDEVICE);}
	SClass_ID		SuperClassID() {return REF_TARGET_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(MOUSE_DEVICE_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};
static MouseDeviceClassDescOld mouseCDOld;
ClassDesc* GetMouseDeviceClassDescDescOld() {return &mouseCDOld;}

class MouseDeviceClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading) {return new MouseDeviceBinding;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_MOUSEDEVICE);}
	SClass_ID		SuperClassID() {return MOT_CAP_DEVBINDING_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(MOUSE_DEVICE_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};
static MouseDeviceClassDesc mouseCD;
ClassDesc* GetMouseDeviceClassDescDesc() {return &mouseCD;}

class TheMouseDeviceClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return GetMouseDevice();}
	const TCHAR *	ClassName() {return GetString(IDS_RB_MOUSEDEVICE);}
	SClass_ID		SuperClassID() {return MOT_CAP_DEV_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(MOUSE_DEVICE_CLASS_ID,1);}
	const TCHAR* 	Category() {return _T("");}
	};
static TheMouseDeviceClassDesc theMouseCD;
ClassDesc* GetTheMouseDeviceClassDescDesc() {return &theMouseCD;}


//--- Mouse device binding ---------------------------------------------------

static BOOL CALLBACK MouseDeviceDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

static MouseDevice theMouseDevice;
static MCInputDevice *GetMouseDevice() {return &theMouseDevice;}

float MouseDeviceBinding::Eval(TimeValue t)
	{
	float val = 0.0f;
	if (which==MC_MOUSE_X) {
		return theMouseDevice.DX() * scale * (invert?-1.0f:1.0f);
	} else {
		return theMouseDevice.DY() * scale * (invert?-1.0f:1.0f);
		}
	}

RefTargetHandle MouseDeviceBinding::Clone(RemapDir& remap)
	{
	MouseDeviceBinding *b = new MouseDeviceBinding;
	b->which  = which;
	b->invert = invert;
	b->scale  = scale;
	return b;
	}

void MouseDeviceBinding::BeginActivate(BOOL reset)
	{
	if (reset) theMouseDevice.ZeroMouse();
	}

void MouseDeviceBinding::AddRollup(IMCParamDlg *dlg)
	{	
	dlg->iRoll->AppendRollup(
			hInstance, 
			MAKEINTRESOURCE(IDD_MC_MOUSE), 
			MouseDeviceDlgProc, 
			GetString(IDS_RB_MOUSEDEVICE), 
			(LPARAM)dlg);
	}

void MouseDeviceBinding::UpdateRollup(IRollupWindow *iRoll)
	{
	if (iRoll->GetNumPanels()>1) {
		HWND hWnd = iRoll->GetPanelDlg(1);
		CheckDlgButton(hWnd,IDC_MOUSE_X,which==MC_MOUSE_X);
		CheckDlgButton(hWnd,IDC_MOUSE_Y,which==MC_MOUSE_Y);
		CheckDlgButton(hWnd,IDC_MOUSE_FLIP,invert);

		ISpinnerControl *spin = GetISpinner(GetDlgItem(hWnd,IDC_MOUSE_SCALESPIN));
		spin->SetLimits(0.0f, float(999999), FALSE);
		spin->SetScale(0.01f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_MOUSE_SCALE), EDITTYPE_FLOAT);
		spin->SetValue(scale,FALSE);
		ReleaseISpinner(spin);
		}
	}

static BOOL CALLBACK MouseDeviceDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	IMCParamDlg *dlg = (IMCParamDlg*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!dlg && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:
			dlg = (IMCParamDlg*)lParam;
			dlg->binding->UpdateRollup(dlg->iRoll);
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_MOUSE_X: {
					MouseDeviceBinding *b = (MouseDeviceBinding*)dlg->binding;
					b->which = MC_MOUSE_X;
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;
					}

				case IDC_MOUSE_Y: {
					MouseDeviceBinding *b = (MouseDeviceBinding*)dlg->binding;
					b->which = MC_MOUSE_Y;
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;
					}

				case IDC_MOUSE_FLIP: {
					MouseDeviceBinding *b = (MouseDeviceBinding*)dlg->binding;
					b->invert = IsDlgButtonChecked(hWnd,IDC_MOUSE_FLIP);
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;
					}
				}
			break;

		case CC_SPINNER_CHANGE: {
			ISpinnerControl *spin = (ISpinnerControl *)lParam;
			MouseDeviceBinding *b = (MouseDeviceBinding*)dlg->binding;
			b->scale = spin->GetFVal();
			b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
			break;
			}

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:   			
   			dlg->iRoll->DlgMouseMessage(hWnd,msg,wParam,lParam);
			break; 

		default:
			return FALSE;
		}
	return TRUE;
	}


#define WHICH_CHUNK_ID		0x0100
#define INVERT_CHUNK_ID		0x0200
#define SCALE_CHUNK_ID		0x0300

IOResult MouseDeviceBinding::Save(ISave *isave)
	{
	ULONG nb;	

	isave->BeginChunk(WHICH_CHUNK_ID);
	isave->Write(&which,sizeof(which),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(INVERT_CHUNK_ID);
	isave->Write(&invert,sizeof(invert),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(SCALE_CHUNK_ID);
	isave->Write(&scale,sizeof(scale),&nb);
	isave->EndChunk();
	
	return IO_OK;
	}

IOResult MouseDeviceBinding::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case WHICH_CHUNK_ID:
				res=iload->Read(&which,sizeof(which),&nb);
				break;

			case INVERT_CHUNK_ID:
				res=iload->Read(&invert,sizeof(invert),&nb);
				break;

			case SCALE_CHUNK_ID:
				res=iload->Read(&scale,sizeof(scale),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	return IO_OK;
	}




//--- MouseDevice --------------------------------------------------

void MouseDevice::ZeroMouse()
	{
	POINT pt;
	GetCursorPos(&pt);
	xbase = pt.x;
	ybase = pt.y;
	}

void MouseDevice::CheckForWrap()
	{
	#define	WRAP_MARGIN 10
	int sy = GetSystemMetrics(SM_CYSCREEN);
	int sx = GetSystemMetrics(SM_CXSCREEN);
	POINT pt;
	GetCursorPos(&pt);
	if (pt.y<WRAP_MARGIN) {
		ybase += sy-WRAP_MARGIN-pt.y;
		pt.y   = sy-WRAP_MARGIN;
		SetCursorPos(pt.x, pt.y);		
	} else 
	if (pt.y>sy-WRAP_MARGIN) {			
		ybase  += WRAP_MARGIN-pt.y;
		pt.y    = WRAP_MARGIN;			
		SetCursorPos(pt.x, pt.y);		
		}
	if (pt.x<WRAP_MARGIN) {
		xbase += sx-WRAP_MARGIN-pt.x;
		pt.x   = sx-WRAP_MARGIN;
		SetCursorPos(pt.x, pt.y);		
	} else 
	if (pt.x>sx-WRAP_MARGIN) {			
		xbase  += WRAP_MARGIN-pt.x;
		pt.x    = WRAP_MARGIN;			
		SetCursorPos(pt.x, pt.y);		
		}
	}

float MouseDevice::DX()
	{
	CheckForWrap();
	POINT pt;
	GetCursorPos(&pt);
	return float(pt.x - xbase);
	}

float MouseDevice::DY()
	{
	CheckForWrap();
	POINT pt;
	GetCursorPos(&pt);
	return -float(pt.y - ybase);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\joydev.cpp ===
/**********************************************************************
 *<
	FILE: joydev.cpp

	DESCRIPTION: Joystick device for motion capture system

	CREATED BY: Rolf Berteig

	HISTORY: November 8, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "motion.h"
#include "mcapdev.h"
//#include "mmanager.h"

static MCInputDevice *GetJoyDevice();

#define JOY_DEVICE_CLASS_ID	0xf52b57d1

#define SPEED_UI_FACT 1.0f

class JoyDeviceBinding : public MCDeviceBinding {
	public:
		int which, invert, type, btype;	 // For joystick, type=1 is accum. mode. For buttons, type=0 is inc/dec, type=1 is inc, and type=2 is absolute mode
		float scale, speed, curVal;				
		IMCControl *cont; // Ref #0
		int dir, comp;

		JoyDeviceBinding();
		MCInputDevice *GetDevice() {return GetJoyDevice();}
		TSTR BindingName();
		float Eval(TimeValue t);
		void Accumulate(TimeValue t);
		void DeleteThis() {delete this;}
		Class_ID ClassID() {return Class_ID(JOY_DEVICE_CLASS_ID,0);}
		RefTargetHandle Clone(RemapDir& remap);

		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return cont;}
		void SetReference(int i, RefTargetHandle rtarg) {cont = (IMCControl*)rtarg;}

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		void AddRollup(IMCParamDlg *dlg);
		void UpdateRollup(IRollupWindow *iRoll);
		void BeginActivate(BOOL reset);
		void EndActivate();
		void SetStates(HWND hWnd);
		void UpdateContName(HWND hWnd);
		void DoPickCont(HWND hWnd);
		BOOL Accumulating();
	};


#define FILTER_SIZE		100

class JoyDevice : public MCInputDevice {
	public:
		BOOL active, error;
		DWORD xbase, ybase, zbase, tbase;
		DWORD xsamp[FILTER_SIZE];
		DWORD ysamp[FILTER_SIZE];
		DWORD zsamp[FILTER_SIZE];
		DWORD tsamp[FILTER_SIZE];

		DWORD filterPos, count;
		CRITICAL_SECTION csect;

		JoyDevice();
		~JoyDevice();

		TSTR DeviceName() {return GetString(IDS_RB_JOYDEVICE);}
		MCDeviceBinding *CreateBinding() {return new JoyDeviceBinding;}

		void Cycle(UINT tick);
		void ZeroJoy();
		float DX();
		float DY();
		float DZ();
		float DT();
		float POVH();
		float POVV();
		float But1();
		float But2();
		float But3();
		float But4();
		DWORD Filter(DWORD *f);

		DWORD ReadButtons();
		DWORD ReadPOV();
	};

//--- Class Descriptor -----------------------------------------------

// This is only here to support old files. Before the motion capture
// device interface was made plug-able the general REF_TARGET_CLASS_ID was used.
class JoyDeviceClassDescOld:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading) {return new JoyDeviceBinding;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_JOYDEVICE);}
	SClass_ID		SuperClassID() {return REF_TARGET_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(JOY_DEVICE_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};
static JoyDeviceClassDescOld joyCDOld;
ClassDesc* GetJoyDeviceClassDescDescOld() {return &joyCDOld;}

class JoyDeviceClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading) {return new JoyDeviceBinding;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_JOYDEVICE);}
	SClass_ID		SuperClassID() {return MOT_CAP_DEVBINDING_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(JOY_DEVICE_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};
static JoyDeviceClassDesc joyCD;
ClassDesc* GetJoyDeviceClassDescDesc() {return &joyCD;}

class TheJoyDeviceClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return GetJoyDevice();}
	const TCHAR *	ClassName() {return GetString(IDS_RB_JOYDEVICE);}
	SClass_ID		SuperClassID() {return MOT_CAP_DEV_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(JOY_DEVICE_CLASS_ID,1);}
	const TCHAR* 	Category() {return _T("");}
	};
static TheJoyDeviceClassDesc theJoyCD;
ClassDesc* GetTheJoyDeviceClassDescDesc() {return &theJoyCD;}



//--- Joy device binding ---------------------------------------------------

static BOOL CALLBACK JoyDeviceDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

static JoyDevice theJoyDevice;
static MCInputDevice *GetJoyDevice() {return &theJoyDevice;}

JoyDeviceBinding::JoyDeviceBinding() 
	{
	which  = IDC_JOY_X; 
	scale  = 1.0f; 
	speed  = 10.0f * SPEED_UI_FACT;
	curVal = 0.0f;
	invert = FALSE;
	type   = 0;
	btype  = 0;
	cont   = NULL;
	dir    = 2;
	comp   = 0;
	}

TSTR JoyDeviceBinding::BindingName() 
	{
	return GetString(which);
	}

BOOL JoyDeviceBinding::Accumulating()
	{
	switch (which) {
		case IDC_JOY_X:
		case IDC_JOY_Y:
		case IDC_JOY_Z:
			if (!type) return FALSE;
			break;
		case IDC_JOY_BUT1:
		case IDC_JOY_BUT2:
		case IDC_JOY_BUT3:
		case IDC_JOY_BUT4:
			if (btype==2) return FALSE;
			break;
		}
	return TRUE;
	}

void JoyDeviceBinding::Accumulate(TimeValue t)
	{
	float fact = 1.0f, bval;
	
	if (!Accumulating()) return;

	if (cont) {
		Matrix3 tm(1);
		cont->GetValueLive(t,&tm,CTRL_RELATIVE);
		fact = tm.GetRow(dir)[comp];
		}

	switch (which) {
		case IDC_JOY_X:
			curVal += theJoyDevice.DX() * 0.05f * fact * scale * (invert?-1.0f:1.0f);			
			break;
		case IDC_JOY_Y:
			curVal += theJoyDevice.DY() * 0.05f * fact * scale * (invert?-1.0f:1.0f);			
			break;
		case IDC_JOY_Z:
			curVal += theJoyDevice.DZ() * 0.05f * fact * scale * (invert?-1.0f:1.0f);			
			break;
		case IDC_JOY_THROTTLE:
			curVal += theJoyDevice.DT() * 0.05f * fact * scale * (invert?-1.0f:1.0f);			
			break;

		case IDC_JOY_POVH:
			curVal += speed * fact * theJoyDevice.POVH();
			break;
		case IDC_JOY_POVV:
			curVal += speed * fact * theJoyDevice.POVV();
			break;

		case IDC_JOY_BUT1:
			bval = theJoyDevice.But1();
			switch (btype) {
				case 0: curVal += speed * fact * bval; break;
				case 1: if (bval>0) curVal += speed * fact * bval; break;
				}
			if (speed>0.0f && curVal<0.0f) curVal = 0.0f;
			if (speed<0.0f && curVal>0.0f) curVal = 0.0f;
			break;
		case IDC_JOY_BUT2:
			bval = theJoyDevice.But2();
			switch (btype) {
				case 0: curVal += speed * fact * bval; break;
				case 1: if (bval>0) curVal += speed * fact * bval; break;				
				}			
			if (speed>0.0f && curVal<0.0f) curVal = 0.0f;
			if (speed<0.0f && curVal>0.0f) curVal = 0.0f;
			break;
		case IDC_JOY_BUT3:
			bval = theJoyDevice.But3();
			switch (btype) {
				case 0: curVal += speed * fact * bval; break;
				case 1: if (bval>0) curVal += speed * fact * bval; break;
				}			
			if (speed>0.0f && curVal<0.0f) curVal = 0.0f;
			if (speed<0.0f && curVal>0.0f) curVal = 0.0f;
			break;
		case IDC_JOY_BUT4:
			bval = theJoyDevice.But4();
			switch (btype) {
				case 0: curVal += speed * fact * bval; break;
				case 1: if (bval>0) curVal += speed * fact * bval; break;
				}			
			if (speed>0.0f && curVal<0.0f) curVal = 0.0f;
			if (speed<0.0f && curVal>0.0f) curVal = 0.0f;
			break;			
		}
	}

float JoyDeviceBinding::Eval(TimeValue t)
	{		
	float bval;
	switch (which) {
		case IDC_JOY_X:			
			if (!type) curVal = theJoyDevice.DX() * scale * (invert?-1.0f:1.0f);
			break;
		case IDC_JOY_Y:			
			if (!type) curVal = theJoyDevice.DY() * scale * (invert?-1.0f:1.0f);
			break;
		case IDC_JOY_Z:			
			if (!type) curVal = theJoyDevice.DZ() * scale * (invert?-1.0f:1.0f);
			break;
		case IDC_JOY_THROTTLE:			
			if (!type) curVal = theJoyDevice.DT() * scale * (invert?-1.0f:1.0f);
			break;

		case IDC_JOY_BUT1:						
			if (btype==2) {
				bval = theJoyDevice.But1();
				if (bval>0) curVal = speed; else curVal = 0.0f; break;
				}			
			break;
		case IDC_JOY_BUT2:			
			if (btype==2) {
				bval = theJoyDevice.But2();
				if (bval>0) curVal = speed; else curVal = 0.0f; break;
				}
			break;
		case IDC_JOY_BUT3:
			if (btype==2) {
				bval = theJoyDevice.But3();
				if (bval>0) curVal = speed; else curVal = 0.0f; break;
				}			
			break;
		case IDC_JOY_BUT4:			
			if (btype==2) {
				bval = theJoyDevice.But4();
				if (bval>0) curVal = speed; else curVal = 0.0f; break;
				}			
			break;			
		}
	
	return curVal;
	}

RefTargetHandle JoyDeviceBinding::Clone(RemapDir& remap)
	{
	JoyDeviceBinding *b = new JoyDeviceBinding;
	b->which  = which;
	b->invert = invert;
	b->scale  = scale;
	b->speed  = speed;
	b->type   = type;
	b->btype  = btype;
	b->dir    = dir;
	b->comp   = comp;
	if (cont) b->ReplaceReference(0,cont);
	return b;
	}

void JoyDeviceBinding::BeginActivate(BOOL reset)
	{
	BOOL wasActive = theJoyDevice.active;
	theJoyDevice.active = TRUE;
	if (reset) {
		if (!wasActive) theJoyDevice.ZeroJoy();
		curVal = 0.0f;
		}
	}

void JoyDeviceBinding::EndActivate()
	{
	theJoyDevice.active = FALSE;
	}


void JoyDeviceBinding::AddRollup(IMCParamDlg *dlg)
	{	
	dlg->iRoll->AppendRollup(
			hInstance, 
			MAKEINTRESOURCE(IDD_MC_JOY), 
			JoyDeviceDlgProc, 
			GetString(IDS_RB_JOYDEVICE), 
			(LPARAM)dlg);
	}

void JoyDeviceBinding::UpdateRollup(IRollupWindow *iRoll)
	{
	if (iRoll->GetNumPanels()>1) {
		HWND hWnd = iRoll->GetPanelDlg(1);
		
		CheckDlgButton(hWnd,IDC_JOY_X,IDC_JOY_X==which);
		CheckDlgButton(hWnd,IDC_JOY_Y,IDC_JOY_Y==which);
		CheckDlgButton(hWnd,IDC_JOY_Z,IDC_JOY_Z==which);
		CheckDlgButton(hWnd,IDC_JOY_THROTTLE,IDC_JOY_THROTTLE==which);
		CheckDlgButton(hWnd,IDC_JOY_POVH,IDC_JOY_POVH==which);
		CheckDlgButton(hWnd,IDC_JOY_POVV,IDC_JOY_POVV==which);
		CheckDlgButton(hWnd,IDC_JOY_BUT1,IDC_JOY_BUT1==which);
		CheckDlgButton(hWnd,IDC_JOY_BUT2,IDC_JOY_BUT2==which);
		CheckDlgButton(hWnd,IDC_JOY_BUT3,IDC_JOY_BUT3==which);
		CheckDlgButton(hWnd,IDC_JOY_BUT4,IDC_JOY_BUT4==which);

		CheckDlgButton(hWnd,IDC_JOY_FLIP,invert);
		CheckDlgButton(hWnd,IDC_JOY_ACCUM,type);

		CheckDlgButton(hWnd,IDC_JOY_TYPEINCDEC  ,btype==0);
		CheckDlgButton(hWnd,IDC_JOY_TYPEINC     ,btype==1);
		CheckDlgButton(hWnd,IDC_JOY_TYPEABSOLUTE,btype==2);

		CheckDlgButton(hWnd,IDC_JOY_DIRX,dir==0);
		CheckDlgButton(hWnd,IDC_JOY_DIRY,dir==1);
		CheckDlgButton(hWnd,IDC_JOY_DIRZ,dir==2);

		CheckDlgButton(hWnd,IDC_JOY_COMPX,comp==0);
		CheckDlgButton(hWnd,IDC_JOY_COMPY,comp==1);
		CheckDlgButton(hWnd,IDC_JOY_COMPZ,comp==2);

		ISpinnerControl *spin = GetISpinner(GetDlgItem(hWnd,IDC_JOY_SCALESPIN));
		spin->SetLimits(0.0f, float(999999), FALSE);
		spin->SetScale(0.01f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_JOY_SCALE), EDITTYPE_FLOAT);
		spin->SetValue(scale,FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_JOY_SPEEDSPIN));
		spin->SetLimits(-float(999999), float(999999), FALSE);
		spin->SetScale(0.01f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_JOY_SPEED), EDITTYPE_FLOAT);
		spin->SetValue(speed/SPEED_UI_FACT,FALSE);
		ReleaseISpinner(spin);

		SetStates(hWnd);
		UpdateContName(hWnd);
		}
	}

void JoyDeviceBinding::UpdateContName(HWND hWnd)
	{
	if (cont) {
		TSTR name;
		cont->NotifyDependents(FOREVER,(PartID)&name,REFMSG_GET_NODE_NAME);
		if (name.length()) name = name + TSTR(_T("\\")) + TSTR(_T("Rotation"));
		else name = _T("Rotation");
		SetDlgItemText(hWnd,IDC_INC_BINDING, name);
	} else {
		SetDlgItemText(hWnd,IDC_INC_BINDING,GetString(IDS_RB_NONE));
		}
	}

void JoyDeviceBinding::SetStates(HWND hWnd)
	{
	switch (which) {
		case IDC_JOY_BUT1:
		case IDC_JOY_BUT2:
		case IDC_JOY_BUT3:
		case IDC_JOY_BUT4:
			EnableWindow(GetDlgItem(hWnd,IDC_JOY_TYPEINCDEC  ),TRUE);
			EnableWindow(GetDlgItem(hWnd,IDC_JOY_TYPEINC     ),TRUE);
			EnableWindow(GetDlgItem(hWnd,IDC_JOY_TYPEABSOLUTE),TRUE);
			break;

		default:
			EnableWindow(GetDlgItem(hWnd,IDC_JOY_TYPEINCDEC  ),FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_JOY_TYPEINC     ),FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_JOY_TYPEABSOLUTE),FALSE);
			break;
		}

	if (Accumulating()) {
		if (cont) EnableWindow(GetDlgItem(hWnd,IDC_CLEAR_INC_BINDING),TRUE);
		else EnableWindow(GetDlgItem(hWnd,IDC_CLEAR_INC_BINDING),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_INC_BINDING),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_DIRX),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_DIRY),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_DIRZ),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_COMPX),TRUE);		
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_COMPY),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_COMPZ),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_BASED_ON_DIR_LABEL),TRUE);		
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_DIRLABEL),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_COMPLABEL),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_CONTLABEL),TRUE);
	} else {
		EnableWindow(GetDlgItem(hWnd,IDC_INC_BINDING),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_CLEAR_INC_BINDING),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_DIRX),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_DIRY),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_DIRZ),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_COMPX),FALSE);		
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_COMPY),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_COMPZ),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_BASED_ON_DIR_LABEL),FALSE);		
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_DIRLABEL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_COMPLABEL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_JOY_CONTLABEL),FALSE);
		}	
	}

class MCTrackViewFilter : public TrackViewFilter {
	public:		
		BOOL proc(Animatable *anim, Animatable *client,int subNum)
			{
			if (anim->SuperClassID()==CTRL_ROTATION_CLASS_ID &&
				anim->ClassID()==Class_ID(ROT_MOTION_CLASS_ID,0)) {
				return TRUE;
			} else {
				return FALSE;
				}
			}
	};

void JoyDeviceBinding::DoPickCont(HWND hWnd)
	{
	TrackViewPick res;
	MCTrackViewFilter filt;
	if (GetCOREInterface()->TrackViewPickDlg(hWnd,&res, &filt)) {
		if (ReplaceReference(0,res.anim)!=REF_SUCCEED) {
			MessageBox(hWnd,
				_T("Can't create circular reference."),
				GetString(IDS_RB_JOYDEVICE),
				MB_OK|MB_ICONEXCLAMATION);
			}
		UpdateContName(hWnd);
		SetStates(hWnd);
		}
	}

static BOOL CALLBACK JoyDeviceDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	IMCParamDlg *dlg = (IMCParamDlg*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!dlg && msg!=WM_INITDIALOG) return FALSE;
	JoyDeviceBinding *b;
	if (dlg) b = (JoyDeviceBinding*)dlg->binding;

	switch (msg) {
		case WM_INITDIALOG:
			dlg = (IMCParamDlg*)lParam;			
			dlg->binding->UpdateRollup(dlg->iRoll);
			SetWindowLong(hWnd,GWL_USERDATA,lParam);			
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_JOY_X:
				case IDC_JOY_Y:
				case IDC_JOY_Z:
				case IDC_JOY_THROTTLE:
				case IDC_JOY_POVH:
				case IDC_JOY_POVV:
				case IDC_JOY_BUT1:
				case IDC_JOY_BUT2:
				case IDC_JOY_BUT3:
				case IDC_JOY_BUT4:					
					b->which = LOWORD(wParam);
					b->SetStates(hWnd);
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);					
					break;								
					
				case IDC_JOY_FLIP:					
					b->invert = IsDlgButtonChecked(hWnd,IDC_JOY_FLIP);
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;

				case IDC_JOY_ACCUM:
					b->type = IsDlgButtonChecked(hWnd,IDC_JOY_ACCUM);
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					b->SetStates(hWnd);
					break;

				case IDC_JOY_TYPEINCDEC:
					b->btype = 0;
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;
				case IDC_JOY_TYPEINC:
					b->btype = 1;
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;
				case IDC_JOY_TYPEABSOLUTE:
					b->btype = 2;
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;

				case IDC_JOY_DIRX:
					b->dir = 0;
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;
				case IDC_JOY_DIRY:
					b->dir = 1;
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;
				case IDC_JOY_DIRZ:
					b->dir = 2;
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;

				case IDC_JOY_COMPX:
					b->comp = 0;
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;
				case IDC_JOY_COMPY:
					b->comp = 1;
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;
				case IDC_JOY_COMPZ:
					b->comp = 2;
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;

				case IDC_INC_BINDING:
					b->DoPickCont(hWnd);
					break;

				case IDC_CLEAR_INC_BINDING:
					b->ReplaceReference(0,NULL);
					b->UpdateContName(hWnd);
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;
				}
			break;

		case CC_SPINNER_CHANGE: {
			ISpinnerControl *spin = (ISpinnerControl *)lParam;			
			switch (LOWORD(wParam)) {
				case IDC_JOY_SCALESPIN:
					b->scale = spin->GetFVal();
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;

				case IDC_JOY_SPEEDSPIN:
					b->speed = spin->GetFVal()*SPEED_UI_FACT;
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;
				}

			break;
			}

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:   			
   			dlg->iRoll->DlgMouseMessage(hWnd,msg,wParam,lParam);
			break; 

		default:
			return FALSE;
		}
	return TRUE;
	}


#define WHICH_CHUNK_ID		0x0100
#define INVERT_CHUNK_ID		0x0200
#define SCALE_CHUNK_ID		0x0300
#define SPEED_CHUNK_ID		0x0400
#define TYPE_CHUNK_ID		0x0410
#define BTYPE_CHUNK_ID		0x0420
#define DIR_CHUNK_ID		0x0430
#define COMP_CHUNK_ID		0x0440

IOResult JoyDeviceBinding::Save(ISave *isave)
	{
	ULONG nb;	

	isave->BeginChunk(WHICH_CHUNK_ID);
	isave->Write(&which,sizeof(which),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(INVERT_CHUNK_ID);
	isave->Write(&invert,sizeof(invert),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(SCALE_CHUNK_ID);
	isave->Write(&scale,sizeof(scale),&nb);
	isave->EndChunk();

	isave->BeginChunk(SPEED_CHUNK_ID);
	isave->Write(&speed,sizeof(speed),&nb);
	isave->EndChunk();

	isave->BeginChunk(TYPE_CHUNK_ID);
	isave->Write(&type,sizeof(type),&nb);
	isave->EndChunk();

	isave->BeginChunk(BTYPE_CHUNK_ID);
	isave->Write(&btype,sizeof(btype),&nb);
	isave->EndChunk();

	isave->BeginChunk(DIR_CHUNK_ID);
	isave->Write(&dir,sizeof(dir),&nb);
	isave->EndChunk();

	isave->BeginChunk(COMP_CHUNK_ID);
	isave->Write(&comp,sizeof(comp),&nb);
	isave->EndChunk();
	
	return IO_OK;
	}

IOResult JoyDeviceBinding::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case WHICH_CHUNK_ID:
				res=iload->Read(&which,sizeof(which),&nb);
				break;

			case INVERT_CHUNK_ID:
				res=iload->Read(&invert,sizeof(invert),&nb);
				break;

			case SCALE_CHUNK_ID:
				res=iload->Read(&scale,sizeof(scale),&nb);
				break;

			case SPEED_CHUNK_ID:
				res=iload->Read(&speed,sizeof(speed),&nb);
				break;

			case TYPE_CHUNK_ID:
				res=iload->Read(&type,sizeof(type),&nb);
				break;

			case BTYPE_CHUNK_ID:
				res=iload->Read(&btype,sizeof(btype),&nb);
				break;

			case DIR_CHUNK_ID:
				res=iload->Read(&dir,sizeof(dir),&nb);
				break;

			case COMP_CHUNK_ID:
				res=iload->Read(&comp,sizeof(comp),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	return IO_OK;
	}




//--- JoyDevice --------------------------------------------------

JoyDevice::JoyDevice()
	{
	InitializeCriticalSection(&csect);
	active = FALSE;
	error  = FALSE;
	}

JoyDevice::~JoyDevice()
	{
	DeleteCriticalSection(&csect);
	}

void JoyDevice::ZeroJoy()
	{
	EnterCriticalSection(&csect);

	int dev = joyGetNumDevs();
	JOYINFOEX ji;
	memset(&ji,0,sizeof(ji));
	ji.dwSize = sizeof(ji);
	ji.dwFlags = JOY_RETURNALL;
	MMRESULT res = joyGetPosEx(JOYSTICKID1,&ji);
	error = FALSE;
	switch (res) {
		case JOYERR_UNPLUGGED:
			MessageBox(NULL,_T("Joystick is unplugged"), _T("Joy Stick"), MB_OK);
			error = TRUE;
			break;

		case MMSYSERR_NODRIVER:
			MessageBox(NULL,_T("No joystick driver present."), _T("Joy Stick"), MB_OK);
			error = TRUE;
			break;

		case MMSYSERR_INVALPARAM:
			MessageBox(NULL,_T("Invalid parameter."), _T("Joy Stick"), MB_OK);
			error = TRUE;
			break;
		}
	xbase = ji.dwXpos;
	ybase = ji.dwYpos;	
	zbase = ji.dwRpos;	
	tbase = ji.dwZpos;

	count = 0;
	filterPos = 0;
	Cycle(0);

	LeaveCriticalSection(&csect);
	}

float JoyDevice::DX()
	{
	DWORD val = Filter(xsamp);
	return 0.005f * (float(val) - float(xbase));
	}

float JoyDevice::DY()
	{		
	DWORD val = Filter(ysamp);
	return 0.005f * (float(val) - float(ybase));
	}

float JoyDevice::DZ()
	{		
	DWORD val = Filter(zsamp);
	return 0.005f * (float(val) - float(zbase));
	}

float JoyDevice::DT()
	{		
	DWORD val = Filter(tsamp);
	return 0.005f * (float(val) - float(tbase));
	}

void JoyDevice::Cycle(UINT tick)
	{
	if (!active) return;
	if (error) return;

	JOYINFOEX ji;
	memset(&ji,0,sizeof(ji));
	ji.dwSize = sizeof(ji);
	ji.dwFlags = JOY_RETURNALL;
	
	EnterCriticalSection(&csect);
	joyGetPosEx(JOYSTICKID1,&ji);	
	
	xsamp[filterPos] = ji.dwXpos;
	ysamp[filterPos] = ji.dwYpos;
	zsamp[filterPos] = ji.dwRpos;
	tsamp[filterPos] = ji.dwZpos;
	if (count<FILTER_SIZE) count++;
	filterPos++;
	if (filterPos>=FILTER_SIZE) filterPos = 0;
	LeaveCriticalSection(&csect);	
	}

DWORD JoyDevice::Filter(DWORD *f)
	{
	if (!count) return 0;
	DWORD val = 0;
	EnterCriticalSection(&csect);	
	for (DWORD i=0; i<count; i++) {
		int index = filterPos-i-1;
		if (index<0) index += FILTER_SIZE;
		assert(index>=0 && index<FILTER_SIZE);
		val += f[index];
		}
	LeaveCriticalSection(&csect);	
	if (!count) return 0;
	return val/count;
	}

float JoyDevice::POVH()
	{
	DWORD pov = ReadPOV();
	float val = 0.0f;
	if (pov==JOY_POVLEFT)  val = -1.0f;
	if (pov==JOY_POVRIGHT) val = 1.0f;
	return val;
	}

float JoyDevice::POVV()
	{
	DWORD pov = ReadPOV();
	float val = 0.0f;
	if (pov==JOY_POVFORWARD)   val = 1.0f;
	if (pov==JOY_POVBACKWARD)  val = -1.0f;
	return val;
	}

float JoyDevice::But1()
	{
	return ReadButtons()&JOY_BUTTON1 ? 1.0f : -1.0f;
	}

float JoyDevice::But2()
	{
	return ReadButtons()&JOY_BUTTON2 ? 1.0f : -1.0f;
	}

float JoyDevice::But3()
	{
	return ReadButtons()&JOY_BUTTON3 ? 1.0f : -1.0f;
	}

float JoyDevice::But4()
	{
	return ReadButtons()&JOY_BUTTON4 ? 1.0f : -1.0f;
	}

DWORD JoyDevice::ReadButtons()
	{
	if (error) return 0;

	JOYINFOEX ji;
	memset(&ji,0,sizeof(ji));
	ji.dwSize = sizeof(ji);
	ji.dwFlags = JOY_RETURNALL;
	
	EnterCriticalSection(&csect);
	joyGetPosEx(JOYSTICKID1,&ji);	
	LeaveCriticalSection(&csect);	

	return ji.dwButtons;
	}

DWORD JoyDevice::ReadPOV()
	{
	if (error) return 0;

	JOYINFOEX ji;
	memset(&ji,0,sizeof(ji));
	ji.dwSize = sizeof(ji);
	ji.dwFlags = JOY_RETURNPOVCTS;
	
	EnterCriticalSection(&csect);
	joyGetPosEx(JOYSTICKID1,&ji);
	LeaveCriticalSection(&csect);	

	return ji.dwPOV;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\floatmc.cpp ===
/**********************************************************************
 *<
	FILE: floatMC.cpp

	DESCRIPTION: Float motion capture controller

	CREATED BY: Rolf Berteig

	HISTORY: October 30, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "motion.h"
#include "mmanager.h"


static Class_ID floatmcControlClassID(FLOAT_MOTION_CLASS_ID,0); 

class FloatMC : public MCControl {
	public:
		MCDeviceBinding *bind;
		float base;
		int sampleCount;
		float *data;

		FloatMC();
		Class_ID ClassID() {return floatmcControlClassID;}  
		SClass_ID SuperClassID() {return CTRL_FLOAT_CLASS_ID;} 
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_FLOATMC);}
		ParamDimension* GetParamDimension(int i) {return defaultDim;}
		RefTargetHandle Clone(RemapDir& remap);

		int NumDeviceBindings() {return 1;}
		MCDeviceBinding *GetDeviceBinding(int i) {return bind;}
		void SetDeviceBinding(int i,MCDeviceBinding *b) {bind=b;}
		void GetValueLive(TimeValue t,void *val, GetSetMethod method);
		void BeginCapture(Interval record,TimeValue sampSize);
		void EndCapture(Interval record,TimeValue sampSize, KeyReduceStatus *stat);
		void Capture(Interval record,TimeValue t,int sample);
		void BeginLive(TimeValue t);

		void EditTrackParams(
			TimeValue t, ParamDimensionBase *dim, TCHAR *pname, 
			HWND hParent, IObjParam *ip, DWORD flags);
	};


//--- Class Descriptor -----------------------------------------------

class FloatMCClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new FloatMC;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_FLOATMC);}
	SClass_ID		SuperClassID() {return CTRL_FLOAT_CLASS_ID;}
	Class_ID		ClassID() {return floatmcControlClassID;}
	const TCHAR* 	Category() {return _T("");}
	};
static FloatMCClassDesc floatmcCD;
ClassDesc* GetFloatMotionDesc() {return &floatmcCD;}


//--- FloatMC methods ----------------------------------------------

FloatMC::FloatMC()
	{
	ReplaceReference(0,CreateInterpFloat());
	bind = NULL;
	base = 0.0f;
	data = NULL;
	}

RefTargetHandle FloatMC::Clone(RemapDir& remap)
	{
	FloatMC *c = new FloatMC;
	c->MCControlClone(this,remap);
	return c;
	}

void FloatMC::EditTrackParams(
		TimeValue t, ParamDimensionBase *dim, TCHAR *pname, 
		HWND hParent, IObjParam *ip, DWORD flags)
	{
	GenMCParamDlg *dlg = new GenMCParamDlg(this,IDD_MC_FLOAT);
	dlg->DoWindow(hParent, pname);
	}

void FloatMC::GetValueLive(TimeValue t,void *val, GetSetMethod method)
	{
	float pt = base;
	if (bind) pt += bind->Eval(t);
	if (method==CTRL_ABSOLUTE) {
		*((float*)val)  = pt;
	} else {
		*((float*)val) += pt;
		}
	}


void FloatMC::BeginCapture(Interval record,TimeValue sampSize)
	{
	// Set the base point to the controller value at the start time.
	cont->GetValue(record.Start(),&base,FOREVER,CTRL_ABSOLUTE);	

	// Allocate a data buffer
	sampleCount = record.Duration()/sampSize + 1;
	data = new float[sampleCount];
	for (int i=0; i<sampleCount; i++) data[i] = 0.0f;
	}

void FloatMC::Capture(Interval record,TimeValue t,int sample)
	{
	assert(sample>=0 && sample<sampleCount);	
	GetValueLive(t,&data[sample], CTRL_ABSOLUTE);	
	}
  
void FloatMC::EndCapture(Interval record,TimeValue sampSize, KeyReduceStatus *stat)
	{		
	// Clear any keys out of the record interval
	cont->DeleteTime(record,TIME_INCLEFT|TIME_INCRIGHT|TIME_NOSLIDE);

	// Make keys out of the data
	SuspendAnimate();
	AnimateOn();	
	for (int i=0; i<sampleCount; i++) {
		TimeValue t = record.Start() + i * sampSize;
		cont->SetValue(t,&data[i],1,CTRL_ABSOLUTE);
		if (i%UPDATE_RATE==0) if (stat->Progress(i)!=KEYREDUCE_CONTINUE) goto abort;
		}	

abort:
	ResumeAnimate();
	delete[] data;
	base = 0.0f;
	}

void FloatMC::BeginLive(TimeValue t)
	{
	// Set the base point to the controller value at the start time.
	cont->GetValue(t,&base,FOREVER,CTRL_ABSOLUTE);	
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\mmanager.h ===
/**********************************************************************
 *<
	FILE: mmanager.h

	DESCRIPTION: Motion capture manager

	CREATED BY: Rolf Berteig

	HISTORY: October 30, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#ifndef  _MMANAGER_H_
#define	 _MMANAGER_H_

#include "keyreduc.h"
#include "mcapdev.h"


// Flags for MCControl
#define MCC_RECORD_ACTIVE	(1<<0)
#define MCC_RECORD_ON		(1<<1)
#define MCC_LIVE_ON			(1<<2)

#define UPDATE_RATE	10

// Base class for motion capture controllers.
class MCControl : public IMCControl {
	public:		
		Control *cont; // The keyframe controller that will store the data		
		DWORD flags;
		int selSet;
		TSTR trackName;

		MCControl();
		~MCControl();

		void DeleteThis() {delete this;}
		int IsKeyable() {return 1;}	

		int NumSubs()  {return 1;}
		Animatable* SubAnim(int i) {return cont;}
		TSTR SubAnimName(int i);
		
		int NumRefs() {return 1 + NumDeviceBindings();}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		int SubNumToRefNum(int subNum) {return subNum;}

		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage)
			{return REF_SUCCEED;}
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		void RefDeleted();
		void RefAdded(RefMakerHandle rm);
		void RefDeletedUndoRedo();
		void RefAddedUndoRedo(RefMakerHandle rm);
		RefResult AutoDelete();

		void Copy(Control *from);
		BOOL AssignController(Animatable *control,int subAnim);

		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);		
		
		// These are just passed on to the sub controller.		
		void AddNewKey(TimeValue t,DWORD flags);
		int NumKeys();
		TimeValue GetKeyTime(int index);
		void CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags);
		BOOL IsKeyAtTime(TimeValue t,DWORD flags);
		BOOL GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt);
		void DeleteKeyAtTime(TimeValue t);		
		int GetKeyTimes(Tab<TimeValue> &times,Interval range,DWORD flags); // RB 3/7/99: Added
		int GetKeySelState(BitArray &sel,Interval range,DWORD flags); // RB 3/7/99: Added
		void SelectKeys(TrackHitTab& sel, DWORD flags); // RB 3/7/99: Added
		BOOL IsLeaf() {return FALSE;}
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);	
		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method);
		void CommitValue(TimeValue t);
		void RestoreValue(TimeValue t);
		void EnumIKParams(IKEnumCallback &callback);
		BOOL CompDeriv(TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags);
		float IncIKParam(TimeValue t,int index,float delta);
		void ClearIKParam(Interval iv,int index);
		void EnableORTs(BOOL enable);		

		int TrackParamsType() {return TRACKPARAMS_WHOLE;}

		BOOL ControllerInScene();

		// Local methods
		void MCControlClone(MCControl *src,RemapDir& remap);
		void Accumulate(TimeValue t);
		virtual BOOL GetRecordState() {return flags&MCC_RECORD_ACTIVE ? TRUE : FALSE;}
		virtual void SetRecordState(BOOL onOff) {if (onOff) flags|=MCC_RECORD_ACTIVE; else flags &= ~MCC_RECORD_ACTIVE;}
		virtual void LiveOn();
		virtual void LiveOff();
		virtual void RecordOn(BOOL reset=TRUE);
		virtual void RecordOff();
		virtual BOOL IsLiveOn()  {return flags&MCC_LIVE_ON;}
		virtual BOOL IsRecordOn(){return flags&MCC_RECORD_ON;}
		virtual void BeginCapture(Interval record,TimeValue sampSize) {}
		virtual void EndCapture(Interval record,TimeValue sampSize, KeyReduceStatus *stat) {}
		virtual void BeginLive(TimeValue t) {}
		virtual void EndLive(TimeValue t) {}
		virtual void Capture(Interval record,TimeValue t,int sample) {}		
	};

#define STARTSTOP_CUSTOM				0
#define STARTSTOP_MEDIACONTROLSTATION	1

class StartStopParams {
	public:
		int presetType, devID;
		int channel, stop, play, record;
		StartStopParams(int t, int d, int c, int s, int p, int r)
			{presetType=t; devID=d, channel=c; stop=s; play=p; record=r;}
		StartStopParams() {}
		int GetChannel();
		int GetStop();
		int GetPlay();
		int GetRecord();
	};

class MotionManager : public UtilityObj, public IMCapManager {
	public:
		// Controllers and devices that we're managing
		Tab<MCControl*> cont;
		Tab<MCInputDevice*> device;
		BOOL listBuilt;

		// Parameters
		BOOL doubleSample, reduce, livePreRoll, playWhileTest;
		float reduceThresh;
		TimeValue pre, in, out;
		Tab<TSTR*> selSets;

		// Record/Live data
		CRITICAL_SECTION csect;
		UINT calls;
		BOOL stop, live, recording, capture;
		TimeValue startTime, sampleRate, nextSample;
		int samples, totalSamples, playSpeed;
		Interval record;

		// UI stuff
		Interface *ip;		
		IUtil *iu;
		HWND hPanel;
		HIMAGELIST hTrackIcons, hButtonIcons;
		
		// Start/Stop params
		StartStopParams ssParams;
		BOOL startStopEnabled;
		BOOL recDown, playDown;

		MotionManager();
		~MotionManager();
		void InitUI();
		void DeleteThis() {}

		void SetupDeviceList();

		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		
		void Init(HWND hWnd);
		void SetupList();
		void Destroy(HWND hWnd);
		void DrawTrack(HDC hdc,int index,BOOL sel,RECT rect);
		TSTR ControlName(MCControl *c);
		TSTR ControlName(int index);
		void Start();
		void Stop();
		void Live();
		void CheckMessages();
		void SetupStartStop();
		void SetStartStopEnable(BOOL onOff);

		void NewSelSet();
		void DeleteSelSet();
		void ActivateSelSet(int i);
		void ClearSelSetName();

		void TrackParams(HWND hWnd,int index);

		MCDeviceBinding *SelectBinding(HWND hWnd, BOOL &cancel);		
		void ToggleRecordMode(int index);

		void Register(MCControl *c);
		void UnRegister(MCControl *c);		
		BOOL IsRegistered(MCControl *c);

		void DoCapture(TimeValue pre, TimeValue start, TimeValue end, TimeValue samp);		
		void Increment();

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// From IMCapManager
		void MidiNote(int channel, int note);
		TimeValue GetTime();
	};

extern MotionManager theMM;


//--- Devices ----------------------------------------------

//extern MCInputDevice *GetMouseDevice();
//extern MCInputDevice *GetMidiDevice();
//extern MCInputDevice *GetJoyDevice();



//--- General UI for Motion Capture controllers ------------------------

#define MCPARAMDLG_CLASS_ID 0x11fa4b2a

class MCParamDlg : public IMCParamDlg {
	public:
		MCControl *cont;		
		HWND hWnd;
		BOOL valid, blockInvalidate;		

		MCParamDlg(MCControl *c);
		void DoWindow(HWND hParent, TCHAR *pname);

		Class_ID ClassID() {return Class_ID(MCPARAMDLG_CLASS_ID,0);}
		SClass_ID SuperClassID() {return REF_MAKER_CLASS_ID;}		
		
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return cont;}
		void SetReference(int i, RefTargetHandle rtarg) {cont=(MCControl*)rtarg;}

		void MaybeCloseWindow();
		void Invalidate();
		virtual void Update();
		void SetupUI(HWND hWnd);
		void Close();

		void SetBinding(MCDeviceBinding *b);

		virtual void AddRollup()=0;
		virtual void UpdateBinding(int which)=0;
		virtual HWND GetHPanel()=0;


	};

class GenMCParamDlg : public MCParamDlg {
	public:
		int editBinding;
		HWND hPanel;
		int dlgID;		

		GenMCParamDlg(MCControl *c,int dlgID);
		void Update();
		void AddRollup();
		void SetupButtons();
		void SetEditBinding(int which);
		void AssignBinding(int which);
		void UpdateBinding(int which);
		HWND GetHPanel() {return hPanel;}
	};

#define REFMSG_NEW_BINDING	(REFMSG_USER+0x0381)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\motion.cpp ===
/**********************************************************************
 *<
	FILE: motion.cpp

	DESCRIPTION: Motion capture controllers

	CREATED BY: Rolf Berteig

	HISTORY: October 30, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "motion.h"
#include "buildver.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;
	if ( !controlsInit ) {
		controlsInit = TRUE;
				
		InitCustomControls(hInstance);
		InitCommonControls();
		}
	return(TRUE);
	}

__declspec( dllexport ) const TCHAR *
LibDescription() { return
 GetString(IDS_LIB_DESCRIPTION); }


__declspec( dllexport ) int LibNumberClasses() {return 15;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0:  return	GetMotionManDesc();
		case 1:  return GetPosMotionDesc();
		case 2:  return	GetRotMotionDesc();
		case 3:  return	GetScaleMotionDesc();
		case 4:  return	GetFloatMotionDesc();
		case 5:  return	GetPoint3MotionDesc();		
		case 6:  return GetMouseDeviceClassDescDesc();
		case 7:  return GetMidiDeviceClassDescDesc();
		case 8:  return GetJoyDeviceClassDescDesc();
		case 9:  return GetMouseDeviceClassDescDescOld();
		case 10: return GetMidiDeviceClassDescDescOld();
		case 11: return GetJoyDeviceClassDescDescOld();
		case 12: return GetTheJoyDeviceClassDescDesc();
		case 13: return GetTheMouseDeviceClassDescDesc();
		case 14: return GetTheMidiDeviceClassDescDesc();
		default: return 0;
		}
	}


__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\mididev.cpp ===
/**********************************************************************
 *<
	FILE: mididev.cpp

	DESCRIPTION: A midi device for motion capture

	CREATED BY: Rolf Berteig

	HISTORY: November 6, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "motion.h"
//#include "mmanager.h"
#include "mcapdev.h"
#include "midiman.h"

static void MIDIViewerDialog(HWND hParent);
static MCInputDevice *GetMidiDevice();

#define MIDI_DEVICE_CLASS_ID	0x84d63b45

#define NUM_MIDI_CHANNELS	16
#define NUM_MIDI_NOTES		132

// Macros to pull out peices of param1
#define MIDI_CHANNEL(a)				((a)&0x0f)
#define MIDI_EVENT(a)				((a)&0xf0)
#define MIDI_NOTENUMBER(a)			(((a)&0xff00)>>8)
#define MIDI_VELOCITY(a)			(((a)&0xff0000)>>16)
#define MIDI_PITCHBEND(a)			(((a)&0xff0000)>>16)
#define MIDI_NOTEFLOAT(a,low,high)	(float((a)-(low))/float((high)-(low)))
#define MIDI_VELFLOAT(a)            (float(a)/127.0f)
#define MIDI_BENDFLOAT(a)			(float(a)/127.0f)

// MIDI events
#define MIDI_NOTE_ON		0x90
#define MIDI_NOTE_OFF		0x80
#define MIDI_PITCH_BEND		0xe0
#define MIDI_CONTROLCHANGE	0xb0

#define SPEED_UI_FACT 0.005f


class MidiDeviceBinding : public MCDeviceBinding {
	public:
		int channel, trigger, lowNote, highNote, sustain, variSustain;
		int controlNum;
		float min, max, speed;
		float curVal;		

		MidiDeviceBinding();
		MCInputDevice *GetDevice() {return GetMidiDevice();}
		TSTR BindingName() {return GetString(IDS_RB_MIDI);}
		float Eval(TimeValue t);
		void Accumulate(TimeValue t);
		void DeleteThis() {delete this;}
		Class_ID ClassID() {return Class_ID(MIDI_DEVICE_CLASS_ID,0);}
		RefTargetHandle Clone(RemapDir& remap);

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		void AddRollup(IMCParamDlg *dlg);
		void UpdateRollup(IRollupWindow *iRoll);
		void BeginActivate(BOOL reset);
		void EndActivate();

		void InitDlg(HWND hWnd);
		void SetupNote(HWND hCombo);
		void SetupOctave(HWND hCombo);
		void SetEnabledStates(HWND hWnd);

		void SetTrigger(int t) {trigger=t;}
		void SetChannel(int c) {channel=c;}
		void SetLowNote(int n) {lowNote=n;}
		void SetHighNote(int n) {highNote=n;}
		void SetMin(float m) {min=m;}
		void SetMax(float m) {max=m;}
		void SetSpeed(float s) {speed=s;}
		void SetSustain(int s) {sustain=s;}
		void SetVariSustain(int v) {variSustain=v;}
		void SetControlNum(int n) {controlNum=n;}

		int GetNoteVal(HWND hWnd, int idNote, int idOctave);
	};

class ChannelData {
	public:
		ChannelData();
		BOOL pressed[NUM_MIDI_NOTES];
		TimeValue time[NUM_MIDI_NOTES];
		int vel[NUM_MIDI_NOTES];
		int bend;
	};

class MidiDevice : public MCInputDevice {
	public:
		ChannelData data[NUM_MIDI_CHANNELS];
		BOOL active;
		//HMIDIIN hMidiIn;		
		IMCapManager *theMM;
		BOOL noDevice;

		MidiDevice();

		TSTR DeviceName() {return GetString(IDS_RB_MIDI);}
		MCDeviceBinding *CreateBinding() {return new MidiDeviceBinding;}

		void MidiEvent(DWORD param);
		void Open();
		void Close();
		void Start();
		void Stop();

		void UtilityStarted(IMCapManager *im);
		void UtilityStopped(IMCapManager *im);

		int FirstKeyDown(int channel, int low, int high);
		int NewestKeyDown(int channel, int low, int high);
	};

//--- Class Descriptor -----------------------------------------------

// This is only here to support old files. Before the motion capture
// device interface was made plug-able the general REF_TARGET_CLASS_ID was used.
class MidiDeviceClassDescOld:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading) {return new MidiDeviceBinding;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_MIDI);}
	SClass_ID		SuperClassID() {return REF_TARGET_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(MIDI_DEVICE_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};
static MidiDeviceClassDescOld midiCDOld;
ClassDesc* GetMidiDeviceClassDescDescOld() {return &midiCDOld;}

class MidiDeviceClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading) {return new MidiDeviceBinding;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_MIDI);}
	SClass_ID		SuperClassID() {return MOT_CAP_DEVBINDING_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(MIDI_DEVICE_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};
static MidiDeviceClassDesc midiCD;
ClassDesc* GetMidiDeviceClassDescDesc() {return &midiCD;}

class TheMidiDeviceClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return GetMidiDevice();}
	const TCHAR *	ClassName() {return GetString(IDS_RB_MIDI);}
	SClass_ID		SuperClassID() {return MOT_CAP_DEV_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(MIDI_DEVICE_CLASS_ID,1);}
	const TCHAR* 	Category() {return _T("");}
	};
static TheMidiDeviceClassDesc theMidiCD;
ClassDesc* GetTheMidiDeviceClassDescDesc() {return &theMidiCD;}


//--- Midi device binding --------------------------------------------

static MidiDevice theMidiDevice;
static MCInputDevice *GetMidiDevice() {return &theMidiDevice;}


static BOOL CALLBACK MidiDeviceDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);


MidiDeviceBinding::MidiDeviceBinding()
	{	
	channel     = 0;
	trigger     = IDC_MIDI_NOTE;
	lowNote     = 0;
	highNote    = NUM_MIDI_NOTES-1;
	min         = 0.0f;
	max         = 1.0f;
	speed       = 10.0f * SPEED_UI_FACT;
	sustain     = 0;
	variSustain = TRUE;	
	controlNum  = 7;
	}

#define CHANNEL_CHUNK_ID		0x0100
#define TRIGGER_CHUNK_ID		0x0110
#define LOWNOTE_CHUNK_ID		0x0120
#define HIGHNOTE_CHUNK_ID		0x0130
#define MIN_CHUNK_ID			0x0140
#define MAX_CHUNK_ID			0x0150
#define SPEED_CHUNK_ID			0x0160
#define SUSTAIN_CHUNK_ID		0x0170
#define VARISUSTAIN_CHUNK_ID	0x0180
#define CONTROLNUM_CHUNK_ID		0x0190

IOResult MidiDeviceBinding::Save(ISave *isave)
	{
	ULONG nb;

	isave->BeginChunk(CHANNEL_CHUNK_ID);
	isave->Write(&channel,sizeof(channel),&nb);
	isave->EndChunk();

	isave->BeginChunk(TRIGGER_CHUNK_ID);
	isave->Write(&trigger,sizeof(trigger),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(LOWNOTE_CHUNK_ID);
	isave->Write(&lowNote,sizeof(lowNote),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(HIGHNOTE_CHUNK_ID);
	isave->Write(&highNote,sizeof(highNote),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(MIN_CHUNK_ID);
	isave->Write(&min,sizeof(min),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(MAX_CHUNK_ID);
	isave->Write(&max,sizeof(max),&nb);
	isave->EndChunk();

	isave->BeginChunk(SPEED_CHUNK_ID);
	isave->Write(&speed,sizeof(speed),&nb);
	isave->EndChunk();

	isave->BeginChunk(SUSTAIN_CHUNK_ID);
	isave->Write(&sustain,sizeof(sustain),&nb);
	isave->EndChunk();

	isave->BeginChunk(VARISUSTAIN_CHUNK_ID);
	isave->Write(&variSustain,sizeof(variSustain),&nb);
	isave->EndChunk();

	isave->BeginChunk(CONTROLNUM_CHUNK_ID);
	isave->Write(&controlNum, sizeof(controlNum),&nb);
	isave->EndChunk();

	return IO_OK;
	}

IOResult MidiDeviceBinding::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case CHANNEL_CHUNK_ID:
				res=iload->Read(&channel,sizeof(channel),&nb);
				break;

			case TRIGGER_CHUNK_ID:
				res=iload->Read(&trigger,sizeof(trigger),&nb);
				break;

			case LOWNOTE_CHUNK_ID:
				res=iload->Read(&lowNote,sizeof(lowNote),&nb);
				break;

			case HIGHNOTE_CHUNK_ID:
				res=iload->Read(&highNote,sizeof(highNote),&nb);
				break;

			case MIN_CHUNK_ID:
				res=iload->Read(&min,sizeof(min),&nb);
				break;

			case MAX_CHUNK_ID:
				res=iload->Read(&max,sizeof(max),&nb);
				break;

			case SPEED_CHUNK_ID:
				res=iload->Read(&speed,sizeof(speed),&nb);
				break;

			case SUSTAIN_CHUNK_ID:
				res=iload->Read(&sustain,sizeof(sustain),&nb);
				break;

			case VARISUSTAIN_CHUNK_ID:
				res=iload->Read(&variSustain,sizeof(variSustain),&nb);
				break;

			case CONTROLNUM_CHUNK_ID:
				res=iload->Read(&controlNum,sizeof(controlNum),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	return IO_OK;
	}

RefTargetHandle MidiDeviceBinding::Clone(RemapDir& remap)
	{
	MidiDeviceBinding *b = new MidiDeviceBinding;
	b->channel     = channel;
	b->trigger     = trigger;
	b->lowNote     = lowNote;
	b->highNote    = highNote;
	b->sustain	   = sustain;
	b->variSustain = variSustain;
	b->min		   = min;
	b->max		   = max;
	b->speed	   = speed;
	b->curVal	   = curVal;
	return b;
	}

void MidiDeviceBinding::BeginActivate(BOOL reset)
	{	
	//theMidiDevice.Start();
	if (reset) curVal = 0.0f;
	}

void MidiDeviceBinding::Accumulate(TimeValue t)
	{
	switch (trigger) {
		case IDC_MIDI_NOTE: {
			float newVal;
			int note = theMidiDevice.NewestKeyDown(channel, lowNote, highNote);			
			if (note>=0) {
				float u  = MIDI_NOTEFLOAT(note,lowNote,highNote);
				float v  = MIDI_VELFLOAT(theMidiDevice.data[channel].vel[note]);
				float dv = v * speed * (float)fabs(max-min);
				newVal = min*(1.0f-u) + max*u;
				if (newVal<curVal) {
					curVal -= dv;
					if (curVal<newVal) curVal=newVal;
					}
				if (newVal>curVal) {
					curVal += dv;
					if (curVal>newVal) curVal=newVal;
					}				
				}
			break;
			}
		}
	}

float MidiDeviceBinding::Eval(TimeValue t)
	{
	assert(theMidiDevice.theMM);

	switch (trigger) {
		case IDC_MIDI_NOTE: {
			return curVal;			
			}

		case IDC_MIDI_USER: {			
			float u = MIDI_VELFLOAT(theMidiDevice.data[channel].vel[controlNum]);
			float target = min*(1.0f-u) + max*u;
			if (sustain>0) {
				float ss = variSustain ? float(sustain) * u : sustain;
				float t0 = float(theMidiDevice.data[channel].time[controlNum]);
				float t1 = float(theMidiDevice.theMM->GetTime());
				if (t1>t0+ss) target = min;
				else {
					float v = 2.0f * (t1-t0)/float(ss) - 1.0f;
					target = (1.0f-v*v) * target;
					}
				}
			return target;
			}

		case IDC_MIDI_VEL: {						
			int note = theMidiDevice.NewestKeyDown(channel, lowNote, highNote);			
			if (note>=0) {				
				float u = MIDI_VELFLOAT(theMidiDevice.data[channel].vel[note]);				
				float target = min*(1.0f-u) + max*u;
				if (sustain>0) {
					float ss = variSustain ? float(sustain) * u : sustain;
					float t0 = float(theMidiDevice.data[channel].time[note]);
					float t1 = float(theMidiDevice.theMM->GetTime());
					if (t1>t0+ss) target = min;
					else {
						float v = 2.0f * (t1-t0)/float(ss) - 1.0f;
						target = (1.0f-v*v) * target;
						}
					}
				return target;
			} else {
				return min;
				}
			}

		case IDC_MIDI_BEND: {
			float u = MIDI_BENDFLOAT(theMidiDevice.data[channel].bend);
			return min*(1.0f-u) + max*u;
			break;
			}
		}
	return 0.0f;
	}

void MidiDeviceBinding::EndActivate()
	{		
	//theMidiDevice.Stop();
	}


void MidiDeviceBinding::AddRollup(IMCParamDlg *dlg)
	{
	dlg->iRoll->AppendRollup(
			hInstance, 
			MAKEINTRESOURCE(IDD_MC_MIDI), 
			MidiDeviceDlgProc, 
			GetString(IDS_RB_MIDI), 
			(LPARAM)dlg);
	}

void MidiDeviceBinding::UpdateRollup(IRollupWindow *iRoll)
	{
	if (iRoll->GetNumPanels()>1) {
		HWND hWnd = iRoll->GetPanelDlg(1);
		SendDlgItemMessage(hWnd, IDC_MIDI_LOWNOTE,    CB_SETCURSEL, lowNote %12, 0);
		SendDlgItemMessage(hWnd, IDC_MIDI_HIGHNOTE,   CB_SETCURSEL, highNote%12, 0);
		SendDlgItemMessage(hWnd, IDC_MIDI_LOWOCTAVE,  CB_SETCURSEL, lowNote /12, 0);
		SendDlgItemMessage(hWnd, IDC_MIDI_HIGHOCTAVE, CB_SETCURSEL, highNote/12, 0);
		
		for (int i=0; i<16; i++) {
			CheckDlgButton(hWnd, IDC_MIDI_CHAN1+i, FALSE);
			}
		CheckDlgButton(hWnd, IDC_MIDI_CHAN1+channel, TRUE);

		CheckDlgButton(hWnd, trigger, TRUE);
		CheckDlgButton(hWnd, IDC_SUSTAIN_VARIABLE, variSustain);

		ISpinnerControl *spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_PARAMMINSPIN));
		spin->SetValue(min,FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_PARAMMAXSPIN));	
		spin->SetValue(max,FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_SPEEDSPIN));	
		spin->SetValue(speed/SPEED_UI_FACT,FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_SUSTAINSPIN));	
		spin->SetValue(sustain,FALSE);
		ReleaseISpinner(spin);

		SetEnabledStates(hWnd);
		}
	}

void MidiDeviceBinding::SetupNote(HWND hCombo)
	{
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("C"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("C#"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("D"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("D#"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("E"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("F"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("F#"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("G"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("G#"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("A"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("A#"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("B"));
	}

void MidiDeviceBinding::SetupOctave(HWND hCombo)
	{
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("-2"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("-1"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("0"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("1"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("2"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("3"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("4"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("5"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("6"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("7"));
	SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)_T("8"));	
	}

int MidiDeviceBinding::GetNoteVal(HWND hWnd, int idNote, int idOctave)
	{
	int note = SendDlgItemMessage(hWnd,idNote,CB_GETCURSEL,0,0);
	int octave = SendDlgItemMessage(hWnd,idOctave,CB_GETCURSEL,0,0);
	if (note<0) note = 0;
	if (octave<0) octave = 0;
	return octave * 12 + note;
	}

void MidiDeviceBinding::SetEnabledStates(HWND hWnd)
	{
	ISpinnerControl *speedSpin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_SPEEDSPIN));
	ISpinnerControl *sustSpin  = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_SUSTAINSPIN));	
	ISpinnerControl *contSpin  = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_USERNUMSPIN));	
	
	if (trigger==IDC_MIDI_NOTE || trigger==IDC_MIDI_BEND) {
		sustSpin->Disable();
		EnableWindow(GetDlgItem(hWnd, IDC_SUSTAIN_VARIABLE), FALSE);
	} else {
		sustSpin->Enable();
		EnableWindow(GetDlgItem(hWnd, IDC_SUSTAIN_VARIABLE), TRUE);
		}
	if (trigger==IDC_MIDI_VEL || trigger==IDC_MIDI_BEND || trigger==IDC_MIDI_USER) 
		 speedSpin->Disable();
	else speedSpin->Enable();
	
	if (trigger==IDC_MIDI_USER) {
		contSpin->Enable();
		EnableWindow(GetDlgItem(hWnd, IDC_MIDI_USERNUM_LABEL), TRUE);
	} else {
		contSpin->Disable();
		EnableWindow(GetDlgItem(hWnd, IDC_MIDI_USERNUM_LABEL), FALSE);
		}

	ReleaseISpinner(sustSpin);
	ReleaseISpinner(speedSpin);
	ReleaseISpinner(contSpin);

	if (trigger!=IDC_MIDI_BEND && trigger!=IDC_MIDI_USER) {
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL1), TRUE);
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL2), TRUE);
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL3), TRUE);
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL4), TRUE);
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL5), TRUE);
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL6), TRUE);
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL7), TRUE);
		EnableWindow(GetDlgItem(hWnd, IDC_MIDI_LOWNOTE), TRUE);
		EnableWindow(GetDlgItem(hWnd, IDC_MIDI_LOWOCTAVE), TRUE);
		EnableWindow(GetDlgItem(hWnd, IDC_MIDI_HIGHNOTE), TRUE);
		EnableWindow(GetDlgItem(hWnd, IDC_MIDI_HIGHOCTAVE), TRUE);
	} else {
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL1), FALSE);
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL2), FALSE);
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL3), FALSE);
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL4), FALSE);
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL5), FALSE);
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL6), FALSE);
		EnableWindow(GetDlgItem(hWnd, IDC_NOTERANGE_LABEL7), FALSE);
		EnableWindow(GetDlgItem(hWnd, IDC_MIDI_LOWNOTE), FALSE);
		EnableWindow(GetDlgItem(hWnd, IDC_MIDI_LOWOCTAVE), FALSE);
		EnableWindow(GetDlgItem(hWnd, IDC_MIDI_HIGHNOTE), FALSE);
		EnableWindow(GetDlgItem(hWnd, IDC_MIDI_HIGHOCTAVE), FALSE);
		}
	}

void MidiDeviceBinding::InitDlg(HWND hWnd)
	{
	ISpinnerControl *spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_PARAMMINSPIN));
	spin->SetLimits(-float(999999), float(999999), FALSE);
	spin->SetAutoScale();
	spin->LinkToEdit(GetDlgItem(hWnd,IDC_MIDI_PARAMMIN), EDITTYPE_FLOAT);
	spin->SetValue(min,FALSE);
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_PARAMMAXSPIN));
	spin->SetLimits(-float(999999), float(999999), FALSE);
	spin->SetAutoScale();
	spin->LinkToEdit(GetDlgItem(hWnd,IDC_MIDI_PARAMMAX), EDITTYPE_FLOAT);
	spin->SetValue(max,FALSE);
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_SPEEDSPIN));
	spin->SetLimits(0.0f, float(100.0f), FALSE);
	spin->SetAutoScale();
	spin->LinkToEdit(GetDlgItem(hWnd,IDC_MIDI_SPEED), EDITTYPE_FLOAT);
	spin->SetValue(speed/SPEED_UI_FACT,FALSE);
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_SUSTAINSPIN));
	spin->SetLimits(0, TIME_PosInfinity, FALSE);
	spin->SetScale(10.0f);
	spin->LinkToEdit(GetDlgItem(hWnd,IDC_MIDI_SUSTAIN), EDITTYPE_TIME);
	spin->SetValue(sustain,FALSE);
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_USERNUMSPIN));
	spin->SetLimits(0, 127, FALSE);
	spin->SetScale(1.0f);
	spin->LinkToEdit(GetDlgItem(hWnd,IDC_MIDI_USERNUM), EDITTYPE_INT);
	spin->SetValue(controlNum,FALSE);
	ReleaseISpinner(spin);

	SetupNote(GetDlgItem(hWnd,IDC_MIDI_LOWNOTE));
	SetupNote(GetDlgItem(hWnd,IDC_MIDI_HIGHNOTE));
	SetupOctave(GetDlgItem(hWnd,IDC_MIDI_LOWOCTAVE));
	SetupOctave(GetDlgItem(hWnd,IDC_MIDI_HIGHOCTAVE));	
	}


static BOOL CALLBACK MidiDeviceDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	IMCParamDlg *dlg = (IMCParamDlg*)GetWindowLong(hWnd,GWL_USERDATA);
	MidiDeviceBinding *b = NULL;
	if (!dlg && msg!=WM_INITDIALOG) return FALSE;
	if (dlg) b = (MidiDeviceBinding*)dlg->binding;

	switch (msg) {
		case WM_INITDIALOG:
			dlg = (IMCParamDlg*)lParam;
			((MidiDeviceBinding*)dlg->binding)->InitDlg(hWnd);			
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_MIDI_VIEWER:
					MIDIViewerDialog(hWnd);
					break;

				case IDC_MIDI_CHAN1: case IDC_MIDI_CHAN9:
				case IDC_MIDI_CHAN2: case IDC_MIDI_CHAN10:
				case IDC_MIDI_CHAN3: case IDC_MIDI_CHAN11:
				case IDC_MIDI_CHAN4: case IDC_MIDI_CHAN12:
				case IDC_MIDI_CHAN5: case IDC_MIDI_CHAN13:
				case IDC_MIDI_CHAN6: case IDC_MIDI_CHAN14:
				case IDC_MIDI_CHAN7: case IDC_MIDI_CHAN15:
				case IDC_MIDI_CHAN8: case IDC_MIDI_CHAN16:
					b->SetChannel(LOWORD(wParam)-IDC_MIDI_CHAN1);
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;

				case IDC_MIDI_USER:
				case IDC_MIDI_NOTE:
				case IDC_MIDI_VEL:
				case IDC_MIDI_BEND:
					b->SetTrigger(LOWORD(wParam));
					b->SetEnabledStates(hWnd);
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;

				case IDC_MIDI_LOWNOTE:
				case IDC_MIDI_LOWOCTAVE:
					if (HIWORD(wParam)==CBN_SELCHANGE) {
						b->SetLowNote(
							b->GetNoteVal(hWnd,IDC_MIDI_LOWNOTE,IDC_MIDI_LOWOCTAVE));
						b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
						}
					break;

				case IDC_MIDI_HIGHNOTE:
				case IDC_MIDI_HIGHOCTAVE:
					if (HIWORD(wParam)==CBN_SELCHANGE) {
						b->SetHighNote(
							b->GetNoteVal(hWnd,IDC_MIDI_HIGHNOTE,IDC_MIDI_HIGHOCTAVE));
						b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
						}
					break;

				case IDC_SUSTAIN_VARIABLE:
					b->SetVariSustain(
						IsDlgButtonChecked(hWnd,IDC_SUSTAIN_VARIABLE));
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					break;
				}
			break;		

		case CC_SPINNER_CHANGE: {
			ISpinnerControl *spin = (ISpinnerControl *)lParam;			
			switch (LOWORD(wParam)) {
				case IDC_MIDI_PARAMMINSPIN: b->SetMin(spin->GetFVal()); break;
				case IDC_MIDI_PARAMMAXSPIN: b->SetMax(spin->GetFVal()); break;
				case IDC_MIDI_SPEEDSPIN:    b->SetSpeed(spin->GetFVal()*SPEED_UI_FACT); break;
				case IDC_MIDI_SUSTAINSPIN:  b->SetSustain(spin->GetIVal()); break;
				case IDC_MIDI_USERNUMSPIN:  b->SetControlNum(spin->GetIVal()); break;
				}
			b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
			break;
			}

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:   			
   			dlg->iRoll->DlgMouseMessage(hWnd,msg,wParam,lParam);
			break; 

		default:
			return FALSE;
		}
	return TRUE;
	}



//--- Midi device ----------------------------------------------------


ChannelData::ChannelData()
	{
	for (int i=0; i<NUM_MIDI_NOTES; i++) {
		pressed[i] = FALSE;
		time[i]    = TIME_NegInfinity;
		vel[i]     = 0;
		}
	bend = 0;
	}

static DWORD MidiInFunc(
		HMIDIIN hMidi, UINT msg, DWORD Instance, 
		DWORD param1, DWORD param2)
	{
	switch (msg) {
		case MIM_DATA:
			theMidiDevice.MidiEvent(param1);
			break;
		}

	return 0;
	}

MidiDevice::MidiDevice()
	{		
	//hMidiIn = NULL;
	active   = FALSE;	
	theMM    = NULL;
	noDevice = FALSE;
	}

void MidiDevice::Open()
	{
	int res = MIDIMan_Open(MidiInFunc,0,20);
	if (!noDevice && res!=MMSYSERR_NOERROR) {
		TSTR buf1 = GetString(IDS_RB_NODEVICE);
		TSTR buf2 = GetString(IDS_RB_MIDI);
		MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);
		noDevice = TRUE;
		}
#if 0
	if (!hMidiIn) {
		if (midiInGetNumDevs()) {
			res = midiInOpen(&hMidiIn, 0,(DWORD)MidiInFunc, 0,CALLBACK_FUNCTION);
			if (res!=MMSYSERR_NOERROR) {
				TSTR buf1 = GetString(IDS_RB_NODEVICE);
				TSTR buf2 = GetString(IDS_RB_MIDI);
				MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);
				}			
			}
		}
#endif
	}

void MidiDevice::Close()
	{
	int res = MIDIMan_Close(MidiInFunc,0);
	if (!noDevice && res!=MMSYSERR_NOERROR) {
		TSTR buf1 = GetString(IDS_RB_MIDIDEVICE_ERROR);
		TSTR buf2 = GetString(IDS_RB_MIDI);
		MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);
		}
#if 0
	if (hMidiIn) {
		res = midiInClose(hMidiIn);
		hMidiIn = NULL;
		if (res!=MMSYSERR_NOERROR) {
			TSTR buf1 = GetString(IDS_RB_MIDIDEVICE_ERROR);
			TSTR buf2 = GetString(IDS_RB_MIDI);
			MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK);
			}
		}
#endif
	}

void MidiDevice::Start()
	{
	if (!active && MIDIMan_IsOpened()) {
		if (MIDIMan_Start() != MMSYSERR_NOERROR) {
			TSTR buf1 = GetString(IDS_RB_MIDIDEVICE_ERROR);
			TSTR buf2 = GetString(IDS_RB_MIDI);
			MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);
			return;
			}
		active = TRUE;
		}
#if 0
	if (!active && hMidiIn) {		
		if (midiInStart(hMidiIn) != MMSYSERR_NOERROR) {
			TSTR buf1 = GetString(IDS_RB_MIDIDEVICE_ERROR);
			TSTR buf2 = GetString(IDS_RB_MIDI);
			MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);			
			return;
			}
		active = TRUE;
		}
#endif
	
	// Clear the keyboard.
	for (int i=0; i<NUM_MIDI_CHANNELS; i++) {
		data[i] = ChannelData();
		}
	}

void MidiDevice::Stop()
	{
	if (active && MIDIMan_IsOpened()) {
		if (MIDIMan_Stop() != MMSYSERR_NOERROR) {
			TSTR buf1 = GetString(IDS_RB_MIDIDEVICE_ERROR);
			TSTR buf2 = GetString(IDS_RB_MIDI);
			MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);
			return;
			}
		active = FALSE;
		}
#if 0
	if (active && hMidiIn) {
		if (midiInStop(hMidiIn) != MMSYSERR_NOERROR) {
			TSTR buf1 = GetString(IDS_RB_MIDIDEVICE_ERROR);
			TSTR buf2 = GetString(IDS_RB_MIDI);
			MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);
			return;
			}
		active = FALSE;
		}
#endif
	}

void MidiDevice::UtilityStarted(IMCapManager *im) 
	{
	Open();
	Start();
	theMM = im;
	}

void MidiDevice::UtilityStopped(IMCapManager *im) 
	{
	Stop();
	Close();
	theMM = NULL;
	}

void MidiDevice::MidiEvent(DWORD param)
	{
	assert(theMM);
	int channel = MIDI_CHANNEL(param);
	int event = MIDI_EVENT(param);
	int vel = MIDI_VELOCITY(param);
	int nn  = MIDI_NOTENUMBER(param);

	switch (event) {		
		case MIDI_NOTE_ON: {			
			data[channel].pressed[nn] = TRUE;
			data[channel].time[nn]    = theMM->GetTime();
			if (vel) data[channel].vel[nn] = vel;
			theMM->MidiNote(channel, nn);
			break;
			}

		case MIDI_NOTE_OFF: {			
			data[channel].pressed[nn] = FALSE;
			data[channel].time[nn]    = TIME_NegInfinity;
			data[channel].vel    [nn] = 0;
			break;
			}

		case MIDI_PITCH_BEND: {
			int pb = MIDI_PITCHBEND(param);
			data[channel].bend = pb;
			break;
			}
		
		case MIDI_CONTROLCHANGE:
			data[channel].pressed[nn] = TRUE;
			data[channel].time[nn]    = theMM->GetTime();
			data[channel].vel[nn] = vel;
			break;		
		}
	}

int MidiDevice::FirstKeyDown(int channel, int low, int high)
	{
	for (int i=low; i<=high; i++) {
		if (data[channel].pressed[i]) return i;
		}
	return -1;
	}

int MidiDevice::NewestKeyDown(int channel, int low, int high)
	{
	int res = -1;
	TimeValue t = TIME_NegInfinity;
	for (int i=low; i<=high; i++) {
		if (data[channel].pressed[i] && 
			data[channel].time[i] > t) {
			res = i;
			t   = data[channel].time[i];
			}
		}
	return res;
	}


//------------------------------------------------------------
// MIDI Viewer Dialog

static int chanButs[] = {
	IDC_MV_CHANBUT1,IDC_MV_CHANBUT2,IDC_MV_CHANBUT3,IDC_MV_CHANBUT4,
	IDC_MV_CHANBUT5,IDC_MV_CHANBUT6,IDC_MV_CHANBUT7,IDC_MV_CHANBUT8,
	IDC_MV_CHANBUT9,IDC_MV_CHANBUT10,IDC_MV_CHANBUT11,IDC_MV_CHANBUT12,
	IDC_MV_CHANBUT13,IDC_MV_CHANBUT14,IDC_MV_CHANBUT15,IDC_MV_CHANBUT16};

static int chanProg[] = {
	IDC_MV_CHANPROG1,IDC_MV_CHANPROG2,IDC_MV_CHANPROG3,IDC_MV_CHANPROG4,
	IDC_MV_CHANPROG5,IDC_MV_CHANPROG6,IDC_MV_CHANPROG7,IDC_MV_CHANPROG8,
	IDC_MV_CHANPROG9,IDC_MV_CHANPROG10,IDC_MV_CHANPROG11,IDC_MV_CHANPROG12,
	IDC_MV_CHANPROG13,IDC_MV_CHANPROG14,IDC_MV_CHANPROG15,IDC_MV_CHANPROG16};

static int octaves[] = {
	IDC_MV_OCTAVEBUT1,IDC_MV_OCTAVEBUT2,IDC_MV_OCTAVEBUT3,
	IDC_MV_OCTAVEBUT4,IDC_MV_OCTAVEBUT5,IDC_MV_OCTAVEBUT6,
	IDC_MV_OCTAVEBUT7,IDC_MV_OCTAVEBUT8,IDC_MV_OCTAVEBUT9,
	IDC_MV_OCTAVEBUT10,IDC_MV_OCTAVEBUT11};

static int notes[] = {
	IDC_MV_NOTEPROG1, IDC_MV_NOTEPROG2, IDC_MV_NOTEPROG3,
	IDC_MV_NOTEPROG4, IDC_MV_NOTEPROG5, IDC_MV_NOTEPROG6,
	IDC_MV_NOTEPROG7, IDC_MV_NOTEPROG8, IDC_MV_NOTEPROG9,
	IDC_MV_NOTEPROG10,IDC_MV_NOTEPROG11,IDC_MV_NOTEPROG12};

static HWND hMIDIViewer=NULL;
//static HMIDIIN hMidiIn=NULL;
static int channel=0, octave=0;	

static int channelVars[16];
static int noteVars[12];
static int controllerVar=0;
static int controlNum = 7;

static void ClearChannelVars() {
	for (int i=0; i<16; i++) channelVars[i] = 0;
	}

static void ClearNoteVars() {
	for (int i=0; i<12; i++) noteVars[i] = 0;	
	}

static BOOL CALLBACK MidiViewerDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG: {
			CheckDlgButton(hWnd,chanButs[channel],TRUE);
			CheckDlgButton(hWnd,octaves[octave],TRUE);
			hMIDIViewer = hWnd;
			ClearChannelVars();
			ClearNoteVars();
			for (int i=0; i<12; i++) {
				SendDlgItemMessage(hWnd,notes[i],
					PBM_SETRANGE,0,MAKELPARAM(0,127));
				}
			SendDlgItemMessage(hWnd,IDC_MV_NOTEUSER,
					PBM_SETRANGE,0,MAKELPARAM(0,127));
			SetTimer(hWnd,1,100,NULL);

			ISpinnerControl *spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_USERNUMSPIN));
			spin->SetLimits(0, 127, FALSE);
			spin->SetScale(1.0f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_MIDI_USERNUM), EDITTYPE_INT);
			spin->SetValue(controlNum,FALSE);
			ReleaseISpinner(spin);

			break;
			}
		
		case WM_TIMER: {
			for (int i=0; i<16; i++) {
				SendDlgItemMessage(hWnd,chanProg[i],
					PBM_SETPOS,channelVars[i],0);
				channelVars[i] -= 20;
				if (channelVars[i]<0) channelVars[i] = 0;
				}
			for (i=0; i<12; i++) {
				SendDlgItemMessage(hWnd,notes[i],
					PBM_SETPOS,noteVars[i],0);
				noteVars[i] -= 10;
				if (noteVars[i]<0) noteVars[i] = 0;
				}
			
			SendDlgItemMessage(hWnd,IDC_MV_NOTEUSER,
					PBM_SETPOS,controllerVar,0);
			//controllerVar -= 10;
			//if (controllerVar<0) controllerVar = 0;
			break;
			}


		case WM_DESTROY:
			hMIDIViewer = NULL;
			KillTimer(hWnd,1);
			break;

		case CC_SPINNER_CHANGE: {
			ISpinnerControl *iSpin = (ISpinnerControl*)lParam;
			controlNum = iSpin->GetIVal();
			controllerVar = 0;
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_MV_CHANBUT1:  channel = 0; ClearNoteVars(); break;
				case IDC_MV_CHANBUT2:  channel = 1; ClearNoteVars(); break;
				case IDC_MV_CHANBUT3:  channel = 2; ClearNoteVars(); break;
				case IDC_MV_CHANBUT4:  channel = 3; ClearNoteVars(); break;
				case IDC_MV_CHANBUT5:  channel = 4; ClearNoteVars(); break;
				case IDC_MV_CHANBUT6:  channel = 5; ClearNoteVars(); break;
				case IDC_MV_CHANBUT7:  channel = 6; ClearNoteVars(); break;
				case IDC_MV_CHANBUT8:  channel = 7; ClearNoteVars(); break;
				case IDC_MV_CHANBUT9:  channel = 8; ClearNoteVars(); break;
				case IDC_MV_CHANBUT10: channel = 9; ClearNoteVars(); break;
				case IDC_MV_CHANBUT11: channel = 10; ClearNoteVars(); break;
				case IDC_MV_CHANBUT12: channel = 11; ClearNoteVars(); break;
				case IDC_MV_CHANBUT13: channel = 12; ClearNoteVars(); break;
				case IDC_MV_CHANBUT14: channel = 13; ClearNoteVars(); break;
				case IDC_MV_CHANBUT15: channel = 14; ClearNoteVars(); break;
				case IDC_MV_CHANBUT16: channel = 15; ClearNoteVars(); break;		

				case IDC_MV_OCTAVEBUT1:  octave = 0; break;
				case IDC_MV_OCTAVEBUT2:  octave = 1; break;
				case IDC_MV_OCTAVEBUT3:  octave = 2; break;
				case IDC_MV_OCTAVEBUT4:  octave = 3; break;
				case IDC_MV_OCTAVEBUT5:  octave = 4; break;
				case IDC_MV_OCTAVEBUT6:  octave = 5; break;
				case IDC_MV_OCTAVEBUT7:  octave = 6; break;
				case IDC_MV_OCTAVEBUT8:  octave = 7; break;
				case IDC_MV_OCTAVEBUT9:  octave = 8; break;
				case IDC_MV_OCTAVEBUT10: octave = 9; break;
				case IDC_MV_OCTAVEBUT11: octave = 10; break;

				case IDCANCEL:
				case IDOK:
					EndDialog(hWnd,1);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

static DWORD MidiViewerInFunc(
		HMIDIIN hMidi, UINT msg, DWORD Instance, 
		DWORD param1, DWORD param2)
	{
	switch (msg) {
		case MIM_DATA: {
			int ch = MIDI_CHANNEL(param1);
			int nn = MIDI_NOTENUMBER(param1);			
			int event = MIDI_EVENT(param1);
			int vel = MIDI_VELOCITY(param1);			

			channelVars[ch] = 100;
			
			SetDlgItemInt(hMIDIViewer,IDC_MV_CHAN,ch+1,TRUE);
			SetDlgItemInt(hMIDIViewer,IDC_MV_EVENT,event>>4,TRUE);
			SetDlgItemInt(hMIDIViewer,IDC_MV_VEL,vel,TRUE);
			SetDlgItemInt(hMIDIViewer,IDC_MV_NOTE,nn,TRUE);

			switch (event) {
				case MIDI_CONTROLCHANGE:
					if (controlNum==nn && ch==channel) {
						controllerVar = vel;
						}
					break;

				case MIDI_NOTE_ON: {
					int vel = MIDI_VELOCITY(param1);
					if (nn/12==octave && ch==channel) {
						noteVars[nn%12] = vel;
						}
					break;
					}

				case MIDI_NOTE_OFF: {
					if (nn/12==octave && ch==channel) {
						noteVars[nn%12] = 0;
						}
					break;
					}
				}
			break;
			}
		}

	return 0;
	}


static void MIDIViewerDialog(HWND hParent)
	{
	int res = MMSYSERR_NOERROR;	

	if (hMIDIViewer) {
		SetForegroundWindow(hMIDIViewer);
		return;
		}

	res = MIDIMan_Open(MidiViewerInFunc,0);
	if (res != MMSYSERR_NOERROR) {
		TSTR buf1 = GetString(IDS_RB_NODEVICE);
		TSTR buf2 = GetString(IDS_RB_MIDI);
		MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);
		return;
		}

	res = MIDIMan_Start();
	if (res != MMSYSERR_NOERROR) {
		TSTR buf1 = GetString(IDS_RB_MIDIDEVICE_ERROR);
		TSTR buf2 = GetString(IDS_RB_MIDI);
		MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);
		return;
		}	

	DialogBox(
		hInstance,
		MAKEINTRESOURCE(IDD_MIDI_VIEWER),
		hParent,
		MidiViewerDlgProc);

	MIDIMan_Stop();
	res = MIDIMan_Close(MidiViewerInFunc,0);
	if (res != MMSYSERR_NOERROR) {
		TSTR buf1 = GetString(IDS_RB_MIDIDEVICE_ERROR);
		TSTR buf2 = GetString(IDS_RB_MIDI);
		MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);
		}	
#if 0
	BOOL opened = FALSE;
	if (theMidiDevice.hMidiIn) {
		opened = TRUE;
		theMidiDevice.Stop();
		theMidiDevice.Close();
		}

	if (!midiInGetNumDevs()) {
		TSTR buf1 = GetString(IDS_RB_NOMIDIDEVICES);
		TSTR buf2 = GetString(IDS_RB_MIDIVIEWER);
		MessageBox(hParent,buf1,buf2,MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);
		goto done;
		}

	if (!hMidiIn) {
		res = midiInOpen(&hMidiIn, 0,(DWORD)MidiViewerInFunc, 0,
			CALLBACK_FUNCTION);
		}
	if (res!=MMSYSERR_NOERROR) {
		TSTR buf1 = GetString(IDS_RB_NODEVICE);
		TSTR buf2 = GetString(IDS_RB_MIDI);
		MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);
		goto done;
		}
	
	if (midiInStart(hMidiIn) != MMSYSERR_NOERROR) {
		TSTR buf1 = GetString(IDS_RB_MIDIDEVICE_ERROR);
		TSTR buf2 = GetString(IDS_RB_MIDI);
		MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);
		goto done;
		}	
	
	DialogBox(
		hInstance,
		MAKEINTRESOURCE(IDD_MIDI_VIEWER),
		hParent,
		MidiViewerDlgProc);

	if (midiInStop(hMidiIn) != MMSYSERR_NOERROR) {
		TSTR buf1 = GetString(IDS_RB_MIDIDEVICE_ERROR);
		TSTR buf2 = GetString(IDS_RB_MIDI);
		MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);
		}

	if (midiInClose(hMidiIn) != MMSYSERR_NOERROR) {
		TSTR buf1 = GetString(IDS_RB_MIDIDEVICE_ERROR);
		TSTR buf2 = GetString(IDS_RB_MIDI);
		MessageBox(GetCOREInterface()->GetMAXHWnd(), buf1, buf2, MB_ICONSTOP|MB_OK|MB_APPLMODAL);
		}	
	hMidiIn = NULL;

done:	
	if (opened) {		
		theMidiDevice.Open();
		theMidiDevice.Start();
		}
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\point3mc.cpp ===
/**********************************************************************
 *<
	FILE: point3MC.cpp

	DESCRIPTION: Point3 motion capture controller

	CREATED BY: Rolf Berteig

	HISTORY: October 30, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "motion.h"
#include "mmanager.h"


static Class_ID point3mcControlClassID(POINT3_MOTION_CLASS_ID,0); 

class Point3MC : public MCControl {
	public:
		MCDeviceBinding *bind[3];
		Point3 base;
		int sampleCount;
		Point3 *data;

		Point3MC();
		Class_ID ClassID() {return point3mcControlClassID;}  
		SClass_ID SuperClassID() {return CTRL_POINT3_CLASS_ID;} 
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_POINT3MC);}
		ParamDimension* GetParamDimension(int i) {return defaultDim;}
		RefTargetHandle Clone(RemapDir& remap);

		int NumDeviceBindings() {return 3;}
		MCDeviceBinding *GetDeviceBinding(int i) {return bind[i];}
		void SetDeviceBinding(int i,MCDeviceBinding *b) {bind[i]=b;}
		void GetValueLive(TimeValue t,void *val, GetSetMethod method);
		void BeginCapture(Interval record,TimeValue sampSize);
		void EndCapture(Interval record,TimeValue sampSize, KeyReduceStatus *stat);
		void Capture(Interval record,TimeValue t,int sample);
		void BeginLive(TimeValue t);

		void EditTrackParams(
			TimeValue t, ParamDimensionBase *dim, TCHAR *pname, 
			HWND hParent, IObjParam *ip, DWORD flags);
	};


//--- Class Descriptor -----------------------------------------------

class Point3MCClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new Point3MC;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_POINT3MC);}
	SClass_ID		SuperClassID() {return CTRL_POINT3_CLASS_ID;}
	Class_ID		ClassID() {return point3mcControlClassID;}
	const TCHAR* 	Category() {return _T("");}
	};
static Point3MCClassDesc point3mcCD;
ClassDesc* GetPoint3MotionDesc() {return &point3mcCD;}


//--- Point3MC methods ----------------------------------------------

Point3MC::Point3MC()
	{
	ReplaceReference(0,CreateInterpPoint3());
	bind[0] = bind[1] = bind[2] = NULL;
	base = Point3(0,0,0);
	data = NULL;
	}

RefTargetHandle Point3MC::Clone(RemapDir& remap)
	{
	Point3MC *c = new Point3MC;
	c->MCControlClone(this,remap);
	return c;
	}

void Point3MC::EditTrackParams(
		TimeValue t, ParamDimensionBase *dim, TCHAR *pname, 
		HWND hParent, IObjParam *ip, DWORD flags)
	{
	GenMCParamDlg *dlg = new GenMCParamDlg(this,IDD_MC_POINT3);
	dlg->DoWindow(hParent, pname);
	}

void Point3MC::GetValueLive(TimeValue t,void *val, GetSetMethod method)
	{
	Point3 pt = base;
	for (int i=0; i<3; i++) if (bind[i]) pt[i] += bind[i]->Eval(t);
	if (method==CTRL_ABSOLUTE) {
		*((Point3*)val)  = pt;
	} else {
		*((Point3*)val) += pt;
		}
	}


void Point3MC::BeginCapture(Interval record,TimeValue sampSize)
	{
	// Set the base point to the controller value at the start time.
	cont->GetValue(record.Start(),&base,FOREVER,CTRL_ABSOLUTE);	

	// Allocate a data buffer
	sampleCount = record.Duration()/sampSize + 1;
	data = new Point3[sampleCount];
	for (int i=0; i<sampleCount; i++) data[i] = Point3(0,0,0);
	}

void Point3MC::Capture(Interval record,TimeValue t,int sample)
	{
	assert(sample>=0 && sample<sampleCount);	
	GetValueLive(t,&data[sample], CTRL_ABSOLUTE);	
	}
  
void Point3MC::EndCapture(Interval record,TimeValue sampSize, KeyReduceStatus *stat) 
	{		
	// Clear any keys out of the record interval
	cont->DeleteTime(record,TIME_INCLEFT|TIME_INCRIGHT|TIME_NOSLIDE);

	// Make keys out of the data
	SuspendAnimate();
	AnimateOn();	
	for (int i=0; i<sampleCount; i++) {
		TimeValue t = record.Start() + i * sampSize;
		cont->SetValue(t,&data[i],1,CTRL_ABSOLUTE);
		if (i%UPDATE_RATE==0) if (stat->Progress(i)!=KEYREDUCE_CONTINUE) goto abort;
		}	
abort:
	ResumeAnimate();
	delete[] data;
	base = Point3(0,0,0);
	}

void Point3MC::BeginLive(TimeValue t)
	{
	// Set the base point to the controller value at the start time.
	cont->GetValue(t,&base,FOREVER,CTRL_ABSOLUTE);	
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\motion.h ===
/**********************************************************************
 *<
	FILE: motion.h

	DESCRIPTION:

	CREATED BY: Rolf Berteig

	HISTORY:

 *>	Copyright (c) 1999, All Rights Reserved.
 **********************************************************************/

#ifndef __MOTION__H
#define __MOTION__H

#include "Max.h"
#include "utilapi.h"
#include "resource.h"


#define MOTION_MANAGER_CLASS_ID		0x76ef52a6

extern ClassDesc* GetPosMotionDesc();
extern ClassDesc* GetRotMotionDesc();
extern ClassDesc* GetScaleMotionDesc();
extern ClassDesc* GetFloatMotionDesc();
extern ClassDesc* GetPoint3MotionDesc();
extern ClassDesc* GetMotionManDesc();
extern ClassDesc* GetMouseDeviceClassDescDesc();
extern ClassDesc* GetMidiDeviceClassDescDesc();
extern ClassDesc* GetJoyDeviceClassDescDesc();
extern ClassDesc* GetMouseDeviceClassDescDescOld();
extern ClassDesc* GetMidiDeviceClassDescDescOld();
extern ClassDesc* GetJoyDeviceClassDescDescOld();
extern ClassDesc* GetTheJoyDeviceClassDescDesc();
extern ClassDesc* GetTheMouseDeviceClassDescDesc();
extern ClassDesc* GetTheMidiDeviceClassDescDesc();

TCHAR *GetString(int id);
extern HINSTANCE hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\mmanager.cpp ===
/**********************************************************************
 *<
	FILE: mmanager.cpp

	DESCRIPTION: Motion capture manager

	CREATED BY: Rolf Berteig

	HISTORY: October 30, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "motion.h"
#include "mmanager.h"
#include "notify.h"
#include "midiman.h"

//--- A command mode for capturing ----------------------------------

class CaptureCMode : 
			public CommandMode, 
			public ChangeForegroundCallback,
			public MouseCallBack {
	public:
		BOOL valid, recording;		
		CaptureCMode() {valid=FALSE; recording=FALSE;}

		// Command mode
		int Class() {return ANIMATION_COMMAND;}
		int ID() {return 0x8f623bb4;}
		MouseCallBack *MouseProc(int *numPoints) {*numPoints=1;return this;}
		ChangeForegroundCallback *ChangeFGProc() {return this;}
		BOOL ChangeFG(CommandMode *oldMode) {if (oldMode!=this) return TRUE; else return FALSE;}
		void EnterMode() {}
		void ExitMode() {}
		
		// Mouse proc
		int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m) {return TRUE;}

		// FG proc
		BOOL IsValid() {return valid;}
		void Invalidate() {valid=FALSE;}
		void Validate() {valid=TRUE;}
		void callback(TimeValue t,IScene *scene) {
			if (recording) scene->FlagFGAnimated(t);
			for (int i=0; i<theMM.cont.Count(); i++) {
				if (theMM.cont[i]->GetRecordState()) {
					theMM.cont[i]->FlagDependents(t);
					}
				}
			}
	};
CaptureCMode theCaptureMode;



//--- MCControl Base Class ------------------------------------------

MCControl::MCControl()
	{
	flags  = 0;
	cont   = NULL;
	selSet = -1;
	theMM.Register(this);	
	}

MCControl::~MCControl()
	{
	theMM.UnRegister(this);
	}

TSTR MCControl::SubAnimName(int i) 
	{
	if (trackName.length()) {
		TSTR buf = GetString(IDS_RB_DATA);
		buf = buf + TSTR(_T(" (")) + trackName + TSTR(_T(")"));
		return buf;
	} else {
		return GetString(IDS_RB_DATA);
		}
	}
	
RefTargetHandle MCControl::GetReference(int i) 
	{
	switch (i) {
		case 0:  return cont;
		default: return GetDeviceBinding(i-1);
		}
	}

void MCControl::SetReference(int i, RefTargetHandle rtarg) 
	{
	switch (i) {
		case 0:  cont = (Control*)rtarg; break;
		default: SetDeviceBinding(i-1,(MCDeviceBinding*)rtarg);
		}
	}

BOOL MCControl::AssignController(Animatable *control,int subAnim)
	{
	ReplaceReference(0,(RefTargetHandle)control);
	NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE,TREE_VIEW_CLASS_ID,FALSE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);	
	return TRUE;
	}

void MCControl::Copy(Control *from)
	{
	if (from->IsKeyable()) {
		ReplaceReference(0,from);
		}
	NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE,TREE_VIEW_CLASS_ID,FALSE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);	
	}

void MCControl::AddNewKey(TimeValue t,DWORD flags)
	{
	cont->AddNewKey(t,flags);
	}

int MCControl::NumKeys()
	{
	return cont->NumKeys();
	}

TimeValue MCControl::GetKeyTime(int index)
	{
	return cont->GetKeyTime(index);
	}

void MCControl::CopyKeysFromTime(
		TimeValue src,TimeValue dst,DWORD flags)
	{
	cont->CopyKeysFromTime(src,dst,flags);
	}

BOOL MCControl::IsKeyAtTime(TimeValue t,DWORD flags)
	{
	return cont->IsKeyAtTime(t,flags);
	}

BOOL MCControl::GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt)
	{
	return cont->GetNextKeyTime(t,flags,nt);
	}

void MCControl::DeleteKeyAtTime(TimeValue t)
	{
	cont->DeleteKeyAtTime(t);
	}

int MCControl::GetKeyTimes(Tab<TimeValue> &times,Interval range,DWORD flags)
	{
	return cont->GetKeyTimes(times,range,flags);
	}

int MCControl::GetKeySelState(BitArray &sel,Interval range,DWORD flags)
	{
	return cont->GetKeySelState(sel,range,flags);
	}

void MCControl::SelectKeys(TrackHitTab& sel, DWORD flags)
	{
	cont->SelectKeys(sel, flags);
	}

void MCControl::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	if (IsLiveOn() || IsRecordOn()) {
		GetValueLive(t,val,method);
		valid.SetInstant(t);
	} else {
		cont->GetValue(t,val,valid,method);
		}
	}

void MCControl::SetValue(
		TimeValue t, void *val, int commit, GetSetMethod method)
	{
	cont->SetValue(t,val,commit,method);
	}

void MCControl::CommitValue(TimeValue t)
	{
	cont->CommitValue(t);
	}

void MCControl::RestoreValue(TimeValue t)
	{
	cont->RestoreValue(t);
	}

void MCControl::EnumIKParams(IKEnumCallback &callback)
	{
	cont->EnumIKParams(callback);
	}

BOOL MCControl::CompDeriv(TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags)
	{
	return cont->CompDeriv(t,ptm,derivs,flags);
	}

float MCControl::IncIKParam(TimeValue t,int index,float delta)
	{
	return cont->IncIKParam(t,index,delta);
	}

void MCControl::ClearIKParam(Interval iv,int index)
	{
	cont->ClearIKParam(iv,index);
	}

void MCControl::EnableORTs(BOOL enable)
	{
	cont->EnableORTs(enable);
	}


void MCControl::BeginEditParams( 
		IObjParam *ip, ULONG flags,Animatable *prev)
	{}

void MCControl::EndEditParams( 
		IObjParam *ip, ULONG flags,Animatable *next)
	{}

void MCControl::MCControlClone(MCControl *src,RemapDir& remap)
	{
	ReplaceReference(0,remap.CloneRef(src->cont));
	for (int i=0; i<src->NumDeviceBindings(); i++) {
		MCDeviceBinding *b = src->GetDeviceBinding(i);
		if (b) {
			ReplaceReference(i+1,remap.CloneRef(b));
			}
		}
	}


void MCControl::LiveOn()    
	{
	flags |=  MCC_LIVE_ON;
	for (int i=0; i<NumDeviceBindings(); i++) {
		if (GetDeviceBinding(i)) GetDeviceBinding(i)->BeginActivate();
		}
	}

void MCControl::RecordOn(BOOL reset)  
	{
	flags |=  MCC_RECORD_ON;
	for (int i=0; i<NumDeviceBindings(); i++) {
		if (GetDeviceBinding(i)) GetDeviceBinding(i)->BeginActivate(reset);
		}
	}


void MCControl::RecordOff() 
	{
	flags &= ~MCC_RECORD_ON;
	for (int i=0; i<NumDeviceBindings(); i++) {
		if (GetDeviceBinding(i)) GetDeviceBinding(i)->EndActivate();
		}
	}

void MCControl::LiveOff()   
	{
	flags &= ~MCC_LIVE_ON;
	for (int i=0; i<NumDeviceBindings(); i++) {
		if (GetDeviceBinding(i)) GetDeviceBinding(i)->EndActivate();
		}
	}


#define FLAGS_CHUNK_ID				0x0100
#define SELSETINDEX_CHUNK_ID		0x0120
#define TRACKNAME_CHUNK_ID			0x0130

IOResult MCControl::Save(ISave *isave)
	{
	ULONG nb;	

	isave->BeginChunk(FLAGS_CHUNK_ID);
	isave->Write(&flags,sizeof(flags),&nb);
	isave->EndChunk();

	isave->BeginChunk(SELSETINDEX_CHUNK_ID);
	isave->Write(&selSet,sizeof(selSet),&nb);
	isave->EndChunk();

	isave->BeginChunk(TRACKNAME_CHUNK_ID);
	isave->WriteWString(trackName);
	isave->EndChunk();

	return IO_OK;
	}

IOResult MCControl::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case FLAGS_CHUNK_ID:
				res=iload->Read(&flags,sizeof(flags),&nb);
				break;

			case SELSETINDEX_CHUNK_ID:
				res=iload->Read(&selSet,sizeof(selSet),&nb);
				break;

			case TRACKNAME_CHUNK_ID: {
				TCHAR *ptr = NULL;
				res=iload->ReadWStringChunk(&ptr);
				trackName = TSTR(ptr);
				break;
				}
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
		
	return IO_OK;
	}


class InSceneDepProc : public DependentEnumProc {
	public:
		int ct;
		MCControl *me;
		InSceneDepProc(MCControl *m) {ct=0;me=m;}
		int proc(ReferenceMaker *rmaker) {	  
			if (rmaker!=me && rmaker->SuperClassID()!=0) {
				ct++;
				}
			return 0;
			}
	};

BOOL MCControl::ControllerInScene()
	{
	InSceneDepProc proc(this);
	EnumDependents(&proc);
	return proc.ct>0;
	}

void MCControl::RefDeleted()
	{
	if (!ControllerInScene()) theMM.UnRegister(this);
	}

RefResult MCControl::AutoDelete()
	{
	RefDeleted();
	return ReferenceTarget::AutoDelete();
	}

void MCControl::RefAdded(RefMakerHandle rm)
	{
	if (ControllerInScene() &&
		!theMM.IsRegistered(this)) 
		 theMM.Register(this);
	}

void MCControl::RefDeletedUndoRedo()
	{
	if (!ControllerInScene()) theMM.UnRegister(this);
	}

void MCControl::RefAddedUndoRedo(RefMakerHandle rm)
	{
	if (ControllerInScene() &&
		!theMM.IsRegistered(this)) 
		 theMM.Register(this);
	}

void MCControl::Accumulate(TimeValue t)
	{
	for (int i=0; i<NumDeviceBindings(); i++) {
		if (GetDeviceBinding(i)) GetDeviceBinding(i)->Accumulate(t);
		}
	}


//--- MotionManager Descriptor ----------------------------------------------------

MotionManager theMM;

class MotionManClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theMM;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_MOTIONMAN);}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(MOTION_MANAGER_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	BOOL			NeedsToSave() {return TRUE;}
	IOResult 		Save(ISave *isave) {return theMM.Save(isave);}
	IOResult 		Load(ILoad *iload) {return theMM.Load(iload);}
	};

static MotionManClassDesc motionManDesc;
ClassDesc* GetMotionManDesc() {return &motionManDesc;}


//--- MotionManager ----------------------------------------------------

static BOOL CALLBACK MotionManDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static void SubClassNamedSel(HWND hNameSel);

static DWORD MIDIInProc(
		HMIDIIN hMidiIn,
		UINT wMsg, DWORD dwInstance,
		DWORD dwParam1, DWORD dwParam2);

static StartStopParams ssPresets[] = {
	StartStopParams(STARTSTOP_MEDIACONTROLSTATION,IDS_RB_MEDIACONTROLSTATION,15,21,22,23)
	};
#define STARTSTOP_PRESETS	1

int StartStopParams::GetChannel() {
	if (presetType==STARTSTOP_CUSTOM) return channel;
	else return ssPresets[presetType-1].channel;
	}
int StartStopParams::GetStop() {
	if (presetType==STARTSTOP_CUSTOM) return stop;
	else return ssPresets[presetType-1].stop;
	}
int StartStopParams::GetPlay() {
	if (presetType==STARTSTOP_CUSTOM) return play;
	else return ssPresets[presetType-1].play;
	}
int StartStopParams::GetRecord() {
	if (presetType==STARTSTOP_CUSTOM) return record;
	else return ssPresets[presetType-1].record;
	}


static void NotifyReset(void *param, NotifyInfo *info)
	{	
	if (!info || info->intcode!=NOTIFY_SYSTEM_POST_RESET) return;
	for (int i=0; i<theMM.selSets.Count(); i++) {
		delete theMM.selSets[i];
		}
	theMM.selSets.Resize(0);
	}

MotionManager::MotionManager()
	{
	RegisterNotification(NotifyReset, NULL, NOTIFY_SYSTEM_POST_RESET);

	hTrackIcons = NULL;
	hButtonIcons = NULL;
	InitializeCriticalSection(&csect);	

	listBuilt = FALSE;
	live      = FALSE;
	recording = FALSE;

	pre = 0;
	in  = 0;
	out = 16000;

	reduce        = FALSE;
	doubleSample  = FALSE;
	reduceThresh  = 1.0f;
	livePreRoll   = FALSE;
	playWhileTest = FALSE;
		
	ssParams = StartStopParams(STARTSTOP_MEDIACONTROLSTATION,IDS_RB_MEDIACONTROLSTATION,15,21,22,23);
	startStopEnabled = FALSE;
	recDown          = FALSE;
	playDown         = FALSE;

	playSpeed = 1;
	}

MotionManager::~MotionManager()
	{
	UnRegisterNotification(NotifyReset, NULL);
	DeleteCriticalSection(&csect);
	ImageList_Destroy(hTrackIcons);
	for (int i=0; i<selSets.Count(); i++) {
		delete selSets[i];
		}
	}

void MotionManager::SetupDeviceList()
	{
	if (!listBuilt) {
		listBuilt = TRUE;
		SubClassList *sublist = GetCOREInterface()->GetDllDir().ClassDir().
			GetClassList(MOT_CAP_DEV_CLASS_ID);
		for (int i=0; i<sublist->Count(ACC_ALL); i++) {
			if (!(*sublist)[i].IsPublic()) continue;
			MCInputDevice *d = (MCInputDevice*)(*sublist)[i].CD()->Create();
			device.Append(1,&d);
			}
		}
	}

void MotionManager::InitUI()
	{
	if (!hTrackIcons) {
		hTrackIcons = ImageList_Create(10, 10, TRUE, 2, 0);
		HBITMAP hBitmap, hMask;
		hBitmap = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_MM_ICONS));
		hMask   = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_MM_ICONSMASK));
		ImageList_Add(hTrackIcons,hBitmap,hMask);
		DeleteObject(hBitmap);
		DeleteObject(hMask);

		hButtonIcons = ImageList_Create(16, 16, TRUE, 1, 0);		
		hBitmap = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_BUTTONS));
		hMask   = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_BUTTONS_MASK));
		ImageList_Add(hButtonIcons,hBitmap,hMask);
		DeleteObject(hBitmap);
		DeleteObject(hMask);
		}
	}

BOOL MotionManager::IsRegistered(MCControl *c)
	{
	for (int i=0; i<cont.Count(); i++) {
		if (cont[i]==c) return TRUE;
		}
	return FALSE;
	}

void MotionManager::Register(MCControl *c)
	{
	cont.Append(1,&c);
	if (hPanel) SetupList();
	}

void MotionManager::UnRegister(MCControl *c)
	{
	for (int i=0; i<cont.Count(); i++) {
		if (cont[i]==c) {
			cont.Delete(i,1);
			break;
			}
		}
	if (hPanel) SetupList();
	}


class FindSubName : public DependentEnumProc {
	public:		
		Animatable *anim;
		TSTR name;
		FindSubName(Animatable *a) {anim=a;}
		int proc(ReferenceMaker *rmaker) {
			for (int i=0; i<rmaker->NumSubs(); i++) {
				if (rmaker->SubAnim(i)==anim) {
					name = rmaker->SubAnimName(i);
					return 1;
					}
				}
			return 0;
			}
	};

class FindParentName : public DependentEnumProc {
	public:				
		TSTR name;	
		ReferenceMaker *me;
		FindParentName(ReferenceMaker *r) {me=r;}
		int proc(ReferenceMaker *rmaker) {
			switch (rmaker->SuperClassID()) {
				case MATERIAL_CLASS_ID:
				case TEXMAP_CLASS_ID:
				case SOUNDOBJ_CLASS_ID:
				case ATMOSPHERIC_CLASS_ID:
					rmaker->GetClassName(name);
					return 1;

				default:
					if (rmaker!=me) {
						FindParentName fpn(rmaker);
						rmaker->EnumDependents(&fpn);
						if (fpn.name.Length()) {
							name = fpn.name;
							return 1;
							}
						}
					break;

				}
			return 0;
			}
	};

TSTR MotionManager::ControlName(MCControl *c)
	{
	if (c->trackName.length()) {
		return c->trackName;
		}

	TSTR parent, name;
	FindSubName fsn(c);
	
	// Try to find some names
	c->NotifyDependents(FOREVER,(PartID)&parent,REFMSG_GET_NODE_NAME);
	c->EnumDependents(&fsn);
	
	// Not within a node... look for a material or something
	if (!parent.Length()) {
		FindParentName fpn(c);
		c->EnumDependents(&fpn);
		parent = fpn.name;
		}

	if (parent.Length() && fsn.name.Length()) {
		name = parent + TSTR(_T("\\")) + fsn.name;
	} else if (parent.Length()) {
		name = parent;
	} else if (fsn.name.Length()) {
		name = fsn.name;
	} else {
		c->GetClassName(name);
		}

	return name;
	}

TSTR MotionManager::ControlName(int index)
	{
	if (index<0 || index>=cont.Count()) return _T("");
	else return ControlName(cont[index]);
	}

void MotionManager::ToggleRecordMode(int index)
	{
	if (index>=0 && index<cont.Count()) {
		cont[index]->SetRecordState(!cont[index]->GetRecordState());
		}
	}


void MotionManager::BeginEditParams(
		Interface *ip,IUtil *iu)
	{	
	ssParams.channel    = GetMotionCaptureINISetting(MCAP_INI_CHANNEL);
	ssParams.presetType = GetMotionCaptureINISetting(MCAP_INI_PRESET);
	ssParams.stop       = GetMotionCaptureINISetting(MCAP_INI_STOP);
	ssParams.play       = GetMotionCaptureINISetting(MCAP_INI_PLAY);
	ssParams.record     = GetMotionCaptureINISetting(MCAP_INI_RECORD);
	startStopEnabled    = GetMotionCaptureINISetting(MCAP_INI_SSENABLE);

	this->ip = ip;
	this->iu = iu;
	SetupDeviceList();
	for (int i=0; i<device.Count(); i++) {
		device[i]->UtilityStarted(this);
		}
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_MANAGER_PARAMS),
		MotionManDlgProc,
		GetString(IDS_RB_MOTIONMAN),
		0);		

	if (startStopEnabled) {
		MIDIMan_Open(MIDIInProc,0,10);
		MIDIMan_Start();
		}
	}
	
void MotionManager::EndEditParams(
		Interface *ip,IUtil *iu)
	{
	if (startStopEnabled) {
		MIDIMan_Stop();
		MIDIMan_Close(MIDIInProc,0);
		}

	for (int i=0; i<device.Count(); i++) {
		device[i]->UtilityStopped(this);
		}
	this->ip = NULL;
	this->iu = NULL;	
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
	}


void MotionManager::SetupList()
	{
	TSTR max;

	SendDlgItemMessage(hPanel,IDC_MM_TRACKS,LB_RESETCONTENT,0,0);

	for (int i=0; i<cont.Count(); i++) {
		TSTR name = ControlName(cont[i]);
		SendDlgItemMessage(
			hPanel,IDC_MM_TRACKS,LB_ADDSTRING,0,(LPARAM)(TCHAR*)name);
		if (name.Length()>max.Length()) max = name;
		}
		
	HWND hCont = GetDlgItem(hPanel,IDC_MM_TRACKS);
	HDC hdc = GetDC(hCont);
	SIZE size;
	GetTextExtentPoint(hdc,max,max.Length(),&size);
	SendDlgItemMessage(hPanel,IDC_MM_TRACKS,LB_SETHORIZONTALEXTENT,size.cx+12,0);
	ReleaseDC(hCont,hdc);			
	}

void MotionManager::Init(HWND hWnd)
	{
	InitUI();
	hPanel = hWnd;
		
	ISpinnerControl *spin = 
		GetISpinner(GetDlgItem(hPanel,IDC_MM_PREROLLSPIN));
	spin->SetLimits(TIME_NegInfinity, TIME_PosInfinity, FALSE);
	spin->SetScale(10.0f);
	spin->LinkToEdit(GetDlgItem(hPanel,IDC_MM_PREROLL), EDITTYPE_TIME);
	spin->SetValue(pre,FALSE);
	ReleaseISpinner(spin);
	
	spin = GetISpinner(GetDlgItem(hPanel,IDC_MM_INSPIN));
	spin->SetLimits(TIME_NegInfinity, TIME_PosInfinity, FALSE);
	spin->SetScale(10.0f);
	spin->LinkToEdit(GetDlgItem(hPanel,IDC_MM_IN), EDITTYPE_TIME);
	spin->SetValue(in,FALSE);
	ReleaseISpinner(spin);
	
	spin = GetISpinner(GetDlgItem(hPanel,IDC_MM_OUTSPIN));
	spin->SetLimits(TIME_NegInfinity, TIME_PosInfinity, FALSE);
	spin->SetScale(10.0f);
	spin->LinkToEdit(GetDlgItem(hPanel,IDC_MM_OUT), EDITTYPE_TIME);
	spin->SetValue(out,FALSE);
	ReleaseISpinner(spin);

	ICustButton *but = GetICustButton(GetDlgItem(hPanel,IDC_MM_START));
	but->SetType(CBT_CHECK);
	but->SetHighlightColor(RED_WASH);
	ReleaseICustButton(but);

	but = GetICustButton(GetDlgItem(hPanel,IDC_MM_LIVE));
	but->SetType(CBT_CHECK);
	but->SetHighlightColor(RED_WASH);
	ReleaseICustButton(but);	
	
	but = GetICustButton(GetDlgItem(hPanel,IDC_MM_DELSET));
	but->SetImage(hButtonIcons,0,0,0,0,16,16);
	ReleaseICustButton(but);		

	CheckDlgButton(hPanel,IDC_SAMPLES1,!doubleSample);
	CheckDlgButton(hPanel,IDC_SAMPLES2, doubleSample);
	CheckDlgButton(hPanel,IDC_REDUCE_KEYS, reduce);
	CheckDlgButton(hPanel,IDC_MM_LIVEPREROLL, livePreRoll);
	CheckDlgButton(hPanel,IDC_MM_PLAYTEST, playWhileTest);
	CheckDlgButton(hPanel,IDC_MM_STARTSTOPENABLE,startStopEnabled);

	spin = GetISpinner(GetDlgItem(hPanel,IDC_REDUCE_THRESHSPIN));
	spin->SetLimits(0.0f, float(999999), FALSE);
	spin->SetScale(0.1f);
	spin->LinkToEdit(GetDlgItem(hPanel,IDC_REDUCE_THRESH), EDITTYPE_FLOAT);
	spin->SetValue(reduceThresh,FALSE);
	ReleaseISpinner(spin);
	
	SubClassNamedSel(GetDlgItem(hPanel,IDC_MM_SETS));
	for (int i=0; i<selSets.Count(); i++) {
		SendMessage(GetDlgItem(hPanel,IDC_MM_SETS), CB_ADDSTRING, 0, 
			(LPARAM)(TCHAR*)*(selSets[i]));
		}

	SetupList();
	}

void MotionManager::Destroy(HWND hWnd)
	{
	// Save settings
	ISpinnerControl *spin = 
		GetISpinner(GetDlgItem(hPanel,IDC_MM_PREROLLSPIN));	
	pre   = spin->GetIVal();
	ReleaseISpinner(spin);
	spin  = GetISpinner(GetDlgItem(hPanel,IDC_MM_INSPIN));	
	in    = spin->GetIVal();
	ReleaseISpinner(spin);
	spin  = GetISpinner(GetDlgItem(hPanel,IDC_MM_OUTSPIN));	
	out   = spin->GetIVal();
	ReleaseISpinner(spin);	
	}

void MotionManager::DrawTrack(
		HDC hdc,int index,BOOL sel,RECT rect)
	{
	if (index>=0) {
		TSTR name = ControlName(index);	
		TextOut(hdc,rect.left+10,rect.top,name,name.Length());
		ImageList_Draw(
			hTrackIcons,
			cont[index]->GetRecordState(),
			hdc, rect.left, rect.top+2, ILD_NORMAL);
		}
	}

void MotionManager::CheckMessages()
	{
	MSG msg;

	// Make sure any mouse messages go to us.
	while (PeekMessage(&msg,NULL,WM_MOUSEFIRST,WM_MOUSELAST,PM_REMOVE)) {
		BOOL trap = TRUE;

		// Don't trap left clicks to record controlls.
		if (GetParent(msg.hwnd)==hPanel && msg.message!=WM_RBUTTONDOWN) {
			int id = GetWindowLong(msg.hwnd,GWL_ID);
			if (id==IDC_MM_START || id==IDC_MM_STOP || id==IDC_MM_LIVE) {
				trap = FALSE;
				}
			}
		
		if (msg.message==WM_RBUTTONDOWN) {
			Stop();
			return;
			}

		//if (trap) msg.hwnd = hPanel;
		if (!trap) {
			ip->TranslateAndDispatchMAXMessage(msg);
			}
		}
	while (PeekMessage(&msg,hPanel,0,0,PM_REMOVE)) {			
		ip->TranslateAndDispatchMAXMessage(msg);
		}
	UpdateWindow(hPanel);
	}

void MotionManager::TrackParams(HWND hWnd,int index)
	{
	if (index>=0 && index<cont.Count()) {
		cont[index]->EditTrackParams(
			0, NULL, ControlName(index), hWnd, (IObjParam*)ip, 0);
		}
	}

void MotionManager::MidiNote(int channel, int note)
	{

	}

void MotionManager::NewSelSet()
	{
	int set = selSets.Count();
	TCHAR buf[256];
	GetDlgItemText(hPanel,IDC_MM_SETS,buf,256);
	TSTR *name = new TSTR(buf);
	selSets.Append(1,&name);

	for (int i=0; i<cont.Count(); i++) {
		if (cont[i]->GetRecordState()) {
			cont[i]->selSet = set;
			}
		}
	}

void MotionManager::DeleteSelSet()
	{
	LRESULT res;	
 	HWND hNameSel = GetDlgItem(hPanel,IDC_MM_SETS);
	TCHAR buf[256];
	GetDlgItemText(hPanel,IDC_MM_SETS,buf,256);
	if (CB_ERR != 
		(res = SendMessage(hNameSel, CB_FINDSTRINGEXACT, 0, (LPARAM)buf))) {		
		SendMessage(hNameSel, CB_DELETESTRING, res, 0);
		ClearSelSetName();
		
		selSets.Delete(res,1);

		// Offset set indices
		for (int i=0; i<cont.Count(); i++) {
			if (cont[i]->selSet==res) cont[i]->selSet = -1;
			if (cont[i]->selSet>res) cont[i]->selSet--;
			}
		}	
	}

void MotionManager::ClearSelSetName()
	{				
	SetDlgItemText(hPanel,IDC_MM_SETS,NULL);
	}

void MotionManager::ActivateSelSet(int i)
	{
	for (int j=0; j<cont.Count(); j++) {
		if (cont[j]->selSet == i) {
			cont[j]->SetRecordState(TRUE);
		} else {
			cont[j]->SetRecordState(FALSE);
			}
		}
	InvalidateRect(GetDlgItem(hPanel,IDC_MM_TRACKS),NULL,TRUE);
	}


static WNDPROC NamedSelWndProc = NULL;

static LRESULT CALLBACK NamedSelSubWndProc(
		HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
	{
	switch (message) {
		case WM_SETFOCUS:  
			DisableAccelerators(); 
			if (theMM.ip) theMM.ip->UnRegisterDlgWnd(theMM.hPanel);
			break;		
		case WM_KILLFOCUS: 
			EnableAccelerators();  
			if (theMM.ip) theMM.ip->RegisterDlgWnd(theMM.hPanel);
			break;
					
		case WM_CHAR:
			if (wParam==13) {
				TCHAR buf[256];
				HWND hCombo = GetParent(hWnd);						
				LRESULT res;
				GetWindowText(hWnd,buf,256);				
				if (CB_ERR != 
					(res = SendMessage(hCombo, CB_FINDSTRINGEXACT, 0, (LPARAM)buf))) {
					// String is already in the list.					
					SendMessage(hCombo, CB_SETCURSEL, res, 0);
					SendMessage(GetParent(hCombo), WM_COMMAND, 
						MAKEWPARAM(GetWindowLong(hCombo,GWL_ID),CBN_SELCHANGE),
						(LPARAM)hCombo );
				} else {
					SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)buf);
					SendMessage(hWnd, EM_SETSEL, 0, (WPARAM)((INT)-1));
					theMM.NewSelSet();
					}
				return 0;
				}
			break;
		}
	return CallWindowProc(NamedSelWndProc,hWnd,message,wParam,lParam);
	}

static BOOL CALLBACK EnumChildren(HWND hwnd, LPARAM lParam)
	{	
	NamedSelWndProc = (WNDPROC)SetWindowLong(hwnd,GWL_WNDPROC,(LONG)NamedSelSubWndProc );
	return FALSE;
	}

static void SubClassNamedSel(HWND hNameSel)
	{
	EnumChildWindows(hNameSel,EnumChildren,0);
	}


static BOOL CALLBACK MotionManDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			theMM.Init(hWnd);	 		
			break;
				
		case WM_DESTROY:
			theMM.Destroy(hWnd);
			break;
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theMM.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;
		
		case WM_RBUTTONDOWN:
			theMM.Stop();
			break;

		case CC_SPINNER_CHANGE: {
			ISpinnerControl *spin = (ISpinnerControl *)lParam;			
			switch (LOWORD(wParam)) {
				case IDC_MM_PREROLLSPIN:    theMM.pre = spin->GetIVal(); break;
				case IDC_MM_INSPIN:		    theMM.in = spin->GetIVal(); break;
				case IDC_MM_OUTSPIN:        theMM.out = spin->GetIVal(); break;
				case IDC_REDUCE_THRESHSPIN: theMM.reduceThresh = spin->GetFVal(); break;
				}
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_MM_PLAYTEST:
					theMM.playWhileTest = IsDlgButtonChecked(hWnd,IDC_MM_PLAYTEST);
					break;

				case IDC_MM_LIVEPREROLL:
					theMM.livePreRoll = IsDlgButtonChecked(hWnd,IDC_MM_LIVEPREROLL);
					break;

				case IDC_REDUCE_KEYS:
					theMM.reduce = IsDlgButtonChecked(hWnd,IDC_REDUCE_KEYS);
					break;

				case IDC_MM_START:
					theMM.Start();
					break;

				case IDC_MM_STOP:
					theMM.Stop();
					break;

				case IDC_MM_LIVE:
					theMM.Live();
					break;

				case IDC_MM_TRACKS:
					if (HIWORD(wParam)==LBN_SELCHANGE) {
						int index = SendDlgItemMessage(
							hWnd, IDC_MM_TRACKS, LB_GETCURSEL, 0, 0);
						if (index!=LB_ERR) {
							theMM.ToggleRecordMode(index);
							InvalidateRect(GetDlgItem(hWnd,IDC_MM_TRACKS),NULL,TRUE);
							}
						theMM.ClearSelSetName();
					} else if (HIWORD(wParam)==LBN_DBLCLK) {
						int index = SendDlgItemMessage(
							hWnd, IDC_MM_TRACKS, LB_GETCURSEL, 0, 0);
						if (index!=LB_ERR) {
							theMM.ToggleRecordMode(index);
							InvalidateRect(GetDlgItem(hWnd,IDC_MM_TRACKS),NULL,TRUE);
							theMM.TrackParams(hWnd,index);
							}
						}
					break;

				case IDC_MM_ALL:
				case IDC_MM_INVERT:
				case IDC_MM_NONE: {
					for (int i=0; i<theMM.cont.Count(); i++) {
						if (LOWORD(wParam)==IDC_MM_ALL)	   theMM.cont[i]->SetRecordState(TRUE);
						if (LOWORD(wParam)==IDC_MM_INVERT) theMM.ToggleRecordMode(i);
						if (LOWORD(wParam)==IDC_MM_NONE)   theMM.cont[i]->SetRecordState(FALSE);
						}
					InvalidateRect(GetDlgItem(hWnd,IDC_MM_TRACKS),NULL,TRUE);
					theMM.ClearSelSetName();
					break;
					}

				case IDC_MM_SETS:
					if (HIWORD(wParam)==CBN_SELCHANGE) {
						int index = SendDlgItemMessage(
							hWnd, IDC_MM_SETS, CB_GETCURSEL, 0, 0);
						if (index!=LB_ERR) {
							theMM.ActivateSelSet(index);
							}
						}
					break;

				case IDC_MM_DELSET:
					theMM.DeleteSelSet();
					break;

				case IDC_MM_STARTSTOPENABLE:
					theMM.SetStartStopEnable(IsDlgButtonChecked(hWnd,IDC_MM_STARTSTOPENABLE));
					break;

				case IDC_MM_AUTOSTART:
					theMM.SetupStartStop();
					break;
				}
			break;

		case WM_MEASUREITEM: {
			MEASUREITEMSTRUCT *mi = (LPMEASUREITEMSTRUCT)lParam;
			TSTR name = theMM.ControlName(mi->itemID);						
			HWND hCont = GetDlgItem(hWnd,IDC_MM_TRACKS);
			HDC hdc = GetDC(hCont);
			SIZE size;
			GetTextExtentPoint(hdc,name,name.Length(),&size);
			mi->itemWidth  = size.cx + 12;
			mi->itemHeight = size.cy - 2;
			ReleaseDC(hCont,hdc);			
			break;
			}

		case WM_DRAWITEM: {
			DRAWITEMSTRUCT *di = (DRAWITEMSTRUCT*)lParam;
			theMM.DrawTrack(di->hDC,di->itemID,
				di->itemState,di->rcItem);
			break;
			}

		default:
			return FALSE;
		}
	return TRUE; 
	}



static BOOL CALLBACK SelectBindingDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	static int *index=NULL;

	switch (msg) {
		case WM_INITDIALOG: {
			index = (int*)lParam;
			SendDlgItemMessage(hWnd,IDC_DEVICE_LIST,
				LB_ADDSTRING,0,(LPARAM)GetString(IDS_RB_NONE));			
			for (int i=0; i<theMM.device.Count(); i++) {
				TSTR name = theMM.device[i]->DeviceName();
				SendDlgItemMessage(hWnd,IDC_DEVICE_LIST,
					LB_ADDSTRING,0,(LPARAM)(TCHAR*)name);
				}
			break;
			}
		
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_DEVICE_LIST:
					if (HIWORD(wParam)!=LBN_DBLCLK) break;
					// fallthrough

				case IDOK:
					*index = SendDlgItemMessage(
							hWnd, IDC_DEVICE_LIST, LB_GETCURSEL, 0, 0);
					EndDialog(hWnd,1);
					break;
					
				case IDCANCEL:
					EndDialog(hWnd,0);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}


MCDeviceBinding *MotionManager::SelectBinding(HWND hWnd, BOOL &cancel)
	{
	int index;
	SetupDeviceList();
	if (DialogBoxParam(
			hInstance,
			MAKEINTRESOURCE(IDD_SELBINDING),
			hWnd,
			SelectBindingDlgProc,
			(LPARAM)&index)) {

		if (index>=0 && index-1<device.Count()) {			
			cancel = FALSE;
			if (index==0) return NULL;
			return device[index-1]->CreateBinding();
			}
		}
	cancel = TRUE;
	return NULL;	
	}

static void SetupParams(HWND hWnd)
	{
	ISpinnerControl *spin;			
	
	spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_CHANNELSPIN));	
	spin->SetValue(theMM.ssParams.GetChannel()+1,FALSE);
	if (theMM.ssParams.presetType!=STARTSTOP_CUSTOM) 
		 spin->Disable();
	else spin->Enable();
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_STOPSPIN));	
	spin->SetValue(theMM.ssParams.GetStop(),FALSE);
	if (theMM.ssParams.presetType!=STARTSTOP_CUSTOM) 
		 spin->Disable();
	else spin->Enable();
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_PLAYSPIN));	
	spin->SetValue(theMM.ssParams.GetPlay(),FALSE);
	if (theMM.ssParams.presetType!=STARTSTOP_CUSTOM) 
		 spin->Disable();
	else spin->Enable();
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_RECORDSPIN));	
	spin->SetValue(theMM.ssParams.GetRecord(),FALSE);
	if (theMM.ssParams.presetType!=STARTSTOP_CUSTOM) 
		 spin->Disable();
	else spin->Enable();
	ReleaseISpinner(spin);
	}

static BOOL CALLBACK StartStopDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	static int oldType;

	switch (msg) {
		case WM_INITDIALOG: {
			CenterWindow(hWnd,GetParent(hWnd));
			
			oldType = theMM.ssParams.presetType;
			SendDlgItemMessage(hWnd,IDC_MIDI_PRESETS,CB_ADDSTRING,
				0, (LPARAM)GetString(IDS_RB_CUSTOM));
			for (int i=0; i<STARTSTOP_PRESETS; i++) {
				SendDlgItemMessage(hWnd,IDC_MIDI_PRESETS,CB_ADDSTRING,
					0, (LPARAM)GetString(ssPresets[i].devID));
				}
			SendDlgItemMessage(hWnd,IDC_MIDI_PRESETS,CB_SETCURSEL,
				theMM.ssParams.presetType,0);

			ISpinnerControl *spin;
			
			spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_CHANNELSPIN));
			spin->SetLimits(1,16,FALSE);
			spin->SetScale(0.05f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_MIDI_CHANNEL),EDITTYPE_INT);			
			ReleaseISpinner(spin);

			spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_STOPSPIN));
			spin->SetLimits(0,127,FALSE);
			spin->SetScale(0.1f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_MIDI_STOP),EDITTYPE_INT);			
			ReleaseISpinner(spin);

			spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_PLAYSPIN));
			spin->SetLimits(0,127,FALSE);
			spin->SetScale(0.1f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_MIDI_PLAY),EDITTYPE_INT);			
			ReleaseISpinner(spin);

			spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_RECORDSPIN));
			spin->SetLimits(0,127,FALSE);
			spin->SetScale(0.1f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_MIDI_RECORD),EDITTYPE_INT);			
			ReleaseISpinner(spin);

			SetupParams(hWnd);
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_MIDI_PRESETS:
					if (HIWORD(wParam)==CBN_SELCHANGE) {
						int res = SendDlgItemMessage(hWnd,IDC_MIDI_PRESETS,
							CB_GETCURSEL,0,0);
						if (res!=CB_ERR) {
							theMM.ssParams.presetType = res;
							SetupParams(hWnd);
							}
						}
					break;

				case IDOK:
					if (theMM.ssParams.presetType==STARTSTOP_CUSTOM) {
						ISpinnerControl *spin;

						spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_CHANNELSPIN));
						theMM.ssParams.channel = spin->GetIVal()-1;
						ReleaseISpinner(spin);

						spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_STOPSPIN));
						theMM.ssParams.stop = spin->GetIVal();
						ReleaseISpinner(spin);

						spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_PLAYSPIN));
						theMM.ssParams.play = spin->GetIVal();
						ReleaseISpinner(spin);

						spin = GetISpinner(GetDlgItem(hWnd,IDC_MIDI_RECORDSPIN));
						theMM.ssParams.record = spin->GetIVal();
						ReleaseISpinner(spin);
						}

					EndDialog(hWnd,1);
					break;					

				case IDCANCEL:
					theMM.ssParams.presetType = oldType;
					EndDialog(hWnd,0);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

void MotionManager::SetupStartStop()
	{
	if (DialogBox(
			hInstance,
			MAKEINTRESOURCE(IDD_MANAGER_STARTSTOP),
			hPanel,
			StartStopDlgProc)) {
		
		SetMotionCaptureINISetting(MCAP_INI_CHANNEL,ssParams.channel );
		SetMotionCaptureINISetting(MCAP_INI_PRESET,ssParams.presetType );
		SetMotionCaptureINISetting(MCAP_INI_STOP,ssParams.stop );
		SetMotionCaptureINISetting(MCAP_INI_PLAY,ssParams.play );
		SetMotionCaptureINISetting(MCAP_INI_RECORD,ssParams.record );
		}
	}

static DWORD MIDIInProc(
		HMIDIIN hMidiIn,
		UINT wMsg, DWORD dwInstance,
		DWORD dwParam1, DWORD dwParam2)
	{
	switch (wMsg) {
		case MIM_DATA: {
			int ch = MIDI_CHANNEL(dwParam1);
			int nn = MIDI_NOTENUMBER(dwParam1);			
			int event = MIDI_EVENT(dwParam1);
			int vel = MIDI_VELOCITY(dwParam1);
					
			if (ch!=theMM.ssParams.GetChannel()) break;
			if (event!=MIDI_CONTROLCHANGE) break;

			if ((theMM.live || theMM.recording) &&
				(nn==theMM.ssParams.GetStop())) {
				PostMessage(theMM.hPanel,WM_COMMAND,IDC_MM_STOP,0);
				return MIDIPROC_PROCESSED;
				}

			if (nn==theMM.ssParams.GetPlay()) {
				if (vel==0) {
					theMM.playDown = FALSE;
					if (theMM.recDown) {
						PostMessage(theMM.hPanel,WM_COMMAND,IDC_MM_START,0);
					} else {
						break;
						}
				} else {
					theMM.playDown = TRUE;
					}
				return MIDIPROC_PROCESSED;
				}

			if (nn==theMM.ssParams.GetRecord()) {
				if (vel==0) {
					theMM.recDown = FALSE;
					if (theMM.playDown) {
						PostMessage(theMM.hPanel,WM_COMMAND,IDC_MM_START,0);
					} else {
						if (!theMM.recording)
							PostMessage(theMM.hPanel,WM_COMMAND,IDC_MM_LIVE,0);
						}
				} else {
					theMM.recDown = TRUE;
					}
				return MIDIPROC_PROCESSED;
				}
			}
		}
	
	if (theMM.live || theMM.recording) return MIDIPROC_PROCESSED;
	return MIDIPROC_NOTPROCESSED;
	}

void MotionManager::SetStartStopEnable(BOOL onOff)
	{
	if (startStopEnabled==onOff) return;
	if (onOff) {
		MIDIMan_Open(MIDIInProc,0,10);
		MIDIMan_Start();
	} else {
		MIDIMan_Stop();
		MIDIMan_Close(MIDIInProc,0);
		}
	startStopEnabled = onOff;
	SetMotionCaptureINISetting(MCAP_INI_SSENABLE,startStopEnabled);
	}

void MotionManager::Start() 
	{
	if (ip->IsAnimPlaying()) {
		ip->EndAnimPlayback();
		}

	// Check to make sure there is something to record.
	BOOL any=FALSE;
	for (int i=0; i<cont.Count(); i++) {
		if (cont[i]->GetRecordState()) {
			any = TRUE;
			break;
			}
		}
	if (!any) {
		TSTR buf1 = GetString(IDS_RB_NOTRACKSON);
		TSTR buf2 = GetString(IDS_RB_MOTIONCAPTURE);
		MessageBox(hPanel,buf1,buf2,MB_OK|MB_ICONEXCLAMATION);
		Stop();
		return;
		}

	playSpeed = ip->GetPlaybackSpeed();
	
	// Grab settings from UI
	ISpinnerControl *spin = 
		GetISpinner(GetDlgItem(hPanel,IDC_MM_PREROLLSPIN));	
	pre   = spin->GetIVal();
	ReleaseISpinner(spin);
	spin  = GetISpinner(GetDlgItem(hPanel,IDC_MM_INSPIN));	
	in    = spin->GetIVal();
	ReleaseISpinner(spin);
	spin  = GetISpinner(GetDlgItem(hPanel,IDC_MM_OUTSPIN));	
	out   = spin->GetIVal();
	ReleaseISpinner(spin);	
	spin  = GetISpinner(GetDlgItem(hPanel,IDC_REDUCE_THRESHSPIN));	
	reduceThresh = spin->GetFVal();
	ReleaseISpinner(spin);
	reduce       = IsDlgButtonChecked(hPanel,IDC_REDUCE_KEYS);
	doubleSample = IsDlgButtonChecked(hPanel,IDC_SAMPLES2);

	// Make sure the current range fits.
	if (pre>in) pre=in;
	if (in>/*=*/out) {
		TSTR buf1 = GetString(IDS_RB_NOTIME);
		TSTR buf2 = GetString(IDS_RB_MOTIONCAPTURE);
		MessageBox(hPanel,buf1,buf2,MB_OK|MB_ICONEXCLAMATION);
		Stop();
		return;
		}
	Interval anim    = ip->GetAnimRange();
	Interval animNew = anim;	
	if (animNew.Start()>pre) {
		animNew.SetStart(pre);		
		}
	if (animNew.End()<out) {
		animNew.SetEnd(out);		
		}
	if (!(animNew==anim)) ip->SetAnimRange(animNew);

	// Do it!
	SetCapture(hPanel);
	DoCapture(
		pre, in, out, GetTicksPerFrame()/(doubleSample?2:1));	
	ReleaseCapture();

	// Put the range back
	if (!(animNew==anim)) ip->SetAnimRange(anim);
	}


#define TimeValToMS(t) ((t*1000)/TIME_TICKSPERSEC)
#define MSToTimeVal(ms) ((ms*TIME_TICKSPERSEC)/1000)

static void CALLBACK PlayCallback(
		UINT idEvent,UINT reserved,DWORD user,
		DWORD reserved1,DWORD reserved2)
	{
	theMM.Increment();
	}

void MotionManager::Stop()
	{
	stop = TRUE;
	
	ICustButton *but = GetICustButton(GetDlgItem(hPanel,IDC_MM_LIVE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);	

	but = GetICustButton(GetDlgItem(hPanel,IDC_MM_START));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);	
	}

void MotionManager::Live()
	{
	if (ip->IsAnimPlaying()) {
		ip->EndAnimPlayback();
		}

	SHORT res=0;		

	// Don't re-enter
	if (live || recording) {
		Stop();
		return;
		}
	live = TRUE;

	SetCapture(hPanel);
	playSpeed = ip->GetPlaybackSpeed();

	// Turn on the controllers which are in record mode.
	for (int i=0; i<cont.Count(); i++) {
		if (cont[i]->GetRecordState()) {			
			cont[i]->BeginLive(ip->GetTime());
			cont[i]->LiveOn();
			}
		}
	
	// Push capture mode
	theCaptureMode.recording = FALSE;
	ip->PushCommandMode(&theCaptureMode);

	// Clear the key state
	GetAsyncKeyState(VK_ESCAPE);
	stop = FALSE;


	// Set the clock period to 1 millisecond and start timer
	calls     = 0;
	startTime = GetAnimStart();
	timeBeginPeriod(1);	
	TimeValue t = 0;
	UINT playTimer = 
		timeSetEvent(1,0,PlayCallback,(DWORD)this,TIME_PERIODIC);	


	// Loop until the user hits escape
	while (!stop && !(res&1)) {
		if (playWhileTest) {
			t = GetTime();
			if (t>GetAnimEnd()) {
				t = startTime;
				calls = 0;
				}
			}

		// Process some messages
		CheckMessages();

		// Invalidate controllers
		for (int i=0; i<cont.Count(); i++) {
			cont[i]->NotifyDependents(FOREVER,0,REFMSG_CHANGE);			
			}
		if (playWhileTest) {
			ip->SetTime(t,FALSE);
			ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
		} else {
			ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
			}

		res = GetAsyncKeyState(VK_ESCAPE);
		}


	// Shut off timer
	timeKillEvent(playTimer);
	timeEndPeriod(1);

	// Turn off the live button
	ICustButton *but = GetICustButton(GetDlgItem(hPanel,IDC_MM_LIVE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);	

	// Turn off the controllers which are in record mode.
	for (i=0; i<cont.Count(); i++) {
		if (cont[i]->GetRecordState()) {			
			cont[i]->LiveOff();
			cont[i]->EndLive(ip->GetTime());
			}
		}

	// Pop off animate mode.
	ip->PopCommandMode();
	ip->DeleteMode(&theCaptureMode);

	// Invalidate controllers and redraw one more time to put everything back.
	for (i=0; i<cont.Count(); i++) {
		cont[i]->NotifyDependents(FOREVER,0,REFMSG_CHANGE);		
		}
	ip->RedrawViews(ip->GetTime(),REDRAW_END);

	ReleaseCapture();

	live = FALSE;
	}


void MotionManager::Increment()
	{	
	EnterCriticalSection(&theMM.csect);	
	
	// Increment the counter.
	calls++;	

	for (int i=0; i<device.Count(); i++) {
		device[i]->Cycle(calls);
		}

	// Accumulate 50 times per second
	if (calls%20==0) {
		TimeValue t = GetTime();
		for (int i=0; i<cont.Count(); i++) {
			if (cont[i]->GetRecordState()) {
				cont[i]->Accumulate(t);
				}
			}
		}

	if (recording) {
		TimeValue t = GetTime();
		if (!capture && record.InInterval(t)) {
			capture = TRUE;
			// Turn on the controllers which are in record mode.
			for (int i=0; i<cont.Count(); i++) {
				if (cont[i]->GetRecordState()) {				
					if (livePreRoll) {
						cont[i]->LiveOff();
						cont[i]->EndLive(t);
						}
					cont[i]->RecordOn(!livePreRoll);
					}
				}
			}
		
		// Tell controllers to capture a sample
		if (t>=nextSample && t>record.Start() && samples<totalSamples) {
			for (int i=0; i<cont.Count(); i++) {
				if (cont[i]->GetRecordState()) {
					cont[i]->Capture(record,t,samples);
					}
				}
			samples++;
			nextSample += sampleRate;
			}
		}

	LeaveCriticalSection(&theMM.csect);	
	}

TimeValue MotionManager::GetTime()
	{
	TimeValue res;
	EnterCriticalSection(&theMM.csect);	
	TimeValue dt = MSToTimeVal(calls);
	switch (playSpeed) {
		case -4: dt /= 4; break;
		case -2: dt /= 2; break;
		case  2: dt *= 2; break;
		case  4: dt *= 4; break;
		}
	res = startTime + dt;		
	LeaveCriticalSection(&theMM.csect);	
	return res;
	}


static ULONG _stdcall Function(void *foo) {return 0;}

class CaptureStatus : public KeyReduceStatus {
	public:		
		int pp;
		int total;
		Interface *ip;
		TCHAR *title;
		BOOL canceled;

		CaptureStatus(Interface *i,TCHAR *t) {ip=i;title=t;pp=0;canceled=FALSE;}
		void Init(int total) {
			this->total = total;
			ip->ProgressStart(title, TRUE, Function, 0);
			}
		void Done() {
			ip->ProgressEnd();
			}
		int Progress(int p) {
			int pct = total?((p+pp)*100)/total:100;
			ip->ProgressUpdate(pct);
			if (ip->GetCancel()) {
				ip->SetCancel(FALSE);
				canceled = TRUE;
				return KEYREDUCE_STOP;
			} else {
				return KEYREDUCE_CONTINUE;
				}
			}
	};


void MotionManager::DoCapture(
		TimeValue pre, TimeValue start, TimeValue end, TimeValue samp)
	{
	TimeValue t;
	SHORT res=0;	
	int numCont = 0;

	// Don't re-enter
	if (recording || live) {
		Stop();
		return;
		}
	recording = TRUE;
	capture   = FALSE;		

	theHold.SuperBegin();
	theHold.Begin();

	// Set the clock period to 1 millisecond
	timeBeginPeriod(1);
	

	// Play soundtrack while recordin' -- Harry D, 23/12/98
	SoundObj *snd;
	snd = ip->GetSoundObject();
	snd->Stop();
	
	// Setup everything and redraw at the start
	startTime    = pre;
	record       = Interval(start,end);
	sampleRate   = samp;
	calls        = 0;	
	nextSample   = start;
	samples      = 0;	
	totalSamples = record.Duration()/sampleRate + 1;
	theCaptureMode.recording = TRUE;
	ip->PushCommandMode(&theCaptureMode);
	ip->SetTime(startTime);

	// Turn on the controllers which are in record mode.
	for (int i=0; i<cont.Count(); i++) {
		if (cont[i]->GetRecordState()) {
			numCont++;
			cont[i]->BeginCapture(record,samp);
			if (livePreRoll) {
				cont[i]->BeginLive(start);
				cont[i]->LiveOn();
				}
			}
		}

	// Clear the key state
	GetAsyncKeyState(VK_ESCAPE);
	stop = FALSE;

	// Set a time event.
	UINT playTimer = 
		timeSetEvent(1,0,PlayCallback,(DWORD)this,TIME_PERIODIC);	
	
//	snd->Scrub(start,end); // start sound here
	snd->Scrub(pre, end); // start sound here // mjm - 9.10.99

	// Loop through the capture range
	while ((t=GetTime())<=end && !stop && !(res&1)) {
		
		// Process some messages
		CheckMessages();

		// While recording, invalidate controllers
		if (record.InInterval(t) || livePreRoll) {
			for (int i=0; i<cont.Count(); i++) {
				cont[i]->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
				}
			}

		// Step to the next frame and redraw
		ip->SetTime(t,FALSE);
		ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);		
		
		// Check for escape key
		res = GetAsyncKeyState(VK_ESCAPE);
		}

	snd->Stop();
	
	timeKillEvent(playTimer);
	timeEndPeriod(1);

	// Setup progress bar.
	CaptureStatus stat(ip,_T("Creating Keys"));
	stat.Init(totalSamples*numCont);

	// Turn off the controllers which are in record mode.	
	for (i=0; i<cont.Count(); i++) {
		if (cont[i]->GetRecordState()) {
			if (!stat.canceled) 
				cont[i]->EndCapture(record,samp,&stat);
			cont[i]->RecordOff();			
			stat.pp += totalSamples;			
			}
		}
	theHold.Accept(GetString(IDS_RB_MOTIONCAPTURE));
	stat.Done();	
	stat.pp = 0;
	
	// Reduce keys
	if (!stat.canceled && reduce) {
		for (i=0; i<cont.Count(); i++) {
			if (cont[i]->GetRecordState()) {						
				
				// Set up title in progress bar
				TSTR title = ControlName(cont[i]);
				title = TSTR(_T("Reducing Keys: ")) + title;
				stat.title = title;

				// Reduce the keys
				float thresh = reduceThresh;
				switch (cont[i]->cont->SuperClassID()) {
					case CTRL_ROTATION_CLASS_ID:
						thresh = DegToRad(thresh); break;
					case CTRL_SCALE_CLASS_ID:
						thresh = thresh/100.0f; break;
					}
				int res = ApplyKeyReduction(
					cont[i]->cont, record, thresh, samp, &stat);
				
				// Close status
				stat.Done();

				if (res!=KEYREDUCE_CONTINUE) break;
				}
			}
		}	
	theHold.SuperAccept(GetString(IDS_RB_MOTIONCAPTURE));

	// Bump off the command mode.
	ip->PopCommandMode();
	ip->DeleteMode(&theCaptureMode);
	ip->SetTime(start,REDRAW_END);
	
	recording = FALSE;

	Stop();
	}


#define DOUBLESAMP_CHUNK_ID		0x0100
#define LIVEPRE_CHUNK_ID		0x0110
#define REDUCE_CHUNK_ID			0x0120
#define REDUCETHRESH_CHUNK_ID	0x0130
#define PRE_CHUNK_ID			0x0140
#define IN_CHUNK_ID				0x0150
#define OUT_CHUNK_ID			0x0160
#define SELSET_CHUNK_ID			0x0170
#define PLAYTEST_CHUNK_ID		0x0180

IOResult MotionManager::Save(ISave *isave)
	{
	ULONG nb;	

	isave->BeginChunk(DOUBLESAMP_CHUNK_ID);
	isave->Write(&doubleSample,sizeof(doubleSample),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(LIVEPRE_CHUNK_ID);
	isave->Write(&livePreRoll,sizeof(livePreRoll),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(PLAYTEST_CHUNK_ID);
	isave->Write(&playWhileTest,sizeof(playWhileTest),&nb);
	isave->EndChunk();	

	isave->BeginChunk(REDUCE_CHUNK_ID);
	isave->Write(&reduce,sizeof(reduce),&nb);
	isave->EndChunk();

	isave->BeginChunk(REDUCETHRESH_CHUNK_ID);
	isave->Write(&reduceThresh,sizeof(reduceThresh),&nb);
	isave->EndChunk();

	isave->BeginChunk(PRE_CHUNK_ID);
	isave->Write(&pre,sizeof(pre),&nb);
	isave->EndChunk();

	isave->BeginChunk(IN_CHUNK_ID);
	isave->Write(&in,sizeof(in),&nb);
	isave->EndChunk();

	isave->BeginChunk(OUT_CHUNK_ID);
	isave->Write(&out,sizeof(out),&nb);
	isave->EndChunk();

	for (int i=0; i<selSets.Count(); i++) {
		isave->BeginChunk(SELSET_CHUNK_ID);
		isave->WriteWString(*(selSets[i]));
		isave->EndChunk();
		}

	return IO_OK;
	}

IOResult MotionManager::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	if (iu) iu->CloseUtility();

	for (int i=0; i<selSets.Count(); i++) {
		delete selSets[i];
		}
	selSets.Resize(0);

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case SELSET_CHUNK_ID: {
				TCHAR *buf;
				iload->ReadWStringChunk(&buf);
				TSTR *name = new TSTR(buf);
				selSets.Append(1,&name);
				break;
				}

			case DOUBLESAMP_CHUNK_ID:
				res=iload->Read(&doubleSample,sizeof(doubleSample),&nb);
				break;
			
			case LIVEPRE_CHUNK_ID:
				res=iload->Read(&livePreRoll,sizeof(livePreRoll),&nb);
				break;

			case PLAYTEST_CHUNK_ID:
				res=iload->Read(&playWhileTest,sizeof(playWhileTest),&nb);
				break;

			case REDUCE_CHUNK_ID:
				res=iload->Read(&reduce,sizeof(reduce),&nb);
				break;

			case REDUCETHRESH_CHUNK_ID:
				res=iload->Read(&reduceThresh,sizeof(reduceThresh),&nb);
				break;

			case PRE_CHUNK_ID:
				res=iload->Read(&pre,sizeof(pre),&nb);
				break;

			case IN_CHUNK_ID:
				res=iload->Read(&in,sizeof(in),&nb);
				break;

			case OUT_CHUNK_ID:
				res=iload->Read(&out,sizeof(out),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
		
	return IO_OK;
	}



//--- General UI for MCControl parameters-----------------------------

static BOOL CALLBACK MCContParamDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

class MCParamWindow {
	public:
		HWND hWnd;
		HWND hParent;
		Control *cont;
		MCParamWindow() {assert(0);}
		MCParamWindow(HWND hWnd,HWND hParent,Control *cont)
			{this->hWnd=hWnd; this->hParent=hParent; this->cont=cont;}
	};
static Tab<MCParamWindow> mcParamWindows;

static void RegisterMCParamWindow(HWND hWnd, HWND hParent, Control *cont)
	{
	MCParamWindow rec(hWnd,hParent,cont);
	mcParamWindows.Append(1,&rec);
	}

static void UnRegisterMCParamWindow(HWND hWnd)
	{	
	for (int i=0; i<mcParamWindows.Count(); i++) {
		if (hWnd==mcParamWindows[i].hWnd) {
			mcParamWindows.Delete(i,1);
			return;
			}
		}	
	}

static HWND FindOpenMCParamWindow(HWND hParent,Control *cont)
	{	
	for (int i=0; i<mcParamWindows.Count(); i++) {
		if (hParent == mcParamWindows[i].hParent &&
			cont    == mcParamWindows[i].cont) {
			return mcParamWindows[i].hWnd;
			}
		}
	return NULL;
	}

MCParamDlg::MCParamDlg(MCControl *c)
	{
	blockInvalidate = FALSE;
	valid   = FALSE;
	cont    = NULL;	
	hWnd    = NULL;
	binding = NULL;
	ReplaceReference(0,c);
	for (int i=0; i<cont->NumDeviceBindings(); i++) {
		if (cont->GetDeviceBinding(i)) {
			binding = cont->GetDeviceBinding(i);
			break;
			}
		}
	}

void MCParamDlg::DoWindow(HWND hParent, TCHAR *pname)
	{
	HWND hCur = FindOpenMCParamWindow(hParent,cont);
	if (hCur) {
		SetForegroundWindow(hCur);
		DeleteAllRefsFromMe();
		delete this;
		return;
		}

	hWnd = CreateDialogParam(
		hInstance,
		MAKEINTRESOURCE(IDD_MC_PARAMS),
		hParent,
		MCContParamDlgProc,
		(LPARAM)this);
	
	if (pname && TSTR(pname).Length()) {
		TSTR buf = TSTR(GetString(IDS_RB_MOTIONCAPTURE)) 
			+ TSTR(_T("\\")) + TSTR(pname);
		SetWindowText(hWnd,buf);
		}
	RegisterMCParamWindow(hWnd,hParent,cont);
	}

class CheckForNonMCParamDlg : public DependentEnumProc {
	public:		
		BOOL non;
		ReferenceMaker *me;
		CheckForNonMCParamDlg(ReferenceMaker *m) {non=FALSE;me=m;}
		int proc(ReferenceMaker *rmaker) {
			if (rmaker==me) return 0;
			if (rmaker->SuperClassID()!=REF_MAKER_CLASS_ID &&
				rmaker->ClassID()!=Class_ID(MCPARAMDLG_CLASS_ID,0)) {
				non = TRUE;
				return 1;
				}
			return 0;
			}	
	};
void MCParamDlg::MaybeCloseWindow()
	{
	CheckForNonMCParamDlg check(cont);
	cont->EnumDependents(&check);
	if (!check.non) {
		PostMessage(hWnd,WM_CLOSE,0,0);
		}
	}

RefResult MCParamDlg::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
     	PartID& partID,  
     	RefMessage message)
	{
	switch (message) {
		case REFMSG_NEW_BINDING:
			UpdateBinding(partID);
			break;

		case REFMSG_NODE_NAMECHANGE:
		case REFMSG_CHANGE:
			if (!blockInvalidate) Invalidate();			
			break;
		
		case REFMSG_REF_DELETED:
			MaybeCloseWindow();
			break;
		}
	return REF_SUCCEED;
	}

void MCParamDlg::Invalidate()
	{
	valid = FALSE;	
	InvalidateRect(GetHPanel(),NULL,FALSE);	
	}

void MCParamDlg::Update()
	{		
	if (!valid) {
		if (binding) binding->UpdateRollup(iRoll);
		valid = TRUE;
		}
	}

void MCParamDlg::SetupUI(HWND hWnd)
	{
	this->hWnd = hWnd;
	iRoll = GetIRollup(GetDlgItem(hWnd,IDC_MAIN_ROLLUP));
	
	// have the controller add it's rollup
	AddRollup();

	// Have the binding add it's rollup
	if (binding) binding->AddRollup(this);	

	// Display all the rollups
	iRoll->Show();
	}

void MCParamDlg::Close()
	{
	UnRegisterMCParamWindow(hWnd);
	DeleteAllRefsFromMe();
	SetWindowLong(hWnd,GWL_USERDATA,0);
	delete this;
	}

void MCParamDlg::SetBinding(MCDeviceBinding *b)
	{
	binding = b;
	if (iRoll->GetNumPanels()>1) {
		iRoll->DeleteRollup(1, iRoll->GetNumPanels()-1);
		}
	if (binding) {
		binding->AddRollup(this);
		iRoll->Show();
		}
	Invalidate();
	}

static BOOL CALLBACK MCContParamDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	static int dialogWidth;
	MCParamDlg *dlg = (MCParamDlg*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!dlg && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG: {
			dlg = (MCParamDlg*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			dlg->SetupUI(hWnd);
			Rect rect;
			GetWindowRect(hWnd,&rect);
			dialogWidth = rect.w()-1;
			break;
			}
		
		case WM_CLOSE:
			DestroyWindow(hWnd);
			break;

		case WM_DESTROY:
			dlg->Close();
			break;

		case WM_PAINT:
			dlg->Update();
			return FALSE;		

		case WM_WINDOWPOSCHANGING: {
			WINDOWPOS *wp = (WINDOWPOS*)lParam;			
			wp->cx = dialogWidth;
			if (wp->cy<20) wp->cy = 20;
			break;
			}

		case WM_SIZE: {
			Rect rect;
			GetClientRectP(GetDlgItem(hWnd,IDC_MAIN_ROLLUP),&rect);
			int height = HIWORD(lParam)-rect.top-8;
			if (height<10) height = 10;
			SetWindowPos(
				GetDlgItem(hWnd,IDC_MAIN_ROLLUP),
				NULL,
				0, 0,
				rect.w()-1, height,
				SWP_NOMOVE|SWP_NOZORDER);
			break;
			}		

		default:
			return FALSE;
		}
	return TRUE;
	}



//--- GenMCParamDlg ----------------------------------------------

static BOOL CALLBACK GenMCDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

static int bindingButtons[]     = {IDC_XBINDING,     IDC_YBINDING,     IDC_ZBINDING};
static int bindingEditButtons[] = {IDC_EDIT_XBINDING,IDC_EDIT_YBINDING,IDC_EDIT_ZBINDING};

GenMCParamDlg::GenMCParamDlg(MCControl *c, int dlgID) : 
		MCParamDlg(c)
	{	
	editBinding = -1;
	for (int i=0; i<c->NumDeviceBindings(); i++) {
		if (c->GetDeviceBinding(i)) {
			editBinding = i;
			break;
			}
		}
	hPanel = NULL;
	this->dlgID = dlgID;
	}

void GenMCParamDlg::Update()
	{
	if (!valid) {
		MCParamDlg::Update();
		SetupButtons();		
		}
	}

void GenMCParamDlg::AddRollup()
	{
	int strID = 0;
	switch (dlgID) {
		case IDD_MC_FLOAT:    strID = IDS_RB_FLOATMC;   break;
		case IDD_MC_POSITION: strID = IDS_RB_POSMC;		break;
		case IDD_MC_POINT3:   strID = IDS_RB_POINT3MC;	break;
		case IDD_MC_ROTATION: strID = IDS_RB_ROTMC;		break;
		case IDD_MC_SCALE:    strID = IDS_RB_SCALEMC;   break;		
		}
	iRoll->AppendRollup(
			hInstance, 
			MAKEINTRESOURCE(dlgID), 
			GenMCDlgProc, 
			GetString(strID),
			(LPARAM)this);	
	}

void GenMCParamDlg::SetupButtons()
	{
	for (int i=0; i<cont->NumDeviceBindings(); i++) {
		if (cont->GetDeviceBinding(i)) {
			SetDlgItemText(hPanel,bindingButtons[i],
				cont->GetDeviceBinding(i)->BindingName());
		} else {
			SetDlgItemText(hPanel,bindingButtons[i],
				GetString(IDS_RB_NONE));
			}
		
		ICustButton *but;
		but = GetICustButton(GetDlgItem(hPanel,bindingEditButtons[i]));
		if (but) {
			but->SetType(CBT_CHECK);
			if (!cont->GetDeviceBinding(i)) {
				but->SetCheck(FALSE);
				but->Disable();
			} else if (editBinding==i) {
				but->SetCheck(TRUE);
				but->Enable();
			} else {
				but->SetCheck(FALSE);
				but->Enable();
				}
			ReleaseICustButton(but);
			}
		}	
	
	ICustEdit *edit = GetICustEdit(GetDlgItem(hPanel,IDC_TRACKNAME));
	edit->SetText(cont->trackName);
	ReleaseICustEdit(edit);
	}

void GenMCParamDlg::UpdateBinding(int which)
	{
	if (editBinding==which) {
		SetEditBinding(which);
		}
	}

void GenMCParamDlg::SetEditBinding(int which)
	{	
	editBinding = which;
	SetupButtons();
	switch (which) {
		case 0:  
		case 1:  
		case 2:  SetBinding(cont->GetDeviceBinding(which)); break;
		default: SetBinding(NULL); break;
		}
	}

void GenMCParamDlg::AssignBinding(int which)
	{
	BOOL cancel;	
	MCDeviceBinding *b = theMM.SelectBinding(hPanel,cancel);
	if (!cancel) {
		theHold.Begin();
		cont->ReplaceReference(which+1,b);
		theHold.Accept(GetString(IDS_RB_PICKBINDING));
		cont->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		cont->NotifyDependents(FOREVER,which,REFMSG_NEW_BINDING);
		if (b) SetEditBinding(which);
		else if (which==editBinding) SetEditBinding(-1);
		}
	}

static BOOL CALLBACK GenMCDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	GenMCParamDlg *dlg = (GenMCParamDlg*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!dlg && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:
			dlg = (GenMCParamDlg*)lParam;
			dlg->hPanel = hWnd;
			dlg->SetupButtons();
			SetWindowLong(hWnd,GWL_USERDATA,lParam);			
			break;
		
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TRACKNAME: {
					ICustEdit *edit = GetICustEdit(GetDlgItem(hWnd,IDC_TRACKNAME));
					TCHAR buf[256];
					edit->GetText(buf,256);
					dlg->cont->trackName = buf;
					dlg->blockInvalidate = TRUE;
					dlg->cont->NotifyDependents(FOREVER,0,REFMSG_NODE_NAMECHANGE);
					dlg->blockInvalidate = FALSE;
					ReleaseICustEdit(edit);
					if (theMM.hPanel) theMM.SetupList();
					break;
					}

				case IDC_EDIT_XBINDING: dlg->SetEditBinding(0); break;
				case IDC_EDIT_YBINDING: dlg->SetEditBinding(1); break;
				case IDC_EDIT_ZBINDING: dlg->SetEditBinding(2); break;

				case IDC_XBINDING: dlg->AssignBinding(0); break;
				case IDC_YBINDING: dlg->AssignBinding(1); break;
				case IDC_ZBINDING: dlg->AssignBinding(2); break;
				}
		
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:   			
   			dlg->iRoll->DlgMouseMessage(hWnd,msg,wParam,lParam);
			break; 

		case WM_PAINT:
			dlg->Update();
			return FALSE;

		default:
			return FALSE;
		}
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by motion.rc
//
#define IDS_RB_DATA                     1
#define IDS_RB_POSMC                    2
#define IDS_RB_MOTIONMAN                3
#define IDS_RB_ROTMC                    4
#define IDS_RB_SCALEMC                  5
#define IDS_RB_FLOATMC                  6
#define IDS_RB_POINT3MC                 7
#define IDS_RB_MOUSEDEVICE              8
#define IDS_RB_MOUSEX                   9
#define IDS_RB_MOUSEY                   10
#define IDD_EXPRPARAMS                  103
#define IDB_MM_ICONS                    103
#define IDD_FUNC_LIST                   104
#define IDB_MM_ICONSMASK                104
#define IDD_SELBINDING                  104
#define IDD_SCALAR_ASGN                 105
#define IDD_MC_PARAMS                   105
#define IDD_VECTOR_ASGN                 106
#define IDD_MC_POSITION                 106
#define IDB_BUTTONS                     108
#define IDB_BUTTONS_MASK                109
#define IDD_MIDI_VIEWER                 109
#define IDD_MANAGER_STARTSTOP           110
#define IDD_PATHPARAMS                  123
#define IDD_STDJOINTPARAMS              129
#define IDD_PATHJOINTPARAMS             130
#define IDD_EULER_PARAMS                145
#define IDD_MANAGER_PARAMS              145
#define IDD_NOISEPARAMS                 146
#define IDD_MC_MOUSE                    146
#define IDD_MC_FLOAT                    147
#define IDD_MC_SCALE                    148
#define IDD_MC_ROTATION                 149
#define IDD_MC_MIDI                     150
#define IDD_MC_JOY                      151
#define IDD_MC_POINT3                   152
#define IDC_EXPLAIN_NOTATION            1002
#define IDC_MM_TRACKS                   1003
#define IDC_DEVICE_LIST                 1004
#define IDC_MAIN_ROLLUP                 1005
#define IDC_XBINDING                    1007
#define IDC_YBINDING                    1008
#define IDC_ZBINDING                    1009
#define IDC_EDIT_XBINDING               1011
#define IDC_EDIT_YBINDING               1012
#define IDC_MOUSE_X                     1012
#define IDC_EDIT_ZBINDING               1013
#define IDC_MOUSE_Y                     1013
#define IDC_SAMPLES1                    1013
#define IDC_SAMPLES2                    1014
#define IDC_REDUCE_KEYS                 1015
#define IDC_MOUSE_SCALE                 1016
#define IDC_MOUSE_SCALESPIN             1017
#define IDC_MOUSE_FLIP                  1018
#define IDC_MIDI_NOTE                   1019
#define IDC_MIDI_PARAMMIN               1020
#define IDC_MIDI_PARAMMINSPIN           1021
#define IDC_MIDI_PARAMMAX               1022
#define IDC_MIDI_PARAMMAXSPIN           1023
#define IDC_MIDI_CHAN1                  1024
#define IDC_MIDI_CHAN2                  1025
#define IDC_MIDI_CHAN3                  1026
#define IDC_MIDI_CHAN4                  1027
#define IDC_MIDI_CHAN5                  1028
#define IDC_MIDI_CHAN6                  1029
#define IDC_MIDI_CHAN7                  1030
#define IDC_MIDI_CHAN8                  1031
#define IDC_MIDI_CHAN9                  1032
#define IDC_MIDI_CHAN10                 1033
#define IDC_MIDI_CHAN11                 1034
#define IDC_MIDI_CHAN12                 1035
#define IDC_MIDI_CHAN13                 1036
#define IDC_MIDI_CHAN14                 1037
#define IDC_MIDI_CHAN15                 1038
#define IDC_MIDI_CHAN16                 1039
#define IDC_MIDI_VEL                    1040
#define IDC_MIDI_BEND                   1041
#define IDC_MIDI_LOWNOTE                1042
#define IDC_MIDI_LOWOCTAVE              1043
#define IDC_MIDI_HIGHNOTE               1044
#define IDC_MIDI_HIGHOCTAVE             1045
#define IDC_MIDI_SPEED                  1046
#define IDC_MIDI_SPEEDSPIN              1047
#define IDC_EXPR_EDIT                   1048
#define IDC_MIDI_SUSTAIN                1048
#define IDC_EXPR_EVAL                   1049
#define IDC_MIDI_SUSTAINSPIN            1049
#define IDC_VAR_NAME                    1050
#define IDC_MIDI_SUSTAINLABEL           1050
#define IDC_SCALAR_RB                   1051
#define IDC_MIDI_SPEED_LABEL            1051
#define IDC_VECTOR_RB                   1052
#define IDC_NOTERANGE_LABEL1            1052
#define IDC_CREATE_VAR                  1053
#define IDC_NOTERANGE_LABEL2            1053
#define IDC_SCALAR_LIST                 1054
#define IDC_NOTERANGE_LABEL3            1054
#define IDC_VECTOR_LIST                 1055
#define IDC_NOTERANGE_LABEL4            1055
#define IDC_ASGN_CONST                  1056
#define IDC_NOTERANGE_LABEL5            1056
#define IDC_ASGN_CNTRL                  1057
#define IDC_NOTERANGE_LABEL6            1057
#define IDC_NOTERANGE_LABEL7            1058
#define IDC_SUSTAIN_VARIABLE            1059
#define IDC_FUNCTIONS                   1060
#define IDC_MM_LIVEPREROLL              1060
#define IDC_MIDI_USER                   1060
#define IDC_SAVE                        1061
#define IDC_MM_SETS                     1061
#define IDC_MIDI_USERNUM                1061
#define IDC_LOAD                        1062
#define IDC_MIDI_USERNUMSPIN            1062
#define IDC_CUR_ASGN                    1063
#define IDC_JOY_X                       1063
#define IDC_MIDI_SPEED_LABEL2           1063
#define IDC_FUNC_LIST                   1064
#define IDC_JOY_Y                       1064
#define IDC_DELETE_VAR                  1065
#define IDC_JOY_SCALE                   1065
#define IDC_DESCRIPTION                 1066
#define IDC_JOY_SCALESPIN               1066
#define IDC_XTO                         1067
#define IDC_JOY_FLIP                    1067
#define IDC_VEC_X                       1068
#define IDC_XTOSPIN                     1068
#define IDC_JOY_Z                       1068
#define IDC_VEC_Y                       1069
#define IDC_XDAMPING                    1069
#define IDC_MM_PREROLL                  1069
#define IDC_JOY_THROTTLE                1069
#define IDC_VEC_Z                       1070
#define IDC_XDAMPINGSPIN                1070
#define IDC_MM_PREROLLSPIN              1070
#define IDC_JOY_POVH                    1070
#define IDC_OFFSET                      1071
#define IDC_YTO                         1071
#define IDC_MM_IN                       1071
#define IDC_JOY_POVV                    1071
#define IDC_CHANGE_OFFSET               1072
#define IDC_YDAMPING                    1072
#define IDC_MM_INSPIN                   1072
#define IDC_JOY_BUT1                    1072
#define IDC_YTOSPIN                     1073
#define IDC_MM_OUT                      1073
#define IDC_JOY_BUT2                    1073
#define IDC_YDAMPINGSPIN                1074
#define IDC_MM_OUTSPIN                  1074
#define IDC_JOY_BUT3                    1074
#define IDC_ZTO                         1075
#define IDC_REDUCE_THRESH               1075
#define IDC_JOY_BUT4                    1075
#define IDC_MV_CHANPROG1                1075
#define IDC_ZDAMPING                    1076
#define IDC_REDUCE_THRESHSPIN           1076
#define IDC_JOY_SPEED                   1076
#define IDC_MV_CHANBUT1                 1076
#define IDC_ZTOSPIN                     1077
#define IDC_JOY_SPEEDSPIN               1077
#define IDC_MV_CHANPROG2                1077
#define IDC_MIDI_VIEWER                 1077
#define IDC_ZDAMPINGSPIN                1078
#define IDC_MV_CHANBUT2                 1078
#define IDC_MM_AUTOSTART                1078
#define IDC_JOY_TYPEINCDEC              1078
#define IDC_MV_CHANPROG3                1079
#define IDC_MM_STARTSTOPENABLE          1079
#define IDC_JOY_TYPEINC                 1079
#define IDC_MV_CHANBUT3                 1080
#define IDC_JOY_B1                      1080
#define IDC_JOY_TYPEABSOLUTE            1080
#define IDC_MV_CHANPROG4                1081
#define IDC_JOY_B2                      1081
#define IDC_JOY_ACCUM                   1081
#define IDC_MV_CHANBUT4                 1082
#define IDC_JOY_B3                      1082
#define IDC_MV_CHANPROG5                1083
#define IDC_JOY_B4                      1083
#define IDC_MV_CHANBUT5                 1084
#define IDC_MIDI_CHANNEL                1084
#define IDC_MV_CHANPROG6                1085
#define IDC_MIDI_CHANNELSPIN            1085
#define IDC_MV_CHANBUT6                 1086
#define IDC_MIDI_OCTAVE                 1086
#define IDC_PICKPATH                    1087
#define IDC_MV_CHANPROG7                1087
#define IDC_MM_PLAYTEST                 1087
#define IDC_PATHNAME                    1088
#define IDC_MV_CHANBUT7                 1088
#define IDC_TRACKNAME                   1088
#define IDC_MV_CHANPROG8                1089
#define IDC_MIDI_USERNUM_LABEL          1089
#define IDC_MV_CHANBUT8                 1090
#define IDC_MV_CHANPROG9                1091
#define IDC_MIDI_PLAY                   1091
#define IDC_MV_CHANBUT9                 1092
#define IDC_MIDI_PLAYSPIN               1092
#define IDC_MV_CHANPROG10               1093
#define IDC_MIDI_STOP                   1093
#define IDC_MV_CHANBUT10                1094
#define IDC_MIDI_STOPSPIN               1094
#define IDC_MV_CHANPROG11               1095
#define IDC_MIDI_RECORD                 1095
#define IDC_MV_CHANBUT11                1096
#define IDC_MIDI_RECORDSPIN             1096
#define IDC_MV_CHANPROG12               1097
#define IDC_MV_CHANBUT12                1098
#define IDC_XACTIVE                     1099
#define IDC_MV_CHANPROG13               1099
#define IDC_XLIMITED                    1100
#define IDC_MV_CHANBUT13                1100
#define IDC_XEASE                       1101
#define IDC_MV_CHANPROG14               1101
#define IDC_XFROM                       1102
#define IDC_MV_CHANBUT14                1102
#define IDC_XFROMSPIN                   1103
#define IDC_MV_CHANPROG15               1103
#define IDC_YACTIVE                     1104
#define IDC_MV_CHANBUT15                1104
#define IDC_YLIMITED                    1105
#define IDC_MV_CHANPROG16               1105
#define IDC_YFROM                       1106
#define IDC_MV_CHANBUT16                1106
#define IDC_YEASE                       1107
#define IDC_MV_NOTEPROG1                1107
#define IDC_YFROMSPIN                   1108
#define IDC_MV_NOTEPROG2                1108
#define IDC_ZACTIVE                     1109
#define IDC_MV_NOTEPROG3                1109
#define IDC_ZLIMITED                    1110
#define IDC_MV_NOTEPROG4                1110
#define IDC_ZFROM                       1111
#define IDC_MV_NOTEPROG5                1111
#define IDC_ZEASE                       1112
#define IDC_MV_NOTEPROG6                1112
#define IDC_ZFROMSPIN                   1113
#define IDC_MV_NOTEPROG7                1113
#define IDC_MV_NOTEPROG8                1114
#define IDC_MV_NOTEPROG9                1115
#define IDC_MV_NOTEPROG10               1116
#define IDC_MV_NOTEPROG11               1117
#define IDC_MV_NOTEPROG12               1118
#define IDC_MV_OCTAVEBUT1               1119
#define IDC_MV_OCTAVEBUT2               1120
#define IDC_MV_OCTAVEBUT3               1121
#define IDC_MV_OCTAVEBUT4               1122
#define IDC_MV_OCTAVEBUT5               1123
#define IDC_MV_OCTAVEBUT6               1124
#define IDC_MV_OCTAVEBUT7               1125
#define IDC_MV_OCTAVEBUT8               1126
#define IDC_MV_OCTAVEBUT9               1127
#define IDC_MV_OCTAVEBUT10              1128
#define IDC_MV_OCTAVEBUT11              1129
#define IDC_MV_NOTEUSER                 1130
#define IDC_MV_CHAN                     1131
#define IDC_MV_EVENT                    1132
#define IDC_MV_VEL                      1133
#define IDC_MV_NOTE                     1134
#define IDC_MIDI_PRESETS                1135
#define IDC_INC_BINDING                 1136
#define IDC_JOY_DIRX                    1137
#define IDC_CLEAR_INC_BINDING           1138
#define IDC_JOY_DIRY                    1139
#define IDC_JOY_DIRZ                    1140
#define IDC_JOY_COMPX                   1141
#define IDC_JOY_COMPY                   1142
#define IDC_JOY_COMPZ                   1143
#define IDC_BASED_ON_DIR_LABEL          1144
#define IDC_JOY_DIRLABEL                1145
#define IDC_JOY_COMPLABEL               1146
#define IDC_JOY_CONTLABEL               1147
#define IDC_EULER_X                     1149
#define IDC_MM_START                    1149
#define IDC_EULER_Y                     1150
#define IDC_MM_LIVE                     1150
#define IDC_EULER_Z                     1151
#define IDC_NOISE_XSTRENGTH             1151
#define IDC_MM_STOP                     1151
#define IDC_NOISE_XSTRENGTHSPIN         1152
#define IDC_MM_ALL                      1152
#define IDC_NOISE_FREQ                  1153
#define IDC_MM_INVERT                   1153
#define IDC_NOISE_FREQSPIN              1154
#define IDC_MM_NONE                     1154
#define IDC_NOISE_YSTRENGTH             1155
#define IDC_MM_DELSET                   1155
#define IDC_EXPR_CONST                  1156
#define IDC_NOISE_YSTRENGTHSPIN         1156
#define IDC_EXPR_CONST_SPIN             1157
#define IDC_NOISE_SEED                  1157
#define IDC_VEC_Z_SPIN                  1158
#define IDC_NOISE_SEEDSPIN              1158
#define IDC_VEC_Y_SPIN                  1159
#define IDC_NOISE_ZSTRENGTH             1159
#define IDC_NOISE_ZSTRENGTHSPIN         1160
#define IDC_VEC_X_SPIN                  1161
#define IDC_NOISE_ROUGH                 1161
#define IDC_NOISE_ROUGHSPIN             1162
#define IDC_NOISE_RAMPIN                1163
#define IDC_NOISE_RAMPINSPIN            1164
#define IDC_NOISE_RAMPOUT               1165
#define IDC_NOISE_RAMPOUTSPIN           1166
#define IDC_PATH_FOLLOW                 1200
#define IDC_PATH_BANK                   1201
#define IDC_FOLLOW_BANKSPIN             1202
#define IDC_FOLLOW_BANK                 1203
#define IDC_FOLLOW_BANKLABEL            1204
#define IDC_FOLLOW_TRACK                1205
#define IDC_FOLLOW_TRACKSPIN            1206
#define IDC_FOLLOW_TRACKLABEL           1207
#define IDC_NOISE_XSTRENGTHLABEL        1210
#define IDC_NOISE_YSTRENGTHLABEL        1211
#define IDC_NOISE_ZSTRENGTHLABEL        1212
#define IDC_NOISE_FRACTAL               1213
#define IDC_NOISE_ROUGHLABEL            1214
#define IDC_NOISE_GRAPH                 1215
#define IDC_NOISE_ZSTRENGTHLABEL2       1216
#define IDC_NOISE_ZSTRENGTHLABEL3       1217
#define IDC_NOISE_XLIM0                 1506
#define IDC_NOISE_YLIM0                 1507
#define IDC_NOISE_ZLIM0                 1508
#define IDC_JP_XFROMLABEL               1534
#define IDC_JP_XTOLABEL                 1535
#define IDC_JP_YFROMLABEL               1536
#define IDC_JP_ZFROMLABEL               1537
#define IDC_JP_YTOLABEL                 1538
#define IDC_JP_ZTOLABEL                 1539
#define IDC_JP_XDAMPINGLABEL            1549
#define IDC_JP_YDAMPINGLABEL            1550
#define IDS_STATIC                      1550
#define IDC_JP_ZDAMPINGLABEL            1551
#define IDS_DB_EXPR_PARSE_ERROR         20280
#define IDS_DB_DUPNAME                  20281
#define IDS_DB_CANT_CREATE_VAR          20282
#define IDS_DB_NOSUCH                   20283
#define IDS_DB_CANT_CHANGE_OFFSET       20284
#define IDS_DB_NOCURVAR                 20285
#define IDS_DB_CANTDELETE               20286
#define IDS_DB_EXPRCNTL                 20287
#define IDS_DB_NOTHINGDEL               20288
#define IDS_DB_XPR_FILES                20289
#define IDS_DB_BAD_NAME                 20552
#define IDS_DB_POSITION_EXPR            20553
#define IDS_DB_POINT3_EXPR              20554
#define IDS_DB_FLOAT_EXPR               20555
#define IDS_DB_SCALE_EXPR               20556
#define IDS_DB_ROTATION_EXPR            20557
#define IDS_DB_CIRCULAR_DEPENDENCY      20558
#define IDS_DB_CANT_ASSIGN              20559
#define IDS_DB_NEED_VECTOR              20560
#define IDS_DB_NEED_SCALAR              20561
#define IDS_DB_SAVE_EXPR                20562
#define IDS_DB_LOAD_EXPR                20563
#define IDS_RB_PERCENT                  30135
#define IDS_RB_PATHPARAMS               30136
#define IDS_RB_NONE                     30137
#define IDS_RB_MOTIONCAPTURE            30138
#define IDS_RB_NOTRACKSON               30139
#define IDS_RB_NOTIME                   30140
#define IDS_RB_PICKBINDING              30141
#define IDS_RB_MIDI                     30142
#define IDS_RB_NODEVICE                 30143
#define IDS_RB_MIDIDEVICE_ERROR         30144
#define IDS_RB_JOYDEVICE                30145
#define IDS_RB_JOYX                     30146
#define IDS_RB_JOYY                     30147
#define IDS_RB_ROTJOINTPARAMS           30148
#define IDS_RB_NOMIDIDEVICES            30148
#define IDS_RB_MIDIVIEWER               30149
#define IDS_RB_MEDIACONTROLSTATION      30150
#define IDS_RB_PATHJOINTPARAMS          30151
#define IDS_RB_CUSTOM                   30151
#define IDS_LIB_DESCRIPTION             30152
#define IDS_RB_STRENGTH                 30247
#define IDS_RB_PATH                     30532
#define IDS_RB_EULERXYZ                 30533
#define IDS_RB_EULERPARAMS              30534
#define IDS_RB_XROTATION                30535
#define IDS_RB_YROTATION                30536
#define IDS_RB_ZROTATION                30537
#define IDS_RB_NOISEFLOAT               30538
#define IDS_RB_NOISEPOSITION            30539
#define IDS_RB_NOISEPOINT3              30540
#define IDS_RB_NOISEROTATION            30541
#define IDS_RB_NOISESCALE               30542
#define IDS_RB_PATHCONTROLLER           30625
#define IDS_RB_ILLEGALPATH              30626
#define IDS_RB_NOISECONTROLTITLE        30655
#define IDS_RB_EXPRESSIONCONTROLTITLE   30656
#define IDS_RB_PICKPATH                 30663
#define IDS_DB_FN_SIN                   30664
#define IDS_DB_FN_NOISE                 30665
#define IDS_DB_FN_IF                    30666
#define IDS_DB_FN_MIN                   30667
#define IDS_DB_FN_MAX                   30668
#define IDS_DB_FN_POW                   30669
#define IDS_DB_FN_MOD                   30670
#define IDS_DB_FN_DEGTORAD              30671
#define IDS_DB_FN_RADTODEG              30672
#define IDS_DB_FN_COS                   30673
#define IDS_DB_FN_TAN                   30674
#define IDS_DB_FN_ASIN                  30675
#define IDS_DB_FN_ACOS                  30676
#define IDS_DB_FN_ATAN                  30677
#define IDS_DB_FN_SINH                  30678
#define IDS_DB_FN_COSH                  30679
#define IDS_DB_FN_TANH                  30680
#define IDS_DB_FN_LN                    30681
#define IDS_DB_FN_LOG                   30682
#define IDS_DB_FN_EXP                   30683
#define IDS_DB_FN_SQRT                  30684
#define IDS_DB_FN_ABS                   30685
#define IDS_DB_FN_CEIL                  30686
#define IDS_DB_FN_FLOOR                 30687
#define IDS_DB_FN_COMP                  30688
#define IDS_DB_FN_UNIT                  30689
#define IDS_DB_FN_LENGTH                30690
#define IDS_DB_FN_PI                    30691
#define IDS_DB_FN_E                     30692
#define IDS_DB_FN_TPS                   30693
#define IDS_DB_FN_VIF                   30694

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        111
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1148
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\mckbddev\mckbddev.h ===
/**********************************************************************
 *<
	FILE: mckbddev.h

	DESCRIPTION:

	CREATED BY: Christer Janson

	HISTORY:

 *>	Copyright (c) 1999, All Rights Reserved.
 **********************************************************************/

#ifndef __MCKBDDEV__H
#define __MCKBDDEV__H

#include "Max.h"
#include "utilapi.h"
#include "resource.h"

extern ClassDesc* GetKbdDeviceClassDesc();
extern ClassDesc* GetKbdBindingClassDesc();

TCHAR *GetString(int id);
extern HINSTANCE hInstance;

#endif // __MCKBDDEV__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\mckbddev\mckbddev.cpp ===
/**********************************************************************
 *<
	FILE: kbddev.cpp

	DESCRIPTION: Keyboard device driver for motion capture system

	CREATED BY: Christer Janson

	HISTORY: May 21, 1997

 *>     Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "mckbddev.h"
#include "mcapdev.h"

HINSTANCE	hInstance;
int			controlsInit = FALSE;

#define KBD_DEVICE_CLASS_ID			Class_ID(0x3b5228b8, 0x18377f5b)
#define KBD_DEVICEBINDING_CLASS_ID	Class_ID(0x4cd34d1d, 0x4d50722f)

static MCInputDevice *GetKbdDevice();

static void InitEnvelopeImage(HINSTANCE hInst);

class KbdDeviceBinding : public MCDeviceBinding {
	public:
		float	attack;
		float	decay;
		float	sustain;
		float	release;
		float	scale;
		float	timeScale;
		USHORT	nVKey;

		int		pressStatus;
		float	valueWhenStatusChanged;
		float	curValue;

		KbdDeviceBinding();
		MCInputDevice	*GetDevice() {return GetKbdDevice();}
		TSTR	BindingName();
		float	Eval(int time);
		void	DeleteThis() {delete this;}
		Class_ID	ClassID() {return KBD_DEVICEBINDING_CLASS_ID;}
		RefTargetHandle	Clone(RemapDir& remap);

		IOResult	Save(ISave *isave);
		IOResult	Load(ILoad *iload);

		void	AddRollup(IMCParamDlg *dlg);
		void	UpdateRollup(IRollupWindow *iRoll);
		void	BeginActivate(BOOL reset);
		void	EndActivate();

		void	AssignKey(HWND hParent);
		TCHAR*	GetVKeyName(USHORT vKey);
};

#define ELEMENTS(array) (sizeof(array)/sizeof((array)[0]))

struct VKeyStatus {
	USHORT	vKey;
	BOOL	bPressed;
	UINT	nActionTime;
	UINT	nLastSample;
};

struct VKey {
	USHORT	vkey;
	char*	name;
	int		nameRes;
};

VKey KeyList[] = {
	186,        _T(";"),	0,
	187,        _T("="),	0,
	188,        _T(","),	0,
	189,        _T("-"),	0,
	190,        _T("."),	0,
	191,        _T("/"),	0,
	192,        _T("`"),	0,
	219,        _T("["),	0,
	220,        _T("\\"),	0,
	221,        _T("]"),	0,
	222,        _T("\'"),	0,
	VK_BACK,	NULL,	IDS_KBD_KEYNAME_BACKSPACE,
	VK_SPACE,	NULL,	IDS_KBD_KEYNAME_SPACE,
	VK_PRIOR,	NULL,	IDS_KBD_KEYNAME_PGUP,
	VK_NEXT,	NULL,	IDS_KBD_KEYNAME_PGDN,
	VK_END,		NULL,	IDS_KBD_KEYNAME_END,
	VK_HOME,	NULL,	IDS_KBD_KEYNAME_HOME,
	VK_LEFT,	NULL,	IDS_KBD_KEYNAME_LEFTARROW,
	VK_UP,		NULL,	IDS_KBD_KEYNAME_UPARROW,
	VK_RIGHT,	NULL,	IDS_KBD_KEYNAME_RIGHTARROW,
	VK_DOWN,	NULL,	IDS_KBD_KEYNAME_DOWNARROW,
	VK_INSERT,	NULL,	IDS_KBD_KEYNAME_INSERT,
	VK_DELETE,	NULL,	IDS_KBD_KEYNAME_DELETE,
	VK_NUMPAD0,	NULL,	IDS_KBD_KEYNAME_NUMPAD0,
	VK_NUMPAD1,	NULL,	IDS_KBD_KEYNAME_NUMPAD1,
	VK_NUMPAD2,	NULL,	IDS_KBD_KEYNAME_NUMPAD2,
	VK_NUMPAD3,	NULL,	IDS_KBD_KEYNAME_NUMPAD3,
	VK_NUMPAD4,	NULL,	IDS_KBD_KEYNAME_NUMPAD4,
	VK_NUMPAD5,	NULL,	IDS_KBD_KEYNAME_NUMPAD5,
	VK_NUMPAD6,	NULL,	IDS_KBD_KEYNAME_NUMPAD6,
	VK_NUMPAD7,	NULL,	IDS_KBD_KEYNAME_NUMPAD7,
	VK_NUMPAD8,	NULL,	IDS_KBD_KEYNAME_NUMPAD8,
	VK_NUMPAD9,	NULL,	IDS_KBD_KEYNAME_NUMPAD9,
	VK_MULTIPLY,NULL,	IDS_KBD_KEYNAME_GREYSTAR,
	VK_ADD,		NULL,	IDS_KBD_KEYNAME_GREYPLUS,
	VK_SUBTRACT,NULL,	IDS_KBD_KEYNAME_GREYMINUS,
	VK_DECIMAL,	NULL,	IDS_KBD_KEYNAME_GREYDOT,
	VK_DIVIDE,	NULL,	IDS_KBD_KEYNAME_GREYSLASH,
	VK_F1,		NULL,	IDS_KBD_KEYNAME_F1,
	VK_F2,		NULL,	IDS_KBD_KEYNAME_F2,
	VK_F3,		NULL,	IDS_KBD_KEYNAME_F3,
	VK_F4,		NULL,	IDS_KBD_KEYNAME_F4,
	VK_F5,		NULL,	IDS_KBD_KEYNAME_F5,
	VK_F6,		NULL,	IDS_KBD_KEYNAME_F6,
	VK_F7,		NULL,	IDS_KBD_KEYNAME_F7,
	VK_F8,		NULL,	IDS_KBD_KEYNAME_F8,
	VK_F9,		NULL,	IDS_KBD_KEYNAME_F9,
	VK_F10,		NULL,	IDS_KBD_KEYNAME_F10,
	VK_F11,		NULL,	IDS_KBD_KEYNAME_F11,
	VK_F12,		NULL,	IDS_KBD_KEYNAME_F12,
};

typedef Tab<VKeyStatus*> VKeyStatusTab;

class KbdDevice : public MCInputDevice {
	public:
		BOOL	active;
		CRITICAL_SECTION	csect;

		KbdDevice();
		~KbdDevice();

		TSTR DeviceName()	{return GetString(IDS_KBD_DEVICENAME);}
		MCDeviceBinding	*CreateBinding() {return new KbdDeviceBinding;}

		void	Cycle(UINT tick);

		void	AppendVKey(USHORT vKey);
		void	RemoveVKey(USHORT vKey);
		VKeyStatus*	QueryVKey(USHORT vKey);

	private:
		VKeyStatusTab	vKeyTab;
};

//--- Class Descriptors -----------------------------------------------

// ClassDesc for Device Binding
class KbdDeviceBindingClassDesc:public ClassDesc {
	public:
	int				IsPublic() {return 0;}
	void*			Create(BOOL loading) {return new KbdDeviceBinding;}
	const TCHAR*	ClassName() {return GetString(IDS_KBD_DEVICENAME);}
	SClass_ID		SuperClassID() {return MOT_CAP_DEVBINDING_CLASS_ID;}
	Class_ID		ClassID() {return KBD_DEVICEBINDING_CLASS_ID;}
	const TCHAR*	Category() {return _T("");}
};

static KbdDeviceBindingClassDesc kbdBindCD;
ClassDesc* GetKbdBindingClassDesc() {return &kbdBindCD;}

// ClassDesc for Device
class KbdDeviceClassDesc:public ClassDesc {
	public:
	int				IsPublic() {return 1;}
	void*			Create(BOOL loading) {return GetKbdDevice();}
	const TCHAR*	ClassName() {return GetString(IDS_KBD_DEVICENAME);}
	SClass_ID		SuperClassID() {return MOT_CAP_DEV_CLASS_ID;}
	Class_ID		ClassID() {return KBD_DEVICE_CLASS_ID;}
	const TCHAR*	Category() {return _T("");}
};

static KbdDeviceClassDesc kbdCD;
ClassDesc* GetKbdDeviceClassDesc() {return &kbdCD;}


//--- Kbd device binding ---------------------------------------------------

static BOOL CALLBACK KbdDeviceDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

static KbdDevice theKbdDevice;
MCInputDevice *GetKbdDevice() {return &theKbdDevice;}

KbdDeviceBinding::KbdDeviceBinding() 
{
	// Setup default values
	attack = 0.2f;
	decay = 0.0f;
	sustain = 1.0f;
	release = 0.2f;
	scale = 10.0f;
	timeScale = 1.0f;
	nVKey = 0;
}

TSTR KbdDeviceBinding::BindingName() 
{
	TSTR bindStr;
	TSTR keyStr = GetString(IDS_KBD_KEY);

	if (nVKey == 0) {
		bindStr.printf("%s: %s", keyStr, GetString(IDS_KBD_UNASSIGNED));
	}
	else {
		bindStr.printf("%s: %s", keyStr, GetVKeyName(nVKey));
	}

	return bindStr;
}


float KbdDeviceBinding::Eval(int time)
{
	// Query the device for the status of this vkey
	VKeyStatus* pVks = theKbdDevice.QueryVKey(nVKey);

	if (!pVks)
		return 0.0f;

	// Get the time since the last press/release
	float deltaT = (pVks->nLastSample - pVks->nActionTime)/(timeScale*1000.0f);
	
	// When the press/release status changes, we save off the value.
	// This lets us start attach/release slopes from the current value
	// instead of always starting from 0 or sustain.
	if (pVks->bPressed != pressStatus) {
		pressStatus = pVks->bPressed;
		valueWhenStatusChanged = curValue;
	}

	// Here we're bringing down attack with the time it [would have] taken
	// to get to the current value.
	float usedAttack = attack*(1-valueWhenStatusChanged);

	if (pVks->bPressed) {
		if (deltaT < usedAttack) {
			// Attack in progress
			curValue = deltaT/(usedAttack)*(1-valueWhenStatusChanged)+valueWhenStatusChanged;
		}
		else if (deltaT < (usedAttack+decay)) {
			// Decay in progress
			curValue = 1.0f-(deltaT-usedAttack)/decay*(1-sustain);
		}
		else {
			// Sustain ongoing
			curValue = sustain;
		}
	}
	else {
		if (deltaT < release && pVks->nActionTime > 0) {
			// releasing...
			curValue = valueWhenStatusChanged-deltaT/release;
		}
		else {
			curValue = 0.0f;
		}
	}

	// This shouldn't really be needed, but if somethinmg goes terribly wrong,
	// it shouldn't affect the user too much.
	if (curValue<0.0f)
		curValue = 0.0f;

	if (curValue>1.0f)
		curValue = 1.0f;

	return curValue*scale;
}

RefTargetHandle KbdDeviceBinding::Clone(RemapDir& remap)
{
	KbdDeviceBinding *b = new KbdDeviceBinding;
	b->attack = attack;
	b->decay = decay;
	b->sustain = sustain;
	b->release = release;
	b->scale = scale;
	b->timeScale = timeScale;
	b->nVKey = nVKey;
	return b;
}

void KbdDeviceBinding::BeginActivate(BOOL reset)
{
	// Initialize at startup.
	pressStatus = -1;
	valueWhenStatusChanged = 0.0f;
	curValue = 0.0f;

	theKbdDevice.active = TRUE;
	theKbdDevice.AppendVKey(nVKey);
	DisableAccelerators();
}

void KbdDeviceBinding::EndActivate()
{
	theKbdDevice.active = FALSE;
	theKbdDevice.RemoveVKey(nVKey);
	EnableAccelerators();
}


void KbdDeviceBinding::AddRollup(IMCParamDlg *dlg)
{
	InitEnvelopeImage(hInstance);

	dlg->iRoll->AppendRollup(
			hInstance, 
			MAKEINTRESOURCE(IDD_MC_KBD), 
			KbdDeviceDlgProc, 
			GetString(IDS_KBD_DEVICENAME),
			(LPARAM)dlg);
}

void KbdDeviceBinding::UpdateRollup(IRollupWindow *iRoll)
{
	if (iRoll->GetNumPanels()>1) {
		HWND hWnd = iRoll->GetPanelDlg(1);
		
		if (hWnd) {
			ISpinnerControl *spin;
			spin = GetISpinner(GetDlgItem(hWnd,IDC_KBD_ATTACKSPIN));
			spin->SetLimits(0.0f, 1.0f, FALSE);
			spin->SetScale(0.01f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_KBD_ATTACK), EDITTYPE_FLOAT);
			spin->SetValue(attack,FALSE);
			ReleaseISpinner(spin);

			spin = GetISpinner(GetDlgItem(hWnd,IDC_KBD_DECAYSPIN));
			spin->SetLimits(0.0f, 1.0f, FALSE);
			spin->SetScale(0.01f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_KBD_DECAY), EDITTYPE_FLOAT);
			spin->SetValue(decay,FALSE);
			ReleaseISpinner(spin);

			spin = GetISpinner(GetDlgItem(hWnd,IDC_KBD_SUSTAINSPIN));
			spin->SetLimits(0.0f, 1.0f, FALSE);
			spin->SetScale(0.01f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_KBD_SUSTAIN), EDITTYPE_FLOAT);
			spin->SetValue(sustain,FALSE);
			ReleaseISpinner(spin);

			spin = GetISpinner(GetDlgItem(hWnd,IDC_KBD_RELEASESPIN));
			spin->SetLimits(0.0f, 1.0f, FALSE);
			spin->SetScale(0.01f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_KBD_RELEASE), EDITTYPE_FLOAT);
			spin->SetValue(release,FALSE);
			ReleaseISpinner(spin);

			spin = GetISpinner(GetDlgItem(hWnd,IDC_KBD_SCALESPIN));
			spin->SetLimits(float(-999999), float(999999), FALSE);
			spin->SetAutoScale(TRUE);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_KBD_SCALE), EDITTYPE_FLOAT);
			spin->SetValue(scale,FALSE);
			ReleaseISpinner(spin);

			spin = GetISpinner(GetDlgItem(hWnd,IDC_KBD_TIMESCALESPIN));
			spin->SetLimits(float(0.01), float(999999), FALSE);
			spin->SetAutoScale(TRUE);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_KBD_TIMESCALE), EDITTYPE_FLOAT);
			spin->SetValue(timeScale,FALSE);
			ReleaseISpinner(spin);

			InvalidateRect(GetDlgItem(hWnd, IDC_KBD_ENVGRAPH), NULL, FALSE);

			int numElems = ELEMENTS(KeyList);
			int idx;
			SendMessage(GetDlgItem(hWnd, IDC_KBD_KEYEDIT), CB_RESETCONTENT, 0, 0);
			for (int i=0; i<numElems; i++) {
				// A little kludgy, but so what. I only want keys that has a resource in the drop down.
				// The rest of the entries in the KeyList are for displaying the key after it's been pressed.
				// By doing it this way I can do it with one list.
				if (KeyList[i].nameRes != 0) {
					idx = SendMessage(GetDlgItem(hWnd, IDC_KBD_KEYEDIT), CB_ADDSTRING, 0, (LPARAM)GetVKeyName(KeyList[i].vkey));
					SendMessage(GetDlgItem(hWnd, IDC_KBD_KEYEDIT), CB_SETITEMDATA, idx, (LPARAM)KeyList[i].vkey);
				}
			}

			// Display the configured key
			SendMessage(GetDlgItem(hWnd, IDC_KBD_KEYEDIT), WM_SETTEXT, 0, (LPARAM)GetVKeyName(nVKey));
		}
	}
}

TCHAR* KbdDeviceBinding::GetVKeyName(USHORT vKey)
{
	static TCHAR keyName[10];

	if (vKey == 0) {
		return GetString(IDS_KBD_UNASSIGNED);
	}

	int numElems = ELEMENTS(KeyList);
	for (int i=0; i<numElems; i++) {
		if (vKey == KeyList[i].vkey) {
			if (KeyList[i].name) {
				// A special key < 32
				return KeyList[i].name;
			}
			else {
				// A named key
				return GetString(KeyList[i].nameRes);
			}
		}
	}

	// If it is none of the above, it's a letter or character.
	// Just display the character as is.

	_stprintf(keyName, _T("%c"), vKey);
	return keyName;
}


static BOOL CALLBACK KbdDeviceDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	IMCParamDlg *dlg = (IMCParamDlg*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!dlg && msg!=WM_INITDIALOG) return FALSE;
	KbdDeviceBinding *b;
	if (dlg) b = (KbdDeviceBinding*)dlg->binding;

	switch (msg) {
		case WM_INITDIALOG:
			dlg = (IMCParamDlg*)lParam;
			b = (KbdDeviceBinding*)dlg->binding;
			b->UpdateRollup(dlg->iRoll);
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			SetWindowLong(GetDlgItem(hWnd,IDC_KBD_ENVGRAPH),GWL_USERDATA,lParam);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_KBD_KEYBTN:
					b->AssignKey(hWnd);
					// Need to tell Manager that key has changed
					// so that the label can be updated
					b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);                                   
					break;                                                          
				case IDC_KBD_KEYEDIT:
					switch(HIWORD(wParam)) {
						case CBN_SETFOCUS:
							DisableAccelerators();
							break;
						case CBN_KILLFOCUS:
							EnableAccelerators();
							break;
						case CBN_SELENDOK: {
							int idx = SendMessage((HWND)lParam, CB_GETCURSEL, 0, 0);
							b->nVKey = (USHORT)SendMessage((HWND)lParam, CB_GETITEMDATA, idx, 0);
							// Need to tell Manager that key has changed
							// so that the label can be updated
							b->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
							break;
						}
						case CBN_EDITCHANGE:
							SendMessage(GetDlgItem(hWnd, IDC_KBD_KEYEDIT), WM_SETTEXT, 0, (LPARAM)b->GetVKeyName(b->nVKey));
							break;
					}
				}
			break;
		case CC_SPINNER_CHANGE: {
			ISpinnerControl *spin = (ISpinnerControl *)lParam;
			switch (LOWORD(wParam)) {
				case IDC_KBD_ATTACKSPIN:
					b->attack = spin->GetFVal();
					break;
				case IDC_KBD_DECAYSPIN:
					b->decay = spin->GetFVal();
					break;
				case IDC_KBD_SUSTAINSPIN:
					b->sustain = spin->GetFVal();
					break;
				case IDC_KBD_RELEASESPIN:
					b->release = spin->GetFVal();
					break;
				case IDC_KBD_SCALESPIN:
					b->scale = spin->GetFVal();
					break;
				case IDC_KBD_TIMESCALESPIN:
					b->timeScale = spin->GetFVal();
					break;
				}
				// Since we don't register for undo, we need this:
				SetSaveRequiredFlag(TRUE);

				InvalidateRect(GetDlgItem(hWnd, IDC_KBD_ENVGRAPH), NULL, TRUE);
			break;
			}

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:                      
			dlg->iRoll->DlgMouseMessage(hWnd,msg,wParam,lParam);
			break; 

		default:
			return FALSE;
		}
	return TRUE;
	}


#define ATTACK_CHUNK_ID		0x0100
#define DECAY_CHUNK_ID		0x0200
#define SUSTAIN_CHUNK_ID	0x0300
#define RELEASE_CHUNK_ID	0x0400
#define SCALE_CHUNK_ID		0x0500
#define TIMESCALE_CHUNK_ID	0x0550
#define VKEY_CHUNK_ID		0x0600

IOResult KbdDeviceBinding::Save(ISave *isave)
{
	ULONG nb;       

	isave->BeginChunk(ATTACK_CHUNK_ID);
	isave->Write(&attack,sizeof(attack),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(DECAY_CHUNK_ID);
	isave->Write(&decay,sizeof(decay),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(SUSTAIN_CHUNK_ID);
	isave->Write(&sustain,sizeof(sustain),&nb);
	isave->EndChunk();

	isave->BeginChunk(RELEASE_CHUNK_ID);
	isave->Write(&release,sizeof(release),&nb);
	isave->EndChunk();

	isave->BeginChunk(SCALE_CHUNK_ID);
	isave->Write(&scale,sizeof(scale),&nb);
	isave->EndChunk();

	isave->BeginChunk(TIMESCALE_CHUNK_ID);
	isave->Write(&timeScale,sizeof(timeScale),&nb);
	isave->EndChunk();

	isave->BeginChunk(VKEY_CHUNK_ID);
	isave->Write(&nVKey,sizeof(nVKey),&nb);
	isave->EndChunk();

	return IO_OK;
}

IOResult KbdDeviceBinding::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case ATTACK_CHUNK_ID:
				res=iload->Read(&attack,sizeof(attack),&nb);
				break;

			case DECAY_CHUNK_ID:
				res=iload->Read(&decay,sizeof(decay),&nb);
				break;

			case SUSTAIN_CHUNK_ID:
				res=iload->Read(&sustain,sizeof(sustain),&nb);
				break;

			case RELEASE_CHUNK_ID:
				res=iload->Read(&release,sizeof(release),&nb);
				break;

			case SCALE_CHUNK_ID:
				res=iload->Read(&scale,sizeof(scale),&nb);
				break;

			case TIMESCALE_CHUNK_ID:
				res=iload->Read(&timeScale,sizeof(timeScale),&nb);
				break;

			case VKEY_CHUNK_ID:
				res=iload->Read(&nVKey,sizeof(nVKey),&nb);
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
	}
	return IO_OK;
}




//--- KbdDevice --------------------------------------------------

KbdDevice::KbdDevice()
{
	InitializeCriticalSection(&csect);
	active = FALSE;
}

KbdDevice::~KbdDevice()
{
	DeleteCriticalSection(&csect);
}

void KbdDevice::AppendVKey(USHORT vKey)
{
	EnterCriticalSection(&csect);
	
	// No need to append the same key twice.
	// If one binding adds the device, many bindings can read
	// the key afterwards.
	BOOL bKeyExist = FALSE;
	for (int i=0; i<vKeyTab.Count(); i++) {
		if (vKeyTab[i]->vKey == vKey) {
			bKeyExist = TRUE;
			break;
		}
	}
		
	if (!bKeyExist) {
		VKeyStatus* pVks = new VKeyStatus;
		pVks->vKey = vKey;
		pVks->bPressed = FALSE;
		pVks->nActionTime = 0;
		pVks->nLastSample = 0;
		vKeyTab.Append(1, &pVks, 10);
	}

	LeaveCriticalSection(&csect);
}

void KbdDevice::RemoveVKey(USHORT nVKey)
{
	EnterCriticalSection(&csect);

	// Step through and delete the specified key entry.
	// Abort when we find one since we don't add duplicates.
	// Also, make sure not to complain if it's not found,
	// since this will happen when multiple device bindings
	// requests (thus deletes) the same key.
	for (int i=0; i<vKeyTab.Count(); i++) {
		VKeyStatus* pVks = vKeyTab[i];
		if (pVks->vKey == nVKey) {
			vKeyTab.Delete(i, 1);
			delete pVks;
			break;
		}
	}
	
	LeaveCriticalSection(&csect);
}

VKeyStatus* KbdDevice::QueryVKey(USHORT vKey)
{
	VKeyStatus* pVks = NULL;
	
	EnterCriticalSection(&csect);
	
	for (int i=0; i<vKeyTab.Count(); i++) {
		if (vKeyTab[i]->vKey == vKey) {
			pVks = vKeyTab[i];
			break;
		}
	}

	LeaveCriticalSection(&csect);
	
	return pVks;
}

void KbdDevice::Cycle(UINT tick)
{
	int i, numKeys;
	VKeyStatus* pVks;
	USHORT nStatus;

	if (!active)
		return;

	numKeys = vKeyTab.Count();
		
	EnterCriticalSection(&csect);
	for (i=0; i<numKeys; i++) {
		pVks = vKeyTab[i];
	
		pVks->nLastSample = tick;

		nStatus = GetAsyncKeyState(pVks->vKey);
		if (nStatus & 0x8000) {
			if (!pVks->bPressed) {
				pVks->bPressed = TRUE;
				pVks->nActionTime = tick;
			}
		}
		else {
			if (pVks->bPressed) {
				pVks->bPressed = FALSE;
				pVks->nActionTime = tick;
			}
		}
	}
	LeaveCriticalSection(&csect);	
}


//--- Envelope Graph ---------------------------------------------

static LRESULT CALLBACK EnvelopeImageWinProc( 
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

static void InitEnvelopeImage(HINSTANCE hInst)
{
	static BOOL init = FALSE;
	if (init) return;
	else init = TRUE;

	WNDCLASS wc;
	wc.style         = 0;
    wc.hInstance     = hInst;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName  = NULL;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = EnvelopeImageWinProc;
    wc.lpszClassName = _T("EnvelopeImage");

	RegisterClass(&wc);	
}

static void DrawEnvelopeImage(KbdDeviceBinding* b,HWND hWnd,HDC hdc)
{
	Rect rect, orect;

	if (!b) return;

	GetClientRect(hWnd,&rect);

	orect = rect;

	rect.top += 4;
	rect.left += 4;
	rect.right -= 4;
	rect.bottom -= 4;

	float ySize = (float)(rect.bottom-rect.top);
	float MaxLevel = (rect.right-rect.left) / 4.0f;

	int Attack = (int)(MaxLevel*b->attack) + rect.left;
	int Decay = (int)(MaxLevel*b->decay + Attack);
	int Sustain = (int)(ySize - ySize * b->sustain + rect.top);
	int Release = (int)(rect.right - MaxLevel*b->release);

	SelectObject(hdc,CreatePen(PS_SOLID,0,RGB(10, 10, 10)));
	MoveToEx(hdc, rect.left, rect.bottom, NULL);
	LineTo(hdc, Attack, rect.top);
	LineTo(hdc, Decay, Sustain);
	LineTo(hdc, Release, Sustain);
	LineTo(hdc, rect.right, rect.bottom);

	DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));

	WhiteRect3D(hdc,orect,TRUE);
}

static LRESULT CALLBACK EnvelopeImageWinProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	IMCParamDlg *dlg = (IMCParamDlg*)GetWindowLong(hWnd,GWL_USERDATA);
	KbdDeviceBinding *b;
	if (dlg) {
		b = (KbdDeviceBinding*)dlg->binding;
	}

	switch (msg) {
		case WM_PAINT: {
			PAINTSTRUCT ps;
			HDC hdc = BeginPaint(hWnd,&ps);
			DrawEnvelopeImage(b,hWnd,hdc);
			EndPaint(hWnd,&ps);
			break;
			}

		default:
			return DefWindowProc(hWnd,msg,wParam,lParam);
	}
	
	return 0;
}


//--- Key Assignment ---------------------------------------------

static int vKey, kFlags;
static WNDPROC oldButtonProc;

BOOL CALLBACK newButtonProc(HWND hButton, UINT iMsg, UINT wParam, LONG lParam)
{
	switch(iMsg) {
	case WM_CREATE:
		kFlags = vKey = 0;
		break;
	case WM_SYSKEYDOWN:
	case WM_KEYDOWN:
		switch(wParam) {
		case VK_NUMLOCK:
		case VK_CAPITAL:
		case VK_CLEAR:
		case VK_SCROLL:
		case VK_PAUSE:
		case VK_F1:
		case VK_BACK:
		case VK_DELETE:
			return 0;
		case VK_MENU:
			kFlags |= FALT;
			return 0;
		case VK_SHIFT:
			kFlags |= FSHIFT;
			return 0;
		case VK_CONTROL:
			kFlags |= FCONTROL;
			return 0;
		default:
			if(GetKeyState(VK_MENU) & 0x8000)
				kFlags |= FALT;
			vKey = wParam;
			SendMessage(GetParent(hButton), WM_COMMAND, IDOK, 0);
		}
		return 0;
	case WM_SYSKEYUP:
	case WM_KEYUP:
		switch(wParam) {
		case VK_MENU:
			kFlags &= ~FALT;
			return 0;
		case VK_SHIFT:
			kFlags &= ~FSHIFT;
			return 0;
		case VK_CONTROL:
			kFlags &= ~FCONTROL;
			return 0;
		}
		return 0;
	case WM_SYSCHAR:
	case WM_SYSCOMMAND:
		return 0;
	}
	return CallWindowProc(oldButtonProc, hButton, iMsg, wParam, lParam);
}

BOOL CALLBACK KeyPressProc(HWND hDlg, UINT iMsg, UINT wParam, LONG lParam)
{
    switch (iMsg)  {
		case WM_INITDIALOG:
			CenterWindow(hDlg, GetWindow(hDlg, GW_OWNER));
			oldButtonProc = (WNDPROC)GetWindowLong(GetDlgItem(hDlg, ID_FILE_EXIT), GWL_WNDPROC);
			SetWindowLong(GetDlgItem(hDlg, ID_FILE_EXIT), GWL_WNDPROC, (LONG)newButtonProc);
			SetFocus(GetDlgItem(hDlg, ID_FILE_EXIT));
			return TRUE;
		case WM_COMMAND:
			switch (LOWORD(wParam))  {
			case IDOK:
				EndDialog(hDlg, TRUE);
				break;
			case ID_FILE_EXIT:
				EndDialog(hDlg, FALSE);
				break;
			case IDCANCEL:
				EndDialog(hDlg, FALSE);
				break;
			}
			break;
    }
    return FALSE;
}



void KbdDeviceBinding::AssignKey(HWND hParent)
{
	if (DialogBox(hInstance, MAKEINTRESOURCE(IDD_KBD_KEYPRESSDLG), hParent , KeyPressProc)) {
		nVKey = vKey;
		SendMessage(GetDlgItem(hParent, IDC_KBD_KEYEDIT), WM_SETTEXT, 0, (LPARAM)(char*)BindingName());
	}
}


//--- Public functions ---------------------------------------------


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;
	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}
	return(TRUE);
}

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESCRIPTION); }

__declspec( dllexport ) int LibNumberClasses() {return 2;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetKbdDeviceClassDesc();
		case 1: return GetKbdBindingClassDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\posmc.cpp ===
/**********************************************************************
 *<
	FILE: posMC.cpp

	DESCRIPTION: Position motion capture controller

	CREATED BY: Rolf Berteig

	HISTORY: October 30, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "motion.h"
#include "mmanager.h"


static Class_ID posmcControlClassID(POS_MOTION_CLASS_ID,0); 

class PositionMC : public MCControl {
	public:
		MCDeviceBinding *bind[3];
		Point3 base;
		int sampleCount;
		Point3 *data;

		PositionMC();
		Class_ID ClassID() {return posmcControlClassID;}  
		SClass_ID SuperClassID() {return CTRL_POSITION_CLASS_ID;} 
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_POSMC);}
		ParamDimension* GetParamDimension(int i) {return stdWorldDim;}
		RefTargetHandle Clone(RemapDir& remap);

		int NumDeviceBindings() {return 3;}
		MCDeviceBinding *GetDeviceBinding(int i) {return bind[i];}
		void SetDeviceBinding(int i,MCDeviceBinding *b) {bind[i]=b;}
		void GetValueLive(TimeValue t,void *val, GetSetMethod method);
		void BeginCapture(Interval record,TimeValue sampSize);
		void EndCapture(Interval record,TimeValue sampSize, KeyReduceStatus *stat);
		void Capture(Interval record,TimeValue t,int sample);
		void BeginLive(TimeValue t);

		void EditTrackParams(
			TimeValue t, ParamDimensionBase *dim, TCHAR *pname, 
			HWND hParent, IObjParam *ip, DWORD flags);
	};


//--- Class Descriptor -----------------------------------------------

class PosMCClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new PositionMC;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_POSMC);}
	SClass_ID		SuperClassID() {return CTRL_POSITION_CLASS_ID;}
	Class_ID		ClassID() {return posmcControlClassID;}
	const TCHAR* 	Category() {return _T("");}
	};
static PosMCClassDesc posmcCD;
ClassDesc* GetPosMotionDesc() {return &posmcCD;}


//--- PositionMC methods ----------------------------------------------

PositionMC::PositionMC()
	{
	ReplaceReference(0,CreateInterpPosition());
	bind[0] = bind[1] = bind[2] = NULL;
	base = Point3(0,0,0);
	data = NULL;
	}

RefTargetHandle PositionMC::Clone(RemapDir& remap)
	{
	PositionMC *c = new PositionMC;
	c->MCControlClone(this,remap);
	return c;
	}

void PositionMC::EditTrackParams(
		TimeValue t, ParamDimensionBase *dim, TCHAR *pname, 
		HWND hParent, IObjParam *ip, DWORD flags)
	{
	GenMCParamDlg *dlg = new GenMCParamDlg(this,IDD_MC_POSITION);
	dlg->DoWindow(hParent, pname);
	}

void PositionMC::GetValueLive(TimeValue t,void *val, GetSetMethod method)
	{
	Point3 pt = base;
	for (int i=0; i<3; i++) if (bind[i]) pt[i] += bind[i]->Eval(t);
	if (method==CTRL_ABSOLUTE) {
		*((Point3*)val) = pt;
	} else {
		Matrix3 *tm = (Matrix3*)val;
		tm->PreTranslate(pt);
		}
	}

void PositionMC::BeginCapture(Interval record,TimeValue sampSize)
	{
	// Set the base point to the controller value at the start time.
	cont->GetValue(record.Start(),&base,FOREVER,CTRL_ABSOLUTE);	

	// Allocate a data buffer
	sampleCount = record.Duration()/sampSize + 1;
	data = new Point3[sampleCount];
	for (int i=0; i<sampleCount; i++) data[i] = Point3(0,0,0);
	}

void PositionMC::Capture(Interval record,TimeValue t,int sample)
	{
	assert(sample>=0 && sample<sampleCount);	
	GetValueLive(t,&data[sample], CTRL_ABSOLUTE);	
	}
  
void PositionMC::EndCapture(Interval record,TimeValue sampSize, KeyReduceStatus *stat) 
	{		
	// Clear any keys out of the record interval
	cont->DeleteTime(record,TIME_INCLEFT|TIME_INCRIGHT|TIME_NOSLIDE);

	// Make keys out of the data
	SuspendAnimate();
	AnimateOn();	
	for (int i=0; i<sampleCount; i++) {
		TimeValue t = record.Start() + i * sampSize;
		cont->SetValue(t,&data[i],1,CTRL_ABSOLUTE);
		if (i%UPDATE_RATE==0) if (stat->Progress(i)!=KEYREDUCE_CONTINUE) goto abort;
		}	

abort:
	ResumeAnimate();
	delete[] data;
	base = Point3(0,0,0);
	}

void PositionMC::BeginLive(TimeValue t)
	{
	// Set the base point to the controller value at the start time.
	cont->GetValue(t,&base,FOREVER,CTRL_ABSOLUTE);	
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\mckbddev\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mckbddev.rc
//
#define IDS_KBD_DEVICENAME              1
#define IDS_KBD_UNASSIGNED              2
#define IDS_KBD_KEY                     3
#define IDS_KBD_KEYNAME_BACKSPACE       4
#define IDS_KBD_KEYNAME_SPACE           5
#define IDS_KBD_KEYNAME_PGUP            6
#define IDS_KBD_KEYNAME_PGDN            7
#define IDS_KBD_KEYNAME_END             8
#define IDS_KBD_KEYNAME_HOME            9
#define IDS_KBD_KEYNAME_LEFTARROW       10
#define IDS_KBD_KEYNAME_UPARROW         11
#define IDS_KBD_KEYNAME_RIGHTARROW      12
#define IDS_KBD_KEYNAME_DOWNARROW       13
#define IDS_KBD_KEYNAME_INSERT          14
#define IDS_KBD_KEYNAME_DELETE          15
#define IDS_KBD_KEYNAME_NUMPAD0         16
#define IDS_KBD_KEYNAME_NUMPAD1         17
#define IDS_KBD_KEYNAME_NUMPAD2         18
#define IDS_KBD_KEYNAME_NUMPAD3         19
#define IDS_KBD_KEYNAME_NUMPAD4         20
#define IDS_KBD_KEYNAME_NUMPAD5         21
#define IDS_KBD_KEYNAME_NUMPAD6         22
#define IDS_KBD_KEYNAME_NUMPAD7         23
#define IDS_KBD_KEYNAME_NUMPAD8         24
#define IDS_KBD_KEYNAME_NUMPAD9         25
#define IDS_KBD_KEYNAME_GREYSTAR        26
#define IDS_KBD_KEYNAME_GREYPLUS        27
#define IDS_KBD_KEYNAME_GREYMINUS       28
#define IDS_KBD_KEYNAME_GREYDOT         29
#define IDS_KBD_KEYNAME_GREYSLASH       30
#define IDS_KBD_KEYNAME_F1              31
#define IDS_KBD_KEYNAME_F2              32
#define IDS_KBD_KEYNAME_F3              33
#define IDS_KBD_KEYNAME_F4              34
#define IDS_KBD_KEYNAME_F5              35
#define IDS_KBD_KEYNAME_F6              36
#define IDS_KBD_KEYNAME_F7              37
#define IDS_KBD_KEYNAME_F8              38
#define IDS_KBD_KEYNAME_F9              39
#define IDS_KBD_KEYNAME_F10             40
#define IDS_KBD_KEYNAME_F11             41
#define IDS_KBD_KEYNAME_F12             42
#define IDS_LIBDESCRIPTION              43
#define IDD_MC_KBD                      111
#define IDD_KBD_KEYPRESSDLG             112
#define IDC_KBD_ALT                     1003
#define IDC_KBD_KEYBTN                  1089
#define IDC_KBD_ENVGRAPH                1090
#define IDC_KEYEDIT                     1092
#define IDC_KBD_KEYEDIT                 1092
#define ID_FILE_EXIT                    1093
#define IDC_KBD_ATTACK                  1155
#define IDC_KBD_ATTACKSPIN              1156
#define IDC_KBD_DECAY                   1157
#define IDC_KBD_DECAYSPIN               1158
#define IDC_KBD_SUSTAIN                 1159
#define IDC_KBD_SUSTAINSPIN             1160
#define IDC_KBD_RELEASE                 1161
#define IDC_KBD_RELEASESPIN             1162
#define IDC_KBD_SCALE                   1163
#define IDC_KBD_SCALESPIN               1164
#define IDC_KBD_TIMESCALE               1165
#define IDC_KBD_TIMESCALESPIN           1166

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\scalemc.cpp ===
/**********************************************************************
 *<
	FILE: scaleMC.cpp

	DESCRIPTION: Scale motion capture controller

	CREATED BY: Rolf Berteig

	HISTORY: October 30, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "motion.h"
#include "mmanager.h"


static Class_ID scalemcControlClassID(SCALE_MOTION_CLASS_ID,0); 

class ScaleMC : public MCControl {
	public:
		MCDeviceBinding *bind[3];
		Point3 base;
		int sampleCount;
		Point3 *data;

		ScaleMC();
		Class_ID ClassID() {return scalemcControlClassID;}  
		SClass_ID SuperClassID() {return CTRL_SCALE_CLASS_ID;} 
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_SCALEMC);}
		ParamDimension* GetParamDimension(int i) {return stdPercentDim;}
		RefTargetHandle Clone(RemapDir& remap);

		int NumDeviceBindings() {return 3;}
		MCDeviceBinding *GetDeviceBinding(int i) {return bind[i];}
		void SetDeviceBinding(int i,MCDeviceBinding *b) {bind[i]=b;}
		void GetValueLive(TimeValue t,void *val, GetSetMethod method);
		void BeginCapture(Interval record,TimeValue sampSize);
		void EndCapture(Interval record,TimeValue sampSize, KeyReduceStatus *stat);
		void Capture(Interval record,TimeValue t,int sample);
		void BeginLive(TimeValue t);

		void EditTrackParams(
			TimeValue t, ParamDimensionBase *dim, TCHAR *pname, 
			HWND hParent, IObjParam *ip, DWORD flags);
	};



//--- Class Descriptor -----------------------------------------------

class ScaleMCClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new ScaleMC;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_SCALEMC);}
	SClass_ID		SuperClassID() {return CTRL_SCALE_CLASS_ID;}
	Class_ID		ClassID() {return scalemcControlClassID;}
	const TCHAR* 	Category() {return _T("");}
	};
static ScaleMCClassDesc scalemcCD;
ClassDesc* GetScaleMotionDesc() {return &scalemcCD;}


//--- ScaleMC methods ----------------------------------------------

ScaleMC::ScaleMC()
	{
	ReplaceReference(0,CreateInterpScale());
	bind[0] = bind[1] = bind[2] = NULL;
	base = Point3(1,1,1);
	data = NULL;
	}

RefTargetHandle ScaleMC::Clone(RemapDir& remap)
	{
	ScaleMC *c = new ScaleMC;
	c->MCControlClone(this,remap);
	return c;
	}

void ScaleMC::EditTrackParams(
		TimeValue t, ParamDimensionBase *dim, TCHAR *pname, 
		HWND hParent, IObjParam *ip, DWORD flags)
	{
	GenMCParamDlg *dlg = new GenMCParamDlg(this,IDD_MC_SCALE);
	dlg->DoWindow(hParent, pname);
	}

void ScaleMC::GetValueLive(TimeValue t,void *val, GetSetMethod method)
	{
	Point3 pt = base;
	for (int i=0; i<3; i++) {
		if (bind[i]) pt[i] += bind[i]->Eval(t)/100.0f;		
		}
	if (method==CTRL_ABSOLUTE) {
		*((ScaleValue*)val) = ScaleValue(pt);
	} else {
		Matrix3 *tm = (Matrix3*)val;
		tm->PreScale(pt);
		}
	}

void ScaleMC::BeginCapture(Interval record,TimeValue sampSize)
	{
	// Set the base point to the controller value at the start time.
	ScaleValue s;
	cont->GetValue(record.Start(),&s,FOREVER,CTRL_ABSOLUTE);	
	base = s.s;

	// Allocate a data buffer
	sampleCount = record.Duration()/sampSize + 1;
	data = new Point3[sampleCount];
	for (int i=0; i<sampleCount; i++) data[i] = Point3(1,1,1);
	}

void ScaleMC::Capture(Interval record,TimeValue t,int sample)
	{
	assert(sample>=0 && sample<sampleCount);	
	ScaleValue s;
	GetValueLive(t,&s, CTRL_ABSOLUTE);	
	data[sample] = s.s; 
	}
  
void ScaleMC::EndCapture(Interval record,TimeValue sampSize, KeyReduceStatus *stat) 
	{		
	// Clear any keys out of the record interval
	cont->DeleteTime(record,TIME_INCLEFT|TIME_INCRIGHT|TIME_NOSLIDE);

	// Make keys out of the data
	SuspendAnimate();
	AnimateOn();	
	for (int i=0; i<sampleCount; i++) {
		TimeValue t = record.Start() + i * sampSize;
		ScaleValue s(data[i]);
		cont->SetValue(t,&s,1,CTRL_ABSOLUTE);
		if (i%UPDATE_RATE==0) if (stat->Progress(i)!=KEYREDUCE_CONTINUE) goto abort;
		}	

abort:
	ResumeAnimate();
	delete[] data;
	base = Point3(1,1,1);
	}

void ScaleMC::BeginLive(TimeValue t)
	{
	// Set the base point to the controller value at the start time.
	ScaleValue s;
	cont->GetValue(t,&s,FOREVER,CTRL_ABSOLUTE);
	base = s.s;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\acubic.cpp ===
/**********************************************************************
 *<
	FILE: ACUBIC.CPP

	DESCRIPTION: Cubic Reflection/Refraction map.

	CREATED BY: Dan Silva

	HISTORY:
				Update 11/17 to param block2 by Peter Watje

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include <bmmlib.h>
#include "render.h"
#include "stdmat.h"
#include "iparamm2.h"

static TCHAR *suffixes[6] = { 
	_T("_UP"),
	_T("_DN"),
	_T("_LF"),
	_T("_RT"),
	_T("_FR"),
	_T("_BK"),
	};

// Define this to display the rendered maps:
//#define DBG

extern HINSTANCE hInstance;

static Class_ID acubicClassID(ACUBIC_CLASS_ID,0);

//#define PB_SIZE	    0
//#define PB_BLUR	    1
//#define PB_BLUROFF  2
//#define PB_NEAR     3
//#define PB_FAR      4

enum { acubic_params };  // pblock ID
// grad_params param IDs
enum 
{ 
	acubic_size, acubic_blur, acubic_bluroffset, acubic_near, acubic_far,
	acubic_source, acubic_useatmospheric, acubic_applyblur,
	acubic_frametype, acubic_nthframe,
	acubic_bitmap_names,
	acubic_outputname,
//	acubic_camera,
//	acubic_node

};

#if 0
static TCHAR *meditNames[6] = {
	_T("MAX_UP.JPG"),
	_T("MAX_DN.JPG"),
	_T("MAX_LF.JPG"),
	_T("MAX_RT.JPG"),
	_T("MAX_FR.JPG"),
	_T("MAX_BK.JPG")
	};
#endif

static TCHAR *getCubeName(int i)  {
	switch(i) {
		case 0: return GetString(IDS_DS_UP);  
		case 1: return GetString(IDS_DS_DOWN);  
		case 2: return GetString(IDS_DS_LEFT);  
		case 3: return GetString(IDS_DS_RIGHT);  
		case 4: return GetString(IDS_DS_FRONT);  
		default: return GetString(IDS_DS_BACK);  
		}
	}


Matrix3 TMForView( int i);

//---------------------------------------------------
class EnvSampler {
	public:
		virtual	BMM_Color_64 sample(Point3 n)=0;
	};

void BuildSphereMap(Bitmap *bm, EnvSampler& env) {
	FLOAT dv,du,u,v,phi,cphi,theta;;
	int iu,iv;
	Point3 n;
	int w = bm->Width();
	int h = bm->Height();
	PixelBuf l64(w);
	BMM_Color_64 *pb=l64.Ptr();

	dv = 1.0f/(float)h;
	du = 1.0f/(float)w;
	for (iv = 0,v=0.0f; iv<h; iv++,v+=dv) {
		phi = PI*(.5f - v);
		cphi = (float)cos(phi);
		n.z =  (float)sin(phi);
		for (iu=0,u=0.0f; iu<w; iu++,u+=du) {
			/* compute normal in direction for iv,iu */
			theta = TWOPI*(u-.5f);
			//if (P.reflip) theta = -theta;
			n.y = (float)sin(theta)*cphi;
			n.x = (float)cos(theta)*cphi;
			pb[iu] = env.sample(n);
			}
		bm->PutPixels(0,iv, w, pb);
		}

#ifdef DBG
	bm->Display(_T("Cubic Test"), BMM_UR);
	MessageBox(NULL, _T("The spherical map"), _T(" Auto Cubic Test"), MB_OK|MB_ICONEXCLAMATION);
	bm->UnDisplay();
#endif
	}

//---------------------------------------------------

inline float FMax(float a, float b) { return a>b?a:b; }

void ComputeSphereCoords(Point3 n, Point2& t, Point2& d) {
	t.x = 0.5f + (float)atan2(n.y,n.x)/TWOPI;
	t.y = 0.5f - (float)asin(n.z)/PI;
	float dd = FMax((float)fabs(n.x),(float)fabs(n.y))/(1.0f-n.z*n.z+.1f)/TWOPI;
	d.x = d.y = dd;
	}


//---------------------------------------------------
/*
class ACubic;

class ACubicDlg: public ParamDlg, public  PickObjectProc, public RendProgressCallback, public DADMgr{
	public:
		HWND hwmedit;	 	// window handle of the materials editor dialog
		IMtlParams *ip;
		ACubic *theTex;	// current ACubic being edited.
		HWND hPanel; 		// Rollup pane
		ICustButton *iPick,*iCamPick;
		ISpinnerControl *sizeSpin,*blurSpin,*nthSpin,*blurOffSpin,*nearSpin,*farSpin;
		ICustButton *iFile[6];
		TimeValue curTime; 
		int isActive;
		BOOL valid;
		BOOL camPick;
		BOOL abortRender;

		//-----------------------------
		ACubicDlg(HWND hwMtlEdit, IMtlParams *imp, ACubic *m); 
		~ACubicDlg();
		BOOL PanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
		void LoadDialog(BOOL draw);  // stuff params into dialog
		void UpdateMtlDisplay() { ip->MtlChanged(); }
		void ReloadDialog();
		void ActivateDlg(BOOL onOff) {}
		void BrowseInFile(int id);
		void BrowseOutFile();
		void StuffDlgName(int i);
		void StuffOutName();
		void MaybeEnablePick();
		void Invalidate() { valid = FALSE;	InvalidateRect(hPanel,NULL,0); }
		BOOL KeyAtCurTime(int id);
		void Destroy(HWND hWnd) { 
			ReleaseICustButton(iPick);	
			iPick = NULL; 
			ReleaseICustButton(iCamPick);	
			iCamPick = NULL;
			for (int i=0; i<6; i++) {
				ReleaseICustButton(iFile[i]);
				iFile[i] = NULL;	
				}
			}
		void SetUseFile(BOOL onOff);
		BOOL CheckWindowMessages(HWND hWnd);
		int FindFileFromHWND(HWND hw);


		// methods inherited from ParamDlg:
		Class_ID ClassID() {return acubicClassID;  }
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing() { return (ReferenceTarget *)theTex; }
		void DeleteThis() { delete this;  }	
		void SetTime(TimeValue t);

		// From PickObjectProc
		BOOL Pick(INode *node);
		BOOL Filter(INode *node);
		void EnterMode() { if (camPick) iCamPick->SetCheck(TRUE); else 	iPick->SetCheck(TRUE);	}
		void ExitMode() { if (camPick) iCamPick->SetCheck(FALSE); else 	iPick->SetCheck(FALSE);	}
		BOOL AllowMultiSelect() { return FALSE;}

		// From RendProgressCallback
		void SetTitle(const TCHAR *title){};
		int Progress(int done, int total);

		// DADMgr methods
		// called on the draggee to see what if anything can be dragged from this x,y
		SClass_ID GetDragType(HWND hwnd, POINT p) { return BITMAPDAD_CLASS_ID; }
		// called on potential dropee to see if can drop type at this x,y
		BOOL OkToDrop(ReferenceTarget *dropThis, HWND hfrom, HWND hto, POINT p, SClass_ID type, BOOL isNew) {
			if (hfrom==hto) return FALSE;
			return (type==BITMAPDAD_CLASS_ID)?1:0;
			}
		int SlotOwner() { return OWNER_MTL_TEX;	}
	    ReferenceTarget *GetInstance(HWND hwnd, POINT p, SClass_ID type);
		void Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type);
		BOOL  LetMeHandleLocalDAD() { return 0; } 
	};

*/

//--------------------------------------------------------------
// CubicMap 
//--------------------------------------------------------------
#define VIEW_UP 0
#define VIEW_DN	1
#define VIEW_LF	2
#define VIEW_RT 3
#define VIEW_FR	4
#define VIEW_BK	5

class CubicMap {
	public:
		Bitmap *bitmap[6];
		Bitmap *blurmap;
		int size;
		CubicMap *next;
		int nodeID;
		BOOL tossMapsWhenBlur;
		TimeValue mapTime; // when maps were last rendered
	// Methods
		CubicMap();
		~CubicMap();
		void FreeMaps();
		void FreeCubicMaps();
		int AllocMaps(int sz);
		BMM_Color_64 Sample(Point3 dir);
		int BuildBlurMap();
		void FreeBlurMap();
	};	  

CubicMap::CubicMap() { 
	for (int i=0; i<6; i++) 
		bitmap[i] = NULL; 
	blurmap = NULL;
	next = NULL;
	size = 0; 
	tossMapsWhenBlur = TRUE;
	}

CubicMap::~CubicMap() { 
	FreeMaps();
	}

void CubicMap::FreeCubicMaps() {
	for (int i=0; i<6; i++) {  
		if (bitmap[i]) {
			bitmap[i]->DeleteThis(); 
			bitmap[i] = NULL;
			}
		}
	}

void CubicMap::FreeMaps() {
	FreeCubicMaps();
	FreeBlurMap();
	}

int CubicMap::AllocMaps(int sz) {
	if (bitmap[0]&&size==size)
		return 1;
	FreeMaps();
	BitmapInfo bi;
	bi.SetName(_T(""));
	bi.SetWidth(sz);
	bi.SetHeight(sz);
	bi.SetType(BMM_TRUE_32);
	size = sz;
	for (int i=0; i<6; i++) {
		if (NULL == (bitmap[i] = TheManager->Create(&bi)))
			return 0;
		}
	return 1;
	}


class CubeSampler: public EnvSampler {
	CubicMap *cm;
	public:
		CubeSampler(CubicMap *c) { cm = c; }
		BMM_Color_64 sample(Point3 n){ return cm->Sample(n);	}
	};

void  CubicMap::FreeBlurMap() {
	if (blurmap) {
		blurmap->DeleteThis();
		blurmap = NULL;
		}
	}

int CubicMap::BuildBlurMap() {
	if (bitmap[0]==NULL)
		return 1;
	if (!(blurmap&&blurmap->Width()==4*size && blurmap->Height()==2*size)) {
		BitmapInfo bi;
		bi.SetName(_T(""));
		bi.SetWidth(4*size);
		bi.SetHeight(2*size);
		bi.SetType(BMM_TRUE_32);
		if (blurmap) blurmap->DeleteThis();
		blurmap = TheManager->Create(&bi);
		}
	if (blurmap) {
		CubeSampler cs(this);
		BuildSphereMap(blurmap, cs);
		if (tossMapsWhenBlur)
			FreeCubicMaps(); 
		blurmap->SetFilter(BMM_FILTER_PYRAMID);  
		BitmapFilter *filt = blurmap->Filter();
		if (filt)
			filt->MakeDirty();  // so filter gets recomputed for each frame
		}
	return 1;
	}

//--------------------------------------------------------------
// ACubic: 
//--------------------------------------------------------------
#define NUM_SRC_FILES 6 // mjm - 2.3.99

class ACubic: public StdCubic { 
	friend class ACubicPostLoad;
	friend class ACubicDlgProc;
	int size;
	int nth;
	float blur;
	float blurOff;
	float nearRange,farRange;
//	CRITICAL_SECTION csect;
	BOOL applyBlur;
	BOOL do_nth;
	BOOL useEnvMap;
	BOOL inMedit;
	BitmapInfo biInFile;			// for reading cubic map files
	BitmapInfo biOutFile;			// for rendering cubic map.
	TSTR fileNames[NUM_SRC_FILES];	// source files
	CubicMap *maps;					// when Automatic mode
	Interval ivalid;
	int rollScroll;



//	ACubicDlg *paramDlg;
	public:
		BOOL useFile;
		IMtlParams *ip;
		IParamBlock2 *pblock;  // ref #1
		ACubic();
		~ACubic() {	
//			DeleteCriticalSection(&csect); 
			}
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		// From StdCubic
		void SetSize(int n, TimeValue t);
		void SetDoNth(BOOL onoff) { do_nth = onoff; }
		void SetNth(int n) { nth = n; }
		void SetApplyBlur(BOOL onoff);
		void SetBlur(float b, TimeValue t);
		void SetBlurOffset(float b, TimeValue t);
		int GetSize(TimeValue t){ return pblock->GetInt(acubic_size,t); }
		BOOL GetDoNth() { return do_nth; }
		int GetNth() { return nth; }
		BOOL GetApplyBlur() { return applyBlur; }
		float GetBlur(TimeValue t) { return pblock->GetFloat(acubic_blur,t); }
		float GetBlurOffset(TimeValue t){ return pblock->GetFloat(acubic_bluroffset,t); }
		int  GetOutFileName(TSTR& fullname, TSTR &fname, int i);
		int WriteBM(Bitmap *bm, TCHAR *name);
		void RenderCubicMap(INode *node);
		void SetUseFile(BOOL onOff);
		float GetNearRange(TimeValue t) { return pblock->GetFloat(acubic_near,t); }
		float GetFarRange(TimeValue t) { return pblock->GetFloat(acubic_far,t); }
	    void SetNearRange(float v, TimeValue t);
	    void SetFarRange(float v, TimeValue t);

		void NotifyChanged();
	
		// Evaluate the color of map for the context.
		RGBA EvalColor(ShadeContext& sc);

		// optimized evaluation for monochrome use
		float EvalMono(ShadeContext& sc);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		ULONG LocalRequirements(int subMtlNum) { 
			ULONG req = MTLREQ_VIEW_DEP;  // DS 10/18/99 so viewport will update when rotate interactively. (211026)
			if (!useFile)
				req |= MTLREQ_AUTOREFLECT;	
			return req;
			}

		int LoadMapFiles(TimeValue t);
		int BuildMaps(TimeValue t, RenderMapsContext &rmc);
		int DoThisFrame(TimeValue t, BOOL fieldRender, TimeValue mapTime);
		CubicMap *FindMap(int nodeNum);
		void FreeMaps();
		int RenderBegin(TimeValue t, ULONG flags) {  return 1;}
		int RenderEnd(TimeValue t) { if (!useFile) FreeMaps(); return 1; }

		Class_ID ClassID() {	return acubicClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_ACUBIC_NAME); }  
		void DeleteThis() { delete this; }	

		int NumSubs() {return 1; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		void EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags) {
			if (useFile) {
				for (int i=0; i<6; i++) {
					biInFile.SetName(fileNames[i]);
					biInFile.EnumAuxFiles(nameEnum,flags);
					}
				}

			}
		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock

		void UpdateInterface(BOOL on);	
};



class ACubicClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new ACubic; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_ACUBIC_NAME_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return acubicClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_ENV;  }
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("reflectRefract"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static ACubicClassDesc acubicCD;

ClassDesc* GetACubicDesc() { return &acubicCD;  }


/*
BOOL ACubicDlg::Filter(INode *node) { 
	if (!camPick)
		return TRUE; 
	ObjectState os = node->EvalWorldState(ip->GetTime());
	return os.obj->SuperClassID()==CAMERA_CLASS_ID;
	}

BOOL ACubicDlg::Pick(INode *node)
	{
	if (node) {
		if (camPick) {
			ObjectState os = node->EvalWorldState(ip->GetTime());
			if (os.obj->SuperClassID()==CAMERA_CLASS_ID) {
				CameraState cs;
				Interval iv;
				CameraObject *cam = (CameraObject *)os.obj;
				cam->EvalCameraState(ip->GetTime(),iv,&cs);
				theTex->SetNearRange(cs.nearRange,ip->GetTime());
				theTex->SetFarRange(cs.farRange,ip->GetTime());
				nearSpin->SetValue(theTex->nearRange,FALSE);
				farSpin->SetValue(theTex->farRange,FALSE);
				}
			}
		else {
			theTex->RenderCubicMap(node);
			}
		}
	return TRUE;
	}



//--------------------------------------------------------------

static BOOL CALLBACK  PanelDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	ACubicDlg *theDlg;
	if (msg==WM_INITDIALOG) {
		theDlg = (ACubicDlg*)lParam;
		theDlg->hPanel = hwndDlg;
		SetWindowLong(hwndDlg, GWL_USERDATA,lParam);
		}
	else {
	    if ( (theDlg = (ACubicDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
		}
	theDlg->isActive = 1;
	int	res = theDlg->PanelProc(hwndDlg,msg,wParam,lParam);
	theDlg->isActive = 0;
	return res;
	}

ACubicDlg::ACubicDlg(HWND hwMtlEdit, IMtlParams *imp, ACubic *m) { 
	hwmedit = hwMtlEdit;
	ip = imp;
	hPanel = NULL;
	theTex = m; 
	isActive = 0;
	valid = FALSE;
	iPick = iCamPick = NULL;
	for (int i=0; i<6; i++)
		iFile[i] = NULL;
	hPanel = ip->AddRollupPage( 
		hInstance,
		MAKEINTRESOURCE(IDD_AUTO_CUBIC),
		PanelDlgProc, 
		GetString(IDS_DS_ACUBIC_PARAMS), 
		(LPARAM)this );		
	curTime = imp->GetTime();
	}

void ACubicDlg::ReloadDialog() {
	Interval valid;
	theTex->Update(curTime, valid);
	LoadDialog(FALSE);
	}

void ACubicDlg::SetTime(TimeValue t) {
	Interval valid;
	if (t!=curTime) {
		curTime = t;
		theTex->Update(curTime, valid);
		LoadDialog(FALSE);
		InvalidateRect(hPanel,NULL,0);
		}
	}



void ACubicDlg::SetUseFile(BOOL onOff) {
	theTex->SetUseFile(onOff);
	CheckRadioButton( hPanel, IDC_CUBESRC_AUTO,IDC_CUBESRC_FILE, IDC_CUBESRC_AUTO+theTex->useFile);

	// AUTO STUFF
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_AUTO_GRP), !onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_FIRST_ONLY), !onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_EVERY_NTH), !onOff);
	if (onOff) nthSpin->Disable(); else nthSpin->Enable();

	//FILE STUFF
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_RELOAD), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_FILE_GRP), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_FILE_GRP2), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_OUTFILE), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_OUTFILE_NAME), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_UP), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_DN), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_LF), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_RT), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_BK), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_FR), onOff);

	for (int i=0; i<6; i++) 
		iFile[i]->Enable(onOff);
	MaybeEnablePick();
	}

ACubicDlg::~ACubicDlg() {
	ip->EndPickMode();
	theTex->paramDlg = NULL;
	ReleaseISpinner(sizeSpin);
	ReleaseISpinner(blurSpin);
	ReleaseISpinner(blurOffSpin);
	ReleaseISpinner(nthSpin);
	ReleaseISpinner(nearSpin);
	ReleaseISpinner(farSpin);
	SetWindowLong(hPanel, GWL_USERDATA, NULL);
	hPanel =  NULL;
	}

static int fileButtonID[6]={IDC_FILE_UP,IDC_FILE_DN,IDC_FILE_LF,IDC_FILE_RT,IDC_FILE_FR,IDC_FILE_BK};
static int fileNameID[6]={IDC_CUBE_UP,IDC_CUBE_DN,IDC_CUBE_LF,IDC_CUBE_RT,IDC_CUBE_FR,IDC_CUBE_BK};

static int SideFromID(int id) {
	for (int i=0; i<6; i++) if (fileButtonID[i]==id) return i;
	return 0;
	}

void ACubicDlg::MaybeEnablePick() {
	if (!theTex->useFile) {
		iPick->Disable(); 
		return;
		}
	if (_tcslen(theTex->biOutFile.Name())>0) 
		iPick->Enable(); 
	else 
		iPick->Disable();
	}


BOOL ACubicDlg::PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg)    {
		case WM_INITDIALOG:
			{
			iPick = GetICustButton(GetDlgItem(hwndDlg,IDC_CUBE_PICK));
			iPick->SetType(CBT_CHECK);
			iPick->SetHighlightColor(GREEN_WASH);

			iCamPick = GetICustButton(GetDlgItem(hwndDlg,IDC_ACUBE_PICKCAM));
			iCamPick->SetType(CBT_CHECK);
			iCamPick->SetHighlightColor(GREEN_WASH);

			for (int i=0; i<6; i++) {
				iFile[i] = GetICustButton(GetDlgItem(hwndDlg,fileButtonID[i]));
				iFile[i]->SetDADMgr(this);
				}

			sizeSpin = SetupIntSpinner(hwndDlg, IDC_ACUBE_SIZE_SPIN, IDC_ACUBE_SIZE_EDIT,1,5000,100);
			blurSpin = SetupFloatSpinner(hwndDlg, IDC_ACUBE_BLUR_SPIN, IDC_ACUBE_BLUR_EDIT,0.0f,100.0f,1.0f,.01f);
			blurOffSpin = SetupFloatSpinner(hwndDlg, IDC_ACUBE_BLUROFF_SPIN, IDC_ACUBE_BLUOFF_EDIT,0.0f,1.0f,0.0f,.001f);
			nthSpin = SetupIntSpinner(hwndDlg, IDC_ACUBE_NTH_SPIN, IDC_ACUBE_NTH_EDIT,1,1000, 1);
			nearSpin = SetupFloatSpinner(hwndDlg, IDC_ACUBE_NEAR_SPIN, IDC_ACUBE_NEAR_EDIT,0.0f,10000.0f,0.0f,1.0f);
			farSpin = SetupFloatSpinner(hwndDlg, IDC_ACUBE_FAR_SPIN, IDC_ACUBE_FAR_EDIT,0.0f,10000.0f,500.0f,1.0f);
			CheckRadioButton( hwndDlg, IDC_FIRST_ONLY, IDC_EVERY_NTH, IDC_FIRST_ONLY+theTex->do_nth);
			SetCheckBox(hwndDlg, IDC_ACUBE_BLUR, theTex->applyBlur);
			SetCheckBox(hwndDlg, IDC_USE_ENVMAP, theTex->useEnvMap);
			for (i=0; i<6; i++) 
				StuffDlgName(i);
			StuffOutName();
			SetUseFile(theTex->useFile);
			MaybeEnablePick();
			return TRUE;
			}
			break;
		case WM_COMMAND:  
		    switch (id) {
				case IDC_FIRST_ONLY:
					theTex->do_nth = FALSE;
					break;
				case IDC_EVERY_NTH:
					theTex->do_nth = TRUE;
					break;
				case IDC_ACUBE_BLUR:
					theTex->SetApplyBlur(GetCheckBox(hwndDlg, id));			
					theTex->NotifyChanged();
					break;
				case IDC_USE_ENVMAP:
					theTex->useEnvMap = GetCheckBox(hwndDlg, id);			
					break;
				case IDC_CUBESRC_AUTO:
					SetUseFile(FALSE);
					theTex->NotifyChanged();
					break;
				case IDC_CUBESRC_FILE:
					SetUseFile(TRUE);
					theTex->NotifyChanged();
					break;
				case IDC_CUBE_PICK:
					camPick = FALSE;
					ip->SetPickMode(this); 
					break;
				case IDC_ACUBE_PICKCAM:
					camPick = TRUE;
					ip->SetPickMode(this); 
					break;
				case IDC_CUBE_RELOAD:
					theTex->FreeMaps();
					theTex->NotifyChanged();
					break;
				case IDC_FILE_UP:
				case IDC_FILE_DN:
				case IDC_FILE_LF:
				case IDC_FILE_RT:
				case IDC_FILE_FR:
				case IDC_FILE_BK:
					BrowseInFile(id);
					break;
				case IDC_CUBE_OUTFILE_NAME:
					BrowseOutFile();
					MaybeEnablePick();
					break;
				}
			break;
		case WM_PAINT: 	
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			break;
		case WM_CLOSE: 	break;       
		case WM_DESTROY:
			Destroy(hwndDlg);
			break;
		case CC_SPINNER_CHANGE: 
			if (!theHold.Holding()) theHold.Begin();
			switch (id) {
				case IDC_ACUBE_SIZE_SPIN: 
					theTex->SetSize(sizeSpin->GetIVal(),curTime); 	
					sizeSpin->SetKeyBrackets(KeyAtCurTime(PB_SIZE));
					break;
				case IDC_ACUBE_BLUR_SPIN: 
					theTex->SetBlur(blurSpin->GetFVal(),curTime); 	
					blurSpin->SetKeyBrackets(KeyAtCurTime(PB_BLUR));
					break;
				case IDC_ACUBE_BLUROFF_SPIN: 
					theTex->SetBlurOffset(blurOffSpin->GetFVal(),curTime); 	
					blurOffSpin->SetKeyBrackets(KeyAtCurTime(PB_BLUROFF));
					break;
				case IDC_ACUBE_NTH_SPIN: 
					theTex->nth = nthSpin->GetIVal(); 	
					break;
				case IDC_ACUBE_NEAR_SPIN: 
					theTex->SetNearRange(nearSpin->GetFVal(),curTime); 	
					nearSpin->SetKeyBrackets(KeyAtCurTime(PB_NEAR));
					break;
				case IDC_ACUBE_FAR_SPIN: 
					theTex->SetFarRange(farSpin->GetFVal(),curTime); 	
					farSpin->SetKeyBrackets(KeyAtCurTime(PB_FAR));
					break;
				}
			break;
		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			theTex->NotifyChanged();
		    UpdateMtlDisplay();
			break;
		case CC_COMMAND:
			switch (code) {
				int i;
				case 8190:  /// DROP
					i = 10;
					break;
				}
			break;
    	}
	return FALSE;
	}


BOOL ACubicDlg::CheckWindowMessages(HWND hWnd)
	{
	MSG msg;
	Interface *iface = GetCOREInterface();
	while (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
//		if (msg.message == WM_QUIT) {
//			PostMessage(msg.hwnd,msg.message,msg.wParam,msg.lParam);
//			abortRender = TRUE;
//			return FALSE;
//			}
		// Escape key aborts render
		if (msg.message == WM_KEYDOWN&&msg.wParam==27) {
			PostMessage(msg.hwnd,msg.message,msg.wParam,msg.lParam);
			abortRender = TRUE;
			return FALSE;
			}
		if (msg.message==WM_PAINT |