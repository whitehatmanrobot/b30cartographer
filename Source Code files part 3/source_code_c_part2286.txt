ort   _nameResourceID;
        private __VSEDITORTRUSTLEVEL _trustLevel;

        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute.ProvideEditorFactoryAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideEditorFactoryAttribute.
        /// </devdoc>
        public ProvideEditorFactoryAttribute (Type factoryType, short nameResourceID) {
            if (factoryType == null) {
                throw new ArgumentNullException("factoryType");
            }

            _factoryType = factoryType;
            _nameResourceID = nameResourceID;
            _trustLevel = __VSEDITORTRUSTLEVEL.ETL_NeverTrusted;
        }
        
        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute.FactoryType"]' />
        /// <devdoc>
        ///     Returns the editor factory type this attribute declares.
        /// </devdoc>
        public Type FactoryType {
            get {
                return _factoryType;
            }
        }

        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute.TrustLevel"]' />
        /// <devdoc>
        ///     Gets or Sets the trust level for the editor.
        /// </devdoc>
        public __VSEDITORTRUSTLEVEL TrustLevel
        {
            get { return _trustLevel; }
            set { _trustLevel = value; }
        }
        
        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute.NameResourceID"]' />
        /// <devdoc>
        ///     Returns the native resource ID for the factory name.
        /// </devdoc>
        public short NameResourceID {
            get {
                return _nameResourceID;
            }
        }

        private string EditorRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}", FactoryType.GUID.ToString("B")); }
        }

        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyEditorFactory, FactoryType.Name));

            using (Key childKey = context.CreateKey(EditorRegKey))
            {
                childKey.SetValue(string.Empty, FactoryType.Name);
                childKey.SetValue("DisplayName", string.Format(CultureInfo.InvariantCulture, "#{0}", NameResourceID));
                childKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                childKey.SetValue("EditorTrustLevel", (int)_trustLevel);

                // Now report logical views for the editor factory.
                //
                using (Key viewKey = childKey.CreateSubkey("LogicalViews"))
                {
                    TypeConverter converter = TypeDescriptor.GetConverter(typeof(LogicalView));
                    foreach(ProvideViewAttribute pva in FactoryType.GetCustomAttributes(typeof(ProvideViewAttribute), true)) {
                        if (pva.LogicalView != LogicalView.Primary) {
                            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyEditorView, converter.ConvertToString(pva.LogicalView)));
                            Guid logicalView = (Guid)converter.ConvertTo(pva.LogicalView, typeof(Guid));
                            string physicalView = pva.PhysicalView;
                            if (physicalView == null) {
                                physicalView = string.Empty;
                            }
                            viewKey.SetValue(logicalView.ToString("B"), physicalView);
                        }
                    }
                }
            }
        }

        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="Unregister"]' />
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(EditorRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideAssemblyFilterAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideAssemblyFilterAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\ProvideAssemblyFilterAttribute.uex' path='docs/doc[@for="ProvideAssemblyFilterAttribute"]' />
    /// <devdoc>
    ///    Provides an assembly filter for a toolbox item configuration object.  Place this attribute on an object
    ///    that implements IConfigureToolboxItem to describe the assemblies the object wishes to filter.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited = true, AllowMultiple = true)]
    public sealed class ProvideAssemblyFilterAttribute : Attribute {
        private string _assemblyFilter;

        /// <include file='doc\ProvideAssemblyFilterAttribute.uex' path='docs/doc[@for="ProvideAssemblyFilterAttribute.ProvideAssemblyFilterAttribute"]' />
        /// <devdoc>
        ///    Constructor
        /// </devdoc>
        public ProvideAssemblyFilterAttribute(string assemblyFilter) {
            if (assemblyFilter == null) {
                throw new ArgumentNullException("assemblyFilter");
            }

            if (assemblyFilter.Length == 0) {
                throw new ArgumentException(Resources.General_ExpectedNonEmptyString, "assemblyFilter");
            }

            _assemblyFilter = assemblyFilter;
        }

        /// <include file='doc\ProvideAssemblyFilterAttribute.uex' path='docs/doc[@for="ProvideAssemblyFilterAttribute.AssemblyFilter"]' />
        /// <devdoc>
        ///    The filter for the toolbox item configuration object.  Filters are used to optimize which toolbox item configuration objects
        ///    are invoked when a new toolbox item is added.  Filters allow you to specify as much as as little of an assembly as you 
        ///    like.  Here are some examples:
        /// 
        ///    All Assemblies:  *
        ///    Any version of System.Windows.Forms: System.Windows.Forms
        ///    
        /// </devdoc>
        public string AssemblyFilter {
            get {
                return _assemblyFilter;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\OleMenuCommand.cs ===
using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using Microsoft.VisualStudio.OLE.Interop;

namespace Microsoft.VisualStudio.Shell
{
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs"]/*' />
    /// <summary>
    /// This is the set of arguments passed to a OleMenuCommand object when the
    /// Invoke function is called
    /// </summary>
    [CLSCompliant(false)]
    public class OleMenuCmdEventArgs : System.EventArgs
    {
        private object inParam;
        private IntPtr outParam;
        private OLECMDEXECOPT execOptions;

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs.OleMenuCmdEventArgs"]/*' />
        /// <summary>
        /// Builds the OleMenuCmdEventArgs
        /// </summary>
        /// <param name="inParam">The input parameter to the command function.</param>
        /// <param name="outParam">A pointer to the parameter returned by the function</param>
        public OleMenuCmdEventArgs(object inParam, IntPtr outParam) :
            this(inParam, outParam, OLECMDEXECOPT.OLECMDEXECOPT_DODEFAULT)
        {
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs.OleMenuCmdEventArgs"]/*' />
        /// <summary>
        /// Builds the OleMenuCmdEventArgs
        /// </summary>
        /// <param name="inParam">The input parameter to the command function.</param>
        /// <param name="outParam">A pointer to the parameter returned by the function</param>
        /// <param name="options">Execution options for the command.</param>
        public OleMenuCmdEventArgs(object inParam, IntPtr outParam, OLECMDEXECOPT options) : base()
        {
            this.execOptions = options;
            this.inParam = inParam;
            this.outParam = outParam;
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs.InValue"]/*' />
        /// <summary>
        /// Gets the parameter passed as input to the command function
        /// </summary>
        public object InValue
        {
            get { return inParam; }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs.Options"]/*' />
        /// <summary>
        /// Gets the execution options for the command.
        /// </summary>
        public OLECMDEXECOPT Options
        {
            get { return execOptions; }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs.OutValue"]/*' />
        /// <summary>
        /// Gets a pointer to the parameter used as output by the command function
        /// </summary>
        public IntPtr OutValue
        {
            get { return outParam; }
        }
    }

    /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand"]/*' />
    /// <summary>
    /// This class is an expansion of MenuCommand.
    /// </summary>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class OleMenuCommand : MenuCommand, IOleMenuCommand, IMenuCommandInvokeEx
    {
        /// <summary>The event handler called to execute the command.</summary>
        private EventHandler execHandler;
        /// <summary>
        /// The event handler caller before getting the command status; it can be used to
        /// implement a command with a dynamic status.
        /// </summary>
        private EventHandler beforeQueryStatusHandler;
        private string text;
        // Used in the case of dynamic menu (created with the DYNAMICITEMSTART option)
        private int matchedCommandId;
        // If the command supports parameters, then this string will contain the description
        // of the parameters
        private string parametersDescription;

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand"]/*' />
        /// <summary>
        /// Builds a new OleMenuCommand.
        /// </summary>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="id">ID of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, CommandID id) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, null, null, String.Empty);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand1"]/*' />
        /// <summary>
        /// Builds a new OleMenuCommand.
        /// </summary>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="id">ID of the command.</param>
        /// <param name="Text">The text of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, CommandID id, string Text) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, null, null, Text);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand2"]/*' />
        /// <devdoc>
        /// Builds a new OleMenuCommand.
        /// </devdoc>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="changeHandler">The event handler called when the command's status changes.</param>
        /// <param name="id">ID of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, EventHandler changeHandler, CommandID id) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, changeHandler, null, String.Empty);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand3"]/*' />
        /// <devdoc>
        /// Builds a new OleMenuCommand.
        /// </devdoc>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="changeHandler">The event handler called when the command's status changes.</param>
        /// <param name="id">ID of the command.</param>
        /// <param name="Text">The text of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, EventHandler changeHandler, CommandID id, string Text) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, changeHandler, null, Text);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand4"]/*' />
        /// <devdoc>
        /// Builds a new OleMenuCommand.
        /// </devdoc>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="changeHandler">The event handler called when the command's status changes.</param>
        /// <param name="beforeQueryStatus">Event handler called when a lient asks for the command status.</param>
        /// <param name="id">ID of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, EventHandler changeHandler, EventHandler beforeQueryStatus, CommandID id) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, changeHandler, beforeQueryStatus, String.Empty);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand5"]/*' />
        /// <devdoc>
        /// Builds a new OleMenuCommand.
        /// </devdoc>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="changeHandler">The event handler called when the command's status changes.</param>
        /// <param name="beforeQueryStatus">Event handler called when a lient asks for the command status.</param>
        /// <param name="id">ID of the command.</param>
        /// <param name="Text">The text of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, EventHandler changeHandler, EventHandler beforeQueryStatus, CommandID id, string Text) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, changeHandler, beforeQueryStatus, Text);
        }

        private void PrivateInit(EventHandler handler, EventHandler changeHandler, EventHandler beforeQS, string Text)
        {
            execHandler = handler;
            if (changeHandler != null)
            {
                this.CommandChanged += changeHandler;
            }
            beforeQueryStatusHandler = beforeQS;
            text = Text;
            parametersDescription = null;
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.BeforeQueryStatus"]/*' />
        /// <devdoc>
        /// Event fired when a client asks for the status of the command.
        /// </devdoc>
        /// <value></value>
        // Below suppression cannot be added to the fxcop baseline file as the code analysis phase just ignores it.
        [SuppressMessage("Microsoft.Naming","CA1713:EventsShouldNotHaveBeforeOrAfterPrefix", Justification="BASELINE: VSIP Shell MPF")]
        public event EventHandler BeforeQueryStatus
        {
            add { beforeQueryStatusHandler += value; }
            remove { beforeQueryStatusHandler -= value; }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleStatus"]/*' />
        public override int OleStatus
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
            get
            {
                if (null != beforeQueryStatusHandler)
                {
                    beforeQueryStatusHandler(this, EventArgs.Empty);
                }
                return base.OleStatus;
            }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.ParametersDescription"]/*' />
        /// <devdoc>
        /// Get or set the string that describes the paraeters accepted by the command.
        /// </devdoc>
        public string ParametersDescription
        {
            get { return parametersDescription; }
            set { parametersDescription = value; }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.Invoke"]/*' />
        /// <devdoc>
        /// Executes the command.
        /// </devdoc>
        /// <param name="inArg">The parameter passed to the command.</param>
        [PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
        public override void Invoke(object inArg)
        {
            try
            {
                OleMenuCmdEventArgs args = new OleMenuCmdEventArgs(inArg, NativeMethods.InvalidIntPtr);
                execHandler(this, args);
            }
            catch (CheckoutException ex)
            {
                if (CheckoutException.Canceled != ex)
                    throw;
            }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.Invoke1"]/*' />
        /// <devdoc>
        /// Executes the command.
        /// </devdoc>
        /// <param name="inArg">The parameter passed to the command.</param>
        /// <param name="outArg">The parameter returned by the command.</param>
        [EnvironmentPermission(SecurityAction.LinkDemand, Unrestricted = true)]        
        public virtual void Invoke(object inArg, IntPtr outArg)
        {
            Invoke(inArg, outArg, OLECMDEXECOPT.OLECMDEXECOPT_DODEFAULT);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.Invoke2"]/*' />
        /// <summary>
        /// Executes the command with execution options.
        /// </summary>
        /// <param name="inArg">The parameter passed to the command.</param>
        /// <param name="outArg">The parameter returned by the command.</param>
        /// <param name="options">The execution options for the command.</param>
        [EnvironmentPermission(SecurityAction.LinkDemand, Unrestricted = true)]
        [CLSCompliant(false)]
        public virtual void Invoke(object inArg, IntPtr outArg, OLECMDEXECOPT options)
        {
            try
            {
                OleMenuCmdEventArgs args = new OleMenuCmdEventArgs(inArg, outArg, options);
                execHandler(this, args);
            }
            catch (CheckoutException ex)
            {
                if (CheckoutException.Canceled != ex)
                    throw;
            }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.Text"]/*' />
        /// <devdoc>
        /// Gets or sets the text for the command.
        /// </devdoc>
        /// <value></value>
        public virtual string Text
        {
            get { return text; }
            set { if (text != value) { text = value; OnCommandChanged(EventArgs.Empty); } }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.DynamicItemMatch"]/*' />
        /// <devdoc>
        /// Allows a dynamic item command to match the subsequent items in its list.  This must be overriden
        /// when implementing a menu via DYNAMICITEMSTART.
        /// </devdoc>
        /// <param name="cmdId"></param>
        /// <returns></returns>
        public virtual bool DynamicItemMatch(int cmdId)
        {
            return false;
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.MatchedCommandId"]/*' />
        /// <devdoc>
        /// The command id that was most recently used to match this command.  This must be set by the sub-class
        /// when a match occurs and can be used to identify the actual command being invoked.
        /// </devdoc>
        /// <value></value>
        public int MatchedCommandId
        {
            get { return matchedCommandId; }
            set { matchedCommandId = value; }
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideExtenderAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <summary>
    /// This attribute registers the package as an extender.  The GUID passed in determines
    /// what is being extended. The attributes on a package do not control the behavior of
    /// the package, but they can be used by registration tools to register the proper
    /// information with Visual Studio.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideExtenderAttribute : RegistrationAttribute {

        private Guid CATID = Guid.Empty;
        private Guid extender = Guid.Empty;
        private string name;

        /// <summary>
        /// Creates a new ProvideExtenderAttribute.
        /// </summary>
        /// <param name="extendeeCatId">CatId of the element you want to extend.</param>
        /// <param name="extenderGuid">GUID of the extender.</param>
        /// <param name="extenderName">Name of the element you want to extend.</param>
        public ProvideExtenderAttribute(string extendeeCatId, string extenderGuid, string extenderName) 
        {
            CATID = new Guid(extendeeCatId);
            extender = new Guid(extenderGuid);
            name = extenderName;
        }

        /// <summary>
        /// The CatID of the element being extended.
        /// </summary>
        public Guid ExtendeeCatId {
            get {
                return CATID;
            }
        }

        /// <summary>
        /// The Guid of the extender.
        /// </summary>
        public Guid Extender {
            get {
                return extender;
            }
        }

        /// <summary>
        /// The name of the extender.
        /// </summary>
        public string ExtenderName {
            get {
                return name ;
            }
        }

        /// <summary>
        /// The reg key name of this Extender.
        /// </summary>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "Extenders\\{0}\\{1}", CATID.ToString("B"), name);
            }
        }

        /// <summary>
        /// Called to register this attribute with the given context.  The context
        /// contains the location where the registration information should be placed.
        /// it also contains such as the type being registered, and path information.
        /// </summary>
        public override void Register(RegistrationContext context) 
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyExtender, name, CATID.ToString("B")));

            using (Key childKey = context.CreateKey(RegKeyName))
            {
                // Set default value for the Key = Extender GUID
                childKey.SetValue(string.Empty, extender.ToString("B"));
            }
        }

        /// <summary>
        /// Unregister this Extender specification.
        /// </summary>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideEditorLogicalViewAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute adds a logical view to the editor created by an editor factory.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideEditorLogicalViewAttribute : RegistrationAttribute
    {
        private Guid factory;
        private Guid logicalView;
        private bool isTrusted;

        /// <summary>
        /// Creates a new RegisterEditorLogicalView attribute to register a logical
        /// view provided by your editor.
        /// </summary>
        /// <param name="factoryType">The type of factory; can be a Type, a GUID or a string representation of a GUID</param>
        /// <param name="logicalViewGuid">The guid of the logical view to register.</param>
        public ProvideEditorLogicalViewAttribute(object factoryType, string logicalViewGuid)
        {
            this.isTrusted = true;
            this.logicalView = new Guid(logicalViewGuid);
			
            // figure out what type of object they passed in and get the GUID from it
            if (factoryType is string)
                this.factory = new Guid((string)factoryType);
            else if (factoryType is Type)
                this.factory = ((Type)factoryType).GUID;
            else if (factoryType is Guid)
                this.factory = (Guid)factoryType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, factoryType));

        }

        /// <summary>
        /// Get the Guid representing the type of the editor factory
        /// </summary>
        public Guid FactoryType
        {
            get {return factory;}
        }

        /// <summary>
        /// Get the Guid representing the logical view
        /// </summary>
        public Guid LogicalView
        {
            get {return logicalView;}
        }

        /// <summary>
        /// Get or set the trust flag for this logical view. If a view is not trusted, it can not be opened
        /// from a wizard or automation code.
        /// </summary>
        public bool IsTrusted
        {
            get { return isTrusted; }
            set { isTrusted = value; }
        }

        private string EditorPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}", factory.ToString("B")); }
        }

        private string LogicalViewPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "{0}\\LogicalViews", EditorPath); }
        }

        private string UntrustedViewsPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "{0}\\UntrustedLogicalViews", EditorPath); }
        }

        /// <summary>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     It also contains other information such as the type being registered and path information.
        /// </summary>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyEditorView, logicalView.ToString("B")));

            using (Key childKey = context.CreateKey( LogicalViewPath ))
            {
                childKey.SetValue(logicalView.ToString("B"), "");
            }

            // Check if this view can be trusted for automation code.
            if (!IsTrusted)
            {
                // This logical view is not trusted, so we have to add it to the list of the untrusted ones.
                using (Key untrustedViewsKey = context.CreateKey(UntrustedViewsPath))
                {
                    untrustedViewsKey.SetValue(logicalView.ToString("B"), "");
                }

                // Now we should to check the trust level of the editor: if it has an untrusted view its tust
                // level can not be full trust. The problem is that the Key object provided by the context has
                // no GetValue method, so we can not do any check on the previous value of the trust level and
                // all we can do is overwrite it with ETL_HasUntrustedLogicalViews.
                using (Key editorKey = context.CreateKey(EditorPath))
                {
                    editorKey.SetValue("EditorTrustLevel", (int)Microsoft.VisualStudio.Shell.Interop.__VSEDITORTRUSTLEVEL.ETL_HasUntrustedLogicalViews);
                }
            }
        }

        /// <summary>
        /// Unregister this logical view.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveValue(LogicalViewPath, logicalView.ToString("B"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideLanguageExtensionAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideLanguageExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute"]' />
    /// <devdoc>
    ///     This attribute associates a file extension to a given editor factory.  
    ///     The editor factory may be specified as either a GUID or a type and 
    ///     is placed on a package.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideLanguageExtensionAttribute : RegistrationAttribute {

        private Guid languageService;
        private string extension;
        
        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute.ProvideLanguageExtensionAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public ProvideLanguageExtensionAttribute (string languageServiceGuid, string extension) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_ExtensionNeedsDot, extension));
            }

            this.languageService = new Guid(languageServiceGuid);
            this.extension = extension;
        }
        
        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute.ProvideLanguageExtensionAttribute1"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public ProvideLanguageExtensionAttribute (Type languageService, string extension) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_ExtensionNeedsDot, extension));
            }

            this.languageService = languageService.GUID;
            this.extension = extension;
        }
        
        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute.Extension"]' />
        /// <devdoc>
        ///     The file extension of the file.
        /// </devdoc>
        public string Extension {
            get {
                return extension;
            }
        }
        
        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute.LanguageService"]' />
        /// <devdoc>
        ///     The language service SID.
        /// </devdoc>
        public Guid LanguageService {
            get {
                return languageService;
            }
        }

        private string ExtensionsRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Languages\\File Extensions\\{0}", Extension); }
        }

        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLanguageExtension, Extension, LanguageService.ToString("B")));

            using (Key childKey = context.CreateKey(ExtensionsRegKey))
            {
                childKey.SetValue(string.Empty, LanguageService.ToString("B"));
            }
        }

        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="Unregister"]' />
        public override void Unregister(RegistrationContext context) {
            context.RemoveKey(ExtensionsRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideKeyBindingTableAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideKeyBindingTableAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package has a key binding table declared within its 
    ///     CTO file.  This attribute is only used for registration purposes.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideKeyBindingTableAttribute : RegistrationAttribute {
        
        private short   _nameResourceID;
        private Guid    _tableGuid;
        private bool    _allowNavKeys = false;
    
        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.ProvideKeyBindingTableAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideKeyBindingTableAttribute.
        /// </devdoc>
        public ProvideKeyBindingTableAttribute (string tableGuid, short nameResourceID) {
            if (tableGuid == null) {
                throw new ArgumentNullException("tableGuid");
            }
            _tableGuid = new Guid(tableGuid);
            _nameResourceID = nameResourceID;
        }
        
        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.NameResourceID"]' />
        /// <devdoc>
        ///     Returns the key binding table's name resource ID.
        /// </devdoc>
        public short NameResourceID {
            get {
                return _nameResourceID;
            }
        }

        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.TableGuid"]' />
        /// <devdoc>
        ///     Returns the key binding table guid.
        /// </devdoc>
        public Guid TableGuid {
            get {
                return _tableGuid;
            }
        }

        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.AllowNavKeyBinding"]/*' />
        /// <summary>
        /// Set to true if the user can bind new commands of the nagivation keys
        /// </summary>
        public bool AllowNavKeyBinding
        {
            get { return _allowNavKeys; }
            set { _allowNavKeys = value; }
        }

        private string KeyBindingRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "KeyBindingTables\\{0}", TableGuid.ToString("B")); }
        }

        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyKeyBinding, TableGuid.ToString("B"), NameResourceID));

            using (Key childKey = context.CreateKey(KeyBindingRegKey))
            {
                childKey.SetValue(string.Empty, string.Format(CultureInfo.InvariantCulture, "#{0}", NameResourceID));
                childKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                childKey.SetValue("AllowNavKeyBinding", _allowNavKeys ? 1 : 0);
            }
        }

        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.Unregister"]/*' />
        public override void Unregister(RegistrationContext context) {
            context.RemoveKey(KeyBindingRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Package.cs ===
//------------------------------------------------------------------------------
// <copyright file="Package.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing.Design;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Resources;
    using System.Runtime.InteropServices;
    using System.Threading;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;

    using AssemblyEnumerationService = Microsoft.VisualStudio.AssemblyEnumerationService;
    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\Package.uex' path='docs/doc[@for="Package"]' />
    /// <devdoc>
    ///     This class implements IVsPackage.  It provides a 
    ///     framework-friendly way to define a package and its associated 
    ///     services.
    /// </devdoc>
    [PackageRegistrationAttribute()]
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class Package : 

        IVsPackage, 
        IOleServiceProvider,
        IOleCommandTarget,
        IVsPersistSolutionOpts, 
        IServiceContainer,
        IVsUserSettings,
        IVsUserSettingsMigration,
        IVsToolWindowFactory,
        IVsToolboxItemProvider
    {

        private ServiceProvider     _provider;
        private ServiceCollection<object>  _services = new ServiceCollection<object>();
        private Hashtable           _editorFactories;
        private Hashtable           _projectFactories;
        private ToolWindowCollection  _toolWindows;          // this is the list of all toolwindows
        private Container           _componentToolWindows; // this is the toolwindows that implement IComponent
        private Container           _pagesAndProfiles;
        private ArrayList           _optionKeys;
        private Dictionary<string, System.Windows.Forms.IDataObject> _tbxItemDataCache = new Dictionary<string, System.Windows.Forms.IDataObject>();


        
        private enum ProfileManagerLoadAction
        {
            None,
            LoadPropsFromRegistry,
            ResetSettings
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.Package"]' />
        /// <devdoc>
        ///     Simple constructor.
        /// </devdoc>
        protected Package() {
            ServiceCreatorCallback callback = new ServiceCreatorCallback(OnCreateService);
            ((IServiceContainer)this).AddService(typeof(IMenuCommandService), callback);
            ((IServiceContainer)this).AddService(typeof(IOleCommandTarget), callback);
        }
    
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ToolboxInitialized"]' />
        /// <devdoc>
        ///     This event is raised when the toolbox is freshly initialized.
        ///     If you provide tools for the toolbox you should add them when
        ///     this event is raised.
        /// </devdoc>
        protected event EventHandler ToolboxInitialized;
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ToolboxUpgraded"]' />
        /// <devdoc>
        ///     This event is raised when the toolbox is upgraded to a
        ///     new version.  You should perform any work needed to
        ///     upgrade the toolbox here.
        /// </devdoc>
        protected event EventHandler ToolboxUpgraded;

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ApplicationRegistryRoot"]' />
        /// <devdoc>
        ///     This property returns the registry root for the application.
        ///     Typically this is HKLM\Software\Microsoft\VisualStudio\[ver]
        ///     but this can change based on any alternate root that the
        ///     shell was initialized with.  This key is read-only.
        /// </devdoc>
        public RegistryKey ApplicationRegistryRoot {
            get {
                return VSRegistry.RegistryRoot(_provider, __VsLocalRegistryType.RegType_Configuration, false);
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.UserDataPath"]' />
        /// <devdoc>
        ///     This property returns the path to user data storage for
        ///     Visual Studio.  Typically this is %USERPROFILE%\Application Data\
        ///     Visual Studio\[ver] but this can change based on any
        ///     alternate root that the shell was initialized with.
        /// </devdoc>
        public string UserDataPath {
            get {
                // Get the registry root and remove the SOFTWARE\ part
                string registryRoot = GetRegistryRoot();
                registryRoot = registryRoot.Substring("SOFTWARE\\".Length);
    
                string appData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
    
                return Path.Combine(appData, registryRoot);
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.UserDataPath"]' />
        /// <devdoc>
        ///     This property returns the path to user data storage for
        ///     Visual Studio.  Typically this is %USERPROFILE%\Local Settings\Application Data\
        ///     Visual Studio\[ver] but this can change based on any
        ///     alternate root that the shell was initialized with.
        /// </devdoc>
        public string UserLocalDataPath {
            get {
                // Get the registry root and remove the SOFTWARE\ part
                string registryRoot = GetRegistryRoot();
                registryRoot = registryRoot.Substring("SOFTWARE\\".Length);
    
                string appData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
    
                return Path.Combine(appData, registryRoot);
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.UserRegistryRoot"]' />
        /// <devdoc>
        ///     This property returns the registry root for the current
        ///     user.  Typically this is HKCU\Software\Microsoft\VisualStudio\[ver]
        ///     but this can change based on any alternate root that the shell
        ///     is initialized with.  This key is read-write.
        /// </devdoc>
        public RegistryKey UserRegistryRoot {
            get {
                return VSRegistry.RegistryRoot(_provider, __VsLocalRegistryType.RegType_UserSettings, true);
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.AddOptionKey"]' />
        /// <devdoc>
        ///     This method adds a user option key name into the list of
        ///     option keys that we will load and save from the solution
        ///     file.  You should call this early in your constructor.
        ///     Calling this will cause the OnLoadOptions and
        ///     OnSaveOptions methods to be invoked for each key you
        ///     add.
        /// </devdoc>
        protected void AddOptionKey(string name) {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (name == null) {
                throw new ArgumentNullException("name");
            }

            // the key is the class name of the service interface.  Note that
            // while it would be a lot more correct to use the fully-qualified class
            // name, IStorage won't have it and returns STG_E_INVALIDNAME.  The
            // doc's don't have any information here; I can only assume it is because
            // of the '.'.

            // clovett: According to the docs for IStorage::CreateStream, the name
            // cannot be longer than 31 characters.
            if (name.IndexOf('.') != -1 || name.Length > 31) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Package_BadOptionName, name));
            }

            if (_optionKeys == null) {
                _optionKeys = new ArrayList();
            }
            else {
                if (_optionKeys.Contains(name)) {
                    throw new ArgumentException(string.Format(Resources.Culture, Resources.Package_OptionNameUsed, name));
                }
            }
            _optionKeys.Add(name);
        }



        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ExportSettings"]' />
        /// <devdoc>
        ///     This method implements the IVsUserSettings Interface
        ///     used to manage profiles and import/export settings
        ///     to XML files.
        /// </devdoc>
        int IVsUserSettings.ExportSettings(string strPageGuid, IVsSettingsWriter writer) {
            Debug.Assert(strPageGuid != null && strPageGuid.Length > 0, "Passed page guid cannot be null");
            Debug.Assert(writer != null, "IVsSettingsWriter cannot be null");

            Guid requestPageGuid = new Guid(strPageGuid);
            IProfileManager profileManager = GetProfileManager(requestPageGuid, ProfileManagerLoadAction.LoadPropsFromRegistry);
            if(profileManager != null) {
                profileManager.SaveSettingsToXml(writer);
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.MigrateSettings"]' />
        /// <devdoc>
        ///     This method implements the IVsUserSettingsMigration Interface
        ///     used to bring forward user settings from a previous version.
        /// </devdoc>
        int IVsUserSettingsMigration.MigrateSettings(IVsSettingsReader reader, IVsSettingsWriter writer, string strPageGuid) {
            
            Debug.Assert(strPageGuid != null && strPageGuid.Length > 0, "Passed page guid cannot be null");
            Debug.Assert(reader != null, "IVsSettingsReader cannot be null");
            Debug.Assert(writer != null, "IVsSettingsWriter cannot be null");

            Guid requestPageGuid = Guid.Empty;

            try
            {
                requestPageGuid = new Guid(strPageGuid);
            }
            catch (FormatException)
            {
                // If this is thrown, it means strPageGuid is not really a GUID, but rather a
                // tools options page name like "Environment.General".
            }

            IProfileMigrator profileMigrator = null;

            if (requestPageGuid == Guid.Empty)
            {
                profileMigrator = GetAutomationObject(strPageGuid) as IProfileMigrator;
            }
            else
            {
                profileMigrator = GetProfileManager(requestPageGuid, ProfileManagerLoadAction.None) as IProfileMigrator;
            }

            if(profileMigrator != null) {
                profileMigrator.MigrateSettings(reader, writer);
            }
            return NativeMethods.S_OK;
        }


        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ImportSettings"]' />
        /// <devdoc>
        ///     This method implements the IVsUserSettings Interface
        ///     used to manage profiles and import/export settings
        ///     to XML files.
        /// </devdoc>
        int IVsUserSettings.ImportSettings(string strPageGuid, IVsSettingsReader reader, uint flags, ref int restartRequired) {

            // nobody should require a restart...
            if (restartRequired > 0)
                restartRequired = 0;

            Debug.Assert(strPageGuid != null && strPageGuid.Length > 0, "Passed page guid cannot be null");
            Debug.Assert(reader != null, "IVsSettingsReader cannot be null");

            bool loadPropsFromRegistry = (flags & (uint)__UserSettingsFlags.USF_ResetOnImport) == 0;

            Guid requestPageGuid = new Guid(strPageGuid);
            IProfileManager profileManager = GetProfileManager(requestPageGuid, loadPropsFromRegistry ? ProfileManagerLoadAction.LoadPropsFromRegistry : ProfileManagerLoadAction.ResetSettings);
            if(profileManager != null) {
                // we get the live instance (if any) when we load
                profileManager.LoadSettingsFromXml(reader);
                // update the store
                profileManager.SaveSettingsToStorage();
            }
            return NativeMethods.S_OK;
        }


        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.Dispose"]' />
        /// <devdoc>
        ///     This method will be called by Visual Studio in reponse
        ///     to a package close (disposing will be true in this
        ///     case).  The default implementation revokes all
        ///     services and calls Dispose() on any created services
        ///     that implement IDisposable.
        /// </devdoc>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        protected virtual void Dispose(bool disposing) {
            if (disposing) {

                // Unregister any registered editor factories.
                //
                if (_editorFactories != null)
                {
                    Hashtable editorFactories = _editorFactories;
                    _editorFactories = null;

                    try {
                        IVsRegisterEditors registerEditors = GetService(typeof(SVsRegisterEditors)) as IVsRegisterEditors;
                        foreach (DictionaryEntry de in editorFactories) {
                            try {
                                if (registerEditors != null) {
                                    // Don't check for the return value because, even if this unregister fails,
                                    // we have anyway to try to unregister the others.
                                    registerEditors.UnregisterEditor((uint)de.Value);
                                }
                            }
                            catch (Exception) { /* do nothing */ }
                            finally {
                                IDisposable disposable = de.Key as IDisposable;
                                if (disposable != null) {
                                    disposable.Dispose();
                                }
                            }
                        }
                    }
                    catch (Exception e) {
                        Debug.Fail(String.Format("Failed to dispose editor factories for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }
                // Unregister any registered project factories.
                //
                if (_projectFactories != null)
                {
                    Hashtable projectFactories = _projectFactories;
                    _projectFactories = null;
                    try
                    {
                        IVsRegisterProjectTypes registerProjects = GetService(typeof(SVsRegisterProjectTypes)) as IVsRegisterProjectTypes;

                        foreach (DictionaryEntry de in projectFactories)
                        {
                            try
                            {
                                if (registerProjects != null)
                                {
                                    // As above, don't check for the return value.
                                    registerProjects.UnregisterProjectType((uint)de.Value);
                                }
                            }
                            finally
                            {
                                IDisposable disposable = de.Key as IDisposable;
                                if (disposable != null)
                                {
                                    disposable.Dispose();
                                }
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        Debug.Fail(String.Format("Failed to dispose project factories for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }

                // Dispose all IComponent ToolWindows
                //
                if (_componentToolWindows != null)
                {
                    Container componentToolWindows = _componentToolWindows;
                    _componentToolWindows = null;
                    try
                    {
                        componentToolWindows.Dispose();
                    }
                    catch (Exception e)
                    {
                        Debug.Fail(String.Format("Failed to dispose component toolwindows for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }

                // Dispose all pages.
                //
                if (_pagesAndProfiles != null)
                {
                    Container pagesAndProfiles = _pagesAndProfiles;
                    _pagesAndProfiles = null;
                    try
                    {
                        pagesAndProfiles.Dispose();
                    }
                    catch (Exception e)
                    {
                        Debug.Fail(String.Format("Failed to dispose component toolwindows for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }

                // Enumerate the service list and destroy all services.  This should
                // always be done last.
                //
                if (_services != null && _services.Count > 0)
                {
                    try
                    {
                        IProfferService ps = (IProfferService)GetService(typeof(SProfferService));
                        ServiceCollection<object> services = _services;
                        _services = null;

                        foreach (object value in services.Values)
                        {

                            object service = value;
                            ProfferedService proffer = service as ProfferedService;
                            try
                            {
                                if (null != proffer)
                                {
                                    service = proffer.Instance;
                                    if (proffer.Cookie != 0 && ps != null)
                                    {
                                        int hr = ps.RevokeService(proffer.Cookie);
                                        if (NativeMethods.Failed(hr))
                                        {
                                            Debug.Fail(String.Format(CultureInfo.CurrentUICulture, "Failed to unregister service {0}", service.GetType().FullName));
                                            Trace.WriteLine(String.Format(CultureInfo.CurrentUICulture, "Failed to unregister service {0}", service.GetType().FullName));
                                        }
                                    }
                                }
                            }
                            finally
                            {
                                if (service is IDisposable)
                                {
                                    ((IDisposable)service).Dispose();
                                }
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        Debug.Fail(String.Format("Failed to dispose proffered service for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }

                // Disallow any service requests after this.
                //
                if (_provider != null)
                {
                    try
                    {
                        _provider.Dispose();
                    }
                    catch (Exception e)
                    {
                        Debug.Fail(String.Format("Failed to dispose the service provider for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                    _provider = null;
                }

                if (_toolWindows != null)
                {
                    _toolWindows.Dispose();
                    _toolWindows = null;
                }

                if (_optionKeys != null)
                {
                    _optionKeys = null;
                }

                // Disconnect user preference change events
                //
                SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(OnUserPreferenceChanged);
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetAutomationObject"]' />
        /// <devdoc>
        ///     This method returns the automation object for this package.
        ///     The default implementation will return null if name is null, indicating there
        ///     is no default automation object.  If name is non null, this will walk metadata
        ///     attributes searching for an option page that has a name of the format
        ///     &lt;Category&gt;.&lt;Name&gt;.  If the option page has this format and indicates that it
        ///     supports automation, its automation object will be returned.
        /// </devdoc>
        protected virtual object GetAutomationObject(string name) {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (name == null) {
                return null;
            }

            string[] nameParts = name.Split(new char[] {'.'});
            if (nameParts.Length != 2) {
                return null;
            }

            nameParts[0] = nameParts[0].Trim();
            nameParts[1] = nameParts[1].Trim();

            AttributeCollection attributes = TypeDescriptor.GetAttributes(this);
            foreach(Attribute attr in attributes) {
                ProvideOptionPageAttribute pa = attr as ProvideOptionPageAttribute;
                if (pa != null && pa.SupportsAutomation) {

                    // Check to see if the name matches.
                    //
                    if (string.Compare(pa.CategoryName, nameParts[0], StringComparison.OrdinalIgnoreCase) != 0) {
                        continue;
                    }

                    if (string.Compare(pa.PageName, nameParts[1], StringComparison.OrdinalIgnoreCase) != 0) {
                        continue;
                    }

                    // Ok, the name matches.  Return this page's automation object.
                    //
                    DialogPage page = GetDialogPage(pa.PageType);
                    return page.AutomationObject;
                }
            }

            // Failed.
            //
            return null;
        }

        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetDialogPage"]' />
        /// <devdoc>
        ///     This method returns the requested dialog page.  Dialog
        ///     pages are cached so they can keep a single instance
        ///     of their state.  This method allows a deriving class
        ///     to get a cached dialog page.  The object will be 
        ///     dynamically created if it is not in the cache.
        /// </devdoc>
        protected DialogPage GetDialogPage(Type dialogPageType) {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (dialogPageType == null) {
                throw new ArgumentNullException("dialogPageType");
            }

            if (!typeof(DialogPage).IsAssignableFrom(dialogPageType)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Package_BadDialogPageType, dialogPageType.FullName));
            }

            if (_pagesAndProfiles != null) {
                foreach(object page in _pagesAndProfiles.Components) {
                    if (page.GetType() == dialogPageType) {
                        return (DialogPage)page;
                    }
                }
            }

            // Create a new instance of this option page.
            //
            ConstructorInfo ctor = dialogPageType.GetConstructor(new Type[] {});
            if (ctor == null) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Package_PageCtorMissing, dialogPageType.FullName));
            }

            DialogPage p = (DialogPage)ctor.Invoke(new object[] {});
            
                        
            if (_pagesAndProfiles == null) {
                _pagesAndProfiles = new PackageContainer(this);
            }
            _pagesAndProfiles.Add(p);

            return p;
        }


        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetProfileManager"]' />
        /// <devdoc>
        ///     This method returns the requested profile manager based on its guid.
        ///     Profile managers are cached so they can keep a single instance
        ///     of their state.  This method allows a deriving class
        ///     to get a cached profile manager.  The object will be 
        ///     dynamically created if it is not in the cache.
        /// </devdoc>
        private IProfileManager GetProfileManager(Guid objectGuid, ProfileManagerLoadAction loadAction) {
            
            IProfileManager result = null;

            if(objectGuid == Guid.Empty) {
                throw new ArgumentNullException("objectGuid");
            }
            if (_pagesAndProfiles != null) {
                foreach(object profileManager in _pagesAndProfiles.Components) {
                    if (profileManager.GetType().GUID.Equals(objectGuid)) {
                        if (profileManager is IProfileManager)
                        {
                            result = profileManager as IProfileManager;
                            if (result != null)
                            {
                                switch (loadAction) {
                                    case ProfileManagerLoadAction.LoadPropsFromRegistry:
                                        result.LoadSettingsFromStorage();
                                        break;
                                    case ProfileManagerLoadAction.ResetSettings:
                                        result.ResetSettings();
                                        break;
                                }
                            }
                        }

                        // No need to keep on looking in the attributes since
                        // we've found the one we were looking for.

                        break;
                    }
                }
            }

            if (result == null) {

                // Didn't find it in our cache.  Now look in the metadata attributes
                // for the class.  Look at all types at the same time.
                //
                AttributeCollection attributes = TypeDescriptor.GetAttributes(this);
                foreach(Attribute attr in attributes) {
                    if (attr is ProvideProfileAttribute) {
                        Type objectType = ((ProvideProfileAttribute)attr).ObjectType;
                        if (objectType.GUID.Equals(objectGuid)) {

                            // found it... now instanciate since it was not in the cache
                            // if not build a constructor for it

                            ConstructorInfo ctor = objectType.GetConstructor(new Type[] {});
                            if (ctor == null) {
                                throw new ArgumentException(string.Format(Resources.Culture, Resources.Package_PageCtorMissing, objectType.FullName));
                            }
                            result = (IProfileManager)ctor.Invoke(new object[] {});

                            // if it's a DialogPage cache it
                            if(result != null) {
                                if(_pagesAndProfiles == null) {
                                    _pagesAndProfiles = new PackageContainer(this);
                                }
                                _pagesAndProfiles.Add((IComponent)result);
                            }

                            // No need to load settings from storage on first creation
                            // since that happens because of the Add above.

                            break;
                        }
                    }
                }
            }
            return result;
        }

        
        /// <devdoc>
        ///     Retrieves the shell's root key for VS options, or uses the value of
        ///     the DefaultRegistryRootAttribute if we coundn't get the shell service.
        /// </devdoc>
        private string GetRegistryRoot() {
            string regisrtyRoot;
    
            IVsShell vsh = (IVsShell)GetService(typeof(SVsShell));
            if (vsh == null) {
                // Search our custom attributes for an instance of DefaultRegistryRoot
                //
                DefaultRegistryRootAttribute regRootAttr = (DefaultRegistryRootAttribute)TypeDescriptor.GetAttributes(this.GetType())[typeof(DefaultRegistryRootAttribute)];
                if (regRootAttr == null) {
                    Debug.Fail("Package should have a registry root attribute");
                    throw new NotSupportedException();
                }
    
                regisrtyRoot = @"SOFTWARE\Microsoft\VisualStudio\" + regRootAttr.Root;
            }
            else {
                object obj;
                NativeMethods.ThrowOnFailure( vsh.GetProperty((int)__VSSPROPID.VSSPROPID_VirtualRegistryRoot, out obj) );
                regisrtyRoot = obj.ToString();
            }
    
            return regisrtyRoot;
        }
    
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetService"]' />
        /// <devdoc>
        ///     IServiceProvider implementation.
        /// </devdoc>
        protected object GetService(Type serviceType) {
            if (zombie)
                return null;

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            // Check for the special services we provide.
            //
            if (serviceType.IsEquivalentTo(typeof(IServiceContainer)) || serviceType.IsEquivalentTo(typeof(Package)) || serviceType.IsEquivalentTo(this.GetType())) {
                return this;
            }

            object value = null;

            // Check our service list
            //
            if (_services != null && _services.Count > 0) {
                lock (serviceType) {
                    
                    if (_services.ContainsKey(serviceType))
                        value = _services[serviceType];

                    if (value is ProfferedService) {
                        value = ((ProfferedService)value).Instance;
                    }

                    if (value is ServiceCreatorCallback) {

                        // In case someone recursively requests the same service, 
                        // null out the service type here.  That way they'll just
                        // fail instead of stack fault.
                        //
                        _services[serviceType] = null;


                        value = ((ServiceCreatorCallback)value)(this, serviceType);
                        if (value == null)
                        {
                            string message = "An object was not returned from a service creator callback for the registered type of " + serviceType.Name + ".  This may mean that it failed a type equivalence comparison.  To compare type objects you must use Type.IsEquivalentTo(Type).  Do not use .Equals or the == operator.";

                            // If this fails, it will likely indicate that the pacakge did a .Equals or == on the Service type which may fail type equivalence.
                            IVsAppCommandLine appCmdLine = GetService(typeof(SVsAppCommandLine)) as IVsAppCommandLine;
                            if (appCmdLine != null)
                            {
                                // If we are running under the experimental hive, notify the VSIP developer that this is incorrect.
                                string suffix;
                                int fPresent = 0;
                                appCmdLine.GetOption("RootSuffix", out fPresent, out suffix);
                                if (fPresent == 1 && string.Compare(suffix, "Exp", StringComparison.OrdinalIgnoreCase) == 0)
                                {
                                    System.Windows.Forms.MessageBox.Show(message);
                                }
                            }


                            Debug.Fail(message);
                        }
                        else if (!value.GetType().IsCOMObject && !serviceType.IsAssignableFrom(value.GetType()))
                        {
                            // Callback passed us a bad service.  NULL it, rather than throwing an exception.
                            // Callers here do not need to be prepared to handle bad callback implementations.
                            Debug.Fail("Object " + value.GetType().Name + " was returned from a service creator callback but it does not implement the registered type of " + serviceType.Name);
                            value = null;
                        }
                        _services[serviceType] = value;
                    }
                }
            }

            // Delegate to the parent provider, but only if we have verified that _services doesn't actually contain our key
            // if it does, that means that we're in the middle of trying to resolve this service, and the service resolution
            // has recursed.
            //
            Debug.Assert(value != null || _services == null || _services.Count == 0 || !_services.ContainsKey(serviceType), "GetService is recursing on itself while trying to resolve the service " + serviceType.Name + ". This means that someone is asking for this service while the service is trying to create itself.  Breaking the recursion now and aborting this GetService call.");
            if (value == null && _provider != null && (_services == null || _services.Count == 0 || !_services.ContainsKey(serviceType))) {
                value = _provider.GetService(serviceType);
            }

            return value;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.Initialize"]/*' />
        /// <devdoc>
        /// This method is called when the package is first 
        /// initialized.  Override it if you need to do work
        /// that happens as part of package initialization.
        /// </devdoc>
        protected virtual void Initialize() {
            // If we have services to proffer, do that now.
            //
            if (_services.Count > 0)
            {
                IProfferService ps = (IProfferService)GetService(typeof(SProfferService));

                Debug.Assert(ps != null, "We have services to proffer but IProfferService is not available.");
                if (ps != null) {

                    foreach (KeyValuePair<Type, object> pair in _services)
                    {
                        ProfferedService service = pair.Value as ProfferedService;

                        if (service != null) {
                            uint cookie;
                            Guid serviceGuid = (Guid)pair.Key.GUID;
                            NativeMethods.ThrowOnFailure(
                                ps.ProfferService(ref serviceGuid, this, out cookie)
                            );
                            service.Cookie= cookie;
                        }
                    }
                }
            }

            // Initialize this thread's culture info with that of the shell's LCID
            //
            int locale = GetProviderLocale();
            Thread.CurrentThread.CurrentUICulture = new CultureInfo(locale);

            // Begin listening to user preference change events
            //
            SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(OnUserPreferenceChanged);
            
            // Be sure to load the package user options from the solution in case
            // the package was not already loaded when the solution was opened.
            if (null != _optionKeys)
            {
                try {
                    IVsSolutionPersistence pPersistance = (IVsSolutionPersistence)this.GetService(typeof(SVsSolutionPersistence));
                    if (pPersistance != null) {
                        foreach (string key in _optionKeys) {
                            // NOTE: don't check for the error code because a failure here is
                            // expected and not a problem.
                            pPersistance.LoadPackageUserOpts(this, key);
                        }
                    }
                } catch (Exception) {
                    // no settings found, no problem.
                }
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.QueryClose"]/*' />
        /// <devdoc>
        /// Called to ask the package if the shell can be closed.
        /// </devdoc>
        /// <param name="canClose">Set canClose to false if you want to prevent the shell from closing</param>
        /// <returns>HRESULT</returns>
        protected virtual int QueryClose(out bool canClose)
        {
            canClose = true;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetProviderLocale"]' />
        /// <devdoc>
        /// Return the locale associated with this IServiceProvider.
        /// </devdoc>
        public int GetProviderLocale() {
            CultureInfo ci = CultureInfo.CurrentCulture;
            int lcid = ci.LCID;
            IUIHostLocale loc = (IUIHostLocale)GetService(typeof(IUIHostLocale));
            Debug.Assert(loc != null, "Unable to get IUIHostLocale, defaulting CLR designer to current thread LCID");
            if (loc != null) {
                uint locale;
                NativeMethods.ThrowOnFailure(loc.GetUILocale(out locale));
                lcid = (int)locale;
            }
            return lcid;
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.CreateInstance"]/*' />
        /// <devdoc>
        /// Create the specified COM object using Visual Studio's ILocalRegistry
        /// and cast it to the given managed type.  If VS cannot create it, then
        /// fall back to Activator.CreateInstance.  This allows managed classes
        /// to be registered in local to the particular VS version in 
        /// HKLM\Software\Microsoft\VisualStudio\8.0\clsid.
        /// </devdoc>
        public object CreateInstance(ref Guid clsid, ref Guid iid, Type type) {
            object result = null;
            IntPtr pUnk = this.CreateInstance(ref clsid, ref iid);
            if (pUnk != IntPtr.Zero) {
                try {
                    result = Marshal.GetTypedObjectForIUnknown(pUnk, type);
                } finally {
                    Marshal.Release(pUnk);
                }
            } else {
                result = Activator.CreateInstance(type);
            }
            return result;
        }

        private IntPtr CreateInstance(ref Guid clsid, ref Guid iid) {
            ILocalRegistry3 localRegistry = this.GetService(typeof(SLocalRegistry)) as ILocalRegistry3;
            IntPtr pUnk;
            NativeMethods.ThrowOnFailure(localRegistry.CreateInstance(clsid, null, ref iid, NativeMethods.CLSCTX_INPROC_SERVER, out pUnk));
            localRegistry = null;
            return pUnk;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetOutputPane"]/*' />
        /// <devdoc>
        /// Return the specified output window pane.  If the pane is not found, 
        /// create it with the given caption.
        /// </devdoc>
        public IVsOutputWindowPane GetOutputPane(Guid page, string caption) {
            IVsOutputWindow outputWindow = this.GetService(typeof(SVsOutputWindow)) as IVsOutputWindow;
            Debug.Assert(outputWindow != null, "Cannot find IVsOutputWindow");
            IVsOutputWindowPane pane = null;
            int hr = outputWindow.GetPane(ref page, out pane);
            if ( NativeMethods.Failed(hr) )
            {
                if (caption != null) {
                    hr = outputWindow.CreatePane(ref page, caption, 1, 1);
                    if ( NativeMethods.Succeeded(hr) ) {
                        // Don't throw or fail here: a null pane is an expected value.
                        outputWindow.GetPane(ref page, out pane);
                    }
                }
            }
            if (pane != null) 
                NativeMethods.ThrowOnFailure( pane.Activate() );
            return pane;
        }

        /// <devdoc>
        ///     ServiceCreatorCallback implementation for the services we offer on demand.
        /// </devdoc>
        private object OnCreateService(IServiceContainer container, Type serviceType) {

            // Menu commands.  IOleCommandTarget is implemented on IMenuCommandService,
            // so we offer both as services and delegate the creation of IOleCommandTarget
            // to IMenuCommandService.
            //
            if (serviceType.IsEquivalentTo(typeof(IOleCommandTarget))) {
                object commandService = GetService(typeof(IMenuCommandService));
                if (commandService is IOleCommandTarget) {
                    return commandService;
                }
                Debug.Fail("IMenuCommandService is either unavailable or does not implement IOleCommandTarget");
            }
            else if (serviceType.IsEquivalentTo(typeof(IMenuCommandService))) {
                return new OleMenuCommandService(this);
            }

            Debug.Fail("OnCreateService invoked for a service we didn't add");
            return null;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.OnLoadOptions"]/*' />
        /// <devdoc>
        /// This method can be overridden by the deriving
        /// class to load solution options.
        /// </devdoc>
        protected virtual void OnLoadOptions(string key, Stream stream) {
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.OnSaveOptions"]/*' />
        /// <devdoc>
        /// This method can be overridden by the deriving
        /// class to save solution options.
        /// </devdoc>
        protected virtual void OnSaveOptions(string key, Stream stream) {
        }

        /// <devdoc>
        ///     Invoked when a user setting has changed.  Here we invalidate
        ///     the cached locale data so we can obtain updated culture information.
        /// </devdoc>
        private void OnUserPreferenceChanged(object sender, UserPreferenceChangedEventArgs e) {
            if (e.Category == UserPreferenceCategory.Locale) {
                CultureInfo.CurrentCulture.ClearCachedData();
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ParseToolboxResource"]/*' />
        /// <devdoc>
        /// Parses a toolbox resource format and adds the toolbox items to the toolbox.  This
        /// method can be used to automatically add items to the toolbox.  The resource data
        /// is passed in through the resourceData parameter and consists of a text file with
        /// the following format:
        /// ; Comment
        /// [CategoryName]
        /// &lt;class name&gt;, &lt;assembly name&gt;
        /// The category name can be localized through the localizedCategorized resource
        /// manager that is passed into this method.  The localizedCategories parameter
        /// may be null, in which case the category names will not be localized.
        /// The assembly name may either be a fully qualified name, or a partial name.
        /// If a partial name is passed, the latest assembly of that partial name will
        /// be loaded.
        /// </devdoc>
        protected void ParseToolboxResource(TextReader resourceData, ResourceManager localizedCategories) {
            ParseToolboxResource(resourceData, localizedCategories, Guid.Empty);
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ParseToolboxResource"]/*' />
        /// <devdoc>
        /// Parses a toolbox resource format and adds the toolbox items to the toolbox.  This
        /// method can be used to automatically add items to the toolbox.  The resource data
        /// is passed in through the resourceData parameter and consists of a text file with
        /// the following format:
        /// ; Comment
        /// [CategoryName]
        /// &lt;class name&gt;, &lt;assembly name&gt;
        /// The category name can be localized through the localizedCategorized resource
        /// manager that is passed into this method.  The localizedCategories parameter
        /// may be null, in which case the category names will not be localized.
        /// The assembly name may either be a fully qualified name, or a partial name.
        /// If a partial name is passed, the latest assembly of that partial name will
        /// be loaded.
        /// </devdoc>
        protected void ParseToolboxResource(TextReader resourceData, Guid packageGuid) {
            ParseToolboxResource(resourceData, null, packageGuid);
        }


        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ParseToolboxResource"]/*' />
        /// <devdoc>
        /// Parses a toolbox resource format and adds the toolbox items to the toolbox.  This
        /// method can be used to automatically add items to the toolbox.  The resource data
        /// is passed in through the resourceData parameter and consists of a text file with
        /// the following format:
        /// ; Comment
        /// [CategoryName]
        /// &lt;class name&gt;, &lt;assembly name&gt;
        /// The category name can be localized through the localizedCategorized resource
        /// manager that is passed into this method.  The localizedCategories parameter
        /// may be null, in which case the category names will not be localized.
        /// The assembly name may either be a fully qualified name, or a partial name.
        /// If a partial name is passed, the latest assembly of that partial name will
        /// be loaded.
        /// </devdoc>
        private void ParseToolboxResource(TextReader resourceData, ResourceManager localizedCategories, Guid packageGuid) {

            if (resourceData == null) {
                throw new ArgumentNullException("resourceData");
            }

            IToolboxService tbx = GetService(typeof(IToolboxService)) as IToolboxService;
            if (tbx == null) {
                Debug.Fail("Missing toolbox service");
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.General_MissingService, typeof(IToolboxService).FullName));
            }

            IVsToolbox vstbx = GetService(typeof(SVsToolbox)) as IVsToolbox;
            IVsToolbox2 vsToolbox2 = vstbx as IVsToolbox2;
            IVsToolbox3 vsToolbox = vstbx as IVsToolbox3;
            if (vsToolbox == null) {
                Debug.Fail("Missing VS toolbox service");
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.General_MissingService, typeof(SVsToolbox).FullName));
            }

            string line = resourceData.ReadLine();
            string currentCategory = null;
            string rawCategory = null;

            while(line != null) {

                try
                {
                    line = line.Trim();

                    if (line.Length != 0)
                    {
                        if (line.StartsWith(";", StringComparison.OrdinalIgnoreCase))
                        {
                            // Ignore this comment
                        }
                        else if (line.StartsWith("[", StringComparison.OrdinalIgnoreCase) && line.EndsWith("]", StringComparison.OrdinalIgnoreCase))
                        {

                            // This line is a toolbox category name.  Create a new category.
                            //
                            currentCategory = line.Trim(new char[] { '[', ']' }).Trim();
                            rawCategory = currentCategory;

                            if (localizedCategories != null) {
                                string locCategory = localizedCategories.GetString(currentCategory);
                                if (locCategory == null) {
                                    Debug.Fail("Category name " + currentCategory + " has not been localized");
                                }
                                else {
                                    currentCategory = locCategory;
                                }
                            }

                            bool categoryAdded = false;
                            if (!String.IsNullOrEmpty(currentCategory)) {
                                if (packageGuid != Guid.Empty && vsToolbox2 != null) {
                                    vsToolbox2.AddTab2(currentCategory, ref packageGuid);   //represents a native resource when package is sent in.
                                    if (!String.IsNullOrEmpty(rawCategory) && vsToolbox != null)
                                    {
                                        vsToolbox.SetIDOfTab(currentCategory, packageGuid.ToString("B") + "-" + rawCategory);
                                        rawCategory = null;
                                    }
                                    categoryAdded = true;
                                }
                                else if (vstbx != null) {
                                    //add the tab -- even if there are no items...
                                    vstbx.AddTab(currentCategory);
                                    categoryAdded = true;
                                }
                                if (categoryAdded && !String.IsNullOrEmpty(rawCategory) && vsToolbox != null)
                                {
                                    vsToolbox.SetIDOfTab(currentCategory, rawCategory);
                                    rawCategory = null;
                                }
                            }
                        }
                        else {

                            // The line is a toolbox item class.  Discover the type.  The
                            // type name is an assembly qualified name.  If it is fully 
                            // qualified we can load it directly.  If it isn't, then we must use the
                            // sdk enumeration service to find the assembly with the matching name.
                            // This allows toolbox item providers to list simple names in their toolbox item
                            // definition files, but do a strong bind.
                            //
                            int idx = line.IndexOf(",");
                            if (idx == -1)
                            {
                                Debug.Fail("Bad line: " + line);
                            }
                            else
                            {
                                string typeName = line.Substring(0, idx).Trim();
                                string assemblyName = line.Substring(idx + 1).Trim();

                                if (assemblyName.IndexOf(",") == -1)
                                {
                                    // Must use the assembly enumeration service to locate the
                                    // assembly.
                                    AssemblyEnumerationService enumSvc = new AssemblyEnumerationService(this);
                                    foreach (AssemblyName an in enumSvc.GetAssemblyNames(assemblyName))
                                    {
                                        assemblyName = an.FullName;
                                        break;
                                    }
                                }

                                Assembly a = Assembly.Load(assemblyName);
                                Debug.Assert(a != null, "Assembly " + assemblyName + " not found on machine");

                                if (a != null)
                                {
                                    Type t = a.GetType(typeName);
                                    Debug.Assert(t != null, "Type " + typeName + " not found on machine");
                                    if (t != null)
                                    {
                                        ToolboxItem item = ToolboxService.GetToolboxItem(t);
                                        Debug.Assert(item != null, "Tool " + line + " does not offer a toolbox item");
                                        if (item != null)
                                        {

                                            if (currentCategory == null)
                                            {
                                                tbx.AddToolboxItem(item);
                                            }
                                            else
                                            {
                                                tbx.AddToolboxItem(item, currentCategory);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    Debug.Fail("Exception during toolbox processing: " + ex.ToString());
                }

                line = resourceData.ReadLine();
            }
        }


        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.RegisterEditorFactory"]/*' />
        /// <devdoc>
        /// Registers this editor factory with Visual Studio.
        /// If you are providing an editor factory, you should register
        /// it by overriding the Initialize method. Call 
        /// base.Initialize first, and then call RegisterEditorFactory
        /// for each editor factory.  There is no need to unregister
        /// an editor factory as Package will handle this for you.
        /// Also, if your editor factory is IDisposable, it will be
        /// disposed when it is unregistered.
        /// </devdoc>
        protected void RegisterEditorFactory(IVsEditorFactory factory) {
            IVsRegisterEditors registerEditors = GetService(typeof(SVsRegisterEditors)) as IVsRegisterEditors;
            if (registerEditors == null) {
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Package_MissingService, typeof(SVsRegisterEditors).FullName));
            }

            uint cookie;
            Guid riid = factory.GetType().GUID;

            NativeMethods.ThrowOnFailure( registerEditors.RegisterEditor(ref riid, factory, out cookie) );

            if (_editorFactories == null) {
                _editorFactories = new Hashtable();
            }

            _editorFactories[factory] = cookie;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.RegisterEditorFactory"]/*' />
        /// <devdoc>
        /// Registers this project factory with Visual Studio.
        /// If you are providing an project factory, you should register
        /// it by overriding the Initialize method. Call 
        /// base.Initialize first, and then call RegisterProjectFactory
        /// for each project factory.  There is no need to unregister
        /// an project factory as the Package base class will handle this for you.
        /// Also, if your project factory is IDisposable, it will be
        /// disposed when it is unregistered.
        /// </devdoc>
        protected void RegisterProjectFactory(IVsProjectFactory factory) {
            IVsRegisterProjectTypes registerProjects = GetService(typeof(SVsRegisterProjectTypes)) as IVsRegisterProjectTypes;
            if (registerProjects == null) {
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Package_MissingService, typeof(SVsRegisterProjectTypes).FullName));
            }

            uint cookie;
            Guid riid = factory.GetType().GUID;

            NativeMethods.ThrowOnFailure( registerProjects.RegisterProjectType(ref riid, factory, out cookie) );

            if (_projectFactories == null) {
                _projectFactories = new Hashtable();
            }

            _projectFactories[factory] = cookie;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ShowOptionPage"]/*' />
        /// <devdoc>
        /// Displays the Tools->Options dialog with the given
        /// options page selected.
        /// </devdoc>
        public void ShowOptionPage(Type optionsPageType) {

            if (optionsPageType == null) {
                throw new ArgumentNullException("optionsPageType");
            }

            System.ComponentModel.Design.MenuCommandService mcs = GetService(typeof(IMenuCommandService)) as System.ComponentModel.Design.MenuCommandService;
            if (mcs != null) {
                CommandID cmd = new CommandID(NativeMethods.GUID_VSStandardCommandSet97, NativeMethods.cmdidToolsOptions);
                mcs.GlobalInvoke(cmd, optionsPageType.GUID.ToString());
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IOleCommandTarget.Exec"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IOleCommandTarget implementation.
        /// </devdoc>
        int IOleCommandTarget.Exec(ref Guid guidGroup, uint nCmdId, uint nCmdExcept, IntPtr pIn, IntPtr vOut) {
            IOleCommandTarget tgt = (IOleCommandTarget)GetService(typeof(IOleCommandTarget));
            if (tgt != null) {
                return tgt.Exec(ref guidGroup, nCmdId, nCmdExcept, pIn, vOut);
            }
            else {
                return NativeMethods.OLECMDERR_E_NOTSUPPORTED;
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IOleCommandTarget.QueryStatus"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IOleCommandTarget implementation.
        /// </devdoc>
        int IOleCommandTarget.QueryStatus(ref Guid guidGroup, uint nCmdId, OLECMD[] oleCmd, IntPtr oleText) {
            IOleCommandTarget tgt = (IOleCommandTarget)GetService(typeof(IOleCommandTarget));
            if (tgt != null) {
                return tgt.QueryStatus(ref guidGroup, nCmdId, oleCmd, oleText);
            }
            return(NativeMethods.OLECMDERR_E_NOTSUPPORTED);
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IOleServiceProvider.QueryService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IOleServiceProvider implementation.
        /// </devdoc>
        int IOleServiceProvider.QueryService(ref Guid sid, ref Guid iid, out IntPtr ppvObj) {
            
            ppvObj = (IntPtr)0;
            int hr = NativeMethods.S_OK;

            object service = null;

            if (_services != null && _services.Count > 0) {
                foreach(Type serviceType in _services.Keys) {
                    if (serviceType.GUID.Equals(sid)) {
                        service = GetService(serviceType);
                        break;
                    }
                }
            }

            if (service == null) {
                hr = NativeMethods.E_NOINTERFACE;
            }
            else {
                // Now check to see if the user asked for an IID other than
                // IUnknown.  If so, we must do another QI.
                //
                if (iid.Equals(NativeMethods.IID_IUnknown)) {
                    ppvObj = Marshal.GetIUnknownForObject(service);
                }
                else {
                    IntPtr pUnk = Marshal.GetIUnknownForObject(service);
                    hr = Marshal.QueryInterface(pUnk, ref iid, out ppvObj);
                    Marshal.Release(pUnk);
                }
            }

            return hr;
        }
    
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.AddService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, object serviceInstance) {
            ((IServiceContainer)this).AddService(serviceType, serviceInstance, false);
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.AddService1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, object serviceInstance, bool promote) {

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            if (serviceInstance == null) {
                throw new ArgumentNullException("serviceInstance");
            }

            // Disallow the addition of duplicate services.
            //
            if (_services.ContainsKey(serviceType)) {
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Package_DuplicateService, serviceType.FullName));
            }

            if (promote) {

                // If we're promoting, we need to store this guy in a promoted service
                // object because we need to manage additional state.  We attempt
                // to proffer at this time if we have a service provider.  If we don't,
                // we will proffer when we get one.
                //
                ProfferedService service = new ProfferedService();
                service.Instance = serviceInstance;
                
                if (_provider != null) {
                    IProfferService ps = (IProfferService)GetService(typeof(SProfferService));
                    if (ps != null) {
                        uint cookie;
                        Guid serviceGuid = (Guid)serviceType.GUID;
                        NativeMethods.ThrowOnFailure( ps.ProfferService(ref serviceGuid, this, out cookie) );
                        service.Cookie= cookie;
                        _services[serviceType] = service;
                    }
                }
            }
            else {
                _services[serviceType] = serviceInstance;
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.AddService2"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, ServiceCreatorCallback callback) {
            ((IServiceContainer)this).AddService(serviceType, callback, false);
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.AddService3"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, ServiceCreatorCallback callback, bool promote) {

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            if (callback == null) {
                throw new ArgumentNullException("callback");
            }

            // Disallow the addition of duplicate services.
            //
            if (_services.ContainsKey(serviceType)) {
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Package_DuplicateService, serviceType.FullName));
            }

            if (promote) {

                // If we're promoting, we need to store this guy in a promoted service
                // object because we need to manage additional state.  We attempt
                // to proffer at this time if we have a service provider.  If we don't,
                // we will proffer when we get one.
                //
                ProfferedService service = new ProfferedService();
                _services[serviceType] = service;
                service.Instance = callback;
                
                if (_provider != null) {
                    IProfferService ps = (IProfferService)GetService(typeof(SProfferService));
                    if (ps != null) {
                        uint cookie;
                        Guid serviceGuid = (Guid)serviceType.GUID;
                        NativeMethods.ThrowOnFailure( ps.ProfferService(ref serviceGuid, this, out cookie) );
                        service.Cookie= cookie;
                    }
                }
            }
            else {
                _services[serviceType] = callback;
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.RemoveService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Removes the given service type from the service container.
        /// </devdoc>
        void IServiceContainer.RemoveService(Type serviceType) {
            ((IServiceContainer)this).RemoveService(serviceType, false);
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.RemoveService1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Removes the given service type from the service container.
        /// </devdoc>
        void IServiceContainer.RemoveService(Type serviceType, bool promote) {
            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            if (_services != null && _services.Count > 0) {
                object value = null;
                if (_services.ContainsKey(serviceType))
                    value = _services[serviceType];

                if (value != null) {
                    _services.Remove(serviceType);

                    try {
                        ProfferedService service = value as ProfferedService;
                        if (null != service) {
                            value = service.Instance;
                            if (service.Cookie != 0) {
                                IProfferService ps = (IProfferService)GetService(typeof(SProfferService));
                                if (ps != null) {
                                    NativeMethods.ThrowOnFailure(ps.RevokeService(service.Cookie));
                                }
                                service.Cookie = 0;
                            }
                        }
                    } 
                    finally {
                        if (value is IDisposable) {
                            ((IDisposable)value).Dispose();
                        }
                    }
                }
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceProvider.GetService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IServiceProvider implementation.  We just delegate to
        /// the Package implementation for this.
        /// </devdoc>
        object IServiceProvider.GetService(Type serviceType) {
            return GetService(serviceType);
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.Close"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.Close() {
            if (!zombie)
            {
                Dispose(true);
            }

            zombie = true;

            return NativeMethods.S_OK;
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.CreateTool"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// graysonm : temporarily remove explicit implementation syntax in order to allow hiding of this method
        /// in a derived class until tool window support is implemented.
        /// </devdoc>
        public int CreateTool(ref Guid persistenceSlot)
        {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            // Let the factory do the work
            int hr = ((IVsToolWindowFactory)this).CreateToolWindow(ref persistenceSlot, 0);
            return hr;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsToolWindowFactory.CreateToolWindow"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Create a tool window of the specified type with the specified ID.
        /// </devdoc>
        /// <param name="toolWindowType">Type of the window to be created</param>
        /// <param name="id">Instance ID</param>
        int IVsToolWindowFactory.CreateToolWindow(ref Guid toolWindowType, uint id)
        {
            if (id > int.MaxValue)
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentUICulture, "Instance ID cannot be more then {0}", int.MaxValue));
            int instanceID = (int)id;

            // Find the Type for this GUID
            Attribute[] attributes = Attribute.GetCustomAttributes(this.GetType());
            foreach (Attribute attribute in attributes)
            {
                if (attribute is ProvideToolWindowAttribute)
                {
                    ProvideToolWindowAttribute tool = (ProvideToolWindowAttribute)attribute;
                    if (tool.ToolType.GUID == toolWindowType)
                    {
                        // We found the corresponding type
                        // If a window get created this way, FindToolWindow should be used to get a reference to it
                        FindToolWindow(tool.ToolType, instanceID, true, tool);
                        break;
                    }
                }
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.CreateToolWindow"]/*' />
        /// <devdoc>
        /// Create a tool window of the specified type with the specified ID.
        /// </devdoc>
        /// <param name="toolWindowType">Type of the window to be created</param>
        /// <param name="id">Instance ID</param>
        /// <returns>An instance of a class derived from ToolWindowPane</returns>
        protected WindowPane CreateToolWindow(Type toolWindowType, int id)
        {
            if (toolWindowType == null)
                throw new ArgumentNullException("toolWindowType");
            if (id < 0)
                throw new ArgumentOutOfRangeException(string.Format(Resources.Culture, Resources.Package_InvalidInstanceID, id));
            if (!toolWindowType.IsSubclassOf(typeof(WindowPane)))
                throw new ArgumentException(Resources.Package_InvalidToolWindowClass);

            // Look in the Attributes of this package and see if this package
            // support this type of ToolWindow
            Attribute[] attributes = Attribute.GetCustomAttributes(this.GetType());
            foreach (Attribute attribute in attributes)
            {
                if (attribute is ProvideToolWindowAttribute)
                {
                    ProvideToolWindowAttribute tool = (ProvideToolWindowAttribute)attribute;
                    if (tool.ToolType == toolWindowType)
                    {
                        // We found the corresponding attribute on the package,
                        // so create the toolwindow
                        return CreateToolWindow(toolWindowType, id, tool);
                    }
                }
            }

            return null;
        }

        /// <devdoc>
        /// This is the only method that should be calling IVsUiShell.CreateToolWindow()
        /// </devdoc>
        private WindowPane CreateToolWindow(Type toolWindowType, int id, ProvideToolWindowAttribute tool)
        {
            if (toolWindowType == null)
                throw new ArgumentNullException("toolWindowType");
            if (id < 0)
                throw new ArgumentOutOfRangeException(string.Format(Resources.Culture, Resources.Package_InvalidInstanceID, id));
            if (!toolWindowType.IsSubclassOf(typeof(WindowPane)))
                throw new ArgumentException(Resources.Package_InvalidToolWindowClass);
            if (tool == null)
                throw new ArgumentNullException("tool");

            // First create an instance of the ToolWindowPane
            WindowPane window = (WindowPane)Activator.CreateInstance(toolWindowType);
            ToolWindowPane toolwindow = window as ToolWindowPane;

            // Check if this window has a ToolBar
            bool hasToolBar = false;

            Guid emptyGuid = Guid.Empty;
            Guid toolClsid = Guid.Empty;
            string caption = null;

            if (toolwindow != null)
            {
                toolClsid = toolwindow.ToolClsid;
                caption = toolwindow.Caption;
                hasToolBar = (toolwindow.ToolBar != null);
                toolwindow.Package = this;
            }

            uint flags = (uint)__VSCREATETOOLWIN.CTW_fInitNew;
            if (!tool.Transient)
                flags |= (uint)__VSCREATETOOLWIN.CTW_fForceCreate;
            if (hasToolBar)
                flags |= (uint)__VSCREATETOOLWIN.CTW_fToolbarHost;
            if (tool.MultiInstances)
                flags |= (uint)__VSCREATETOOLWIN.CTW_fMultiInstance;
            
            object windowPane = null;
            if (toolClsid.CompareTo(Guid.Empty) == 0)
            {
                // If a tool CLSID is not specified, then host the IVsWindowPane
                if (toolwindow != null)
                    // This method makes it possible to provide an IVsWindowPane not derived from ToolWindowPane
                    windowPane = toolwindow.GetIVsWindowPane();
                else
                    windowPane = window;
            }

            Guid persistenceGuid = toolWindowType.GUID;
            IVsWindowFrame windowFrame;
            // Use IVsUIShell to create frame.
            IVsUIShell vsUiShell = (IVsUIShell)GetService(typeof(SVsUIShell));
            if (vsUiShell == null)
                throw new Exception(string.Format(Resources.Culture, Resources.General_MissingService, typeof(SVsUIShell).FullName));

            int hr = vsUiShell.CreateToolWindow(flags,         // flags
                (uint)id,               // instance ID
                windowPane,             // IVsWindowPane to host in the toolwindow (null if toolClsid is specified)
                ref toolClsid,          // toolClsid to host in the toolwindow (Guid.Empty if windowPane is not null)
                ref persistenceGuid,    // persistence Guid
                ref emptyGuid,          // auto activate Guid
                null,                   // service provider
                caption,         // Window title
                null,
                out windowFrame);
            NativeMethods.ThrowOnFailure(hr);

            // If the toolwindow is a component, site it.
            IComponent component = null;
            // Check first if the content is a component, preferring IVsUIElementPane over IVsWindowPane-style pane
            if (window.Content != null)
            {
                component = window.Content as IComponent;
            }
            else
            {
                component = window.Window as IComponent;
            }
            // If we don't have a component yet, see if the toolwindow itself is a component
            if (component == null)
            {
                component = windowPane as IComponent;
            }
            if (component != null)
            {
                if (_componentToolWindows == null)
                    _componentToolWindows = new PackageContainer(this);
                _componentToolWindows.Add((IComponent)component);
            }

            // This generates the OnToolWindowCreated event on the ToolWindowPane
            if (toolwindow != null)
                toolwindow.Frame = windowFrame;

            if (hasToolBar && windowFrame != null && toolwindow != null)
            {
                // Set the toolbar
                IVsToolWindowToolbarHost2 toolBarHost;
                object obj;
                NativeMethods.ThrowOnFailure(windowFrame.GetProperty((int)__VSFPROPID.VSFPROPID_ToolbarHost, out obj));
                toolBarHost = (IVsToolWindowToolbarHost2)obj;
                if (toolBarHost != null)
                {
                    Guid toolBarCommandSet = toolwindow.ToolBar.Guid;
                    NativeMethods.ThrowOnFailure(toolBarHost.AddToolbar2((VSTWT_LOCATION)toolwindow.ToolBarLocation, ref toolBarCommandSet, (uint)toolwindow.ToolBar.ID, toolwindow.ToolBarDropTarget));
                }

                toolwindow.OnToolBarAdded();
            }


            // If the ToolWindow was created successfully, keep track of it
            if (toolwindow != null)
            {
                if (_toolWindows == null)
                    _toolWindows = new ToolWindowCollection();
                _toolWindows.Add(toolWindowType.GUID, id, toolwindow);
            }
            return window;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.0lWindow"]/*' />
        /// <devdoc>
        /// Return the tool window corresponding to the specified type and ID.
        /// If it does not exist, it returns creates one if create is true,
        /// or null if create is false.
        /// </devdoc>
        /// <param name="toolWindowType">Type of the window to be created</param>
        /// <param name="id">Instance ID</param>
        /// <param name="create">Create if none exist?</param>
        /// <returns>An instance of a class derived from ToolWindowPane</returns>
        public ToolWindowPane FindToolWindow(Type toolWindowType, int id, bool create)
        {
            return FindToolWindow(toolWindowType, id, create, null) as ToolWindowPane;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.0lWindow"]/*' />
        /// <devdoc>
        /// Return the window pane corresponding to the specified type and ID.
        /// If it does not exist, it returns creates one if create is true,
        /// or null if create is false.
        /// </devdoc>
        /// <param name="toolWindowType">Type of the window to be created</param>
        /// <param name="id">Instance ID</param>
        /// <param name="create">Create if none exist?</param>
        /// <returns>An instance of a class derived from WindowPane</returns>
        public WindowPane FindWindowPane(Type toolWindowType, int id, bool create)
        {
            return FindToolWindow(toolWindowType, id, create, null);
        }

        private WindowPane FindToolWindow(Type toolWindowType, int id, bool create, ProvideToolWindowAttribute tool)
        {
            if (toolWindowType == null)
                throw new ArgumentNullException("toolWindowType");

            WindowPane window = null;

            if (null != _toolWindows)
            {
                window = _toolWindows.GetToolWindowPane(toolWindowType.GUID, id);
            }

            if ((null == window) && create)
            {
                if (tool != null)
                    window = CreateToolWindow(toolWindowType, id, tool);
                else
                    window = CreateToolWindow(toolWindowType, id);
            }

            return window;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.GetAutomationObject"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.GetAutomationObject(string propName, out object auto) {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            auto = GetAutomationObject(propName);
            if (auto == null) {
                Marshal.ThrowExceptionForHR(NativeMethods.E_NOTIMPL);
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.GetPropertyPage"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.GetPropertyPage(ref Guid rguidPage, VSPROPSHEETPAGE[] ppage) {
            if (ppage == null || ppage.Length < 1)
                throw new ArgumentException(string.Format(Resources.Culture, Resources.General_ArraySizeShouldBeAtLeast1), "ppage");

            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            IWin32Window pageWindow = null;

            // First, check out the active pages.
            //
            if (_pagesAndProfiles != null) {
                foreach(object page in _pagesAndProfiles.Components) {
                    if (page.GetType().GUID.Equals(rguidPage)) {

                        // Found a match.
                        //
                        IWin32Window w = page as IWin32Window;
                        if (w != null) {
                            if (w is DialogPage) {
                                ((DialogPage)w).ResetContainer();
                            }
                            pageWindow = w;
                            break;
                        }
                    }
                }
            }

            if (pageWindow == null) {

                DialogPage page = null;

                // Didn't find it in our cache.  Now look in the metadata attributes
                // for the class.  Look at all types at the same time.
                //
                AttributeCollection attributes = TypeDescriptor.GetAttributes(this);
                foreach(Attribute attr in attributes) {
                    if (attr is ProvideOptionDialogPageAttribute) {
                        Type pageType = ((ProvideOptionDialogPageAttribute)attr).PageType;
                        if (pageType.GUID.Equals(rguidPage)) {

                            // Found a matching attribute.  Now go get the DialogPage with GetDialogPage.
                            // This has a side-effect of storing the page in
                            // _pagesAndProfiles for us.
                            //
                            page = GetDialogPage(pageType);
                            pageWindow = page;
                            break;
                        }
                    }

                    if (page != null)
                    {
                        if (_pagesAndProfiles == null)       
                        {
                            _pagesAndProfiles = new PackageContainer(this);
                        }
                        _pagesAndProfiles.Add(page);

                        // No need to continue looking in the attributes, 
                        // we've already found the one we're looking for
                        break;
                    }
                }
            }

            // We should now have a page window. If we don't then the requested page
            // doesn't exist.
            //
            if (pageWindow == null) {
                Marshal.ThrowExceptionForHR(NativeMethods.E_NOTIMPL);
            }

            ppage[0].dwSize = (uint)Marshal.SizeOf(typeof(VSPROPSHEETPAGE));
            ppage[0].hwndDlg = pageWindow.Handle;
            // zero-out all the fields we aren't using.
            ppage[0].dwFlags = 0;
            ppage[0].HINSTANCE = 0;
            ppage[0].dwTemplateSize = 0;
            ppage[0].pTemplate = IntPtr.Zero;
            ppage[0].pfnDlgProc = IntPtr.Zero;
            ppage[0].lParam = IntPtr.Zero;
            ppage[0].pfnCallback = IntPtr.Zero;
            ppage[0].pcRefParent = IntPtr.Zero;
            ppage[0].dwReserved = 0;
            ppage[0].wTemplateId = (ushort)0;

            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.QueryClose"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.QueryClose(out int close)
        {
            // Default to true as we don't want an error to prevent the shell from closing
            close = 1;
            bool canClose = true;
            int hr = this.QueryClose(out canClose);
            if (!canClose)
                close = 0;
            return hr;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.ResetDefaults"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.ResetDefaults(uint grfFlags) {

            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (grfFlags == (uint)__VSPKGRESETFLAGS.PKGRF_TOOLBOXITEMS) {
                if (ToolboxInitialized != null) {
                    ToolboxInitialized(this, EventArgs.Empty);
                }
            }
            else if (grfFlags == (uint)__VSPKGRESETFLAGS.PKGRF_TOOLBOXSETUP) {
                if (ToolboxUpgraded != null) {
                    ToolboxUpgraded(this, EventArgs.Empty);
                }
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.SetSite"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.SetSite(IOleServiceProvider sp) {

            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (sp != null) {
                if (_provider != null) {
                    throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Package_SiteAlreadySet, GetType().FullName));
                }
                _provider = ServiceProvider.CreateFromSetSite(sp);

                Initialize();
            }
            else if (_provider != null)
            {
                // No SP, dispose us.
                //
                Dispose(true);
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPersistSolutionOpts.LoadUserOptions"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPersistSolutionOpts implementation.
        /// Called when a solution is opened, and allows us to inspect our options.
        /// </devdoc>
        int IVsPersistSolutionOpts.LoadUserOptions(IVsSolutionPersistence pPersistance, uint options) {

            int hr = NativeMethods.S_OK;
            if ((options & (uint)__VSLOADUSEROPTS.LUO_OPENEDDSW) != 0) {
                return hr;
            }

            if (_optionKeys != null) {
                foreach(string key in _optionKeys) {
                    hr = pPersistance.LoadPackageUserOpts(this, key);
                    if (NativeMethods.Failed(hr))
                        break;
                }
            }

            NativeMethods.ThrowOnFailure(hr);
            return hr;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPersistSolutionOpts.ReadUserOptions"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPersistSolutionOpts implementation.
        /// Called by the shell to load our solution options.
        /// </devdoc>
        int IVsPersistSolutionOpts.ReadUserOptions(IStream pStream, string pszKey) {

            NativeMethods.DataStreamFromComStream stream = new NativeMethods.DataStreamFromComStream(pStream);
            using (stream) {
                OnLoadOptions(pszKey, stream);
            }

            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPersistSolutionOpts.SaveUserOptions"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPersistSolutionOpts implementation.
        /// Called by the shell when we are to persist our service options
        /// </devdoc>
        int IVsPersistSolutionOpts.SaveUserOptions(IVsSolutionPersistence pPersistance) {

            if (_optionKeys != null) {
                foreach(string key in _optionKeys) {
                    NativeMethods.ThrowOnFailure( pPersistance.SavePackageUserOpts(this, key) );
                }
            }

            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPersistSolutionOpts.WriteUserOptions"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPersistSolutionOpts implementation.
        /// Called by the shell to persist our solution options.  Here is where the service
        /// can persist any goo that it cares about.
        /// </devdoc>
        int IVsPersistSolutionOpts.WriteUserOptions(IStream pStream, string pszKey) {

            NativeMethods.DataStreamFromComStream stream = new NativeMethods.DataStreamFromComStream(pStream);
            using (stream) {
                OnSaveOptions(pszKey, stream);
            }

            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsToolboxItemProvider.GetItemContent"]/*' />
        /// <devdoc>
        /// IVsToolboxItemProvider implementation.
        /// Called by the shell to retrieve the content of a data format in a toolbox item that
        /// was statically registered.  See comments in vsshell100.idl for details.
        /// </devdoc>
        int IVsToolboxItemProvider.GetItemContent(string itemId, /* CLIPFORMAT */ ushort format, out /* HGLOBAL */ IntPtr global) {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            object data = GetToolboxItemData(itemId, DataFormats.GetFormat(format));

            if (data == null) {
                global = IntPtr.Zero;
            }
            else {
                // OleDataObject has a nice facility for serializing objects into hglobals, so
                // let's take advantage of it.
                var dataObj = new OleDataObject();
                dataObj.SetData(DataFormats.GetFormat(format).Name, data);

                FORMATETC[] fetc = new FORMATETC[] { new FORMATETC() };
                fetc[0].cfFormat = format;
                fetc[0].dwAspect = (uint)DVASPECT.DVASPECT_CONTENT;
                fetc[0].lindex = -1;
                fetc[0].tymed = (uint)TYMED.TYMED_HGLOBAL;

                STGMEDIUM[] stm = new STGMEDIUM[] { new STGMEDIUM() };
                stm[0].tymed = (uint)TYMED.TYMED_HGLOBAL;

                ((Microsoft.VisualStudio.OLE.Interop.IDataObject)dataObj).GetData(fetc, stm);
                global = stm[0].unionmember;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetToolboxItemData"]' />
        /// <devdoc>
        /// Given a toolbox item "unique ID" and a data format identifier, returns the content of
        /// the data format.  If this is not implemented, the shell will fall back to a call to
        /// IVsPackage.ResetDefaults (which invokes the ToolboxInitialized or ToolboxUpgraded
        /// event).
        /// </devdoc>
        protected virtual object GetToolboxItemData(string itemId, DataFormats.Format format) {
            if (string.IsNullOrEmpty(itemId)) {
                throw new ArgumentNullException("itemId");
            }

            // Try cache first
            System.Windows.Forms.IDataObject tbxDataObj;
            if (_tbxItemDataCache.TryGetValue(itemId, out tbxDataObj)) {
                if (tbxDataObj.GetDataPresent(format.Name)) {
                    return tbxDataObj.GetData(format.Name);
                }
                else {
                    throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Toolbox_UnsupportedFormat, format.Name));
                }
            }

            string typeName;
            string assemblyName;
            int idx = itemId.IndexOf(",");
            if (idx == -1) {
                Debug.Fail("Invalid toolbox item ID: " + itemId);
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Toolbox_InvalidItemId, itemId));
            }
            else {
                typeName = itemId.Substring(0, idx).Trim();
                assemblyName = itemId.Substring(idx + 1).Trim();
            }

            if (assemblyName.IndexOf(",") == -1) {
                // Must use the assembly enumeration service to locate the assembly.
                Microsoft.VisualStudio.AssemblyEnumerationService enumSvc = 
                    new Microsoft.VisualStudio.AssemblyEnumerationService(this);
                foreach (AssemblyName an in enumSvc.GetAssemblyNames(assemblyName)) {
                    assemblyName = an.FullName;
                    break;
                }
            }

            Assembly a = Assembly.Load(assemblyName);
            Debug.Assert(a != null, "Assembly " + assemblyName + " not found on machine");

            if (a != null) {
                Type t = a.GetType(typeName);
                Debug.Assert(t != null, "Type " + itemId + " not found on machine");
                if (t != null) {
                    ToolboxItem item = ToolboxService.GetToolboxItem(t);
                    Debug.Assert(item != null, "Tool " + assemblyName + ":" + itemId + " does not offer a toolbox item");
                    if (item != null) {
                        ToolboxItemContainer container = new ToolboxItemContainer(item);
                        tbxDataObj = container.ToolboxData;
                        // Missed in cache, so save it in cache now
                        _tbxItemDataCache.Add(itemId, tbxDataObj);

                        if (tbxDataObj.GetDataPresent(format.Name)) {
                            return tbxDataObj.GetData(format.Name);
                        }
                        else {
                            throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Toolbox_UnsupportedFormat, format.Name));
                        }
                    }
                }
            }

            throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Toolbox_ItemNotFound, itemId));
        }

        /// <devdoc>
        ///     This class derives from container to provide a service provider
        ///     connection to the package.
        /// </devdoc>
        private sealed class PackageContainer : Container {
            private IUIService _uis;
            private AmbientProperties _ambientProperties;

            private IServiceProvider _provider;

            /// <devdoc>
            ///     Creates a new container using the given service provider.
            /// </devdoc>
            internal PackageContainer(IServiceProvider provider) {
                _provider = provider;
            }

            /// <devdoc>
            ///     Override to GetService so we can route requests
            ///     to the package's service provider.
            /// </devdoc>
            protected override object GetService(Type serviceType) {
                if (serviceType == null) {
                    throw new ArgumentNullException("serviceType");
                }
                if (_provider != null) {
                    if (serviceType.IsEquivalentTo(typeof(AmbientProperties))) {
                        if (_uis == null) {
                            _uis = (IUIService)_provider.GetService(typeof(IUIService));
                        }
                        if (_ambientProperties == null) {
                            _ambientProperties = new AmbientProperties();
                        }
                        if (_uis != null) {
                            // update the _ambientProperties in case the styles have changed
                            // since last time.
                            _ambientProperties.Font = (Font)_uis.Styles["DialogFont"];
                        }
                        return _ambientProperties;
                    }
                    object service = _provider.GetService(serviceType);

                    if (service != null) {
                        return service;
                    }
                }
                return base.GetService(serviceType);
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetGlobalService"]' />
        /// <devdoc>
        /// Get a service proffered globally by VisualStudio or one of its package.
        /// This is equivalent to calling GetService() on an instance of a package 
        /// that proffer no service itself.
        /// </devdoc>
        /// <param name="serviceType">Type corresponding to the Service being requested</param>
        /// <returns>The service being requested if available, otherwise null</returns>
        static public object GetGlobalService(Type serviceType)
        {
            object service = null;

            ServiceProvider globalProvider = ServiceProvider.GlobalProvider;

            Debug.Assert(globalProvider != null, "The global service provider is unavailable. You may be calling from the wrong thread.");

            if (globalProvider != null)
            {
                service = globalProvider.GetService(serviceType);
            }
            return service;
        }

        /// <devdoc>
        ///     This class contains a service that is being promoted to vS.  
        /// </devdoc>
        private sealed class ProfferedService {
            public object Instance;
            public uint   Cookie;
        }

        /// <devdoc>
        /// Internal zombie flag indicates that VS is shutting us down.
        /// </devdoc>
        private bool zombie = false;

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.Zombied"]/*' />
        /// <devdoc>
        /// Zombie flag indicates that the package is being closed.
        /// </devdoc>
        public bool Zombied {
            get {
                return zombie;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideLanguageEditorOptionPageAttribute.cs ===
﻿//////////////////////////////////////////////////////////////////////////////
// RegisterLanguageServiceAttribute
//
// Provide a general method for setting a language service's editor tool
// option page.
//
// This information is stored in the registry key
// <RegistrationRoot>\Languages\Language Services\[language]\EditorToolsOptions
// where [language] is the name of the language.
//
// Under EditorToolsOptions is a tree of pages and sub-pages that can
// nest any number of levels.  These pages correspond to options pages
// displayed in the Visual Studio Tools Options for editors (where the
// language name is displayed under which is a tree of option pages, each
// page containing appropriate options).
//
// Each key in this option page list contains a resoure id or literal
// string containing the localized name of the page (this is what is
// actually shown in the Tools Options dialog).  In addition, it also
// contains a package GUID and optionally a GUID of an option page.
//
// If there is no option page GUID then the key is considered a node in the
// tree of options and has no associated page.  Otherwise, the key is
// a leaf in the tree and its option page will be shown.
//
// Example:
// root base key: HKLM\Software\Microsoft\VisualStudio\8.0
//   Languages\
//     Language Services\
//       CSharp\
//         EditorToolsOptions\
//           Formatting\ = sz:#242
//             General\ = sz:#255
//               Package = sz:{GUID}
//               Page = sz:{GUID}
//             Indentation\ = sz:#250
//               Package = sz:{GUID}
//               Page = sz:{GUID}
//
// Goal:
// LanguageEditorOptionPage("CSharp","Formatting","#242");
// LanguageEditorOptionPage("CSharp","Formatting\General","#255","{PAGE GUID}");
// LanguageEditorOptionPage("CSharp","Formatting\Indentation","#250","{PAGE GUID}");
//
//////////////////////////////////////////////////////////////////////////////

#region Using directives

using System;
using System.Diagnostics;
using System.Collections;
using System.Globalization;
using System.Runtime.InteropServices;
using System.ComponentModel.Design;
using Microsoft.Win32;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;
using MSVSIP = Microsoft.VisualStudio.Shell;

#endregion

namespace Microsoft.VisualStudio.Shell
{
    internal class LanguageToolsOptionCreator {
        // This class is used only to expose some static member, so we declare a private constructor
        // to avoid the creation of any instance of it.
        private LanguageToolsOptionCreator() { }

        private static string FormatRegKey(string languageName, string categoryName) {

            string strRegKey =
                string.Format(CultureInfo.InvariantCulture,
                              "{0}\\{1}\\{2}\\{3}",
                              RegistryPaths.languageServices,
                              languageName,
                              RegistryPaths.editorToolsOptions,
                              categoryName);
            return strRegKey;
        }

        internal static void CreateRegistryEntries(RegistrationAttribute.RegistrationContext context, string languageName, string categoryName, string categoryResourceId, Guid pageGuid)
        {

            using (RegistrationAttribute.Key serviceKey = context.CreateKey(FormatRegKey(languageName, categoryName))) {
                // Add specific entries corresponding to arguments to
                // constructor.
                serviceKey.SetValue(string.Empty, categoryResourceId);
                serviceKey.SetValue(RegistryPaths.package, context.ComponentType.GUID.ToString("B"));
                if (pageGuid != Guid.Empty) {
                    serviceKey.SetValue(RegistryPaths.page, pageGuid.ToString("B"));
                }
            }
        }

        internal static void RemoveRegistryEntries(RegistrationAttribute.RegistrationContext context, string languageName, string categoryName) {

            context.RemoveKey(FormatRegKey(languageName, categoryName));
        }
    }

    /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorToolsOptionCategoryAttribute"]' />
    /// <devdoc>
    /// This attribute is used to declare a ToolsOption category for a language.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideLanguageEditorToolsOptionCategoryAttribute : RegistrationAttribute {
        private string languageName;
        private string categoryName;
        private string categoryResourceId;

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorToolsOptionCategoryAttribute.ProvideLanguageEditorToolsOptionCategoryAttribute"]' />
        /// <devdoc>
        /// Creates a new ProvideLanguageEditorToolsOptionCategory attribute for a given language and category.
        /// </devdoc>
        /// <param name="languageName">The name of the language.</param>
        /// <param name="categoryName">The name of the category.</param>
        /// <param name="categoryResourceId">The id of the resource with the localized name for the category.</param>
        public ProvideLanguageEditorToolsOptionCategoryAttribute(string languageName, string categoryName, string categoryResourceId) {
            this.languageName = languageName;
            this.categoryName = categoryName;
            this.categoryResourceId = categoryResourceId;
        }

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorToolsOptionCategoryAttribute.Register"]' />
        public override void Register(RegistrationAttribute.RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLanguageOptionCategory, languageName, categoryName));

            // Create the registry entries using the creator object.
            LanguageToolsOptionCreator.CreateRegistryEntries(context, languageName, categoryName, categoryResourceId, Guid.Empty);
        }

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorToolsOptionCategoryAttribute.Unregister"]' />
        public override void Unregister(RegistrationAttribute.RegistrationContext context) {
            // Remove the entries using the creator object.
            LanguageToolsOptionCreator.RemoveRegistryEntries(context, languageName, categoryName);
        }
    }

    /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute"]' />
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideLanguageEditorOptionPageAttribute : ProvideOptionDialogPageAttribute
    {
        private string languageName;
        private string pageName;
        private string category;

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.ProvideLanguageEditorOptionPageAttribute"]' />
        /// <devdoc>
        /// Constructor for node with child option pages (to be added with
        /// additional ProvideLanguageEditorOptionPageAttribute).
        /// </devdoc>
        public ProvideLanguageEditorOptionPageAttribute(
            Type pageType,
            string languageName,
            string category,
            string pageName,
            string pageNameResourceId
            ) : base(pageType, pageNameResourceId)
        {
            this.languageName = languageName;
            this.pageName = pageName;
            this.category = category;
        }

        //////////////////////////////////////////////////////////////////////
        // Properties.

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.LanguageName"]' />
        public string LanguageName
        {
            get { return languageName; }
        }

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.PageGuid"]' />
        public Guid PageGuid
        {
            get { return PageType.GUID; }
        }

        private string FullPathToPage {
            get {
                if (string.IsNullOrEmpty(category))
                    return pageName;
                return string.Format("{0}\\{1}", category, pageName);
            }
        }
        //////////////////////////////////////////////////////////////////////
        // Public methods.

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.Register"]' />
        public override void Register(RegistrationAttribute.RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLanguageOptionPage, LanguageName, PageNameResourceId));

            // Create the registry entries using the creator object.
            LanguageToolsOptionCreator.CreateRegistryEntries(context, LanguageName, FullPathToPage, PageNameResourceId, PageGuid);
        }

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.Unregister"]' />
        public override void Unregister(RegistrationAttribute.RegistrationContext context)
        {
            // Remove the registry entries for this page.
            LanguageToolsOptionCreator.RemoveRegistryEntries(context, LanguageName, FullPathToPage);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideLoadKeyAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideLoadKeyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute"]' />
    /// <devdoc>
    ///     This attribute registers a package load key for your package.  
    ///     Package load keys are used by Visual Studio to validate that 
    ///     a package can be loaded.    
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited=false, AllowMultiple=false)]
    public sealed class ProvideLoadKeyAttribute : RegistrationAttribute {

        private string _minimumEdition;
        private string _productVersion;
        private string _productName;
        private string _companyName;
        private short  _resourceId;
    
        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.ProvideLoadKeyAttribute"]/*' />
        public ProvideLoadKeyAttribute (string minimumEdition, string productVersion, string productName, string companyName, short resourceId) {
            if (minimumEdition == null) {
                throw new ArgumentNullException("minimumEdition");
            }
            if (productVersion == null) {
                throw new ArgumentNullException("productVersion");
            }
            if (productName == null) {
                throw new ArgumentNullException("productName");
            }
            if (companyName == null) {
                throw new ArgumentNullException("companyName");
            }
            
            _minimumEdition = minimumEdition;
            _productVersion = productVersion;
            _productName = productName;
            _companyName = companyName;
            _resourceId = resourceId;
        }
        
        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.MinEdition"]' />
        /// <devdoc>
        ///     Minimum edition of Visual Studio on which
        ///     VSPackage is loaded. This must be the literal 
        ///     edition value provided by Microsoft when 
        ///     obtaining your PLK.
        /// </devdoc>
        public string MinimumEdition {
            get {
                return _minimumEdition;
            }
        }

        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.ProductVersion"]' />
        /// <devdoc>
        ///     Version of the product that this VSPackage
        ///     implements.
        /// </devdoc>
        public string ProductVersion {
            get {
                return _productVersion;
            }
        }
        
        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.ProductName"]' />
        /// <devdoc>
        ///     Name of the product that this VSPackage 
        ///     delivers. Note that one product might be
        ///     comprised of multiple VSPackages, in which 
        ///     case each will need its own PLK.
        /// </devdoc>
        public string ProductName {
            get {
                return _productName;
            }
        }

        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.CompanyName"]' />
        /// <devdoc>
        ///     VSIP Partner/creator of the VSPackage. 
        ///     The literal name (case-sensitive) provided 
        ///     to Microsoft when registering for a PLK.
        /// </devdoc>
        public string CompanyName {
            get {
                return _companyName;
            }
        }
        
        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.ResourceId"]' />
        /// <devdoc>
        ///     Resource ID for VSPackage load key.
        /// </devdoc>
        public short ResourceId {
            get {
                return _resourceId;
            }
        }

        /// <summary>
        /// Registry Key name for this package's load key information.
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        public string RegKeyName (RegistrationContext context)
        {
            return string.Format(CultureInfo.InvariantCulture, "Packages\\{0}", context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLoadKey, CompanyName, ProductName, ProductVersion, MinimumEdition));

            using (Key packageKey = context.CreateKey(RegKeyName(context)))
            {
                packageKey.SetValue("ID", ResourceId);
                packageKey.SetValue("MinEdition", MinimumEdition);
                packageKey.SetValue("ProductVersion", ProductVersion);
                packageKey.SetValue("ProductName", ProductName);
                packageKey.SetValue("CompanyName", CompanyName);
            }
        }

        /// <summary>
        /// Unregisters this package's load key information
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName(context));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideLanguageCodeExpansionAttribute.cs ===
﻿//////////////////////////////////////////////////////////////////////////////
// ProvideLanguageCodeExpansionAttribute
//
// This attribute class will ease the pain of registering a language
// service's support for code snippets written with the managed
// package framework.
//
// Usage:
// [ProvideLanguageCodeExpansionAttribute(<type> or "<GUID>",
//                                        <language name>,
//                                        <language name id>,
//                                        "<language identifier>",
//                                        "<Path to snippet index file>",
//   ShowRoots = true | false
//   SearchPaths = "<semi-colon-delimited path list to snippet index
//                  files>"
//   ForceCreateDirs = "<semi-colon-delimited list of dirs that the
//                  expansion manager will create>
// )]
//
//////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.Globalization;
using System.Runtime.InteropServices;
using System.ComponentModel.Design;
using Microsoft.Win32;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;

//namespace Vsip.TestPackage
namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute"]' />
    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideLanguageCodeExpansionAttribute : RegistrationAttribute
    {
        //////////////////////////////////////////////////////////////////////
        // ProvideLanguageServiceAttribute Private fields.
        //
        private Guid   languageServiceGuid;
        private string languageName;
        private string snippetIndexPath;
        private string searchPaths;
        private string forceCreateDirs;
        private string languageIdString;
        private string displayName;
        private bool   showRoots = false;


        //////////////////////////////////////////////////////////////////////
        // ProvideLanguageServiceAttribute Public Methods

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.ProvideLanguageCodeExpansionAttribute"]' />
        /// <devdoc>
        /// Registers a language service's support for code snippets.
        /// </devdoc>
        /// <param name="languageService">Language Service class. This can be a string with the value of the Guid or the Type of the language service.</param>
        /// <param name="languageName">Name of the language service.  Used in the registry so cannot be localized.</param>
        /// <param name="languageResourceId">Resource ID of the localized name of the language service.</param>
        /// <param name="languageIdentifier">String used to identify snippets and the snippets index file.</param>
        /// <param name="pathToSnippetIndexFile">Full path to a snippets index file.</param>
        public ProvideLanguageCodeExpansionAttribute(
            object languageService,
            string languageName,
            int languageResourceId,
            string languageIdentifier,
            string pathToSnippetIndexFile)
        {
            // Get the guid of the language service.
            if (languageService is Type)
            {
                this.languageServiceGuid = ((Type)languageService).GUID;
            }
            else if (languageService is string)
            {
                this.languageServiceGuid = new Guid((string)languageService);
            }
            else
                throw new ArgumentException();

            this.languageName     = languageName;
            this.snippetIndexPath = pathToSnippetIndexFile;
            this.displayName      = languageResourceId.ToString(CultureInfo.InvariantCulture);
            this.languageIdString = languageIdentifier;
        }

        // ProvideLanguageCodeExpansionAttribute Properties.

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.LanguageServiceSid"]' />
        public Guid LanguageServiceSid
        {
            get { return languageServiceGuid; }
        }

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.LanguageName"]' />
        public string LanguageName
        {
            get { return languageName; }
        }


        //////////////////////////////////////////////////////////////////////
        // The following properties are entries in the language key.  These
        // are all optional (however, if they are specified by the user, they
        // will be created in the registry, regardless if they have a value or
        // not).

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.ShowRoots"]' />
        public bool ShowRoots
        {
            get { return showRoots; }
            set { showRoots = value; }
        }

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.SearchPaths"]' />
        public string SearchPaths
        {
            get { return searchPaths; }
            set { searchPaths = value; }
        }

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.ForceCreateDirs"]' />
        public string ForceCreateDirs
        {
            get { return forceCreateDirs; }
            set { forceCreateDirs = value; }
        }
        //////////////////////////////////////////////////////////////////////
        // Helper property
        private string LanguageRegistryKey
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0}\\{1}",
                                     RegistryPaths.codeExpansion,
                                     LanguageName);
            }
        }

        
        //////////////////////////////////////////////////////////////////////
        // ProvideLanguageCodeExpansionAttribute Public Methods.

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.Register"]' />
        public override void Register(RegistrationAttribute.RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLanguageCodeExpansion, LanguageServiceSid.ToString("B")));

            string packageGuid = context.ComponentType.GUID.ToString("B");
            // Create our top-most language key
            using (Key serviceKey = context.CreateKey(LanguageRegistryKey))
            {
                // Add specific entries corresponding to arguments to
                // ProvideLanguageCodeExpansionAttribute constructor.
                serviceKey.SetValue(string.Empty, LanguageServiceSid.ToString("B"));
                serviceKey.SetValue(RegistryPaths.package, packageGuid);
                serviceKey.SetValue(RegistryPaths.displayName, displayName);
                serviceKey.SetValue(RegistryPaths.languageStringId, languageIdString);
                serviceKey.SetValue(RegistryPaths.indexPath, snippetIndexPath);
                serviceKey.SetValue(RegistryPaths.showRoots, showRoots ? 1 : 0);
                if (!string.IsNullOrEmpty(SearchPaths))
                {
                    using (Key pathsKey = serviceKey.CreateSubkey(RegistryPaths.paths))
                    {
                        pathsKey.SetValue(LanguageName, SearchPaths);
                    }
                }
                if (!string.IsNullOrEmpty(ForceCreateDirs))
                {
                    using (Key forceCreateKey = serviceKey.CreateSubkey(RegistryPaths.forceCreateDirs))
                    {
                        forceCreateKey.SetValue(LanguageName, ForceCreateDirs);
                    }
                }
            }
        }

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.Unregister"]' />
        public override void Unregister(RegistrationAttribute.RegistrationContext context)
        {
            context.RemoveKey(LanguageRegistryKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\providelanguageServiceAttribute.cs ===
﻿//////////////////////////////////////////////////////////////////////////////
// ProvideLanguageServiceAttribute
//
// This attribute class will ease the pain of registering a language service
// written in managed code.
//
// To add editor Tool Options Pages, use ProvideLanguageEditorOptionPageAttribute.
// To add code expansion support, use ProvideLanguageCodeExpansionAttribute.
//
// Usage:
// [ProvideLanguageServiceAttribute(<type>,<language name>,<language name id>,
//    DebuggerLanguageExpressionEvaluator = "{guid}"
//    ShowCompetion = true | false
//    ShowSmartIndent = true | false
//    RequestStockColors = true | false
//    ShowHotURLs = true | false
//    DefaultToNonHotURLs = true | false
//    DefaultToInsertSpaces = true | false
//    ShowDropDownOptions = true | false
//    SingleCodeWindowOnly = true | false
//    EnableAdvancedMembersOption = true | false
//    SupportCopyPasteOfHTML = true | false
//    EnableLineNumbers = true | false
//    HideAdvancedMembersByDefault = true | false
//    CodeSense = true | false
//    MatchBraces = true | false
//    QuickInfo = true | false
//    ShowMatchingBrace = true | false
//    MatchBracesAtCaret = true | false
//    MaxErrorMessages = <number>
//    CodeSenseDelay = <number>
//    EnableAsyncCompletion = true | false
//    EnableCommenting = true | false
//    EnableFormatSelection = true | false
//    AutoOutlining = true | false
// )]
//
// Notes:
// * All named options are optional.
// 
//
// <type>             is the type of the class implementing the language
//                    service.  The language GUID is obtained from this.
// <language name>    Name of the language to be used as a registry key name.
// <language name id> resource id of localized language name which Visual
//                    Studio will show to the user.
//
// LocalizedName      literal text or #ddd (resource id of localized name)
//                    This name is used for the string put into the tree list
//                    of options in Visual Studio's Tools Options dialog.
//                    This value appears as the default value for the
//                    GroupName and ItemName registry keys.  If not specified,
//                    the GroupName or ItemName is substituted.
// GroupName          Registry key name.  This acts as a node in the tree list
//                    of options.
// ItemName           Registry key name which has a registry entry that
//                    specifies the guid of an option page to show.
//
// Note: All GroupName and ItemName keys contain an additional registry entry
//       for the package guid (which is derived internally and does not have
//       to be specified in the attribute).
//////////////////////////////////////////////////////////////////////////////

#region Using directives

using System;
using System.Diagnostics;
using System.Collections;
using System.Globalization;
using System.Runtime.InteropServices;
using System.ComponentModel.Design;
using Microsoft.Win32;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;

#endregion

namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute"]' />
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideLanguageServiceAttribute : RegistrationAttribute
    {
        // ProvideLanguageServiceAttribute Private fields.
        //
        private Guid                languageServiceGuid;
        private string              strLanguageName;
        private int                 languageResourceID;
        private Hashtable           optionsTable;
        private DebuggerLanguages   debuggerLanguages;


        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ProvideLanguageServiceAttribute"]' />
        /// <devdoc>
        /// Registers a language service.
        /// </devdoc>
        /// <param name="languageService"></param>
        /// <param name="strLanguageName"></param>
        /// <param name="languageResourceID"></param>
        public ProvideLanguageServiceAttribute(
            object languageService,
            string strLanguageName,
            int languageResourceID)
        {
            if (languageService is Type)
                this.languageServiceGuid = ((Type)languageService).GUID;
            else if (languageService is string)
                this.languageServiceGuid = new Guid((string)languageService);
            else
                throw new ArgumentException();
            this.strLanguageName     = strLanguageName;
            this.languageResourceID  = languageResourceID;

            debuggerLanguages   = new DebuggerLanguages(strLanguageName);
            optionsTable = new Hashtable();
        }

        // ProvideLanguageServiceAttribute Properties.

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.LanguageServiceSid"]' />
        public Guid LanguageServiceSid
        {
            get { return languageServiceGuid; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.LanguageName"]' />
        public string LanguageName
        {
            get { return strLanguageName; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.LanguageResourceID"]' />
        public int LanguageResourceID
        {
            get { return languageResourceID; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.DebuggerLanguageExpressionEvaluator"]' />
        /// <devdoc>
        /// Establish an expression evaluator for debugging languages.
        /// </devdoc>
        public string DebuggerLanguageExpressionEvaluator
        {
            get { return debuggerLanguages.ExpressionEvaluator.ToString("B"); }
            set { debuggerLanguages.ExpressionEvaluator = new Guid(value); }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowCompletion"]' />
        public bool ShowCompletion
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showCompletion];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showCompletion] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowSmartIndent"]' />
        public bool ShowSmartIndent
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showIndentOptions];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showIndentOptions] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.RequestStockColors"]' />
        public bool RequestStockColors
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.useStockColors];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.useStockColors] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowHotURLs"]' />
        public bool ShowHotURLs
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showHotURLs];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showHotURLs] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.DefaultToNonHotURLs"]' />
        public bool DefaultToNonHotURLs
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.nonHotURLs];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.nonHotURLs] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.DefaultToInsertSpaces"]' />
        public bool DefaultToInsertSpaces
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.insertSpaces];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.insertSpaces] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowDropDownOptions"]' />
        public bool ShowDropDownOptions
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showDropDownBar];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showDropDownBar] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.SingleCodeWindowOnly"]' />
        public bool SingleCodeWindowOnly
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.disableWindowNewWindow];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.disableWindowNewWindow] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableAdvancedMembersOption"]' />
        public bool EnableAdvancedMembersOption
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableAdvMembersOption];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableAdvMembersOption] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.SupportCopyPasteOfHTML"]' />
        public bool SupportCopyPasteOfHTML
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.supportCF_HTML];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.supportCF_HTML] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableLineNumbers"]' />
        public bool EnableLineNumbers
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableLineNumbersOption];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableLineNumbersOption] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.HideAdvancedMembersByDefault"]' />
        public bool HideAdvancedMembersByDefault
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.hideAdvancedMembersByDefault];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.hideAdvancedMembersByDefault] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.CodeSense"]' />
        public bool CodeSense
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.codeSense];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.codeSense] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.MatchBraces"]' />
        public bool MatchBraces
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.matchBraces];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.matchBraces] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.QuickInfo"]' />
        public bool QuickInfo
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.quickInfo];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.quickInfo] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowMatchingBrace"]' />
        public bool ShowMatchingBrace
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showMatchingBrace];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showMatchingBrace] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.MatchBracesAtCaret"]' />
        public bool MatchBracesAtCaret
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.matchBracesAtCaret];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.matchBracesAtCaret] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.MaxErrorMessages"]' />
        public int MaxErrorMessages
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.maxErrorMessages];
                return (null == val) ? 0 : (int)val;
            }
            set { optionsTable[LanguageOptionKeys.maxErrorMessages] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.CodeSenseDelay"]' />
        public int CodeSenseDelay
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.codeSenseDelay];
                return (null == val) ? 0 : (int)val;
            }
            set { optionsTable[LanguageOptionKeys.codeSenseDelay] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableAsyncCompletion"]' />
        public bool EnableAsyncCompletion
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableAsyncCompletion];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableAsyncCompletion] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableCommenting"]' />
        public bool EnableCommenting
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableCommenting];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableCommenting] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableFormatSelection"]' />
        public bool EnableFormatSelection
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableFormatSelection];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableFormatSelection] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.AutoOutlining"]' />
        public bool AutoOutlining
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.autoOutlining];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.autoOutlining] = value; }
        }


        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.LanguageServicesKeyName"]' />
        private string LanguageServicesKeyName
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0}\\{1}",
                                     RegistryPaths.languageServices,
                                     LanguageName);
            }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.Register"]' />
        public override void Register(RegistrationAttribute.RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLanguageService, LanguageName, LanguageServiceSid.ToString("B")));

            // Create our top-most language key
            using (Key serviceKey = context.CreateKey(LanguageServicesKeyName))
            {
                // Add specific entries corresponding to arguments to
                // ProvideLanguageServiceAttribute constructor.
                serviceKey.SetValue(string.Empty, LanguageServiceSid.ToString("B"));
                serviceKey.SetValue(RegistryPaths.package, context.ComponentType.GUID.ToString("B"));
                serviceKey.SetValue(RegistryPaths.languageResourceId, languageResourceID);

                // Now add any explicitly specified options.
                string name;
                string value;
                foreach(object item in optionsTable.Keys)
                {
                    name = item.ToString();
                    if (optionsTable[item] is bool)
                    {
                        // Bool values are special-cased as they need to
                        // be written as 0 or 1 instead of false or true.
                        int nValue = 0;
                        if ((bool)optionsTable[item])
                        {
                            nValue = 1;
                        }
                        serviceKey.SetValue(name, nValue);
                    }
                    else if (optionsTable[item] is int)
                    {
                        serviceKey.SetValue(name, (int)optionsTable[item]);
                    }
                    else
                    {
                        // If not bool type, always write the value as a
                        // string.
                        value = optionsTable[item].ToString();
                        serviceKey.SetValue(name, value);
                    }
                }
                if (debuggerLanguages.IsValid())
                {
                    // If any debugger language options have been specified then...
                    // Note: we are assuming there can be only one of these entries
                    // for each language service.
                    string eeRegName = string.Format(CultureInfo.InvariantCulture, 
                                                     "{0}\\{1}", 
                                                     RegistryPaths.debuggerLanguages, 
                                                     debuggerLanguages.ExpressionEvaluator.ToString("B"));
                    using (Key dbgLangKey = serviceKey.CreateSubkey(eeRegName))
                    {
                        dbgLangKey.SetValue(null, debuggerLanguages.LanguageName);
                    }
                }
            }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.Unregister"]' />
        public override void Unregister(RegistrationAttribute.RegistrationContext context)
        {
            context.RemoveKey(LanguageServicesKeyName);
        }

        // Local classes.

        // DebuggerLanguages encapsulates all elements under the
        // "Debugger Languages" registry key.  There are only two entries
        // ever under this key and that's a language name and a guid of an
        // expression evaluator.
        private class DebuggerLanguages
        {
            //////////////////////////////////////////////////////////////////
            // DebuggerLanguages Private fields.
            private Guid   guidEE;    // Expression Evaluator Guid
            private string languageName;

            //////////////////////////////////////////////////////////////////
            // DebuggerLanguages Public methods.
            public DebuggerLanguages(string languageName)
            {
                this.languageName = languageName;
                guidEE = Guid.Empty;
            }
            /// <summary>
            /// Guid of the expression evaluator.
            /// </summary>
            /// <value>Guid</value>
            public Guid ExpressionEvaluator
            {
                get { return guidEE; }
                set { guidEE = value; }
            }

            public string LanguageName
            {
                get { return languageName; }
            }

            /// <summary>
            /// Determine whether the debugger language options have been set.
            /// </summary>
            /// <returns>bool</returns>
            public bool IsValid()
            {
                return guidEE != Guid.Empty;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideObjectAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideObjectAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideObjectAttribute.uex' path='docs/doc[@for="ProvideObjectAttribute"]' />
    /// <devdoc>
    ///     This attribute declares a class as creatable through Visual Studio.  
    ///     A creatable class will be given an entry in Visual Studio's local 
    ///     registry at install time.  The objectType parameter specifies the
    ///     data type of the object that will be created.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideObjectAttribute : RegistrationAttribute {

        private Type _objectType;
        private RegistrationMethod registrationMethod = RegistrationMethod.Default;
    
        /// <include file='doc\ProvideObjectAttribute.uex' path='docs/doc[@for="ProvideObjectAttribute.ProvideObjectAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideObjectAttribute.
        /// </devdoc>
        public ProvideObjectAttribute (Type objectType) {
            if (objectType == null) {
                throw new ArgumentNullException("objectType");
            }
            _objectType = objectType;
        }
        
        /// <include file='doc\ProvideObjectAttribute.uex' path='docs/doc[@for="ProvideObjectAttribute.ObjectType"]' />
        /// <devdoc>
        ///     The type of object that can be created from this package.
        /// </devdoc>
        public Type ObjectType {
            get {
                return _objectType;
            }
        }

        /// <summary>
        /// Select between specifying the Codebase entry or the Assembly entry in the registry.
        /// This can be overriden during registration
        /// </summary>
        public RegistrationMethod RegisterUsing
        {
            get
            {
                return registrationMethod;
            }
            set
            {
                registrationMethod = value;
            }
        }

        private string CLSIDRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "CLSID\\{0}", ObjectType.GUID.ToString("B")); }
        }

        /// <include file='doc\ProvideObjectAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyCreateObject, ObjectType.Name));

            using (Key childKey = context.CreateKey(CLSIDRegKey))
            {
                childKey.SetValue(string.Empty, ObjectType.FullName);
                childKey.SetValue("InprocServer32", context.InprocServerPath);
                childKey.SetValue("Class", ObjectType.FullName);

                // If specified on the command line, let the command line option override
                if (context.RegistrationMethod != RegistrationMethod.Default) {
                    registrationMethod = context.RegistrationMethod;
                }

            switch(registrationMethod) {
                case RegistrationMethod.Default:
                case RegistrationMethod.Assembly:
                    childKey.SetValue("Assembly", ObjectType.Assembly.FullName);
                    break;
                
                    case RegistrationMethod.CodeBase:
                        childKey.SetValue("CodeBase", context.CodeBase);
                        break;
                }

                childKey.SetValue("ThreadingModel", "Both");
            }
        }
        /// <summary>
        /// Unregisters this attribute.
        /// </summary>
        /// <param name="context">
        ///     Contains the location from where the registration inforomation should be removed.
        ///     It also contains other informations as the type being unregistered and path information.
        /// </param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(CLSIDRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideOptionDialogPageAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideOptionPageAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideOptionDialogPageAttribute.uex' path='docs/doc[@for="ProvideOptionDialogPageAttribute"]' />
    /// <devdoc>
    /// This is the base class for all the attributes that are used to register an option page.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public abstract class ProvideOptionDialogPageAttribute : RegistrationAttribute {

        // The type of the option page provided with this attribute. This type must derive from DialogPage.
        private Type _pageType;
        // The id of the resource storing the localized name of the option page.
        private string _pageNameResourceId;

        /// <include file='doc\ProvideOptionDialogPageAttribute.uex' path='docs/doc[@for="ProvideOptionDialogPageAttribute.ProvideOptionDialogPageAttribute"]' />
        /// <devdoc>
        /// This is the constructor of this attribute; it will set the type of the proffered option page.
        /// </devdoc>
        /// <param name="pageType"></param>
        /// <param name="pageNameResourceId"></param>
        public ProvideOptionDialogPageAttribute(Type pageType, string pageNameResourceId)
        {
            // Check the input type: as first make sure this is not null...
            if (pageType == null) {
                throw new ArgumentNullException("pageType");
            }
            // .. then make sure that it derives from DialogPage.
            if (!typeof(DialogPage).IsAssignableFrom(pageType)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Package_PageNotDialogPage, pageType.FullName));
            }
            _pageType = pageType;
            _pageNameResourceId = pageNameResourceId;
        }

        /// <include file='doc\ProvideOptionDialogPageAttribute.uex' path='docs/doc[@for="ProvideOptionDialogPageAttribute.PageType"]' />
        /// <devdoc>
        /// Gets the type of the option page provided with this attribute.
        /// </devdoc>
        public Type PageType {
            get { return _pageType; }
        }

        /// <include file='doc\ProvideOptionDialogPageAttribute.uex' path='docs/doc[@for="ProvideOptionDialogPageAttribute.PageNameResourceId"]' />
        /// <devdoc>
        /// Gets the id of the resource storing the localized name of the option page.
        /// </devdoc>
        public string PageNameResourceId {
            get { return _pageNameResourceId; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideMenuResourceAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideMenuResourceAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers menu resources.  When Visual Studio encounters 
    ///     such a package it will merge the menu resource information in its menus.  The attributes on a 
    ///     package do not control the behavior of the package, but they can be used by registration 
    ///     tools to register the proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideMenuResourceAttribute : RegistrationAttribute {

        private string _resourceID;
        private int   _version;
    
        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute.ProvideMenuResourceAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideMenuResourceAttribute.
        /// </devdoc>
        public ProvideMenuResourceAttribute (short resourceID, int version) {
            _resourceID = resourceID.ToString();
            _version = version;
        }
        
        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute.ProvideMenuResourceAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideMenuResourceAttribute.
        /// </devdoc>
        public ProvideMenuResourceAttribute (string resourceID, int version) {
            if (string.IsNullOrEmpty(resourceID)) {
                throw new ArgumentNullException("resourceID");
            }
            _resourceID = resourceID;
            _version = version;
        }

        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute.ResourceID"]' />
        /// <devdoc>
        ///     Returns the native resource ID for the menu resource.
        /// </devdoc>
        public string ResourceID {
            get {
                return _resourceID;
            }
        }
        
        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute.Version"]' />
        /// <devdoc>
        ///     Returns the version of this menu resource.
        /// </devdoc>
        public int Version {
            get {
                return _version;
            }
        }

        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyMenuResource, ResourceID, Version));

            using (Key childKey = context.CreateKey("Menus"))
            {
                childKey.SetValue(context.ComponentType.GUID.ToString("B"), string.Format(CultureInfo.InvariantCulture, ", {0}, {1}", ResourceID, Version));
            }
        }

        /// <summary>
        ///     Called to unregister this attribute with the given context.
        /// </summary>
        /// <param name="context">
        ///     Contains the location where the registration inforomation should be placed.
        ///     It also contains other informations as the type being registered and path information.
        /// </param>
        public override void Unregister(RegistrationContext context) {
            context.RemoveValue("Menus", context.ComponentType.GUID.ToString("B"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideToolboxFormatAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideToolboxFormatAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <include file='doc\ProvideToolboxFormatAttribute.uex' path='docs/doc[@for="ProvideToolboxFormatAttribute"]' />
    /// <devdoc>
    ///     This attribute declares a single toolbox clipboard format that
    ///     the package supports.  Multiple attributes can be added to
    ///     a package to allow more than one clipboard format.  By
    ///     providing this attribute on your package, you enable
    ///     users to drag data objects containing this format onto the
    ///     toolbox. You must still handle the drop notifications 
    ///     yourself.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited=true, AllowMultiple=true)]
    public sealed class ProvideToolboxFormatAttribute : Attribute {

        private string _format;
    
        /// <include file='doc\ProvideToolboxFormatAttribute.uex' path='docs/doc[@for="ProvideToolboxFormatAttribute.ProvideToolboxFormatAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideToolboxFormatAttribute.
        /// </devdoc>
        public ProvideToolboxFormatAttribute(string format) {

            if (format == null) {
                throw new ArgumentNullException("format");
            }

            _format = format;
        }
    
        /// <include file='doc\ProvideToolboxFormatAttribute.uex' path='docs/doc[@for="ProvideToolboxFormatAttribute.Format"]' />
        /// <devdoc>
        ///     Returns the clipboard format to enable for this package.
        /// </devdoc>
        public string Format {
            get {
                return _format;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideOptionPageAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideOptionPageAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers one or more option pages.  
    ///     Option pages are exposed to the user through Visual Studio's Tools->Options 
    ///     dialog.  The first parameter to this attribute is the type of option page, 
    ///     which is a type that must derive from DialogPage.  Option page attributes 
    ///     are read by the package class when Visual Studio requests a particular option 
    ///     page GUID.  Package will walk the attributes and try to match the requested 
    ///     GUID to a GUID on a type in the package. 
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideOptionPageAttribute : ProvideOptionDialogPageAttribute {

        private string  _categoryName;
        private string  _pageName;
        private short   _categoryResourceID;
        private bool    _supportsAutomation;
        private bool    _noShowAllView;
        private bool    _supportsProfiles = false;
        private ProfileMigrationType _migrationType = ProfileMigrationType.None;
        
        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.ProvideOptionPageAttribute"]' />
        /// <devdoc>
        ///     The page type is a type that derives from
        ///     DialogPage.  The nameResourceID
        ///     parameter specifies a Win32 resource ID in the 
        ///     stored in the native UI resource satellite
        ///     that describes the name of this page.
        ///     The categoryResourceID specifies the page
        ///     category name.
        /// </devdoc>        
        public ProvideOptionPageAttribute(Type pageType, string categoryName, string pageName, short categoryResourceID, short pageNameResourceID, bool supportsAutomation) 
            : base (pageType, "#"+pageNameResourceID.ToString()) {
            if (categoryName == null) {
                throw new ArgumentNullException("categoryName");
            }
            if (pageName == null) {
                throw new ArgumentNullException("pageName");
            }

            _categoryName = categoryName;
            _pageName = pageName;
            _categoryResourceID = categoryResourceID;
            _supportsAutomation = supportsAutomation;
        }

        /// <devdoc>
        /// The VB Simplified option page is visible only for "simply" pages, that is a page that sets this
        /// parameter to true.
        /// </devdoc>
        public bool NoShowAllView {
            get { return _noShowAllView;  }
            set { _noShowAllView = value; }
        }

        
        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.TypeId"]' />
        /// <devdoc>
        /// Identity of this instance of the attribute.
        /// </devdoc>
        public override object TypeId {
            get {
                return this;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.CategoryName"]' />
        /// <devdoc>
        ///     The programmatic name for this category (non localized).
        /// </devdoc>
        public string CategoryName {
            get {
                return _categoryName;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.CategoryResourceID"]' />
        /// <devdoc>
        ///     The native resourceID of the category name for this page.
        /// </devdoc>
        public short CategoryResourceID {
            get {
                return _categoryResourceID;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.PageName"]' />
        /// <devdoc>
        ///     The programmatic name for this page (non localized).
        /// </devdoc>
        public string PageName {
            get {
                return _pageName;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.SupportsAutomation"]' />
        /// <devdoc>
        ///     True if this page should be registered as supporting automation.
        /// </devdoc>
        public bool SupportsAutomation {
            get {
                return _supportsAutomation;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.SupportsProfiles"]' />
        /// <devdoc>
        ///     True if this page should be registered as supporting profiles.  
        ///     Note: Only works if SupportsAutomation is true.  The ProvideProfile attribute 
        ///     can also be used to specify profile support for Tools/Options pages.
        /// </devdoc>
        public bool SupportsProfiles {
            get {
                return _supportsProfiles;
            }
            set {
                _supportsProfiles = value;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.ProfileMigrationType"]' />
        /// <devdoc>
        ///     Specifies the migration action to take for this category.
        /// </devdoc>
        public ProfileMigrationType ProfileMigrationType
        {
            get { return _migrationType; }
            set { _migrationType = value; }
        }

        private string ToolsOptionsPagesRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "ToolsOptionsPages\\{0}", CategoryName); }
        }

        private string AutomationCategoryRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "AutomationProperties\\{0}", CategoryName); }
        }
        private string AutomationRegKey
        {
            get { return String.Format(CultureInfo.InvariantCulture, "{0}\\{1}", AutomationCategoryRegKey, PageName); }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyOptionPage, CategoryName, PageName));

            using (Key toolsOptionsKey = context.CreateKey(ToolsOptionsPagesRegKey))
            {
                toolsOptionsKey.SetValue(string.Empty, string.Format(CultureInfo.InvariantCulture, "#{0}", CategoryResourceID));
                toolsOptionsKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));

                using (Key pageKey = toolsOptionsKey.CreateSubkey(PageName))
                {
                    pageKey.SetValue(string.Empty, PageNameResourceId);
                    pageKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                    pageKey.SetValue("Page", PageType.GUID.ToString("B"));
                    if ( NoShowAllView )
                        pageKey.SetValue("NoShowAllView", 1);
                }
            }

            if (SupportsAutomation) {
                using (Key automationKey = context.CreateKey(AutomationRegKey))
                {
                    automationKey.SetValue("Name", string.Format(CultureInfo.InvariantCulture, "{0}.{1}", CategoryName, PageName));
                    automationKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                    if ( SupportsProfiles ) {
                        automationKey.SetValue("ProfileSave", 1);
                        automationKey.SetValue("VSSettingsMigration", (int)ProfileMigrationType);
                    }
                }
            }

        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ToolsOptionsPagesRegKey);

            if (SupportsAutomation)
            {
                context.RemoveKey(AutomationRegKey);
                context.RemoveKeyIfEmpty(AutomationCategoryRegKey);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideProfileAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideProfileAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProfileMigrationType"]/*' />
    public enum ProfileMigrationType
    {
        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProfileMigrationType.None"]/*' />
        None,
        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProfileMigrationType.PassThrough"]/*' />
        PassThrough,
        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProfileMigrationType.Custom"]/*' />
        Custom
    };

    /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute"]' />
    /// <devdoc>
    ///     This attribute declares a class as a Visual Studio Profile item and
    ///     places items in the VS registry for the User Settings.
    ///     This may optionally specify a Tools Options page.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideProfileAttribute : RegistrationAttribute {
        
        private Type    _objectType;
        private string  _groupName;
        private string  _categoryName;
        private string  _objectName;
        private string  _alternateParent;
        private string  _resourcePackageGuid;
        private short   _groupResourceID = 0;
        private short   _categoryResourceID = 0;
        private short   _objectNameResourceID = 0;
        private short   _descriptionResourceID = 0;
        private bool    _isToolsOptionPage;
        private ProfileMigrationType _migrationType = ProfileMigrationType.None;

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.ProvideProfileAttribute1"]' />
        /// <devdoc>
        /// </devdoc>        
        public ProvideProfileAttribute(Type objectType, string categoryName, string objectName, short categoryResourceID, short objectNameResourceID, bool isToolsOptionPage) {
            if (objectType == null) {
                throw new ArgumentNullException("objectType");
            }
            if (categoryName == null) {
                throw new ArgumentNullException("categoryName");
            }
            if (objectName == null) {
                throw new ArgumentNullException("objectName");
            }
            if (!typeof(IProfileManager).IsAssignableFrom(objectType)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.General_InvalidType, typeof(IProfileManager).FullName), objectType.FullName);
            }

            _objectType = objectType;
            _categoryName = categoryName;
            _objectName = objectName;
            _categoryResourceID = categoryResourceID;
            _objectNameResourceID = objectNameResourceID;
            _isToolsOptionPage = isToolsOptionPage;
        }


        /// <devdoc>
        ///     The programmatic name for this Group (non localized).
        /// </devdoc>
        public string GroupName
        {
            get { return _groupName; }
            set { _groupName = value; }
        }

        /// <devdoc>
        ///     The native resourceID of the group name for this page in the Profile.
        /// </devdoc>
        public short GroupResourceID
        {
            get { return _groupResourceID; }
            set { _groupResourceID = value; }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.CategoryName"]' />
        /// <devdoc>
        ///     The programmatic name for this category (non localized).
        /// </devdoc>
        public string CategoryName {
            get {
                return _categoryName;
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.CategoryResourceID"]' />
        /// <devdoc>
        ///     The native resourceID of the category name for this page.
        /// </devdoc>
        public short CategoryResourceID {
            get {
                return _categoryResourceID;
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.PageName"]' />
        /// <devdoc>
        ///     The programmatic name for this page (non localized).
        /// </devdoc>
        public string ObjectName {
            get {
                return _objectName;
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.PageNameResourceID"]' />
        /// <devdoc>
        ///     The native resourceID of the name for this page in the Profile.
        /// </devdoc>
        public short ObjectNameResourceID {
            get {
                return _objectNameResourceID;
            }
        }
        
        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.PageType"]' />
        /// <devdoc>
        ///     The type of this object.
        /// </devdoc>
        public Type ObjectType {
            get {
                return _objectType;
            }
        }
    
        /// <devdoc>
        ///     The Guid of a package providing the resource strings (only need to specify if this a different package).
        /// </devdoc>
        public string ResourcePackageGuid
        {
            get { return _resourcePackageGuid; }
            set { _resourcePackageGuid = value; }
        }

        /// <devdoc>
        ///     The native resourceID of the description for this page in the Profile.
        /// </devdoc>
        public short DescriptionResourceID
        {
            get { return _descriptionResourceID; }
            set { _descriptionResourceID = value; }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.AlternateParent"]' />
        /// <devdoc>
        ///     Allows the data to be parented under a different category in profile data.
        /// </devdoc>
        public string AlternateParent
        {
            get { return _alternateParent; }
            set { _alternateParent = value; }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.IsToolsOptionPage"]' />
        /// <devdoc>
        ///     Is this a Tools->Option page.
        /// </devdoc>

        public bool IsToolsOptionPage {
            get {
                return _isToolsOptionPage;
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.MigrationType"]' />
        /// <devdoc>
        ///     Specifies the migration action to take for this category.
        /// </devdoc>
        public ProfileMigrationType MigrationType
        {
            get { return _migrationType; }
            set { _migrationType = value; }
        }

        private string SettingsRegKey
        {
            get
            {
                if (String.IsNullOrEmpty(GroupName))
                    return string.Format(CultureInfo.InvariantCulture, "UserSettings\\{0}_{1}", CategoryName, ObjectName);
                else
                    return string.Format(CultureInfo.InvariantCulture, "UserSettings\\{0}\\{1}_{2}", GroupName, CategoryName, ObjectName);
            }
        }
     
        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyCreateObject, ObjectType.Name));

            if (!String.IsNullOrEmpty(GroupName) && GroupResourceID>0)
            {
                using (Key groupKey = context.CreateKey(String.Format(CultureInfo.InvariantCulture, "UserSettings\\{0}", GroupName)))
                {
                    groupKey.SetValue(string.Empty, GroupResourceID.ToString(CultureInfo.InvariantCulture));
                }
            }

            using (Key childKey = context.CreateKey(SettingsRegKey))
            {
                childKey.SetValue(string.Empty, ObjectNameResourceID.ToString(CultureInfo.InvariantCulture));
                childKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                childKey.SetValue("Category", ObjectType.GUID.ToString("B"));
                if(IsToolsOptionPage) {
                    childKey.SetValue("ToolsOptionsPath", CategoryName);
                }
                if (!String.IsNullOrEmpty(AlternateParent))
                    childKey.SetValue("AlternateParent", AlternateParent);
                if (!String.IsNullOrEmpty(ResourcePackageGuid))
                    childKey.SetValue("ResourcePackage", ResourcePackageGuid);
                if (DescriptionResourceID > 0)
                    childKey.SetValue("Description", DescriptionResourceID.ToString(CultureInfo.InvariantCulture));

                childKey.SetValue("VSSettingsMigration", (int)MigrationType);
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(SettingsRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideProjectItemAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideProjectItemAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell
{
    using System;
    using System.IO;
    using System.Diagnostics;
    using System.Globalization;


    /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute"]' />
    /// <devdoc>
    ///     This attribute associates register items to be included in the Add New Item.  
    ///     dialog for the specified project type. It is placed on a package.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideProjectItemAttribute : RegistrationAttribute
    {
        private int priority;
        private Guid factory;
        private string templateDir;
        private string itemType;

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.ProvideProjectItemAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public ProvideProjectItemAttribute(object projectFactoryType, string itemCategoryName, string templatesDir, int priority)
        {
            if (templatesDir == null || templatesDir.Length == 0)
                throw new ArgumentNullException("templatesDir");

            if (itemCategoryName == null || itemCategoryName.Length == 0)
                throw new ArgumentNullException("itemCategoryName");

            // figure out what type of object they passed in and get the GUID from it
            if (projectFactoryType is string)
                this.factory = new Guid((string)projectFactoryType);
            else if (projectFactoryType is Type)
                this.factory = ((Type)projectFactoryType).GUID;
            else if (projectFactoryType is Guid)
                this.factory = (Guid)projectFactoryType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, projectFactoryType));

            this.priority = priority;
            this.templateDir = templatesDir;
            this.itemType = itemCategoryName;
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.ProjectFactoryType"]' />
        /// <devdoc>
        ///     The Project factory guid.
        /// </devdoc>
        public Guid ProjectFactoryType
        {
            get {return factory;}
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.Priority"]' />
        /// <devdoc>
        ///     The priority of this item.
        /// </devdoc>
        public int Priority
        {
            get {return priority;}
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.TemplateDir"]/*' />
        public string TemplateDir
        {
            get { return templateDir; }
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.ItemType"]/*' />
        /// <summary>
        /// String describing the item type. This string is used as the folder in the
        /// left side of the "Add New Items" dialog.
        /// </summary>
        public string ItemType
        {
            get { return itemType; }
        }


        /// <summary>
        ///        The reg key name of the project.
        /// </summary>
        private string ProjectRegKeyName(RegistrationContext context) 
        {
            return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\AddItemTemplates\\TemplateDirs\\{1}\\/1",
                                factory.ToString("B"),
                                context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyProjectItems, factory.ToString("B")));

            using (Key childKey = context.CreateKey(ProjectRegKeyName(context)))
            {
                childKey.SetValue("", itemType);

                Uri url = new Uri(context.ComponentType.Assembly.CodeBase);
                string templates = url.LocalPath;
                templates = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(templates), templateDir);
                templates = context.EscapePath(System.IO.Path.GetFullPath(templates));
                childKey.SetValue("TemplatesDir", templates);

                childKey.SetValue("SortPriority", Priority);
            }
        }

        /// <include file='doc\ProvideProjectItemAttributeProjectItem.uex' path='docs/doc[@for="ProvideProjectItemAttribute.Unregister"]/*' />
        /// <summary>
        /// Unregister this editor.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ProjectRegKeyName(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideProjectFactoryAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideProjectFactoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.ComponentModel;
    using System.Globalization;

    /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers an project factory.  A single 
    ///     package can provide multiple project factories.  If a package declares that 
    ///     it provides an project factory, it should create the factory and offer it 
    ///     to Visual Studio in the Initialize method of Package.
    /// 
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideProjectFactoryAttribute : RegistrationAttribute {

        private Type    _factoryType;
        private string   _displayProjectFileExtensions;
        private string  _name;
        private string  _defaultProjectExtension;
        private string  _possibleProjectExtensions;
        private string  _projectTemplatesDirectory;
        private int     _sortPriority = 100;
        private Guid    _folderGuid = Guid.Empty;

        private string languageVsTemplate;
        private string templateGroupIDsVsTemplate;
        private string templateIDsVsTemplate;
        private string displayProjectTypeVsTemplate;
        private string projectSubTypeVsTemplate;
        private bool newProjectRequireNewFolderVsTemplate = false;
        private bool showOnlySpecifiedTemplatesVsTemplate = false;

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.ProvideProjectFactoryAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideProjectFactoryAttribute.
        /// </devdoc>
        public ProvideProjectFactoryAttribute(Type factoryType, string name, string displayProjectFileExtensionsResourceID, string defaultProjectExtension, string possibleProjectExtensions, string projectTemplatesDirectory) {
            if (factoryType == null) {
                throw new ArgumentNullException("factoryType");
            }

            _factoryType = factoryType;
            _name = name;
            _displayProjectFileExtensions = displayProjectFileExtensionsResourceID;
            _defaultProjectExtension = defaultProjectExtension;
            _possibleProjectExtensions = possibleProjectExtensions;
            _projectTemplatesDirectory = projectTemplatesDirectory;
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.Name"]/*' />
        /// <summary>
        /// The tree node name in the create new project and add new item dialogs.
        /// Take precendence over the nameResourceID value
        /// </summary>
        /// <value>Name to be used</value>
        public string Name
        {
            get { return _name; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.SortPriority"]/*' />
        /// <summary>
        /// Affect the order in which project are displayed in the new project dialog
        /// </summary>
        /// <value>Default is 100</value>
        public int SortPriority
        {
            get { return _sortPriority; }
            set { _sortPriority = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.FactoryType"]' />
        /// <devdoc>
        ///     Returns the project factory type this attribute declares.
        /// </devdoc>
        public Type FactoryType {
            get {
                return _factoryType;
            }            
        }
        
        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.DisplayProjectFileExtensionsResourceID"]' />
        /// <devdoc>
        ///     Returns the display project files extensions string.
        /// </devdoc>
        public string DisplayProjectFileExtensions {
            get {
                return _displayProjectFileExtensions;
            }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.DefaultProjectExtension"]' />
        /// <devdoc>
        ///     Returns the default project extension.
        /// </devdoc>
        public string DefaultProjectExtension {
            get {
                return _defaultProjectExtension;
            }
        }


        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.PossibleProjectExtensions"]' />
        /// <devdoc>
        ///     Returns the default project extension.
        /// </devdoc>
        public string PossibleProjectExtensions {
            get {
                return _possibleProjectExtensions;
            }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.ProjectTemplatesDirectory"]' />
        /// <devdoc>
        ///     Returns the default project extension.
        /// </devdoc>
        public string ProjectTemplatesDirectory {
            get {
                return _projectTemplatesDirectory;
            }
        }

        /// <summary>
        /// Get or Set the Folder guid.
        /// This can be used to control where the project node appear in the New Project dialog
        /// </summary>
        public string FolderGuid
        {
            get { return _folderGuid.ToString("B"); }
            set { _folderGuid = new Guid(value); }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.LanguageVsTemplate"]/*' />
        public string LanguageVsTemplate
        {
            get { return languageVsTemplate; }
            set { languageVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.DisplayProjectTypeVsTemplate"]/*' />
        public string DisplayProjectTypeVsTemplate
        {
            get { return displayProjectTypeVsTemplate; }
            set { displayProjectTypeVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.DisableOnlineTemplates"]/*' />
        public bool DisableOnlineTemplates
        {
            get;
            set;
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.ProjectSubTypeVsTemplate"]/*' />
        public string ProjectSubTypeVsTemplate
        {
            get { return projectSubTypeVsTemplate; }
            set { projectSubTypeVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.NewProjectRequireNewFolderVsTemplate"]/*' />
        public bool NewProjectRequireNewFolderVsTemplate
        {
            get { return newProjectRequireNewFolderVsTemplate; }
            set { newProjectRequireNewFolderVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.ShowOnlySpecifiedTemplatesVsTemplate"]/*' />
        public bool ShowOnlySpecifiedTemplatesVsTemplate
        {
            get { return showOnlySpecifiedTemplatesVsTemplate; }
            set { showOnlySpecifiedTemplatesVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.TemplateGroupIDsVsTemplate"]/*' />
        public string TemplateGroupIDsVsTemplate
        {
            get { return templateGroupIDsVsTemplate; }
            set { templateGroupIDsVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.TemplateIDsVsTemplate"]/*' />
        public string TemplateIDsVsTemplate
        {
            get { return templateIDsVsTemplate; }
            set { templateIDsVsTemplate = value; }
        }


        private string ProjectRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}", FactoryType.GUID.ToString("B")); }
        }

        private string NewPrjTemplateRegKey(RegistrationContext context)
        {
            return string.Format(CultureInfo.InvariantCulture, "NewProjectTemplates\\TemplateDirs\\{0}\\/1", context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyProjectFactory, FactoryType.Name));

            using (Key projectKey = context.CreateKey(ProjectRegKey))
            {
                projectKey.SetValue(string.Empty, FactoryType.Name);
                if (_name != null)
                    projectKey.SetValue("DisplayName", _name);
                if (_displayProjectFileExtensions != null)
                    projectKey.SetValue("DisplayProjectFileExtensions", _displayProjectFileExtensions);
                if (DisableOnlineTemplates)
                    projectKey.SetValue("DisableOnlineTemplates", (int)1);
                projectKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                if (_defaultProjectExtension != null)
                    projectKey.SetValue("DefaultProjectExtension", _defaultProjectExtension);
                if (_possibleProjectExtensions != null)
                    projectKey.SetValue("PossibleProjectExtensions", _possibleProjectExtensions);
                if (_projectTemplatesDirectory != null)
                {
                    if (!System.IO.Path.IsPathRooted(_projectTemplatesDirectory))
                    {
                        // If path is not rooted, make it relative to package path
                        _projectTemplatesDirectory = System.IO.Path.Combine(context.ComponentPath, _projectTemplatesDirectory);
                    }
                    projectKey.SetValue("ProjectTemplatesDir", _projectTemplatesDirectory);
                }

                // VsTemplate Specific Keys
                if (languageVsTemplate != null)
                    projectKey.SetValue("Language(VsTemplate)", languageVsTemplate);
                if (showOnlySpecifiedTemplatesVsTemplate)
                    projectKey.SetValue("ShowOnlySpecifiedTemplates(VsTemplate)", (int)1);
                if (templateGroupIDsVsTemplate != null)
                    projectKey.SetValue("TemplateGroupIDs(VsTemplate)", templateGroupIDsVsTemplate);
                if (templateIDsVsTemplate != null)
                    projectKey.SetValue("TemplateIDs(VsTemplate)", templateIDsVsTemplate);
                if (displayProjectTypeVsTemplate != null)
                    projectKey.SetValue("DisplayProjectType(VsTemplate)", displayProjectTypeVsTemplate);
                if (projectSubTypeVsTemplate != null)
                    projectKey.SetValue("ProjectSubType(VsTemplate)", projectSubTypeVsTemplate);
                if (newProjectRequireNewFolderVsTemplate)
                    projectKey.SetValue("NewProjectRequireNewFolder(VsTemplate)", (int)1);
            }

            using (Key prjTemplateKey = context.CreateKey(NewPrjTemplateRegKey(context)))
            {

                string keyName = String.Empty;
                if (_name != null)
                    prjTemplateKey.SetValue(keyName, _name);
                prjTemplateKey.SetValue("SortPriority", _sortPriority);
                if (_projectTemplatesDirectory != null)
                {
                    prjTemplateKey.SetValue("TemplatesDir", _projectTemplatesDirectory);
                }
                if (_folderGuid != Guid.Empty)
                {
                    prjTemplateKey.SetValue("Folder", FolderGuid);
                }
            }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.Unregister"]/*' />
        public override void Unregister(RegistrationContext context) {
            context.RemoveKey(ProjectRegKey);
            context.RemoveKey(NewPrjTemplateRegKey(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideViewAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideViewAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <include file='doc\ProvideViewAttribute.uex' path='docs/doc[@for="ProvideViewAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that an editor factory offers a particular logical view.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideViewAttribute : Attribute {

        private LogicalView _logicalView;
        private string      _physicalView;

        /// <include file='doc\ProvideViewAttribute.uex' path='docs/doc[@for="ProvideViewAttribute.ProvideViewAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideViewAttribute.
        /// </devdoc>
	    public ProvideViewAttribute (LogicalView logicalView, string physicalView) {
            _logicalView = logicalView;
            _physicalView = physicalView;   // NULL is valid here.
        }

        /// <include file='doc\ProvideViewAttribute.uex' path='docs/doc[@for="ProvideViewAttribute.LogicalView"]' />
        /// <devdoc>
        ///     Returns the logical view in this attribute.
        /// </devdoc>
	    public LogicalView LogicalView {
            get {
                return _logicalView;
            }
        }

        /// <include file='doc\ProvideViewAttribute.uex' path='docs/doc[@for="ProvideViewAttribute.PhysicalView"]' />
        /// <devdoc>
        ///     Returns the physical view that is mapped to the logical view.
        /// </devdoc>
	    public string PhysicalView {
            get {
                return _physicalView;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideServiceAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideServiceAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideServiceAttribute.uex' path='docs/doc[@for="ProvideServiceAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package provides a particular service.  The attributes on a 
    ///     package do not control the behavior of the package, but they can be used by registration 
    ///     tools to register the proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideServiceAttribute : RegistrationAttribute {

        private string _name;
        private Guid _serviceGuid;
        private Type _serviceType;

        /// <param name="serviceType"></param>
        public ProvideServiceAttribute(object serviceType)
        {
            _serviceType = null;
            // figure out what type of object they passed in and get the GUID from it
            if (serviceType is string)
                _serviceGuid = new Guid((string)serviceType);
            else if (serviceType is Type)
            {
                _serviceType = (Type)serviceType;
                _serviceGuid = _serviceType.GUID;
                _name = _serviceType.Name;
            }
            else if (serviceType is Guid)
                _serviceGuid = (Guid)serviceType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, serviceType));
        }

        /// <summary>
        /// Name of the service
        /// </summary>
        public string ServiceName
        {
            get {return _name;}
            set {_name = value;}
        }

        /// <summary>
        /// Type of the service.
        /// </summary>
        public Type Service
        {
            get { return _serviceType; }
        }

        /// <include file='doc\ProvideServiceAttribute.uex' path='docs/doc[@for="ProvideServiceAttribute.ServiceType"]' />
        /// <devdoc>
        ///     Returns the service's Guid declared in this attribute.
        /// </devdoc>
        public Guid ServiceType {
            get {
                return _serviceGuid;
            }
        }

        private string ServiceRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Services\\{0}", ServiceType.ToString("B")); }
        }

        /// <include file='doc\ProvideServiceAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyService, ServiceName));

            using (Key serviceKey = context.CreateKey(ServiceRegKey))
            {
                serviceKey.SetValue(string.Empty, context.ComponentType.GUID.ToString("B"));
                serviceKey.SetValue("Name", ServiceName);
            }
        }

        /// <summary>
        /// Unregisters this attribute.
        /// </summary>
        /// <param name="context">
        ///     Contains the location from where the registration inforomation should be removed.
        ///     It also contains other informations as the type being unregistered and path information.
        /// </param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ServiceRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideToolWindowVisibilityAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterToolWindowVisibilityAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// Declares that a tool window is should be visible when a certain command
    /// UI guid becomes active.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideToolWindowVisibilityAttribute : RegistrationAttribute {

        private string _name;
        private Guid _toolwindow;
        private Guid _commandUIGuid;

        /// <summary>
        /// Creates a new attribute for a specific tool window and a command UI guid.
        /// </summary>
        /// <param name="toolWindow">The tool window Type or Guid (as string).</param>
        /// <param name="commandUIGuid">The command UI guid that controls the tool window's visibility.</param>
        public ProvideToolWindowVisibilityAttribute(object toolWindow, string commandUIGuid)
        {
            if (toolWindow is Type)
            {
                Type t = (Type)toolWindow;
                _toolwindow = t.GUID;
                _name = t.Name;
            }
            else if (toolWindow is string)
                _toolwindow = new Guid(toolWindow as string);
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.General_InvalidType, typeof(System.Type).FullName), "toolWindow");
            _commandUIGuid = new Guid(commandUIGuid);
        }

        /// <summary>
        /// Get the command UI guid controlling the visibility of the tool window.
        /// </summary>
        public Guid CommandUIGuid
        {
            get { return _commandUIGuid; }
        }

        /// <summary>
        /// Get or Set name of the toolwindow.
        /// This does not impact the runtime behavior.
        /// </summary>
        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }

        private string RegistryPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "ToolWindows\\{0}\\Visibility", _toolwindow.ToString("B")); }
        }

        /// <summary>
        /// Called to register this attribute with the given context.  The context
        /// contains the location where the registration information should be placed.
        /// it also contains such as the type being registered, and path information.
        /// </summary>
        public override void Register(RegistrationContext context)
        {
            // Write to the context's log what we are about to do
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyToolVisibility, _name, CommandUIGuid.ToString("B")));

            // Create the visibility key.
            using (Key childKey = context.CreateKey(RegistryPath))
            {
                // Set the value for the command UI guid.
                childKey.SetValue(CommandUIGuid.ToString("B"), 0);
            }
        }

        /// <summary>
        /// Unregister this visibility entry.
        /// </summary>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveValue(RegistryPath, CommandUIGuid.ToString("B"));
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideToolWindowAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterToolWindowResourceAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell
{

    using System;
    using System.Drawing;
    using System.ComponentModel.Design;
    using System.Globalization;

    /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle"]/*' />
    public enum VsDockStyle {
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.none"]/*' />
        none,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.MDI"]/*' />
        MDI,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.Float"]/*' />
        Float,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.Linked"]/*' />
        Linked,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.Tabbed"]/*' />
        Tabbed,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.AlwaysFloat"]/*' />
        AlwaysFloat
    };
    /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation"]/*' />
    public enum ToolWindowOrientation {
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.none"]/*' />
        none,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.Top"]/*' />
        Top,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.Left"]/*' />
        Left,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.Right"]/*' />
        Right,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.Bottom"]/*' />
        Bottom
    };

    /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute"]/*' />
    /// <devdoc>
    /// This attribute declares that a package own a tool window.  Visual Studio uses this 
    /// information to handle the positioning and persistence of your window. The attributes on a 
    /// package do not control the behavior of the package, but they can be used by registration 
    /// tools to register the proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideToolWindowAttribute: RegistrationAttribute {

        private Type tool;
        private string name = null;
        private ToolWindowOrientation orientation = ToolWindowOrientation.none;
        private VsDockStyle style = VsDockStyle.none;
        private Guid dockedWith = Guid.Empty;
        private Rectangle position = Rectangle.Empty;
        private bool multiInstances = false;
        private bool transient = false;

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.ProvideToolWindowAttribute"]/*' />
        /// <devdoc>
        /// Constructor
        /// Creates a new RegisterToolWindowResourceAttribute.
        /// </devdoc>
        /// <param name="toolType">Type of the tool window</param>
        public ProvideToolWindowAttribute(Type toolType) 
        {
            tool = toolType;
            name = tool.FullName;
        }

        #region Properties
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Style"]/*' />
        /// <devdoc>
        /// Default DockStyle for the ToolWindow
        /// </devdoc>
        public VsDockStyle Style
        {
            get { return style; }
            set { style = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.PositionX"]/*' />
        /// <devdoc>
        /// Default horizontal component of the position for the to top left corner of the ToolWindow
        /// </devdoc>
        public int PositionX
        {
            get { return position.X; }
            set { position.X = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.PositionY"]/*' />
        /// <devdoc>
        /// Default vertical component of the position for the to top left corner of the ToolWindow
        /// </devdoc>
        public int PositionY
        {
            get { return position.Y; }
            set { position.Y = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Width"]/*' />
        /// <devdoc>
        /// Default width of the ToolWindow
        /// </devdoc>
        public int Width
        {
            get { return position.Width; }
            set { position.Width = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Height"]/*' />
        /// <devdoc>
        /// Default height of the ToolWindow
        /// </devdoc>
        public int Height
        {
            get { return position.Height; }
            set { position.Height = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Orientation"]/*' />
        /// <devdoc>
        /// Default Orientation for the ToolWindow, relative to the window specified by the Window Property
        /// </devdoc>
        public ToolWindowOrientation Orientation
        {
            get { return orientation; }
            set { orientation = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.ToolType"]/*' />
        /// <devdoc>
        /// Type of the ToolWindow
        /// </devdoc>
        public Type ToolType
        {
            get { return tool; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Window"]/*' />
        /// <devdoc>
        /// Default Window that the ToolWindow will be docked with
        /// </devdoc>
        public string Window
        {
            get { return dockedWith.ToString(); }
            set { dockedWith = new Guid(value); }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.MultiInstances"]/*' />
        /// <devdoc>
        /// Default Window that the ToolWindow will be docked with
        /// </devdoc>
        public bool MultiInstances
        {
            get { return multiInstances; }
            set { multiInstances = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Transient"]/*' />
        /// <devdoc>
        /// Set to true if you want to prevent window from loading on IDE start up
        /// Default is false which makes the toolwindow persistent (if the IDE is closed
        /// while the window is showing, the window will show up the next time the IDE
        /// starts).
        /// </devdoc>
        public bool Transient
        {
            get { return transient; }
            set { transient = value; }
        }

        #endregion


        /// <devdoc>
        ///        The reg key name of this Tool Window.
        /// </devdoc>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "ToolWindows\\{0}", tool.GUID.ToString("B"));
            }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Register"]/*' />
        /// <devdoc>
        /// Called to register this attribute with the given context.  The context
        /// contains the location where the registration information should be placed.
        /// it also contains such as the type being registered, and path information.
        /// </devdoc>
        public override void Register(RegistrationContext context) 
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyToolResource, name, tool.GUID.ToString("B")));

            using (Key childKey = context.CreateKey(RegKeyName))
            {
                // Package owning this tool window
                childKey.SetValue(string.Empty, context.ComponentType.GUID.ToString("B"));
                if (name != null)
                    childKey.SetValue("Name", name);
                if (orientation != ToolWindowOrientation.none)
                    childKey.SetValue("Orientation", OrientationToString(orientation));
                if (style != VsDockStyle.none)
                    childKey.SetValue("Style", StyleToString(style));
                if (dockedWith != Guid.Empty)
                    childKey.SetValue("Window", dockedWith.ToString("B"));
                if (position.Width != 0 && position.Height != 0)
                {
                    string positionString = string.Format(CultureInfo.InvariantCulture, "{0}, {1}, {2}, {3}",
                                position.Left,
                                position.Top,
                                position.Right,
                                position.Bottom);
                    childKey.SetValue("Float", positionString);
                }
                if (transient)
                    childKey.SetValue("DontForceCreate", 1);
            }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Unregister"]/*' />
        /// <devdoc>
        /// Unregister this Tool Window.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName);
        }

        /// <devdoc>
        /// Convert enum to string
        /// </devdoc>
        private string StyleToString(VsDockStyle style)
        {
            switch (style)
            {
                case VsDockStyle.MDI:
                {
                    return "MDI";
                }
                case VsDockStyle.Float:
                {
                    return "Float";
                }
                case VsDockStyle.Linked:
                {
                    return "Linked";
                }
                case VsDockStyle.Tabbed:
                {
                    return "Tabbed";
                }
                case VsDockStyle.AlwaysFloat:
                {
                    return "AlwaysFloat";
                }
                case VsDockStyle.none:
                {
                    return string.Empty;
                }
                default:
                    throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_UnknownDockingStyle, style));
            }
        }

        /// <devdoc>
        /// Convert enum to string
        /// </devdoc>
        private string OrientationToString(ToolWindowOrientation position)
        {
            switch (position)
            {
                case ToolWindowOrientation.Top:
                {
                    return "Top";
                }
                case ToolWindowOrientation.Left:
                {
                    return "Left";
                }
                case ToolWindowOrientation.Right:
                {
                    return "Right";
                }
                case ToolWindowOrientation.Bottom:
                {
                    return "Bottom";
                }
                case ToolWindowOrientation.none:
                {
                    return string.Empty;
                }
                default:
                    throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_UnknownPosition, position));
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideToolboxItemConfigurationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideToolboxItemConfigurationAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using System.Globalization;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="ProvideToolboxItemConfigurationAttribute"]' />
    /// <devdoc>
    ///    Registers a confugration object for toolbox items.
    ///    ProvideToolboxItemConfigurationAttribute attached to the package.  This attribute will register 
    ///    the object under the local CLSID hive in the VS registry and also add a reference to the GUID in
    ///    VSREGROOT\ToolboxItemConfiguration.  The data contained in this registry entry
    ///    is as follows:
    /// 
    ///    VSREGROOT\ToolboxItemConfiguration
    ///        AssemblyName
    ///             ConfigurationTypeName={guid}
    /// 
    ///    As an example:
    /// 
    ///    VSREGROOT\ToolboxItemConfiguration
    ///        System, Version=2.0.3500
    ///            CompactFrameworkProvider = {GUID}
    /// 
    /// 
    ///    The assembly name is parsed and the various keys are matched.  Keys can have a
    ///    "*" in them to be taken as wildcards.  So, for example, to cover all versions
    ///    of System.WindowsForms you would specify:
    /// 
    ///    System.Windows.Forms, Version=*, PublicKeyToken=969...
    /// 
    ///    The assembly name may also be a wildcard to load the configuration object
    ///    for all toolbox items (not recommended).  
    /// 
    ///    Place this attribute on your package, and then place one or more ProvideAssemblyFilter attributes
    ///    on the class that implements IConfigureToolboxItem.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited = true, AllowMultiple = true)]
    public sealed class ProvideToolboxItemConfigurationAttribute : RegistrationAttribute {
        private Type _objectType;

        /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="ProvideToolboxItemConfigurationAttribute.ProvideToolboxItemConfigurationAttribute"]' />
        /// <devdoc>
        ///    Constructor
        /// </devdoc>
        public ProvideToolboxItemConfigurationAttribute(Type objectType) {
            if (objectType == null) {
                throw new ArgumentNullException("objectType");
            }

            _objectType = objectType;
        }

        /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="ProvideToolboxItemConfigurationAttribute.ConfigurationType"]' />
        /// <devdoc>
        ///    The configuration type to use.
        /// </devdoc>
        public Type ObjectType {
            get {
                return _objectType;
            }
        }

        private string CLSIDRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "CLSID\\{0}", ObjectType.GUID.ToString("B")); }
        }

        private string GetItemCfgFilterKey(string filter)
        {
            return string.Format(CultureInfo.InvariantCulture, "ToolboxItemConfiguration\\{0}", filter);
        }

        /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyToolboxItemConfiguration, ObjectType.Name));

            using (Key childKey = context.CreateKey(CLSIDRegKey))
            {
                childKey.SetValue(string.Empty, ObjectType.FullName);
                childKey.SetValue("InprocServer32", context.InprocServerPath);
                childKey.SetValue("Class", ObjectType.FullName);
                if (context.RegistrationMethod == RegistrationMethod.CodeBase)
                {
                    childKey.SetValue("Codebase", context.CodeBase);
                }
                else
                {
                    childKey.SetValue("Assembly", ObjectType.Assembly.FullName);
                }
                childKey.SetValue("ThreadingModel", "Both");
            }
            
            string guid = ObjectType.GUID.ToString("B");
            // Now, look up the object type and look for assembly filters.
            foreach (object attr in ObjectType.GetCustomAttributes(typeof(ProvideAssemblyFilterAttribute), true)) {
                ProvideAssemblyFilterAttribute filter = (ProvideAssemblyFilterAttribute)attr;
                context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyToolboxItemFilter, filter.AssemblyFilter)); 
                using (Key itemCfgKey = context.CreateKey(GetItemCfgFilterKey(filter.AssemblyFilter)))
                {
                    itemCfgKey.SetValue(ObjectType.FullName, guid);
                }
            }
        }

        /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(CLSIDRegKey);

            // Now, look up the object type and remove assembly filters.
            foreach (object attr in ObjectType.GetCustomAttributes(typeof(ProvideAssemblyFilterAttribute), true)) {
                ProvideAssemblyFilterAttribute filter = (ProvideAssemblyFilterAttribute)attr;
                context.RemoveKey(GetItemCfgFilterKey(filter.AssemblyFilter));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideToolboxItemsAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideToolboxItemsAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="ProvideToolboxItemsAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers toolbox items and should be provided time 
    ///     during setup to install these items.  The attributes on a package do not control the 
    ///     behavior of the package, but they can be used by registration tools to register the 
    ///     proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    public class ProvideToolboxItemsAttribute : RegistrationAttribute {

        private int   _version;
        private bool  _needsCallbackAfterReset = false;
    
        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="ProvideToolboxItemsAttribute.ProvideToolboxItemsAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideToolboxItemsAttribute.
        /// </devdoc>
        public ProvideToolboxItemsAttribute(int version) {
            _version = version;
            _needsCallbackAfterReset = false;
        }

        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="ProvideToolboxItemsAttribute.ProvideToolboxItemsAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideToolboxItemsAttribute.
        ///     If needsCallbackAfterReset is true, then it will write out the "needsCallbackAfterReset" regkey which
        ///     tells the shell we have transient items to add and need to be called after resetdefaults is complete.
        /// </devdoc>
        public ProvideToolboxItemsAttribute(int version, bool needsCallbackAfterReset) {
            _version = version;
            _needsCallbackAfterReset = needsCallbackAfterReset;
        }

        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="ProvideToolboxItemsAttribute.Version"]' />
        /// <devdoc>
        ///     Returns the version of items on the toolbox.
        ///     The first time a package get loaded after this version change,
        ///     the ToolboxInitialized event will be generated.
        /// </devdoc>
        public int Version {
            get {
                return _version;
            }
        }

        /// <summary>
        /// Setting this to true will force a ToolboxInitialized event after each
        /// toolbox reset.
        /// This can be used when developing your package to force the toolbox to
        /// ask the list of items to the package everytime (in case it has changed).
        /// For shipped products, it is best to leave it to false so that the cache can
        /// be used for better performances. Some scenario (such as item list that cannot
        /// cannot be persisted to the cache) may need to have this flag set to true
        /// </summary>
        public bool NeedsCallBackAfterReset
        {
            get { return _needsCallbackAfterReset; }
            set { _needsCallbackAfterReset = value; }
        }

        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        /// </devdoc>
        public override void Register(RegistrationContext context) {

            using (Key packageKey = context.CreateKey(GetPackageRegKeyPath(context.ComponentType.GUID)))
            {
                using (Key childKey = packageKey.CreateSubkey("Toolbox"))
                {
                    childKey.SetValue("Default Items", Version);

                    // Search the package for the AllowToolboxFormat attribute.
                    //
                    string format = string.Empty;
                    foreach(ProvideToolboxFormatAttribute pfa in context.ComponentType.GetCustomAttributes(typeof(ProvideToolboxFormatAttribute), true)) {
                        if (format.Length == 0) {
                            format = pfa.Format;
                        }
                        else {
                            format = string.Format(CultureInfo.InvariantCulture, "{0}, {1}", format, pfa.Format);
                        }
                    }

                    if (format.Length > 0) {
                        childKey.SetValue("Formats", format);
                    }

                    if (_needsCallbackAfterReset) {
                        childKey.SetValue("NeedsCallbackAfterReset", (int)1);
                    }

                    context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyToolboxItem, Version, format));
                }
            }
        }

        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Removes the registration data.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(GetPackageRegKeyPath(context.ComponentType.GUID));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideToolboxPageAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideToolboxPageAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers one or more toolbox pages.  Toolbox pages are 
    ///     exposed to the user through Visual Studio's customize toolbox dialog.  A toolbox page must 
    ///     derive from DialogPage. Toolbox page 
    ///     attributes are read by the package class when Visual Studio requests a particular property 
    ///     page GUID.  Package will walk the attributes and try to match the requested GUID to a 
    ///     GUID on a type in the package. 
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideToolboxPageAttribute : ProvideOptionDialogPageAttribute {

        private short   _pageOrder;
        private string  _helpKeyword;

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.ProvideToolboxPageAttribute"]' />
        /// <devdoc>
        ///     The page type is a type that implements
        ///     IWin32Window.  The nameResourceID
        ///     parameter specifies a Win32 resource ID in the 
        ///     stored in the native UI resource satellite
        ///     that describes the name of this page.
        /// </devdoc>
        public ProvideToolboxPageAttribute(Type pageType, short nameResourceID) : this(pageType, nameResourceID, 0) {
        }
        
        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.TypeId"]' />
        /// <devdoc>
        /// Identity of this instance of the attribute.
        /// </devdoc>
        public override object TypeId {
            get {
                return this;
            }
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.ProvideToolboxPageAttribute1"]' />
        /// <devdoc>
        ///     The page type is a type that implements
        ///     IWin32Window.  The nameResourceID
        ///     parameter specifies a Win32 resource ID in the 
        ///     stored in the native UI resource satellite
        ///     that describes the name of this page.  Page order is 
        ///     optional and defaults to zero.  If non-zero, a registry entry will be
        ///     created named DefaultTbx, which specifies the sort order of the
        ///     toolbox pages.
        /// </devdoc>
        public ProvideToolboxPageAttribute(Type pageType, short nameResourceID, short pageOrder) : this(pageType, nameResourceID, pageOrder, null) {
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.ProvideToolboxPageAttribute1"]' />
        /// <devdoc>
        ///     The page type is a type that implements
        ///     IWin32Window.  The nameResourceID
        ///     parameter specifies a Win32 resource ID in the 
        ///     stored in the native UI resource satellite
        ///     that describes the name of this page.  Page order is 
        ///     optional and defaults to zero.  If non-zero, a registry entry will be
        ///     created named DefaultTbx, which specifies the sort order of the
        ///     toolbox pages.
        ///     Helpkeyword is a keyword exposed to F1 help (support for this was added by joshs -- reference VS Whidbey#262176)
        /// </devdoc>
        public ProvideToolboxPageAttribute(Type pageType, short nameResourceID, short pageOrder, string helpKeyword) 
            : base(pageType, "#"+nameResourceID.ToString()) {

            _pageOrder = pageOrder;
            _helpKeyword = helpKeyword;
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.HelpKeyword"]' />
        /// <devdoc>
        /// Returns the help keyword associated with this toolbox page.
        /// </devdoc>
        public string HelpKeyword {
            get {
                return _helpKeyword;
            }
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.PageOrder"]' />
        /// <devdoc>
        ///     The sort order of the page or zero if this page should be left unsorted.
        /// </devdoc>
        public short PageOrder {
            get {
                return _pageOrder;
            }
        }
        
        private string ToolboxPageRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "ToolboxPages\\{0}", PageType.FullName); }
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyToolboxPage, PageType.Name));

            using (Key childKey = context.CreateKey(ToolboxPageRegKey))
            {
                childKey.SetValue(string.Empty, PageNameResourceId);
                childKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                childKey.SetValue("Page", PageType.GUID.ToString("B"));
                if (PageOrder != 0) {
                    childKey.SetValue("DefaultTbx", PageOrder);
                }
                if (_helpKeyword != null && _helpKeyword.Length > 0) {
                    childKey.SetValue("HelpKeyword", _helpKeyword);
                }
            }
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ToolboxPageRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\RegisterEditorLogicalViewAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute adds a logical view to the editor created by an editor factory.
    /// </summary>
    [Obsolete("RegisterEditorLogicalViewAttribute has been deprecated. Please use ProvideEditorLogicalViewAttribute instead.")]
	[AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterEditorLogicalViewAttribute : RegistrationAttribute
    {
        private Guid factory;
        private Guid logicalView;

        /// <summary>
        /// Creates a new RegisterEditorLogicalView attribute to register a logical
        /// view provided by your editor.
        /// </summary>
        /// <param name="factoryType">The type of factory; can be a Type, a GUID or a string representation of a GUID</param>
        /// <param name="logicalViewGuid">The guid of the logical view to register.</param>
        public RegisterEditorLogicalViewAttribute(object factoryType, string logicalViewGuid)
        {
            this.logicalView = new Guid(logicalViewGuid);
			
            // figure out what type of object they passed in and get the GUID from it
            if (factoryType is string)
                this.factory = new Guid((string)factoryType);
            else if (factoryType is Type)
                this.factory = ((Type)factoryType).GUID;
            else if (factoryType is Guid)
                this.factory = (Guid)factoryType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, factoryType));

        }

        /// <summary>
        /// Get the Guid representing the type of the editor factory
        /// </summary>
        public Guid FactoryType
        {
            get {return factory;}
        }

        /// <summary>
        /// Get the Guid representing the logical view
        /// </summary>
        public Guid LogicalView
        {
            get {return logicalView;}
        }

        private string LogicalViewPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}\\LogicalViews", factory.ToString("B")); }
        }


        /// <summary>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     It also contains other information such as the type being registered and path information.
        /// </summary>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyEditorView, logicalView.ToString("B")));

            using (Key childKey = context.CreateKey( LogicalViewPath ))
            {
                childKey.SetValue(logicalView.ToString("B"), "");
            }
        }

        /// <summary>
        /// Unregister this logical view.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveValue(LogicalViewPath, logicalView.ToString("B"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\RegistryPaths.cs ===
namespace Microsoft.VisualStudio.Shell
{
    // These string names and definitions are from vscommon\inc\vsregkeynames.h
    internal class RegistryPaths
    {
        private RegistryPaths() { }

        internal static string package            = "Package";
        internal static string displayName        = "DisplayName";
        internal static string languageStringId   = "LangStringID";
        internal static string languageResourceId = "LangResID";
        internal static string showRoots          = "ShowRoots";
        internal static string indexPath          = "IndexPath";
        internal static string paths              = "Paths";
        internal static string languages          = "Languages";
        internal static string languageServices   = languages + "\\Language Services";
        internal static string codeExpansion      = languages + "\\CodeExpansions";
        internal static string forceCreateDirs    = "ForceCreateDirs";
        internal static string debuggerLanguages  = "Debugger Languages";
        internal static string editorToolsOptions = "EditorToolsOptions";
        internal static string page               = "Page";
    }

    internal class LanguageOptionKeys
    {
        private LanguageOptionKeys() { }

        internal static string showCompletion               = "ShowCompletion";
        internal static string showIndentOptions            = "ShowSmartIndent";
        internal static string useStockColors               = "RequestStockColors";
        internal static string showHotURLs                  = "ShowHotURLs";
        internal static string nonHotURLs                   = "Default to Non Hot URLs";
        internal static string insertSpaces                 = "DefaultToInsertSpaces";
        internal static string showDropDownBar              = "ShowDropdownBarOption";
        internal static string disableWindowNewWindow       = "Single Code Window Only";
        internal static string enableAdvMembersOption       = "EnableAdvancedMembersOption";
        internal static string supportCF_HTML               = "Support CF_HTML";
        internal static string enableLineNumbersOption      = "EnableLineNumbersOption";
        internal static string hideAdvancedMembersByDefault = "HideAdvancedMembersByDefault";
        internal static string codeSense                    = "CodeSense";
        internal static string matchBraces                  = "MatchBraces";
        internal static string quickInfo                    = "QuickInfo";
        internal static string showMatchingBrace            = "ShowMatchingBrace";
        internal static string matchBracesAtCaret           = "MatchBracesAtCaret";
        internal static string maxErrorMessages             = "MaxErrorMessages";
        internal static string codeSenseDelay               = "CodeSenseDelay";
        internal static string enableAsyncCompletion        = "EnableAsyncCompletion";
        internal static string enableCommenting             = "EnableCommenting";
        internal static string enableFormatSelection        = "EnableFormatSelection";
        internal static string autoOutlining                = "AutoOutlining";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\RegisterAutoLoadAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <summary>
    ///     This attribute registers the package as an extender.  The GUID passed in determines
    ///     what is being extended. The attributes on a package do not control the behavior of
    ///     the package, but they can be used by registration tools to register the proper
    ///     information with Visual Studio.
    /// </summary>
    [Obsolete("RegisterAutoLoadAttribute has been deprecated. Please use ProvideAutoLoadAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterAutoLoadAttribute : RegistrationAttribute {

        private Guid loadGuid = Guid.Empty;

        /// <summary>
        ///     Specify that the package should get loaded when this context is active.
        /// </summary>
        /// <param name="cmdUiContextGuid">Context which should trigger the loading of your package.</param>
        public RegisterAutoLoadAttribute(string cmdUiContextGuid) 
        {
            loadGuid = new Guid(cmdUiContextGuid);
        }

        /// <summary>
        /// Context Guid which triggers the loading of the package.
        /// </summary>
        public Guid LoadGuid
        {
            get
            {
                return loadGuid;
            }
        }

        /// <summary>
        ///        The reg key name of this AutoLoad.
        /// </summary>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "AutoLoadPackages\\{0}", loadGuid.ToString("B"));
            }
        }

        /// <summary>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration information should be placed.
        ///     it also contains such as the type being registered, and path information.
        /// </summary>
        public override void Register(RegistrationContext context) 
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyAutoLoad, loadGuid.ToString("B")));

            using (Key childKey = context.CreateKey(RegKeyName))
                        {
                childKey.SetValue(context.ComponentType.GUID.ToString("B"), 0);
            }
        }

        /// <summary>
        /// Unregister this AutoLoad specification.
        /// </summary>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveValue(RegKeyName, context.ComponentType.GUID.ToString("B"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\RegisterEditorExtensionAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterEditorExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.IO;
    using System.Globalization;


    /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute"]' />
    /// <devdoc>
    ///     This attribute associates a file extension to a given editor factory.  
    ///     The editor factory may be specified as either a GUID or a type and 
    ///     is placed on a package.
    /// </devdoc>
    [Obsolete("RegisterEditorExtensionAttribute has been deprecated. Please use ProvideEditorExtensionAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterEditorExtensionAttribute : RegistrationAttribute {

        private Guid factory;
        private string extension;
        private int priority;
        private Guid project;
        private string templateDir;
        private int resId;
        private bool editorFactoryNotify;
        
        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.RegisterEditorExtensionAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public RegisterEditorExtensionAttribute (object factoryType, string extension, int priority) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_ExtensionNeedsDot, extension));
            }

            // figure out what type of object they passed in and get the GUID from it
            if (factoryType is string)
                this.factory = new Guid((string)factoryType);
            else if (factoryType is Type)
                this.factory = ((Type)factoryType).GUID;
            else if (factoryType is Guid)
                this.factory = (Guid)factoryType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, factoryType));

            this.extension = extension;
            this.priority = priority;
            this.project = Guid.Empty;
            this.templateDir = "";
            this.resId = 0;
            this.editorFactoryNotify = false;
        }
        
        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.Extension"]' />
        /// <devdoc>
        ///     The file extension of the file.
        /// </devdoc>
        public string Extension {
            get {
                return extension;
            }
        }
        
        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.Factory"]' />
        /// <devdoc>
        ///     The editor factory guid.
        /// </devdoc>
        public Guid Factory {
            get {
                return factory;
            }
        }
        
        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.Priority"]' />
        /// <devdoc>
        ///     The priority of this extension registration.
        /// </devdoc>
        public int Priority {
            get {
                return priority;
            }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.ProjectGuid"]/*' />
        public string ProjectGuid {
            set { project = new System.Guid(value); }
            get { return project.ToString(); }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.EditorFactoryNotify"]/*' />
        public bool EditorFactoryNotify {
            get { return this.editorFactoryNotify; }
            set { this.editorFactoryNotify = value; }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.TemplateDir"]/*' />
        public string TemplateDir {
            get { return templateDir; }
            set { templateDir = value; }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.NameResourceID"]/*' />
        public int NameResourceID {
            get { return resId; }
            set { resId = value; }
        }

        /// <devdoc>
        ///        The reg key name of this extension.
        /// </devdoc>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}", Factory.ToString("B"));
            }
        }

        /// <devdoc>
        ///        The reg key name of the project.
        /// </devdoc>
        private string ProjectRegKeyName(RegistrationContext context) 
        {
            return string.Format(CultureInfo.InvariantCulture,
                                 "Projects\\{0}\\AddItemTemplates\\TemplateDirs\\{1}",
                                 project.ToString("B"),
                                 context.ComponentType.GUID.ToString("B"));
        }

        private string EditorFactoryNotifyKey {
            get { return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\FileExtensions\\{1}",
                                       project.ToString("B"),
                                       Extension);
            }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyEditorExtension, Extension, Factory.ToString("B")));

            using (Key editorKey = context.CreateKey(RegKeyName))
            {
                if (0 != resId)
                    editorKey.SetValue("DisplayName", "#" + resId.ToString(CultureInfo.InvariantCulture));
                editorKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
            }

            using (Key extensionKey = context.CreateKey(RegKeyName + "\\Extensions"))
            {
                extensionKey.SetValue(Extension.Substring(1), Priority);
            }

            // Build the path of the registry key for the "Add file to project" entry
            if (project != Guid.Empty)
            {
                string prjRegKey = ProjectRegKeyName(context) + "\\/1";
                using (Key projectKey = context.CreateKey( prjRegKey ))
                {
                    if (0 != resId)
                        projectKey.SetValue("", "#" + resId.ToString(CultureInfo.InvariantCulture));
                    if (templateDir.Length != 0)
                    {
                        Uri url = new Uri(context.ComponentType.Assembly.CodeBase, true);
                        string templates = url.LocalPath;
                        templates = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(templates), templateDir);
                        templates = context.EscapePath( System.IO.Path.GetFullPath(templates) );
                        projectKey.SetValue("TemplatesDir", templates);
                    }
                    projectKey.SetValue("SortPriority", Priority);
                }
            }

            // Register the EditorFactoryNotify
            if ( EditorFactoryNotify )
            {
                // The IVsEditorFactoryNotify interface is called by the project system, so it doesn't make sense to
                // register it if there is no project associated to this editor.
                if (project == Guid.Empty)
                    throw new ArgumentException(Resources.Attributes_NoPrjForEditorFactoryNotify);

                // Create the registry key
                using (Key edtFactoryNotifyKey = context.CreateKey(EditorFactoryNotifyKey))
                {
                    edtFactoryNotifyKey.SetValue("EditorFactoryNotify", context.ComponentType.GUID.ToString("B"));
                }
            }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Unregister this editor.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName);
            if (project != Guid.Empty)
            {
                context.RemoveKey(ProjectRegKeyName(context));
                if (EditorFactoryNotify)
                    context.RemoveKey(EditorFactoryNotifyKey);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\RegisterLanguageExtensionAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterLanguageExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute"]' />
    /// <devdoc>
    ///     This attribute associates a file extension to a given editor factory.  
    ///     The editor factory may be specified as either a GUID or a type and 
    ///     is placed on a package.
    /// </devdoc>
    [Obsolete("RegisterLanguageExtensionAttribute has been deprecated. Please use ProvideLanguageExtensionAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterLanguageExtensionAttribute : RegistrationAttribute {

        private Guid languageService;
        private string extension;
        
        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute.RegisterLanguageExtensionAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public RegisterLanguageExtensionAttribute (string languageServiceGuid, string extension) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_ExtensionNeedsDot, extension));
            }

            this.languageService = new Guid(languageServiceGuid);
            this.extension = extension;
        }
        
        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute.RegisterLanguageExtensionAttribute1"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public RegisterLanguageExtensionAttribute (Type languageService, string extension) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_ExtensionNeedsDot, extension));
            }

            this.languageService = languageService.GUID;
            this.extension = extension;
        }
        
        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute.Extension"]' />
        /// <devdoc>
        ///     The file extension of the file.
        /// </devdoc>
        public string Extension {
            get {
                return extension;
            }
        }
        
        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute.LanguageService"]' />
        /// <devdoc>
        ///     The language service SID.
        /// </devdoc>
        public Guid LanguageService {
            get {
                return languageService;
            }
        }

        private string ExtensionsRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Languages\\File Extensions\\{0}", Extension); }
        }

        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLanguageExtension, Extension, LanguageService.ToString("B")));

            using (Key childKey = context.CreateKey(ExtensionsRegKey))
            {
                childKey.SetValue(string.Empty, LanguageService.ToString("B"));
            }
        }

        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context) {
            context.RemoveKey(ExtensionsRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\RegisterProjectItem.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterProjectItemAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell
{
    using System;
    using System.IO;
    using System.Diagnostics;
    using System.Globalization;


    /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute"]' />
    /// <devdoc>
    ///     This attribute associates register items to be included in the Add New Item.  
    ///     dialog for the specified project type. It is placed on a package.
    /// </devdoc>
	[Obsolete("RegisterProjectItemAttribute has been deprecated. Please use ProvideProjectItemAttribute instead.")]    
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterProjectItemAttribute : RegistrationAttribute
    {
        private int priority;
        private Guid factory;
        private string templateDir;
        private string itemType;

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.RegisterProjectItemAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public RegisterProjectItemAttribute(object projectFactoryType, string itemCategoryName, string templatesDir, int priority)
        {
            if (templatesDir == null || templatesDir.Length == 0)
                throw new ArgumentNullException("templatesDir");

            if (itemCategoryName == null || itemCategoryName.Length == 0)
                throw new ArgumentNullException("itemCategoryName");

            // figure out what type of object they passed in and get the GUID from it
            if (projectFactoryType is string)
                this.factory = new Guid((string)projectFactoryType);
            else if (projectFactoryType is Type)
                this.factory = ((Type)projectFactoryType).GUID;
            else if (projectFactoryType is Guid)
                this.factory = (Guid)projectFactoryType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, projectFactoryType));

            this.priority = priority;
            this.templateDir = templatesDir;
            this.itemType = itemCategoryName;
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.ProjectFactoryType"]' />
        /// <devdoc>
        ///     The Project factory guid.
        /// </devdoc>
        public Guid ProjectFactoryType
        {
            get {return factory;}
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.Priority"]' />
        /// <devdoc>
        ///     The priority of this item.
        /// </devdoc>
        public int Priority
        {
            get {return priority;}
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.TemplateDir"]/*' />
        public string TemplateDir
        {
            get { return templateDir; }
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.ItemType"]/*' />
        /// <summary>
        /// String describing the item type. This string is used as the folder in the
        /// left side of the "Add New Items" dialog.
        /// </summary>
        public string ItemType
        {
            get { return itemType; }
        }


        /// <summary>
        ///        The reg key name of the project.
        /// </summary>
        private string ProjectRegKeyName(RegistrationContext context) 
        {
            return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\AddItemTemplates\\TemplateDirs\\{1}\\/1",
                                factory.ToString("B"),
                                context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyProjectItems, factory.ToString("B")));

            using (Key childKey = context.CreateKey(ProjectRegKeyName(context)))
            {
                childKey.SetValue("", itemType);

                Uri url = new Uri(context.ComponentType.Assembly.CodeBase, true);
                string templates = url.LocalPath;
                templates = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(templates), templateDir);
                templates = context.EscapePath(System.IO.Path.GetFullPath(templates));
                childKey.SetValue("TemplatesDir", templates);

                childKey.SetValue("SortPriority", Priority);
            }
        }

        /// <include file='doc\RegisterProjectItem.uex' path='docs/doc[@for="RegisterProjectItemAttribute.Unregister"]/*' />
        /// <summary>
        /// Unregister this editor.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ProjectRegKeyName(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\RegistrationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegistrationAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.IO;
    using System.Globalization;

    /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationMethod"]/*' />
    /// <summary>
    /// How should the assembly be registered/located
    /// </summary>
    public enum RegistrationMethod {
        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationMethod.Default"]/*' />
        /// <summary>
        /// Default should only be used by tools
        /// </summary>
        Default = 0, 
        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationMethod.CodeBase"]/*' />
        /// <summary>
        /// The path to the assembly should be stored in the registry and used to locate the assembly at runtime
        /// </summary>
        CodeBase,
        /// <summary>
        /// The assembly should be in the GAC or in PrivateAssemblies
        /// </summary>
        Assembly};

    /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationAttribute"]' />
    /// <devdoc>
    ///     This attribute is the basis for all other attributes that can be registered by RegPkg.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    public abstract class RegistrationAttribute : Attribute {

        /// <summary>
        /// Override the TypeID property in order to let the RegistrationAttribute derived
        /// classes to work with System.ComponentModel.TypeDescriptor.GetAttributes(...).
        /// An attribute derived from this one will have to override this property only if
        /// it needs a better control on the instances that can be applied to a class.
        /// </summary>
        public override object TypeId
        {
            get
            {
                Type t = this.GetType();
                // Only one AttributeUsage attribute can be applyed to an attribute and the default
                // value is AllowMultiple = false. If both a base and derived attribute have an
                // AttributeUsage, only the one of the derived one will be returned by GetCustomAttributes.
                // We use a foreach because it will protect us from an empty collection
                // (it should never happen, but it is better to be safe) and because it will do
                // all the casts.
                bool isMultiple = false;
                foreach (AttributeUsageAttribute au in t.GetCustomAttributes(typeof(AttributeUsageAttribute), true))
                {
                    isMultiple = au.AllowMultiple;
                    // It should not be possible to have more than one AttributeUsageAttribute, but just in case...
                    break;
                }
                if (isMultiple)
                    return this;
                return t;
            }
        }

        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration information should be placed.
        ///     It also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public abstract void Register(RegistrationContext context);

        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        ///     Called to unregister this attribute with the given context.  The context
        ///     contains the location where the registration information should be removed.
        ///     It also contains things such as the type being unregistered, and path information.
        /// </devdoc>
        public abstract void Unregister(RegistrationContext context);
        
        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key"]' />
        /// <devdoc>
        ///     Abstraction around a registry key.  This may or may not actually
        ///     point to a real registry key.  It could point to a file.
        /// </devdoc>
        public abstract class Key : IDisposable {
            
            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key.Close"]' />
            /// <devdoc>
            ///     Called to close this key.  Alternately, you may use the C# "using"
            ///     syntax on keys, since they are IDisposable. Always close keys when you
            ///     are done with them.
            /// </devdoc>
            public abstract void Close();

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key.CreateSubkey"]' />
            /// <devdoc>
            ///     Creates a subkey of the given name.
            /// </devdoc>
            public abstract Key CreateSubkey(string name);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key.SetValue"]' />
            /// <devdoc>
            ///     Sets the name to the given value. Pass an empty string or null into this to
            ///     set the default value for a key.
            /// </devdoc>
            public abstract void SetValue(string valueName, object value);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key.IDisposable.Dispose"]/*' />
            /// <internalonly/>
            /// <devdoc>
            /// Closes the key.
            /// </devdoc>
            void IDisposable.Dispose() {
                Close();
            }
        }

        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext"]' />
        /// <devdoc>
        ///     Abstraction around the registry itself.
        /// </devdoc>
        public abstract class RegistrationContext {
            
            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.ComponentPath"]' />
            /// <devdoc>
            ///     The path to the compnent that is being registered.  You should always use this rather than the 
            ///     codebase of the component type, and you should never assume that this is a physical path on
            ///     disk.  It may be a token that identifies the path at install time.  The "component"
            ///     is the type that the registration attribute was found on.
            /// </devdoc>
            public abstract string ComponentPath { get; }

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RegisteringType"]' />
            /// <devdoc>
            ///     The type of the component that is being registered.
            /// </devdoc>
            public abstract Type ComponentType { get; }

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.InprocServerPath"]' />
            /// <devdoc>
            ///     The path to the COM object supplying the class factory.
            /// </devdoc>
            public abstract string InprocServerPath { get;}

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.CodeBase"]' />
            /// <devdoc>
            ///     The path to the object being registered (including filename).
            /// </devdoc>
            public abstract string CodeBase { get;}

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RootFolder"]' />
            /// <devdoc>
            ///     The path to the installation for the host application (e.g. Visual Studio "C:\Program Files\Microsoft Visual Studio <version>\").
            /// </devdoc>
            public abstract string RootFolder { get; }

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RegistrationMethod"]' />
            /// <devdoc>
            /// Specify if the assembly should be located using CodeBase or Assembly
            /// </devdoc>
            public abstract RegistrationMethod RegistrationMethod{get;}

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.Log"]' />
            /// <devdoc>
            ///     Returns a text writer that can be used to log registration information.  This should 
            ///     be a human readable (and ideally localized) bit of text that describes the
            ///     current registration process.
            /// </devdoc>
            public abstract TextWriter Log { get; }

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.CreateKey"]' />
            /// <devdoc>
            ///     Creates a new key of the given name.  The key is created at the appropriate registration
            ///     point in the registry.  Always close or dispose this key when finished with it.
            /// </devdoc>
            public abstract Key CreateKey(string name);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RemoveKey"]' />
            /// <devdoc>
            /// Removes the key of the given name.
            /// </devdoc>
            public abstract void RemoveKey(string name);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RemoveValue"]' />
            /// <devdoc>
            /// Removes the value of the given name under the key of the given keyname
            /// </devdoc>
            public abstract void RemoveValue(string keyname, string valuename);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RemoveKey"]' />
            /// <devdoc>
            /// Removes the key of the given name if it has no child key and
            /// no value.
            /// </devdoc>
            public abstract void RemoveKeyIfEmpty(string name);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.EscapePath"]' />
            /// <devdoc>
            /// Escape the string if needed
            /// This is used by the implementation of the Register method on attributes so that paths be escaped when
            /// needed. The attribute itself does not know if we are writting to a .reg file or directly to the registry.
            /// </devdoc>
            public abstract string EscapePath(string str);
        }

        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="GetPackageRegKeyPath"]' />
        /// <devdoc>
        ///     Returns the registry path (relative to this AppID's registry root) where the
        ///     registration for the given package is located.
        /// </devdoc>
        protected string GetPackageRegKeyPath(Guid package) {
            return string.Format(CultureInfo.InvariantCulture, "Packages\\{0}", package.ToString("B"));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\RegisterExtenderAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <summary>
    ///     This attribute registers the package as an extender.  The GUID passed in determines
    ///     what is being extended. The attributes on a package do not control the behavior of
    ///     the package, but they can be used by registration tools to register the proper
    ///     information with Visual Studio.
    /// </summary>
    [Obsolete("RegisterExtenderAttribute has been deprecated. Please use ProvideExtenderAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterExtenderAttribute : RegistrationAttribute {

        private Guid CATID = Guid.Empty;
        private Guid extender = Guid.Empty;
        private string name;

        /// <summary>
        ///     Creates a new RegisterExtenderAttribute.
        /// </summary>
        /// <param name="extendeeCatId">CatId of the element you want to extend.</param>
        /// <param name="extenderGuid">GUID of the extender.</param>
        /// <param name="extenderName">Name of the element you want to extend.</param>
        public RegisterExtenderAttribute(string extendeeCatId, string extenderGuid, string extenderName) 
        {
            CATID = new Guid(extendeeCatId);
            extender = new Guid(extenderGuid);
            name = extenderName;
        }

        /// <summary>
        /// The CatID of the element being extended.
        /// </summary>
        public Guid ExtendeeCatId {
            get {
                return CATID;
            }
        }

        /// <summary>
        /// The Guid of the extender.
        /// </summary>
        public Guid Extender {
            get {
                return extender;
            }
        }

        /// <summary>
        /// The name of the extender.
        /// </summary>
        public string ExtenderName {
            get {
                return name ;
            }
        }

        /// <summary>
        ///        The reg key name of this Extender.
        /// </summary>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "Extenders\\{0}\\{1}", CATID.ToString("B"), name);
            }
        }

        /// <summary>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration information should be placed.
        ///     it also contains such as the type being registered, and path information.
        /// </summary>
        public override void Register(RegistrationContext context) 
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyExtender, name, CATID.ToString("B")));

            using (Key childKey = context.CreateKey(RegKeyName))
            {
                // Set default value for the Key = Extender GUID
                childKey.SetValue(string.Empty, extender.ToString("B"));
            }
        }

        /// <summary>
        /// Unregister this Extender specification.
        /// </summary>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\RegisterLoadKeyAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterLoadKeyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute"]' />
    /// <devdoc>
    ///     This attribute registers a package load key for your package.  
    ///     Package load keys are used by Visual Studio to validate that 
    ///     a package can be loaded.    
    /// </devdoc>
    [Obsolete("RegisterLoadKeyAttribute has been deprecated. Please use ProvideLoadKeyAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, Inherited=false, AllowMultiple=false)]
    public sealed class RegisterLoadKeyAttribute : RegistrationAttribute {

        private string _minimumEdition;
        private string _productVersion;
        private string _productName;
        private string _companyName;
        private short  _resourceId;
    
        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.RegisterLoadKeyAttribute"]/*' />
        public RegisterLoadKeyAttribute (string minimumEdition, string productVersion, string productName, string companyName, short resourceId) {
            if (minimumEdition == null) {
                throw new ArgumentNullException("minimumEdition");
            }
            if (productVersion == null) {
                throw new ArgumentNullException("productVersion");
            }
            if (productName == null) {
                throw new ArgumentNullException("productName");
            }
            if (companyName == null) {
                throw new ArgumentNullException("companyName");
            }
            
            _minimumEdition = minimumEdition;
            _productVersion = productVersion;
            _productName = productName;
            _companyName = companyName;
            _resourceId = resourceId;
        }
        
        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.MinEdition"]' />
        /// <devdoc>
        ///     Minimum edition of Visual Studio on which
        ///     VSPackage is loaded. This must be the literal 
        ///     edition value provided by Microsoft when 
        ///     obtaining your PLK.
        /// </devdoc>
        public string MinimumEdition {
            get {
                return _minimumEdition;
            }
        }

        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.ProductVersion"]' />
        /// <devdoc>
        ///     Version of the product that this VSPackage
        ///     implements.
        /// </devdoc>
        public string ProductVersion {
            get {
                return _productVersion;
            }
        }
        
        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.ProductName"]' />
        /// <devdoc>
        ///     Name of the product that this VSPackage 
        ///     delivers. Note that one product might be
        ///     comprised of multiple VSPackages, in which 
        ///     case each will need its own PLK.
        /// </devdoc>
        public string ProductName {
            get {
                return _productName;
            }
        }

        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.CompanyName"]' />
        /// <devdoc>
        ///     VSIP Partner/creator of the VSPackage. 
        ///     The literal name (case-sensitive) provided 
        ///     to Microsoft when registering for a PLK.
        /// </devdoc>
        public string CompanyName {
            get {
                return _companyName;
            }
        }
        
        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.ResourceId"]' />
        /// <devdoc>
        ///     Resource ID for VSPackage load key.
        /// </devdoc>
        public short ResourceId {
            get {
                return _resourceId;
            }
        }

        /// <summary>
        /// Registry Key name for this package's load key information.
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        public string RegKeyName (RegistrationContext context)
        {
            return string.Format(CultureInfo.InvariantCulture, "Packages\\{0}", context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLoadKey, CompanyName, ProductName, ProductVersion, MinimumEdition));

            using (Key packageKey = context.CreateKey(RegKeyName(context)))
            {
                packageKey.SetValue("ID", ResourceId);
                packageKey.SetValue("MinEdition", MinimumEdition);
                packageKey.SetValue("ProductVersion", ProductVersion);
                packageKey.SetValue("ProductName", ProductName);
                packageKey.SetValue("CompanyName", CompanyName);
            }
        }

        /// <summary>
        /// Unregisters this package's load key information
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName(context));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\TaskCategory.cs ===
//------------------------------------------------------------------------------
// <copyright file="TaskCategory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory"]' />
    /// <devdoc>
    ///     This class implements IVsTask.  It provides a 
    ///     framework-friendly way to define a package and its associated 
    ///     services.
    /// </devdoc>
    public enum TaskCategory {
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.All"]/*' />
        All = VSTASKCATEGORY.CAT_ALL,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.BuildCompile"]/*' />
        BuildCompile = VSTASKCATEGORY.CAT_BUILDCOMPILE,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.Comments"]/*' />
        Comments = VSTASKCATEGORY.CAT_COMMENTS,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.CodeSense"]/*' />
        CodeSense = VSTASKCATEGORY.CAT_CODESENSE,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.ShortCuts"]/*' />
        ShortCuts = VSTASKCATEGORY.CAT_SHORTCUTS,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.User"]/*' />
        User = VSTASKCATEGORY.CAT_USER,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.Misc"]/*' />
        Misc = VSTASKCATEGORY.CAT_MISC,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.Html"]/*' />
        Html = VSTASKCATEGORY.CAT_HTML
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\TaskErrorCategory.cs ===
//------------------------------------------------------------------------------
// <copyright file="TaskErrorCategory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\TaskErrorCategory.uex' path='docs/doc[@for="TaskErrorCategory"]' />
    /// <devdoc>
    /// </devdoc>
    public enum TaskErrorCategory {
        /// <include file='doc\TaskErrorCategory.uex' path='docs/doc[@for="TaskErrorCategory.Error"]' />
        Error = __VSERRORCATEGORY.EC_ERROR,
        /// <include file='doc\TaskErrorCategory.uex' path='docs/doc[@for="TaskErrorCategory.Warning"]' />
        Warning = __VSERRORCATEGORY.EC_WARNING,
        /// <include file='doc\TaskErrorCategory.uex' path='docs/doc[@for="TaskErrorCategory.Message"]' />
        Message = __VSERRORCATEGORY.EC_MESSAGE
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\TaskPriority.cs ===
//------------------------------------------------------------------------------
// <copyright file="TaskPriority.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\TaskPriority.uex' path='docs/doc[@for="TaskPriority"]' />
    /// <devdoc>
    ///     This class implements IVsTask.  It provides a 
    ///     framework-friendly way to define a package and its associated 
    ///     services.
    /// </devdoc>
    public enum TaskPriority {
    	/// <include file='doc\TaskPriority.uex' path='docs/doc[@for="TaskPriority.High"]/*' />
    	High = VSTASKPRIORITY.TP_HIGH,
    	/// <include file='doc\TaskPriority.uex' path='docs/doc[@for="TaskPriority.Normal"]/*' />
    	Normal = VSTASKPRIORITY.TP_NORMAL,
    	/// <include file='doc\TaskPriority.uex' path='docs/doc[@for="TaskPriority.Low"]/*' />
    	Low = VSTASKPRIORITY.TP_LOW
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\RunningDocumentTable.cs ===
//--------------------------------------------------------------------------
//  <copyright file="RunningDocumentTable.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Collections;
using System.Xml;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using Microsoft.VisualStudio.Shell;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;

namespace Microsoft.VisualStudio.Shell {

    public class RunningDocumentTable : IEnumerable<RunningDocumentInfo> {
        IServiceProvider site;
        IVsRunningDocumentTable rdt;

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.RunningDocumentTable"]/*' />
        public RunningDocumentTable(IServiceProvider site) {
            this.site = site;
            this.rdt = site.GetService(typeof(SVsRunningDocumentTable)) as IVsRunningDocumentTable;
            if (this.rdt == null){
                throw new System.NotSupportedException(typeof(SVsRunningDocumentTable).FullName);
            }
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.FindDocument"]/*' />
        public object FindDocument(string moniker) {
            IVsHierarchy hierarchy;
            uint itemid;
            uint docCookie;
            return FindDocument(moniker, out hierarchy, out itemid, out docCookie);
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.FindDocument1"]/*' />
        [CLSCompliant(false)]
        public object FindDocument(string moniker, out uint docCookie) {
            IVsHierarchy hierarchy;
            uint itemid;
            return FindDocument(moniker, out hierarchy, out itemid, out docCookie);
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.FindDocument2"]/*' />
        [CLSCompliant(false)]
        public object FindDocument(string moniker, out IVsHierarchy hierarchy, out uint itemid, out uint docCookie){
            itemid = 0;
            hierarchy = null;
            docCookie = 0;
            if (this.rdt == null) return null;
            IntPtr docData = IntPtr.Zero;
            NativeMethods.ThrowOnFailure(rdt.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, moniker, out hierarchy, out itemid, out docData, out docCookie));
            if (docData == IntPtr.Zero) return null;
            try {
                return Marshal.GetObjectForIUnknown(docData);
            } finally {
                Marshal.Release(docData);
            }
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.GetHierarchyItem"]/*' />
        [CLSCompliant(false)]
        public IVsHierarchy GetHierarchyItem(string moniker) {                      
            uint docCookie;
            uint itemid;
            IVsHierarchy hierarchy;
            object docData = this.FindDocument(moniker, out hierarchy, out itemid, out docCookie);
            return hierarchy;
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.GetRunningDocumentContents"]/*' />
        /// Return the document contents if it is loaded, otherwise return null.
        public string GetRunningDocumentContents(string path) {
            object docDataObj = this.FindDocument(path);
            if (docDataObj != null) {
                return GetBufferContents(docDataObj);
            }
            return null;
        }

        private static string GetBufferContents(object docDataObj) {
            string text = null;
            IVsTextLines buffer = null;
            if (docDataObj is IVsTextLines) {
                buffer = (IVsTextLines)docDataObj;
            } else if (docDataObj is IVsTextBufferProvider) {
                IVsTextBufferProvider tp = (IVsTextBufferProvider)docDataObj;
                if (tp.GetTextBuffer(out buffer) != NativeMethods.S_OK)
                    buffer = null;
            }
            if (buffer != null) {
                int endLine, endIndex;
                NativeMethods.ThrowOnFailure(buffer.GetLastLineIndex(out endLine, out endIndex));
                NativeMethods.ThrowOnFailure(buffer.GetLineText(0, 0, endLine, endIndex, out text));
                buffer = null;
            }
            return text;
        }

        [CLSCompliant(false)]
        public string GetRunningDocumentContents(uint docCookie) {
            uint flags, readLocks, editLocks, itemid;
            string moniker;
            IVsHierarchy hierarchy;
            IntPtr docData;
            int hr = this.rdt.GetDocumentInfo(docCookie, out flags, out readLocks, out editLocks, out moniker, out hierarchy, out itemid, out docData);
            if (hr == VSConstants.S_OK && docData != IntPtr.Zero) {
                try {
                    object data = Marshal.GetObjectForIUnknown(docData);
                    return GetBufferContents(data);
                } finally {
                    Marshal.Release(docData);
                }
            }
            return "";
        }

        [CLSCompliant(false)]
        public RunningDocumentInfo GetDocumentInfo(uint docCookie) {
            RunningDocumentInfo info = new RunningDocumentInfo();
            info.DocCookie = docCookie;

            IntPtr docData;
            int hr = this.rdt.GetDocumentInfo(docCookie, out info.Flags,
                out info.ReadLocks, out info.EditLocks, out info.Moniker,
                out info.Hierarchy, out info.ItemId, out docData);
            if (hr == VSConstants.S_OK) {
                try {
                    if (docData != IntPtr.Zero)
                        info.DocData = Marshal.GetObjectForIUnknown(docData);
                    return info;
                } finally {
                    Marshal.Release(docData);
                }
            }
            return info;
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="VsShell.SaveFileIfDirty"]/*' />
        public string SaveFileIfDirty(string fullPath) {
            object docData = this.FindDocument(fullPath);
            if (docData is IVsPersistDocData2) {
                IVsPersistDocData2 pdd = (IVsPersistDocData2)docData;
                int dirty = 0;
                int hr = pdd.IsDocDataDirty(out dirty);
                if (NativeMethods.Succeeded(hr) && dirty != 0) {
                    string newdoc;
                    int cancelled;
                    NativeMethods.ThrowOnFailure(pdd.SaveDocData(VSSAVEFLAGS.VSSAVE_Save, out newdoc, out cancelled));
                    return newdoc;
                }
            }
            return fullPath;
        }

        [CLSCompliant(false)]
        public void RenameDocument(string oldName, string newName, IVsHierarchy pIVsHierarchy, uint itemId){
            IntPtr pUnk = Marshal.GetIUnknownForObject(pIVsHierarchy);
            if (pUnk != IntPtr.Zero) {
                try {
                    IntPtr pHier = IntPtr.Zero;
                    Guid guid = typeof(IVsHierarchy).GUID;
                    NativeMethods.ThrowOnFailure(Marshal.QueryInterface(pUnk, ref guid, out pHier));
                    try {
                        NativeMethods.ThrowOnFailure(this.rdt.RenameDocument(oldName, newName, pHier, itemId));
                    } finally {
                        Marshal.Release(pHier);
                    }
                } finally {
                    Marshal.Release(pUnk);
                }
            }
        }

        [CLSCompliant(false)]
        public uint Advise(IVsRunningDocTableEvents sink) {
            uint cookie;
            NativeMethods.ThrowOnFailure(this.rdt.AdviseRunningDocTableEvents(sink, out cookie));
            return cookie;
        }

        [CLSCompliant(false)]
        public void Unadvise(uint cookie) {
            NativeMethods.ThrowOnFailure(this.rdt.UnadviseRunningDocTableEvents(cookie));
        }

        [CLSCompliant(false)]
        public uint RegisterAndLockDocument(_VSRDTFLAGS lockType, string mkDocument, IVsHierarchy hierarchy, uint itemid, IntPtr docData) {
            uint cookie;
            NativeMethods.ThrowOnFailure(rdt.RegisterAndLockDocument((uint)lockType, mkDocument, hierarchy, itemid, docData, out cookie));
            return cookie;           
        }

        [CLSCompliant(false)]
        public void LockDocument(_VSRDTFLAGS lockType, uint cookie) {
            NativeMethods.ThrowOnFailure(rdt.LockDocument((uint)lockType, cookie));
        }

        [CLSCompliant(false)]
        public void UnlockDocument(_VSRDTFLAGS lockType, uint cookie) {
            NativeMethods.ThrowOnFailure(rdt.UnlockDocument((uint)lockType, cookie));
        }

        // Enumerate the running documents
        public IEnumerator<RunningDocumentInfo> GetEnumerator() {
            IList<RunningDocumentInfo> list = new List<RunningDocumentInfo>();
            IEnumRunningDocuments ppenum;
            if (NativeMethods.Succeeded(rdt.GetRunningDocumentsEnum(out ppenum))) {
                uint[] rgelt = new uint[1];
                uint fetched = 0;
                while (true) {
                    if (NativeMethods.Succeeded(ppenum.Next(1, rgelt, out fetched)) && fetched == 1) {
                        list.Add(GetDocumentInfo(rgelt[0]));
                    } else {
                        break;
                    }
                }
            }
            return list.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }
    }

    [CLSCompliant(false)]
    public struct RunningDocumentInfo {
        public uint DocCookie;
        public uint Flags;
        public uint ReadLocks;
        public uint EditLocks;
        public IVsHierarchy Hierarchy;
        public uint ItemId;
        public string Moniker;
        public object DocData;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\SelectionContainer.cs ===
namespace Microsoft.VisualStudio.Shell
{
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    using ISelectionContainer = Microsoft.VisualStudio.Shell.Interop.ISelectionContainer;

    /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer"]/*' />
    /// <devdoc>
    /// This class implements the ISelectionContainer interface. It can be used to show
    /// informations on the property window.
    /// </devdoc>
    [CLSCompliant(false)]
    public class SelectionContainer : 
        ISelectionContainer
    {
        private ICollection     _selectableObjects;
        private ICollection     _selectedObjects;
        private readonly bool   _selectableReadOnly;
        private readonly bool   _selectedReadOnly;

        private static ICollection _emptyCollection = new Object[0];

        // Constants for selection container flags.
        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ALL"]/*' />
        public const uint ALL = 0x1;
        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SELECTED"]/*' />
        public const uint SELECTED = 0x2;

        private const int SELOBJ_ACTIVATE_WINDOW = 0x1;


        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectionContainer"]/*' />
        /// <devdoc>
        /// Creates a container with empty collections of selected and selectable objects.
        /// </devdoc>
        public SelectionContainer()
        {
            _selectableObjects = _emptyCollection;
            _selectedObjects = _emptyCollection;
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectionContainer1"]/*' />
        /// <devdoc>
        /// Creates a selection container with empty collections of selected and selectable objects.
        /// </devdoc>
        /// <param name="selectableReadOnly">Specifies if the collection of the selectable objects is read only.</param>
        /// <param name="selectedReadOnly">Specifies if the selection is read only.</param>
        public SelectionContainer(bool selectableReadOnly, bool selectedReadOnly) : this()
        {
            _selectableReadOnly = selectableReadOnly;
            _selectedReadOnly = selectedReadOnly;
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectableObjects"]/*' />
        /// <devdoc>
        /// Get or set the collection of the selectable objects
        /// </devdoc>
        public ICollection SelectableObjects
        {
            get
            {
                return _selectableObjects;
            }
            set
            {
                if (value == null)
                {
                    value = _emptyCollection;
                }
                _selectableObjects = value;
            }
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectedObjects"]/*' />
        /// <devdoc>
        /// Get or set the collection of the selected objects.
        /// </devdoc>
        public ICollection SelectedObjects
        {
            get
            {
                return _selectedObjects;
            }
            set
            {
                if (value == null)
                {
                    value = _emptyCollection;
                }
                _selectedObjects = value;
            }
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectedObjectsChanged"]/*' />
        /// <devdoc>
        /// This event is fired when the selection changes.
        /// </devdoc>
        public event EventHandler SelectedObjectsChanged;

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ActivateObjects"]/*' />
        /// <devdoc>
        /// Activates the selected objects. Its default implementation is empty.
        /// </devdoc>
        protected virtual void ActivateObjects()
        {
            // This default implementation of this function is empty.
        }

        // Helper function to change the selected objects
        private void ChangeSelection(object[] prgUnkObjects, int dwFlags)
        {
            // Check if it is possible to change the selection.
            if (_selectedReadOnly) throw new InvalidOperationException();
            // Store the array of selected object in the internal array
            SelectedObjects = prgUnkObjects;
            // Raise the "Selected objects changed" event.
            if (SelectedObjectsChanged != null) SelectedObjectsChanged(this, EventArgs.Empty);
            // Check if the objects need to be activated
            if ( (dwFlags & SELOBJ_ACTIVATE_WINDOW) != 0 )
            {
                ActivateObjects();
            }
        }

   
    
#region ISelectionContainer Members

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ISelectionContainer.CountObjects"]/*' />
        /// <internalonly/>
        int ISelectionContainer.CountObjects(uint dwFlags, out uint pc)
        {
            switch (dwFlags)
            {
                case ALL:
                    pc = (uint)SelectableObjects.Count;
                    break;

                case SELECTED:
                    pc = (uint)SelectedObjects.Count;
                    break;

                default:
                    throw new ArgumentException(string.Format(Resources.Culture, Resources.General_UnsupportedValue, dwFlags), "dwFlags");
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ISelectionContainer.GetObjects"]/*' />
        /// <internalonly/>
        int ISelectionContainer.GetObjects(uint dwFlags, uint cObjects, object[] apUnkObjects)
        {
            ICollection objects = null;

            switch (dwFlags)
            {
                case ALL:
                    objects = SelectableObjects;
                    break;

                case SELECTED:
                    objects = SelectedObjects;
                    break;

                default:
                    throw new ArgumentException(string.Format(Resources.Culture, Resources.General_UnsupportedValue, dwFlags), "dwFlags");
            }

            int idx = 0;
            foreach (object obj in objects)
            {
                if (idx >= cObjects || idx >= apUnkObjects.Length)
                {
                    break;
                }
                apUnkObjects[idx++] = obj;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ISelectionContainer.SelectObjects"]/*' />
        /// <internalonly/>
        int ISelectionContainer.SelectObjects(uint cSelect, object[] apUnkSelect, uint dwFlags)
        {
            ChangeSelection(apUnkSelect, (int)dwFlags);
            return NativeMethods.S_OK;
        }

#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ServiceProvider.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Threading;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider"]' />
    /// <devdoc>
    ///     This class acts as a bridge between Microsoft.VisualStudio.OLE.Interop.IServiceProvider 
    ///     and System.IServiceProvider.  It implements System.IServiceProvider and takes 
    ///     as a constructor argument an instance of Microsoft.VisualStudio.OLE.Interop.IServiceProvider.  
    ///     It supports both GUID and type based lookups and also has debug code to assert 
    ///     for common native implementation pitfalls, like not implementing IUnknown on 
    ///     an object or requiring a specific IID along with a matching SID.
    /// </devdoc>
    [CLSCompliant(false)]
	[System.Runtime.InteropServices.ComVisible(true)]
    public sealed class ServiceProvider : IServiceProvider, IDisposable, IObjectWithSite {
        
        private static TraceSwitch TRACESERVICE = new TraceSwitch("TRACESERVICE", "ServiceProvider: Trace service provider requests.");

        private IOleServiceProvider    serviceProvider;
        private bool                   defaultServices;

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.ServiceProvider"]' />
        /// <devdoc>
        ///     Creates a new ServiceProvider object and uses the given interface to resolve
        ///     services.
        /// </devdoc>
        public ServiceProvider(IOleServiceProvider sp) : this(sp, true){
        }
        
        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.ServiceProvider1"]' />
        /// <devdoc>
        ///     Creates a new ServiceProvider object and uses the given interface to resolve
        ///     services.  If defaultServices is true (the default) this service  provider will
        ///     respond to Microsoft.VisualStudio.OLE.Interop.IServiceProvider and IObjectWithSite
        ///     as services.  A query for Microsoft.VisualStudio.OLE.Interop.IServiceProvider will
        ///     return the underlying COM service provider and a query for IObjectWithSite will
        ///     return this object.  If false is passed into defaultServices these two services
        ///     will not be provided and the service provider will be "transparent".
        /// </devdoc>
        public ServiceProvider(IOleServiceProvider sp, bool defaultServices) {
            if (sp == null) {
                throw new ArgumentNullException("sp");
            }
            this.serviceProvider = sp;
            this.defaultServices = defaultServices;
        }

        /// <devdoc>
        ///     Private, default constructor used to create a dummy ServiceProvider with
        ///     no underlying services.
        /// </devdoc>
        private ServiceProvider() {
        }
        
        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.Dispose"]' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dispose() {
            if (serviceProvider != null) {
                serviceProvider = null;
            }
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.GetService"]' />
        /// <devdoc>
        ///     Retrieves the requested service.
        /// </devdoc>
        public object GetService(Type serviceType) {

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            // If we have already been disposed, disallow all service
            // requests.
            //
            if (serviceProvider == null) {
                return null;
            }
            
            // First, can we resolve this service class into a GUID?  If not, then
            // we have nothing to pass.
            //
            Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Resolving service '" + serviceType.FullName + " through the service provider " + serviceProvider.ToString() + ".");
            return GetService(serviceType.GUID, serviceType);
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.GetService1"]' />
        /// <devdoc>
        ///     Retrieves the requested service.
        /// </devdoc>
        public object GetService(Guid guid) {
            // If we have already been disposed, disallow all service
            // requests.
            //
            if (serviceProvider == null) {
                return null;
            }
            return GetService(guid, null);
        }

        /// <devdoc>
        ///     Retrieves the requested service.  The guid must be specified; the class is only
        ///     used when debugging and it may be null.
        /// </devdoc>
        private object GetService(Guid guid, Type serviceType) {
            object service = null;

            // No valid guid on the passed in class, so there is no service for it.
            //
            if (guid.Equals(Guid.Empty)) {
                Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "\tNo SID -- Guid is empty");
                return null;
            }

            // We provide a couple of services of our own.
            //
            if (defaultServices) {
                if (guid.Equals(NativeMethods.IID_IServiceProvider)) {
                    return serviceProvider;
                }
                if (guid.Equals(NativeMethods.IID_IObjectWithSite)) {
                    return (IObjectWithSite)this;
                }
            }

            IntPtr pUnk = IntPtr.Zero;
            Guid guidUnk = NativeMethods.IID_IUnknown;
            int hr = serviceProvider.QueryService(ref guid, ref guidUnk, out pUnk);

            if ( (NativeMethods.Succeeded(hr)) && (IntPtr.Zero != pUnk) ) {
                try {
                    service = Marshal.GetObjectForIUnknown(pUnk);
                }
                finally {
                    Marshal.Release(pUnk);
                }
            }
            else {
                service = null;

                // These may be interesting to log.
                //
                Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "\tQueryService failed");

                #if DEBUG
                // Ensure that this service failure was not the result of a bad QI implementation.
                // In C++, 99% of a service query uses SID == IID, but for us, we always use IID = IUnknown
                // first.  If the service didn't implement IUnknown correctly, we'll fail the service request
                // and it's very difficult to track this down. 
                //
                pUnk = IntPtr.Zero;
                hr = serviceProvider.QueryService(ref guid, ref guid, out pUnk);

                if ( (NativeMethods.Succeeded(hr)) && (IntPtr.Zero != pUnk) ) {
                    object obj = null;
                    try {
                        obj = Marshal.GetObjectForIUnknown(pUnk);
                    }
                    finally {
                        Marshal.Release(pUnk);
                    }

                    // Note that I do not return this service if we succeed -- I don't
                    // want to make debug work correctly when retail doesn't!
                    Debug.Assert(!System.Runtime.InteropServices.Marshal.IsComObject(obj),
                                 "The service " + (serviceType != null ? serviceType.Name : guid.ToString()) +
                                 " implements it's own interface, but does not implement IUnknown!\r\n" +
                                 "This is a bad service implementation, not a problem in the CLR service provider mechanism." + obj.ToString());
                }

                #endif
            }

            return service;
        }

        internal TInterfaceType GetService<TInterfaceType>(Type serviceType) where TInterfaceType : class
        {
            TInterfaceType service = GetService(serviceType) as TInterfaceType;
            if (service == null)
            {
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.General_MissingService, serviceType.FullName));
            }
            return service;
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.IObjectWithSite.GetSite"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the current site object we're using to
        /// resolve services.
        /// </devdoc>
        void IObjectWithSite.GetSite(ref Guid riid, out IntPtr ppv) {
            object o = GetService(riid);
            if (o == null) {
                Marshal.ThrowExceptionForHR(NativeMethods.E_NOINTERFACE);
            }

            IntPtr punk = Marshal.GetIUnknownForObject(o);
            int hr = Marshal.QueryInterface(punk, ref riid, out ppv);
            Marshal.Release(punk);
            if (NativeMethods.Failed(hr)) {
                Marshal.ThrowExceptionForHR(hr);
            }
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.IObjectWithSite.SetSite"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Sets the site object we will be using to resolve services.
        /// </devdoc>
        void IObjectWithSite.SetSite(object pUnkSite) {
            if (pUnkSite is IOleServiceProvider) {
                serviceProvider = (IOleServiceProvider)pUnkSite;
            }
        }

        /// <devdoc>
        ///     The global service provider.
        ///     Note that this is not a ThreadStatic field. Once a non-empty
        ///     global service provider has been created, it will act as the
        ///     proxy for all other threads.
        /// <devdoc>
        static ServiceProvider globalProvider;

        /// <summary>
        ///     The thread which set globalProvider
        /// </summary>
        static Thread threadOwningGlobalProvider;

        static void SetGlobalProvider(ServiceProvider sp)
        {
            globalProvider = sp;
            threadOwningGlobalProvider = Thread.CurrentThread;
        }

        /// <summary>
        ///     Is the calling thread the same as the thread which set the
        ///     global provider.
        /// </summary>
        /// <returns></returns>
        internal static bool CheckServiceProviderThreadAccess()
        {
            return threadOwningGlobalProvider == Thread.CurrentThread;
        }

        /// <devdoc>
        ///     Determines if the given ServiceProvider is uninitialized
        /// </devdoc>
        static bool IsNullOrUnsited(ServiceProvider sp)
        {
            return sp == null || sp.serviceProvider == null;
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.GlobalProvider"]' />
        /// <devdoc>
        /// Get the global service provider for the calling thread. The global
        /// service provider is set by calling ServiceProvider.CreateFromSetSite.
        /// If ServiceProvider.CreateFromSetSite has not been called, an attempt
        /// is made to retrieve the a service provider from the OLE message filter.
        /// If no suitable service provider can be found on the calling thread, then
        /// a new, empty ServiceProvider is returned.
        /// </devdoc>
        public static ServiceProvider GlobalProvider
        {
            get
            {
                if (IsNullOrUnsited(globalProvider))
                {
                    IOleServiceProvider oleProvider = OleServiceProvider.GlobalProvider;
                    if (oleProvider != null)
                    {
                        Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Initializing ServiceProvider.GlobalProvider from OLE message filter.");
                        SetGlobalProvider(new ServiceProvider(oleProvider));
                    }
                    else if(globalProvider == null)
                    {
                        Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Creating a dummy global ServiceProvider because OleServiceProvider.GlobalProvider is unavailable for this thread.");
                        SetGlobalProvider(new ServiceProvider());
                    }
                }
                return globalProvider;
            }
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.CreateFromSetSite"]' />
        /// <devdoc>
        /// Create a new ServiceProvider for the given site.
        /// Should be called from an object that implements SetSite
        /// (IObjectWithSite or IVsPackage). Automatically sets the global
        /// service provider if it hasn't already been set.
        /// This method is typically called from the SetSite method of a
        /// Visual Studio package.
        /// Note: By calling this method, the caller declares that it knows
        /// the global OLE service provider for the calling thread and that
        /// the ServiceProvider instance returned may be used by other,
        /// unrelated components, accessed via the ServiceProvider.GlobalProvider
        /// static property.
        /// </devdoc>
        public static ServiceProvider CreateFromSetSite(IOleServiceProvider sp)
        {
            ServiceProvider provider = new ServiceProvider(sp);

            // If there is no current global service provider or the existing
            // one is unsited, then set it here.
            if (IsNullOrUnsited(globalProvider))
            {
                Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Initializing ServiceProvider.GlobalProvider from SetSite.");
                SetGlobalProvider(provider);
            }

            return provider;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Task.cs ===
//------------------------------------------------------------------------------
// <copyright file="Task.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\Task.uex' path='docs/doc[@for="Task"]' />
    /// <devdoc>
    ///     This class implements IVsTaskItem.  
    /// </devdoc>
    [ComVisible(true)]
    [CLSCompliant(false)]
    public class Task :

        IVsTaskItem,
        IVsProvideUserContext
    {
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.contextNameKeyword"]/*' />
        public const string contextNameKeyword = "Keyword";

        private TaskProvider owner;
        private bool canDelete;
        private bool checkedEditable;
        private bool priorityEditable;
        private bool textEditable;
        private TaskPriority priority;
        private TaskCategory category;
        private int          subCategoryIndex;
        private string       text; 
        private string       document;
        private string       caption;
        private string       helpKeyword;
        private int          line;
        private int          imageIndex;
        private int          column;
        private bool         isChecked;
        private IVsUserContext context = null;

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Task"]/*' />
        public Task() {
            priority = TaskPriority.Normal;
            subCategoryIndex = -1;
            // Initializing the imageIndex to -1 tells VS to not expect to get
            // an imageList from us either, and instead use the default images.
            // This fixes bug 172354.
            imageIndex = -1;
            line = -1;
            column = -1;
            text = string.Empty;
            helpKeyword = string.Empty;
            document = string.Empty;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Task1"]/*' />
        public Task(Exception error) : this() {
    
            // Now use the exception to fill in the 
            // task data.
            if (error == null) {
                throw new ArgumentNullException("error");
            }

            Text = error.Message;
            HelpKeyword = error.HelpLink;

            if (Text.Length == 0) {
                Text = error.ToString();
            }

            // UNDONE: How do we generate this info for non-code thingies?  This must be
            // generic, or at least extensible.

            while(error != null) {
                System.ComponentModel.Design.Serialization.CodeDomSerializerException cdex;
                System.Xml.XmlException xmlex;
                 
                if ((cdex = error as System.ComponentModel.Design.Serialization.CodeDomSerializerException) != null) {
                    System.CodeDom.CodeLinePragma lp = cdex.LinePragma;
                    if (lp != null) {
                        Document = lp.FileName;
                        Line = lp.LineNumber;
                    }
                    break;
                }
                else if ((xmlex = error as System.Xml.XmlException) != null) {
                    Line = xmlex.LineNumber - 1;
                    break;
                }
                error = error.InnerException;
            }
        }


        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.CanDelete"]/*' />
        public bool CanDelete {
            get {
                return canDelete;
            }
            set {
                if (canDelete != value) {
                    canDelete = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Category"]/*' />
        public TaskCategory Category {
            get {
                return category; 
            }
            set {
                if (category != value) {
                    category = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Checked"]/*' />
        public bool Checked {
            get {
                return isChecked;
            }
            set {
                if (isChecked != value) {
                    isChecked = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Column"]/*' />
        public int Column {
            get {
                return column;
            }
            set {
                if (column != value) {
                    column = value;
                    UpdateOwner();
                }
            }
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Document"]/*' />
        public string Document { 
            get {
                return document;
            }
            set {
                if (value == null) {
                    value = string.Empty;
                }
                if (document != value) {
                    document = value;
                    UpdateOwner();
                }
            }
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.HelpKeyword"]/*' />
        public string HelpKeyword {
            get {
                return helpKeyword;
            }
            set {
                if (value == null) {
                    value = string.Empty;
                }

                if (helpKeyword != value) {
                    helpKeyword = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.ImageIndex"]/*' />
        public int ImageIndex {
            get {
                return imageIndex;
            }
            set {
                if (imageIndex != value) {
                    imageIndex = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IsCheckedEditable"]/*' />
        public bool IsCheckedEditable {
            get {
                return checkedEditable;
            }
            set {
                if (checkedEditable != value) {
                    checkedEditable = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IsPriorityEditable"]/*' />
        public bool IsPriorityEditable {
            get {
                return priorityEditable;
            }
            set {
                if (priorityEditable != value) {
                    priorityEditable = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IsTextEditable"]/*' />
        public bool IsTextEditable {
            get {
                return textEditable;
            }
            set {
                if (textEditable != value) {
                    textEditable = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Line"]/*' />
        public int Line {
            get {
                return line;
            }
            set {
                if (line != value) {
                    line = value;
                    UpdateOwner();
                }
            }
        }

        internal TaskProvider Owner {
            get {
                return owner;
            }
            set {
                if (owner != null && value == null) {
                    OnRemoved(EventArgs.Empty);
                }
                owner = value;
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Priority"]/*' />
        public TaskPriority Priority {
            get {
                return priority;
            }
            set {
                if (priority != value) {
                    priority = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.SubcategoryIndex"]/*' />
        public int SubcategoryIndex {
            get {
                return subCategoryIndex;
            }
            set {
                if (subCategoryIndex != value) {
                    subCategoryIndex = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Text"]/*' />
        public string Text {
            get {
                return text;
            }
            set {
                if (value == null) {
                    value = string.Empty;
                }
                if (text != value) {
                    text = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Deleted"]/*' />
        public event EventHandler Deleted;

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Removed"]/*' />
        public event EventHandler Removed;
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Help"]/*' />
        public event EventHandler Help;
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Navigate"]/*' />
        public event EventHandler Navigate;
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.OnDeleted"]/*' />
        protected virtual void OnDeleted(EventArgs e) {
            if (Deleted != null) {
                Deleted(this, e);
            }
        }
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.OnRemoved"]/*' />
        protected virtual void OnRemoved(EventArgs e) {
            if (Removed != null) {
                Removed(this, e);
            }
        }        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.OnHelp"]/*' />
        protected virtual void OnHelp(EventArgs e) {

            if (HelpKeyword.Length > 0 && owner != null) {
                IHelpService help = owner.GetService(typeof(IHelpService)) as IHelpService;
                Debug.Assert(help != null, "We can't find a help service in the service provider");
                if (help != null) {
                    help.ShowHelpFromKeyword(HelpKeyword);
                }
            }

            if (Help != null) {
                Help(this, e);
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.OnNavigate"]/*' />
        protected virtual void OnNavigate(EventArgs e) {
            if (Navigate != null) {
                Navigate(this, e);
            }
        }

        private void UpdateOwner() {
            if (owner != null) {
                owner.Refresh();
            }
        }

        private string GetDisplayName(string fileName) {
            if (owner != null) {
            IVsRunningDocumentTable pRDT = (IVsRunningDocumentTable)owner.GetService(typeof(SVsRunningDocumentTable));
            if (pRDT != null) {
                IntPtr punkDocData;
                uint docCookie;
                uint[] pitemid = new uint[1];
                IVsHierarchy ppIVsHierarchy;
                int hr = pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, fileName, out ppIVsHierarchy, out pitemid[0], out punkDocData, out docCookie);
                if (NativeMethods.Succeeded(hr) && punkDocData != IntPtr.Zero && ppIVsHierarchy != null)
                {
                    Marshal.Release(punkDocData);
                    object isNew;
                    hr = ppIVsHierarchy.GetProperty(pitemid[0], (int)__VSHPROPID.VSHPROPID_IsNewUnsavedItem, out isNew);
                    if (NativeMethods.Succeeded(hr) && (bool)isNew) {
                        object fileCaption;
                        hr = ppIVsHierarchy.GetProperty(pitemid[0], (int)__VSHPROPID.VSHPROPID_Caption, out fileCaption);
                        string caption = fileCaption as string;
                        if (NativeMethods.Succeeded(hr) && !String.IsNullOrEmpty(caption))
                        {
                            return caption;
                        }
                    }
                }
            }
            }
            return fileName;
        }

        private string GetCaption() {
            if (caption == null) {
                caption = GetDisplayName(document);
            }
            return caption;
        }

        #region IVsTaskItem

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.CanDelete"]/*' />
        /// <internalonly/>
        int IVsTaskItem.CanDelete(out int fdelete) {
            fdelete = (CanDelete) ? 1 : 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.Category"]/*' />
        /// <internalonly/>
        int IVsTaskItem.Category(VSTASKCATEGORY[] cat) {
            if (cat != null) {
                cat[0] = (VSTASKCATEGORY)(uint)Category;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.Column"]/*' />
        /// <internalonly/>
        int IVsTaskItem.Column(out int col) {
            col = Column;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.Document"]/*' />
        /// <internalonly/>
        int IVsTaskItem.Document(out string doc) {
            doc = GetCaption();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.HasHelp"]/*' />
        /// <internalonly/>
        int IVsTaskItem.HasHelp(out int fHelp) {
            fHelp = (Help != null || (HelpKeyword != null && owner!=null)) ? 1 : 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.ImageListIndex"]/*' />
        /// <internalonly/>
        int IVsTaskItem.ImageListIndex(out int index) {
            index = ImageIndex;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.IsReadOnly"]/*' />
        /// <internalonly/>
        int IVsTaskItem.IsReadOnly(VSTASKFIELD field, out int fReadOnly) {

            bool readOnly = true;

            switch(field) {
                case VSTASKFIELD.FLD_CHECKED:
                    readOnly = !IsCheckedEditable;
                    break;
                case VSTASKFIELD.FLD_PRIORITY:
                    readOnly = !IsPriorityEditable;
                    break;
                case VSTASKFIELD.FLD_DESCRIPTION:
                    readOnly = !IsTextEditable;
                    break;
            }

            fReadOnly = (readOnly) ? 1 : 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.Line"]/*' />
        /// <internalonly/>
        int IVsTaskItem.Line(out int line) {
            line = Line;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.NavigateTo"]/*' />
        /// <internalonly/>
        int IVsTaskItem.NavigateTo() {
            OnNavigate(EventArgs.Empty);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.NavigateToHelp"]/*' />
        /// <internalonly/>
        int IVsTaskItem.NavigateToHelp() {
            OnHelp(EventArgs.Empty);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.OnDeleteTask"]/*' />
        /// <internalonly/>
        int IVsTaskItem.OnDeleteTask() {
            OnDeleted(EventArgs.Empty);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.OnFilterTask"]/*' />
        /// <internalonly/>
        int IVsTaskItem.OnFilterTask(int f) {
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.SubcategoryIndex"]/*' />
        /// <internalonly/>
        int IVsTaskItem.SubcategoryIndex(out int index) {
            index = SubcategoryIndex;
            if ( index < 0 )
            {
                return NativeMethods.E_FAIL;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.get_Checked"]/*' />
        /// <internalonly/>
        int IVsTaskItem.get_Checked(out int f) {
            f = Checked ? 1 : 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.get_Priority"]/*' />
        /// <internalonly/>
        int IVsTaskItem.get_Priority(VSTASKPRIORITY[] pri) {
            if (pri != null) {
                pri[0] = (VSTASKPRIORITY)(uint)Priority;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.get_Text"]/*' />
        /// <internalonly/>
        int IVsTaskItem.get_Text(out string text) {
            text = Text;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.put_Checked"]/*' />
        /// <internalonly/>
        int IVsTaskItem.put_Checked(int f) {
            isChecked = f != 0;  // don't call property, as it will call back to the task list
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.put_Priority"]/*' />
        /// <internalonly/>
        int IVsTaskItem.put_Priority(VSTASKPRIORITY pri) {
            priority = (TaskPriority)(uint)pri;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.put_Text"]/*' />
        /// <internalonly/>
        int IVsTaskItem.put_Text(string t) {
            text = t;
            return NativeMethods.S_OK;
        }
        #endregion

        #region IVsProvideUserContext Members

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.GetUserContext"]/*' />
        public int GetUserContext(out IVsUserContext ppctx)
        {
            int hr = NativeMethods.S_OK;
            if (context == null)
            {
                // Create an empty context
                IVsMonitorUserContext monitorContext = owner.GetService(typeof(SVsMonitorUserContext)) as IVsMonitorUserContext;
                NativeMethods.ThrowOnFailure(monitorContext.CreateEmptyContext(out context));

                // Add the required information to the context
                hr = context.AddAttribute(VSUSERCONTEXTATTRIBUTEUSAGE.VSUC_Usage_LookupF1, contextNameKeyword, this.HelpKeyword);
            }
            ppctx = context;

            return hr;
        }

        #endregion
    }


    /// <include file='doc\Task.uex' path='docs/doc[@for="ErrorTask"]' />
    /// <devdoc>
    ///     This class implements IVsErrorItem.  
    /// </devdoc>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class ErrorTask : Task, IVsErrorItem {

        IVsHierarchy        item;
        TaskErrorCategory   category;

        /// <include file='doc\Task.uex' path='docs/doc[@for="ErrorTask.ErrorTask"]/*' />
        public ErrorTask() {
            category = TaskErrorCategory.Error;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="ErrorTask.ErrorTask1"]/*' />
        public ErrorTask(Exception error) : base(error) {
        }

        /// Get/Set the error category associated with this task.
        public TaskErrorCategory ErrorCategory {
            get {
                return category;
            }
            set {
                category = value;
            }
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="ErrorTask.Project"]/*' />
        /// Get/Set the hierarchy item associated with this task.
        public IVsHierarchy HierarchyItem {
            get { return this.item; }
            set { this.item = value; }
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsErrorItem.GetProject"]/*' />
        /// todo: This method will soon switch to out IVsHierarchy ppProject
        int IVsErrorItem.GetHierarchy(out IVsHierarchy ppHier) {
            ppHier = this.item;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsErrorItem.GetCategory"]/*' />
        int IVsErrorItem.GetCategory(out uint pCategory) {
            pCategory = (uint)ErrorCategory;
            return NativeMethods.S_OK;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ToolWindowPane.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolWindowPane.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;

using IDropTarget = Microsoft.VisualStudio.OLE.Interop.IDropTarget;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;

namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane"]/*' />
    /// <summary>
    /// Summary description for ToolWindowPane.
    /// </summary>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class ToolWindowPane : WindowPane
    {
        private string caption;
        private IVsWindowFrame frame = null;
        private Microsoft.VisualStudio.Shell.Package package = null;
        private CommandID toolBarCommandID = null;
        private IDropTarget toolBarDropTarget = null;
        private VSTWT_LOCATION toolBarLocation;
        private int bitmapResourceID;
        private int bitmapIndex;
        private Guid toolClsid;

        /// <summary>
        /// Creates a new tool window pane with a null parent service provider
        /// </summary>
        public ToolWindowPane()
            : base()
        {
            toolClsid = Guid.Empty;
            bitmapIndex = -1;
            bitmapResourceID = -1;
            toolBarLocation = VSTWT_LOCATION.VSTWT_TOP;
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.ToolWindowPane"]/*' />
        /// <summary>
        /// Constructor
        /// </summary>
        protected ToolWindowPane(IServiceProvider provider)
            : base(provider)
        {
            toolClsid = Guid.Empty;
            bitmapIndex = -1;
            bitmapResourceID = -1;
            toolBarLocation = VSTWT_LOCATION.VSTWT_TOP;
        }
    
        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.Caption"]/*' />
        /// <summary>
        /// Get or Set the text on the title bar of the ToolWindow
        /// </summary>
        /// <value></value>
        public string Caption
        {
            get { return caption; }
            set
            {
                caption = value;
                if (frame != null && caption != null)
                {
                    // Since the window is already created, set the coresponding property
                    int hr = NativeMethods.S_OK;
                    try {
                        hr = frame.SetProperty((int)__VSFPROPID.VSFPROPID_Caption, caption);
                    } catch (COMException e) {
                        hr = e.ErrorCode;
                    }
                    Debug.Assert(hr >= 0, "Failed to set caption on toolwindow");
                }
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.Frame"]/*' />
        /// <summary>
        /// Get or Set the Frame (IvsWindowFrame) hosting the ToolWindow
        /// </summary>
        public object Frame
        {
            get { return frame; }
            set
            {
                frame = (IVsWindowFrame)value;
                // Fire the event to let any custom creation code run
                OnToolWindowCreated();
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.Package"]/*' />
        /// <summary>
        /// Get or Set the Package (Microsoft.VisualStudio.Shell.Package) owning the ToolWindow.
        /// This should only be set by the base Package class when it creates the toolwindow.
        /// </summary>
        public object Package
        {
            get { return package; }
            set
            {
                if (frame != null || package != null)
                    throw new NotSupportedException(Resources.ToolWindow_PackageOnlySetByCreator);
                package = (Microsoft.VisualStudio.Shell.Package)value;
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.ToolBar"]/*' />
        /// <summary>
        /// If the toolwindow has a ToolBar, it is described by this parameter.
        /// Otherwise this is null
        /// </summary>
        public CommandID ToolBar
        {
            get { return toolBarCommandID; }
            set
            {
                if (frame != null)
                    throw new Exception(Resources.ToolWindow_TooLateToAddToolbar);
                toolBarCommandID = value;
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.ToolBarDropTarget"]/*' />
        /// <summary>
        /// If the toolwindow has a ToolBar, allows intercepting drag and drop operations on the toolbar.
        /// Otherwise this is null
        /// </summary>
        [CLSCompliant(false)]
        public IDropTarget ToolBarDropTarget
        {
            get { return toolBarDropTarget; }
            set
            {
                if (frame != null)
                    throw new Exception(Resources.ToolWindow_TooLateToAddToolbar);
                toolBarDropTarget = value;
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.ToolBarLocation"]/*' />
        /// <summary>
        /// Get or Set where the toolbar should be in the tool window (Up, down, left, right).
        /// This parameter is based on VSTWT_LOCATION
        /// </summary>
        public int ToolBarLocation
        {
            get { return (int)toolBarLocation; }
            set
            {
                if (frame != null)
                    throw new Exception(Resources.ToolWindow_TooLateToAddToolbar);
                toolBarLocation = (VSTWT_LOCATION)value;
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.ToolClsid"]/*' />
        /// <summary>
        /// This is used to specify the CLSID of a tool that should be used for this toolwindow
        /// </summary>
        public Guid ToolClsid
        {
            get { return toolClsid; }
            set
            {
                if (frame != null)
                    throw new Exception(Resources.ToolWindow_TooLateToAddTool);
                toolClsid = value;
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.BitmapResourceID"]/*' />
        /// <summary>
        /// Get or Set the resource ID for the bitmap strip from which to take the window frame icon
        /// </summary>
        public int BitmapResourceID
        {
            get { return bitmapResourceID; }
            set
            {
                bitmapResourceID = value;
                if (frame != null && bitmapResourceID != -1)
                {
                    int hr = NativeMethods.S_OK;
                    // Since the window is already created, set the coresponding property
                    try {
                        hr = frame.SetProperty((int)__VSFPROPID.VSFPROPID_BitmapResource, bitmapResourceID);
                    } catch (COMException e) {
                        hr = e.ErrorCode;
                    }
                    Debug.Assert(hr >= 0, "Failed to set bitmap resource on toolwindow");
                }
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.BitmapIndex"]/*' />
        /// <summary>
        /// Get or Set the index of the image to use in the bitmap strip for the window frame icon
        /// </summary>
        public int BitmapIndex
        {
            get { return bitmapIndex; }
            set
            {
                bitmapIndex = value;
                if (frame != null && bitmapIndex != -1)
                {
                    int hr = NativeMethods.S_OK;
                    // Since the window is already created, set the coresponding property
                    try {
                        hr = frame.SetProperty((int)__VSFPROPID.VSFPROPID_BitmapIndex, bitmapIndex);
                    } catch (COMException e) {
                        hr = e.ErrorCode;
                    }
                    Debug.Assert(hr >= 0, "Failed to set bitmap index on toolwindow");
                }
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.GetIVsWindowPane"]/*' />
        /// <summary>
        /// This method makes it possible to provide an IVsWindowPane not derived from ToolWindowPane
        /// To support that scenario one would override this method and create their IVsWindowPane and
        /// return it.
        /// </summary>
        /// <returns>IVsWindowPane to be hosted in the toolwindow frame</returns>
        public virtual object GetIVsWindowPane()
        {
            return this;
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.OnToolWindowCreated"]/*' />
        /// <summary>
        /// This method can be overriden by the derived class to execute
        /// any code that needs to run after the IVsWindowFrame is created.
        /// If the toolwindow has a toolbar with a combobox, it should make
        /// sure its command handler are set by the time they return from
        /// this method.
        /// This is called when someone set the Frame property.
        /// </summary>
        public virtual void OnToolWindowCreated()
        {
            Debug.Assert(frame != null, "Frame should be set before this method is called");

            // If any property were set, set them on the frame (setting our properties will take care of it)
            Caption = caption;
            BitmapResourceID = bitmapResourceID;
            BitmapIndex = bitmapIndex;
        }

        /// <summary>
        /// This should be overriden if you want to run code before the window is shown
        /// but after its toolbar is added.
        /// </summary>
        public virtual void OnToolBarAdded()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\VsMenus.cs ===
//--------------------------------------------------------------------------
//  <copyright file="VsCommands.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using System;

namespace Microsoft.VisualStudio.Shell
{

    /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus"]/*' />
    public class VsMenus
	{
		// menu command guids.
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidStandardCommandSet97"]/*' />
        public static Guid guidStandardCommandSet97 = new Guid("5efc7975-14bc-11cf-9b2b-00aa00573819");
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidStandardCommandSet2K"]/*' />
        public static Guid guidStandardCommandSet2K = new Guid("1496A755-94DE-11D0-8C3F-00C04FC2AAE2");
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidVsVbaPkg"]/*' />
        public static Guid guidVsVbaPkg = new Guid(0xa659f1b3, 0xad34, 0x11d1, 0xab, 0xad, 0x0, 0x80, 0xc7, 0xb8, 0x9c, 0x95);
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidSHLMainMenu"]/*' />
        public static Guid guidSHLMainMenu = new Guid(0xd309f791, 0x903f, 0x11d0, 0x9e, 0xfc, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f);
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidVSUISet"]/*' />
        public static Guid guidVSUISet = new Guid("60481700-078b-11d1-aaf8-00a0c9055a90");
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidCciSet"]/*' />
        public static Guid guidCciSet = new Guid("2805D6BD-47A8-4944-8002-4e29b9ac2269");
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidVsUIHierarchyWindowCmds"]/*' />
        public static Guid guidVsUIHierarchyWindowCmds = new Guid("60481700-078B-11D1-AAF8-00A0C9055A90");
		
        // Special Menus.
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_CODEWIN"]/*' />
        public const int IDM_VS_CTXT_CODEWIN = 0x040D;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_ITEMNODE"]/*' />
        public const int IDM_VS_CTXT_ITEMNODE = 0x0430;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_PROJNODE"]/*' />
        public const int IDM_VS_CTXT_PROJNODE = 0x0402;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_REFERENCEROOT"]/*' />
        public const int IDM_VS_CTXT_REFERENCEROOT = 0x0450;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_REFERENCE"]/*' />
        public const int IDM_VS_CTXT_REFERENCE = 0x0451;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_FOLDERNODE"]/*' />
        public const int IDM_VS_CTXT_FOLDERNODE = 0x0431;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_NOCOMMANDS"]/*' />
        public const int IDM_VS_CTXT_NOCOMMANDS = 0x041A;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.VSCmdOptQueryParameterList"]/*' />
        public const int VSCmdOptQueryParameterList = 1;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_XPROJ_MULTIITEM"]/*' />
        public const int IDM_VS_CTXT_XPROJ_MULTIITEM = 0x0419;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_XPROJ_PROJITEM"]/*' />
        public const int IDM_VS_CTXT_XPROJ_PROJITEM = 0x0417;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ServiceProviderHierarchy.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceProviderHierarchy.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Collections.Generic;
    using Microsoft.VisualStudio.OLE.Interop;

    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchy"]' />
    /// <devdoc>
    ///     This class acts as a hierarchical service provider.  It stores IServiceProviders in a sorted dictionary
    ///     for an ordered retrieval.  When GetService is called to retrieve a service, the service providers are queried
    ///     in a specific order.  This is useful when multiple service providers are combined such as in 
    ///     the WindowPane implementation
    /// </devdoc>
    [CLSCompliant(false)]
    public sealed class ServiceProviderHierarchy : SortedList<int, IServiceProvider>, IServiceProvider {
        
        /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchy.GetService"]' />
        /// <devdoc>
        ///     Retrieves the requested service by walking the hierarchy of service providers.
        /// </devdoc>
        public object GetService(Type serviceType) {
            
            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            if (serviceType.IsEquivalentTo(typeof(IObjectWithSite)))
            {
                throw new InvalidOperationException("can not re-site chained services providers");
            }

            object service = null;

            if (serviceType.IsEquivalentTo(typeof(ServiceProviderHierarchy))) {
                service = this;
            }
            else {
                foreach(IServiceProvider provider in Values) {
                    service = provider.GetService(serviceType);
                    if (service != null) {
                        break;
                    }
                }
            }

            return service;
        }
    }

    /// <include file='doc\ServiceProviderHierarchyOrder.uex' path='docs/doc[@for="ServiceProviderHierarchyOrder"]' />
    /// <devdoc>
    ///     When multiple service providers are combined in a service provider hierarchy they 
    ///     are ordered according to a numeric ordering.  This class provides recommended service
    ///     resolution order for common service providers.
    /// </devdoc>
    public sealed class ServiceProviderHierarchyOrder {
        /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchyOrder.PackageSite"]/*' />
        public const int PackageSite = 100;
        /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchyOrder.WindowPaneSite"]/*' />
        public const int WindowPaneSite = 50;
        /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchyOrder.ProjectItemContext"]/*' />
        public const int ProjectItemContext = 25;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Url.cs ===
//--------------------------------------------------------------------------
//  <copyright file="Url.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using System;
using System.Linq;
using System.Windows.Forms;
using System.Diagnostics;
using Microsoft.Win32;
using System.Globalization;
using System.IO;
using System.Collections;
using System.Xml;
using System.Text;
using System.Net;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;

namespace Microsoft.VisualStudio.Shell
{	
    /// <summary>
    /// This class wraps the Uri class and provides an unescaped "LocalPath" for file URL's
    /// and an unescaped AbsoluteUri for other schemes, plus it also returned an un-hex-escaped
    /// result from MakeRelative so it can be presented to the user.
    /// </summary>
    public class Url
    {
        private Uri uri = null;
        private bool isFile;
        private string cachedAbsUrl;

        
        public Url(string path)
        {
            Init(path);
        }
        
        void Init(string path)
        {
            // Must try absolute first, then fall back on relative, otherwise it
            // makes some absolute UNC paths like (\\lingw11\Web_test\) relative!
            if (path != null)
            {

                if (!Uri.TryCreate(path, UriKind.Absolute, out this.uri))
                {
                    Uri.TryCreate(path, UriKind.Relative, out this.uri);
                } 
                
                this.CheckIsFile();
            }
        }

        void CheckIsFile()
        {
            this.isFile = false;
            if (this.uri != null)
            {
                if (this.uri.IsAbsoluteUri)
                {
                    this.isFile = this.uri.IsFile;
                }
                else
                {
                    int numberSlashes = this.uri.OriginalString.Count<char>(ch => (ch == '/'));
                    int numberBackSlashes = this.uri.OriginalString.Count<char>(ch => (ch == '\\'));
                    // If there are no slashes in the string, or the number of slashes is smaller than the number of backslashes, consider this to be a File Uri.
                    if (numberSlashes == 0 || numberSlashes < numberBackSlashes)
                    {
                        this.isFile = true;
                    }
                }
            }
        }

        // allows relpath to be null, in which case it just returns the baseUrl.
        
        public Url(Url baseUrl, string relpath)
        {
            if (baseUrl.uri == null || !baseUrl.uri.IsAbsoluteUri)
            {
                Init(relpath);
            }
            else if (string.IsNullOrEmpty(relpath))
            {
                this.uri = baseUrl.uri;
            }
            else
            {
                Uri.TryCreate(baseUrl.uri, relpath, out this.uri);
            }
            CheckIsFile();
        }
        
        
        public string AbsoluteUrl
        {
            get
            {
                if (this.uri == null) return null;
                if (cachedAbsUrl != null) return cachedAbsUrl;
                if (this.uri.IsAbsoluteUri)
                {
                    if (this.isFile)
                    {
                        // Fix for build break. UriComponents.LocalPath is no longer available.
                        // return uri.GetComponents(UriComponents.LocalPath, UriFormat.SafeUnescaped);
                        cachedAbsUrl = uri.LocalPath;
                    }
                    else
                    {
                        cachedAbsUrl = uri.GetComponents(UriComponents.AbsoluteUri, UriFormat.SafeUnescaped);
                    }
                }
                else
                {
                    cachedAbsUrl = uri.OriginalString;
                }
            return cachedAbsUrl;
            }
        }

        
        /// <summary>Returns the AbsoluteUrl for the parent directory containing the file 
        /// referenced by this URL object, where the Directory string is also unescaped.</summary>
        public string Directory
        {
            get 
            {
                string path = this.AbsoluteUrl;
                if (path == null) return null;
                if (this.isFile) {
                    return Path.GetDirectoryName(path);
                }

                int i = path.LastIndexOf('/');
                int len = (i > 0) ? i : path.Length;
                return path.Substring(0, len);
            }
        }

        
        public bool IsFile
        {
            get { return this.isFile; }
        }

        
        public Url Move(Url oldBase, Url newBase)
        {
            if (this.uri == null || oldBase.uri == null) return null;
            string rel = oldBase.uri.MakeRelativeUri(this.uri).ToString();
            return new Url(newBase, rel);
        }

        // return an un-escaped relative path
        
        public string MakeRelative(Url url)
        {
            if (this.uri == null || url.uri == null) return null;
            if (this.uri.Scheme != url.uri.Scheme || this.uri.Host != url.uri.Host)
            {
                // Then it cannot be relatavized (e.g from file:// to http://).
                return url.AbsoluteUrl;
            }
            // This will return a hex-escaped string.
            string rel = this.uri.MakeRelativeUri(url.uri).ToString();

            // So unescape it.
            return Unescape(rel, this.isFile);
        }

        const char c_DummyChar = (char)0xFFFF;

        private static char EscapedAscii(char digit, char next)
        {
            // Only accept hexadecimal characters
            if (!(((digit >= '0') && (digit <= '9'))
                || ((digit >= 'A') && (digit <= 'F'))
                || ((digit >= 'a') && (digit <= 'f'))))
            {
                return c_DummyChar;
            }

            int res = 0;
            if (digit <= '9')
                res = (int)digit - (int)'0';
            else if (digit <= 'F')
                res = ((int)digit - (int)'A') + 10;
            else
                res = ((int)digit - (int)'a') + 10;

            // Only accept hexadecimal characters
            if (!(((next >= '0') && (next <= '9'))
                || ((next >= 'A') && (next <= 'F'))
               || ((next >= 'a') && (next <= 'f'))))
            {
                return c_DummyChar;
            }

            res = res << 4;
            if (next <= '9')
                res += (int)next - (int)'0';
            else if (digit <= 'F')
                res += ((int)next - (int)'A') + 10;
            else
                res += ((int)next - (int)'a') + 10;

            return (char)(res);
        }

        
        public static string Unescape(string escaped, bool isFile)
        {
            if (String.IsNullOrEmpty(escaped))
            {
                return String.Empty;
            }

            byte[] bytes = null;
            char[] dest = new char[escaped.Length];
            int j = 0;

            for (int i = 0, end = escaped.Length; i < end; i++)
            {
                char ch = escaped[i];
                if (ch != '%')
                {
                    if (ch == '/' && isFile)
                    {
                        ch = Path.DirectorySeparatorChar;
                    }
                    dest[j++] = ch;
                }
                else
                {
                    int byteCount = 0;
                    // lazy initialization of max size, will reuse the array for next sequences
                    if (bytes == null)
                    {
                        bytes = new byte[end - i];
                    }

                    do
                    {
                        // Check on exit criterion
                        if ((ch = escaped[i]) != '%' || (end - i) < 3)
                        {
                            break;
                        }
                        // already made sure we have 3 characters in str
                        ch = EscapedAscii(escaped[i + 1], escaped[i + 2]);
                        if (ch == c_DummyChar)
                        {
                            //invalid hex sequence, we will out '%' character
                            ch = '%';
                            break;
                        }
                        else if (ch < '\x80')
                        {
                            // character is not part of a UTF-8 sequence
                            i += 2;
                            break;
                        }
                        else
                        {
                            //a UTF-8 sequence
                            bytes[byteCount++] = (byte)ch;
                            i += 3;
                        }
                    } while (i < end);

                    if (byteCount != 0)
                    {

                        int charCount = Encoding.UTF8.GetCharCount(bytes, 0, byteCount);
                        if (charCount != 0)
                        {
                            Encoding.UTF8.GetChars(bytes, 0, byteCount, dest, j);
                            j += charCount;
                        }
                        else
                        {
                            // the encoded, high-ANSI characters are not UTF-8 encoded
                            for (int k = 0; k < byteCount; ++k)
                            {
                                dest[j++] = (char)bytes[k];
                            }
                        }
                    }
                    if (i < end)
                    {
                        dest[j++] = ch;
                    }
                }
            }
            return new string(dest, 0, j);
        }

        
        public Uri Uri
        {
            get { return this.uri; }
        }

        /// Return unescaped path up to (but not including) segment i.
        public string GetPartial(int i)
        {
            return GetPartial(0, i);
        }

        public string GetPartial(int i, int j) {
            string path = JoinSegments(i, j);
            if (i == 0)
                if (!this.isFile) {
                    // prepend "http://host/"
                    path = this.uri.Scheme + "://" + this.uri.Host + '/' + path;
                } else if (this.uri.IsAbsoluteUri && this.uri.IsUnc && this.AbsoluteUrl.StartsWith(@"\\", StringComparison.OrdinalIgnoreCase)) {
                    path = @"\\" + path;
                }
            return path;
        }

        
        /// Return unescaped relative path starting segment i.
        public string GetRemainder(int i)
        {
            return JoinSegments(i, -1);
        }
        
        // Unlike the Uri class, this ALWAYS succeeds, even on relative paths, and it
        // strips out the path separator characters
        public string[] Segments
        {
            get
            {
                if (this.uri == null)
                    return null;
                string path = this.AbsoluteUrl;
                if (this.isFile)
                {
                    if (path.EndsWith(@"\", StringComparison.OrdinalIgnoreCase))
                    {
                        path = path.Substring(0, path.Length - 1);
                    }
                    if (this.uri.IsAbsoluteUri && this.uri.IsUnc && path.StartsWith(@"\\", StringComparison.OrdinalIgnoreCase))
                    {
                        path = path.Substring(2);
                    }
                    return path.Split(Path.DirectorySeparatorChar);
                }
                else
                {
                    // strip off "http://" and host name, since those are not part of the path.
                    path = path.Substring(this.uri.Scheme.Length + 3 + this.uri.Host.Length + 1);
                    if (path.EndsWith("/", StringComparison.OrdinalIgnoreCase))
                        path = path.Substring(0, path.Length - 1);
                    return path.Split('/');
                }
            }
        }

        public string JoinSegments(int i, int j)
        {
            if (i < 0)
                throw new ArgumentOutOfRangeException("i");

            StringBuilder sb = new StringBuilder();
            string[] segments = this.Segments;
            if (segments == null)
                return null;
            if (j < 0)
                j = segments.Length;
            int len = segments.Length;
            for (; i < j && i < len; i++)
            {
                if (sb.Length > 0)
                    sb.Append(this.isFile ? Path.DirectorySeparatorChar : '/');
                string s = segments[i];
                sb.Append(s);
            }
            return Unescape(sb.ToString(), isFile);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Empty string is not a valid value for the argument '{0}'.
        /// </summary>
        internal static string Argument_EmptyString
        {
            get
            {
                return ResourceManager.GetString("Argument_EmptyString", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To register the {0} file extension, you must prefix the extension with a &apos;.&apos;..
        /// </summary>
        internal static string Attributes_ExtensionNeedsDot {
            get {
                return ResourceManager.GetString("Attributes_ExtensionNeedsDot", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The factoryType must be of one of those type: Type, Guid, string (representing a Guid)..
        /// </summary>
        internal static string Attributes_InvalidFactoryType {
            get {
                return ResourceManager.GetString("Attributes_InvalidFactoryType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No project guid provided, but it is needed to register the extension for EditorFactoryNotify..
        /// </summary>
        internal static string Attributes_NoPrjForEditorFactoryNotify {
            get {
                return ResourceManager.GetString("Attributes_NoPrjForEditorFactoryNotify", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No Product Name was specified.  To register as an Installed Product, a Product Name is required..
        /// </summary>
        internal static string Attributes_ProductNameNotSpecified {
            get {
                return ResourceManager.GetString("Attributes_ProductNameNotSpecified", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unknown docking style: {0}..
        /// </summary>
        internal static string Attributes_UnknownDockingStyle {
            get {
                return ResourceManager.GetString("Attributes_UnknownDockingStyle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unknown relative position: {0}..
        /// </summary>
        internal static string Attributes_UnknownPosition {
            get {
                return ResourceManager.GetString("Attributes_UnknownPosition", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Failed to retrieve service {0}..
        /// </summary>
        internal static string Flavor_FailedToGetService {
            get {
                return ResourceManager.GetString("Flavor_FailedToGetService", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Expecting an array of size greater than zero..
        /// </summary>
        internal static string General_ArraySizeShouldBeAtLeast1 {
            get {
                return ResourceManager.GetString("General_ArraySizeShouldBeAtLeast1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Expected string that is not empty..
        /// </summary>
        internal static string General_ExpectedNonEmptyString {
            get {
                return ResourceManager.GetString("General_ExpectedNonEmptyString", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Expected object of type {0}..
        /// </summary>
        internal static string General_InvalidType {
            get {
                return ResourceManager.GetString("General_InvalidType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The service &apos;{0}&apos; must be installed for this feature to work.  Ensure that this service is available..
        /// </summary>
        internal static string General_MissingService {
            get {
                return ResourceManager.GetString("General_MissingService", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method called on a disposed object of type {0}..
        /// </summary>
        internal static string General_ObjectDisposed {
            get {
                return ResourceManager.GetString("General_ObjectDisposed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unsupported value: {0}..
        /// </summary>
        internal static string General_UnsupportedValue {
            get {
                return ResourceManager.GetString("General_UnsupportedValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The dialog page type {0} does not derive from DialogPage..
        /// </summary>
        internal static string Package_BadDialogPageType {
            get {
                return ResourceManager.GetString("Package_BadDialogPageType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The solution option name {0} is invalid.  It cannot contain &apos;.&apos;, &apos;/&apos; or other special characters..
        /// </summary>
        internal static string Package_BadOptionName {
            get {
                return ResourceManager.GetString("Package_BadOptionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The service {0} already exists in the service container..
        /// </summary>
        internal static string Package_DuplicateService {
            get {
                return ResourceManager.GetString("Package_DuplicateService", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Instance ID {0} is invalid..
        /// </summary>
        internal static string Package_InvalidInstanceID {
            get {
                return ResourceManager.GetString("Package_InvalidInstanceID", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The service instance must derive from or implement {0}..
        /// </summary>
        internal static string Package_InvalidServiceInstance {
            get {
                return ResourceManager.GetString("Package_InvalidServiceInstance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to CreateToolWindow only creates Tool Windows derived from ToolWindowPane..
        /// </summary>
        internal static string Package_InvalidToolWindowClass {
            get {
                return ResourceManager.GetString("Package_InvalidToolWindowClass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The package requires that service &apos;{0}&apos; be installed.  Ensure that this service is available..
        /// </summary>
        internal static string Package_MissingService {
            get {
                return ResourceManager.GetString("Package_MissingService", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The solution option name {0} is already used by this package..
        /// </summary>
        internal static string Package_OptionNameUsed {
            get {
                return ResourceManager.GetString("Package_OptionNameUsed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The page type {0} does not offer an empty constructor..
        /// </summary>
        internal static string Package_PageCtorMissing {
            get {
                return ResourceManager.GetString("Package_PageCtorMissing", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The page type {0} does not implement {1}..
        /// </summary>
        internal static string Package_PageMissingInterface {
            get {
                return ResourceManager.GetString("Package_PageMissingInterface", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The page class {0} must derive from DialogPage..
        /// </summary>
        internal static string Package_PageNotDialogPage {
            get {
                return ResourceManager.GetString("Package_PageNotDialogPage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A site has already been set on package {0}..
        /// </summary>
        internal static string Package_SiteAlreadySet {
            get {
                return ResourceManager.GetString("Package_SiteAlreadySet", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameters {0} and {1} have incompatible types.
        /// </summary>
        internal static string Reg_ErrorIncompatibleParametersTypes {
            get {
                return ResourceManager.GetString("Reg_ErrorIncompatibleParametersTypes", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameters {0} and {1} have incompatible values.
        /// </summary>
        internal static string Reg_ErrorIncompatibleParametersValues {
            get {
                return ResourceManager.GetString("Reg_ErrorIncompatibleParametersValues", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Autoload package:         {0}.
        /// </summary>
        internal static string Reg_NotifyAutoLoad {
            get {
                return ResourceManager.GetString("Reg_NotifyAutoLoad", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Creatable Object: {0}.
        /// </summary>
        internal static string Reg_NotifyCreateObject {
            get {
                return ResourceManager.GetString("Reg_NotifyCreateObject", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Editor Extension: {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyEditorExtension {
            get {
                return ResourceManager.GetString("Reg_NotifyEditorExtension", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Editor Factory:   {0}.
        /// </summary>
        internal static string Reg_NotifyEditorFactory {
            get {
                return ResourceManager.GetString("Reg_NotifyEditorFactory", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Logical View:     {0}.
        /// </summary>
        internal static string Reg_NotifyEditorView {
            get {
                return ResourceManager.GetString("Reg_NotifyEditorView", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Extender:         {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyExtender {
            get {
                return ResourceManager.GetString("Reg_NotifyExtender", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Installed Product:   {0}, Version {1}.
        /// </summary>
        internal static string Reg_NotifyInstalledProduct {
            get {
                return ResourceManager.GetString("Reg_NotifyInstalledProduct", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Installed Product:   Using IVsInstalledProduct interface.
        /// </summary>
        internal static string Reg_NotifyInstalledProductInterface {
            get {
                return ResourceManager.GetString("Reg_NotifyInstalledProductInterface", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Key Binding: {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyKeyBinding {
            get {
                return ResourceManager.GetString("Reg_NotifyKeyBinding", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Language Code Expansion: {0}.
        /// </summary>
        internal static string Reg_NotifyLanguageCodeExpansion {
            get {
                return ResourceManager.GetString("Reg_NotifyLanguageCodeExpansion", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Language Extension: {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyLanguageExtension {
            get {
                return ResourceManager.GetString("Reg_NotifyLanguageExtension", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LanguageOptionCategory: {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyLanguageOptionCategory {
            get {
                return ResourceManager.GetString("Reg_NotifyLanguageOptionCategory", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Language Option Page: {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyLanguageOptionPage {
            get {
                return ResourceManager.GetString("Reg_NotifyLanguageOptionPage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Language Service: {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyLanguageService {
            get {
                return ResourceManager.GetString("Reg_NotifyLanguageService", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LoadKey:          {0} {1}
        ///Version {2}
        ///Edition Required: {3}.
        /// </summary>
        internal static string Reg_NotifyLoadKey {
            get {
                return ResourceManager.GetString("Reg_NotifyLoadKey", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Menu:             {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyMenuResource {
            get {
                return ResourceManager.GetString("Reg_NotifyMenuResource", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Option Page:      {0}\{1}.
        /// </summary>
        internal static string Reg_NotifyOptionPage {
            get {
                return ResourceManager.GetString("Reg_NotifyOptionPage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Package:          {0} {1}.
        /// </summary>
        internal static string Reg_NotifyPackage {
            get {
                return ResourceManager.GetString("Reg_NotifyPackage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Project Factory:  {0}.
        /// </summary>
        internal static string Reg_NotifyProjectFactory {
            get {
                return ResourceManager.GetString("Reg_NotifyProjectFactory", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Project Items:    {0}.
        /// </summary>
        internal static string Reg_NotifyProjectItems {
            get {
                return ResourceManager.GetString("Reg_NotifyProjectItems", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Service:          {0}.
        /// </summary>
        internal static string Reg_NotifyService {
            get {
                return ResourceManager.GetString("Reg_NotifyService", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Statically Registered Toolbox Group: ID "{0}", Name "{1}".
        /// </summary>
        internal static string Reg_NotifyStaticToolboxGroup {
            get {
                return ResourceManager.GetString("Reg_NotifyStaticToolboxGroup", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Statically Registered Toolbox Item: Group ID "{0}", Item ID "{1}", Item Name "{2}".
        /// </summary>
        internal static string Reg_NotifyStaticToolboxItem {
            get {
                return ResourceManager.GetString("Reg_NotifyStaticToolboxItem", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Toolbox Items:    Version {0} (Formats: {1}).
        /// </summary>
        internal static string Reg_NotifyToolboxItem {
            get {
                return ResourceManager.GetString("Reg_NotifyToolboxItem", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Toolbox Config:   {0}.
        /// </summary>
        internal static string Reg_NotifyToolboxItemConfiguration {
            get {
                return ResourceManager.GetString("Reg_NotifyToolboxItemConfiguration", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to                    Filter: {0}.
        /// </summary>
        internal static string Reg_NotifyToolboxItemFilter {
            get {
                return ResourceManager.GetString("Reg_NotifyToolboxItemFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Toolbox Page:     {0}.
        /// </summary>
        internal static string Reg_NotifyToolboxPage {
            get {
                return ResourceManager.GetString("Reg_NotifyToolboxPage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ToolWindow:       {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyToolResource {
            get {
                return ResourceManager.GetString("Reg_NotifyToolResource", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Tool Visibility:  {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyToolVisibility {
            get {
                return ResourceManager.GetString("Reg_NotifyToolVisibility", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Invalid toolbox item ID: {0}..
        /// </summary>
        internal static string Toolbox_InvalidItemId {
            get {
                return ResourceManager.GetString("Toolbox_InvalidItemId", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Toolbox item &quot;{0}&quot; not found on machine..
        /// </summary>
        internal static string Toolbox_ItemNotFound {
            get {
                return ResourceManager.GetString("Toolbox_ItemNotFound", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unsupported toolbox format: {0}..
        /// </summary>
        internal static string Toolbox_UnsupportedFormat {
            get {
                return ResourceManager.GetString("Toolbox_UnsupportedFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The package property of the tool window should only be set by the creator of the tool window..
        /// </summary>
        internal static string ToolWindow_PackageOnlySetByCreator {
            get {
                return ResourceManager.GetString("ToolWindow_PackageOnlySetByCreator", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to toolClsid cannot be added after the Frame is created.
        ///Add the toolClsid in the ToolWindow constructor..
        /// </summary>
        internal static string ToolWindow_TooLateToAddTool {
            get {
                return ResourceManager.GetString("ToolWindow_TooLateToAddTool", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Toolbar cannot be added after the Frame is created.
        ///Add the ToolBar in the ToolWindow constructor..
        /// </summary>
        internal static string ToolWindow_TooLateToAddToolbar {
            get {
                return ResourceManager.GetString("ToolWindow_TooLateToAddToolbar", resourceCulture);
            }
        }

        /// <summary>
        /// The default text of the wait dialog during a CommonMessagePump wait. 
        /// </summary>
        internal static string CommonMessagePumpDefaultWaitText
        {
            get {
                return ResourceManager.GetString("CommonMessagePumpDefaultWaitText"); 
            }
        }

        /// <summary>
        /// The default status bar text during a CommonMessagePump wait.
        /// </summary>
        internal static string CommonMessagePumpDefaultWaitStatusBarText
        {
            get {
                return ResourceManager.GetString("CommonMessagePumpDefaultWaitStatusBarText"); 
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Invoked on the wrong thread..
        /// </summary>
        internal static string Services_InvokedOnWrongThread
        {
            get {
                return ResourceManager.GetString("Services_InvokedOnWrongThread"); 
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\TaskProvider.cs ===
//------------------------------------------------------------------------------
// <copyright file="TaskProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.VisualStudio.TextManager.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider"]' />
    /// <devdoc>
    ///     This class implements IVsTaskProvider.  It provides a 
    ///     framework-friendly way to define a package and its associated 
    ///     services.  
    /// </devdoc>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class TaskProvider :

        IVsTaskProvider,
        IVsTaskProvider2,
        IVsTaskProvider3,
        IDisposable {

        internal IServiceProvider       provider;
        internal ImageList              imageList;
        internal IVsTaskList            taskList;
        internal uint                   taskListCookie;
        internal TaskCollection         tasks;
        internal StringCollection       subCategories;
        internal int                    suspended;
        internal bool                   dirty;
        internal Guid                   providerGuid;
        internal string                 name;
        internal bool                   alwaysVisible;
        internal bool                   disableAutoRoute;
        internal Guid                   toolbarGroup;
        internal int                    toolbarId;
        internal bool                   maintainOrder;
        private  bool                   inFinalRelease;


        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.TaskProvider"]/*' />
        public TaskProvider(IServiceProvider provider) {
            this.provider = provider;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Finalize"]/*' />
        ~TaskProvider() {
            Dispose(false);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.MaintainTaskOrder"]/*' />
        /// Determines whether or not the task list should maintain the task order given to it by the task provider.
        public bool MaintainInitialTaskOrder {
            get { return this.maintainOrder; }
            set { this.maintainOrder = value; }
        }

        /// The TaskList groups all tasks from multiple providers
        /// that provide the same GUID into one list.  
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ProviderGuid"]/*' />
        public Guid ProviderGuid {
            get { return this.providerGuid; }
            set { this.providerGuid = value; }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ProviderName"]/*' />
        /// Returns a localized human-readable name for this data provider.
        public string ProviderName {
            get { return this.name; }
            set { this.name = value; }
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.AlwaysVisible"]/*' />
        /// Provider is always visible in dropdown even if it has no tasks.
        public bool AlwaysVisible {
            get { return this.alwaysVisible; }
            set { this.alwaysVisible = value; }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.DisableAutoRoute"]/*' />
        /// Provider is always visible in dropdown even if it has no tasks.
        public bool DisableAutoRoute
        {
            get { return this.disableAutoRoute; }
            set { this.disableAutoRoute = value; }
        }

        // Returns a group GUID and toolbar ID indicating which toolbar should be displayed when this
        // provider is active.  Set pguidGroup and pdwID to GUID_NULL and 0, respectively, to indicate
        // that this provider has no toolbar.  If you do provide a toolbar, you must include the
        // provider dropdown as the first group, by including this line in your CTC file:
        //     guidSHLMainMenu:IDG_VS_TASKLIST_PROVIDERLIST, <your toolbar's group>:<your toolbar menu ID>, 0x0100;
        // See vscommon\appid\inc\ShellCmdPlace.ctc for examples.
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.ToolbarGroup"]/*' />
        public Guid ToolbarGroup {
            get { return this.toolbarGroup; }
            set { this.toolbarGroup = value; }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.ToolbarId"]/*' />
        public int ToolbarId {
            get { return this.toolbarId; }
            set { this.toolbarId = value; }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.ImageList"]/*' />
        public ImageList ImageList {
            get {
                return imageList;
            }
            set {
                if (imageList != value) {
                    imageList = value;
                    UpdateProviderInfo();
                }
            }
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Subcategories"]/*' />
        public StringCollection Subcategories {
            get {
                if (subCategories == null) {
                    subCategories = new StringCollection();
                }
                return subCategories;
            }
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Tasks"]/*' />
        public TaskCollection Tasks {
            get {
                if (tasks == null) {
                    tasks = new TaskCollection(this);
                }
                return tasks;
            }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.VsTaskList"]/*' />
        protected virtual IVsTaskList VsTaskList {
            get {
                if (taskList == null) {
                    taskList = GetService(typeof(SVsTaskList)) as IVsTaskList;
                    if (taskList == null) {
                        throw new InvalidOperationException(string.Format(Resources.Culture, Resources.General_MissingService, typeof(IVsTaskList).FullName));
                    }
                    NativeMethods.ThrowOnFailure( taskList.RegisterTaskProvider(this, out taskListCookie) );
                }

                return taskList;
            }
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Dispose"]/*' />
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Dispose1"]/*' />
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        protected virtual void Dispose(bool disposing)
        {
			if (disposing)
			{
				if (tasks != null && !inFinalRelease)
				{
					tasks.Clear();
					tasks = null;
				}

				if (taskList != null)
				{
					try
					{
						// Don't check for the result code because here we can't do anything in case of failure
						taskList.UnregisterTaskProvider(taskListCookie);
					}
					catch (Exception)
					{ /* do nothing */ }
					taskList = null;
				}

				if (imageList != null)
				{
					imageList.Dispose();
					imageList = null;
				}
			}
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.GetService"]/*' />
        protected internal object GetService(Type serviceType) {
            if (provider != null) {
                return provider.GetService(serviceType);
            }
            return null;
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="Navigate"]/*' />
        /// <devdoc>
        ///     Navigates the document in the given task to the given logical view.
        /// </devdoc>
        public bool Navigate(Task task, Guid logicalView) {

            if (task == null) {
                throw new ArgumentNullException("task");
            }

            // Get the doc data for the task's document
            if (task.Document == null || task.Document.Length == 0) {
                return false;
            }

            IVsUIShellOpenDocument openDoc = GetService(typeof(IVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            if (openDoc == null) {
                return false;
            }

            IVsWindowFrame frame;
            IOleServiceProvider sp;
            IVsUIHierarchy hier;
            uint itemid;
            Guid logView = logicalView;

            if (NativeMethods.Failed(openDoc.OpenDocumentViaProject(task.Document, ref logView, out sp, out hier, out itemid, out frame)) || frame == null) {
                return false;
            }

            object docData;
            frame.GetProperty((int)__VSFPROPID.VSFPROPID_DocData, out docData);

            VsTextBuffer buffer = docData as VsTextBuffer;
            if (buffer == null) {
                IVsTextBufferProvider bufferProvider = docData as IVsTextBufferProvider;
                if (bufferProvider != null) {
                    IVsTextLines lines;
                    NativeMethods.ThrowOnFailure(bufferProvider.GetTextBuffer(out lines));
                    buffer = lines as VsTextBuffer;
                    Debug.Assert(buffer != null, "IVsTextLines does not implement IVsTextBuffer");
                    if (buffer == null) {
                        return false;
                    }
                }
            }

            // Finally, perform the navigation.
            IVsTextManager mgr = GetService(typeof(VsTextManagerClass)) as IVsTextManager;

            if (mgr == null) {
                return false;
            }

            int line = task.Line;
            // Buffer is zero based
            if (line > 0) line--;

            mgr.NavigateToLineAndColumn(buffer, ref logicalView, line, 0, line, 0);
            return true;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Refresh"]/*' />
        public void Refresh() {
            if (suspended == 0) {
                dirty = false;
                NativeMethods.ThrowOnFailure( VsTaskList.RefreshTasks(taskListCookie) );
            } else {
                dirty = true;
            }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Show"]/*' />
        public virtual void Show() {
            IUIService uis = GetService(typeof(IUIService)) as IUIService;
            if (uis != null) {
                uis.ShowToolWindow(new Guid(EnvDTE.Constants.vsWindowKindTaskList));
            }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.SuspendRefresh"]/*' />
        /// <devdoc>
        /// SuspendRefresh stops refresh of the task list from happening until ResumeRefresh
        /// is called.  It supports nested Suspend/Resume.  The reason for this method is because
        /// by default, every change to the TaskCollection results in a call to Refresh, and
        /// the task list updates synchronously when Refresh() is called, so this allows 
        /// batching of the updates to occur which results in cleaner UI experience.  For
        /// example, without this refreshing a long task list will cause the task list scrollbar 
        /// to shrink and grow in a very visible way. By calling Suspend/Resume instead the
        /// the update of the a longs task list happens with very little visual noise.
        /// </devdoc>
        public void SuspendRefresh()
        {
            if (suspended < int.MaxValue)
                suspended++;
            else
                Debug.Fail("TaskProvider.SuspendRefresh() was called int.MaxValue times.\nYou may want to change the counter to something bigger then an int");
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.ResumeRefresh"]/*' />
        public void ResumeRefresh() {
            if (suspended > 0) {
                suspended--;
                if (suspended == 0 && dirty) {
                    Refresh();
                }
            }
        }

        private void TasksChanged() {
            Refresh();
        }

        private void UpdateProviderInfo() {
            if (taskList != null) {
                NativeMethods.ThrowOnFailure( taskList.UpdateProviderInfo(taskListCookie) );
            }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.EnumTaskItems"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.EnumTaskItems(out IVsEnumTaskItems items) {
            items = new VsEnumTaskItems(Tasks);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.ImageList"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.ImageList(out IntPtr himagelist) {
            if (ImageList != null) {
                HandleRef hRef = new HandleRef(null, ImageList.Handle);
                himagelist = UnsafeNativeMethods.ImageList_Duplicate(hRef);
            }
            else {
                himagelist = IntPtr.Zero;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.OnTaskListFinalRelease"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.OnTaskListFinalRelease(IVsTaskList taskList) {
            inFinalRelease = true;
            Dispose(true);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.ReRegistrationKey"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.ReRegistrationKey(out string key) {
            key = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}.{1}", this.GetType().Name, this.GetHashCode());
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.SubcategoryList"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.SubcategoryList(uint cbstr, string[] rgbstr, out uint cnt) {
            cnt = 0;
            if (null == rgbstr) {
                if (0 == cbstr) {
                    cnt = (null == subCategories) ? 0 : (uint)subCategories.Count;
                    return NativeMethods.S_OK;
                }
                throw new ArgumentNullException("rgbstr");
            }
            if (subCategories != null) {
                for (cnt = 0; cnt < cbstr && cnt < subCategories.Count; ++cnt) {
                    rgbstr[(int)cnt] = subCategories[(int)cnt];
                }

            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.EnumTaskItems"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.EnumTaskItems(out IVsEnumTaskItems items) {
            return ((IVsTaskProvider)this).EnumTaskItems(out items);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.ImageList"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.ImageList(out IntPtr himagelist) {
            return ((IVsTaskProvider)this).ImageList(out himagelist);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.OnTaskListFinalRelease"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.OnTaskListFinalRelease(IVsTaskList taskList) {
            return ((IVsTaskProvider)this).OnTaskListFinalRelease(taskList);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.ReRegistrationKey"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.ReRegistrationKey(out string key) {
            return ((IVsTaskProvider)this).ReRegistrationKey(out key);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.SubcategoryList"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.SubcategoryList(uint cbstr, string[] rgbstr, out uint cnt) {
            return ((IVsTaskProvider)this).SubcategoryList(cbstr, rgbstr, out cnt);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.MaintainInitialTaskOrder"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.MaintainInitialTaskOrder(out int fMaintainOrder) {
            fMaintainOrder = this.maintainOrder ? 1 : 0;
            return NativeMethods.S_OK;
        }

        // Returns the behavior flags for this provider.
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider3.GetProviderFlags"]/*' />
        /// <internalonly/>
        int IVsTaskProvider3.GetProviderFlags(out uint tpfFlags){
            tpfFlags = (this.alwaysVisible) ? (uint)__VSTASKPROVIDERFLAGS.TPF_ALWAYSVISIBLE : 0;
            if (disableAutoRoute)
                tpfFlags |= (uint)__VSTASKPROVIDERFLAGS.TPF_NOAUTOROUTING;
            return NativeMethods.S_OK; 
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider3.GetProviderName"]/*' />
        /// <internalonly/>
        int IVsTaskProvider3.GetProviderName(out string pbstrName){
            pbstrName = this.name;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider3.GetProviderGuid"]/*' />
        /// <devdoc>
        /// Returns a unique ID for this provider.  This is used to persist and restore per-provider
        /// data managed by the task list, such as user customizations of column width and order.
        /// </devdoc>
        /// <internalonly/>
        int IVsTaskProvider3.GetProviderGuid(out Guid pguidProvider) {
            pguidProvider = this.GetType().GUID;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider3.GetProviderToolbar"]/*' />
        /// <internalonly/>
        int IVsTaskProvider3.GetProviderToolbar(out Guid pguidGroup, out uint pdwID) {
            pguidGroup = this.toolbarGroup;
            pdwID = (uint)this.toolbarId;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.GetColumnCount"]/*' />
        // Returns the total number of columns supported by this provider, including columns that are
        // not visible by default.
        int IVsTaskProvider3.GetColumnCount(out int count) {
            // todo: provide a way to define custom columns
            // right now it is getting default behavior for free.
            count = 0;
            return NativeMethods.E_FAIL;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.GetColumn"]/*' />
        // Gets the definition of an indexed column (0 <= iColumn < nColumns).
        int IVsTaskProvider3.GetColumn(int iColumn, VSTASKCOLUMN[] pColumn) {
            return NativeMethods.E_FAIL;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.GetSurrogateProviderGuid"]/*' />
        int IVsTaskProvider3.GetSurrogateProviderGuid(out System.Guid guid) {
            guid = Guid.Empty;
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.OnBeginTaskEdit"]/*' />
        // Called when the user begins editing a task in-place.  Providers may want to avoid scrolling
        // the tasklist or changing the selection during editing, since these actions can force in-
        // place edit mode to be canceled abruptly.
        int IVsTaskProvider3.OnBeginTaskEdit(IVsTaskItem item) {
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.OnEndTaskEdit"]/*' />
        // Called when the user finishes editing a task in-place.  fCommitChanges indicates whether the
        // user chose to commit the changes or discard them.  This method may set *pfAllowChanges to
        // FALSE to disallow the user from exiting edit mode.  If fCommitChanges is TRUE, the changes
        // will have already been persisted down to the task item.
        int IVsTaskProvider3.OnEndTaskEdit(IVsTaskItem item, int fCommitChanges, out int fAllowChanges) {
            fAllowChanges = 1;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection"]/*' />
        public sealed class TaskCollection :

            IList {

            private TaskProvider owner;
            private ArrayList list;

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.TaskCollection"]/*' />
            public TaskCollection(TaskProvider owner) {
                if (null == owner) {
                    throw new ArgumentNullException("owner");
                }
                this.owner = owner;
                this.list = new ArrayList();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Count"]/*' />
            public int Count {
                get {
                    return list.Count;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.this"]/*' />
            public Task this[int index] {
                get {
                    return (Task)list[index];
                }
                set {
                    if (value == null) {
                        throw new ArgumentNullException("value");
                    }
                    Task t = this[index];
                    if (t != null) {
                        t.Owner = null;
                    }
                    list[index] = value;
                    value.Owner = owner;
                    owner.TasksChanged();
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Add"]/*' />
            public int Add(Task task) {
                if (task == null) {
                    throw new ArgumentNullException("task");
                }
                int index = list.Add(task);
                task.Owner = owner;
                owner.TasksChanged();
                return index;
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Clear"]/*' />
            public void Clear() {
                if (list.Count > 0) {
                    foreach (Task t in list) {
                        t.Owner = null;
                    }
                    list.Clear();
                    owner.TasksChanged();
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Contains"]/*' />
            public bool Contains(Task task) {
                return list.Contains(task);
            }

            private void EnsureTask(object obj) {
                if (!(obj is Task)) {
                    throw new ArgumentException(string.Format(Resources.Culture, Resources.General_InvalidType, typeof(Task).FullName), "obj");
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.GetEnumerator"]/*' />
            public IEnumerator GetEnumerator() {
                return list.GetEnumerator();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IndexOf"]/*' />
            public int IndexOf(Task task) {
                return list.IndexOf(task);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Insert"]/*' />
            public void Insert(int index, Task task) {
                if (task == null) {
                    throw new ArgumentNullException("task");
                }
                list.Insert(index, task);
                task.Owner = owner;
                owner.TasksChanged();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Remove"]/*' />
            public void Remove(Task task) {
                if (task == null) {
                    throw new ArgumentNullException("task");
                }
                list.Remove(task);
                task.Owner = null;
                owner.TasksChanged();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.RemoveAt"]/*' />
            public void RemoveAt(int index) {
                Task t = this[index];
                t.Owner = null;
                list.RemoveAt(index);
                owner.TasksChanged();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array array, int index) {
                list.CopyTo(array, index);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.IsReadOnly"]/*' />
            /// <internalonly/>
            bool IList.IsReadOnly {
                get {
                    return false;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    EnsureTask(value);
                    this[index] = (Task)value;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object obj) {
                EnsureTask(obj);
                return Add((Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Clear"]/*' />
            /// <internalonly/>
            void IList.Clear() {
                Clear();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object obj) {
                EnsureTask(obj);
                return Contains((Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object obj) {
                EnsureTask(obj);
                return IndexOf((Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object obj) {
                EnsureTask(obj);
                Insert(index, (Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object obj) {
                EnsureTask(obj);
                Remove((Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.RemoveAt"]/*' />
            /// <internalonly/>
            void IList.RemoveAt(int index) {
                RemoveAt(index);
            }
        }

        private class VsEnumTaskItems : IVsEnumTaskItems {

            private TaskCollection tasks;
            private IEnumerator taskEnum;

            internal VsEnumTaskItems(TaskCollection tasks) {
                this.tasks = tasks;
                this.taskEnum = tasks.GetEnumerator();
            }

            public int Clone(out IVsEnumTaskItems newItems) {
                newItems = new VsEnumTaskItems(tasks);
                return NativeMethods.S_OK;
            }

            public int Next(uint celt, IVsTaskItem[] items, uint[] pceltFetched) {
                if (items == null || items.Length < celt)
                    throw new ArgumentException(String.Empty, "items");

                uint fetched = 0;

                while (fetched < celt && taskEnum.MoveNext()) {
                    items[fetched++] = (IVsTaskItem)taskEnum.Current;
                }

                if (pceltFetched != null && pceltFetched.Length > 0) {
                    pceltFetched[0] = fetched;
                }

                if (fetched == 0 && celt > 0) {
                    return NativeMethods.S_FALSE;
                }

                return NativeMethods.S_OK;
            }

            public int Reset() {
                taskEnum.Reset();
                return NativeMethods.S_OK;
            }

            public int Skip(uint count) {
                while (count != 0) {
                    count--;
                    if (!taskEnum.MoveNext() && count != 0) {
                        return NativeMethods.S_FALSE;
                    }
                }

                return NativeMethods.S_OK;
            }
        }
    }


    // <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider"]' />
    /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider"]/*' />
    /// <devdoc>
    /// Use this provider to provide tasks for the Visual Studio Error List
    /// window. This task provider also has a Guid which is returned from
    /// </devdoc>
    [CLSCompliant(false)]
    public class ErrorListProvider : TaskProvider {
        IVsErrorList errorList;


        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.TaskProvider"]/*' />
        public ErrorListProvider(IServiceProvider provider) : base(provider) {
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.Finalize"]/*' />
        ~ErrorListProvider() {
            Dispose(false);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.Dispose1"]/*' />
        protected override void Dispose(bool disposing) {
            base.Dispose(disposing);
            this.errorList = null;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.VsTaskList"]/*' />
        protected override IVsTaskList VsTaskList {
            get {
                if (taskList == null) {

                    this.errorList = GetService(typeof(SVsErrorList)) as IVsErrorList;
                    if (errorList == null) {
                        return base.VsTaskList;
                    }
                    this.taskList = errorList as IVsTaskList;
                    if (taskList == null) {
                        throw new InvalidOperationException(string.Format(Resources.Culture, Resources.General_MissingService, typeof(IVsTaskList).FullName));
                    }
                    NativeMethods.ThrowOnFailure(taskList.RegisterTaskProvider(this, out taskListCookie));
                }

                return taskList;
            }
        }

        // Activates the window and makes it visible.  This should only be called
        // at the completion of a build process.
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.BringToFront"]/*' />
        public void BringToFront() {
            IVsTaskList tasklist = this.VsTaskList;
            NativeMethods.ThrowOnFailure( errorList.BringToFront() );
            tasklist = null;
        }

        // Forces the error toggle "on", so that errors are visible in the list.  Warnings and
        // informational messages are not affected.
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.ForceShowErrors"]/*' />
        public void ForceShowErrors() {
            IVsTaskList tasklist = this.VsTaskList;
            NativeMethods.ThrowOnFailure( errorList.ForceShowErrors() );
            tasklist = null;
        }
    
        /// <include file='doc\ErrorListProvider.uex' path='docs/doc[@for="ErrorListProvider.Show"]/*' />
        public override void Show() {
            IUIService uis = GetService(typeof(IUIService)) as IUIService;
            if (uis != null) {
                Guid errorList = new Guid(EnvDTE80.WindowKinds.vsWindowKindErrorList);
                uis.ShowToolWindow(errorList);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\VSConstants.cs ===
//------------------------------------------------------------------------------
// <copyright file="VSConstants.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio {

    using System;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.TextManager.Interop;
    using Microsoft.VisualStudio.OLE.Interop;
    using System.ComponentModel;

    [CLSCompliant(false)]
    public sealed class VSConstants {

        private VSConstants() { }


        /// <summary>
        /// 
        /// </summary>
        public static class WellKnownToolboxStringMaps
        {
            public const string MultiTargeting = "MultiTargeting:{FBB22D27-7B21-42AC-88C8-595F94BDBCA5}";
        }

        /// <summary>
        /// 
        /// </summary>
        public static class ToolboxMultitargetingFields
        {
            /// <summary>The full type name, e.g. System.Windows.Forms.Button</summary>
            public const string TypeName = "TypeName";
            /// <summary>The full assembly name (strong name), including version</summary>
            public const string AssemblyName = "AssemblyName";
            /// <summary>A semicolon-delimited list of TFMs this item supports (without profiles)</summary>
            public const string Frameworks = "Frameworks";
            /// <summary>The GUID of the package that implements IVsProvideTargetedToolboxItems and knows about this item type</summary>
            public const string ItemProvider = "ItemProvider";
            /// <summary>A boolean value indicating whether to use the project target framework's version in toolbox item tooltips</summary>
            public const string UseProjectTargetFrameworkVersionInTooltip = "UseProjectTargetFrameworkVersionInTooltip";
        }

        /// <summary>
        /// 
        /// </summary>
        public static class CMDSETID
        {
            /// <summary></summary>
            public const string StandardCommandSet97_string = "{5EFC7975-14BC-11CF-9B2B-00AA00573819}";
            /// <summary></summary>
            public static readonly Guid StandardCommandSet97_guid = new Guid(StandardCommandSet97_string);

            /// <summary></summary>
            public const string StandardCommandSet2K_string = "{1496A755-94DE-11D0-8C3F-00C04FC2AAE2}";
            /// <summary></summary>
            public static readonly Guid StandardCommandSet2K_guid = new Guid(StandardCommandSet2K_string);

            /// <summary>
            /// GUID for the Visual Studio 2010 command set. This is a set of new commands added to Visual Studio 2010.
            /// </summary>
            public const string StandardCommandSet2010_string = "{5DD0BB59-7076-4C59-88D3-DE36931F63F0}";
            /// <summary>
            /// GUID for the Visual Studio 2010 command set. This is a set of new commands added to Visual Studio 2010.
            /// </summary>
            public static readonly Guid StandardCommandSet2010_guid = new Guid(StandardCommandSet2010_string);

            /// <summary>Command Group GUID for commands that only apply to the UIHierarchyWindow.</summary>
            public const string UIHierarchyWindowCommandSet_string = "{60481700-078B-11D1-AAF8-00A0C9055A90}";
            /// <summary>Command Group GUID for commands that only apply to the UIHierarchyWindow.</summary>
            public static readonly Guid UIHierarchyWindowCommandSet_guid = new Guid(UIHierarchyWindowCommandSet_string);

            /// <summary></summary>
            public const string VsDocOutlinePackageCommandSet_string = "{21AF45B0-FFA5-11D0-B63F-00A0C922E851}";
            /// <summary></summary>
            public static readonly Guid VsDocOutlinePackageCommandSet_guid = new Guid(VsDocOutlinePackageCommandSet_string);
        }


        // VS Command ID's

        public const int cmdidToolsOptions = 264;

        /// Common OLE GUIDs
        public static readonly Guid IID_IUnknown = new Guid("{00000000-0000-0000-C000-000000000046}");


        /// <summary>This GUID identifies commands fired as a resoult of a WM_APPCOMMAND message received by the main window.</summary>
        public static readonly Guid GUID_AppCommand = new Guid("{12F1A339-02B9-46E6-BDAF-1071F76056BF}");

        [Guid("12F1A339-02B9-46e6-BDAF-1071F76056BF")]
        public enum AppCommandCmdID
        {
            BrowserBackward = 1,
            BrowserForward = 2,
            BrowserRefresh = 3,
            BrowserStop = 4,
            BrowserSearch = 5,
            BrowserFavorites = 6,
            BrowserHome = 7,
            VolumeMute = 8,
            VolumeDown = 9,
            VolumeUp = 10,
            MediaNextTrack = 11,
            MediaPreviousTrack = 12,
            MediaStop = 13,
            MediaPlayPause = 14,
            LaunchMail = 15,
            LaunchMediaSelect = 16,
            LaunchApp1 = 17,
            LaunchApp2 = 18,
            BassDown = 19,
            BassBoost = 20,
            BassUp = 21,
            TrebleDown = 22,
            TrebleUp = 23,
            MicrophoneVolumeMute = 24,
            MicrophoneVolumeDown = 25,
            MicrophoneVolumeUp = 26
        };

        /// <summary>This GUID identifies the standard set of commands known by VisualStudio 97 (version 6).</summary>
        public static readonly Guid GUID_VSStandardCommandSet97 = new Guid("{5EFC7975-14BC-11CF-9B2B-00AA00573819}");

        [Guid("5EFC7975-14BC-11CF-9B2B-00AA00573819")]
        public enum VSStd97CmdID
        {
            AlignBottom = 1,
            AlignHorizontalCenters = 2,
            AlignLeft = 3,
            AlignRight = 4,
            AlignToGrid = 5,
            AlignTop = 6,
            AlignVerticalCenters = 7,
            ArrangeBottom = 8,
            ArrangeRight = 9,
            BringForward = 10,
            BringToFront = 11,
            CenterHorizontally = 12,
            CenterVertically = 13,
            Code = 14,
            Copy = 15,
            Cut = 16,
            Delete = 17,
            FontName = 18,
            FontNameGetList = 500,
            FontSize = 19,
            FontSizeGetList = 501,
            Group = 20,
            HorizSpaceConcatenate = 21,
            HorizSpaceDecrease = 22,
            HorizSpaceIncrease = 23,
            HorizSpaceMakeEqual = 24,
            LockControls = 369,
            InsertObject = 25,
            Paste = 26,
            Print = 27,
            Properties = 28,
            Redo = 29,
            MultiLevelRedo = 30,
            SelectAll = 31,
            SendBackward = 32,
            SendToBack = 33,
            ShowTable = 34,
            SizeToControl = 35,
            SizeToControlHeight = 36,
            SizeToControlWidth = 37,
            SizeToFit = 38,
            SizeToGrid = 39,
            SnapToGrid = 40,
            TabOrder = 41,
            Toolbox = 42,
            Undo = 43,
            MultiLevelUndo = 44,
            Ungroup = 45,
            VertSpaceConcatenate = 46,
            VertSpaceDecrease = 47,
            VertSpaceIncrease = 48,
            VertSpaceMakeEqual = 49,
            ZoomPercent = 50,
            BackColor = 51,
            Bold = 52,
            BorderColor = 53,
            BorderDashDot = 54,
            BorderDashDotDot = 55,
            BorderDashes = 56,
            BorderDots = 57,
            BorderShortDashes = 58,
            BorderSolid = 59,
            BorderSparseDots = 60,
            BorderWidth1 = 61,
            BorderWidth2 = 62,
            BorderWidth3 = 63,
            BorderWidth4 = 64,
            BorderWidth5 = 65,
            BorderWidth6 = 66,
            BorderWidthHairline = 67,
            Flat = 68,
            ForeColor = 69,
            Italic = 70,
            JustifyCenter = 71,
            JustifyGeneral = 72,
            JustifyLeft = 73,
            JustifyRight = 74,
            Raised = 75,
            Sunken = 76,
            Underline = 77,
            Chiseled = 78,
            Etched = 79,
            Shadowed = 80,
            CompDebug1 = 81,
            CompDebug2 = 82,
            CompDebug3 = 83,
            CompDebug4 = 84,
            CompDebug5 = 85,
            CompDebug6 = 86,
            CompDebug7 = 87,
            CompDebug8 = 88,
            CompDebug9 = 89,
            CompDebug10 = 90,
            CompDebug11 = 91,
            CompDebug12 = 92,
            CompDebug13 = 93,
            CompDebug14 = 94,
            CompDebug15 = 95,
            ExistingSchemaEdit = 96,
            Find = 97,
            GetZoom = 98,
            QueryOpenDesign = 99,
            QueryOpenNew = 100,
            SingleTableDesign = 101,
            SingleTableNew = 102,
            ShowGrid = 103,
            NewTable = 104,
            CollapsedView = 105,
            FieldView = 106,
            VerifySQL = 107,
            HideTable = 108,

            PrimaryKey = 109,
            Save = 110,
            SaveAs = 111,
            SortAscending = 112,

            SortDescending = 113,
            AppendQuery = 114,
            CrosstabQuery = 115,
            DeleteQuery = 116,
            MakeTableQuery = 117,

            SelectQuery = 118,
            UpdateQuery = 119,
            Parameters = 120,
            Totals = 121,
            ViewCollapsed = 122,

            ViewFieldList = 123,


            ViewKeys = 124,
            ViewGrid = 125,
            InnerJoin = 126,

            RightOuterJoin = 127,
            LeftOuterJoin = 128,
            FullOuterJoin = 129,
            UnionJoin = 130,
            ShowSQLPane = 131,

            ShowGraphicalPane = 132,
            ShowDataPane = 133,
            ShowQBEPane = 134,
            SelectAllFields = 135,

            OLEObjectMenuButton = 136,

            // ids on the ole verbs menu - these must be sequential ie verblist0-verblist9
            ObjectVerbList0 = 137,
            ObjectVerbList1 = 138,
            ObjectVerbList2 = 139,
            ObjectVerbList3 = 140,
            ObjectVerbList4 = 141,
            ObjectVerbList5 = 142,
            ObjectVerbList6 = 143,
            ObjectVerbList7 = 144,
            ObjectVerbList8 = 145,
            ObjectVerbList9 = 146,  // Unused on purpose!

            ConvertObject = 147,
            CustomControl = 148,
            CustomizeItem = 149,
            Rename = 150,

            Import = 151,
            NewPage = 152,
            Move = 153,
            Cancel = 154,

            Font = 155,

            ExpandLinks = 156,
            ExpandImages = 157,
            ExpandPages = 158,
            RefocusDiagram = 159,
            TransitiveClosure = 160,
            CenterDiagram = 161,
            ZoomIn = 162,
            ZoomOut = 163,
            RemoveFilter = 164,
            HidePane = 165,
            DeleteTable = 166,
            DeleteRelationship = 167,
            Remove = 168,
            JoinLeftAll = 169,
            JoinRightAll = 170,
            AddToOutput = 171,      // Add selected fields to query output
            OtherQuery = 172,      // change query type to 'other'
            GenerateChangeScript = 173,
            SaveSelection = 174,     // Save current selection
            AutojoinCurrent = 175,     // Autojoin current tables
            AutojoinAlways = 176,     // Toggle Autojoin state
            EditPage = 177,     // Launch editor for url
            ViewLinks = 178,     // Launch new webscope for url
            Stop = 179,     // Stope webscope rendering
            Pause = 180,     // Pause webscope rendering
            Resume = 181,     // Resume webscope rendering
            FilterDiagram = 182,     // Filter webscope diagram
            ShowAllObjects = 183,     // Show All objects in webscope diagram
            ShowApplications = 184,     // Show Application objects in webscope diagram
            ShowOtherObjects = 185,     // Show other objects in webscope diagram
            ShowPrimRelationships = 186,     // Show primary relationships
            Expand = 187,     // Expand links
            Collapse = 188,     // Collapse links
            Refresh = 189,     // Refresh Webscope diagram
            Layout = 190,     // Layout websope diagram
            ShowResources = 191,     // Show resouce objects in webscope diagram
            InsertHTMLWizard = 192,     // Insert HTML using a Wizard
            ShowDownloads = 193,     // Show download objects in webscope diagram
            ShowExternals = 194,     // Show external objects in webscope diagram
            ShowInBoundLinks = 195,     // Show inbound links in webscope diagram
            ShowOutBoundLinks = 196,     // Show out bound links in webscope diagram
            ShowInAndOutBoundLinks = 197,     // Show in and out bound links in webscope diagram
            Preview = 198,     // Preview page
            Open = 261,     // Open
            OpenWith = 199,     // Open with
            ShowPages = 200,     // Show HTML pages
            RunQuery = 201,      // Runs a query
            ClearQuery = 202,      // Clears the query's associated cursor
            RecordFirst = 203,      // Go to first record in set
            RecordLast = 204,      // Go to last record in set
            RecordNext = 205,      // Go to next record in set
            RecordPrevious = 206,      // Go to previous record in set
            RecordGoto = 207,      // Go to record via dialog
            RecordNew = 208,      // Add a record to set

            InsertNewMenu = 209,     // menu designer
            InsertSeparator = 210,     // menu designer
            EditMenuNames = 211,     // menu designer

            DebugExplorer = 212,
            DebugProcesses = 213,
            ViewThreadsWindow = 214,
            WindowUIList = 215,

            // ids on the file menu
            NewProject = 216,
            OpenProject = 217,
            OpenProjectFromWeb = 450,
            OpenSolution = 218,
            CloseSolution = 219,
            FileNew = 221,
            NewProjectFromExisting = 385,
            FileOpen = 222,
            FileOpenFromWeb = 451,
            FileClose = 223,
            SaveSolution = 224,
            SaveSolutionAs = 225,
            SaveProjectItemAs = 226,
            PageSetup = 227,
            PrintPreview = 228,
            Exit = 229,

            // ids on the edit menu
            Replace = 230,
            Goto = 231,

            // ids on the view menu
            PropertyPages = 232,
            FullScreen = 233,
            ProjectExplorer = 234,
            PropertiesWindow = 235,
            TaskListWindow = 236,
            OutputWindow = 237,
            ObjectBrowser = 238,
            DocOutlineWindow = 239,
            ImmediateWindow = 240,
            WatchWindow = 241,
            LocalsWindow = 242,
            CallStack = 243,
            AutosWindow = DebugReserved1,
            ThisWindow = DebugReserved2,

            // ids on project menu
            AddNewItem = 220,
            AddExistingItem = 244,
            NewFolder = 245,
            SetStartupProject = 246,
            ProjectSettings = 247,
            ProjectReferences = 367,

            // ids on the debug menu
            StepInto = 248,
            StepOver = 249,
            StepOut = 250,
            RunToCursor = 251,
            AddWatch = 252,
            EditWatch = 253,
            QuickWatch = 254,

            ToggleBreakpoint = 255,
            ClearBreakpoints = 256,
            ShowBreakpoints = 257,
            SetNextStatement = 258,
            ShowNextStatement = 259,
            EditBreakpoint = 260,
            DetachDebugger = 262,

            // ids on the tools menu
            CustomizeKeyboard = 263,
            ToolsOptions = 264,

            // ids on the windows menu
            NewWindow = 265,
            Split = 266,
            Cascade = 267,
            TileHorz = 268,
            TileVert = 269,

            // ids on the help menu
            TechSupport = 270,

            // NOTE cmdidAbout and cmdidDebugOptions must be consecutive
            //      cmd after cmdidDebugOptions (ie 273) must not be used
            About = 271,
            DebugOptions = 272,

            // ids on the watch context menu
            // CollapseWatch appears as 'Collapse Parent', on any
            // non-top-level item
            DeleteWatch = 274,
            CollapseWatch = 275,
            // ids 276, 277, 278, 279, 280 are in use
            // below 
            // ids on the property browser context menu
            PbrsToggleStatus = 282,
            PropbrsHide = 283,

            // ids on the docking context menu
            DockingView = 284,
            HideActivePane = 285,
            // ids for window selection via keyboard
            PaneNextPane = 316,  //(listed below in order)
            PanePrevPane = 317,  //(listed below in order)
            PaneNextTab = 286,
            PanePrevTab = 287,
            PaneCloseToolWindow = 288,
            PaneActivateDocWindow = 289,
            DockingViewMDI = 290,
            DockingViewFloater = 291,
            AutoHideWindow = 292,
            MoveToDropdownBar = 293,
            FindCmd = 294,  // internal Find commands
            Start = 295,
            Restart = 296,

            AddinManager = 297,

            MultiLevelUndoList = 298,
            MultiLevelRedoList = 299,

            ToolboxAddTab = 300,
            ToolboxDeleteTab = 301,
            ToolboxRenameTab = 302,
            ToolboxTabMoveUp = 303,
            ToolboxTabMoveDown = 304,
            ToolboxRenameItem = 305,
            ToolboxListView = 306,
            //(below) cmdidSearchSetCombo        307

            WindowUIGetList = 308,
            InsertValuesQuery = 309,

            ShowProperties = 310,

            ThreadSuspend = 311,
            ThreadResume = 312,
            ThreadSetFocus = 313,
            DisplayRadix = 314,

            OpenProjectItem = 315,

            ClearPane = 318,
            GotoErrorTag = 319,

            TaskListSortByCategory = 320,
            TaskListSortByFileLine = 321,
            TaskListSortByPriority = 322,
            TaskListSortByDefaultSort = 323,
            TaskListShowTooltip = 324,
            TaskListFilterByNothing = 325,
            CancelEZDrag = 326,
            TaskListFilterByCategoryCompiler = 327,
            TaskListFilterByCategoryComment = 328,

            ToolboxAddItem = 329,
            ToolboxReset = 330,

            SaveProjectItem = 331,
            SaveOptions = 959,
            ViewForm = 332,
            ViewCode = 333,
            PreviewInBrowser = 334,
            BrowseWith = 336,
            SearchSetCombo = 307,
            SearchCombo = 337,
            EditLabel = 338,
            Exceptions = 339,
            DefineViews = 340,

            ToggleSelMode = 341,
            ToggleInsMode = 342,

            LoadUnloadedProject = 343,
            UnloadLoadedProject = 344,

            // ids on the treegrids (watch/local/threads/stack)
            ElasticColumn = 345,
            HideColumn = 346,

            TaskListPreviousView = 347,
            ZoomDialog = 348,

            // find/replace options
            FindHiddenText = 349,
            FindMatchCase = 350,
            FindWholeWord = 351,
            FindSimplePattern = 276,
            FindRegularExpression = 352,
            FindBackwards = 353,
            FindInSelection = 354,
            FindStop = 355,
            // UNUSED                               356
            FindInFiles = 277,
            ReplaceInFiles = 278,
            NextLocation = 279,  // next item in task list, find in files results, etc.
            PreviousLocation = 280,  // prev item "
            GotoQuick = 281,

            TaskListNextError = 357,
            TaskListPrevError = 358,
            TaskListFilterByCategoryUser = 359,
            TaskListFilterByCategoryShortcut = 360,
            TaskListFilterByCategoryHTML = 361,
            TaskListFilterByCurrentFile = 362,
            TaskListFilterByChecked = 363,
            TaskListFilterByUnchecked = 364,
            TaskListSortByDescription = 365,
            TaskListSortByChecked = 366,

            // 367 is used above in cmdidProjectReferences
            StartNoDebug = 368,
            // 369 is used above in cmdidLockControls

            FindNext = 370,
            FindPrev = 371,
            FindSelectedNext = 372,
            FindSelectedPrev = 373,
            SearchGetList = 374,
            InsertBreakpoint = 375,
            EnableBreakpoint = 376,
            F1Help = 377,

            //UNUSED 378-396

            MoveToNextEZCntr = 384,
            UpdateMarkerSpans = 386,
            MoveToPreviousEZCntr = 393,

            ProjectProperties = 396,
            PropSheetOrProperties = 397,

            // NOTE - the next items are debug only !!
            TshellStep = 398,
            TshellRun = 399,

            // marker commands on the codewin menu
            MarkerCmd0 = 400,
            MarkerCmd1 = 401,
            MarkerCmd2 = 402,
            MarkerCmd3 = 403,
            MarkerCmd4 = 404,
            MarkerCmd5 = 405,
            MarkerCmd6 = 406,
            MarkerCmd7 = 407,
            MarkerCmd8 = 408,
            MarkerCmd9 = 409,
            MarkerLast = 409,
            MarkerEnd = 410,  // list terminator reserved

            // user-invoked project reload and unload
            ReloadProject = 412,
            UnloadProject = 413,

            NewBlankSolution = 414,
            SelectProjectTemplate = 415,

            // document outline commands
            DetachAttachOutline = 420,
            ShowHideOutline = 421,
            SyncOutline = 422,

            RunToCallstCursor = 423,
            NoCmdsAvailable = 424,

            ContextWindow = 427,
            Alias = 428,
            GotoCommandLine = 429,
            EvaluateExpression = 430,
            ImmediateMode = 431,
            EvaluateStatement = 432,

            FindResultWindow1 = 433,
            FindResultWindow2 = 434,

            // 500 is used above in cmdidFontNameGetList
            // 501 is used above in cmdidFontSizeGetList

            RenameBookmark = 559,
            ToggleBookmark = 560,
            DeleteBookmark = 561,
            BookmarkWindowGoToBookmark = 562,
            EnableBookmark = 564,
            NewBookmarkFolder = 565,
            NextBookmarkFolder = 568,
            PrevBookmarkFolder = 569,

            // ids on the window menu - these must be sequential ie window1-morewind
            Window1 = 570,
            Window2 = 571,
            Window3 = 572,
            Window4 = 573,
            Window5 = 574,
            Window6 = 575,
            Window7 = 576,
            Window8 = 577,
            Window9 = 578,
            Window10 = 579,
            Window11 = 580,
            Window12 = 581,
            Window13 = 582,
            Window14 = 583,
            Window15 = 584,
            Window16 = 585,
            Window17 = 586,
            Window18 = 587,
            Window19 = 588,
            Window20 = 589,
            Window21 = 590,
            Window22 = 591,
            Window23 = 592,
            Window24 = 593,
            Window25 = 594,    // note cmdidWindow25 is unused on purpose!
            MoreWindows = 595,

            AutoHideAllWindows = 597,
            TaskListTaskHelp = 598,

            ClassView = 599,

            MRUProj1 = 600,
            MRUProj2 = 601,
            MRUProj3 = 602,
            MRUProj4 = 603,
            MRUProj5 = 604,
            MRUProj6 = 605,
            MRUProj7 = 606,
            MRUProj8 = 607,
            MRUProj9 = 608,
            MRUProj10 = 609,
            MRUProj11 = 610,
            MRUProj12 = 611,
            MRUProj13 = 612,
            MRUProj14 = 613,
            MRUProj15 = 614,
            MRUProj16 = 615,
            MRUProj17 = 616,
            MRUProj18 = 617,
            MRUProj19 = 618,
            MRUProj20 = 619,
            MRUProj21 = 620,
            MRUProj22 = 621,
            MRUProj23 = 622,
            MRUProj24 = 623,
            MRUProj25 = 624,   // note cmdidMRUProj25 is unused on purpose!

            SplitNext = 625,
            SplitPrev = 626,

            CloseAllDocuments = 627,
            NextDocument = 628,
            PrevDocument = 629,

            Tool1 = 630,   // note cmdidTool1 - cmdidTool24 must be
            Tool2 = 631,   // consecutive
            Tool3 = 632,
            Tool4 = 633,
            Tool5 = 634,
            Tool6 = 635,
            Tool7 = 636,
            Tool8 = 637,
            Tool9 = 638,
            Tool10 = 639,
            Tool11 = 640,
            Tool12 = 641,
            Tool13 = 642,
            Tool14 = 643,
            Tool15 = 644,
            Tool16 = 645,
            Tool17 = 646,
            Tool18 = 647,
            Tool19 = 648,
            Tool20 = 649,
            Tool21 = 650,
            Tool22 = 651,
            Tool23 = 652,
            Tool24 = 653,
            ExternalCommands = 654,

            PasteNextTBXCBItem = 655,
            ToolboxShowAllTabs = 656,
            ProjectDependencies = 657,
            CloseDocument = 658,
            ToolboxSortItems = 659,

            ViewBarView1 = 660,    //UNUSED
            ViewBarView2 = 661,    //UNUSED
            ViewBarView3 = 662,    //UNUSED
            ViewBarView4 = 663,    //UNUSED
            ViewBarView5 = 664,    //UNUSED
            ViewBarView6 = 665,    //UNUSED
            ViewBarView7 = 666,    //UNUSED
            ViewBarView8 = 667,    //UNUSED
            ViewBarView9 = 668,    //UNUSED
            ViewBarView10 = 669,    //UNUSED
            ViewBarView11 = 670,    //UNUSED
            ViewBarView12 = 671,    //UNUSED
            ViewBarView13 = 672,    //UNUSED
            ViewBarView14 = 673,    //UNUSED
            ViewBarView15 = 674,    //UNUSED
            ViewBarView16 = 675,    //UNUSED
            ViewBarView17 = 676,    //UNUSED
            ViewBarView18 = 677,    //UNUSED
            ViewBarView19 = 678,    //UNUSED
            ViewBarView20 = 679,    //UNUSED
            ViewBarView21 = 680,    //UNUSED
            ViewBarView22 = 681,    //UNUSED
            ViewBarView23 = 682,    //UNUSED
            ViewBarView24 = 683,    //UNUSED

            SolutionCfg = 684,
            SolutionCfgGetList = 685,

            //
            // Schema table commands:
            // All invoke table property dialog and select appropriate page.
            //
            ManageIndexes = 675,
            ManageRelationships = 676,
            ManageConstraints = 677,

            TaskListCustomView1 = 678,
            TaskListCustomView2 = 679,
            TaskListCustomView3 = 680,
            TaskListCustomView4 = 681,
            TaskListCustomView5 = 682,
            TaskListCustomView6 = 683,
            TaskListCustomView7 = 684,
            TaskListCustomView8 = 685,
            TaskListCustomView9 = 686,
            TaskListCustomView10 = 687,
            TaskListCustomView11 = 688,
            TaskListCustomView12 = 689,
            TaskListCustomView13 = 690,
            TaskListCustomView14 = 691,
            TaskListCustomView15 = 692,
            TaskListCustomView16 = 693,
            TaskListCustomView17 = 694,
            TaskListCustomView18 = 695,
            TaskListCustomView19 = 696,
            TaskListCustomView20 = 697,
            TaskListCustomView21 = 698,
            TaskListCustomView22 = 699,
            TaskListCustomView23 = 700,
            TaskListCustomView24 = 701,
            TaskListCustomView25 = 702,
            TaskListCustomView26 = 703,
            TaskListCustomView27 = 704,
            TaskListCustomView28 = 705,
            TaskListCustomView29 = 706,
            TaskListCustomView30 = 707,
            TaskListCustomView31 = 708,
            TaskListCustomView32 = 709,
            TaskListCustomView33 = 710,
            TaskListCustomView34 = 711,
            TaskListCustomView35 = 712,
            TaskListCustomView36 = 713,
            TaskListCustomView37 = 714,
            TaskListCustomView38 = 715,
            TaskListCustomView39 = 716,
            TaskListCustomView40 = 717,
            TaskListCustomView41 = 718,
            TaskListCustomView42 = 719,
            TaskListCustomView43 = 720,
            TaskListCustomView44 = 721,
            TaskListCustomView45 = 722,
            TaskListCustomView46 = 723,
            TaskListCustomView47 = 724,
            TaskListCustomView48 = 725,
            TaskListCustomView49 = 726,
            TaskListCustomView50 = 727,  //not used on purpose, ends the list

            WhiteSpace = 728,

            CommandWindow = 729,
            CommandWindowMarkMode = 730,
            LogCommandWindow = 731,

            Shell = 732,

            SingleChar = 733,
            ZeroOrMore = 734,
            OneOrMore = 735,
            BeginLine = 736,
            EndLine = 737,
            BeginWord = 738,
            EndWord = 739,
            CharInSet = 740,
            CharNotInSet = 741,
            Or = 742,
            Escape = 743,
            TagExp = 744,

            // Regex builder context help menu commands
            PatternMatchHelp = 745,
            RegExList = 746,

            DebugReserved1 = 747,
            DebugReserved2 = 748,
            DebugReserved3 = 749,
            //USED ABOVE                        750
            //USED ABOVE                        751
            //USED ABOVE                        752
            //USED ABOVE                        753

            //Regex builder wildcard menu commands
            WildZeroOrMore = 754,
            WildSingleChar = 755,
            WildSingleDigit = 756,
            WildCharInSet = 757,
            WildCharNotInSet = 758,

            FindWhatText = 759,
            TaggedExp1 = 760,
            TaggedExp2 = 761,
            TaggedExp3 = 762,
            TaggedExp4 = 763,
            TaggedExp5 = 764,
            TaggedExp6 = 765,
            TaggedExp7 = 766,
            TaggedExp8 = 767,
            TaggedExp9 = 768,

            EditorWidgetClick = 769,  // param 0 is the moniker as VT_BSTR, param 1 is the buffer line as VT_I4, and param 2 is the buffer index as VT_I4
            CmdWinUpdateAC = 770,

            SlnCfgMgr = 771,

            AddNewProject = 772,
            AddExistingProject = 773,
            AddExistingProjFromWeb = 774,

            AutoHideContext1 = 776,
            AutoHideContext2 = 777,
            AutoHideContext3 = 778,
            AutoHideContext4 = 779,
            AutoHideContext5 = 780,
            AutoHideContext6 = 781,
            AutoHideContext7 = 782,
            AutoHideContext8 = 783,
            AutoHideContext9 = 784,
            AutoHideContext10 = 785,
            AutoHideContext11 = 786,
            AutoHideContext12 = 787,
            AutoHideContext13 = 788,
            AutoHideContext14 = 789,
            AutoHideContext15 = 790,
            AutoHideContext16 = 791,
            AutoHideContext17 = 792,
            AutoHideContext18 = 793,
            AutoHideContext19 = 794,
            AutoHideContext20 = 795,
            AutoHideContext21 = 796,
            AutoHideContext22 = 797,
            AutoHideContext23 = 798,
            AutoHideContext24 = 799,
            AutoHideContext25 = 800,
            AutoHideContext26 = 801,
            AutoHideContext27 = 802,
            AutoHideContext28 = 803,
            AutoHideContext29 = 804,
            AutoHideContext30 = 805,
            AutoHideContext31 = 806,
            AutoHideContext32 = 807,
            AutoHideContext33 = 808,   // must remain unused

            ShellNavBackward = 809,
            ShellNavForward = 810,

            ShellNavigate1 = 811,
            ShellNavigate2 = 812,
            ShellNavigate3 = 813,
            ShellNavigate4 = 814,
            ShellNavigate5 = 815,
            ShellNavigate6 = 816,
            ShellNavigate7 = 817,
            ShellNavigate8 = 818,
            ShellNavigate9 = 819,
            ShellNavigate10 = 820,
            ShellNavigate11 = 821,
            ShellNavigate12 = 822,
            ShellNavigate13 = 823,
            ShellNavigate14 = 824,
            ShellNavigate15 = 825,
            ShellNavigate16 = 826,
            ShellNavigate17 = 827,
            ShellNavigate18 = 828,
            ShellNavigate19 = 829,
            ShellNavigate20 = 830,
            ShellNavigate21 = 831,
            ShellNavigate22 = 832,
            ShellNavigate23 = 833,
            ShellNavigate24 = 834,
            ShellNavigate25 = 835,
            ShellNavigate26 = 836,
            ShellNavigate27 = 837,
            ShellNavigate28 = 838,
            ShellNavigate29 = 839,
            ShellNavigate30 = 840,
            ShellNavigate31 = 841,
            ShellNavigate32 = 842,
            ShellNavigate33 = 843,   // must remain unused

            ShellWindowNavigate1 = 844,
            ShellWindowNavigate2 = 845,
            ShellWindowNavigate3 = 846,
            ShellWindowNavigate4 = 847,
            ShellWindowNavigate5 = 848,
            ShellWindowNavigate6 = 849,
            ShellWindowNavigate7 = 850,
            ShellWindowNavigate8 = 851,
            ShellWindowNavigate9 = 852,
            ShellWindowNavigate10 = 853,
            ShellWindowNavigate11 = 854,
            ShellWindowNavigate12 = 855,
            ShellWindowNavigate13 = 856,
            ShellWindowNavigate14 = 857,
            ShellWindowNavigate15 = 858,
            ShellWindowNavigate16 = 859,
            ShellWindowNavigate17 = 860,
            ShellWindowNavigate18 = 861,
            ShellWindowNavigate19 = 862,
            ShellWindowNavigate20 = 863,
            ShellWindowNavigate21 = 864,
            ShellWindowNavigate22 = 865,
            ShellWindowNavigate23 = 866,
            ShellWindowNavigate24 = 867,
            ShellWindowNavigate25 = 868,
            ShellWindowNavigate26 = 869,
            ShellWindowNavigate27 = 870,
            ShellWindowNavigate28 = 871,
            ShellWindowNavigate29 = 872,
            ShellWindowNavigate30 = 873,
            ShellWindowNavigate31 = 874,
            ShellWindowNavigate32 = 875,
            ShellWindowNavigate33 = 876,   // must remain unused

            // ObjectSearch cmds
            OBSDoFind = 877,
            OBSMatchCase = 878,
            OBSMatchSubString = 879,
            OBSMatchWholeWord = 880,
            OBSMatchPrefix = 881,

            // build cmds
            BuildSln = 882,
            RebuildSln = 883,
            DeploySln = 884,
            CleanSln = 885,

            BuildSel = 886,
            RebuildSel = 887,
            DeploySel = 888,
            CleanSel = 889,

            CancelBuild = 890,
            BatchBuildDlg = 891,

            BuildCtx = 892,
            RebuildCtx = 893,
            DeployCtx = 894,
            CleanCtx = 895,

            QryManageIndexes = 896,
            PrintDefault = 897,         // quick print
            BrowseDoc = 898,
            ShowStartPage = 899,

            MRUFile1 = 900,
            MRUFile2 = 901,
            MRUFile3 = 902,
            MRUFile4 = 903,
            MRUFile5 = 904,
            MRUFile6 = 905,
            MRUFile7 = 906,
            MRUFile8 = 907,
            MRUFile9 = 908,
            MRUFile10 = 909,
            MRUFile11 = 910,
            MRUFile12 = 911,
            MRUFile13 = 912,
            MRUFile14 = 913,
            MRUFile15 = 914,
            MRUFile16 = 915,
            MRUFile17 = 916,
            MRUFile18 = 917,
            MRUFile19 = 918,
            MRUFile20 = 919,
            MRUFile21 = 920,
            MRUFile22 = 921,
            MRUFile23 = 922,
            MRUFile24 = 923,
            MRUFile25 = 924,   // note cmdidMRUFile25 is unused on purpose!

            //External Tools Context Menu Commands
            // continued at 1109
            ExtToolsCurPath = 925,
            ExtToolsCurDir = 926,
            ExtToolsCurFileName = 927,
            ExtToolsCurExtension = 928,
            ExtToolsProjDir = 929,
            ExtToolsProjFileName = 930,
            ExtToolsSlnDir = 931,
            ExtToolsSlnFileName = 932,


            // Object Browsing & ClassView cmds
            // Shared shell cmds (for accessing Object Browsing functionality)
            GotoDefn = 935,
            GotoDecl = 936,
            BrowseDefn = 937,
            SyncClassView = 938,
            ShowMembers = 939,
            ShowBases = 940,
            ShowDerived = 941,
            ShowDefns = 942,
            ShowRefs = 943,
            ShowCallers = 944,
            ShowCallees = 945,

            AddClass = 946,
            AddNestedClass = 947,
            AddInterface = 948,
            AddMethod = 949,
            AddProperty = 950,
            AddEvent = 951,
            AddVariable = 952,
            ImplementInterface = 953,
            Override = 954,
            AddFunction = 955,
            AddConnectionPoint = 956,
            AddIndexer = 957,

            BuildOrder = 958,
            //959 used above for cmdidSaveOptions

            // Object Browser Tool Specific cmds
            OBShowHidden = 960,
            OBEnableGrouping = 961,
            OBSetGroupingCriteria = 962,
            OBBack = 963,
            OBForward = 964,
            OBShowPackages = 965,
            OBSearchCombo = 966,
            OBSearchOptWholeWord = 967,
            OBSearchOptSubstring = 968,
            OBSearchOptPrefix = 969,
            OBSearchOptCaseSensitive = 970,

            // ClassView Tool Specific cmds
            CVGroupingNone = 971,
            CVGroupingSortOnly = 972,
            CVGroupingGrouped = 973,
            CVShowPackages = 974,
            CVNewFolder = 975,
            CVGroupingSortAccess = 976,

            ObjectSearch = 977,
            ObjectSearchResults = 978,

            // Further Obj Browsing cmds at 1095

            // build cascade menus
            Build1 = 979,
            Build2 = 980,
            Build3 = 981,
            Build4 = 982,
            Build5 = 983,
            Build6 = 984,
            Build7 = 985,
            Build8 = 986,
            Build9 = 987,
            BuildLast = 988,

            Rebuild1 = 989,
            Rebuild2 = 990,
            Rebuild3 = 991,
            Rebuild4 = 992,
            Rebuild5 = 993,
            Rebuild6 = 994,
            Rebuild7 = 995,
            Rebuild8 = 996,
            Rebuild9 = 997,
            RebuildLast = 998,

            Clean1 = 999,
            Clean2 = 1000,
            Clean3 = 1001,
            Clean4 = 1002,
            Clean5 = 1003,
            Clean6 = 1004,
            Clean7 = 1005,
            Clean8 = 1006,
            Clean9 = 1007,
            CleanLast = 1008,

            Deploy1 = 1009,
            Deploy2 = 1010,
            Deploy3 = 1011,
            Deploy4 = 1012,
            Deploy5 = 1013,
            Deploy6 = 1014,
            Deploy7 = 1015,
            Deploy8 = 1016,
            Deploy9 = 1017,
            DeployLast = 1018,

            BuildProjPicker = 1019,
            RebuildProjPicker = 1020,
            CleanProjPicker = 1021,
            DeployProjPicker = 1022,
            ResourceView = 1023,

            ShowHomePage = 1024,
            EditMenuIDs = 1025,

            LineBreak = 1026,
            CPPIdentifier = 1027,
            QuotedString = 1028,
            SpaceOrTab = 1029,
            Integer = 1030,
            //unused 1031-1035

            CustomizeToolbars = 1036,
            MoveToTop = 1037,
            WindowHelp = 1038,

            ViewPopup = 1039,
            CheckMnemonics = 1040,

            PRSortAlphabeticaly = 1041,
            PRSortByCategory = 1042,

            ViewNextTab = 1043,

            CheckForUpdates = 1044,

            Browser1 = 1045,
            Browser2 = 1046,
            Browser3 = 1047,
            Browser4 = 1048,
            Browser5 = 1049,
            Browser6 = 1050,
            Browser7 = 1051,
            Browser8 = 1052,
            Browser9 = 1053,
            Browser10 = 1054,
            Browser11 = 1055,  //note unused on purpose to end list

            OpenDropDownOpen = 1058,
            OpenDropDownOpenWith = 1059,

            ToolsDebugProcesses = 1060,

            PaneNextSubPane = 1062,
            PanePrevSubPane = 1063,

            MoveFileToProject1 = 1070,
            MoveFileToProject2 = 1071,
            MoveFileToProject3 = 1072,
            MoveFileToProject4 = 1073,
            MoveFileToProject5 = 1074,
            MoveFileToProject6 = 1075,
            MoveFileToProject7 = 1076,
            MoveFileToProject8 = 1077,
            MoveFileToProject9 = 1078,
            MoveFileToProjectLast = 1079,  // unused in order to end list
            MoveFileToProjectPick = 1081,

            DefineSubset = 1095,
            SubsetCombo = 1096,
            SubsetGetList = 1097,
            OBSortObjectsAlpha = 1098,
            OBSortObjectsType = 1099,
            OBSortObjectsAccess = 1100,
            OBGroupObjectsType = 1101,
            OBGroupObjectsAccess = 1102,
            OBSortMembersAlpha = 1103,
            OBSortMembersType = 1104,
            OBSortMembersAccess = 1105,

            PopBrowseContext = 1106,
            GotoRef = 1107,
            OBSLookInReferences = 1108,

            ExtToolsTargetPath = 1109,
            ExtToolsTargetDir = 1110,
            ExtToolsTargetFileName = 1111,
            ExtToolsTargetExtension = 1112,
            ExtToolsCurLine = 1113,
            ExtToolsCurCol = 1114,
            ExtToolsCurText = 1115,

            BrowseNext = 1116,
            BrowsePrev = 1117,
            BrowseUnload = 1118,
            QuickObjectSearch = 1119,
            ExpandAll = 1120,
            ExtToolsBinDir = 1121,
            BookmarkWindow = 1122,
            CodeExpansionWindow = 1123,

            NextDocumentNav = 1124,
            PrevDocumentNav = 1125,
            ForwardBrowseContext = 1126,

            StandardMax = 1500,

            FindReferences = 1915,

            ///////////////////////////////////////////
            //
            // cmdidStandardMax is now thought to be
            // obsolete. Any new shell commands should
            // be added to the end of StandardCommandSet2K
            // which appears below.
            //
            // If you are not adding shell commands,
            // you shouldn't be doing it in this file! 
            //
            ///////////////////////////////////////////


            FormsFirst = 0x00006000,

            FormsLast = 0x00006FFF,

            VBEFirst = 0x00008000,


            Zoom200 = 0x00008002,
            Zoom150 = 0x00008003,
            Zoom100 = 0x00008004,
            Zoom75 = 0x00008005,
            Zoom50 = 0x00008006,
            Zoom25 = 0x00008007,
            Zoom10 = 0x00008010,


            VBELast = 0x00009FFF,

            SterlingFirst = 0x0000A000,
            SterlingLast = 0x0000BFFF,

            uieventidFirst = 0xC000,
            uieventidSelectRegion = 0xC001,
            uieventidDrop = 0xC002,
            uieventidLast = 0xDFFF,
        }

        /// <summary>
        /// GUID for the 2K command set. This is a set of standard editor commands.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid VSStd2K = new Guid("{1496A755-94DE-11D0-8C3F-00C04FC2AAE2}");

        /// <summary>
        /// Set of the standard, shared editor commands in StandardCommandSet2k.
        /// </summary>
        [Guid("1496A755-94DE-11D0-8C3F-00C04FC2AAE2")]
        public enum VSStd2KCmdID
        {
            TYPECHAR = 1,
            BACKSPACE = 2,
            RETURN = 3,
            TAB = 4,  // test
            ECMD_TAB = 4,
            BACKTAB = 5,
            DELETE = 6,
            LEFT = 7,
            LEFT_EXT = 8,
            RIGHT = 9,
            RIGHT_EXT = 10,
            UP = 11,
            UP_EXT = 12,
            DOWN = 13,
            DOWN_EXT = 14,
            HOME = 15,
            HOME_EXT = 16,
            END = 17,
            END_EXT = 18,
            BOL = 19,
            BOL_EXT = 20,
            FIRSTCHAR = 21,
            FIRSTCHAR_EXT = 22,
            EOL = 23,
            EOL_EXT = 24,
            LASTCHAR = 25,
            LASTCHAR_EXT = 26,
            PAGEUP = 27,
            PAGEUP_EXT = 28,
            PAGEDN = 29,
            PAGEDN_EXT = 30,
            TOPLINE = 31,
            TOPLINE_EXT = 32,
            BOTTOMLINE = 33,
            BOTTOMLINE_EXT = 34,
            SCROLLUP = 35,
            SCROLLDN = 36,
            SCROLLPAGEUP = 37,
            SCROLLPAGEDN = 38,
            SCROLLLEFT = 39,
            SCROLLRIGHT = 40,
            SCROLLBOTTOM = 41,
            SCROLLCENTER = 42,
            SCROLLTOP = 43,
            SELECTALL = 44,
            SELTABIFY = 45,
            SELUNTABIFY = 46,
            SELLOWCASE = 47,
            SELUPCASE = 48,
            SELTOGGLECASE = 49,
            SELTITLECASE = 50,
            SELSWAPANCHOR = 51,
            GOTOLINE = 52,
            GOTOBRACE = 53,
            GOTOBRACE_EXT = 54,
            GOBACK = 55,
            SELECTMODE = 56,
            TOGGLE_OVERTYPE_MODE = 57,
            CUT = 58,
            COPY = 59,
            PASTE = 60,
            CUTLINE = 61,
            DELETELINE = 62,
            DELETEBLANKLINES = 63,
            DELETEWHITESPACE = 64,
            DELETETOEOL = 65,
            DELETETOBOL = 66,
            OPENLINEABOVE = 67,
            OPENLINEBELOW = 68,
            INDENT = 69,
            UNINDENT = 70,
            UNDO = 71,
            UNDONOMOVE = 72,
            REDO = 73,
            REDONOMOVE = 74,
            DELETEALLTEMPBOOKMARKS = 75,
            TOGGLETEMPBOOKMARK = 76,
            GOTONEXTBOOKMARK = 77,
            GOTOPREVBOOKMARK = 78,
            FIND = 79,
            REPLACE = 80,
            REPLACE_ALL = 81,
            FINDNEXT = 82,
            FINDNEXTWORD = 83,
            FINDPREV = 84,
            FINDPREVWORD = 85,
            FINDAGAIN = 86,
            TRANSPOSECHAR = 87,
            TRANSPOSEWORD = 88,
            TRANSPOSELINE = 89,
            SELECTCURRENTWORD = 90,
            DELETEWORDRIGHT = 91,
            DELETEWORDLEFT = 92,
            WORDPREV = 93,
            WORDPREV_EXT = 94,
            WORDNEXT = 96,
            WORDNEXT_EXT = 97,
            COMMENTBLOCK = 98,
            UNCOMMENTBLOCK = 99,
            SETREPEATCOUNT = 100,
            WIDGETMARGIN_LBTNDOWN = 101,
            SHOWCONTEXTMENU = 102,
            CANCEL = 103,
            PARAMINFO = 104,
            TOGGLEVISSPACE = 105,
            TOGGLECARETPASTEPOS = 106,
            COMPLETEWORD = 107,
            SHOWMEMBERLIST = 108,
            FIRSTNONWHITEPREV = 109,
            FIRSTNONWHITENEXT = 110,
            HELPKEYWORD = 111,
            FORMATSELECTION = 112,
            OPENURL = 113,
            INSERTFILE = 114,
            TOGGLESHORTCUT = 115,
            QUICKINFO = 116,
            LEFT_EXT_COL = 117,
            RIGHT_EXT_COL = 118,
            UP_EXT_COL = 119,
            DOWN_EXT_COL = 120,
            TOGGLEWORDWRAP = 121,
            ISEARCH = 122,
            ISEARCHBACK = 123,
            BOL_EXT_COL = 124,
            EOL_EXT_COL = 125,
            WORDPREV_EXT_COL = 126,
            WORDNEXT_EXT_COL = 127,
            OUTLN_HIDE_SELECTION = 128,
            OUTLN_TOGGLE_CURRENT = 129,
            OUTLN_TOGGLE_ALL = 130,
            OUTLN_STOP_HIDING_ALL = 131,
            OUTLN_STOP_HIDING_CURRENT = 132,
            OUTLN_COLLAPSE_TO_DEF = 133,
            DOUBLECLICK = 134,
            EXTERNALLY_HANDLED_WIDGET_CLICK = 135,
            COMMENT_BLOCK = 136,
            UNCOMMENT_BLOCK = 137,
            OPENFILE = 138,
            NAVIGATETOURL = 139,

            // For editor internal use only
            HANDLEIMEMESSAGE = 140,

            SELTOGOBACK = 141,
            COMPLETION_HIDE_ADVANCED = 142,

            FORMATDOCUMENT = 143,
            OUTLN_START_AUTOHIDING = 144,

            // Last Standard Editor Command (+1)
            FINAL = 145,

            ECMD_DECREASEFILTER = 146,
            ECMD_COPYTIP = 148,
            ECMD_PASTETIP = 149,
            ECMD_LEFTCLICK = 150,
            ECMD_GOTONEXTBOOKMARKINDOC = 151,
            ECMD_GOTOPREVBOOKMARKINDOC = 152,
            ECMD_INVOKESNIPPETFROMSHORTCUT = 154,

            AUTOCOMPLETE = 155,

            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_INVOKESNIPPETPICKER2"]/*' />
            ECMD_INVOKESNIPPETPICKER2 = 156,
            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_DELETEALLBOOKMARKSINDOC"]/*' />
            ECMD_DELETEALLBOOKMARKSINDOC = 157,
            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONVERTTABSTOSPACES"]/*' />
            ECMD_CONVERTTABSTOSPACES = 158,
            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONVERTSPACESTOTABS"]/*' />
            ECMD_CONVERTSPACESTOTABS = 159,
            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_FINAL"]/*' />
            ECMD_FINAL = 160,

            ///////////////////////////////////////////////////////////////
            // Some new commands created during CTC file rationalisation
            ///////////////////////////////////////////////////////////////
            STOP = 220,
            REVERSECANCEL = 221,
            SLNREFRESH = 222,
            SAVECOPYOFITEMAS = 223,
            //
            // Shareable commands originating in the HTML editor
            //
            NEWELEMENT = 224,
            NEWATTRIBUTE = 225,
            NEWCOMPLEXTYPE = 226,
            NEWSIMPLETYPE = 227,
            NEWGROUP = 228,
            NEWATTRIBUTEGROUP = 229,
            NEWKEY = 230,
            NEWRELATION = 231,
            EDITKEY = 232,
            EDITRELATION = 233,
            MAKETYPEGLOBAL = 234,
            PREVIEWDATASET = 235,
            GENERATEDATASET = 236,
            CREATESCHEMA = 237,
            LAYOUTINDENT = 238,
            LAYOUTUNINDENT = 239,
            REMOVEHANDLER = 240,
            EDITHANDLER = 241,
            ADDHANDLER = 242,
            STYLE = 243,
            STYLEGETLIST = 244,
            FONTSTYLE = 245,
            FONTSTYLEGETLIST = 246,
            PASTEASHTML = 247,
            VIEWBORDERS = 248,
            VIEWDETAILS = 249,
            EXPANDCONTROLS = 250,
            COLLAPSECONTROLS = 251,
            SHOWSCRIPTONLY = 252,
            INSERTTABLE = 253,
            INSERTCOLLEFT = 254,
            INSERTCOLRIGHT = 255,
            INSERTROWABOVE = 256,
            INSERTROWBELOW = 257,
            DELETETABLE = 258,
            DELETECOLS = 259,
            DELETEROWS = 260,
            SELECTTABLE = 261,
            SELECTTABLECOL = 262,
            SELECTTABLEROW = 263,
            SELECTTABLECELL = 264,
            MERGECELLS = 265,
            SPLITCELL = 266,
            INSERTCELL = 267,
            DELETECELLS = 268,
            SEAMLESSFRAME = 269,
            VIEWFRAME = 270,
            DELETEFRAME = 271,
            SETFRAMESOURCE = 272,
            NEWLEFTFRAME = 273,
            NEWRIGHTFRAME = 274,
            NEWTOPFRAME = 275,
            NEWBOTTOMFRAME = 276,
            SHOWGRID = 277,
            SNAPTOGRID = 278,
            BOOKMARK = 279,
            HYPERLINK = 280,
            IMAGE = 281,
            INSERTFORM = 282,
            INSERTSPAN = 283,
            DIV = 284,
            HTMLCLIENTSCRIPTBLOCK = 285,
            HTMLSERVERSCRIPTBLOCK = 286,
            BULLETEDLIST = 287,
            NUMBEREDLIST = 288,
            EDITSCRIPT = 289,
            EDITCODEBEHIND = 290,
            DOCOUTLINEHTML = 291,
            DOCOUTLINESCRIPT = 292,
            RUNATSERVER = 293,
            WEBFORMSVERBS = 294,
            WEBFORMSTEMPLATES = 295,
            ENDTEMPLATE = 296,
            EDITDEFAULTEVENT = 297,
            SUPERSCRIPT = 298,
            SUBSCRIPT = 299,
            EDITSTYLE = 300,
            ADDIMAGEHEIGHTWIDTH = 301,
            REMOVEIMAGEHEIGHTWIDTH = 302,
            LOCKELEMENT = 303,
            VIEWSTYLEORGANIZER = 304,
            ECMD_AUTOCLOSEOVERRIDE = 305,
            NEWANY = 306,
            NEWANYATTRIBUTE = 307,
            DELETEKEY = 308,
            AUTOARRANGE = 309,
            VALIDATESCHEMA = 310,
            NEWFACET = 311,
            VALIDATEXMLDATA = 312,
            DOCOUTLINETOGGLE = 313,
            VALIDATEHTMLDATA = 314,
            VIEWXMLSCHEMAOVERVIEW = 315,
            SHOWDEFAULTVIEW = 316,
            EXPAND_CHILDREN = 317,
            COLLAPSE_CHILDREN = 318,
            TOPDOWNLAYOUT = 319,
            LEFTRIGHTLAYOUT = 320,
            INSERTCELLRIGHT = 321,
            EDITMASTER = 322,
            INSERTSNIPPET = 323,
            FORMATANDVALIDATION = 324,
            COLLAPSETAG = 325,
            SELECT_TAG = 329,
            SELECT_TAG_CONTENT = 330,
            CHECK_ACCESSIBILITY = 331,
            UNCOLLAPSETAG = 332,
            GENERATEPAGERESOURCE = 333,
            SHOWNONVISUALCONTROLS = 334,
            RESIZECOLUMN = 335,
            RESIZEROW = 336,
            MAKEABSOLUTE = 337,
            MAKERELATIVE = 338,
            MAKESTATIC = 339,
            INSERTLAYER = 340,
            UPDATEDESIGNVIEW = 341,
            UPDATESOURCEVIEW = 342,
            INSERTCAPTION = 343,
            DELETECAPTION = 344,
            MAKEPOSITIONNOTSET = 345,
            AUTOPOSITIONOPTIONS = 346,
            EDITIMAGE = 347,
            //
            // Shareable commands originating in the VC project
            //
            COMPILE = 350,
            //
            PROJSETTINGS = 352,
            LINKONLY = 353,
            //
            REMOVE = 355,
            PROJSTARTDEBUG = 356,
            PROJSTEPINTO = 357,
            ECMD_UPDATEMGDRES = 358,
            //
            //
            UPDATEWEBREF = 360,
            //
            ADDRESOURCE = 362,
            WEBDEPLOY = 363,
            ECMD_PROJTOOLORDER = 367,
            ECMD_PROJECTTOOLFILES = 368,
            ECMD_OTB_PGO_INSTRUMENT = 369,
            ECMD_OTB_PGO_OPT = 370,
            ECMD_OTB_PGO_UPDATE = 371,
            ECMD_OTB_PGO_RUNSCENARIO = 372,

            //
            // Shareable commands originating in the VB and VBA projects
            // Note that there are two versions of each command. One
            // version is originally from the main (project) menu and the
            // other version from a cascading "Add" context menu. The main
            // difference between the two commands is that the main menu
            // version starts with the text "Add" whereas this is not
            // present on the context menu version.
            //
            ADDHTMLPAGE = 400,
            ADDHTMLPAGECTX = 401,
            ADDMODULE = 402,
            ADDMODULECTX = 403,
            // unused 404
            // unused 405
            ADDWFCFORM = 406,
            // unused 407
            // unused 408
            // unused 409
            ADDWEBFORM = 410,
            ECMD_ADDMASTERPAGE = 411,
            ADDUSERCONTROL = 412,
            ECMD_ADDCONTENTPAGE = 413,
            // unused 414 to 425
            ADDDHTMLPAGE = 426,
            // unused 427 to 431
            ADDIMAGEGENERATOR = 432,
            // unused 433
            ADDINHERWFCFORM = 434,
            // unused 435
            ADDINHERCONTROL = 436,
            // unused 437
            ADDWEBUSERCONTROL = 438,
            BUILDANDBROWSE = 439,
            // unused 440
            // unused 441
            ADDTBXCOMPONENT = 442,
            // unused 443
            ADDWEBSERVICE = 444,
            ECMD_ADDSTYLESHEET = 445,
            ECMD_SETBROWSELOCATION = 446,
            ECMD_REFRESHFOLDER = 447,
            ECMD_SETBROWSELOCATIONCTX = 448,
            ECMD_VIEWMARKUP = 449,
            ECMD_NEXTMETHOD = 450,
            ECMD_PREVMETHOD = 451,
            //
            // VB refactoring commands
            //
            ECMD_RENAMESYMBOL = 452,
            ECMD_SHOWREFERENCES = 453,
            ECMD_CREATESNIPPET = 454,
            ECMD_CREATEREPLACEMENT = 455,
            ECMD_INSERTCOMMENT = 456,
            VIEWCOMPONENTDESIGNER = 457,
            GOTOTYPEDEF = 458,
            SHOWSNIPPETHIGHLIGHTING = 459,
            HIDESNIPPETHIGHLIGHTING = 460,
            //
            // Shareable commands originating in the VFP project
            //
            ADDVFPPAGE = 500,
            SETBREAKPOINT = 501,
            //
            // Shareable commands originating in the HELP WORKSHOP project
            //
            SHOWALLFILES = 600,
            ADDTOPROJECT = 601,
            ADDBLANKNODE = 602,
            ADDNODEFROMFILE = 603,
            CHANGEURLFROMFILE = 604,
            EDITTOPIC = 605,
            EDITTITLE = 606,
            MOVENODEUP = 607,
            MOVENODEDOWN = 608,
            MOVENODELEFT = 609,
            MOVENODERIGHT = 610,
            //
            // Shareable commands originating in the Deploy project
            //
            // Note there are two groups of deploy project commands.
            // The first group of deploy commands.
            ADDOUTPUT = 700,
            ADDFILE = 701,
            MERGEMODULE = 702,
            ADDCOMPONENTS = 703,
            LAUNCHINSTALLER = 704,
            LAUNCHUNINSTALL = 705,
            LAUNCHORCA = 706,
            FILESYSTEMEDITOR = 707,
            REGISTRYEDITOR = 708,
            FILETYPESEDITOR = 709,
            USERINTERFACEEDITOR = 710,
            CUSTOMACTIONSEDITOR = 711,
            LAUNCHCONDITIONSEDITOR = 712,
            EDITOR = 713,
            EXCLUDE = 714,
            REFRESHDEPENDENCIES = 715,
            VIEWOUTPUTS = 716,
            VIEWDEPENDENCIES = 717,
            VIEWFILTER = 718,

            //
            // The Second group of deploy commands.
            // Note that there is a special sub-group in which the relative 
            // positions are important (see below)
            //
            KEY = 750,
            STRING = 751,
            BINARY = 752,
            DWORD = 753,
            KEYSOLO = 754,
            IMPORT = 755,
            FOLDER = 756,
            PROJECTOUTPUT = 757,
            FILE = 758,
            ADDMERGEMODULES = 759,
            CREATESHORTCUT = 760,
            LARGEICONS = 761,
            SMALLICONS = 762,
            LIST = 763,
            DETAILS = 764,
            ADDFILETYPE = 765,
            ADDACTION = 766,
            SETASDEFAULT = 767,
            MOVEUP = 768,
            MOVEDOWN = 769,
            ADDDIALOG = 770,
            IMPORTDIALOG = 771,
            ADDFILESEARCH = 772,
            ADDREGISTRYSEARCH = 773,
            ADDCOMPONENTSEARCH = 774,
            ADDLAUNCHCONDITION = 775,
            ADDCUSTOMACTION = 776,
            OUTPUTS = 777,
            DEPENDENCIES = 778,
            FILTER = 779,
            COMPONENTS = 780,
            ENVSTRING = 781,
            CREATEEMPTYSHORTCUT = 782,
            ADDFILECONDITION = 783,
            ADDREGISTRYCONDITION = 784,
            ADDCOMPONENTCONDITION = 785,
            ADDURTCONDITION = 786,
            ADDIISCONDITION = 787,

            //
            // The relative positions of the commands within the following deploy
            // subgroup must remain unaltered, although the group as a whole may
            // be repositioned. Note that the first and last elements are special
            // boundary elements.
            SPECIALFOLDERBASE = 800,
            USERSAPPLICATIONDATAFOLDER = 800,

            COMMONFILES64FOLDER = 801,
            COMMONFILESFOLDER = 802,
            CUSTOMFOLDER = 803,
            USERSDESKTOP = 804,
            USERSFAVORITESFOLDER = 805,
            FONTSFOLDER = 806,
            GLOBALASSEMBLYCACHEFOLDER = 807,
            MODULERETARGETABLEFOLDER = 808,
            USERSPERSONALDATAFOLDER = 809,
            PROGRAMFILES64FOLDER = 810,
            PROGRAMFILESFOLDER = 811,
            USERSPROGRAMSMENU = 812,
            USERSSENDTOMENU = 813,
            SHAREDCOMPONENTSFOLDER = 814,
            USERSSTARTMENU = 815,
            USERSSTARTUPFOLDER = 816,
            SYSTEM64FOLDER = 817,
            SYSTEMFOLDER = 818,
            APPLICATIONFOLDER = 819,
            USERSTEMPLATEFOLDER = 820,
            WEBCUSTOMFOLDER = 821,
            WINDOWSFOLDER = 822,
            SPECIALFOLDERLAST = 823,
            // End of deploy sub-group
            //
            // Shareable commands originating in the Visual Studio Analyzer project
            //
            EXPORTEVENTS = 900,
            IMPORTEVENTS = 901,
            VIEWEVENT = 902,
            VIEWEVENTLIST = 903,
            VIEWCHART = 904,
            VIEWMACHINEDIAGRAM = 905,
            VIEWPROCESSDIAGRAM = 906,
            VIEWSOURCEDIAGRAM = 907,
            VIEWSTRUCTUREDIAGRAM = 908,
            VIEWTIMELINE = 909,
            VIEWSUMMARY = 910,
            APPLYFILTER = 911,
            CLEARFILTER = 912,
            STARTRECORDING = 913,
            STOPRECORDING = 914,
            PAUSERECORDING = 915,
            ACTIVATEFILTER = 916,
            SHOWFIRSTEVENT = 917,
            SHOWPREVIOUSEVENT = 918,
            SHOWNEXTEVENT = 919,
            SHOWLASTEVENT = 920,
            REPLAYEVENTS = 921,
            STOPREPLAY = 922,
            INCREASEPLAYBACKSPEED = 923,
            DECREASEPLAYBACKSPEED = 924,
            ADDMACHINE = 925,
            ADDREMOVECOLUMNS = 926,
            SORTCOLUMNS = 927,
            SAVECOLUMNSETTINGS = 928,
            RESETCOLUMNSETTINGS = 929,
            SIZECOLUMNSTOFIT = 930,
            AUTOSELECT = 931,
            AUTOFILTER = 932,
            AUTOPLAYTRACK = 933,
            GOTOEVENT = 934,
            ZOOMTOFIT = 935,
            ADDGRAPH = 936,
            REMOVEGRAPH = 937,
            CONNECTMACHINE = 938,
            DISCONNECTMACHINE = 939,
            EXPANDSELECTION = 940,
            COLLAPSESELECTION = 941,
            ADDFILTER = 942,
            ADDPREDEFINED0 = 943,
            ADDPREDEFINED1 = 944,
            ADDPREDEFINED2 = 945,
            ADDPREDEFINED3 = 946,
            ADDPREDEFINED4 = 947,
            ADDPREDEFINED5 = 948,
            ADDPREDEFINED6 = 949,
            ADDPREDEFINED7 = 950,
            ADDPREDEFINED8 = 951,
            TIMELINESIZETOFIT = 952,

            //
            // Shareable commands originating with Crystal Reports
            //
            FIELDVIEW = 1000,
            SELECTEXPERT = 1001,
            TOPNEXPERT = 1002,
            SORTORDER = 1003,
            PROPPAGE = 1004,
            HELP = 1005,
            SAVEREPORT = 1006,
            INSERTSUMMARY = 1007,
            INSERTGROUP = 1008,
            INSERTSUBREPORT = 1009,
            INSERTCHART = 1010,
            INSERTPICTURE = 1011,
            //
            // Shareable commands from the common project area (DirPrj)
            //
            SETASSTARTPAGE = 1100,
            RECALCULATELINKS = 1101,
            WEBPERMISSIONS = 1102,
            COMPARETOMASTER = 1103,
            WORKOFFLINE = 1104,
            SYNCHRONIZEFOLDER = 1105,
            SYNCHRONIZEALLFOLDERS = 1106,
            COPYPROJECT = 1107,
            IMPORTFILEFROMWEB = 1108,
            INCLUDEINPROJECT = 1109,
            EXCLUDEFROMPROJECT = 1110,
            BROKENLINKSREPORT = 1111,
            ADDPROJECTOUTPUTS = 1112,
            ADDREFERENCE = 1113,
            ADDWEBREFERENCE = 1114,
            ADDWEBREFERENCECTX = 1115,
            UPDATEWEBREFERENCE = 1116,
            RUNCUSTOMTOOL = 1117,
            SETRUNTIMEVERSION = 1118,
            VIEWREFINOBJECTBROWSER = 1119,
            PUBLISH = 1120,
            PUBLISHCTX = 1121,
            STARTOPTIONS = 1124,
            ADDREFERENCECTX = 1125,
            // note cmdidPropertyManager is consuming 1126  and it shouldn't
            STARTOPTIONSCTX = 1127,
            DETACHLOCALDATAFILECTX = 1128,
            ADDSERVICEREFERENCE = 1129,
            ADDSERVICEREFERENCECTX = 1130,
            UPDATESERVICEREFERENCE = 1131,
            CONFIGURESERVICEREFERENCE = 1132,
            //
            // Shareable commands for right drag operations
            //
            DRAG_MOVE = 1140,
            DRAG_COPY = 1141,
            DRAG_CANCEL = 1142,

            //
            // Shareable commands from the VC resource editor
            //
            TESTDIALOG = 1200,
            SPACEACROSS = 1201,
            SPACEDOWN = 1202,
            TOGGLEGRID = 1203,
            TOGGLEGUIDES = 1204,
            SIZETOTEXT = 1205,
            CENTERVERT = 1206,
            CENTERHORZ = 1207,
            FLIPDIALOG = 1208,
            SETTABORDER = 1209,
            BUTTONRIGHT = 1210,
            BUTTONBOTTOM = 1211,
            AUTOLAYOUTGROW = 1212,
            AUTOLAYOUTNORESIZE = 1213,
            AUTOLAYOUTOPTIMIZE = 1214,
            GUIDESETTINGS = 1215,
            RESOURCEINCLUDES = 1216,
            RESOURCESYMBOLS = 1217,
            OPENBINARY = 1218,
            RESOURCEOPEN = 1219,
            RESOURCENEW = 1220,
            RESOURCENEWCOPY = 1221,
            INSERT = 1222,
            EXPORT = 1223,
            CTLMOVELEFT = 1224,
            CTLMOVEDOWN = 1225,
            CTLMOVERIGHT = 1226,
            CTLMOVEUP = 1227,
            CTLSIZEDOWN = 1228,
            CTLSIZEUP = 1229,
            CTLSIZELEFT = 1230,
            CTLSIZERIGHT = 1231,
            NEWACCELERATOR = 1232,
            CAPTUREKEYSTROKE = 1233,
            INSERTACTIVEXCTL = 1234,
            INVERTCOLORS = 1235,
            FLIPHORIZONTAL = 1236,
            FLIPVERTICAL = 1237,
            ROTATE90 = 1238,
            SHOWCOLORSWINDOW = 1239,
            NEWSTRING = 1240,
            NEWINFOBLOCK = 1241,
            DELETEINFOBLOCK = 1242,
            ADJUSTCOLORS = 1243,
            LOADPALETTE = 1244,
            SAVEPALETTE = 1245,
            CHECKMNEMONICS = 1246,
            DRAWOPAQUE = 1247,
            TOOLBAREDITOR = 1248,
            GRIDSETTINGS = 1249,
            NEWDEVICEIMAGE = 1250,
            OPENDEVICEIMAGE = 1251,
            DELETEDEVICEIMAGE = 1252,
            VIEWASPOPUP = 1253,
            CHECKMENUMNEMONICS = 1254,
            SHOWIMAGEGRID = 1255,
            SHOWTILEGRID = 1256,
            MAGNIFY = 1257,
            ResProps = 1258,
            IMPORTICONIMAGE = 1259,
            EXPORTICONIMAGE = 1260,
            OPENEXTERNALEDITOR = 1261,

            //
            // Shareable commands from the VC resource editor (Image editor toolbar)
            //
            PICKRECTANGLE = 1300,
            PICKREGION = 1301,
            PICKCOLOR = 1302,
            ERASERTOOL = 1303,
            FILLTOOL = 1304,
            PENCILTOOL = 1305,
            BRUSHTOOL = 1306,
            AIRBRUSHTOOL = 1307,
            LINETOOL = 1308,
            CURVETOOL = 1309,
            TEXTTOOL = 1310,
            RECTTOOL = 1311,
            OUTLINERECTTOOL = 1312,
            FILLEDRECTTOOL = 1313,
            ROUNDRECTTOOL = 1314,
            OUTLINEROUNDRECTTOOL = 1315,
            FILLEDROUNDRECTTOOL = 1316,
            ELLIPSETOOL = 1317,
            OUTLINEELLIPSETOOL = 1318,
            FILLEDELLIPSETOOL = 1319,
            SETHOTSPOT = 1320,
            ZOOMTOOL = 1321,
            ZOOM1X = 1322,
            ZOOM2X = 1323,
            ZOOM6X = 1324,
            ZOOM8X = 1325,
            TRANSPARENTBCKGRND = 1326,
            OPAQUEBCKGRND = 1327,
            //---------------------------------------------------
            // The commands ECMD_ERASERSMALL thru ECMD_LINELARGER
            // must be left in the same order for the use of the
            // Resource Editor - They may however be relocated as
            // a complete block
            //---------------------------------------------------
            ERASERSMALL = 1328,
            ERASERMEDIUM = 1329,
            ERASERLARGE = 1330,
            ERASERLARGER = 1331,
            CIRCLELARGE = 1332,
            CIRCLEMEDIUM = 1333,
            CIRCLESMALL = 1334,
            SQUARELARGE = 1335,
            SQUAREMEDIUM = 1336,
            SQUARESMALL = 1337,
            LEFTDIAGLARGE = 1338,
            LEFTDIAGMEDIUM = 1339,
            LEFTDIAGSMALL = 1340,
            RIGHTDIAGLARGE = 1341,
            RIGHTDIAGMEDIUM = 1342,
            RIGHTDIAGSMALL = 1343,
            SPLASHSMALL = 1344,
            SPLASHMEDIUM = 1345,
            SPLASHLARGE = 1346,
            LINESMALLER = 1347,
            LINESMALL = 1348,
            LINEMEDIUM = 1349,
            LINELARGE = 1350,
            LINELARGER = 1351,
            LARGERBRUSH = 1352,
            LARGEBRUSH = 1353,
            STDBRUSH = 1354,
            SMALLBRUSH = 1355,
            SMALLERBRUSH = 1356,
            ZOOMIN = 1357,
            ZOOMOUT = 1358,
            PREVCOLOR = 1359,
            PREVECOLOR = 1360,
            NEXTCOLOR = 1361,
            NEXTECOLOR = 1362,
            IMG_OPTIONS = 1363,

            //
            // Sharable Commands from Visual Web Developer (website projects)
            //
            STARTWEBADMINTOOL = 1400,
            NESTRELATEDFILES = 1401,

            //---------------------------------------------------

            //
            // Shareable commands from WINFORMS
            //
            CANCELDRAG = 1500,
            DEFAULTACTION = 1501,
            CTLMOVEUPGRID = 1502,
            CTLMOVEDOWNGRID = 1503,
            CTLMOVELEFTGRID = 1504,
            CTLMOVERIGHTGRID = 1505,
            CTLSIZERIGHTGRID = 1506,
            CTLSIZEUPGRID = 1507,
            CTLSIZELEFTGRID = 1508,
            CTLSIZEDOWNGRID = 1509,
            NEXTCTL = 1510,
            PREVCTL = 1511,

            RENAME = 1550,
            EXTRACTMETHOD = 1551,
            ENCAPSULATEFIELD = 1552,
            EXTRACTINTERFACE = 1553,
            PROMOTELOCAL = 1554,
            REMOVEPARAMETERS = 1555,
            REORDERPARAMETERS = 1556,
            GENERATEMETHODSTUB = 1557,
            IMPLEMENTINTERFACEIMPLICIT = 1558,
            IMPLEMENTINTERFACEEXPLICIT = 1559,
            IMPLEMENTABSTRACTCLASS = 1560,
            SURROUNDWITH = 1561,

            // this is coming in with the VS2K guid?
            QUICKOBJECTSEARCH = 1119,
            ToggleWordWrapOW = 1600,
            GotoNextLocationOW = 1601,
            GotoPrevLocationOW = 1602,
            BuildOnlyProject = 1603,
            RebuildOnlyProject = 1604,
            CleanOnlyProject = 1605,
            SetBuildStartupsOnlyOnRun = 1606,
            UnhideAll = 1607,
            HideFolder = 1608,
            UnhideFolders = 1609,
            CopyFullPathName = 1610,
            SaveFolderAsSolution = 1611,
            ManageUserSettings = 1612,
            NewSolutionFolder = 1613,
            ClearPaneOW = 1615,
            GotoErrorTagOW = 1616,
            GotoNextErrorTagOW = 1617,
            GotoPrevErrorTagOW = 1618,
            ClearPaneFR1 = 1619,
            GotoErrorTagFR1 = 1620,
            GotoNextErrorTagFR1 = 1621,
            GotoPrevErrorTagFR1 = 1622,
            ClearPaneFR2 = 1623,
            GotoErrorTagFR2 = 1624,
            GotoNextErrorTagFR2 = 1625,
            GotoPrevErrorTagFR2 = 1626,
            OutputPaneCombo = 1627,
            OutputPaneComboList = 1628,
            DisableDockingChanges = 1629,
            ToggleFloat = 1630,
            ResetLayout = 1631,
            NewSolutionFolderBar = 1638,
            DataShortcut = 1639,
            NextToolWindow = 1640,
            PrevToolWindow = 1641,
            BrowseToFileInExplorer = 1642,
            ShowEzMDIFileMenu = 1643,
            PrevToolWindowNav = 1645,
            StaticAnalysisOnlyProject = 1646,
            ECMD_RUNFXCOPSEL = 1647,
            CloseAllButThis = 1650,
            //
            // Class View commands
            //
            CVShowInheritedMembers = 1651,
            CVShowBaseTypes = 1652,
            CVShowDerivedTypes = 1653,
            CVShowHidden = 1654,
            CVBack = 1655,
            CVForward = 1656,
            CVSearchCombo = 1657,
            CVSearch = 1658,
            CVSortObjectsAlpha = 1659,
            CVSortObjectsType = 1660,
            CVSortObjectsAccess = 1661,
            CVGroupObjectsType = 1662,
            CVSortMembersAlpha = 1663,
            CVSortMembersType = 1664,
            CVSortMembersAccess = 1665,
            CVTypeBrowserSettings = 1666,
            CVViewMembersAsImplementor = 1667,
            CVViewMembersAsSubclass = 1668,
            CVViewMembersAsUser = 1669,
            CVReserved1 = 1670,
            CVReserved2 = 1671,
            CVShowProjectReferences = 1672,
            CVGroupMembersType = 1673,
            CVClearSearch = 1674,
            CVFilterToType = 1675,
            CVSortByBestMatch = 1676,
            CVSearchMRUList = 1677,
            CVViewOtherMembers = 1678,
            CVSearchCmd = 1679,
            CVGoToSearchCmd = 1680,

            ControlGallery = 1700,
            //
            // Object Browser commands
            //
            OBShowInheritedMembers = 1711,
            OBShowBaseTypes = 1712,
            OBShowDerivedTypes = 1713,
            OBShowHidden = 1714,
            OBBack = 1715,
            OBForward = 1716,
            OBSearchCombo = 1717,
            OBSearch = 1718,
            OBSortObjectsAlpha = 1719,
            OBSortObjectsType = 1720,
            OBSortObjectsAccess = 1721,
            OBGroupObjectsType = 1722,
            OBSortMembersAlpha = 1723,
            OBSortMembersType = 1724,
            OBSortMembersAccess = 1725,
            OBTypeBrowserSettings = 1726,
            OBViewMembersAsImplementor = 1727,
            OBViewMembersAsSubclass = 1728,
            OBViewMembersAsUser = 1729,
            OBNamespacesView = 1730,
            OBContainersView = 1731,
            OBReserved1 = 1732,
            OBGroupMembersType = 1733,
            OBClearSearch = 1734,
            OBFilterToType = 1735,
            OBSortByBestMatch = 1736,
            OBSearchMRUList = 1737,
            OBViewOtherMembers = 1738,
            OBSearchCmd = 1739,
            OBGoToSearchCmd = 1740,
            OBShowExtensionMembers = 1741,

            FullScreen2 = 1775,
            //
            // find symbol results sorting command
            //
            FSRSortObjectsAlpha = 1776,
            FSRSortByBestMatch = 1777,
            NavigateBack = 1800,
            NavigateForward = 1801,

            ECMD_CORRECTION_1 = 1900,
            ECMD_CORRECTION_2 = 1901,
            ECMD_CORRECTION_3 = 1902,
            ECMD_CORRECTION_4 = 1903,
            ECMD_CORRECTION_5 = 1904,
            ECMD_CORRECTION_6 = 1905,
            ECMD_CORRECTION_7 = 1906,
            ECMD_CORRECTION_8 = 1907,
            ECMD_CORRECTION_9 = 1908,
            ECMD_CORRECTION_10 = 1909,

            OBAddReference = 1914,
            [Obsolete("VSStd2KCmdID.FindReferences has been deprecated; please use VSStd97CmdID.FindReferences instead.", false)]
            FindReferences = 1915,

            CodeDefView = 1926,
            CodeDefViewGoToPrev = 1927,
            CodeDefViewGoToNext = 1928,
            CodeDefViewEditDefinition = 1929,
            CodeDefViewChooseEncoding = 1930,
            ViewInClassDiagram = 1931,
            ECMD_ADDDBTABLE = 1950,
            ECMD_ADDDATATABLE = 1951,
            ECMD_ADDFUNCTION = 1952,
            ECMD_ADDRELATION = 1953,
            ECMD_ADDKEY = 1954,
            ECMD_ADDCOLUMN = 1955,
            ECMD_CONVERT_DBTABLE = 1956,
            ECMD_CONVERT_DATATABLE = 1957,
            ECMD_GENERATE_DATABASE = 1958,
            ECMD_CONFIGURE_CONNECTIONS = 1959,
            ECMD_IMPORT_XMLSCHEMA = 1960,
            ECMD_SYNC_WITH_DATABASE = 1961,
            ECMD_CONFIGURE = 1962,
            ECMD_CREATE_DATAFORM = 1963,
            ECMD_CREATE_ENUM = 1964,
            ECMD_INSERT_FUNCTION = 1965,
            ECMD_EDIT_FUNCTION = 1966,
            ECMD_SET_PRIMARY_KEY = 1967,
            ECMD_INSERT_COLUMN = 1968,
            ECMD_AUTO_SIZE = 1969,
            ECMD_SHOW_RELATION_LABELS = 1970,
            VSDGenerateDataSet = 1971,
            VSDPreview = 1972,
            VSDConfigureAdapter = 1973,
            VSDViewDatasetSchema = 1974,
            VSDDatasetProperties = 1975,
            VSDParameterizeForm = 1976,
            VSDAddChildForm = 1977,
            ECMD_EDITCONSTRAINT = 1978,
            ECMD_DELETECONSTRAINT = 1979,
            ECMD_EDITDATARELATION = 1980,
            CloseProject = 1982,
            ReloadCommandBars = 1983,
            SolutionPlatform = 1990,
            SolutionPlatformGetList = 1991,
            ECMD_DATAACCESSOR = 2000,
            ECMD_ADD_DATAACCESSOR = 2001,
            ECMD_QUERY = 2002,
            ECMD_ADD_QUERY = 2003,
            ECMD_PUBLISHSELECTION = 2005,
            ECMD_PUBLISHSLNCTX = 2006,

            CallBrowserShowCallsTo = 2010,
            CallBrowserShowCallsFrom = 2011,
            CallBrowserShowNewCallsTo = 2012,
            CallBrowserShowNewCallsFrom = 2013,
            CallBrowser1ShowCallsTo = 2014,
            CallBrowser2ShowCallsTo = 2015,
            CallBrowser3ShowCallsTo = 2016,
            CallBrowser4ShowCallsTo = 2017,
            CallBrowser5ShowCallsTo = 2018,
            CallBrowser6ShowCallsTo = 2019,
            CallBrowser7ShowCallsTo = 2020,
            CallBrowser8ShowCallsTo = 2021,
            CallBrowser9ShowCallsTo = 2022,
            CallBrowser10ShowCallsTo = 2023,
            CallBrowser11ShowCallsTo = 2024,
            CallBrowser12ShowCallsTo = 2025,
            CallBrowser13ShowCallsTo = 2026,
            CallBrowser14ShowCallsTo = 2027,
            CallBrowser15ShowCallsTo = 2028,
            CallBrowser16ShowCallsTo = 2029,
            CallBrowser1ShowCallsFrom = 2030,
            CallBrowser2ShowCallsFrom = 2031,
            CallBrowser3ShowCallsFrom = 2032,
            CallBrowser4ShowCallsFrom = 2033,
            CallBrowser5ShowCallsFrom = 2034,
            CallBrowser6ShowCallsFrom = 2035,
            CallBrowser7ShowCallsFrom = 2036,
            CallBrowser8ShowCallsFrom = 2037,
            CallBrowser9ShowCallsFrom = 2038,
            CallBrowser10ShowCallsFrom = 2039,
            CallBrowser11ShowCallsFrom = 2040,
            CallBrowser12ShowCallsFrom = 2041,
            CallBrowser13ShowCallsFrom = 2042,
            CallBrowser14ShowCallsFrom = 2043,
            CallBrowser15ShowCallsFrom = 2044,
            CallBrowser16ShowCallsFrom = 2045,
            CallBrowser1ShowFullNames = 2046,
            CallBrowser2ShowFullNames = 2047,
            CallBrowser3ShowFullNames = 2048,
            CallBrowser4ShowFullNames = 2049,
            CallBrowser5ShowFullNames = 2050,
            CallBrowser6ShowFullNames = 2051,
            CallBrowser7ShowFullNames = 2052,
            CallBrowser8ShowFullNames = 2053,
            CallBrowser9ShowFullNames = 2054,
            CallBrowser10ShowFullNames = 2055,
            CallBrowser11ShowFullNames = 2056,
            CallBrowser12ShowFullNames = 2057,
            CallBrowser13ShowFullNames = 2058,
            CallBrowser14ShowFullNames = 2059,
            CallBrowser15ShowFullNames = 2060,
            CallBrowser16ShowFullNames = 2061,
            CallBrowser1Settings = 2062,
            CallBrowser2Settings = 2063,
            CallBrowser3Settings = 2064,
            CallBrowser4Settings = 2065,
            CallBrowser5Settings = 2066,
            CallBrowser6Settings = 2067,
            CallBrowser7Settings = 2068,
            CallBrowser8Settings = 2069,
            CallBrowser9Settings = 2070,
            CallBrowser10Settings = 2071,
            CallBrowser11Settings = 2072,
            CallBrowser12Settings = 2073,
            CallBrowser13Settings = 2074,
            CallBrowser14Settings = 2075,
            CallBrowser15Settings = 2076,
            CallBrowser16Settings = 2077,
            CallBrowser1SortAlpha = 2078,
            CallBrowser2SortAlpha = 2079,
            CallBrowser3SortAlpha = 2080,
            CallBrowser4SortAlpha = 2081,
            CallBrowser5SortAlpha = 2082,
            CallBrowser6SortAlpha = 2083,
            CallBrowser7SortAlpha = 2084,
            CallBrowser8SortAlpha = 2085,
            CallBrowser9SortAlpha = 2086,
            CallBrowser10SortAlpha = 2087,
            CallBrowser11SortAlpha = 2088,
            CallBrowser12SortAlpha = 2089,
            CallBrowser13SortAlpha = 2090,
            CallBrowser14SortAlpha = 2091,
            CallBrowser15SortAlpha = 2092,
            CallBrowser16SortAlpha = 2093,
            CallBrowser1SortAccess = 2094,
            CallBrowser2SortAccess = 2095,
            CallBrowser3SortAccess = 2096,
            CallBrowser4SortAccess = 2097,
            CallBrowser5SortAccess = 2098,
            CallBrowser6SortAccess = 2099,
            CallBrowser7SortAccess = 2100,
            CallBrowser8SortAccess = 2101,
            CallBrowser9SortAccess = 2102,
            CallBrowser10SortAccess = 2103,
            CallBrowser11SortAccess = 2104,
            CallBrowser12SortAccess = 2105,
            CallBrowser13SortAccess = 2106,
            CallBrowser14SortAccess = 2107,
            CallBrowser15SortAccess = 2108,
            CallBrowser16SortAccess = 2109,
            ShowCallBrowser = 2120,
            CallBrowser1 = 2121,
            CallBrowser2 = 2122,
            CallBrowser3 = 2123,
            CallBrowser4 = 2124,
            CallBrowser5 = 2125,
            CallBrowser6 = 2126,
            CallBrowser7 = 2127,
            CallBrowser8 = 2128,
            CallBrowser9 = 2129,
            CallBrowser10 = 2130,
            CallBrowser11 = 2131,
            CallBrowser12 = 2132,
            CallBrowser13 = 2133,
            CallBrowser14 = 2134,
            CallBrowser15 = 2135,
            CallBrowser16 = 2136,
            CallBrowser17 = 2137,
            GlobalUndo = 2138,
            GlobalRedo = 2139,
            CallBrowserShowCallsToCmd = 2140,
            CallBrowserShowCallsFromCmd = 2141,
            CallBrowserShowNewCallsToCmd = 2142,
            CallBrowserShowNewCallsFromCmd = 2143,
            CallBrowser1Search = 2145,
            CallBrowser2Search = 2146,
            CallBrowser3Search = 2147,
            CallBrowser4Search = 2148,
            CallBrowser5Search = 2149,
            CallBrowser6Search = 2150,
            CallBrowser7Search = 2151,
            CallBrowser8Search = 2152,
            CallBrowser9Search = 2153,
            CallBrowser10Search = 2154,
            CallBrowser11Search = 2155,
            CallBrowser12Search = 2156,
            CallBrowser13Search = 2157,
            CallBrowser14Search = 2158,
            CallBrowser15Search = 2159,
            CallBrowser16Search = 2160,
            CallBrowser1Refresh = 2161,
            CallBrowser2Refresh = 2162,
            CallBrowser3Refresh = 2163,
            CallBrowser4Refresh = 2164,
            CallBrowser5Refresh = 2165,
            CallBrowser6Refresh = 2166,
            CallBrowser7Refresh = 2167,
            CallBrowser8Refresh = 2168,
            CallBrowser9Refresh = 2169,
            CallBrowser10Refresh = 2170,
            CallBrowser11Refresh = 2171,
            CallBrowser12Refresh = 2172,
            CallBrowser13Refresh = 2173,
            CallBrowser14Refresh = 2174,
            CallBrowser15Refresh = 2175,
            CallBrowser16Refresh = 2176,
            CallBrowser1SearchCombo = 2180,
            CallBrowser2SearchCombo = 2181,
            CallBrowser3SearchCombo = 2182,
            CallBrowser4SearchCombo = 2183,
            CallBrowser5SearchCombo = 2184,
            CallBrowser6SearchCombo = 2185,
            CallBrowser7SearchCombo = 2186,
            CallBrowser8SearchCombo = 2187,
            CallBrowser9SearchCombo = 2188,
            CallBrowser10SearchCombo = 2189,
            CallBrowser11SearchCombo = 2190,
            CallBrowser12SearchCombo = 2191,
            CallBrowser13SearchCombo = 2192,
            CallBrowser14SearchCombo = 2193,
            CallBrowser15SearchCombo = 2194,
            CallBrowser16SearchCombo = 2195,

            TaskListProviderCombo = 2200,
            TaskListProviderComboList = 2201,
            CreateUserTask = 2202,
            ErrorListShowErrors = 2210,
            ErrorListShowWarnings = 2211,
            ErrorListShowMessages = 2212,
            Registration = 2214,
            CallBrowser1SearchComboList = 2215,
            CallBrowser2SearchComboList = 2216,
            CallBrowser3SearchComboList = 2217,
            CallBrowser4SearchComboList = 2218,
            CallBrowser5SearchComboList = 2219,
            CallBrowser6SearchComboList = 2220,
            CallBrowser7SearchComboList = 2221,
            CallBrowser8SearchComboList = 2222,
            CallBrowser9SearchComboList = 2223,
            CallBrowser10SearchComboList = 2224,
            CallBrowser11SearchComboList = 2225,
            CallBrowser12SearchComboList = 2226,
            CallBrowser13SearchComboList = 2227,
            CallBrowser14SearchComboList = 2228,
            CallBrowser15SearchComboList = 2229,
            CallBrowser16SearchComboList = 2230,

            SnippetProp = 2240,
            SnippetRef = 2241,
            SnippetRepl = 2242,

            StartPage = 2245,

            EditorLineFirstColumn = 2250,
            EditorLineFirstColumnExtend = 2251,

            SEServerExplorer = 2260,
            SEDataExplorer = 2261,

            ToggleConsumeFirstCompletionMode = 2303,

            ECMD_VALIDATION_TARGET = 11281,
            ECMD_VALIDATION_TARGET_GET_LIST = 11282,
            ECMD_CSS_TARGET = 11283,
            ECMD_CSS_TARGET_GET_LIST = 11284,
            Design = 0x3000,
            DesignOn = 0x3001,
            SEDesign = 0x3003,
            NewDiagram = 0x3004,
            NewTable = 0x3006,
            NewDBItem = 0x300E,
            NewTrigger = 0x3010,
            Debug = 0x3012,
            NewProcedure = 0x3013,
            NewQuery = 0x3014,
            RefreshLocal = 0x3015,
            DbAddDataConnection = 0x3017,
            DBDefDBRef = 0x3018,
            RunCmd = 0x3019,
            RunOn = 0x301A,
            NewDBRef = 0x301B,
            SetAsDef = 0x301C,
            CreateCmdFile = 0x301D,
            Cancel = 0x301E,
            NewDatabase = 0x3020,
            NewUser = 0x3021,
            NewRole = 0x3022,
            ChangeLogin = 0x3023,
            NewView = 0x3024,
            ModifyConnection = 0x3025,
            Disconnect = 0x3026,
            CopyScript = 0x3027,
            AddSCC = 0x3028,
            RemoveSCC = 0x3029,
            GetLatest = 0x3030,
            CheckOut = 0x3031,
            CheckIn = 0x3032,
            UndoCheckOut = 0x3033,
            AddItemSCC = 0x3034,
            NewPackageSpec = 0x3035,
            NewPackageBody = 0x3036,
            InsertSQL = 0x3037,
            RunSelection = 0x3038,
            UpdateScript = 0x3039,
            NewScript = 0x303C,
            NewFunction = 0x303D,
            NewTableFunction = 0x303E,
            NewInlineFunction = 0x303F,
            AddDiagram = 0x3040,
            AddTable = 0x3041,
            AddSynonym = 0x3042,
            AddView = 0x3043,
            AddProcedure = 0x3044,
            AddFunction = 0x3045,
            AddTableFunction = 0x3046,
            AddInlineFunction = 0x3047,
            AddPkgSpec = 0x3048,
            AddPkgBody = 0x3049,
            AddTrigger = 0x304A,
            ExportData = 0x304B,
            DbnsVcsAdd = 0x304C,
            DbnsVcsRemove = 0x304D,
            DbnsVcsCheckout = 0x304E,
            DbnsVcsUndoCheckout = 0x304F,
            DbnsVcsCheckin = 0x3050,
            SERetrieveData = 0x3060,
            SEEditTextObject = 0x3061,
            DesignSQLBlock = 0x3064,
            RegisterSQLInstance = 0x3065,
            UnregisterSQLInstance = 0x3066,
            CommandWindowSaveScript = 0x3106,
            CommandWindowRunScript = 0x3107,
            CommandWindowCursorUp = 0x3108,
            CommandWindowCursorDown = 0x3109,
            CommandWindowCursorLeft = 0x310A,
            CommandWindowCursorRight = 0x310B,
            CommandWindowHistoryUp = 0x310C,
            CommandWindowHistoryDown = 0x310D,
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid VsStd2010 = new Guid("{5DD0BB59-7076-4C59-88D3-DE36931F63F0}");

        //TODO:  These need to be documented by UEX.
        /// <summary>
        /// Set of the standard, shared commands in CMDSETID.StandardCommandSet2010_guid
        /// </summary>
        [Guid("5DD0BB59-7076-4C59-88D3-DE36931F63F0")]
        public enum VSStd2010CmdID
        {
            DynamicToolBarListFirst = 0x1,
            DynamicToolBarListLast = 0x12C,

            WindowFrameDockMenu = 0x1F4,

            ShellNavigate1First = 0x3E8,
            ShellNavigate2First = 0x409,
            ShellNavigate3First = 0x42A,
            ShellNavigate4First = 0x44B,
            ShellNavigate5First = 0x46C,
            ShellNavigate6First = 0x48D,
            ShellNavigate7First = 0x4AE,
            ShellNavigate8First = 0x4CF,
            ShellNavigate9First = 0x4F0,
            ShellNavigate10First = 0x511,
            ShellNavigate11First = 0x532,
            ShellNavigate12First = 0x553,
            ShellNavigate13First = 0x574,
            ShellNavigate14First = 0x595,
            ShellNavigate15First = 0x5B6,
            ShellNavigate16First = 0x5D7,
            ShellNavigate17First = 0x5F8,
            ShellNavigate18First = 0x619,
            ShellNavigate19First = 0x63A,
            ShellNavigate20First = 0x65B,
            ShellNavigate21First = 0x67C,
            ShellNavigate22First = 0x69D,
            ShellNavigate23First = 0x6BE,
            ShellNavigate24First = 0x6DF,
            ShellNavigate25First = 0x700,
            ShellNavigate26First = 0x721,
            ShellNavigate27First = 0x742,
            ShellNavigate28First = 0x763,
            ShellNavigate29First = 0x784,
            ShellNavigate30First = 0x7A5,
            ShellNavigate31First = 0x7C6,
            ShellNavigate32First = 0x7E7,
            ShellNavigateLast = 0x807,

            ZoomIn = 0x834,
            ZoomOut = 0x835,

            OUTLN_EXPAND_ALL = 0x9C4,
            OUTLN_COLLAPSE_ALL = 0x9C5,
            OUTLN_EXPAND_CURRENT = 0x9C6,
            OUTLN_COLLAPSE_CURRENT = 0x9C7,

            ExtensionManager = 0xBB8
        }

        // Editor factory constants

        /// <devdoc>Mutually exclusive w/_OPENFILE</devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public const uint CEF_CLONEFILE = 0x00000001;
        /// <devdoc>Mutually exclusive w/_CLONEFILE</devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public const uint CEF_OPENFILE = 0x00000002;
        /// <devdoc>Editor factory should create editor silently.</devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public const uint CEF_SILENT = 0x00000004;
        /// <devdoc>Editor factory should perform necessary fixups.</devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public const uint CEF_OPENASNEW = 0x00000008;

        [Flags]
        public enum CEF : uint
        {
            /// <devdoc>Mutually exclusive w/_OPENFILE</devdoc>
            CloneFile = 0x00000001,
            /// <devdoc>Mutually exclusive w/_CLONEFILE</devdoc>
            OpenFile = 0x00000002,
            /// <devdoc>Editor factory should create editor silently.</devdoc>
            Silent = 0x00000004,
            /// <devdoc>Editor factory should perform necessary fixups.</devdoc>
            OpenAsNew = 0x00000008
        }


        /// <summary>Command Group GUID for commands that only apply to the UIHierarchyWindow.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_VsUIHierarchyWindowCmds = new Guid("{60481700-078B-11D1-AAF8-00A0C9055A90}");

        /// <summary>
        /// The following commands are special commands that only apply to the UIHierarchyWindow.
        /// They are defined as part of the command group GUID: CMDSETID.UIHierarchyWindowCommandSet_guid.
        /// </summary>
        [Guid("60481700-078b-11d1-aaf8-00a0c9055a90")]
        public enum VsUIHierarchyWindowCmdIds
        {
            /// <summary></summary>
            UIHWCMDID_RightClick = 1,
            /// <summary></summary>
            UIHWCMDID_DoubleClick = 2,
            /// <summary></summary>
            UIHWCMDID_EnterKey = 3,
            /// <summary></summary>
            UIHWCMDID_StartLabelEdit = 4,
            /// <summary></summary>
            UIHWCMDID_CommitLabelEdit = 5,
            /// <summary></summary>
            UIHWCMDID_CancelLabelEdit = 6
        }

        // Special values for IVsHierarchy and SelectionContainer pointers
        public static readonly IntPtr
            HIERARCHY_DONTCHANGE = new IntPtr(-1),
            SELCONTAINER_DONTCHANGE = new IntPtr(-1),
            HIERARCHY_DONTPROPAGATE = new IntPtr(-2),
            SELCONTAINER_DONTPROPAGATE = new IntPtr(-2);

        /// <summary>
        /// These element IDs are the only element IDs that can be used with the selection service.
        /// </summary>
        public enum VSSELELEMID
        {
            /// <summary></summary>
            SEID_UndoManager = 0,
            /// <summary></summary>
            SEID_WindowFrame = 1,
            /// <summary></summary>
            SEID_DocumentFrame = 2,
            /// <summary></summary>
            SEID_StartupProject = 3,
            /// <summary></summary>
            SEID_PropertyBrowserSID = 4,
            /// <summary></summary>
            SEID_UserContext = 5,
            /// <summary></summary>
            SEID_ResultList = 6,
            /// <summary></summary>
            SEID_LastWindowFrame = 7
        }

        // VS Guids

        /// <summary>
        /// 
        /// </summary>
        public static class VsPackageGuid
        {
            /// <summary>GUID of the HTML Editor package.</summary>
            public const string VsEnvironmentPackage_string = "{DA9FB551-C724-11D0-AE1F-00A0C90FFFC3}";
            /// <summary>GUID of the HTML Editor package.</summary>
            public static readonly Guid VsEnvironmentPackage_guid = new Guid(VsEnvironmentPackage_string);

            /// <summary>GUID of the HTML Editor package.</summary>
            public const string HtmlEditorPackage_string = "{1B437D20-F8FE-11D2-A6AE-00104BCC7269}";
            /// <summary>GUID of the HTML Editor package.</summary>
            public static readonly Guid HtmlEditorPackage_guid = new Guid(HtmlEditorPackage_string);

            /// <summary>GUID of the Task & Error List package.</summary>
            public const string VsTaskListPackage_string = "{4A9B7E50-AA16-11D0-A8C5-00A0C921A4D2}";
            /// <summary>GUID of the Task & Error List package.</summary>
            public static readonly Guid VsTaskListPackage_guid = new Guid(VsTaskListPackage_string);

            /// <summary>GUID of the Document Outline tool window package.</summary>
            public const string VsDocOutlinePackage_string = "{21AF45B0-FFA5-11D0-B63F-00A0C922E851}";
            /// <summary>GUID of the Document Outline tool window package.</summary>
            public static readonly Guid VsDocOutlinePackage_guid = new Guid(VsDocOutlinePackage_string);

        }

        /// <summary>
        /// 
        /// </summary>
        public static class VsEditorFactoryGuid
        {
            /// <summary>GUID of HTML Editor editor factory</summary>
            public const string HtmlEditor_string = "{C76D83F8-A489-11D0-8195-00A0C91BBEE3}";
            /// <summary>GUID of HTML Editor editor factory</summary>
            public static readonly Guid HtmlEditor_guid = new Guid(HtmlEditor_string);

            /// <summary>GUID of the Source Code (Text) Editor editor factory</summary>
            public const string TextEditor_string = "{8B382828-6202-11d1-8870-0000F87579D2}";
            /// <summary>GUID of the Source Code (Text) Editor editor factory</summary>
            public static readonly Guid TextEditor_guid = new Guid(TextEditor_string);

            /// <summary>Guid for editor factory to launch external (EXE based) editors</summary>
            public const string ExternalEditor_string = "{8B382828-6202-11D1-8870-0000F87579D2}";
            /// <summary>Guid for EditorFactory to launch external (EXE based) editors</summary>
            public static readonly Guid ExternalEditor_guid = new Guid(ExternalEditor_string);

            /// <summary>Guid for Project Properties Designer editor factory</summary>
            public const string ProjectDesignerEditor_string = "{04B8AB82-A572-4FEF-95CE-5222444B6B64}";
            /// <summary>Guid for Project Properties Designer editor factory</summary>
            public static readonly Guid ProjectDesignerEditor_guid = new Guid(ProjectDesignerEditor_string);

        }

        /// <summary>
        /// 
        /// </summary>
        public static class VsLanguageServiceGuid
        {
            /// <summary></summary>
            public const string HtmlLanguageService_string = "{58E975A0-F8FE-11D2-A6AE-00104BCC7269}";
            /// <summary></summary>
            public static readonly Guid HtmlLanguageService_guid = new Guid(HtmlLanguageService_string);

        }

        /// <summary>
        /// 
        /// </summary>
        public static class OutputWindowPaneGuid
        {
            /// <summary>GUID of the build output pane inside the output window.</summary>
            public const string BuildOutputPane_string = "{1BD8A850-02D1-11D1-BEE7-00A0C913D1F8}";
            /// <summary>GUID of the build output pane inside the output window.</summary>
            public static readonly Guid BuildOutputPane_guid = new Guid(BuildOutputPane_string);

            /// <summary>GUID of the sorted build output pane inside the output window.</summary>
            public const string SortedBuildOutputPane_string = "{2032B126-7C8D-48AD-8026-0E0348004FC0}";
            /// <summary>GUID of the sorted build output pane inside the output window.</summary>
            public static readonly Guid SortedBuildOutputPane_guid = new Guid(SortedBuildOutputPane_string);

            /// <summary>GUID of the debug pane inside the output window.</summary>
            public const string DebugPane_string = "{FC076020-078A-11D1-A7DF-00A0C9110051}";
            /// <summary>GUID of the debug pane inside the output window.</summary>
            public static readonly Guid DebugPane_guid = new Guid(DebugPane_string);

            /// <summary>GUID of the general output pane inside the output window.</summary>
            public const string GeneralPane_string = "{3C24D581-5591-4884-A571-9FE89915CD64}";
            /// <summary>GUID of the general output pane inside the output window.</summary>
            public static readonly Guid GeneralPane_guid = new Guid(GeneralPane_string);

        }

        /// <summary>
        /// These values are used with the VSHPROPID_ItemType property.
        /// </summary>
        public static class ItemTypeGuid
        {
            /// <summary>Physical file on disk or web (IVsProject::GetMkDocument returns a file path).</summary>
            public const string PhysicalFile_string = "{6BB5F8EE-4483-11D3-8BCF-00C04F8EC28C}";
            /// <summary>Physical file on disk or web (IVsProject::GetMkDocument returns a file path).</summary>
            public static readonly Guid PhysicalFile_guid = new Guid(PhysicalFile_string);

            /// <summary>Physical folder on disk or web (IVsProject::GetMkDocument returns a directory path).</summary>
            public const string PhysicalFolder_string = "{6BB5F8EF-4483-11D3-8BCF-00C04F8EC28C}";
            /// <summary>Physical folder on disk or web (IVsProject::GetMkDocument returns a directory path).</summary>
            public static readonly Guid PhysicalFolder_guid = new Guid(PhysicalFolder_string);

            /// <summary>Non-physical folder (folder is logical and not a physical file system directory).</summary>
            public const string VirtualFolder_string = "{6BB5F8EE-4483-11D3-8BCF-00C04F8EC28C}";
            /// <summary>Non-physical folder (folder is logical and not a physical file system directory).</summary>
            public static readonly Guid VirtualFolder_guid = new Guid(VirtualFolder_string);

            /// <summary>Nested or Sub Project.</summary>
            public const string SubProject_string = "{EA6618E8-6E24-4528-94BE-6889FE16485C}";
            /// <summary>Nested or Sub Project.</summary>
            public static readonly Guid SubProject_guid = new Guid(SubProject_string);

        }

        /// <summary>
        /// 
        /// </summary>
        public static class VsDependencyTypeGuid
        {
            /// <summary>Build project dependency (used with IVsDependency::get_Type)</summary>
            public const string BuildProject_string = "{707D11B6-91CA-11D0-8A3E-00A0C91E2ACD}";
            /// <summary>Build project dependency (used with IVsDependency::get_Type)</summary>
            public static readonly Guid BuildProject_guid = new Guid(BuildProject_string);

        }

        /// <summary>
        /// These are optional IVsUserData properties that a Language Service may provide in order to influence
        /// the behavior of the Source Code (Text) Editor. The IVsUserData interface is retrieved by 
        /// QueryInterface on the IVsLanguageInfo object of the Language Service implementation.
        /// </summary>
        public static class VsLanguageUserDataGuid
        {
            /// <summary></summary>
            public const string SupportCF_HTML_string = "{27E97702-589E-11D2-8233-0080C747D9A0}";
            /// <summary></summary>
            public static readonly Guid SupportCF_HTML_guid = new Guid(SupportCF_HTML_string);

        }

        /// <summary>
        /// These are IVsUserData properties that are supported by the TextBuffer (DocData) object
        /// of the Source Code (Text) Editor. The IVsUserData interface is retrieved by 
        /// QueryInterface on the IVsTextLines object of the Text Editor.
        /// </summary>
        public static class VsTextBufferUserDataGuid
        {
            /// <summary>string: Moniker of document loaded in the buffer. It will be the full path of file if the document is a file.</summary>
            public const string VsBufferMoniker_string = "{978A8E17-4DF8-432A-9623-D530A26452BC}";
            /// <summary>string: Moniker of document loaded in the TextBuffer. It will be the full path of file if the document is a file.</summary>
            public static readonly Guid VsBufferMoniker_guid = new Guid(VsBufferMoniker_string);

            /// <summary>bool: true if buffer is a file on disk</summary>
            public const string VsBufferIsDiskFile_string = "{D9126592-1473-11D3-BEC6-0080C747D9A0}";
            /// <summary>bool: true if buffer is a file on disk</summary>
            public static readonly Guid VsBufferIsDiskFile_guid = new Guid(VsBufferIsDiskFile_string);

            /// <summary>uint: VS Text File Format (VSTFF) for buffer. codepage = bufferVSTFF & __VSTFF.VSTFF_CPMASK; vstffFlags = bufferVSTFF & __VSTFF.VSTFF_FLAGSMASK;</summary>
            public const string VsBufferEncodingVSTFF_string = "{16417F39-A6B7-4C90-89FA-770D2C60440B}";
            /// <summary>uint: VS Text File Format (VSTFF) for buffer. codepage = bufferVSTFF & __VSTFF.VSTFF_CPMASK; vstffFlags = bufferVSTFF & __VSTFF.VSTFF_FLAGSMASK;</summary>
            public static readonly Guid VsBufferEncodingVSTFF_guid = new Guid(VsBufferEncodingVSTFF_string);

            /// <summary>uint: This should only be used by editor factories that want to specify a codepage on loading from the openwith dialog. 
            /// This data is only for a set purpose.  You cannot get the value of this back.
            /// </summary>
            public const string VsBufferEncodingPromptOnLoad_string = "{99EC03F0-C843-4C09-BE74-CDCA5158D36C}";
            /// <summary>uint: This should only be used by editor factories that want to specify a codepage on loading from the openwith dialog. 
            /// This data is only for a set purpose.  You cannot get the value of this back.
            /// </summary>
            public static readonly Guid VsBufferEncodingPromptOnLoad_guid = new Guid(VsBufferEncodingPromptOnLoad_string);

            /// <summary>bool: If true and the current BufferEncoding is CHARFMT_MBCS, the buffer will runs it's HTML charset tag detection code to determine a codepage to load and save the file. The detected codepage overrides any codepage set in CHARFMT_MBCS.
            /// This is forced on in the buffer's IPersistFileFormat::LoadDocData when it sees an HTML type of file, according to the extension mapping in "$RootKey$\Languages\File Extensions".
            /// </summary>
            public const string VsBufferDetectCharSet_string = "{36358D1F-BF7E-11D1-B03A-00C04FB68006}";
            /// <summary>bool: If true and the current BufferEncoding is CHARFMT_MBCS, the buffer will runs it's HTML charset tag detection code to determine a codepage to load and save the file. The detected codepage overrides any codepage set in CHARFMT_MBCS.
            /// This is forced on in the buffer's IPersistFileFormat::LoadDocData when it sees an HTML type of file, according to the extension mapping in "$RootKey$\Languages\File Extensions".
            /// </summary>
            public static readonly Guid VsBufferDetectCharSet_guid = new Guid(VsBufferDetectCharSet_string);

            /// <summary>bool: (default = true) If true then a change to the buffer's moniker will cause the buffer to change the language service 
            /// based on the file extension of the moniker.
            /// </summary>
            public const string VsBufferDetectLangSID_string = "{17F375AC-C814-11D1-88AD-0000F87579D2}";
            /// <summary>bool: (default = true) If true then a change to the buffer's moniker will cause the buffer to change the language service 
            /// based on the file extension of the moniker.
            /// </summary>
            public static readonly Guid VsBufferDetectLangSID_guid = new Guid(VsBufferDetectLangSID_string);

            /// <summary>string: This property will be used to set the SEID_PropertyBrowserSID element of the selection for text views.  
            /// This is only used if you have a custom property browser. If this property is not set, the standard property browser 
            /// will be associated with the view.
            /// </summary>
            public const string PropertyBrowserSID_string = "{CE6DDBBA-8D13-11D1-8889-0000F87579D2}";
            /// <summary>string: This property will be used to set the SEID_PropertyBrowserSID element of the selection for text views.  
            /// This is only used if you have a custom property browser. If this property is not set, the standard property browser 
            /// will be associated with the view.
            /// </summary>
            public static readonly Guid PropertyBrowserSID_guid = new Guid(PropertyBrowserSID_string);

            /// <summary>string: This property provides a specific error message for when the buffer originates the BUFFER_E_READONLY error.
            /// Set this string to be the (localized) text you want displayed to the user.  Note that the buffer itself does not 
            /// put up UI, but only calls IVsUIShell::SetErrorInfo. The caller can decide whether to show the message to the user.
            /// </summary>
            public const string UserReadOnlyErrorString_string = "{A3BCFE56-CF1B-11D1-88B1-0000F87579D2}";
            /// <summary>string: This property provides a specific error message for when the buffer originates the BUFFER_E_READONLY error.
            /// Set this string to be the (localized) text you want displayed to the user.  Note that the buffer itself does not 
            /// put up UI, but only calls IVsUIShell::SetErrorInfo. The caller can decide whether to show the message to the user.
            /// </summary>
            public static readonly Guid UserReadOnlyErrorString_guid = new Guid(UserReadOnlyErrorString_string);

            /// <summary>object: This property is used to get access to the buffer's storage object.
            /// The returned pointer can be QI'd for IVsTextStorage and IVsPersistentTextImage.  
            /// This is a get-only property. To set the storage, use the buffer's InitializeContentEx method.
            /// </summary>
            public const string BufferStorage_string = "{D97F167A-638E-11D2-88F6-0000F87579D2}";
            /// <summary>object: This property is used to get access to the buffer's storage object.
            /// The returned pointer can be QI'd for IVsTextStorage and IVsPersistentTextImage.  
            /// This is a get-only property. To set the storage, use the buffer's InitializeContentEx method.
            /// </summary>
            public static readonly Guid BufferStorage_guid = new Guid(BufferStorage_string);

            /// <summary>object: Use this property if the file opened in the buffer is associated with list of extra files under source code control (SCC).
            /// Set this property with an implementation of IVsBufferExtraFiles in order to control how the buffer handles SCC operations.
            /// The IVsBufferExtraFiles object set will determine what files are checked out from Source Code Control (SCC) when edits are made to the buffer.
            /// This property controls the behavior of IVsTextManager2::AttemptToCheckOutBufferFromScc3 and GetBufferSccStatus3 as well as which
            /// files are passed by the buffer when it calls IVsQueryEditQuerySave2 methods.
            /// </summary>
            public const string VsBufferExtraFiles_string = "{FD494BF6-1167-4635-A20C-5C24B2D7B33D}";
            /// <summary>object: Use this property if the file opened in the buffer is associated with list of extra files under source code control (SCC).
            /// Set this property with an implementation of IVsBufferExtraFiles in order to control how the buffer handles SCC operations.
            /// The IVsBufferExtraFiles object set will determine what files are checked out from Source Code Control (SCC) when edits are made to the buffer.
            /// This property controls the behavior of IVsTextManager2::AttemptToCheckOutBufferFromScc3 and GetBufferSccStatus3 as well as which
            /// files are passed by the buffer when it calls IVsQueryEditQuerySave2 methods.
            /// </summary>
            public static readonly Guid VsBufferExtraFiles_guid = new Guid(VsBufferExtraFiles_string);

            /// <summary>bool: </summary>
            public const string VsBufferFileReload_string = "{80D2B881-81A3-4F0B-BCF0-70A0054E672F}";
            /// <summary>bool: </summary>
            public static readonly Guid VsBufferFileReload_guid = new Guid(VsBufferFileReload_string);

            /// <summary>bool: </summary>
            public const string VsInitEncodingDialogFromUserData_string = "{C2382D84-6650-4386-860F-248ECB222FC1}";
            /// <summary>bool: </summary>
            public static readonly Guid VsInitEncodingDialogFromUserData_guid = new Guid(VsInitEncodingDialogFromUserData_string);

            /// <summary>string: The ContentType for the text buffer.</summary>
            public const string VsBufferContentType_string = "{1BEB4195-98F4-4589-80E0-480CE32FF059}";
            /// <summary>string: The ContentType for the text buffer.</summary>
            public static readonly Guid VsBufferContentType_guid = new Guid(VsBufferContentType_string);

            /// <summary>string: The comma-separated list of text view roles for the text view.</summary>
            public const string VsTextViewRoles_string = "{297078FF-81A2-43D8-9CA3-4489C53C99BA}";
            /// <summary>string: The comma-separated list of text view roles for the text view.</summary>
            public static readonly Guid VsTextViewRoles_guid = new Guid(VsTextViewRoles_string);
        }

        /// <summary>
        /// Known editor property categories use with IVsTextEditorPropertyCategoryContainer interface.
        /// </summary>
        public static class EditPropyCategoryGuid
        {
            /// <summary>GUID for text manager global properties</summary>
            public const string TextManagerGlobal_string = "{6BFB60A2-48D8-424E-81A2-040ACA0B1F68}";
            /// <summary>GUID for text manager global properties</summary>
            public static readonly Guid TextManagerGlobal_guid = new Guid(TextManagerGlobal_string);

            /// <summary>GUID for view properties that override everything -- Tools.Options *and* user commands</summary>
            public const string ViewMasterSettings_string = "{D1756E7C-B7FD-49A8-B48E-87B14A55655A}";
            /// <summary>GUID for view properties that override everything -- Tools.Options *and* user commands</summary>
            public static readonly Guid ViewMasterSettings_guid = new Guid(ViewMasterSettings_string);
        }

        /// <summary>
        /// These CATID Guids are used to extend objects passed to the property browser and automation objects that support
        /// Automation Extenders. 
        /// </summary>
        public static class CATID
        {
            /// <summary></summary>
            public const string CSharpFileProperties_string = "{8D58E6AF-ED4E-48B0-8C7B-C74EF0735451}";
            public static readonly Guid CSharpFileProperties_guid = new Guid(CSharpFileProperties_string);

            /// <summary></summary>
            public const string CSharpFolderProperties_string = "{914FE278-054A-45DB-BF9E-5F22484CC84C}";
            public static readonly Guid CSharpFolderProperties_guid = new Guid(CSharpFolderProperties_string);

            /// <summary>This CATID is used to extend EnvDTE.Project automation objects for project types that support it (including VB and C# projects).</summary>
            public const string ProjectAutomationObject_string = "{610D4614-D0D5-11D2-8599-006097C68E81}";
            /// <summary>This CATID is used to extend EnvDTE.Project automation objects for project types that support it (including VB and C# projects).</summary>
            public static readonly Guid ProjectAutomationObject_guid = new Guid(ProjectAutomationObject_string);

            /// <summary>This CATID is used to extend EnvDTE.ProjectItem automation objects for project types that support it (including VB and C# projects).</summary>
            public const string ProjectItemAutomationObject_string = "{610D4615-D0D5-11D2-8599-006097C68E81}";
            /// <summary>This CATID is used to extend EnvDTE.ProjectItem automation objects for project types that support it (including VB and C# projects).</summary>
            public static readonly Guid ProjectItemAutomationObject_guid = new Guid(ProjectItemAutomationObject_string);

            /// <summary></summary>
            public const string VBAFileProperties_string = "{AC2912B2-50ED-4E62-8DFF-429B4B88FC9E}";
            public static readonly Guid VBAFileProperties_guid = new Guid(VBAFileProperties_string);

            /// <summary></summary>
            public const string VBAFolderProperties_string = "{79231B36-6213-481D-AA7D-0F931E8F2CF9}";
            public static readonly Guid VBAFolderProperties_guid = new Guid(VBAFolderProperties_string);

            /// <summary></summary>
            public const string VBFileProperties_string = "{EA5BD05D-3C72-40A5-95A0-28A2773311CA}";
            public static readonly Guid VBFileProperties_guid = new Guid(VBFileProperties_string);

            /// <summary></summary>
            public const string VBFolderProperties_string = "{932DC619-2EAA-4192-B7E6-3D15AD31DF49}";
            public static readonly Guid VBFolderProperties_guid = new Guid(VBFolderProperties_string);

            /// <summary></summary>
            public const string VBProjectProperties_string = "{E0FDC879-C32A-4751-A3D3-0B3824BD575F}";
            public static readonly Guid VBProjectProperties_guid = new Guid(VBProjectProperties_string);

            /// <summary></summary>
            public const string VBReferenceProperties_string = "{2289B812-8191-4E81-B7B3-174045AB0CB5}";
            public static readonly Guid VBReferenceProperties_guid = new Guid(VBReferenceProperties_string);

            /// <summary></summary>
            public const string VCProjectNode_string = "{EE8299CB-19B6-4F20-ABEA-E1FD9A33B683}";
            public static readonly Guid VCProjectNode_guid = new Guid(VCProjectNode_string);

            /// <summary></summary>
            public const string VCFileGroup_string = "{EE8299CA-19B6-4F20-ABEA-E1FD9A33B683}";
            public static readonly Guid VCFileGroup_guid = new Guid(VCFileGroup_string);

            /// <summary></summary>
            public const string VCFileNode_string = "{EE8299C9-19B6-4F20-ABEA-E1FD9A33B683}";
            public static readonly Guid VCFileNode_guid = new Guid(VCFileNode_string);

            /// <summary></summary>
            public const string VCAssemblyReferenceNode_string = "{FE8299C9-19B6-4F20-ABEA-E1FD9A33B683}";
            public static readonly Guid VCAssemblyReferenceNode_guid = new Guid(VCAssemblyReferenceNode_string);

            /// <summary></summary>
            public const string VCProjectReferenceNode_string = "{593DCFCE-20A7-48E4-ACA1-49ADE9049887}";
            public static readonly Guid VCProjectReferenceNode_guid = new Guid(VCProjectReferenceNode_string);

            /// <summary></summary>
            public const string VCActiveXReferenceNode_string = "{9E8182D3-C60A-44F4-A74B-14C90EF9CACE}";
            public static readonly Guid VCActiveXReferenceNode_guid = new Guid(VCActiveXReferenceNode_string);

            /// <summary></summary>
            public const string VCReferences_string = "{FE8299CA-19B6-4F20-ABEA-E1FD9A33B683}";
            public static readonly Guid VCReferences_guid = new Guid(VCReferences_string);

        }

        // Note: We don't define here the GUIDs for the standard tool windows because these
        // GUIDs are defined in Design.StandardToolWindows

        /// <summary>The document's data is HTML.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid CLSID_HtmDocData = new Guid("{62C81794-A9EC-11D0-8198-00A0C91BBEE3}");
        /// <summary>GUID of the HTML package.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid CLSID_HtmedPackage = new Guid("{1B437D20-F8FE-11D2-A6AE-00104BCC7269}");
        /// <summary>GUID of the HTML language service.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid CLSID_HtmlLanguageService = new Guid("{58E975A0-F8FE-11D2-A6AE-00104BCC7269}");
        /// <summary>GUID of the HTML editor factory.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_HtmlEditorFactory = new Guid("{C76D83F8-A489-11D0-8195-00A0C91BBEE3}");
        /// <summary>GUID of the Text editor factory.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_TextEditorFactory = new Guid("{8B382828-6202-11D1-8870-0000F87579D2}");
        /// <summary>GUID used to mark a TextBuffer in order to tell to the HTML editor factory to accept preexisting doc data.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_HTMEDAllowExistingDocData = new Guid("{5742D216-8071-4779-BF5F-A24D5F3142BA}");
        /// <summary>GUID for the environment package.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid CLSID_VsEnvironmentPackage = new Guid("{DA9FB551-C724-11D0-AE1F-00A0C90FFFC3}");
        /// <summary>GUID for the "Visual Studio" pseudo folder in the registry.</summary>
        public static readonly Guid GUID_VsNewProjectPseudoFolder = new Guid("{DCF2A94A-45B0-11D1-ADBF-00C04FB6BE4C}");
        /// <summary>GUID for the "Miscellaneous Files" project.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid CLSID_MiscellaneousFilesProject = new Guid("{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}");
        /// <summary>GUID for Solution Items project.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid CLSID_SolutionItemsProject = new Guid("{D1DCDB85-C5E8-11D2-BFCA-00C04F990235}");
        /// <summary>Pseudo service that returns a IID_IVsOutputWindowPane interface of the General output pane in the VS environment.
        /// Querying for this service will cause the General output pane to be created if it hasn't yet been created.
        /// </summary>
        public static readonly Guid SID_SVsGeneralOutputWindowPane = new Guid("{65482C72-DEFA-41B7-902C-11C091889C83}");
        /// <summary>
        /// SUIHostCommandDispatcher service returns an object that implements IOleCommandTarget.
        /// This object handles command routing for the Environment. Use this service if you need to
        /// route a command based on the current selection/state of the Environment.
        /// </summary>
        public static readonly Guid SID_SUIHostCommandDispatcher = new Guid("{E69CD190-1276-11D1-9F64-00A0C911004F}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid CLSID_VsUIHierarchyWindow = new Guid("{7D960B07-7AF8-11D0-8E5E-00A0C911005A}");

        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_DefaultEditor = new Guid("{6AC5EF80-12BF-11D1-8E9B-00A0C911005A}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_ExternalEditor = new Guid("{8137C9E8-35FE-4AF2-87B0-DE3C45F395FD}");


        /// <summary>
        /// 
        /// </summary>
        public static class CLSID
        {
            /// <summary></summary>
            public const string MiscellaneousFilesProject_string = "{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}";
            /// <summary></summary>
            public static readonly Guid MiscellaneousFilesProject_guid = new Guid(MiscellaneousFilesProject_string);

            /// <summary></summary>
            public const string SolutionFolderProject_string = "{2150E333-8FDC-42A3-9474-1A3956D46DE8}";
            /// <summary></summary>
            public static readonly Guid SolutionFolderProject_guid = new Guid(SolutionFolderProject_string);

            /// <summary></summary>
            public const string SolutionItemsProject_string = "{D1DCDB85-C5E8-11D2-BFCA-00C04F990235}";
            /// <summary></summary>
            public static readonly Guid SolutionItemsProject_guid = new Guid(SolutionItemsProject_string);

            /// <summary></summary>
            public const string VsTextBuffer_string = "{8E7B96A8-E33D-11D0-A6D5-A6D500C04FB67F6A}";
            /// <summary></summary>
            public static readonly Guid VsTextBuffer_guid = new Guid(VsTextBuffer_string);

            /// <summary></summary>
            public const string UnloadedProject_string = "{76E22BD3-C2EC-47F1-802B-53197756DAE8}";
            /// <summary></summary>
            public static readonly Guid UnloadedProject_guid = new Guid(UnloadedProject_string);

            /// <summary></summary>
            public const string VsCfgProviderEventsHelper_string = "{99913F1F-1EE3-11D1-8A6E-00C04F682E21}";
            /// <summary></summary>
            public static readonly Guid VsCfgProviderEventsHelper_guid = new Guid(VsCfgProviderEventsHelper_string);

            /// <summary></summary>
            public const string VsEnvironmentPackage_string = "{DA9FB551-C724-11D0-AE1F-00A0C90FFFC3}";
            /// <summary></summary>
            public static readonly Guid VsEnvironmentPackage_guid = new Guid(VsEnvironmentPackage_string);

            /// <summary></summary>
            public const string VsTaskListPackage_string = "{4A9B7E50-AA16-11D0-A8C5-00A0C921A4D2}";
            /// <summary></summary>
            public static readonly Guid VsTaskListPackage_guid = new Guid(VsTaskListPackage_string);

            /// <summary></summary>
            public const string VsUIWpfLoader_string = "{0B127700-143C-4AB5-9D39-BFF47151B563}";
            /// <summary></summary>
            public static readonly Guid VsUIWpfLoader_guid = new Guid(VsUIWpfLoader_string);

            /// <summary>DocData object of the HTML Editor</summary>
            public const string HtmDocData_string = "{62C81794-A9EC-11D0-8198-00A0C91BBEE3}";
            /// <summary></summary>
            public static readonly Guid HtmDocData_guid = new Guid(HtmDocData_string);

            /// <summary>CLSID of the UIHierarchy window tree control object</summary>
            public const string VsUIHierarchyWindow_string = "{7D960B07-7AF8-11D0-8E5E-00A0C911005A}";
            /// <summary></summary>
            public static readonly Guid VsUIHierarchyWindow_guid = new Guid(VsUIHierarchyWindow_string);

            /// <summary></summary>
            public const string VsTaskList_string = "{BC5955D5-AA0D-11D0-A8C5-00A0C921A4D2}";
            /// <summary></summary>
            public static readonly Guid VsTaskList_guid = new Guid(VsTaskList_string);

        }
        
        
        
        //--------------------------------------------------------------------
        // GUIDs for some panes of the Output Window
        //--------------------------------------------------------------------
        /// <summary>GUID of the build pane inside the output window.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_BuildOutputWindowPane = new Guid("{1BD8A850-02D1-11d1-BEE7-00A0C913D1F8}");
        /// <summary>GUID of the debug pane inside the output window.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_OutWindowDebugPane = new Guid("{FC076020-078A-11D1-A7DF-00A0C9110051}");
        /// <summary>GUID of the general output pane inside the output window.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_OutWindowGeneralPane = new Guid("{3C24D581-5591-4884-A571-9FE89915CD64}");

        // Guids for GetOutputPane.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid BuildOrder = new Guid("2032B126-7C8D-48AD-8026-0E0348004FC0");
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid BuildOutput = new Guid("1BD8A850-02D1-11D1-BEE7-00A0C913D1F8");
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid DebugOutput = new Guid("FC076020-078A-11D1-A7DF-00A0C9110051");

        //--------------------------------------------------------------------
        // standard item types, to be returned from VSHPROPID_TypeGuid
        //--------------------------------------------------------------------

        /// <summary>Physical file on disk or web (IVsProject::GetMkDocument returns a file path).</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_ItemType_PhysicalFile = new Guid("{6BB5F8EE-4483-11D3-8BCF-00C04F8EC28C}");

        /// <summary>Physical folder on disk or web (IVsProject::GetMkDocument returns a directory path).</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_ItemType_PhysicalFolder = new Guid("{6BB5F8EF-4483-11D3-8BCF-00C04F8EC28C}");

        /// <summary>Non-physical folder (folder is logical and not a physical file system directory).</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_ItemType_VirtualFolder = new Guid("{6BB5F8F0-4483-11D3-8BCF-00C04F8EC28C}");

        /// <summary>A nested hierarchy project.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_ItemType_SubProject = new Guid("{EA6618E8-6E24-4528-94BE-6889FE16485C}");

        /// <summary>The BrowseFile page.</summary>
        public static readonly Guid GUID_BrowseFilePage = new Guid("2483F435-673D-4FA3-8ADD-B51442F65349");

        public static readonly Guid guidCOMPLUSLibrary = new Guid(0x1ec72fd7, 0xc820, 0x4273, 0x9a, 0x21, 0x77, 0x7a, 0x5c, 0x52, 0x2e, 0x03);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid CLSID_ComPlusOnlyDebugEngine = new Guid("449EC4CC-30D2-4032-9256-EE18EB41B62B");

        /// <summary>
        /// 
        /// </summary>
        public static class DebugEnginesGuids
        {
            [EditorBrowsable(EditorBrowsableState.Never)]
            public static readonly Guid ManagedOnly = new Guid("449EC4CC-30D2-4032-9256-EE18EB41B62B");
            [EditorBrowsable(EditorBrowsableState.Never)]
            public static readonly Guid NativeOnly = new Guid("{3B476D35-A401-11D2-AAD4-00C04F990171}");
            [EditorBrowsable(EditorBrowsableState.Never)]
            public static readonly Guid Script = new Guid("{F200A7E7-DEA5-11D0-B854-00A0244A1DE2}");
            [EditorBrowsable(EditorBrowsableState.Never)]
            public static readonly Guid ManagedAndNative = new Guid("{92EF0900-2251-11D2-B72E-0000F87572EF}");
            [EditorBrowsable(EditorBrowsableState.Never)]
            public static readonly Guid SQLLocalEngine = new Guid("{E04BDE58-45EC-48DB-9807-513F78865212}");
            [EditorBrowsable(EditorBrowsableState.Never)]
            public static readonly Guid SqlDebugEngine2 = new Guid("{3B476D30-A401-11D2-AAD4-00C04F990171}");
            [EditorBrowsable(EditorBrowsableState.Never)]
            public static readonly Guid SqlDebugEngine3 = new Guid("{3B476D3A-A401-11D2-AAD4-00C04F990171}");

            public const string ManagedOnly_string = "449EC4CC-30D2-4032-9256-EE18EB41B62B";
            public static readonly Guid ManagedOnly_guid = new Guid(ManagedOnly_string);

            public const string NativeOnly_string = "{3B476D35-A401-11D2-AAD4-00C04F990171}";
            public static readonly Guid NativeOnly_guid = new Guid(NativeOnly_string);

            public const string Script_string = "{F200A7E7-DEA5-11D0-B854-00A0244A1DE2}";
            public static readonly Guid Script_guid = new Guid(Script_string);

            public const string ManagedAndNative_string = "{92EF0900-2251-11D2-B72E-0000F87572EF}";
            public static readonly Guid ManagedAndNative_guid = new Guid(ManagedAndNative_string);

            public const string SQLLocalEngine_string = "{E04BDE58-45EC-48DB-9807-513F78865212}";
            public static readonly Guid SQLLocalEngine_guid = new Guid(SQLLocalEngine_string);

            public const string SqlDebugEngine2_string = "{3B476D30-A401-11D2-AAD4-00C04F990171}";
            public static readonly Guid SqlDebugEngine2_guid = new Guid(SqlDebugEngine2_string);

            public const string SqlDebugEngine3_string = "{3B476D3A-A401-11D2-AAD4-00C04F990171}";
            public static readonly Guid SqlDebugEngine3_guid = new Guid(SqlDebugEngine3_string);

        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_VS_DEPTYPE_BUILD_PROJECT = new Guid("707d11b6-91ca-11d0-8a3e-00a0c91e2acd");

        /// <summary>The project designer guid.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_ProjectDesignerEditor = new Guid("04b8ab82-a572-4fef-95ce-5222444b6b64");

        // Build options from the idl file.
        public const uint VS_BUILDABLEPROJECTCFGOPTS_REBUILD = 1;
        public const uint VS_BUILDABLEPROJECTCFGOPTS_BUILD_SELECTION_ONLY = 2;
        public const uint VS_BUILDABLEPROJECTCFGOPTS_BUILD_ACTIVE_DOCUMENT_ONLY = 4;
        public const uint VS_BUILDABLEPROJECTCFGOPTS_PRIVATE = 0xFFFF0000;    // flags private to a particular implementation

        //--------------------------------------------------------------------
        // GUIDs used in calling IVsMonitorSelection::GetCmdUIContextCookie()
        //--------------------------------------------------------------------
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid UICONTEXT_SolutionBuilding = new Guid("{adfc4e60-0397-11d1-9f4e-00a0c911004f}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid UICONTEXT_Debugging = new Guid("{adfc4e61-0397-11d1-9f4e-00a0c911004f}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid UICONTEXT_Dragging = new Guid("{b706f393-2e5b-49e7-9e2e-b1825f639b63}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid UICONTEXT_FullScreenMode = new Guid("{adfc4e62-0397-11d1-9f4e-00a0c911004f}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid UICONTEXT_DesignMode = new Guid("{adfc4e63-0397-11d1-9f4e-00a0c911004f}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid UICONTEXT_NoSolution = new Guid("{adfc4e64-0397-11d1-9f4e-00a0c911004f}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid UICONTEXT_SolutionExists = new Guid("{f1536ef8-92ec-443c-9ed7-fdadf150da82}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid UICONTEXT_EmptySolution = new Guid("{adfc4e65-0397-11d1-9f4e-00a0c911004f}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid UICONTEXT_SolutionHasSingleProject = new Guid("{adfc4e66-0397-11d1-9f4e-00a0c911004f}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid UICONTEXT_SolutionHasMultipleProjects = new Guid("{93694fa0-0397-11d1-9f4e-00a0c911004f}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid UICONTEXT_CodeWindow = new Guid("{8fe2df1d-e0da-4ebe-9d5c-415d40e487b5}");

        /// <summary>
        /// 
        /// </summary>
        public static class UICONTEXT
        {
            /// <summary></summary>
            public const string RESXEditor_string = "{FEA4DCC9-3645-44CD-92E7-84B55A16465C}";
            /// <summary></summary>
            public static readonly Guid RESXEditor_guid = new Guid(RESXEditor_string);

            /// <summary></summary>
            public const string SettingsDesigner_string = "{515231AD-C9DC-4AA3-808F-E1B65E72081C}";
            /// <summary></summary>
            public static readonly Guid SettingsDesigner_guid = new Guid(SettingsDesigner_string);

            /// <summary></summary>
            public const string PropertyPageDesigner_string = "{86670EFA-3C28-4115-8776-A4D5BB1F27CC}";
            /// <summary></summary>
            public static readonly Guid PropertyPageDesigner_guid = new Guid(PropertyPageDesigner_string);

            /// <summary></summary>
            public const string ApplicationDesigner_string = "{D06CD5E3-D961-44DC-9D80-C89A1A8D9D56}";
            /// <summary></summary>
            public static readonly Guid ApplicationDesigner_guid = new Guid(ApplicationDesigner_string);
            
            /// <summary></summary>
            public const string VBProjOpened_string = "{9DA22B82-6211-11d2-9561-00600818403B}";
            /// <summary></summary>
            public static readonly Guid VBProjOpened_guid = new Guid(VBProjOpened_string);

            /// <summary></summary>
            public const string CodeWindow_string = "{8FE2DF1D-E0DA-4EBE-9D5C-415D40E487B5}";
            /// <summary></summary>
            public static readonly Guid CodeWindow_guid = new Guid(CodeWindow_string);

            /// <summary></summary>
            public const string DataSourceWindowAutoVisible_string = "{2E78870D-AC7C-4460-A4A1-3FE37D00EF81}";
            /// <summary></summary>
            public static readonly Guid DataSourceWindowAutoVisible_guid = new Guid(DataSourceWindowAutoVisible_string);

            /// <summary></summary>
            public const string DataSourceWizardSuppressed_string = "{5705AD15-40EE-4426-AD3E-BA750610D599}";
            /// <summary></summary>
            public static readonly Guid DataSourceWizardSuppressed_guid = new Guid(DataSourceWizardSuppressed_string);

            /// <summary></summary>
            public const string DataSourceWindowSupported_string = "{95C314C4-660B-4627-9F82-1BAF1C764BBF}";
            /// <summary></summary>
            public static readonly Guid DataSourceWindowSupported_guid = new Guid(DataSourceWindowSupported_string);

            /// <summary></summary>
            public const string Debugging_string = "{ADFC4E61-0397-11D1-9F4E-00A0C911004F}";
            /// <summary></summary>
            public static readonly Guid Debugging_guid = new Guid(Debugging_string);

            /// <summary></summary>
            public const string DesignMode_string = "{ADFC4E63-0397-11D1-9F4E-00A0C911004F}";
            /// <summary></summary>
            public static readonly Guid DesignMode_guid = new Guid(DesignMode_string);

            /// <summary></summary>
            public const string Dragging_string = "{B706F393-2E5B-49E7-9E2E-B1825F639B63}";
            /// <summary></summary>
            public static readonly Guid Dragging_guid = new Guid(Dragging_string);

            /// <summary></summary>
            public const string EmptySolution_string = "{ADFC4E65-0397-11D1-9F4E-00A0C911004F}";
            /// <summary></summary>
            public static readonly Guid EmptySolution_guid = new Guid(EmptySolution_string);

            /// <summary></summary>
            public const string FullScreenMode_string = "{ADFC4E62-0397-11D1-9F4E-00A0C911004F}";
            /// <summary></summary>
            public static readonly Guid FullScreenMode_guid = new Guid(FullScreenMode_string);

            /// <summary></summary>
            public const string HistoricalDebugging_string = "{D1B1E38F-1A7E-4236-AF55-6FA8F5FA76E6}";
            /// <summary></summary>
            public static readonly Guid HistoricalDebugging_guid = new Guid(HistoricalDebugging_string);

            /// <summary></summary>
            public const string NoSolution_string = "{ADFC4E64-0397-11D1-9F4E-00A0C911004F}";
            /// <summary></summary>
            public static readonly Guid NoSolution_guid = new Guid(NoSolution_string);

            /// <summary></summary>
            public const string NotBuildingAndNotDebugging_string = "{48EA4A80-F14E-4107-88FA-8D0016F30B9C}";
            /// <summary></summary>
            public static readonly Guid NotBuildingAndNotDebugging_guid = new Guid(NotBuildingAndNotDebugging_string);

            /// <summary></summary>
            public const string ProjectRetargeting_string = "{DE039A0E-C18F-490C-944A-888B8E86DA4B}";
            /// <summary></summary>
            public static readonly Guid ProjectRetargeting_guid = new Guid(ProjectRetargeting_string);

            /// <summary></summary>
            public const string SolutionBuilding_string = "{ADFC4E60-0397-11D1-9F4E-00A0C911004F}";
            /// <summary></summary>
            public static readonly Guid SolutionBuilding_guid = new Guid(SolutionBuilding_string);

            /// <summary></summary>
            public const string SolutionExists_string = "{F1536EF8-92EC-443C-9ED7-FDADF150DA82}";
            /// <summary></summary>
            public static readonly Guid SolutionExists_guid = new Guid(SolutionExists_string);

            /// <summary></summary>
            public const string SolutionExistsAndFullyLoaded_string = "{10534154-102D-46E2-ABA8-A6BFA25BA0BE}";
            /// <summary></summary>
            public static readonly Guid SolutionExistsAndFullyLoaded_guid = new Guid(SolutionExistsAndFullyLoaded_string);

            /// <summary></summary>
            public const string SolutionExistsAndNotBuildingAndNotDebugging_string = "{D0E4DEEC-1B53-4CDA-8559-D454583AD23B}";
            /// <summary></summary>
            public static readonly Guid SolutionExistsAndNotBuildingAndNotDebugging_guid = new Guid(SolutionExistsAndNotBuildingAndNotDebugging_string);

            /// <summary></summary>
            public const string SolutionHasMultipleProjects_string = "{93694FA0-0397-11D1-9F4E-00A0C911004F}";
            /// <summary></summary>
            public static readonly Guid SolutionHasMultipleProjects_guid = new Guid(SolutionHasMultipleProjects_string);

            /// <summary></summary>
            public const string SolutionHasSingleProject_string = "{ADFC4E66-0397-11D1-9F4E-00A0C911004F}";
            /// <summary></summary>
            public static readonly Guid SolutionHasSingleProject_guid = new Guid(SolutionHasSingleProject_string);

            /// <summary></summary>
            public const string SolutionOpening_string = "{D2567162-F94F-4091-8798-A096E61B8B50}";
            /// <summary></summary>
            public static readonly Guid SolutionOpening_guid = new Guid(SolutionOpening_string);

            /// <summary></summary>
            public const string SolutionOrProjectUpgrading_string = "{EF4F870B-7B85-4F29-9D15-CE1ABFBE733B}";
            /// <summary></summary>
            public static readonly Guid SolutionOrProjectUpgrading_guid = new Guid(SolutionOrProjectUpgrading_string);

            /// <summary></summary>
            public const string ToolboxInitialized_string = "{DC5DB425-F0FD-4403-96A1-F475CDBA9EE0}";
            /// <summary></summary>
            public static readonly Guid ToolboxInitialized_guid = new Guid(ToolboxInitialized_string);

            /// <summary></summary>
            public const string VBProject_string = "{164B10B9-B200-11D0-8C61-00A0C91E29D5}";
            /// <summary></summary>
            public static readonly Guid VBProject_guid = new Guid(VBProject_string);

            /// <summary></summary>
            public const string CSharpProject_string = "{FAE04EC1-301F-11D3-BF4B-00C04F79EFBC}";
            /// <summary></summary>
            public static readonly Guid CSharpProject_guid = new Guid(CSharpProject_string);

            /// <summary></summary>
            public const string VCProject_string = "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}";
            /// <summary></summary>
            public static readonly Guid VCProject_guid = new Guid(VCProject_string);

            /// <summary></summary>
            public const string FSharpProject_string = "{F2A71F9B-5D33-465A-A702-920D77279786}";
            /// <summary></summary>
            public static readonly Guid FSharpProject_guid = new Guid(FSharpProject_string);

            /// <summary></summary>
            public const string VBCodeAttribute_string = "{C28E28CA-E6DC-446F-BE1A-D496BEF8340A}";
            /// <summary></summary>
            public static readonly Guid VBCodeAttribute_guid = new Guid(VBCodeAttribute_string);

            /// <summary></summary>
            public const string VBCodeClass_string = "{C28E28CA-E6DC-446F-BE1A-D496BEF83401}";
            /// <summary></summary>
            public static readonly Guid VBCodeClass_guid = new Guid(VBCodeClass_string);

            /// <summary></summary>
            public const string VBCodeDelegate_string = "{C28E28CA-E6DC-446F-BE1A-D496BEF83402}";
            /// <summary></summary>
            public static readonly Guid VBCodeDelegate_guid = new Guid(VBCodeDelegate_string);

            /// <summary></summary>
            public const string VBCodeEnum_string = "{C28E28CA-E6DC-446F-BE1A-D496BEF83408}";
            /// <summary></summary>
            public static readonly Guid VBCodeEnum_guid = new Guid(VBCodeEnum_string);

            /// <summary></summary>
            public const string VBCodeFunction_string = "{C28E28CA-E6DC-446F-BE1A-D496BEF83400}";
            /// <summary></summary>
            public static readonly Guid VBCodeFunction_guid = new Guid(VBCodeFunction_string);

            /// <summary></summary>
            public const string VBCodeInterface_string = "{C28E28CA-E6DC-446F-BE1A-D496BEF83406}";
            /// <summary></summary>
            public static readonly Guid VBCodeInterface_guid = new Guid(VBCodeInterface_string);

            /// <summary></summary>
            public const string VBCodeNamespace_string = "{C28E28CA-E6DC-446F-BE1A-D496BEF83409}";
            /// <summary></summary>
            public static readonly Guid VBCodeNamespace_guid = new Guid(VBCodeNamespace_string);

            /// <summary></summary>
            public const string VBCodeParameter_string = "{C28E28CA-E6DC-446F-BE1A-D496BEF83405}";
            /// <summary></summary>
            public static readonly Guid VBCodeParameter_guid = new Guid(VBCodeParameter_string);

            /// <summary></summary>
            public const string VBCodeProperty_string = "{C28E28CA-E6DC-446F-BE1A-D496BEF83404}";
            /// <summary></summary>
            public static readonly Guid VBCodeProperty_guid = new Guid(VBCodeProperty_string);

            /// <summary></summary>
            public const string VBCodeStruct_string = "{C28E28CA-E6DC-446F-BE1A-D496BEF83407}";
            /// <summary></summary>
            public static readonly Guid VBCodeStruct_guid = new Guid(VBCodeStruct_string);

            /// <summary></summary>
            public const string VBCodeVariable_string = "{C28E28CA-E6DC-446F-BE1A-D496BEF83403}";
            /// <summary></summary>
            public static readonly Guid VBCodeVariable_guid = new Guid(VBCodeVariable_string);
        }

        
        //--------------------------------------------------------------------
        // GUIDS for built in task list views
        //--------------------------------------------------------------------
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_VsTaskListViewAll = new Guid("{1880202e-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_VsTaskListViewUserTasks = new Guid("{1880202f-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_VsTaskListViewShortcutTasks = new Guid("{18802030-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_VsTaskListViewHTMLTasks = new Guid("{36ac1c0d-fe86-11d2-8bb1-00c04f8ec28c}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_VsTaskListViewCompilerTasks = new Guid("{18802033-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_VsTaskListViewCommentTasks = new Guid("{18802034-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_VsTaskListViewCurrentFileTasks = new Guid("{18802035-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_VsTaskListViewCheckedTasks = new Guid("{18802036-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_VsTaskListViewUncheckedTasks = new Guid("{18802037-fc20-11d2-8bb1-00c04f8ec28c}");


        /// <summary>
        /// 
        /// </summary>
        public static class VsTaskListView
        {
            //--------------------------------------------------------------------
            // GUIDS for built in task list views
            //--------------------------------------------------------------------
            /// <summary></summary>
            public static readonly Guid All = new Guid("{1880202e-fc20-11d2-8bb1-00c04f8ec28c}");
            /// <summary></summary>
            public static readonly Guid UserTasks = new Guid("{1880202f-fc20-11d2-8bb1-00c04f8ec28c}");
            /// <summary></summary>
            public static readonly Guid ShortcutTasks = new Guid("{18802030-fc20-11d2-8bb1-00c04f8ec28c}");
            /// <summary></summary>
            public static readonly Guid HTMLTasks = new Guid("{36ac1c0d-fe86-11d2-8bb1-00c04f8ec28c}");
            /// <summary></summary>
            public static readonly Guid CompilerTasks = new Guid("{18802033-fc20-11d2-8bb1-00c04f8ec28c}");
            /// <summary></summary>
            public static readonly Guid CommentTasks = new Guid("{18802034-fc20-11d2-8bb1-00c04f8ec28c}");
            /// <summary></summary>
            public static readonly Guid CurrentFileTasks = new Guid("{18802035-fc20-11d2-8bb1-00c04f8ec28c}");
            /// <summary></summary>
            public static readonly Guid CheckedTasks = new Guid("{18802036-fc20-11d2-8bb1-00c04f8ec28c}");
            /// <summary></summary>
            public static readonly Guid UncheckedTasks = new Guid("{18802037-fc20-11d2-8bb1-00c04f8ec28c}");
        }
        
        
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid CLSID_VsTaskList = new Guid("{BC5955D5-aa0d-11d0-a8c5-00a0c921a4d2}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid CLSID_VsTaskListPackage = new Guid("{4A9B7E50-aa16-11d0-a8c5-00a0c921a4d2}");


        /// <summary></summary>
        public static readonly Guid SID_SVsToolboxActiveXDataProvider = new Guid("{35222106-bb44-11d0-8c46-00c04fc2aae2}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid CLSID_VsDocOutlinePackage = new Guid("{21af45b0-ffa5-11d0-b63f-00a0c922e851}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid CLSID_VsCfgProviderEventsHelper = new Guid("{99913f1f-1ee3-11d1-8a6e-00c04f682e21}");


        //--------------------------------------------------------------------
        // Component Selector page GUIDs
        //--------------------------------------------------------------------
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_COMPlusPage = new Guid("{9A341D95-5A64-11d3-BFF9-00C04F990235}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_COMClassicPage = new Guid("{9A341D96-5A64-11d3-BFF9-00C04F990235}");
        /// <summary></summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid GUID_SolutionPage = new Guid("{9A341D97-5A64-11d3-BFF9-00C04F990235}");


        /// <summary>
        /// 
        /// </summary>
        public static class ComponentSelectorPageGuid
        {
            /// <summary>.Net managed assembly page (used with SVsComponentSelectorDlg -- Add Reference dialog)</summary>
            public const string ManagedAssemblyPage_string = "{9A341D95-5A64-11D3-BFF9-00C04F990235}";
            public static readonly Guid ManagedAssemblyPage_guid = new Guid(ManagedAssemblyPage_string);

            /// <summary>COM object page (used with SVsComponentSelectorDlg -- Add Reference dialog)</summary>
            public const string COMPage_string = "{9A341D96-5A64-11D3-BFF9-00C04F990235}";
            public static readonly Guid COMPage_guid = new Guid(COMPage_string);

            /// <summary>Projects page (used with SVsComponentSelectorDlg -- Add Reference dialog)</summary>
            public const string ProjectsPage_string = "{9A341D97-5A64-11D3-BFF9-00C04F990235}";
            public static readonly Guid ProjectsPage_guid = new Guid(ProjectsPage_string);

        }

        //--------------------------------------------------------------------
        // Logical View GUIDs
        //--------------------------------------------------------------------
        /// <summary>Kind of view for document or data: Any defined view.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid LOGVIEWID_Any = new Guid(0xffffffff, 0xffff, 0xffff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff);
        /// <summary>Kind of view for document or data: Primary (default) view.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid LOGVIEWID_Primary = Guid.Empty;
        /// <summary>Kind of view for document or data: Debugger view.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid LOGVIEWID_Debugging = new Guid("{7651A700-06E5-11D1-8EBD-00A0C90F26EA}");
        /// <summary>Kind of view for document or data: Code editor view.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid LOGVIEWID_Code = new Guid("{7651A701-06E5-11D1-8EBD-00A0C90F26EA}");
        /// <summary>Kind of view for document or data: Designer view.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid LOGVIEWID_Designer = new Guid("{7651A702-06E5-11D1-8EBD-00A0C90F26EA}");
        /// <summary>Kind of view for document or data: Text editor view.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid LOGVIEWID_TextView = new Guid("{7651A703-06E5-11D1-8EBD-00A0C90F26EA}");
        /// <summary>Kind of view for document or data: A user defined view.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly Guid LOGVIEWID_UserChooseView = new Guid("{7651A704-06E5-11D1-8EBD-00A0C90F26EA}");



        /// <summary>
        /// 
        /// </summary>
        public static class LOGVIEWID
        {
            /// <summary>Kind of view for document or data: Any defined view.</summary>
            public const string Any_string = "{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}";
            /// <summary>Kind of view for document or data: Any defined view.</summary>
            public static readonly Guid Any_guid = new Guid(Any_string);

            /// <summary>Kind of view for document or data: Code editor view.</summary>
            public const string Code_string = "{7651A701-06E5-11D1-8EBD-00A0C90F26EA}";
            /// <summary>Kind of view for document or data: Code editor view.</summary>
            public static readonly Guid Code_guid = new Guid(Code_string);

            /// <summary>Kind of view for document or data: Debugger view.</summary>
            public const string Debugging_string = "{7651A700-06E5-11D1-8EBD-00A0C90F26EA}";
            /// <summary>Kind of view for document or data: Debugger view.</summary>
            public static readonly Guid Debugging_guid = new Guid(Debugging_string);

            /// <summary>Kind of view for document or data: Designer view.</summary>
            public const string Designer_string = "{7651A702-06E5-11D1-8EBD-00A0C90F26EA}";
            /// <summary>Kind of view for document or data: Designer view.</summary>
            public static readonly Guid Designer_guid = new Guid(Designer_string);

            /// <summary></summary>
            public const string ProjectSpecificEditor_string = "{80A3471A-6B87-433E-A75A-9D461DE0645F}";
            /// <summary></summary>
            public static readonly Guid ProjectSpecificEditor_guid = new Guid(ProjectSpecificEditor_string);

            /// <summary>Kind of view for document or data: Primary (default) view.</summary>
            public static readonly Guid Primary_guid = Guid.Empty;

            /// <summary>Kind of view for document or data: Text editor view.</summary>
            public const string TextView_string = "{7651A703-06E5-11D1-8EBD-00A0C90F26EA}";
            /// <summary>Kind of view for document or data: Text editor view.</summary>
            public static readonly Guid TextView_guid = new Guid(TextView_string);

            /// <summary>Kind of view for document or data: A user defined view.</summary>
            public const string UserChooseView_string = "{7651A704-06E5-11D1-8EBD-00A0C90F26EA}";
            /// <summary>Kind of view for document or data: A user defined view.</summary>
            public static readonly Guid UserChooseView_guid = new Guid(UserChooseView_string);

        }

        // VS Constants

        /// <summary>Special items inside a VsHierarchy: no node.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public const uint VSITEMID_NIL = unchecked((uint)-1);
        /// <summary>Special items inside a VsHierarchy: the hierarchy itself.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public const uint VSITEMID_ROOT = unchecked((uint)-2);
        /// <summary>Special items inside a VsHierarchy: all the currently selected items.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public const uint VSITEMID_SELECTION = unchecked((uint)-3);

        public enum VSITEMID : uint
        {
            /// <summary>Special items inside a VsHierarchy: no node.</summary>
            Nil = unchecked((uint)-1),
            /// <summary>Special items inside a VsHierarchy: the hierarchy itself.</summary>
            Root= unchecked((uint)-2),
            /// <summary>Special items inside a VsHierarchy: all the currently selected items.</summary>
            Selection = unchecked((uint)-3),
        }
        
        /// <summary>Special value for a cookie (e.g. returned from IVsRunningDocumentTable.FindAndLockDocument): no cookie.</summary>
        public const uint VSCOOKIE_NIL = 0;


        // for IVsSelectionEvents flags
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: The undo manager.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public const uint UndoManager = 0x0;
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: A window frame.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public const uint WindowFrame = 0x1;
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: A document frame.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public const uint DocumentFrame = 0x2;
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: The startup project.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public const uint StartupProject = 0x3;
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: The property borowser.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public const uint PropertyBrowserSID = 0x4;
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: A user context.</summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public const uint UserContext = 0x5;

        public enum SelectionElement : uint
        {
            // for IVsSelectionEvents flags
            /// <summary>IVsSelectionEvents.OnElementValueChanged flag: The undo manager.</summary>
            UndoManager = 0x0,
            /// <summary>IVsSelectionEvents.OnElementValueChanged flag: A window frame.</summary>
            WindowFrame = 0x1,
            /// <summary>IVsSelectionEvents.OnElementValueChanged flag: A document frame.</summary>
            DocumentFrame = 0x2,
            /// <summary>IVsSelectionEvents.OnElementValueChanged flag: The startup project.</summary>
            StartupProject = 0x3,
            /// <summary>IVsSelectionEvents.OnElementValueChanged flag: The property borowser.</summary>
            PropertyBrowserSID = 0x4,
            /// <summary>IVsSelectionEvents.OnElementValueChanged flag: A user context.</summary>
            UserContext = 0x5
        }



        // VS HRESULTS

        /// <summary>VS specific error HRESULT for "Project already exists".</summary>
        public const int VS_E_PROJECTALREADYEXISTS = unchecked((int)0x80041FE0);
        /// <summary>VS specific error HRESULT for "Package not loaded".</summary>
        public const int VS_E_PACKAGENOTLOADED = unchecked((int)0x80041FE1);
        /// <summary>VS specific error HRESULT for "Project not loaded".</summary>
        public const int VS_E_PROJECTNOTLOADED = unchecked((int)0x80041FE2);
        /// <summary>VS specific error HRESULT for "Solution not open".</summary>
        public const int VS_E_SOLUTIONNOTOPEN = unchecked((int)0x80041FE3);
        /// <summary>VS specific error HRESULT for "Solution already open".</summary>
        public const int VS_E_SOLUTIONALREADYOPEN = unchecked((int)0x80041FE4);
        /// <summary>VS specific error HRESULT for "Project configuration failed".</summary>
        public const int VS_E_PROJECTMIGRATIONFAILED = unchecked((int)0x80041FE5);
        /// <summary>VS specific error HRESULT for "Incompatible document data".</summary>
        public const int VS_E_INCOMPATIBLEDOCDATA = unchecked((int)0x80041FEA);
        /// <summary>VS specific error HRESULT for "Unsupported format".</summary>
        public const int VS_E_UNSUPPORTEDFORMAT = unchecked((int)0x80041FEB);
        /// <summary>VS specific error HRESULT for "Wizard back button pressed".</summary>
        public const int VS_E_WIZARDBACKBUTTONPRESS = unchecked((int)0x80041fff);
        /// <summary>VS specific success HRESULT for "Project forwarded".</summary>
        public const int VS_S_PROJECTFORWARDED = unchecked((int)0x41ff0);
        /// <summary>VS specific success HRESULT for "Toolbox marker".</summary>
        public const int VS_S_TBXMARKER = unchecked((int)0x41ff1);

        // Selection Containter Constants
        public const uint ALL = 0x1;
        public const uint SELECTED = 0x2;

        // OLE HRESULTS - may be returned by OLE or related VS methods
        public const int
        OLE_E_OLEVERB = unchecked((int)0x80040000),
        OLE_E_ADVF = unchecked((int)0x80040001),
        OLE_E_ENUM_NOMORE = unchecked((int)0x80040002),
        OLE_E_ADVISENOTSUPPORTED = unchecked((int)0x80040003),
        OLE_E_NOCONNECTION = unchecked((int)0x80040004),
        OLE_E_NOTRUNNING = unchecked((int)0x80040005),
        OLE_E_NOCACHE = unchecked((int)0x80040006),
        OLE_E_BLANK = unchecked((int)0x80040007),
        OLE_E_CLASSDIFF = unchecked((int)0x80040008),
        OLE_E_CANT_GETMONIKER = unchecked((int)0x80040009),
        OLE_E_CANT_BINDTOSOURCE = unchecked((int)0x8004000A),
        OLE_E_STATIC = unchecked((int)0x8004000B),
        OLE_E_PROMPTSAVECANCELLED = unchecked((int)0x8004000C),
        OLE_E_INVALIDRECT = unchecked((int)0x8004000D),
        OLE_E_WRONGCOMPOBJ = unchecked((int)0x8004000E),
        OLE_E_INVALIDHWND = unchecked((int)0x8004000F),
        OLE_E_NOT_INPLACEACTIVE = unchecked((int)0x80040010),
        OLE_E_CANTCONVERT = unchecked((int)0x80040011),
        OLE_E_NOSTORAGE = unchecked((int)0x80040012);

        // OLE DISP HRESULTS - may be returned by OLE DISP or related VS methods 

        public const int
        DISP_E_UNKNOWNINTERFACE = unchecked((int)0x80020001),
        DISP_E_MEMBERNOTFOUND = unchecked((int)0x80020003),
        DISP_E_PARAMNOTFOUND = unchecked((int)0x80020004),
        DISP_E_TYPEMISMATCH = unchecked((int)0x80020005),
        DISP_E_UNKNOWNNAME = unchecked((int)0x80020006),
        DISP_E_NONAMEDARGS = unchecked((int)0x80020007),
        DISP_E_BADVARTYPE = unchecked((int)0x80020008),
        DISP_E_EXCEPTION = unchecked((int)0x80020009),
        DISP_E_OVERFLOW = unchecked((int)0x8002000A),
        DISP_E_BADINDEX = unchecked((int)0x8002000B),
        DISP_E_UNKNOWNLCID = unchecked((int)0x8002000C),
        DISP_E_ARRAYISLOCKED = unchecked((int)0x8002000D),
        DISP_E_BADPARAMCOUNT = unchecked((int)0x8002000E),
        DISP_E_PARAMNOTOPTIONAL = unchecked((int)0x8002000F),
        DISP_E_BADCALLEE = unchecked((int)0x80020010),
        DISP_E_NOTACOLLECTION = unchecked((int)0x80020011),
        DISP_E_DIVBYZERO = unchecked((int)0x80020012),
        DISP_E_BUFFERTOOSMALL = unchecked((int)0x80020013);


        //-----------------------------------------------------------------------------
        //  VS_E_BUSY is returned by interfaces to asynchronous behavior when the
        //  object in question in already busy.  For example, starting a build while
        //  a buildable project configuration object is in the process of cleaning,
        //  building or checking for out of date-ness.
        //-----------------------------------------------------------------------------
        /// <summary>
        /// VS specific error HRESULT returned by interfaces to asynchronous behavior when the
        /// object in question in already busy.
        /// </summary>
        public const int VS_E_BUSY = unchecked((int)0x80040200);
        /// <summary>
        /// Is returned by build interfaces that have parameters for specifying an array of IVsOutput's
        /// but the implementation can only apply the method to all outputs.
        /// </summary>
        public const int VS_E_SPECIFYING_OUTPUT_UNSUPPORTED = unchecked((int)0x80040201);

        // General HRESULTS

        /// <summary>HRESULT for FALSE (not an error).</summary>
        public const int S_FALSE = 0x00000001;
        /// <summary>HRESULT for generic success.</summary>
        public const int S_OK = 0x00000000;
        /// <summary>Error HRESULT for a client abort.</summary>
        public const int UNDO_E_CLIENTABORT = unchecked((int)0x80044001);
        /// <summary>Error HRESULT for out of memory.</summary>
        public const int E_OUTOFMEMORY = unchecked((int)0x8007000E);
        /// <summary>Error HRESULT for an invalid argument.</summary>
        public const int E_INVALIDARG = unchecked((int)0x80070057);
        /// <summary>Error HRESULT for a generic failure.</summary>
        public const int E_FAIL = unchecked((int)0x80004005);
        /// <summary>Error HRESULT for the request of a not implemented interface.</summary>
        public const int E_NOINTERFACE = unchecked((int)0x80004002);
        /// <summary>Error HRESULT for the call to a not implemented method.</summary>
        public const int E_NOTIMPL = unchecked((int)0x80004001);
        /// <summary>Error HRESULT for an unexpected condition.</summary>
        public const int E_UNEXPECTED = unchecked((int)0x8000FFFF);
        /// <summary>Error HRESULT for a null or invalid pointer.</summary>
        public const int E_POINTER = unchecked((int)0x80004003);
        /// <summary>Error HRESULT for an invalid HANDLE.</summary>
        public const int E_HANDLE = unchecked((int)0x80070006);
        /// <summary>Error HRESULT for an abort.</summary>
        public const int E_ABORT = unchecked((int)0x80004004);
        /// <summary>Error HRESULT for an access denied.</summary>
        public const int E_ACCESSDENIED = unchecked((int)0x80070005);
        /// <summary>Error HRESULT for a pending condition.</summary>
        public const int E_PENDING = unchecked((int)0x8000000A);

        // Window Messages
        internal const int WM_USER = 0x0400;

        // VS specific messages
        // These definitions are for broadcasting a notification message via
        //   IVsBroadcastMessageEvents::OnBroadcastMessage to indicate that the cmdbar
        //   metrics have changed.
        /// <summary>Toolbar metrics changed.</summary>
        public const int VSM_TOOLBARMETRICSCHANGE = WM_USER + 0x0C52;
        /// <summary></summary>
        public const int VSM_ENTERMODAL = WM_USER + 0x0C53;
        /// <summary></summary>
        public const int VSM_EXITMODAL = WM_USER + 0x0C54;

        // messages sent from Component Selector dialog to page dialogs.
        /// <summary>Inform of selection change on page.</summary>
        public const int CPDN_SELCHANGED = WM_USER + 1280;
        /// <summary>Inform of doubld-click on selected item on page.</summary>
        public const int CPDN_SELDBLCLICK = WM_USER + 1281;
        /// <summary>Initialize list of available components.</summary>
        public const int CPPM_INITIALIZELIST = WM_USER + 1285;
        /// <summary>Determine whether Select button should be enabled.</summary>
        public const int CPPM_QUERYCANSELECT = WM_USER + 1286;
        /// <summary>Retrieve information about selection.</summary>
        public const int CPPM_GETSELECTION = WM_USER + 1287;
        /// <summary>Initialize tab with VARIANT in VSCOMPONENTSELECTORTABINIT.</summary>
        public const int CPPM_INITIALIZETAB = WM_USER + 1288;
        /// <summary>Set multiple-selection mode for picker.</summary>
        public const int CPPM_SETMULTISELECT = WM_USER + 1289;
        /// <summary>Reset and clear selection in list of available components.</summary>
        public const int CPPM_CLEARSELECTION = WM_USER + 1290;

    }

    [CLSCompliant(false)]
    public class Win32Methods
    {
        /// <summary>
        /// Changes the parent window of the specified child window.
        /// </summary>
        /// <param name="hWnd">Handle to the child window.</param>
        /// <param name="hWndParent">Handle to the new parent window. If this parameter is NULL, the desktop window becomes the new parent window.</param>
        /// <returns>A handle to the previous parent window indicates success. NULL indicates failure.</returns>
        [DllImport("User32", ExactSpelling = true, CharSet = CharSet.Auto)]
        public static extern IntPtr SetParent(IntPtr hWnd, IntPtr hWndParent);

        [DllImport("user32.dll", EntryPoint = "IsDialogMessageA", SetLastError = true, CharSet = CharSet.Ansi, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
        public static extern bool IsDialogMessageA(IntPtr hDlg, ref MSG msg);

    }

    [ComImport(), Guid("9BDA66AE-CA28-4e22-AA27-8A7218A0E3FA"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    public interface IEventHandler
    {

        // converts the underlying codefunction into an event handler for the given event
        // if the given event is NULL, then the function will handle no events
        [PreserveSig]
        int AddHandler(string bstrEventName);

        [PreserveSig]
        int RemoveHandler(string bstrEventName);

        IVsEnumBSTR GetHandledEvents();

        bool HandlesEvent(string bstrEventName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\VsShellUtilities.cs ===
//--------------------------------------------------------------------------
//  <copyright file="VSShellUtilities.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <devdoc>
//  </devdoc>
//--------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;
using System.Windows.Forms.Design;
using EnvDTE;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.TextManager.Interop;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;

namespace Microsoft.VisualStudio.Shell
{

    /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities"]/*' />
    /// <devdoc>
    ///This class provides some useful static shell based methods. 
    /// </devdoc>
    [CLSCompliant(false)]
    public static class VsShellUtilities
    {

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.RenameDocument"]/*' />
        /// <devdoc>
        /// Rename document in the running document table from oldName to newName.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="oldName">Full path to the old name of the document.</param>        
        /// <param name="newName">Full path to the new name of the document.</param>        
        public static void RenameDocument(IServiceProvider site, string oldName, string newName)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(oldName))
            { 
                throw new ArgumentException("oldName");
            }

            if (String.IsNullOrEmpty(newName))
            {
                throw new ArgumentException("newName");
            }

            IVsRunningDocumentTable pRDT = site.GetService(typeof(SVsRunningDocumentTable)) as IVsRunningDocumentTable;
            IVsUIShellOpenDocument doc = site.GetService(typeof(SVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            IVsUIShell uiShell = site.GetService(typeof(SVsUIShell)) as IVsUIShell;

            if (pRDT == null || doc == null) return;

            IVsHierarchy pIVsHierarchy;
            uint itemId;
            IntPtr docData;
            uint uiVsDocCookie;
            ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, oldName, out pIVsHierarchy, out itemId, out docData, out uiVsDocCookie));

            if (docData != IntPtr.Zero)
            {
                try
                {
                    IntPtr pUnk = Marshal.GetIUnknownForObject(pIVsHierarchy);
                    Guid iid = typeof(IVsHierarchy).GUID;
                    IntPtr pHier;
                    Marshal.QueryInterface(pUnk, ref iid, out pHier);
                    try
                    {
                        ErrorHandler.ThrowOnFailure(pRDT.RenameDocument(oldName, newName, pHier, itemId));
                    }
                    finally
                    {
                        Marshal.Release(pHier);
                        Marshal.Release(pUnk);
                    }

                    string newCaption = Path.GetFileName(newName);
                    // now we need to tell the windows to update their captions. 
                    List<IVsWindowFrame> windowFrames = GetFramesForDocument(site, Marshal.GetObjectForIUnknown(docData));
                    foreach (IVsWindowFrame frame in windowFrames) {
                        ErrorHandler.ThrowOnFailure(frame.SetProperty((int)__VSFPROPID.VSFPROPID_OwnerCaption, newCaption));
                    }
                }
                finally
                {
                    Marshal.Release(docData);
                }
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocument"]/*' />
        /// <devdoc>
        /// Open document using the appropriate project. 
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document.</param>
        /// <param name="logicalView">In MultiView case determines view to be activated by IVsMultiViewDocumentView. For a list of logical view GUIDS, see constants starting with LOGVIEWID_ defined in NativeMethods class</param>
        /// <param name="hierarchy">Reference to the IVsUIHierarchy interface of the project that can open the document.</param>
        /// <param name="itemID"> Reference to the hierarchy item identifier of the document in the project.</param>
        /// <param name="windowFrame">A reference to the window frame that is mapped to the document.</param>
        /// <param name="view">A reference to the primary view of the document.</param>
        public static void OpenDocument(IServiceProvider provider, string fullPath, Guid logicalView, out IVsUIHierarchy hierarchy, out uint itemID, out IVsWindowFrame windowFrame, out IVsTextView view)
        {
            itemID = VSConstants.VSITEMID_NIL;
            windowFrame = null;
            hierarchy = null;
            view = null;

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            OpenDocument(provider, fullPath, logicalView, out hierarchy, out itemID, out windowFrame);
            view = GetTextView(windowFrame);
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocument"]/*' />
        /// <devdoc>
        /// Open document using the appropriate project. 
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document.</param>
        /// <param name="logicalView">GUID identifying the logical view.</param>
        /// <param name="hierarchy">Reference to the IVsUIHierarchy interface of the project that contains the Open document.</param>
        /// <param name="itemID"> Reference to the hierarchy item identifier of the document in the project.</param>
        /// <param name="windowFrame">A reference to the window frame that is mapped to the document.</param>
        public static void OpenDocument(IServiceProvider provider, string fullPath, Guid logicalView, out IVsUIHierarchy hierarchy, out uint itemID, out IVsWindowFrame windowFrame)
        {
            windowFrame = null;
            itemID = VSConstants.VSITEMID_NIL;
            hierarchy = null;

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            //open document
            if (!IsDocumentOpen(provider, fullPath, logicalView, out hierarchy, out itemID, out windowFrame))
            {
                IVsUIShellOpenDocument shellOpenDoc = provider.GetService(typeof(IVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
                if (shellOpenDoc != null)
                {
                    IOleServiceProvider psp;
                    uint itemid;
                    ErrorHandler.ThrowOnFailure(shellOpenDoc.OpenDocumentViaProject(fullPath, ref logicalView, out psp, out hierarchy, out itemid, out windowFrame));
                }
            }
            if (windowFrame != null)
            {
                ErrorHandler.ThrowOnFailure(windowFrame.Show());
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetTextView"]/*' />
        /// <devdoc>
        /// Get primary view for a window frame.
        /// </devdoc>
        /// <param name="windowFrame">The window frame</param>
        /// <returns>A reference to an IVsTextView if successful. Otherwise null.</returns>
        public static IVsTextView GetTextView(IVsWindowFrame windowFrame)
        {
            if (windowFrame == null)
            {
                throw new ArgumentException("windowFrame");
            }

            object pvar;
            ErrorHandler.ThrowOnFailure(windowFrame.GetProperty((int)__VSFPROPID.VSFPROPID_DocView, out pvar));

            IVsTextView textView = pvar as IVsTextView;

            if (textView == null)
            {
                IVsCodeWindow codeWin = pvar as IVsCodeWindow;
                if (codeWin != null)
                {
                    ErrorHandler.ThrowOnFailure(codeWin.GetPrimaryView(out textView));
                }
            }
            return textView;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetWindowObject"]/*' />
        /// <devdoc>
        /// Get Window interface for the window frame.
        /// </devdoc>
        /// <param name="windowFrame">The window frame.</param>
        /// <returns>A reference to the Window interaface if succesfull. Otherwise null.</returns>
        public static EnvDTE.Window GetWindowObject(IVsWindowFrame windowFrame)
        {
            if (windowFrame == null)
            {
                throw new ArgumentException("windowFrame");
            }

            EnvDTE.Window window = null;
            object pvar;
            ErrorHandler.ThrowOnFailure(windowFrame.GetProperty((int)__VSFPROPID.VSFPROPID_ExtWindowObject, out pvar));
            if (pvar is EnvDTE.Window)
            {
                window = (EnvDTE.Window)pvar;
            }
            return window;

        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.IsDocumentOpen"]/*' />
        /// <devdoc>
        /// Determine if a document is opened with a given logical view.  
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document</param>
        /// <param name="logicalView">GUID identifying the logical view. If logicalView is set to Guid.Empty, it will return true if any view is open.</param>
        /// <param name="hierarchy">Reference to the IVsUIHierarchy interface of the project that contains the Open document</param>
        /// <param name="itemID"> Reference to the hierarchy item identifier of the document in the project</param>
        /// <param name="windowFrame">A reference to the window frame that is mapped to the document</param>
        /// <returns>true if the document is open with the given logical view</returns>
        public static bool IsDocumentOpen(IServiceProvider provider, string fullPath, Guid logicalView, out IVsUIHierarchy hierarchy, out uint itemID, out IVsWindowFrame windowFrame)
        {
            windowFrame = null;
            itemID = VSConstants.VSITEMID_NIL;
            hierarchy = null;

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            //open document
            IVsUIShellOpenDocument shellOpenDoc = provider.GetService(typeof(IVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            IVsRunningDocumentTable pRDT = provider.GetService(typeof(IVsRunningDocumentTable)) as IVsRunningDocumentTable;
            if (pRDT != null && shellOpenDoc != null)
            {
                IntPtr punkDocData = IntPtr.Zero;
                uint docCookie;
                uint[] pitemid = new uint[1];
                IVsHierarchy ppIVsHierarchy;
                try
                {
                    ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, fullPath, out ppIVsHierarchy, out pitemid[0], out punkDocData, out docCookie));
                    int pfOpen;
                    uint flags = (logicalView == Guid.Empty) ? (uint)__VSIDOFLAGS.IDO_IgnoreLogicalView : 0;
                    ErrorHandler.ThrowOnFailure(shellOpenDoc.IsDocumentOpen((IVsUIHierarchy)ppIVsHierarchy, pitemid[0], fullPath, ref logicalView, flags, out hierarchy, pitemid, out windowFrame, out pfOpen));
                    if (windowFrame != null)
                    {
                        itemID = pitemid[0];
                        return (pfOpen == 1);
                    }
                }
                finally
                {
                    if (punkDocData != IntPtr.Zero)
                    {
                        Marshal.Release(punkDocData);
                    }
                }
            }
            return false;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenAsMiscellaneousFile"]/*' />
        /// <devdoc>
        /// Open a file using the miscellaneous project.
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="path">Path to the item to open.</param>
        /// <param name="caption">Caption of the item.</param>
        /// <param name="editor">Unique identifier of the editor type.</param>
        /// <param name="physicalView">Name of physical view.</param>
        /// <param name="logicalView">Name of logical view.</param>
        public static void OpenAsMiscellaneousFile(IServiceProvider provider, string path, string caption, Guid editor, string physicalView, Guid logicalView)
        {

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(path))
            {
                throw new ArgumentException("path");
            }

            IVsProject3 proj = VsShellUtilities.GetMiscellaneousProject(provider);
            VSADDRESULT[] result = new VSADDRESULT[1];
            // NOTE: This method must use VSADDITEMOPERATION.VSADDITEMOP_CLONEFILE.
            // VSADDITEMOPERATION.VSADDITEMOP_OPENFILE doesn't work.
            VSADDITEMOPERATION op = VSADDITEMOPERATION.VSADDITEMOP_CLONEFILE;
            __VSCREATEEDITORFLAGS flags = __VSCREATEEDITORFLAGS.CEF_CLONEFILE;
            ErrorHandler.ThrowOnFailure(proj.AddItemWithSpecific(VSConstants.VSITEMID_NIL, op, caption, 1, new string[1] { path }, IntPtr.Zero,
                (uint)flags, ref editor, physicalView, ref logicalView, result));

            if (result[0] != VSADDRESULT.ADDRESULT_Success)
            {
                throw new ApplicationException(result[0].ToString());
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetMiscellaneousProject"]/*' />
        /// <devdoc>
        /// Get miscellaneous project from current solution
        /// </devdoc>
        /// <param name="provider">The service provider</param>
        /// <returns>A refernce to the IVsProject3 interface for the misceleneous project.</returns>
        public static IVsProject3 GetMiscellaneousProject(IServiceProvider provider)
        {
            if (provider == null)
            {
                throw new ArgumentNullException("provider");
            }

            // Get the IVsExternalFilesManager interface on the SVsExternalFilesManager service.
            IVsExternalFilesManager externalFileMgr = (IVsExternalFilesManager)provider.GetService(typeof(SVsExternalFilesManager));
            if (null == externalFileMgr)
            {
                return null;
            }

            // Now use the external file manager to the the external file project.
            // Note that this project will be created if it does not exist.
            IVsProject prj;
            ErrorHandler.ThrowOnFailure(externalFileMgr.GetExternalFilesProject(out prj));

            // QI for IVsProject3 and return it.
            return prj as IVsProject3;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetMiscellaneousProject"]/*' />
        /// <devdoc>
        /// Get miscellaneous project from current solution
        /// </devdoc>
        /// <param name="provider">The service provider</param>
        /// <param name="create">If false, does not force creation of the misc project</param>
        /// <returns>A refernce to the IVsProject3 interface for the misceleneous project.</returns>
        public static IVsProject3 GetMiscellaneousProject(IServiceProvider provider, bool create)
        {
            if (provider == null)
            {
                throw new ArgumentNullException("provider");
            }

            IVsHierarchy miscHierarchy = null;
            Guid miscProj = VSConstants.CLSID_MiscellaneousFilesProject;
            IVsSolution2 sln = (IVsSolution2)provider.GetService(typeof(SVsSolution));
            int hr = sln.GetProjectOfGuid(ref miscProj, out miscHierarchy);

            if ((NativeMethods.Failed(hr) || miscHierarchy == null) && create)
            {
                return GetMiscellaneousProject(provider);
            }
            return miscHierarchy as IVsProject3;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocument"]/*' />
        /// <devdoc>
        /// Open a document.
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="path">Full path to the document.</param>
        public static void OpenDocument(IServiceProvider provider, string path)
        {
            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(path))
            {
                throw new ArgumentException("path");
            }

            IVsUIHierarchy hierarchy;
            uint itemID;
            IVsWindowFrame windowFrame;
            Guid logicalView = Guid.Empty;
            VsShellUtilities.OpenDocument(provider, path, logicalView, out hierarchy, out itemID, out windowFrame);
            windowFrame = null;
            hierarchy = null;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocumentWithSpecificEditor"]/*' />
        /// <devdoc>
        /// Open a document using a specific editor. 
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document.</param>
        /// <param name="editorType">Unique identifier of the editor type.</param>
        /// <param name="logicalView">In MultiView case determines view to be activated by IVsMultiViewDocumentView. For a list of logical view GUIDS, see constants starting with LOGVIEWID_ defined in NativeMethods class</param>
        /// <returns>A reference to the window frame that is mapped to the document.</returns>
        public static IVsWindowFrame OpenDocumentWithSpecificEditor(IServiceProvider provider, string fullPath, Guid editorType, Guid logicalView)
        {
            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            IVsUIHierarchy hierarchy;
            uint itemID;
            IVsWindowFrame windowFrame;
            OpenDocumentWithSpecificEditor(provider, fullPath, editorType, logicalView, out hierarchy, out itemID, out windowFrame);
            hierarchy = null;
            return windowFrame;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocumentWithSpecificEditor"]/*' />
        /// <devdoc>
        /// Open a document using a specific editor. 
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document.</param>
        /// <param name="editorType">Unique identifier of the editor type.</param>
        /// <param name="logicalView">In MultiView case determines view to be activated by IVsMultiViewDocumentView. For a list of logical view GUIDS, see constants starting with LOGVIEWID_ defined in NativeMethods class</param>
        /// <param name="hierarchy">Reference to the IVsUIHierarchy interface of the project that can open the document.</param>
        /// <param name="itemID"> Reference to the hierarchy item identifier of the document in the project.</param>
        /// <param name="windowFrame">A reference to the window frame that is mapped to the document.</param>
        public static void OpenDocumentWithSpecificEditor(IServiceProvider provider, string fullPath, Guid editorType, Guid logicalView, out IVsUIHierarchy hierarchy, out uint itemID, out IVsWindowFrame windowFrame)
        {
            windowFrame = null;
            itemID = VSConstants.VSITEMID_NIL;
            hierarchy = null;

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            //open document
            IVsUIShellOpenDocument shellOpenDoc = provider.GetService(typeof(IVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            IVsRunningDocumentTable pRDT = provider.GetService(typeof(IVsRunningDocumentTable)) as IVsRunningDocumentTable;
            string physicalView = null;
            if (pRDT != null && shellOpenDoc != null)
            {
                ErrorHandler.ThrowOnFailure(shellOpenDoc.MapLogicalView(ref editorType, ref logicalView, out physicalView));
                // See if the requested editor is already open with the requested view.
                IntPtr punkDocData = IntPtr.Zero;
                uint docCookie;
                IVsHierarchy ppIVsHierarchy;
                try
                {
                    ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, fullPath, out ppIVsHierarchy, out itemID, out punkDocData, out docCookie));                    
                    int pfOpen;
                    uint flags = (uint)__VSIDOFLAGS.IDO_ActivateIfOpen;
                    int hr = shellOpenDoc.IsSpecificDocumentViewOpen((IVsUIHierarchy)ppIVsHierarchy, itemID, fullPath, ref editorType, physicalView, flags, out hierarchy, out itemID, out windowFrame, out pfOpen);
                    if (ErrorHandler.Succeeded(hr) && pfOpen == 1)
                    {
                        return;
                    }
                }
                finally
                { 
                    if (punkDocData != IntPtr.Zero)
                    {
                        Marshal.Release(punkDocData);
                    }
                }

                IOleServiceProvider psp;
                uint editorFlags = (uint)__VSSPECIFICEDITORFLAGS.VSSPECIFICEDITOR_UseEditor | (uint)__VSSPECIFICEDITORFLAGS.VSSPECIFICEDITOR_DoOpen;
                ErrorHandler.ThrowOnFailure(shellOpenDoc.OpenDocumentViaProjectWithSpecific(fullPath, editorFlags, ref editorType, physicalView, ref logicalView, out psp, out hierarchy, out itemID, out windowFrame));
                if (windowFrame != null)
                    ErrorHandler.ThrowOnFailure(windowFrame.Show());
                psp = null;
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetProject"]/*' />
        /// <devdoc>
        /// Get reference to the IVsHierarchy interface for project that owns the document.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="moniker">The document moniker.</param>
        /// <returns>
        /// If the document is open, this is a reference to the IVsUIHierarchy Interface implementation of the project that owns the document. 
        /// If the document is not open, the value of this parameter is NULL. 
        /// </returns>
        public static IVsHierarchy GetProject(IServiceProvider site, string moniker)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(moniker))
            {
                throw new ArgumentException("moniker");
            }

            IVsUIShellOpenDocument opendoc = site.GetService(typeof(SVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            IVsUIHierarchy hierarchy = null;
            uint pitemid;
            IOleServiceProvider sp;
            int docInProj;
            int rc = opendoc.IsDocumentInAProject(moniker, out hierarchy, out pitemid, out sp, out docInProj);
            ErrorHandler.ThrowOnFailure(rc);
            return hierarchy as IVsHierarchy;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetRunningDocumentContents"]/*' />
        /// <devdoc>
        /// Get contents of file loaded by the running document table.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="path">Path to the file.</param>
        /// <returns>The contents of the file if it is loaded by RDT. Otherwise it returns null.</returns>
        public static string GetRunningDocumentContents(IServiceProvider site, string path)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(path))
            {
                throw new ArgumentException("path");
            }

            string text = null;
            IVsRunningDocumentTable pRDT = (IVsRunningDocumentTable)site.GetService(typeof(SVsRunningDocumentTable));
            if (pRDT != null)
            {
                IntPtr punkDocData = IntPtr.Zero;
                uint pitemid;
                uint docCookie;
                IVsHierarchy ppIVsHierarchy;
                try
                {
                    ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, path, out ppIVsHierarchy, out pitemid, out punkDocData, out docCookie));
                    if (punkDocData != IntPtr.Zero)
                    {
                        object docDataObj = Marshal.GetObjectForIUnknown(punkDocData);
                        IVsTextLines buffer = null;
                        if (docDataObj is IVsTextLines)
                        {
                            buffer = (IVsTextLines)docDataObj;
                        }
                        else if (docDataObj is IVsTextBufferProvider)
                        {
                            IVsTextBufferProvider tp = (IVsTextBufferProvider)docDataObj;
                            if (tp.GetTextBuffer(out buffer) != VSConstants.S_OK)
                                buffer = null;
                        }
                        if (buffer != null)
                        {
                            int endLine, endIndex;
                            ErrorHandler.ThrowOnFailure(buffer.GetLastLineIndex(out endLine, out endIndex));
                            ErrorHandler.ThrowOnFailure(buffer.GetLineText(0, 0, endLine, endIndex, out text));
                            buffer = null;
                            return text;
                        }
                    }
                }
                finally
                {
                    if (punkDocData != IntPtr.Zero)
                    {
                        Marshal.Release(punkDocData);
                    }
                }
            }

            return null;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetRDTDocumentInfo"]/*' />
        /// <devdoc>
        /// Get a reference to the IVsPersistDocData interface associated to a document in the Running Document Table.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="documentName">Path to the document.</param>
        /// <param name="hierarchy">[out, optional] Reference to the IVsHierarchy interface for the project who owns the document.</param>
        /// <param name="itemid">[out, optional] Reference to an item identifier in the hierarchy. </param>
        /// <param name="persistDocData">[out] A reference to the IVsPersistDocData interface associated to the document</param>
        /// <param name="docCookie">[out, optional] A reference to an abstract handle to the document. </param>
        public static void GetRDTDocumentInfo(IServiceProvider site, string documentName, out IVsHierarchy hierarchy, out uint itemid, out IVsPersistDocData persistDocData, out uint docCookie)
        {
            hierarchy = null;
            itemid = VSConstants.VSITEMID_NIL;
            persistDocData = null;
            docCookie = (uint)ShellConstants.VSDOCCOOKIE_NIL;

            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(documentName))
            {
                throw new ArgumentException("documentName");
            }

            // Get the document info.
            IVsRunningDocumentTable rdt = site.GetService(typeof(IVsRunningDocumentTable)) as IVsRunningDocumentTable;
            if (rdt == null) return;

            IntPtr docData = IntPtr.Zero;
            try
            {
                ErrorHandler.ThrowOnFailure(rdt.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, documentName, out hierarchy, out itemid, out docData, out docCookie));


                if (docData != IntPtr.Zero)
                {
                    // if interface is not supported, return null
                    persistDocData = Marshal.GetObjectForIUnknown(docData) as IVsPersistDocData;
                }
            }
            finally
            {

                if (docData != IntPtr.Zero)
                {
                    Marshal.Release(docData);
                }
            }
        }

        private static List<IVsWindowFrame> GetFramesForDocument(IServiceProvider site, object docData) {
            List<IVsWindowFrame> result = new List<IVsWindowFrame>();
            IVsRunningDocumentTable rdt = site.GetService(typeof(SVsRunningDocumentTable)) as IVsRunningDocumentTable;
            IVsUIShell uiShell = site.GetService(typeof(SVsUIShell)) as IVsUIShell;

            if (uiShell == null || rdt == null)
                return result;

            IEnumWindowFrames framesEnum;
            ErrorHandler.ThrowOnFailure(uiShell.GetDocumentWindowEnum(out framesEnum));
            IVsWindowFrame[] frames = new IVsWindowFrame[16];
            uint retrieved;

            while (true) {
                ErrorHandler.ThrowOnFailure(framesEnum.Next((uint)frames.Length, frames, out retrieved));
                if (retrieved == 0)
                    break;

                for (int idx = 0; idx < retrieved; idx++) {
                    IVsWindowFrame windowFrame = frames[idx];
                    object data = ErrorHandler.ThrowOnFailure(windowFrame.GetProperty((int)__VSFPROPID.VSFPROPID_DocData, out data));
                    if (NativeMethods.IsSameComObject(data, docData)) {
                        result.Add(windowFrame);
                    }
                }
            }

            return result;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.SaveFileIfDirty"]/*' />
        /// <devdoc>
        /// Save file if it is dirty.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="fullPath">The full path of the file to be saved.</param>
        public static void SaveFileIfDirty(IServiceProvider site, string fullPath)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            IVsRunningDocumentTable pRDT = (IVsRunningDocumentTable)site.GetService(typeof(SVsRunningDocumentTable));
            if (pRDT != null)
            {
                IntPtr punkDocData;
                uint pitemid;
                uint docCookie;
                IVsHierarchy vsHierarchy;
                ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, fullPath, out vsHierarchy, out pitemid, out punkDocData, out docCookie));
                if (punkDocData != IntPtr.Zero)
                {
                    try
                    {
                        object docDataObj = Marshal.GetObjectForIUnknown(punkDocData);
                        IVsPersistDocData2 pdd = (IVsPersistDocData2)docDataObj;
                        int dirty;
                        ErrorHandler.ThrowOnFailure(pdd.IsDocDataDirty(out dirty));
                        if (dirty != 0)
                        {
                            string newdoc;
                            int cancelled;
                            int hr = pdd.SaveDocData(VSSAVEFLAGS.VSSAVE_Save, out newdoc, out cancelled);
                            if (cancelled <= 0) {
                                ErrorHandler.ThrowOnFailure(hr);
                            }

                            // If the document is saved with a different name then update caption on windowFrames
                            if (!String.IsNullOrEmpty(newdoc)) {
                                string newCaption = Path.GetFileName(newdoc);

                                List<IVsWindowFrame> windowFrames = GetFramesForDocument(site, docDataObj);
                                foreach (IVsWindowFrame frame in windowFrames) {
                                    ErrorHandler.ThrowOnFailure(frame.SetProperty((int)__VSFPROPID.VSFPROPID_OwnerCaption, newCaption));
                                }
                            }
                        }
                    }
                    finally
                    {
                        Marshal.Release(punkDocData);
                    }
                }
                vsHierarchy = null;
            }
            pRDT = null;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.SaveFileIfDirty"]/*' />
        /// <devdoc>
        /// Save document data for a text view.
        /// </devdoc>
        /// <param name="view">The view to be saved</param>
        public static void SaveFileIfDirty(IVsTextView view)
        {
            if (view == null)
            {
                throw new ArgumentException("view");
            }


            IVsTextLines buffer;
            ErrorHandler.ThrowOnFailure(view.GetBuffer(out buffer));
            IVsPersistDocData2 pdd = (IVsPersistDocData2)buffer;
            int dirty;
            ErrorHandler.ThrowOnFailure(pdd.IsDocDataDirty(out dirty));
            if (dirty != 0)
            {
                string newdoc;
                int cancelled;
                int hr = pdd.SaveDocData(VSSAVEFLAGS.VSSAVE_Save, out newdoc, out cancelled);
                if (cancelled <= 0) {
                    ErrorHandler.ThrowOnFailure(hr);
                }

                // If the document is saved with a different name then update caption on windowFrame
                if (!String.IsNullOrEmpty(newdoc)) {
                    string newCaption = Path.GetFileName(newdoc);

                    IVsTextViewEx viewEx = view as IVsTextViewEx;
                    if (viewEx != null) {
                        object window;
                        viewEx.GetWindowFrame(out window);
                        IVsWindowFrame frame = window as IVsWindowFrame;
                        if (frame != null) {
                            ErrorHandler.ThrowOnFailure(frame.SetProperty((int)__VSFPROPID.VSFPROPID_OwnerCaption, newCaption));
                        }
                    }
                }
            }
            pdd = null;
            buffer = null;
        }


        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.PromptYesNo"]/*' />
        /// <devdoc>
        /// Prompt the user with the specified message.
        /// </devdoc>
        /// <param name="message">The message to show.</param>
        /// <param name="title">The title of the message box.</param>
        /// <param name="icon">The icon to show on the message box.</param>
        /// <param name="uiShell">A reference to a IVsUIShell interface.</param>        
        /// <returns>Return true if the result is Yes, false otherwise.</returns>
        public static bool PromptYesNo(string message, string title, OLEMSGICON icon, IVsUIShell uiShell)
        {
            Guid emptyGuid = Guid.Empty;
            int result = 0;
            ErrorHandler.ThrowOnFailure(uiShell.ShowMessageBox(
                0,
                ref emptyGuid,
                title,
                message,
                null,
                0,
                OLEMSGBUTTON.OLEMSGBUTTON_YESNO,
                OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_SECOND,
                icon,
                0,
                out result));

            return (result == NativeMethods.IDYES);
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.ShowMessageBox"]/*' />
        /// <devdoc>
        /// Show message box.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider</param>
        /// <param name="message">The message to show</param>
        /// <param name="title">The title of the message box</param>
        /// <param name="icon">The icon to show on the message box</param>
        /// <param name="msgButton">The button type</param>
        /// <param name="defaultButton">The default button</param>
        /// <returns>If the method succeeds, it returns S_OK. If it fails, it returns an error code. If a referernce to the IVsUIShell interface cannot be retrived from the service provider then InvalidOperationException is thrown.</returns>
        public static int ShowMessageBox(IServiceProvider serviceProvider, string message, string title, OLEMSGICON icon, OLEMSGBUTTON msgButton, OLEMSGDEFBUTTON defaultButton)
        {
            Debug.Assert(serviceProvider != null, "Could not create MessageBox for a null serviceprovider");
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsUIShell uiShell = serviceProvider.GetService(typeof(IVsUIShell)) as IVsUIShell;
            Debug.Assert(uiShell != null, "Could not get the IVsUIShell object from the services exposed by this serviceprovider");
            if (uiShell == null)
            {
                throw new InvalidOperationException();
            }
            Guid emptyGuid = Guid.Empty;
            int result = 0;
            ErrorHandler.ThrowOnFailure(uiShell.ShowMessageBox(
                0,
                ref emptyGuid,
                title,
                message,
                null,
                0,
                msgButton,
                defaultButton,
                icon,
                0,
                out result));

            return result;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetTaskItems"]/*' />
        /// <devdoc>
        /// Get list of all tasks items as IVsTaskItem2.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>A list of task items.</returns>
        [Obsolete("This method is obsolete. Please use GetTaskItems2 instead.")]
        public static IList<IVsTaskItem2> GetTaskItems(IServiceProvider serviceProvider)
        {
            IList<IVsTaskItem2> tasks = new List<IVsTaskItem2>();

            foreach (IVsTaskItem item in GetTaskItems2(serviceProvider))
            {
                //
                // For backward compatibility, the result list contains null entries for task items
                // that do not implement IVsTaskItem2.
                //
                tasks.Add(item as IVsTaskItem2);
            }

            return tasks;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetTaskItems2"]/*' />
        /// <devdoc>
        /// Get list of all tasks items.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>A list of task items.</returns>
        public static IList<IVsTaskItem> GetTaskItems2(IServiceProvider serviceProvider)
        {
            IList<IVsTaskItem> tasks = new List<IVsTaskItem>();

            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsTaskList taskList = serviceProvider.GetService(typeof(SVsTaskList)) as IVsTaskList;

            if (taskList == null)
            {
                throw new InvalidOperationException();
            }

            IVsEnumTaskItems enumTaskItems;
            try
            {
                ErrorHandler.ThrowOnFailure(taskList.EnumTaskItems(out enumTaskItems));

                if (enumTaskItems == null)
                {
                    return tasks;
                }

                int result = VSConstants.E_FAIL;
                uint[] fetched = new uint[1];
                do
                {
                    IVsTaskItem[] taskItems = new IVsTaskItem[1];

                    result = enumTaskItems.Next(1, taskItems, fetched);

                    if (fetched[0] == 1)
                    {
                        IVsTaskItem taskItem = taskItems[0];
                        tasks.Add(taskItem);
                    }

                } while (result == VSConstants.S_OK && fetched[0] == 1);
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception : " + e.Message);
            }

            return tasks;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.EmptyTaskList"]/*' />
        /// <devdoc>
        /// Empty the task list.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>If the method succeeds, it returns S_OK. If it fails, it returns an error code. </returns>
        public static int EmptyTaskList(IServiceProvider serviceProvider)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsTaskList taskList = serviceProvider.GetService(typeof(IVsTaskList)) as IVsTaskList;

            if (taskList == null)
            {
                throw new InvalidOperationException();
            }

            IVsEnumTaskItems enumTaskItems;
            int result = VSConstants.S_OK;
            try
            {
                ErrorHandler.ThrowOnFailure(taskList.EnumTaskItems(out enumTaskItems));

                if (enumTaskItems == null)
                {
                    throw new InvalidOperationException();
                }

                // Retrieve the task item text and check whether it is equal with one that supposed to be thrown.
                
                uint[] fetched = new uint[1];
                do
                {
                    IVsTaskItem[] taskItems = new IVsTaskItem[1];

                    result = enumTaskItems.Next(1, taskItems, fetched);

                    if (fetched[0] == 1)
                    {
                        IVsTaskItem2 taskItem = taskItems[0] as IVsTaskItem2;
                        if (taskItem != null)
                        {
                            int canDelete;
                            ErrorHandler.ThrowOnFailure(taskItem.CanDelete(out canDelete));
                            if (canDelete == 1)
                            {
                                ErrorHandler.ThrowOnFailure(taskItem.OnDeleteTask());
                            }
                        }
                    }

                } while (result == VSConstants.S_OK && fetched[0] == 1);

            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception : " + e.Message);
                result = e.ErrorCode;
            }

            return result;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.LaunchDebugger"]/*' />
        /// <devdoc>
        /// Launch the debugger.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <param name="info">A reference to a VsDebugTargetInfo object.</param>
        public static void LaunchDebugger(IServiceProvider serviceProvider, VsDebugTargetInfo info)
        {
            Debug.Assert(serviceProvider != null, "Cannot launch the debugger on an empty service provider");
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            info.cbSize = (uint)Marshal.SizeOf(info);
            IntPtr ptr = Marshal.AllocCoTaskMem((int)info.cbSize);
            Marshal.StructureToPtr(info, ptr, false);
            try
            {
                IVsDebugger d = serviceProvider.GetService(typeof(IVsDebugger)) as IVsDebugger;
                Debug.Assert(d != null, "Could not retrieve IVsDebugger from " + serviceProvider.GetType().Name);

                if (d == null)
                {
                    throw new InvalidOperationException();
                }
                
                ErrorHandler.ThrowOnFailure(d.LaunchDebugTargets(1, ptr));
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception : " + e.Message);
            }
            finally
            {
                if (ptr != IntPtr.Zero)
                {
                    Marshal.FreeCoTaskMem(ptr);
                }
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetHierarchy"]/*' />
        /// <devdoc>
        /// Get reference to IVsHierarchy interface from project guid.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="projectGuid">A project guid.</param>
        ///<returns>A reference to an IVsHierarchy interface.</returns>
        public static IVsHierarchy GetHierarchy(IServiceProvider site, Guid projectGuid)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (projectGuid == Guid.Empty)
            {
                throw new ArgumentException("projectGuid");
            }

            IVsHierarchy hierarchy = null;

            IVsSolution solution = site.GetService(typeof(SVsSolution)) as IVsSolution;

            if (solution == null)
            {
                throw new InvalidOperationException();
            }

            try
            {
                solution.GetProjectOfGuid(ref projectGuid, out hierarchy);
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }
            // If the project is not loaded this is the exception thrown.
            catch (InvalidCastException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }

            return hierarchy;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetUIHierarchyWindow"]/*' />
        /// <devdoc>
        /// Get reference to IVsUIHierarchyWindow interface from guid persistence slot.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <param name="guidPersistenceSlot">Unique identifier for a tool window created using IVsUIShell::CreateToolWindow. The caller of this method can use predefined identifiers that map to tool windows if those tool windows are known to the caller. </param>
        /// <returns>A reference to an IVsUIHierarchyWindow interface.</returns>
        public static IVsUIHierarchyWindow GetUIHierarchyWindow(IServiceProvider serviceProvider, Guid guidPersistenceSlot)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsUIShell shell = serviceProvider.GetService(typeof(SVsUIShell)) as IVsUIShell;

            Debug.Assert(shell != null, "Could not get the ui shell from the project");
            if (shell == null)
            {
                throw new InvalidOperationException();
            }

            object pvar = null;
            IVsWindowFrame frame = null;
            IVsUIHierarchyWindow uiHierarchyWindow = null;

            try
            {
                ErrorHandler.ThrowOnFailure(shell.FindToolWindow(0, ref guidPersistenceSlot, out frame));
                ErrorHandler.ThrowOnFailure(frame.GetProperty((int)__VSFPROPID.VSFPROPID_DocView, out pvar));
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }
            finally
            {
                if (pvar != null)
                {
                    IVsWindowPane pane = (IVsWindowPane)pvar;

                    uiHierarchyWindow = (IVsUIHierarchyWindow)pane;
                }
            }

            return uiHierarchyWindow;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetOutputWindowPane"]/*' />
        /// <devdoc>
        /// Get reference to IVsOutputWindowPane interface from pane guid.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <param name="guidPane">A guid for the pane.</param>
        /// <returns>A reference to an IVsOutputWindowPane interface.</returns>
        public static IVsOutputWindowPane GetOutputWindowPane(IServiceProvider serviceProvider, Guid guidPane)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsOutputWindow outputWindow = serviceProvider.GetService(typeof(IVsOutputWindow)) as IVsOutputWindow;
            if (outputWindow == null)
            {
                throw new InvalidOperationException();
            }

            IVsOutputWindowPane outputWindowPane = null;
            try
            {
                ErrorHandler.ThrowOnFailure(outputWindow.GetPane(ref guidPane, out outputWindowPane));
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }

            return outputWindowPane;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetDebugMode"]/*' />
        /// <devdoc>
        /// Get debug mode of the shell (design/break/shell).
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>A DBGMODE enumeration.</returns>
        public static DBGMODE GetDebugMode(IServiceProvider serviceProvider)
        {
            DBGMODE[] dbgmode = new DBGMODE[1] { DBGMODE.DBGMODE_Design };

            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsDebugger debugger = serviceProvider.GetService(typeof(IVsDebugger)) as IVsDebugger;

            if (debugger == null)
            {
                throw new InvalidOperationException();
            }

            try
            {
                ErrorHandler.ThrowOnFailure(debugger.GetMode(dbgmode));
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }

            return dbgmode[0];
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.IsVisualStudioInDesignMode"]/*' />
        /// <devdoc>
        /// Is Visual Studio in design mode.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>true if visual studio is in design mode</returns>
        public static bool IsVisualStudioInDesignMode(IServiceProvider serviceProvider)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            DBGMODE dbgMode = GetDebugMode(serviceProvider) & ~DBGMODE.DBGMODE_EncMask;

            return dbgMode == DBGMODE.DBGMODE_Design;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.IsSolutionBuilding"]/*' />
        /// <devdoc>
        /// Is current solution building or deploying
        /// </devdoc>
        /// <param name="serviceProvider">The service provider</param>
        /// <returns>true if solution is building or deploying.</returns>
        public static bool IsSolutionBuilding(IServiceProvider serviceProvider)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsSolutionBuildManager solutionBuildManager = serviceProvider.GetService(typeof(IVsSolutionBuildManager)) as IVsSolutionBuildManager;

            if (solutionBuildManager == null)
            {
                throw new InvalidOperationException();
            }

            int returnValueAsInteger = 0;
            ErrorHandler.ThrowOnFailure(solutionBuildManager.QueryBuildManagerBusy(out returnValueAsInteger));
            return (returnValueAsInteger == 1);
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.IsInAutomationFunction"]/*' />
        /// <devdoc>
        /// Is an extensibility object executing an automation function.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>true if the extensiblity object is executing an automation function.</returns>
        public static bool IsInAutomationFunction(IServiceProvider serviceProvider)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsExtensibility extensibility = serviceProvider.GetService(typeof(IVsExtensibility)) as IVsExtensibility;

            if (extensibility == null)
            {
                throw new InvalidOperationException();
            }

            return (extensibility.IsInAutomationFunction() == 0) ? false : true;
        }

        private const int TV_FIRST = 0x1100;
        private const int TVM_SETEXTENDEDSTYLE = TV_FIRST + 44;
        private const int TVM_GETEXTENDEDSTYLE = TV_FIRST + 45;

        private static int TreeView_GetExtendedStyle(IntPtr handle)
        {
            IntPtr ptr = NativeMethods.SendMessage(handle, TVM_GETEXTENDEDSTYLE, IntPtr.Zero, IntPtr.Zero);
            return ptr.ToInt32();
        }

        private static void TreeView_SetExtendedStyle(IntPtr handle, int extendedStyle, int mask)
        {
            NativeMethods.SendMessage(handle, TVM_SETEXTENDEDSTYLE, new IntPtr(mask), new IntPtr(extendedStyle));
        }

        private const int TVS_EX_FADEINOUTEXPANDOS = 0x0040;
        private const int TVS_EX_DOUBLEBUFFER = 0x0004;

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.ApplyTreeViewThemeStyles"]/*' />
        /// <devdoc>
        /// Modify a WinForms TreeView control to use the new Explorer style theme.  Hot tracking is enabled by default.
        /// </devdoc>
        /// <param name="treeView">The tree view control to modify</param>
        public static void ApplyTreeViewThemeStyles(TreeView treeView)
        {
            ApplyTreeViewThemeStyles(treeView, true);
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.ApplyTreeViewThemeStyles"]/*' />
        /// <devdoc>
        /// Modify a WinForms TreeView control to use the new Explorer style theme.
        /// </devdoc>
        /// <param name="treeView">The tree view control to modify.</param>
        /// <param name="enableHotTracking">true to enable hot tracking on the tree view control; otherwise, false.</param>
        public static void ApplyTreeViewThemeStyles(TreeView treeView, bool enableHotTracking)
        {
            if (treeView == null)
            {
                throw new ArgumentNullException("treeView");
            }

            treeView.HotTracking = enableHotTracking;
            treeView.ShowLines = false;

            IntPtr hwnd = treeView.Handle;
            NativeMethods.SetWindowTheme(hwnd, "Explorer", null);
            int exstyle = TreeView_GetExtendedStyle(hwnd);
            exstyle |= TVS_EX_DOUBLEBUFFER | TVS_EX_FADEINOUTEXPANDOS;
            TreeView_SetExtendedStyle(hwnd, exstyle, 0);
        }

        private const int LVM_FIRST = 0x1000;
        private const int LVM_SETEXTENDEDLISTVIEWSTYLE = LVM_FIRST + 54;

        private static void ListView_SetExtendedListViewStyleEx(IntPtr handle, int mask, int extendedStyle)
        {
            NativeMethods.SendMessage(handle, LVM_SETEXTENDEDLISTVIEWSTYLE, new IntPtr(mask), new IntPtr(extendedStyle));
        }

        private const int LVS_EX_DOUBLEBUFFER = 0x00010000;

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.ApplyListViewThemeStyles"]/*' />
        /// <devdoc>
        /// Modify a WinForms ListView control to use the new Explorer style theme
        /// </devdoc>
        /// <param name="listView">The list view control to modify</param>
        public static void ApplyListViewThemeStyles(ListView listView)
        {
            if (listView == null)
            {
                throw new ArgumentNullException("listView");
            }

            IntPtr hwnd = listView.Handle;
            NativeMethods.SetWindowTheme(hwnd, "Explorer", null);
            ListView_SetExtendedListViewStyleEx(hwnd, LVS_EX_DOUBLEBUFFER, LVS_EX_DOUBLEBUFFER);
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetEnvironmentFont"]/*' />
        /// <devdoc>
        /// Retrieve the host's EnvironmentFont as a System.Drawing.Font
        /// </devdoc>
        /// <param name="listView">The host's service provider</param>
        public static Font GetEnvironmentFont(IServiceProvider provider)
        {
            if (provider == null)
            {
                throw new ArgumentNullException("provider");
            }

            IUIService uiService = provider.GetService(typeof(IUIService)) as IUIService;
            if (uiService == null)
            {
                Debug.Fail("Could not get the IUIService object from the services exposed by this service provider");
                throw new InvalidOperationException();
            }

            return (Font)uiService.Styles["DialogFont"];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\WindowPane.cs ===
//------------------------------------------------------------------------------
// <copyright file="WindowPane.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell
{

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;
    using System.Windows.Interop;
    using System.Windows;
    using System.Windows.Markup;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;
    using System.IO;


    class UIWin32ElementWrapper : IVsUIWin32Element, IVsBroadcastMessageEvents, IDisposable
    {
        private IVsShell _vsShell;
        private uint _broadcastEventCookie;

        WindowPane _pane;

        internal UIWin32ElementWrapper(WindowPane pane)
        {
            _pane = pane;
        }
        #region IVsUIWin32Element Members

        public int Create(IntPtr parent, out IntPtr pHandle)
        {
            IntPtr hwnd = _pane.Window.Handle;
            int style = (int)UnsafeNativeMethods.GetWindowLong(hwnd, NativeMethods.GWL_STYLE);

            // set up the required styles of an IVsWindowPane
            style |= (NativeMethods.WS_CLIPSIBLINGS | NativeMethods.WS_CHILD | NativeMethods.WS_VISIBLE);
            style &= ~(NativeMethods.WS_POPUP |
                       NativeMethods.WS_MINIMIZE |
                       NativeMethods.WS_MAXIMIZE |
                       NativeMethods.WS_DLGFRAME |
                       NativeMethods.WS_SYSMENU |
                       NativeMethods.WS_THICKFRAME |
                       NativeMethods.WS_MINIMIZEBOX |
                       NativeMethods.WS_MAXIMIZEBOX);

            UnsafeNativeMethods.SetWindowLong(hwnd, NativeMethods.GWL_STYLE, (IntPtr)style);

            style = (int)UnsafeNativeMethods.GetWindowLong(hwnd, NativeMethods.GWL_EXSTYLE);

            style &= ~(NativeMethods.WS_EX_DLGMODALFRAME |
                       NativeMethods.WS_EX_NOPARENTNOTIFY |
                       NativeMethods.WS_EX_TOPMOST |
                       NativeMethods.WS_EX_MDICHILD |
                       NativeMethods.WS_EX_TOOLWINDOW |
                       NativeMethods.WS_EX_CONTEXTHELP |
                       NativeMethods.WS_EX_APPWINDOW);

            UnsafeNativeMethods.SetWindowLong(hwnd, NativeMethods.GWL_EXSTYLE, (IntPtr)style);
            UnsafeNativeMethods.SetParent(hwnd, (IntPtr)parent);
            //            UnsafeNativeMethods.SetWindowPos(hwnd, IntPtr.Zero, x, y, cx, cy, NativeMethods.SWP_NOZORDER | NativeMethods.SWP_NOACTIVATE);
            UnsafeNativeMethods.ShowWindow(hwnd, NativeMethods.SW_SHOWNORMAL);

            // Sync broadcast events so we update our UI when colors/fonts change.
            //
            if (_vsShell == null)
            {
                _vsShell = ServiceProvider.GlobalProvider.GetService(typeof(SVsShell)) as IVsShell;
                if (_vsShell != null)
                {
                    NativeMethods.ThrowOnFailure(_vsShell.AdviseBroadcastMessages(this, out _broadcastEventCookie));
                }
            }

            pHandle = hwnd;
            return NativeMethods.S_OK;
        }

        public int Destroy()
        {
            throw new NotImplementedException();
        }

        public int GetHandle(out IntPtr pHandle)
        {
            pHandle = _pane.Window.Handle;
            return VSConstants.S_OK;
        }

        public int ShowModal(IntPtr parent, out int pDlgResult)
        {
            throw new NotImplementedException();
        }

        #endregion

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsBroadcastMessageEvents.OnBroadcastMessage"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Receives broadcast messages from the shell
        /// </devdoc>
        int IVsBroadcastMessageEvents.OnBroadcastMessage(uint msg, IntPtr wParam, IntPtr lParam)
        {
            int hr = NativeMethods.S_OK;
            IntPtr hwnd = _pane.Window.Handle;
            bool result = UnsafeNativeMethods.PostMessage(hwnd, (int)msg, wParam, wParam);
            if (!result)
                hr = NativeMethods.E_FAIL;
            return hr;
        }


        #region IDisposable Members

        public void Dispose()
        {
            if (_vsShell != null)
            {
                try
                {
                    // Don't check for return code because here we can't do anything in case of failure.
                    _vsShell.UnadviseBroadcastMessages(_broadcastEventCookie);
                }
                catch (Exception) { /* do nothing */ }
                _vsShell = null;
                _broadcastEventCookie = 0;
            }
        }

        #endregion
    }


    /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane"]' />
    /// <devdoc>
    ///     This is a quick way to implement a tool window pane.  This class 
    ///     implements IVsWindowPane; you must provide an implementation of an 
    ///     object that returns an IWin32Window, however.  In addition to 
    ///     IVsWindowPane this object implements IOleCommandTarget, mapping 
    ///     it to IMenuCommandService and IObjectWithSite, mapping the site 
    ///     to services that can be querried through its protected GetService 
    ///     method.
    /// </devdoc>
    [ContentProperty("Content")]
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class WindowPane : IOleCommandTarget, IServiceProvider, IVsWindowPane, IVsUIElementPane, IDisposable
    {
        private IServiceProvider _parentProvider;
        private ServiceProvider _provider;

        private IMenuCommandService _commandService;
        private HelpService _helpService;

        private bool _zombie = false;

        private UIWin32ElementWrapper win32Wrapper = null;

        /// <summary>
        /// Creates a new window pane with a null parent service provider
        /// </summary>
        protected WindowPane()
        {
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.WindowPane"]' />
        /// <devdoc>
        ///     Creates a new window pane.  The window pane can accept a service provider
        ///     to use when resolving services.  This provider can be null.
        /// </devdoc>
        protected WindowPane(IServiceProvider provider)
            : this()
        {
            _parentProvider = provider;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.Window"]' />
        /// <devdoc>
        ///     Retrieves the window associated with this window pane.
        /// </devdoc>
        public virtual System.Windows.Forms.IWin32Window Window { get { return null; } }

        /// <devdoc>
        /// Stores the state for how this WindowPane was initialized. Initialization
        /// happens through either IVsWindowPane.CreatePaneWindow or IVsUIElementPane.CreateUIElementPane.
        /// </devdoc>
        protected PaneInitializationMode InitializationMode { get; private set; }

        /// <devdoc>
        /// Override or set to provide the content of this tool window.   Expected kinds of objects include
        /// FrameworkElement, IVsUIWpfElement, IVsUIWin32Element.   If the object is not of one of the expected
        /// types, it will be wrapped in a ContentControl, treated as WPF and any styling or formatting may
        /// be applied through the global resource dictionary.
        /// If your tool content is created from xaml, override the setter to provide a backing store for the content.
        /// </devdoc>
        public virtual Object Content
        {
            get;
            set;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.Dispose"]' />
        /// <devdoc>
        ///     Can be called to dispose this editing window.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.Dispose1"]' />
        /// <devdoc>
        ///     Called when this window pane is being disposed.
        /// </devdoc>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        protected virtual void Dispose(bool disposing) {

            if (disposing) {

                if (win32Wrapper != null)
                    win32Wrapper.Dispose();
                win32Wrapper = null;

                IDisposable disposableWindow = null;
                if (Content != null)
                {
                    disposableWindow = Content as IDisposable;
                }
                else
                {
                    disposableWindow = Window as IDisposable;
                }
                    
                if (disposableWindow != null)
                {
                    try {
                        disposableWindow.Dispose();
                    } catch (Exception) {
                        Debug.Fail("Failed to dispose window");
                    }
                }
                disposableWindow = null;

                if (_commandService != null && _commandService is IDisposable) {
                    try {
                        ((IDisposable)_commandService).Dispose();
                    } catch (Exception) {
                        Debug.Fail("Failed to dispose command service");
                    }
                }
                _commandService = null;

                if (_parentProvider != null)
                    _parentProvider = null;

                if (_helpService != null)
                    _helpService = null;

                // Do not clear _provider.  SetSite will do it for us.

                _zombie = true;

            }
        }


        /// <devdoc>
        /// This is a separate method so the jitter doesn't see MenuCommandService (from system.design.dll) in
        /// the GetService call and load the assembly.
        /// </devdoc> 
        private void EnsureCommandService() {
            if (_commandService == null) {
                _commandService = new OleMenuCommandService(this);
            }
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.GetService"]' />
        /// <devdoc>
        ///     Maps to IServiceProvider for service routing.
        /// </devdoc>
        protected virtual object GetService(Type serviceType)
        {

            if (_zombie)
            {
                Debug.Fail("GetService called after WindowPane was zombied");
                return null;
            }

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            // We provide IMenuCommandService, so we will
            // demand create it.  MenuCommandService also
            // implements IOleCommandTarget, but unless
            // someone requested IMenuCommandService no commands
            // will exist, so we don't demand create for
            // IOleCommandTarget
            //
            if (serviceType.IsEquivalentTo(typeof(IMenuCommandService))) {
                EnsureCommandService();
                return _commandService;
            }
            else if (serviceType.IsEquivalentTo(typeof(IOleCommandTarget))) {
                return _commandService;
            }
            else if (serviceType.IsEquivalentTo(typeof(IHelpService))) {
                if (_helpService == null) {
                    _helpService = new HelpService(this);
                }
                return _helpService;
            }

            if (_provider != null) {
                object service = _provider.GetService(serviceType);
                if (service != null) {
                    return service;
                }
            }

            // We should never attempt to resite the parent
            // if _provider is not null it will have already succeeded above.
            if (serviceType.IsEquivalentTo(typeof(IObjectWithSite)))
                return null;

            if (_parentProvider != null) {
                return _parentProvider.GetService(serviceType);
            }

            return null;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.Initialize"]' />
        /// <devdoc>
        ///     This method is called after the window pane has been sited.  Any initialization
        ///     that requires window frame services from VS can be done by overriding this
        ///     method.
        /// </devdoc>
        protected virtual void Initialize() {
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.OnClose"]/*' />
        /// <devdoc>
        ///     The OnClose method is called in response to the ClosePane method on
        ///     IVsWindowPane.  The default implementation calls Dispose();
        /// </devdoc>
        protected virtual void OnClose() {
            Dispose();
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.OnCreate"]/*' />
        /// <devdoc>
        ///     The OnCreate method is called during the CreatePaneWindow method of
        ///     IVsWindowPane.  This provides a handy hook for knowing when VS wants
        ///     the window.  The default implementation does nothing.
        /// </devdoc>
        protected virtual void OnCreate() {
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.PreProcessMessage"]' />
        /// <devdoc>
        ///     This method will be called to pre-process keyboard
        ///     messages before VS handles them.  It is directly
        ///     attached to IVsWindowPane::TranslateAccellerator.
        ///     The default implementation calls the PreProcessMessage
        ///     method on a Windows Forms control.  You may override this if your
        ///     window pane is not based on Windows Forms.
        ///     Arguments and return values are the
        ///     same as for Windows Forms:  return true if you handled
        ///     the message, false if you want the default processing
        ///     to occur.
        /// </devdoc>
        protected virtual bool PreProcessMessage(ref Message m) {
            Control c = Control.FromChildHandle(m.HWnd);
            if (c != null) {
                return c.PreProcessControlMessage(ref m) == PreProcessControlState.MessageProcessed;
            }
            else {
                return false;
            }
        }


        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IOleCommandTarget.Exec"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// This is called by Visual Studio when the user has requested to execute a particular
        /// command.  There is no need to override this method.  If you need access to menu
        /// commands use IMenuCommandService.
        /// </devdoc>
        int IOleCommandTarget.Exec(ref Guid guidGroup, uint nCmdId, uint nCmdExcept, IntPtr pIn, IntPtr vOut) {
            // Always redirect through GetService for this.  That way outside users can replace
            // it.
            //
            IOleCommandTarget cmdTarget = GetService(typeof(IOleCommandTarget)) as IOleCommandTarget;
            if (cmdTarget != null) {
                return cmdTarget.Exec(ref guidGroup, nCmdId, nCmdExcept, pIn, vOut);
            }
            else {
                return NativeMethods.OLECMDERR_E_NOTSUPPORTED;
            }
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IOleCommandTarget.QueryStatus"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// This is called by Visual Studio when it needs the status of our menu commands.  There
        /// is no need to override this method.  If you need access to menu commands use
        /// IMenuCommandService.
        /// </devdoc>
        int IOleCommandTarget.QueryStatus(ref Guid guidGroup, uint nCmdId, OLECMD[] oleCmd, IntPtr oleText) {
            // Always redirect through GetService for this.  That way outside users can replace
            // it.
            //
            IOleCommandTarget cmdTarget = GetService(typeof(IOleCommandTarget)) as IOleCommandTarget;
            if (cmdTarget != null) {
                return cmdTarget.QueryStatus(ref guidGroup, nCmdId, oleCmd, oleText);
            }
            else {
                return NativeMethods.OLECMDERR_E_NOTSUPPORTED;
            }
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IServiceProvider.GetService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IServiceProvider implementation.
        /// </devdoc>
        object IServiceProvider.GetService(Type serviceType) {
            return GetService(serviceType);
        }


        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsUIElementPane.CloseUIElementPane"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsUIElementPane implementation.
        /// </devdoc>
        int IVsUIElementPane.CloseUIElementPane() {
            OnClose();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsUIElementPane.CreateUIElementPane"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsUIElementPane implementation.
        /// </devdoc>
        int IVsUIElementPane.CreateUIElementPane(out object uiElement) {
            uiElement = null;

            if (InitializationMode != PaneInitializationMode.Uninitialized)
                throw new InvalidOperationException("The WindowPane is already initialized");

            // Indicate to derived classes that IVsUIElementPane.CreateUIElementPane was used, and not IVsWindowPane.CreatePaneWindow
            InitializationMode = PaneInitializationMode.IVsUIElementPane;

            // We should call OnCreate one time for derived classes to pre-initialize themselves.
            // This should be called before accessing the Content or Window properties.
            OnCreate();

            if (Content != null)
                uiElement = Content;
            else if (Window != null) {
                win32Wrapper = new UIWin32ElementWrapper(this);
                uiElement = win32Wrapper;
            }
            else
                return VSConstants.E_UNEXPECTED;

            return VSConstants.S_OK;
        }


        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsUIElementPane.GetDefaultSize"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsUIElementPane implementation.
        /// </devdoc>
        int IVsUIElementPane.GetDefaultUIElementSize(SIZE[] size) {
            return NativeMethods.E_NOTIMPL;
        }

        /// <summary>
        /// Override to load previously saved state of the pane
        /// </summary>
        /// <param name="?"></param>
        /// <param name="?"></param>
        /// <returns></returns>
        public virtual int LoadUIState(Stream stateStream)
        {
            return VSConstants.E_NOTIMPL;
        }


        private static byte[] GetBufferFromIStream(IStream comStream)
        {
            LARGE_INTEGER zeroPos;
            zeroPos.QuadPart = 0;
            ULARGE_INTEGER[] streamPosition = new ULARGE_INTEGER[1];
            comStream.Seek(zeroPos, (uint)STREAM_SEEK.STREAM_SEEK_CUR, streamPosition);
            comStream.Seek(zeroPos, (uint)STREAM_SEEK.STREAM_SEEK_SET, null);

            Microsoft.VisualStudio.OLE.Interop.STATSTG[] stat = new Microsoft.VisualStudio.OLE.Interop.STATSTG[1];
            comStream.Stat(stat, (uint)STATFLAG.STATFLAG_NONAME);

            int bufferLength = (int)stat[0].cbSize.QuadPart;
            byte[] buffer = new byte[bufferLength];
            uint bytesRead = 0;
            comStream.Read(buffer, (uint)buffer.Length, out bytesRead);

            // return the stream to its previous location
            LARGE_INTEGER newPos;
            newPos.QuadPart = (long)streamPosition[0].QuadPart;
            comStream.Seek(newPos, (uint)STREAM_SEEK.STREAM_SEEK_SET, null);

            return buffer;
        }


        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsUIElementPane.LoadUIElementState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsUIElementPane implementation.
        /// </devdoc>
        int IVsUIElementPane.LoadUIElementState(IStream pstream)
        {
            byte[] bytes = GetBufferFromIStream(pstream);
            if (bytes.Length > 0)
            {
                using (MemoryStream stateStream = new MemoryStream(bytes))
                {
                     return LoadUIState(stateStream);
                }
            }

            return VSConstants.S_OK;
        }

        /// <summary>
        /// Override to save custom state information to be used later when the pane is reconstructed.
        /// </summary>
        /// <returns>The stream with the state information</returns>
        public virtual int SaveUIState(out Stream stateStream)
        {
            stateStream = null;
            return VSConstants.S_OK;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsUIElementPane.SaveUIElementState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsUIElementPane implementation.
        /// </devdoc>
        int IVsUIElementPane.SaveUIElementState(IStream pstream) {

            Stream stateStream;
            
            int hresult = SaveUIState(out stateStream);
            if (ErrorHandler.Succeeded(hresult))
            {
                // Make sure the returned stream (if any) is properly disposed even if it's not readable or is empty
                using (stateStream)
                {
                    // If a stream was returned and is readable and have anything to read from it
                    if (stateStream != null && stateStream.CanRead && stateStream.Length > 0)
                    {
                        using (BinaryReader reader = new BinaryReader(stateStream))
                        {
                            byte[] bytes = new byte[stateStream.Length];
                            stateStream.Position = 0;
                            reader.Read(bytes, 0, bytes.Length);
                            uint written = 0;
                            pstream.Write(bytes, (uint)bytes.Length, out written);
                            pstream.Commit((uint)STGC.STGC_DEFAULT);
                        }
                    }
                }
            }

            return hresult;
        }

        private int InternalSetSite(IOleServiceProvider p)
        {
            // The siting mechanism works as follows:  If the
            // parent provider provides ServiceProviderHierarchy
            // as a service we will insert our service provider in
            // the WindowPaneSite slot of the hierarchy.
            // If, however, it does not provide
            // this service, we will create a new 
            // ServiceProvider that will be used to resolve
            // services through this site.  
            //
            if (_provider != null)
            {
                _provider.Dispose();
                _provider = null;
            }

            IObjectWithSite ows = GetService(typeof(IObjectWithSite)) as IObjectWithSite;
            ServiceProviderHierarchy serviceHierarchy = GetService(typeof(ServiceProviderHierarchy)) as ServiceProviderHierarchy;
            if (serviceHierarchy != null)
            {
                ServiceProvider sp = (p == null ? null : new ServiceProvider(p));
                serviceHierarchy[ServiceProviderHierarchyOrder.WindowPaneSite] = sp;
            }
            else if (ows != null)
            {
                ows.SetSite(p);
            }
            else
            {
                if (p != null)
                {
                    _provider = new ServiceProvider(p);
                }
            }

            if (p != null)
            {
                Initialize();
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsUIElementPane.SetUIElementSite"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsUIElementPane implementation.
        /// </devdoc>
        int IVsUIElementPane.SetUIElementSite(IOleServiceProvider p) {
            // If classes derived from WindowPane explicitly implemented IVsWindowPane, and relied on the explicit implementation of SetSite to be called,
            // we should make sure we call them.  Otherwise, IVsWindowPane.SetSite will call SetSiteInternal in the default implementation.
            return ((IVsWindowPane)this).SetSite(p);
        }

        private int InternalTranslateAccelerator(Microsoft.VisualStudio.OLE.Interop.MSG[] msg) {
            Message m = Message.Create(msg[0].hwnd, (int)msg[0].message, msg[0].wParam, msg[0].lParam);
            bool eat = PreProcessMessage(ref m);

            msg[0].message = (uint)m.Msg;
            msg[0].wParam = m.WParam;
            msg[0].lParam = m.LParam;

            if (eat) {
                return NativeMethods.S_OK;
            }
            else {
                return NativeMethods.E_FAIL;
            }
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsUIElementPane.TranslateUIElementAccelerator"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsUIElementPane implementation.
        /// </devdoc>
        int IVsUIElementPane.TranslateUIElementAccelerator(Microsoft.VisualStudio.OLE.Interop.MSG[] msg) {
            return InternalTranslateAccelerator(msg);
        }

        #region IVsWindowPane Members

        [System.Obsolete("The IVsWindowPane interface on the WindowPane is obsolete, use IVsUIElementPane")]
        int IVsWindowPane.ClosePane()
        {
            OnClose();
            return NativeMethods.S_OK;
        }

        [System.Obsolete("The IVsWindowPane interface on the WindowPane is obsolete, use IVsUIElementPane")]
        int IVsWindowPane.CreatePaneWindow(IntPtr hwndParent, int x, int y, int cx, int cy, out IntPtr hwnd)
        {
            if (InitializationMode != PaneInitializationMode.Uninitialized)
                throw new InvalidOperationException("The WindowPane is already initialized");

            // Indicate to derived classes that IVsWindowPane.CreatePaneWindow was used, and not IVsUIElementPane.CreateUIElementPane
            InitializationMode = PaneInitializationMode.IVsWindowPane;

            // We should call OnCreate one time for derived classes to pre-initialize themselves.
            // This should be called before accessing the Content or Window properties.
            OnCreate();

            hwnd = IntPtr.Zero;
            if (Content == null && Window == null)
                throw new InvalidOperationException("A WindowPane derived type must provide either a content control or a HWND.   If the tool is WPF based IVsUIElementPane.CreteUIElement should be used.");

            int hresult = NativeMethods.S_OK;
            if (Content != null)
            {
                // This path is unusual in that the content of this frame is WPF but it is being requested as an HWND through this
                // obsolete API.   Create a HwndSource wrapper around the FrameworkElement using the provided parent
                if (Content is FrameworkElement || Content is IVsUIWpfElement)
                {
                    // Create a HwndSource for the the content 
                    HwndSource contentSource = new HwndSource(/* classStyle */ 0,
                        NativeMethods.WS_CHILD | NativeMethods.WS_CLIPSIBLINGS | NativeMethods.WS_VISIBLE,
                        /* exStyle */ 0,
                        /* x, y */ 0, 0,
                        /* name */ "",  // no name for this item. 
                        hwndParent);

                    contentSource.SizeToContent = SizeToContent.Manual;
                    if (Content is IVsUIWpfElement)
                    {
                        object element = null;
                        ((IVsUIWpfElement)Content).CreateFrameworkElement(out element);
                        contentSource.RootVisual = (FrameworkElement)element;
                    }
                    else
                    {
                        contentSource.RootVisual = (FrameworkElement)Content;
                    }

                    contentSource.Disposed += delegate(object sender, EventArgs e)
                    {
                        this.Dispose();
                    };
                    
                    hwnd = contentSource.Handle;
                }
                // If the content is already win32 and impliments the IVsUIWin32Element, we have little to do
                else if (Content is IVsUIWin32Element)
                {
                    hresult = ((IVsUIWin32Element)Content).Create(hwndParent, out hwnd);
                }
            }
            else if (Window != null)
            {
                // If our derived class provided a Win32 control, create it with the provided parent
                win32Wrapper = new UIWin32ElementWrapper(this);
                hresult = win32Wrapper.Create(hwndParent, out hwnd);
            }

            return hresult;
        }

        [System.Obsolete("The IVsWindowPane interface on the WindowPane is obsolete, use IVsUIElementPane")]
        int IVsWindowPane.GetDefaultSize(SIZE[] pSize) {
            return NativeMethods.E_NOTIMPL;
        }

        [System.Obsolete("The IVsWindowPane interface on the WindowPane is obsolete, use IVsUIElementPane")]
        int IVsWindowPane.LoadViewState(IStream pStream) {
            return NativeMethods.E_NOTIMPL;
        }

        [System.Obsolete("The IVsWindowPane interface on the WindowPane is obsolete, use IVsUIElementPane")]
        int IVsWindowPane.SaveViewState(IStream pStream) {
            return NativeMethods.E_NOTIMPL;
        }

        [System.Obsolete("The IVsWindowPane interface on the WindowPane is obsolete, use IVsUIElementPane")]
        int IVsWindowPane.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider psp)
        {
            return InternalSetSite(psp);
        }

        [System.Obsolete("The IVsWindowPane interface on the WindowPane is obsolete, use IVsUIElementPane")]
        int IVsWindowPane.TranslateAccelerator(Microsoft.VisualStudio.OLE.Interop.MSG[] lpmsg)
        {
            return InternalTranslateAccelerator(lpmsg);
        }

        #endregion

        /// <devdoc>
        /// Enumerates the possible initialization states for a WindowPane instance.
        /// </devdoc>
        protected enum PaneInitializationMode
        {
            Uninitialized = 0,
            IVsWindowPane,
            IVsUIElementPane
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\VSRegistry.cs ===
//------------------------------------------------------------------------------
// <copyright file="Package.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
using System;
using Microsoft.Win32;

using Microsoft.VisualStudio.Shell.Interop;

using ErrorHandler = Microsoft.VisualStudio.ErrorHandler;
using IServiceProvider = System.IServiceProvider;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;

namespace Microsoft.VisualStudio.Shell {
    /// <summary>
    /// Helper class to handle the registry of the instance of VS that is
    /// hosting this code.
    /// </summary>
    [System.CLSCompliant(false)]
    public static class VSRegistry {

        private static ServiceProvider GlobalProvider {
            get {
                return ServiceProvider.GlobalProvider;
            }
        }

        /// <summary>
        /// Returns a read-only RegistryKey object for the root of a given storage type.
        /// It is up to the caller to dispose the returned object.
        /// </summary>
        /// <param name="registryType">The type of registry storage to open.</param>
        public static RegistryKey RegistryRoot(__VsLocalRegistryType registryType) {
            return RegistryRoot(GlobalProvider, registryType, false);
        }

        /// <summary>
        /// Returns a RegistryKey object for the root of a given storage type.
        /// It is up to the caller to dispose the returned object.
        /// </summary>
        /// <param name="registryType">The type of registry storage to open.</param>
        /// <param name="writable">Flag to indicate is the key should be writable.</param>
        public static RegistryKey RegistryRoot(__VsLocalRegistryType registryType, bool writable) {
            return RegistryRoot(GlobalProvider, registryType, writable);
        }

        /// <summary>
        /// Returns a RegistryKey object for the root of a given storage type.
        /// It is up to the caller to dispose the returned object.
        /// </summary>
        /// <param name="provider">The service provider to use to access the Visual Studio's services.</param>
        /// <param name="registryType">The type of registry storage to open.</param>
        /// <param name="writable">Flag to indicate is the key should be writable.</param>
        public static RegistryKey RegistryRoot(IServiceProvider provider, __VsLocalRegistryType registryType, bool writable) {
            if (null == provider) {
                throw new ArgumentNullException("provider");
            }

            // The current implementation of the shell supports only RegType_UserSettings and
            // RegType_Configuration, so for any other values we have to return not implemented.
            if ((__VsLocalRegistryType.RegType_UserSettings != registryType) &&
                (__VsLocalRegistryType.RegType_Configuration != registryType))
            {
                throw new NotSupportedException();
            }

            // Try to get the new ILocalRegistry4 interface that is able to handle the new
            // registry paths.
            ILocalRegistry4 localRegistry = provider.GetService(typeof(SLocalRegistry)) as ILocalRegistry4;
            if (null != localRegistry) {
                uint rootHandle;
                string rootPath;
                if (ErrorHandler.Succeeded(localRegistry.GetLocalRegistryRootEx((uint)registryType, out rootHandle, out rootPath))) {
                    // Check if we have valid data.
                    __VsLocalRegistryRootHandle handle = (__VsLocalRegistryRootHandle)rootHandle;
                    if (!string.IsNullOrEmpty(rootPath) && (__VsLocalRegistryRootHandle.RegHandle_Invalid != handle)) {
                        // Check if the root is inside HKLM or HKCU. Note that this does not depends only from
                        // the registry type, but also from instance-specific data like the RANU flag.
                        RegistryKey root = (__VsLocalRegistryRootHandle.RegHandle_LocalMachine == handle) ? Registry.LocalMachine : Registry.CurrentUser;
                        return root.OpenSubKey(rootPath, writable);
                    }
                }
            }

            // We are here if the usage of the new interface failed for same reason, so we have to fall back to
            // the ond way to access the registry.
            ILocalRegistry2 oldRegistry = provider.GetService(typeof(SLocalRegistry)) as ILocalRegistry2;
            if (null == oldRegistry) {
                // There is something wrong with this installation or this service provider.
                return null;
            }
            string registryPath;
            NativeMethods.ThrowOnFailure(oldRegistry.GetLocalRegistryRoot(out registryPath));
            if (string.IsNullOrEmpty(registryPath)) {
                return null;
            }

            RegistryKey regRoot = (__VsLocalRegistryType.RegType_Configuration == registryType) ? Registry.LocalMachine : Registry.CurrentUser;
            return regRoot.OpenSubKey(registryPath, writable);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Utilities.cs ===
//--------------------------------------------------------------------------
//  <copyright file="utilities.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Diagnostics;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Collections;
using System.Xml;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Reflection;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using Microsoft.VisualStudio.Shell;
using Microsoft.Win32;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;

namespace Microsoft.VisualStudio.Shell
{


    /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities"]' />
    public static class PackageUtilities
	{

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetSystemAssemblyPath"]' />
        public static string GetSystemAssemblyPath()
		{
			return Path.GetDirectoryName(typeof(object).Assembly.Location);
#if SYSTEM_COMPILER 
      // To support true cross-platform compilation we really need to use
      // the System.Compiler.dll SystemTypes class which statically loads
      // mscorlib type information from "TargetPlatform" location.
      return Path.GetDirectoryName(SystemTypes.SystemAssembly.Location);
#endif

		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.EnsureOutputPath"]' />
        public static void EnsureOutputPath(string path)
		{
			if (!String.IsNullOrEmpty(path) && !Directory.Exists(path))
			{
				try
				{
					Directory.CreateDirectory(path);
				}
				catch (IOException e)
				{
					Trace.WriteLine("Exception : " + e.Message);
				}
				catch (UnauthorizedAccessException e)
				{
					Trace.WriteLine("Exception : " + e.Message);
				}
				catch (ArgumentException e)
				{
					Trace.WriteLine("Exception : " + e.Message);
				}
				catch (NotSupportedException e)
				{
					Trace.WriteLine("Exception : " + e.Message);
				}

			}
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.ContainsInvalidFileNameChars"]' />
        /// <devdoc>
		/// Returns true if thename that can represent a path, absolut or relative, or a file name contains invalid filename characters.
		/// </devdoc>
		/// <param name="name">File name</param>
		/// <returns>true if file name is invalid</returns>
		public static bool ContainsInvalidFileNameChars(string name)
		{
			if (String.IsNullOrEmpty(name))
			{
				return true;
			}

			if (Path.IsPathRooted(name))
			{
				string root = Path.GetPathRoot(name);
				name = name.Substring(root.Length);
			}

			Url uri = new Url(name);

			string[] segments = uri.Segments;
			if (segments != null)
			{
				foreach (string segment in segments)
				{
					if (IsFilePartInValid(segment))
					{
						return true;
					}
				}
			}
			else
			{
				return IsFilePartInValid(name);
			}

			return false;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.IsFileNameInvalid"]' />
        /// <devdoc>
		/// Cehcks if a file name is valid.
		/// </devdoc>
		/// <param name="fileName">The name of the file</param>
		/// <returns>True if the file is valid.</returns>
		public static bool IsFileNameInvalid(string fileName)
		{
			if (String.IsNullOrEmpty(fileName))
			{
				return true;
			}

			if (IsFileNameAllGivenCharacter('.', fileName) || IsFileNameAllGivenCharacter(' ', fileName))
			{
				return true;
			}


			return IsFilePartInValid(fileName);

		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.CopyUrlToLocal"]' />
        ///<devdoc>
        /// Copy the specified file to the local project directory.  Also supports downloading
		/// of HTTP resources (so be prepared for a delay in that case!).
		/// </devdoc>
		public static  void CopyUrlToLocal(Uri uri, string local)
		{
			if (uri.IsFile)
			{
				// now copy file
				FileInfo fiOrg = new FileInfo(uri.LocalPath);
				FileInfo fiNew = fiOrg.CopyTo(local, true);
			}
			else
			{
				FileStream localFile = new FileStream(local, FileMode.OpenOrCreate, FileAccess.Write, FileShare.None);
				try
				{
					WebRequest wr = WebRequest.Create(uri);
					wr.Timeout = 10000;
					wr.Credentials = CredentialCache.DefaultCredentials;
					WebResponse resp = wr.GetResponse();
					Stream s = resp.GetResponseStream();
					byte[] buffer = new byte[10 * 1024];
					int len;
					while ((len = s.Read(buffer, 0, buffer.Length)) != 0)
					{
						localFile.Write(buffer, 0, len);
					}
				}
				finally
				{
					localFile.Close();
				}
			}
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.MakeRelativeIfRooted"]' />
        /// <devdoc>
		/// If this file is in the same folder the Url or below make it relative to the current Url
		/// </devdoc>
        /// <param name="fileName">filename (is rooted) to be transformed</param>
		/// <param name="url">the location to make the filename relative to</param>
		/// <returns>the relative path to the url or returns filename if not rooted</returns>
		public static string MakeRelativeIfRooted(string fileName, Url url)
		{
			string relativePath = fileName;
			if (Path.IsPathRooted(relativePath))
			{
				string path = new Url(relativePath).AbsoluteUrl;
				string basePath = url.AbsoluteUrl;
				if (path.StartsWith(basePath, StringComparison.OrdinalIgnoreCase))
				{
					relativePath = path.Substring(basePath.Length);
				}
			}
			return relativePath;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetPathDistance"]' />
        /// <devdoc>
		/// Given two uris calculates the distance from the second path top the first one.
		/// </devdoc>
		/// <returns>The distance in path, if it can make it or the fullpath of the second uri if there if relative path does not make sense.</returns>
		public static string GetPathDistance(Uri uriBase, Uri uriRelativeTo)
		{
			string diff = String.Empty;

			if (uriRelativeTo != null && uriBase != null)
			{
				// MakeRelative only really works if on the same drive.
				if (uriRelativeTo.Segments.Length > 0 && uriBase.Segments.Length > 0 && String.Compare(uriRelativeTo.Segments[1], uriBase.Segments[1], StringComparison.OrdinalIgnoreCase) == 0)
				{
					Uri uriRelative = uriBase.MakeRelativeUri(uriRelativeTo);
					if (uriRelative != null)
					{
						diff = Url.Unescape(uriRelative.ToString(), true);
					}
				}
				else
				{
					diff = uriRelativeTo.LocalPath;
				}
			}

			return diff;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.MakeRelative"]' />
        public static string MakeRelative(string filename, string filename2)
		{
			string[] parts = filename.Split(Path.DirectorySeparatorChar);
			string[] parts2 = filename2.Split(Path.DirectorySeparatorChar);

			if (parts.Length == 0 || parts2.Length == 0 || parts[0] != parts2[0])
			{
				return filename2; // completely different paths.
			}

			int i;

			for (i = 1; i < parts.Length && i < parts2.Length; i++)
			{
				if (parts[i] != parts2[i]) break;
			}

			StringBuilder sb = new StringBuilder();

			for (int j = i; j < parts.Length - 1; j++)
			{
				sb.Append("..");
				sb.Append(Path.DirectorySeparatorChar);
			}

			for (int j = i; j < parts2.Length; j++)
			{
				sb.Append(parts2[j]);
				if (j < parts2.Length - 1)
					sb.Append(Path.DirectorySeparatorChar);
			}

			return sb.ToString();
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.CreateCAUUIDFromGuidArray"]' />
        /// <devdoc>
		/// Creates a CAUUID from a guid array. Memory is allocated for the elems. 
		/// It is the responsability of the caller to release this memory.
		/// </devdoc>
		/// <param name="guids"></param>
		/// <returns></returns>
		[CLSCompliant(false)]
		public static CAUUID CreateCAUUIDFromGuidArray(Guid[] guids)
		{
			CAUUID cauuid = new CAUUID();

			if (guids != null)
			{
				cauuid.cElems = (uint)guids.Length;

				int size = Marshal.SizeOf(typeof(Guid));

				cauuid.pElems = Marshal.AllocCoTaskMem(guids.Length * size);

				IntPtr ptr = cauuid.pElems;

				for (int i = 0; i < guids.Length; i++)
				{
					Marshal.StructureToPtr(guids[i], ptr, false);
					ptr = new IntPtr(ptr.ToInt64() + size);
				}
			}

			return cauuid;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetIntPointerFromImage"]' />
        public static int GetIntPointerFromImage(Image image)
		{
			Debug.Assert(image is Bitmap);
			Bitmap bitmap = image as Bitmap;
			if (bitmap != null)
			{
				IntPtr ptr = bitmap.GetHicon();
				// todo: this is not 64bit safe, but is a work around until whidbey bug 172595 is fixed.
				return ptr.ToInt32();
			}
			return 0;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetImageList"]' />
        /// <devdoc>
		/// Creates an imagelist from resourcenames that are assumed to be icons.
		/// </devdoc>
		/// <param name="assembly"></param>
		/// <param name="resourceNames"></param>
		/// <returns></returns>
		public static ImageList GetImageList(Assembly assembly, string[] resourceNames)
		{
			if (resourceNames == null || resourceNames.Length == 0 || assembly == null)
			{
				return null;
			}

			ImageList ilist = new ImageList();
			ilist.ImageSize = new Size(16, 16);

			foreach (string imageName in resourceNames)
			{
				Stream stream = assembly.GetManifestResourceStream(imageName);
				if (stream != null)
				{
					Icon icon = new Icon(stream);
					ilist.Images.Add(icon.ToBitmap());
				}
			}

			return ilist;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetImageList"]' />
        public static ImageList GetImageList(Stream imageStream)
		{
			ImageList ilist = new ImageList();

			if (imageStream == null)
			{
				return ilist;
			}
			ilist.ImageSize = new Size(16, 16);
			Bitmap bitmap = new Bitmap(imageStream);
			ilist.Images.AddStrip(bitmap);
			ilist.TransparentColor = Color.Magenta;
			return ilist;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetImageList"]' />
        public static ImageList GetImageList(object imageListAsPointer)
		{
			ImageList images = null;

			IntPtr intPtr = new IntPtr((int)imageListAsPointer);
			HandleRef hImageList = new HandleRef(null, intPtr);
			int count = UnsafeNativeMethods.ImageList_GetImageCount(hImageList);

			if (count > 0)
			{
				// Create a bitmap big enough to hold all the images
				Bitmap b = new Bitmap(16 * count, 16);
				Graphics g = Graphics.FromImage(b);

				// Loop through and extract each image from the imagelist into our own bitmap
				IntPtr hDC = IntPtr.Zero;
				try
				{
					hDC = g.GetHdc();
					HandleRef handleRefDC = new HandleRef(null, hDC);
					for (int i = 0; i < count; i++)
					{
						UnsafeNativeMethods.ImageList_Draw(hImageList, i, handleRefDC, i * 16, 0, NativeMethods.ILD_NORMAL);
					}
				}
				finally
				{
					if (g != null && hDC != IntPtr.Zero)
					{
						g.ReleaseHdc(hDC);
					}
				}

				// Create a new imagelist based on our stolen images
				images = new ImageList();
				images.ImageSize = new Size(16, 16);
				images.Images.AddStrip(b);
			}
			return images;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.ConvertToType"]' />
        /// <devdoc>
		/// Helper method to call a converter explicitely to convert to an enum type
		/// </devdoc>
		/// <typeparam name="T">The enum to convert to</typeparam>
		/// <param name="value">The enum value to be converted to</param>
		/// <param name="typeToConvert">The type to convert</param>
		/// <param name="culture">The culture to use to read the localized strings</param>
		/// <returns></returns>
		[CLSCompliant(false)]
		public static object ConvertToType<T>(T value, Type typeToConvert, CultureInfo culture)
			where T : struct
		{
			EnumConverter converter = GetEnumConverter<T>();
			if (converter == null)
			{
				return null;
			}
			if (converter.CanConvertTo(typeToConvert))
			{
				return converter.ConvertTo(null, culture, value, typeToConvert);
			}
			
			return null;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.ConvertFromType"]' />
        /// <devdoc>
		/// Helper method for converting from a string to an enum using a converter.
		/// </devdoc>
		/// <typeparam name="T"></typeparam>
		/// <param name="value"></param>
		/// <param name="culture">The culture to use to read the localized strings</param>
		/// <returns></returns>
		[CLSCompliant(false)]
		public static Nullable<T> ConvertFromType<T>(string value, CultureInfo culture)
			where T : struct
		{
			Nullable<T> returnValue = new Nullable<T>();

			returnValue = returnValue.GetValueOrDefault();

			if (value == null)
			{
				return returnValue;
			}

			EnumConverter converter = GetEnumConverter<T>();
			if (converter == null)
			{
				return returnValue;
			}
			
			if (converter.CanConvertFrom(value.GetType()))
			{
				object converted = converter.ConvertFrom(null, culture, value);

				if (converted != null && (converted is T))
				{
					returnValue = (T)converted;
				}
			}

			return returnValue;
		}


        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.SetStringValueFromConvertedEnum"]' />
        /// <devdoc>
		/// Sets a string value from an enum
		/// </devdoc>
		/// <typeparam name="T">The enum type</typeparam>
		/// <param name="enumValue">The value of the enum.</param>
        /// <param name="culture"></param>
        /// <returns></returns>
		[CLSCompliant(false)]
		public static string SetStringValueFromConvertedEnum<T>(T enumValue, CultureInfo culture)
			where T : struct
		{
			object convertToType = PackageUtilities.ConvertToType<T>(enumValue, typeof(string), culture);
			if (convertToType == null || !(convertToType is string))
			{
				return String.Empty;
			}
			
			return (string)convertToType;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetEnumConverter"]' />
        /// <devdoc>
		/// Gets an instance 
		/// </devdoc>
		/// <typeparam name="T"></typeparam>
		/// <returns></returns>
		private static EnumConverter GetEnumConverter<T>()
			where T : struct
		{
			object[] attributes = typeof(T).GetCustomAttributes(typeof(PropertyPageTypeConverterAttribute), true);

			// There should be only one PropertyPageTypeConverterAttribute defined on T
			if (attributes != null && attributes.Length == 1)
			{
				
				Debug.Assert(attributes[0] is PropertyPageTypeConverterAttribute, "The returned attribute must be an attribute is PropertyPageTypeConverterAttribute");
				PropertyPageTypeConverterAttribute converterAttribute = (PropertyPageTypeConverterAttribute)attributes[0];

				if (converterAttribute.ConverterType.IsSubclassOf(typeof(EnumConverter)))
				{
					return Activator.CreateInstance(converterAttribute.ConverterType) as EnumConverter;
				}
			}

			return null;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.IsFilePartInValid"]' />
        /// <devdoc>
		/// Checks whether a file part contains valid characters. The file part can be any part of a non rooted path.
		/// </devdoc>
		/// <param name="filePart"></param>
		/// <returns></returns>
		private static bool IsFilePartInValid(string filePart)
		{
			if (String.IsNullOrEmpty(filePart))
			{
				return true;
			}

			// Define a regular expression that covers all characters that are not in the safe character sets.
			// It is compiled for performance.
			Regex unsafeCharactersRegex = new Regex(@"[/?:&\\*<>|#%" + '\"' + "]", RegexOptions.Compiled);
			return unsafeCharactersRegex.IsMatch(filePart);
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.IsFileNameAllGivenCharacter"]' />
        /// <devdoc>
		/// Checks if the file name is all the given character.
		/// </devdoc>
		private static bool IsFileNameAllGivenCharacter(char c, string fileName)
		{
			// A valid file name cannot be all "c" .
			int charFound = 0;
			for (charFound = 0; charFound < fileName.Length && fileName[charFound] == c; ++charFound) ;
			if (charFound >= fileName.Length)
			{
				return true;
			}

			return false;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Flavor\ProjectDocumentsChangeEventsArgs.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace Microsoft.VisualStudio.Shell.Flavor
{
    /// <include file='doc\ProjectDocumentsChangeEventArgs.uex' path='docs/doc[@for="ProjectDocumentsChangeEventArgs"]/*' />
    public sealed class ProjectDocumentsChangeEventArgs : EventArgs
	{
		private string mkDocument = null;
        /// <include file='doc\ProjectDocumentsChangeEventArgs.uex' path='docs/doc[@for="ProjectDocumentsChangeEventArgs.MkDocument"]/*' />
        /// <devdoc>
		/// Unique name of the Project item that was changed.
		/// Use IVsProject.IsDocumentInProject() to map to an itemid.
		/// </devdoc>
		public string MkDocument
		{
			get { return mkDocument; }
			set { mkDocument = value; }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Flavor\ProjectFactory.cs ===
/***************************************************************************
         Copyright (c) Microsoft Corporation, All rights reserved.             
    This code sample is provided "AS IS" without warranty of any kind, 
    it is not recommended for use in a production environment.
***************************************************************************/

namespace Microsoft.VisualStudio.Shell.Flavor
{
    using System;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell;


    /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory"]/*' />
    /// <devdoc>
    /// The project factory for the project flavor.
    /// Note that this is also known as Project Subtype
    /// </devdoc>
    [CLSCompliant(false)]
    public abstract class FlavoredProjectFactory : IVsAggregatableProjectFactory, IVsProjectFactory
    {
        private ServiceProvider _serviceProvider;
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.ServiceProvider"]/*' />
        protected ServiceProvider serviceProvider
        {
            get { return _serviceProvider; }
        }

        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.FlavoredProjectFactory"]/*' />
        public FlavoredProjectFactory()
        {
        }

        #region IVsProjectFactory

        int IVsProjectFactory.CanCreateProject(string fileName, uint flags, out int canCreate)
        {
            canCreate = this.CanCreateProject(fileName, flags) ? 1 : 0;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.CanCreateProject"]/*' />
        /// <devdoc>
        /// This is called to ask the factory if it can create a project based on the current parameters
        /// </devdoc>
        /// <returns>True if the project can be created</returns>
        protected virtual bool CanCreateProject(string fileName, uint flags)
        {
            // Validate the filename
            bool canCreate = !string.IsNullOrEmpty(fileName);
            canCreate |= !PackageUtilities.ContainsInvalidFileNameChars(fileName);
            return canCreate;
        }

        /// <devdoc>
        /// This is not expected to be called unless using an extension other then the base project
        /// </devdoc>
        int IVsProjectFactory.CreateProject(string fileName, string location, string name, uint flags, ref Guid projectGuid, out System.IntPtr project, out int canceled)
        {
            this.CreateProject(fileName, location, name, flags, ref projectGuid, out project, out canceled);
            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.CreateProject"]/*' />
        /// <devdoc>
        /// If you want to use your own extension, you will need to call IVsCreateAggregatedProject.CreateAggregatedProject()
        /// </devdoc>
        /// <returns>HRESULT</returns>
        protected virtual void CreateProject(string fileName, string location, string name, uint flags, ref Guid projectGuid, out System.IntPtr project, out int canceled)
        {
            // If the extension is that of the base project then we don't get called
            project = IntPtr.Zero;
            canceled = 0;
        }

        int IVsProjectFactory.Close()
        {
            this.Dispose(true);

            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.Dispose"]/*' />
        protected virtual void Dispose(bool disposing)
        {
            if (_serviceProvider != null)
            {
                _serviceProvider.Dispose();
                _serviceProvider = null;
            }
        }

        int IVsProjectFactory.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider provider)
        {
            // keep track of our service provider
            this._serviceProvider = new ServiceProvider(provider);

            this.Initialize();

            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.Initialize"]/*' />
        /// <devdoc>
        /// Called by SetSite after setting our service provider
        /// </devdoc>
        protected virtual void Initialize()
        {
        }

        #endregion

        #region IVsAggregatableProjectFactory

        int IVsAggregatableProjectFactory.GetAggregateProjectType(string fileName, out string projectTypeGuid)
        {
            projectTypeGuid = this.ProjectTypeGuids(fileName);
            return NativeMethods.S_OK;
        }

        int IVsAggregatableProjectFactory.PreCreateForOuter(object outerProject, out object project)
        {
            project = null;
            project = PreCreateForOuter(outerProject);

            if (!(project is FlavoredProject))
            {
                // We are not throwing in this case as someone could create 1 factory that support creating both
                // flavored project and full project. Also, someone could have implemented their flavored project
                // without using our base class. Never the less, if executing in the debugger, we should log this
                // to the output window.
                string warning = String.Format(CultureInfo.InvariantCulture, "Expected to recieve a FlavoredProject from PreCreateForOuter.\n Recieved a {0}", project.GetType().FullName);
                Trace.WriteLine(warning);
                // If you build your own version of this assembly and you intend to use FlavoredProject, uncomment
                // the following line as this will make any problem more obvious on debug builds
                //Debug.Fail(warning);
            }

            if (project == null)
                return NativeMethods.E_FAIL;

            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.PreCreateForOuter"]/*' />
        /// <devdoc>
        /// This function returns an instance of the project. This is just creating the object,
        /// VS will later call SetInner and InitializeForOuter to initialize it.
        /// </devdoc>
        /// <param name="outerProject"></param>
        /// <returns>The project subtype</returns>
        protected abstract object PreCreateForOuter(object outerProject);
        #endregion

        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.ProjectTypeGuids"]/*' />
        protected virtual string ProjectTypeGuids(string file)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Flavor\AggregatableProjectInterops.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

namespace Microsoft.VisualStudio.Shell.Flavor
{
    using System;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.OLE.Interop;

    // We need to define a corrected version of the IA for this interface so that IUnknown pointers are passed
    // as "IntPtr" instead of "object". This ensures that we get the actual IUnknown pointer and not a wrapped
    // managed proxy pointer.
    [ComImport]
    [Guid("ffb2e715-7312-4b93-83d7-d37bcc561c90")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    [CLSCompliant(false)]
    public interface IVsAggregatableProjectCorrected
    {
        [PreserveSig]
        int SetInnerProject(IntPtr punkInnerIUnknown);
        [PreserveSig]
        int InitializeForOuter([MarshalAs(UnmanagedType.LPWStr)]string pszFilename, 
                               [MarshalAs(UnmanagedType.LPWStr)]string pszLocation, 
                               [MarshalAs(UnmanagedType.LPWStr)]string pszName, 
                               uint grfCreateFlags, ref Guid iidProject, out IntPtr ppvProject, out int pfCanceled);
        [PreserveSig]
        int OnAggregationComplete();
        [PreserveSig]
        int GetAggregateProjectTypeGuids([MarshalAs(UnmanagedType.BStr)]out string pbstrProjTypeGuids);
        [PreserveSig]
        int SetAggregateProjectTypeGuids([MarshalAs(UnmanagedType.LPWStr)]string lpstrProjTypeGuids);
    }

    // We need to define a corrected version of the IA for this interface so that IUnknown pointers are passed
    // as "IntPtr" instead of "object". This ensures that we get the actual IUnknown pointer and not a wrapped
    // managed proxy pointer.
    [ComImport()]
    [Guid("6d5140d3-7436-11ce-8034-00aa006009fa")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    [CLSCompliant(false)]
    public interface ILocalRegistryCorrected
    {
        [PreserveSig]
        int CreateInstance(Guid clsid, IntPtr punkOuterIUnknown, ref Guid riid, uint dwFlags, out IntPtr ppvObj);
        [PreserveSig]
        int GetClassObjectOfClsid(ref Guid clsid, uint dwFlags, IntPtr lpReserved, ref Guid riid, out IntPtr ppvClassObject);
        [PreserveSig]
        int GetTypeLibOfClsid(Guid clsid, out ITypeLib pptLib);
    }

    // We need to define a corrected version of the IA for this interface so that IUnknown pointers are passed
    // as "IntPtr" instead of "object". This ensures that we get the actual IUnknown pointer and not a wrapped
    // managed proxy pointer.
    [ComImport]
    [Guid("44569501-2ad0-4966-9bac-12b799a1ced6")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IVsAggregatableProjectFactoryCorrected
    {
        [PreserveSig]
        int GetAggregateProjectType([MarshalAs(UnmanagedType.LPWStr)]string fileName, [MarshalAs(UnmanagedType.BStr)]out string projectTypeGuid);
        [PreserveSig]
        int PreCreateForOuter(IntPtr outerProjectIUnknown, out IntPtr projectIUnknown);
    }

    [ComImport]
    [Guid("D6CEA324-8E81-4e0e-91DE-E5D7394A45CE")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IVsProjectAggregator2
    {
        #region IVsProjectAggregator2 Members

        [PreserveSig]
        int SetInner(IntPtr innerIUnknown);
        [PreserveSig]
        int SetMyProject(IntPtr projectIUnknown);

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\Attributes.cs ===
//--------------------------------------------------------------------------
//  <copyright file="Attributes.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Xml;
using System.Diagnostics;

namespace Microsoft.VisualStudio.Shell
{ 
    /// <include file='doc\Attributes.uex' path='docs/doc[@for="PropertyPageTypeConverterAttribute"]' />
    /// <summary>
    /// Defines our type converter.
    /// </summary>
    /// <remarks>This is needed to get rid of the type TypeConverter type that could not give back the Type we were passing to him.
    /// We do not want to use reflection to get the type back from the  ConverterTypeName. Also the GetType mthos does not spwan converters from other assemblies.</remarks>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Enum | AttributeTargets.Property | AttributeTargets.Field)]
    public sealed class PropertyPageTypeConverterAttribute : Attribute
    {
        Type converterType;
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="PropertyPageTypeConverterAttribute.PropertyPageTypeConverterAttribute"]' />
        public PropertyPageTypeConverterAttribute(Type t)
        {
            this.converterType = t;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="PropertyPageTypeConverterAttribute.ConverterType"]' />
        public Type ConverterType
        {
            get
            {
                return this.converterType;
            }
        }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="LocDisplayNameAttribute"]' />
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Property | AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
    public sealed class LocDisplayNameAttribute : DisplayNameAttribute
    {
        string name;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="LocDisplayNameAttribute.LocDisplayNameAttribute"]' />
        public LocDisplayNameAttribute(string name)
        {
            this.name = name;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="LocDisplayNameAttribute.DisplayName"]' />
        public override string DisplayName
        {
            get
            {
                string result = null;
                try
                {
                    result = Resources.ResourceManager.GetString(this.name, Resources.Culture);
                }
                catch (System.Resources.MissingManifestResourceException)
                {
                }
                if (result == null)
                {
                    Debug.Assert(false, "String resource '" + this.name + "' is missing");
                    result = this.name;
                }
                return result;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Flavor\FlavoredProjectFactoryBase.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

namespace Microsoft.VisualStudio.Shell.Flavor
{
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.VisualStudio.OLE.Interop;

    /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase"]/*' />
    /// <devdoc>
    /// The project factory for the project flavor.
    /// Note that this is also known as Project Subtype
    /// </devdoc>
    [CLSCompliant(false)]
    public abstract class FlavoredProjectFactoryBase : IVsAggregatableProjectFactoryCorrected, IVsProjectFactory
    {
        private ServiceProvider _serviceProvider;
        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.ServiceProvider"]/*' />
        protected ServiceProvider serviceProvider
        {
            get { return _serviceProvider; }
        }

        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.FlavoredProjectFactoryBase"]/*' />
        public FlavoredProjectFactoryBase()
        {
        }

        #region IVsProjectFactory

        int IVsProjectFactory.CanCreateProject(string fileName, uint flags, out int canCreate)
        {
            canCreate = this.CanCreateProject(fileName, flags) ? 1 : 0;
            return VSConstants.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.CanCreateProject"]/*' />
        /// <devdoc>
        /// This is called to ask the factory if it can create a project based on the current parameters
        /// </devdoc>
        /// <returns>True if the project can be created</returns>
        protected virtual bool CanCreateProject(string fileName, uint flags)
        {
            // Validate the filename
            bool canCreate = !string.IsNullOrEmpty(fileName);
            canCreate |= !PackageUtilities.ContainsInvalidFileNameChars(fileName);
            return canCreate;
        }

        /// <devdoc>
        /// This is not expected to be called unless using an extension other then the base project
        /// </devdoc>
        int IVsProjectFactory.CreateProject(string fileName, string location, string name, uint flags, ref Guid projectGuid, out System.IntPtr project, out int canceled)
        {
            this.CreateProject(fileName, location, name, flags, ref projectGuid, out project, out canceled);
            return VSConstants.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.CreateProject"]/*' />
        /// <devdoc>
        /// If you want to use your own extension, you will need to call IVsCreateAggregatedProject.CreateAggregatedProject()
        /// </devdoc>
        /// <returns>HRESULT</returns>
        protected virtual void CreateProject(string fileName, string location, string name, uint flags, ref Guid projectGuid, out System.IntPtr project, out int canceled)
        {
            // If the extension is that of the base project then we don't get called
            project = IntPtr.Zero;
            canceled = 0;
        }

        int IVsProjectFactory.Close()
        {
            this.Dispose(true);

            return VSConstants.S_OK;
        }

        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.Dispose"]/*' />
        protected virtual void Dispose(bool disposing)
        {
            if (_serviceProvider != null)
            {
                _serviceProvider.Dispose();
                _serviceProvider = null;
            }
        }

        int IVsProjectFactory.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider provider)
        {
            // keep track of our service provider
            this._serviceProvider = new ServiceProvider(provider);

            this.Initialize();

            return VSConstants.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.Initialize"]/*' />
        /// <devdoc>
        /// Called by SetSite after setting our service provider
        /// </devdoc>
        protected virtual void Initialize()
        {
        }

        #endregion

        #region IVsAggregatableProjectFactory

        int IVsAggregatableProjectFactoryCorrected.GetAggregateProjectType(string fileName, out string projectTypeGuid)
        {
            projectTypeGuid = this.ProjectTypeGuids(fileName);
            return VSConstants.S_OK;
        }

        int IVsAggregatableProjectFactoryCorrected.PreCreateForOuter(IntPtr outerProjectIUnknown, out IntPtr projectIUnknown)
        {
            projectIUnknown = IntPtr.Zero;  // always initialize out parameters of COM interfaces!

            object newProject = PreCreateForOuter(outerProjectIUnknown);

            IntPtr newProjectIUnknown = IntPtr.Zero;
            ILocalRegistryCorrected localRegistry = (ILocalRegistryCorrected)ServiceProvider.GlobalProvider.GetService(typeof(SLocalRegistry));
            Debug.Assert(localRegistry != null, "Could not get the ILocalRegistry object");
            if (localRegistry == null)
            {
                throw new InvalidOperationException();
            }
            Guid clsid = typeof(Microsoft.VisualStudio.ProjectAggregator.CProjectAggregatorClass).GUID;
            Guid riid = VSConstants.IID_IUnknown;
            uint dwClsCtx = (uint)CLSCTX.CLSCTX_INPROC_SERVER;
            IntPtr aggregateProjectIUnknown = IntPtr.Zero;
            IVsProjectAggregator2 vsProjectAggregator2 = null;

            try
            {
                ErrorHandler.ThrowOnFailure(localRegistry.CreateInstance(clsid, outerProjectIUnknown, ref riid, dwClsCtx, out aggregateProjectIUnknown));

                // If we have a non-NULL punkOuter then we need to create a COM aggregated object with that punkOuter,
                // if not then we are the top of the aggregation.
                if (outerProjectIUnknown != IntPtr.Zero)
                {
                    newProjectIUnknown = Marshal.CreateAggregatedObject(outerProjectIUnknown, newProject);
                }
                else
                {
                    newProjectIUnknown = Marshal.CreateAggregatedObject(aggregateProjectIUnknown, newProject); ;
                }

                vsProjectAggregator2 = (IVsProjectAggregator2)Marshal.GetObjectForIUnknown(aggregateProjectIUnknown);
                if (vsProjectAggregator2 != null)
                {
                    vsProjectAggregator2.SetMyProject(newProjectIUnknown);
                }

                // We return the native ProjectAggregator COM object as the project created by our project
                // factory. This ProjectAggregator main purpose is to manage the fact that the punkInner pointer
                // for the project aggregation is not known until after IVsAggregateProject::SetInnerProject is 
                // called. This native object has a special implementation of QueryInterface that can handle 
                // the SetInnerProject mechanism. The ProjectAggregator will first delegate QueryInterface 
                // calls to our managed project and then delegates to the inner Project.
                // Note: we need to return an AddRef'ed IUnknown (AddRef comes from CreateInstance call).
                projectIUnknown = aggregateProjectIUnknown;
                aggregateProjectIUnknown = IntPtr.Zero;
            }
            finally
            {
                if (newProjectIUnknown != IntPtr.Zero)
                    Marshal.Release(newProjectIUnknown);
                if (aggregateProjectIUnknown != IntPtr.Zero)
                    Marshal.Release(aggregateProjectIUnknown);
            }

            if (projectIUnknown == IntPtr.Zero)
                return VSConstants.E_FAIL;

            return VSConstants.S_OK;
        }

        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.PreCreateForOuter"]/*' />
        /// <devdoc>
        /// This function returns an instance of the project. This is just creating the object,
        /// VS will later call SetInner and InitializeForOuter to initialize it.
        /// </devdoc>
        /// <param name="outerProjectIUnknown"></param>
        /// <returns>The project subtype</returns>
        protected abstract object PreCreateForOuter(IntPtr outerProjectIUnknown);
        #endregion

        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.ProjectTypeGuids"]/*' />
        protected virtual string ProjectTypeGuids(string file)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\DesignPropertyDescriptor.cs ===
//--------------------------------------------------------------------------
//  <copyright file="DesignPropertyDescriptor.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using Microsoft.VisualStudio.Shell;
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Xml;
using System.Diagnostics;

namespace Microsoft.VisualStudio.Shell
{
	/// <summary>
	/// The purpose of DesignPropertyDescriptor is to allow us to customize the
	/// display name of the property in the property grid.  None of the CLR
	/// implementations of PropertyDescriptor allow you to change the DisplayName.
	/// </summary>
	public class DesignPropertyDescriptor : PropertyDescriptor
	{
		private string displayName; // Custom display name
		private PropertyDescriptor property;	// Base property descriptor
		private Hashtable editors = new Hashtable(); // Type -> editor instance
		private TypeConverter converter;


		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override string DisplayName
		{
			get
			{
				return this.displayName;
			}
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override Type ComponentType
		{
			get
			{
				return this.property.ComponentType;
			}
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override bool IsReadOnly
		{
			get
			{
				return this.property.IsReadOnly;
			}
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override Type PropertyType
		{
			get
			{
				return this.property.PropertyType;
			}
		}


		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override object GetEditor(Type editorBaseType)
		{
			object editor = this.editors[editorBaseType];
			if (editor == null)
			{
				for (int i = 0; i < this.Attributes.Count; i++)
				{
					EditorAttribute attr = Attributes[i] as EditorAttribute;
					if (attr == null)
					{
						continue;
					}
					Type editorType = Type.GetType(attr.EditorBaseTypeName);
					if (editorBaseType == editorType)
					{
						Type type = GetTypeFromNameProperty(attr.EditorTypeName);
						if (type != null)
						{
							editor = CreateInstance(type);
							this.editors[type] = editor; // cache it
							break;
						}
					}
				}
			}
			return editor;
		}


		/// <summary>
		/// Return type converter for property
		/// </summary>
		public override TypeConverter Converter
		{
			get
			{
				if (converter == null)
				{
					PropertyPageTypeConverterAttribute attr = (PropertyPageTypeConverterAttribute)Attributes[typeof(PropertyPageTypeConverterAttribute)];
					if (attr != null && attr.ConverterType != null)
					{
						converter = (TypeConverter)CreateInstance(attr.ConverterType);
					}

					if (converter == null)
					{
						converter = TypeDescriptor.GetConverter(this.PropertyType);
					}
				}
				return converter;
			}
		}



		/// <summary>
		/// Convert name to a Type object.
		/// </summary>
		public virtual Type GetTypeFromNameProperty(string typeName)
		{
			return Type.GetType(typeName);
		}


		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override bool CanResetValue(object component)
		{
			bool result = this.property.CanResetValue(component);
			return result;
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override object GetValue(object component)
		{
			object value = this.property.GetValue(component);
			return value;
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override void ResetValue(object component)
		{
			this.property.ResetValue(component);
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override void SetValue(object component, object value)
		{
			this.property.SetValue(component, value);
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override bool ShouldSerializeValue(object component)
		{
			bool result = this.property.ShouldSerializeValue(component);
			return result;
		}

		/// <summary>
		/// Constructor.  Copy the base property descriptor and also hold a pointer
		/// to it for calling its overridden abstract methods.
		/// </summary>
		public DesignPropertyDescriptor(PropertyDescriptor prop) : base(prop)
		{
			this.property = prop;

			Attribute attr = prop.Attributes[typeof(DisplayNameAttribute)];

			if (attr is DisplayNameAttribute)
			{
				this.displayName = ((DisplayNameAttribute)attr).DisplayName;
			}
			else
			{
				this.displayName = prop.Name;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\DefaultRegistryRootAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultRegistryRootAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <include file='doc\DefaultRegistryRootAttribute.uex' path='docs/doc[@for="DefaultRegistryRootAttribute"]' />
    /// <devdoc>
    ///     This attribute defines the default registry root this package was designed to work with.  
    ///     This attribute exists on the Package base class and contains the root for the version of 
    ///     Visual Studio the package was copiled for.  The various path and registry methods on 
    ///     Package make use of this attribute, as does default registration code that setup will 
    ///     use to register packages. 
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=false, Inherited=true)]
    public sealed class DefaultRegistryRootAttribute : Attribute {

        private string _root;
    
        /// <include file='doc\DefaultRegistryRootAttribute.uex' path='docs/doc[@for="DefaultRegistryRootAttribute.DefaultRegistryRootAttribute"]' />
        /// <devdoc>
        ///     Creates a new DefaultRegistryRootAttribute.
        /// </devdoc>
        public DefaultRegistryRootAttribute (string root) {
            if (root == null) {
                throw new ArgumentNullException("root");
            }
            _root = root;
        }
        
        /// <include file='doc\DefaultRegistryRootAttribute.uex' path='docs/doc[@for="DefaultRegistryRootAttribute.Root"]' />
        /// <devdoc>
        ///     Returns the default registry root.
        /// </devdoc>
        public string Root {
            get {
                return _root;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Settings\ShellSettingsStore.cs ===
//------------------------------------------------------------------------------
// <copyright file="SettingsStore.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell.Settings
{
    using System;
    using System.IO;
    using System.Collections.Generic;
    using Microsoft.VisualStudio.Shell.Interop;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.Settings;

    /// <summary>
    /// Abstract class for reading/enumerating the selected scope's collections and properties. It is obtained from 
    /// <see cref="SettingsManager.GetReadOnlySettingsStore"/> method.
    /// 
    /// In the methods of this class if the collection path is provided as the empty string ("") then it 
    /// denotes the top level collection. If the property name is empty string then it denotes the default 
    /// property of the collection.
    /// 
    /// Collections can contain properties and sub-collections. Sub-collections paths are described with the 
    /// separators like directories in file system. Likewise, separator is '\' (back-slash) character. Example
    /// of a sub-collection path would be: "Root Collection\Internal Collection\Leaf Collection".
    /// </summary>
    [CLSCompliant(false)] // Methods of this class have unsigned integer parameters
    internal class ShellSettingsStore : SettingsStore
    {            
        /// <summary>
        /// Returns the value of the requested property whose data type is <see cref="SettingsType.Int32"/> as boolean.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property is of different type or if it does 
        /// not exist.</exception>
        /// <returns>If the underling integer value for the property is non-zero, it returns true and false otherwise.</returns>
        public override bool GetBoolean(string collectionPath, string propertyName)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            int value;
            int hr = this.settingsStore.GetBool(collectionPath, propertyName, out value);
            Marshal.ThrowExceptionForHR(hr);
            
            return Convert.ToBoolean(value);
        }

        /// <summary>
        /// Returns the value of the requested property whose data type is <see cref="SettingsType.Int32"/> as boolean.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="defaultValue">Value to be returned if the property does not exist.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property is of different type.</exception>
        /// <returns>If the property does not exist, it returns the defaultValue passed in otherwise it returns true if the 
        /// underling integer value is non-zero and false if it is zero.</returns>
        public override bool GetBoolean(string collectionPath, string propertyName, bool defaultValue)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            int value;
            int hr = this.settingsStore.GetBoolOrDefault(collectionPath, propertyName, Convert.ToInt32(defaultValue), out value);
            Marshal.ThrowExceptionForHR(hr);

            return Convert.ToBoolean(value);
        }

        /// <summary>
        /// Returns the value of the requested property whose data type is <see cref="SettingsType.Int32"/>.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property is of different type or if it does 
        /// not exist.</exception>
        /// <returns>Value of the property. If the value was stored as an unsigned integer previously then regular type 
        /// conversion sematics applies.</returns>
        public override int GetInt32(string collectionPath, string propertyName)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            int value;
            int hr = this.settingsStore.GetInt(collectionPath, propertyName, out value);
            Marshal.ThrowExceptionForHR(hr);

            return value;
        }

        /// <summary>
        /// Returns the value of the requested property whose data type is <see cref="SettingsType.Int32"/>.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="defaultValue">Value to be returned if the property does not exist.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property is of different type.</exception>
        /// <returns>If the property does not exist, it returns the defaultValue passed in. If the value was stored as an 
        /// unsigned integer previously then regular type conversion sematics applies.</returns>
        public override int GetInt32(string collectionPath, string propertyName, int defaultValue)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            int value;
            int hr = this.settingsStore.GetIntOrDefault(collectionPath, propertyName, defaultValue, out value);
            Marshal.ThrowExceptionForHR(hr);

            return value;
        }

        /// <summary>
        /// Returns the value of the requested property whose data type is <see cref="SettingsType.Int32"/>.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property is of different type or if it does 
        /// not exist.</exception>
        /// <returns>Value of the property. If the value was stored as an signed integer previously then regular type 
        /// conversion sematics applies.</returns>
        public override uint GetUInt32(string collectionPath, string propertyName)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            uint value;
            int hr = this.settingsStore.GetUnsignedInt(collectionPath, propertyName, out value);
            Marshal.ThrowExceptionForHR(hr);

            return value;
        }

        /// <summary>
        /// Returns the value of the requested property whose data type is <see cref="SettingsType.Int32"/>.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="defaultValue">Value to be returned if the property does not exist.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property is of different type.</exception>
        /// <returns>If the property does not exist, it returns the defaultValue passed in. If the value was stored as an 
        /// signed integer previously then regular type conversion sematics applies.</returns>
        public override uint GetUInt32(string collectionPath, string propertyName, uint defaultValue)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            uint value;
            int hr = this.settingsStore.GetUnsignedIntOrDefault(collectionPath, propertyName, defaultValue, out value);
            Marshal.ThrowExceptionForHR(hr);

            return value;
        }

        /// <summary>
        /// Returns the value of the requested property whose data type is <see cref="SettingsType.Int64"/>.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property is of different type or if it does 
        /// not exist.</exception>
        /// <returns>Value of the property. If the value was stored as an unsigned long previously then regular type 
        /// conversion sematics applies.</returns>
        public override long GetInt64(string collectionPath, string propertyName)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            long value;
            int hr = this.settingsStore.GetInt64(collectionPath, propertyName, out value);
            Marshal.ThrowExceptionForHR(hr);

            return value;
        }

        /// <summary>
        /// Returns the value of the requested property whose data type is <see cref="SettingsType.Int64"/>.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="defaultValue">Value to be returned if the property does not exist.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property is of different type.</exception>
        /// <returns>If the property does not exist, it returns the defaultValue passed in. If the value was stored as an 
        /// unsigned long previously then regular type conversion sematics applies.</returns>
        public override long GetInt64(string collectionPath, string propertyName, long defaultValue)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            long value;
            int hr = this.settingsStore.GetInt64OrDefault(collectionPath, propertyName, defaultValue, out value);
            Marshal.ThrowExceptionForHR(hr);

            return value;
        }
        
        /// <summary>
        /// Returns the value of the requested property whose data type is <see cref="SettingsType.Int64"/>.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property is of different type or if it does 
        /// not exist.</exception>
        /// <returns>Value of the property. If the value was stored as an signed long previously then regular type 
        /// conversion sematics applies.</returns>        
        public override ulong GetUInt64(string collectionPath, string propertyName)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            ulong value;
            int hr = this.settingsStore.GetUnsignedInt64(collectionPath, propertyName, out value);
            Marshal.ThrowExceptionForHR(hr);

            return value;
        }

        /// <summary>
        /// Returns the value of the requested property whose data type is <see cref="SettingsType.Int64"/>.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="defaultValue">Value to be returned if the property does not exist.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property is of different type.</exception>
        /// <returns>If the property does not exist, it returns the defaultValue passed in. If the value was stored as an 
        /// signed long previously then regular type conversion sematics applies.</returns>
        public override ulong GetUInt64(string collectionPath, string propertyName, ulong defaultValue)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            ulong value;
            int hr = this.settingsStore.GetUnsignedInt64OrDefault(collectionPath, propertyName, defaultValue, out value);
            Marshal.ThrowExceptionForHR(hr);

            return value;
        }
        
        /// <summary>
        /// Returns the value of the requested property whose data type is <see cref="SettingsType.String"/>.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property is of different type or if it does 
        /// not exist.</exception>
        /// <returns>Value of the property.</returns> 
        public override string GetString(string collectionPath, string propertyName)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            string value;
            int hr = this.settingsStore.GetString(collectionPath, propertyName, out value);
            Marshal.ThrowExceptionForHR(hr);

            return value;
        }

        /// <summary>
        /// Returns the value of the requested property whose data type is <see cref="SettingsType.String"/>.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="defaultValue">Value to be returned if the property does not exist.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property is of different type.</exception>
        /// <returns>If the property does not exist, it returns the defaultValue passed in.</returns>
        public override string GetString(string collectionPath, string propertyName, string defaultValue)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            string value;
            int hr = this.settingsStore.GetStringOrDefault(collectionPath, propertyName, defaultValue, out value);
            Marshal.ThrowExceptionForHR(hr);

            return value;
        }

        /// <summary>
        /// Returns the value of the requested property whose data type is <see cref="SettingsType.Binary"/>. In order to
        /// access the underlying byte array at once <see cref="MemoryStream.ToArray"/> method can be used.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property is of different type or if it does 
        /// not exist.</exception>
        /// <returns><see cref="MemoryStream"/> for the stream of bytes this property.</returns>  
        public override MemoryStream GetMemoryStream(string collectionPath, string propertyName)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            // get the length of the property data
            uint[] actualLength = new uint[1];
            int hr = this.settingsStore.GetBinary(collectionPath, propertyName, 0, null, actualLength);
            Marshal.ThrowExceptionForHR(hr);

            // fetch the property data
            uint propertyDataLength = actualLength[0];  // byte length of the binary property
            byte[] propertyDataBuffer = new byte[propertyDataLength];
            hr = this.settingsStore.GetBinary(collectionPath, propertyName, propertyDataLength, propertyDataBuffer, null);
            Marshal.ThrowExceptionForHR(hr);

            return new MemoryStream(propertyDataBuffer);
        }

        /// <summary>
        /// Returns the type of the requested property.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <exception cref="ArgumentException">Throws this exception if the property does not exist.</exception>
        /// <returns>Type of the property.</returns>  
        public override SettingsType GetPropertyType(string collectionPath, string propertyName)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            uint propertyType;
            int hr = this.settingsStore.GetPropertyType(collectionPath, propertyName, out propertyType);
            Marshal.ThrowExceptionForHR(hr);

            return (SettingsType)propertyType;
        }
        
        /// <summary>
        /// Checks the existance of the property passed in to this method.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <returns>Returns true if the property exists and false otherwise.</returns>
        public override bool PropertyExists(string collectionPath, string propertyName)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            int doesPropertyExist;
            int hr = this.settingsStore.PropertyExists(collectionPath, propertyName, out doesPropertyExist);
            Marshal.ThrowExceptionForHR(hr);

            return Convert.ToBoolean(doesPropertyExist);
        }

        /// <summary>
        /// Checks the existance of the collection passed in to this method.
        /// </summary>
        /// <param name="collectionPath">Path of the collection.</param>
        /// <returns>Returns true if the collection exists and false otherwise.</returns>
        public override bool CollectionExists(string collectionPath)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");

            int doesCollectionExist;
            int hr = this.settingsStore.CollectionExists(collectionPath, out doesCollectionExist);
            Marshal.ThrowExceptionForHR(hr);

            return Convert.ToBoolean(doesCollectionExist);
        }
        
        /// <summary>
        /// Provides the last write time of the properties and sub collections immediate to the given collection. The method does 
        /// report any further changes internal to the sub collections (i.e. non-recursive). The last write time of a collection is 
        /// updated if properties are created, deleted or their values modified or if a sub collection is created or deleted.         
        /// </summary>
        /// <param name="collectionPath">Path of the collection.</param>
        /// <exception cref="ArgumentException">If the collection does not exist, method throws this exception.</exception>
        /// <returns>Last update time to the collection in <see cref="DateTimeKind.Local"/> format.</returns>
        public override DateTime GetLastWriteTime(string collectionPath)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");            

            SYSTEMTIME[] sysTime = new SYSTEMTIME[1];
            int hr = this.settingsStore.GetLastWriteTime(collectionPath, sysTime);
            Marshal.ThrowExceptionForHR(hr);

            return new DateTime(sysTime[0].wYear, sysTime[0].wMonth, sysTime[0].wDay, 
                                sysTime[0].wHour, sysTime[0].wMinute, sysTime[0].wSecond, 
                                sysTime[0].wMilliseconds, DateTimeKind.Local);
        }
                 
        /// <summary>
        /// Returns the number of sub collections under the given collection.
        /// </summary>
        /// <param name="collectionPath">Path of the collection.</param>
        /// <exception cref="ArgumentException">If the collection does not exist, method throws this exception.</exception>
        /// <returns>Number of sub collections is returned.</returns>
        public override int GetSubCollectionCount(string collectionPath)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");

            uint subCollectionCount;
            int hr = this.settingsStore.GetSubCollectionCount(collectionPath, out subCollectionCount);
            Marshal.ThrowExceptionForHR(hr);

            return Convert.ToInt32(subCollectionCount); // throws OverflowException if the value is larger than MAXINT which is not expected anyway
        }

        /// <summary>
        /// Returns the number of properties under the given collection.
        /// </summary>
        /// <param name="collectionPath">Path of the collection.</param>
        /// <exception cref="ArgumentException">If the collection does not exist, method throws this exception.</exception>
        /// <returns>Number of properties is returned.</returns>
        public override int GetPropertyCount(string collectionPath)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");

            uint propertyCount;
            int hr = this.settingsStore.GetPropertyCount(collectionPath, out propertyCount);
            Marshal.ThrowExceptionForHR(hr);

            return Convert.ToInt32(propertyCount); // throws OverflowException if the value is larger than MAXINT which is not expected anyway
        }

        /// <summary>
        /// Returns the names of sub collections under the given collection.
        /// </summary>
        /// <param name="collectionPath">Path of the collection.</param>
        /// <exception cref="ArgumentException">If the collection does not exist, method throws this exception.</exception>
        /// <returns>Names of sub collections is returned.</returns>
        public override IEnumerable<string> GetSubCollectionNames(string collectionPath)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");

            // count is cached since the GetSubCollectionName method itself verifies the limits
            uint subCollectionCount;
            int hr = this.settingsStore.GetSubCollectionCount(collectionPath, out subCollectionCount);
            Marshal.ThrowExceptionForHR(hr);

            // TODO: When "yield return" is used above execption is not thrown when the argument is null,
            // update the below loop to use yield return when that problem is fixed.
            string[] names = new string[subCollectionCount];
            for (uint i = 0; i < subCollectionCount; i++)
            {
                string subCollectionName;
                hr = this.settingsStore.GetSubCollectionName(collectionPath, i, out subCollectionName);
                Marshal.ThrowExceptionForHR(hr);
                names[i] = subCollectionName;
            }

            return names;
        }

        /// <summary>
        /// Returns the names of properties under the given collection.
        /// </summary>
        /// <param name="collectionPath">Path of the collection.</param>
        /// <exception cref="ArgumentException">If the collection does not exist, method throws this exception.</exception>
        /// <returns>Names of properties is returned.</returns>
        public override IEnumerable<string> GetPropertyNames(string collectionPath)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");

            // count is cached since the GetPropertyName method itself verifies the limits
            uint propertyCount;
            int hr = this.settingsStore.GetPropertyCount(collectionPath, out propertyCount);
            Marshal.ThrowExceptionForHR(hr);

            // TODO: When "yield return" is used above execption is not thrown when the argument is null,
            // update the below loop to use yield return when that problem is fixed.
            string[] names = new string[propertyCount];
            for (uint i = 0; i < propertyCount; i++)
            {
                string propertyName;
                hr = this.settingsStore.GetPropertyName(collectionPath, i, out propertyName);
                Marshal.ThrowExceptionForHR(hr);
                names[i] = propertyName;
            }

            return names;
        }        

        /// <summary>
        /// Internal constructor that takes the COM interface that provides the functionality of this class.
        /// </summary>
        /// <param name="settingsStore">COM interface wrapped by this class.</param>
        internal ShellSettingsStore(IVsSettingsStore settingsStore)
        {
            HelperMethods.CheckNullArgument(settingsStore, "settingsStore");
            this.settingsStore = settingsStore;
        }

        // Thunked interop COM interface
        private IVsSettingsStore settingsStore;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Settings\ShellSettingsManager.cs ===
//------------------------------------------------------------------------------
// <copyright file="SettingsManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell.Settings
{
    using System;
    using System.Collections.Generic;
    using Microsoft.VisualStudio.Shell.Interop;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using Microsoft.VisualStudio.Settings;

    /// <summary>
    /// This is the gateway class to reach for the settings stored inside the Visual Studio. It provides two basic
    /// functionality. It allows to search for properties and collections inside the scopes. It hands the 
    /// <see cref="SettingsScope"/> and <see cref="WritableSettingsStore"/> classes for further manipulation of the 
    /// collections and properties within the scopes. This class implements the <see cref="IDisposable"/> pattern 
    /// hence it needs to be disposed after it is no longer necessary.
    /// </summary>
    [CLSCompliant(false)] // Methods of this class have enumeration return values
    public sealed class ShellSettingsManager : SettingsManager
    {        
        /// <summary>
        /// Constructor for the SettingsManager class. It requires Service Provider to reach IVsSettingsManager
        /// which is the interop COM interface of the service that provides the Settings related functionalities.
        /// </summary>
        /// <param name="serviceProvider">Service provider of the VS.</param>
        public ShellSettingsManager(IServiceProvider serviceProvider)
        {
            HelperMethods.CheckNullArgument(serviceProvider, "serviceProvider");

            this.settingsManager = serviceProvider.GetService(typeof(SVsSettingsManager)) as IVsSettingsManager;
            if (this.settingsManager == null)
            {
                throw new NotSupportedException(typeof(SVsSettingsManager).FullName);
            }
        }

        /// <summary>
        /// Outputs the scopes that contain the given collection. If more than one scope contains the collection,
        /// the corresponding bit flags of those scopes are set.
        /// </summary>
        /// <param name="collectionPath">Path of the collection to be searched.</param>
        /// <returns>Enclosing scopes.</returns>
        public override EnclosingScopes GetCollectionScopes(string collectionPath)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");

            uint scopes;
            int hr = this.settingsManager.GetCollectionScopes(collectionPath, out scopes);
            Marshal.ThrowExceptionForHR(hr);

            return (EnclosingScopes)scopes;
        }

        /// <summary>
        /// Outputs the scopes that contain the given property. If more than one scope contains the property,
        /// the corresponding bit flags of those scopes are set.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property to be searched.</param>
        /// <returns>Enclosing scopes.</returns>
        public override EnclosingScopes GetPropertyScopes(string collectionPath, string propertyName)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            uint scopes;
            int hr = this.settingsManager.GetPropertyScopes(collectionPath, propertyName, out scopes);
            Marshal.ThrowExceptionForHR(hr);            

            return (EnclosingScopes)scopes;
        }

        /// <summary>
        /// Provides the <see cref="SettingsStore"/> class for the requested scope which can be used for read-only 
        /// operations.
        /// </summary>
        /// <param name="scope">Requested scope.</param>
        /// <returns><see cref="SettingsStore"/> instance that can be used for accessing the scope.</returns>
        public override SettingsStore GetReadOnlySettingsStore(SettingsScope scope)
        {
            IVsSettingsStore settingsStore;
            int hr = this.settingsManager.GetReadOnlySettingsStore((uint)scope, out settingsStore);
            Marshal.ThrowExceptionForHR(hr);            

            return new ShellSettingsStore(settingsStore);
        }

        /// <summary>
        /// Provides the <see cref="WritableSettingsStore"/> class for the requested scope which can be used both for
        /// reading and writing.
        /// </summary>
        /// <param name="scope">Requested scope.</param>
        /// <exception cref="ArgumentException">If the given scope is not a writable one.</exception>
        /// <returns><see cref="WritableSettingsStore"/> instance that can be used for accessing the scope.</returns>
        public override WritableSettingsStore GetWritableSettingsStore(SettingsScope scope)
        {
            IVsWritableSettingsStore writableSettingsStore;
            int hr = this.settingsManager.GetWritableSettingsStore((uint)scope, out writableSettingsStore);
            Marshal.ThrowExceptionForHR(hr);
            
            return new ShellWritableSettingsStore(writableSettingsStore);
        }

        /// <summary>
        /// Returns the folder that Visual Studio uses for storing various cache, backup, template, etc. files
        /// </summary>
        /// <param name="folder">Requested folder.</param>        
        /// <returns>Full path of the requested folder.</returns>
        public override string GetApplicationDataFolder(ApplicationDataFolder folder)
        {
            string folderPath;
            int hr = this.settingsManager.GetApplicationDataFolder((uint)folder, out folderPath);
            Marshal.ThrowExceptionForHR(hr);

            return folderPath;
        }

        /// <summary>
        /// Returns the list of folders that Visual Studio uses for installing/discovering machine-wide extensions.
        /// </summary>
        /// <returns>List of extensions root paths.</returns>
        public override IEnumerable<string> GetCommonExtensionsSearchPaths()
        {
            uint arraySize;
            int hr = this.settingsManager.GetCommonExtensionsSearchPaths(0, null, out arraySize);
            Marshal.ThrowExceptionForHR(hr);

            string[] searchPaths = new string[arraySize];
            hr = this.settingsManager.GetCommonExtensionsSearchPaths((uint)searchPaths.Length, searchPaths, out arraySize);
            Marshal.ThrowExceptionForHR(hr);
            return searchPaths;
        }

        // Thunked interop COM interface.
        private IVsSettingsManager settingsManager;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Settings\ShellWritableSettingsStore.cs ===
//------------------------------------------------------------------------------
// <copyright file="WritableSettingsStore.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell.Settings
{
    using System;
    using System.IO;
    using System.Collections.Generic;
    using Microsoft.VisualStudio.Shell.Interop;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using Microsoft.VisualStudio.Settings;
    
    /// <summary>
    /// Abstract class for both reading and writing the selected scope's collections and properties. It is obtained from 
    /// <see cref="SettingsManager.GetWritableSettingsStore"/> method.
    /// 
    /// This class is derived from the SettingsStore hence it inherits all the functionalities from it. It adds property and
    /// collection manipulation abilities on top of it.
    /// </summary>    
    [CLSCompliant(false)] // Methods of this class have unsigned integer parameters
    internal sealed class ShellWritableSettingsStore : WritableSettingsStore
    {
        #region SettingsStore implementation
        /// The overrides to the SettingsStore methods are delegated to an instance of
        /// the ShellSettingsStore class.

        public override bool GetBoolean(string collectionPath, string propertyName)
        {
            return settingsStore.GetBoolean(collectionPath, propertyName);
        }

        public override bool GetBoolean(string collectionPath, string propertyName, bool defaultValue)
        {
            return settingsStore.GetBoolean(collectionPath, propertyName, defaultValue);
        }

        public override int GetInt32(string collectionPath, string propertyName)
        {
            return settingsStore.GetInt32(collectionPath, propertyName);
        }

        public override int GetInt32(string collectionPath, string propertyName, int defaultValue)
        {
            return settingsStore.GetInt32(collectionPath, propertyName, defaultValue);
        }

        public override uint GetUInt32(string collectionPath, string propertyName)
        {
            return settingsStore.GetUInt32(collectionPath, propertyName);
        }

        public override uint GetUInt32(string collectionPath, string propertyName, uint defaultValue)
        {
            return settingsStore.GetUInt32(collectionPath, propertyName, defaultValue);
        }

        public override long GetInt64(string collectionPath, string propertyName)
        {
            return settingsStore.GetInt64(collectionPath, propertyName);
        }

        public override long GetInt64(string collectionPath, string propertyName, long defaultValue)
        {
            return settingsStore.GetInt64(collectionPath, propertyName, defaultValue);
        }

        public override ulong GetUInt64(string collectionPath, string propertyName)
        {
            return settingsStore.GetUInt64(collectionPath, propertyName);
        }

        public override ulong GetUInt64(string collectionPath, string propertyName, ulong defaultValue)
        {
            return settingsStore.GetUInt64(collectionPath, propertyName, defaultValue);
        }

        public override string GetString(string collectionPath, string propertyName)
        {
            return settingsStore.GetString(collectionPath, propertyName);
        }

        public override string GetString(string collectionPath, string propertyName, string defaultValue)
        {
            return settingsStore.GetString(collectionPath, propertyName, defaultValue);
        }

        public override MemoryStream GetMemoryStream(string collectionPath, string propertyName)
        {
            return settingsStore.GetMemoryStream(collectionPath, propertyName);
        }

        public override SettingsType GetPropertyType(string collectionPath, string propertyName)
        {
            return settingsStore.GetPropertyType(collectionPath, propertyName);
        }

        public override bool PropertyExists(string collectionPath, string propertyName)
        {
            return settingsStore.PropertyExists(collectionPath, propertyName);
        }

        public override bool CollectionExists(string collectionPath)
        {
            return settingsStore.CollectionExists(collectionPath);
        }

        public override DateTime GetLastWriteTime(string collectionPath)
        {
            return settingsStore.GetLastWriteTime(collectionPath);
        }

        public override int GetSubCollectionCount(string collectionPath)
        {
            return settingsStore.GetSubCollectionCount(collectionPath);
        }

        public override int GetPropertyCount(string collectionPath)
        {
            return settingsStore.GetPropertyCount(collectionPath);
        }

        public override IEnumerable<string> GetSubCollectionNames(string collectionPath)
        {
            return settingsStore.GetSubCollectionNames(collectionPath);
        }

        public override IEnumerable<string> GetPropertyNames(string collectionPath)
        {
            return settingsStore.GetPropertyNames(collectionPath);
        }

        #endregion

        #region WritableSettingsStore implementation

        /// <summary>
        /// Updates the value of the specified property to the given Boolean value while setting its data type to 
        /// <see cref="SettingsType.Int32"/>. If the previous data type of the property is different, it overwrites it.
        /// If the property does not exist it creates one.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="value">New value of the property.</param>
        /// <exception cref="ArgumentException">If the collection does not exist, this exception is thrown.</exception>  
        public override void SetBoolean(string collectionPath, string propertyName, bool value)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            int hr = this.writableSettingsStore.SetBool(collectionPath, propertyName, Convert.ToInt32(value));
            Marshal.ThrowExceptionForHR(hr);
        }     

        /// <summary>
        /// Updates the value of the specified property to the given integer value while setting its data type to 
        /// <see cref="SettingsType.Int32"/>. If the previous data type of the property is different, it overwrites it.
        /// If the property does not exist it creates one.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="value">New value of the property.</param>
        /// <exception cref="ArgumentException">If the collection does not exist, this exception is thrown.</exception>        
        public override void SetInt32(string collectionPath, string propertyName, int value)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            int hr = this.writableSettingsStore.SetInt(collectionPath, propertyName, value);
            Marshal.ThrowExceptionForHR(hr);
        }        

        /// <summary>
        /// Updates the value of the specified property to the given unsigned integer value while setting its data type to 
        /// <see cref="SettingsType.Int32"/>. If the previous data type of the property is different, it overwrites it.
        /// If the property does not exist it creates one.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="value">New value of the property.</param>
        /// <exception cref="ArgumentException">If the collection does not exist, this exception is thrown.</exception>        
        public override void SetUInt32(string collectionPath, string propertyName, uint value)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            int hr = this.writableSettingsStore.SetUnsignedInt(collectionPath, propertyName, value);
            Marshal.ThrowExceptionForHR(hr);

        }        

        /// <summary>
        /// Updates the value of the specified property to the given long value while setting its data type to 
        /// <see cref="SettingsType.Int64"/>. If the previous data type of the property is different, it overwrites it.
        /// If the property does not exist it creates one.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="value">New value of the property.</param>
        /// <exception cref="ArgumentException">If the collection does not exist, this exception is thrown.</exception>        
        public override void SetInt64(string collectionPath, string propertyName, long value)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            int hr = this.writableSettingsStore.SetInt64(collectionPath, propertyName, value);
            Marshal.ThrowExceptionForHR(hr);
        }

        /// <summary>
        /// Updates the value of the specified property to the given unsigned long value while setting its data type to 
        /// <see cref="SettingsType.Int64"/>. If the previous data type of the property is different, it overwrites it.
        /// If the property does not exist it creates one.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="value">New value of the property.</param>
        /// <exception cref="ArgumentException">If the collection does not exist, this exception is thrown.</exception> 
        public override void SetUInt64(string collectionPath, string propertyName, ulong value)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            int hr = this.writableSettingsStore.SetUnsignedInt64(collectionPath, propertyName, value);
            Marshal.ThrowExceptionForHR(hr);
        }

        /// <summary>
        /// Updates the value of the specified property to the given string value while setting its data type to 
        /// <see cref="SettingsType.String"/>. If the previous data type of the property is different, it overwrites it.
        /// If the property does not exist it creates one.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="value">New value of the property.</param>
        /// <exception cref="ArgumentException">If the collection does not exist, this exception is thrown.</exception> 
        public override void SetString(string collectionPath, string propertyName, string value)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");
            HelperMethods.CheckNullArgument(value, "value");

            int hr = this.writableSettingsStore.SetString(collectionPath, propertyName, value);
            Marshal.ThrowExceptionForHR(hr);
        }        

        /// <summary>
        /// Updates the value of the specified property to the bits of the MemoryStream while setting its data type to 
        /// <see cref="SettingsType.Binary"/>. If the previous data type of the property is different, it overwrites it.
        /// If the property does not exist it creates one.
        /// </summary>
        /// <param name="collectionPath">Path of the collection of the property.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="value">MemoryStream to set the bits of the property.</param>
        /// <exception cref="ArgumentException">If the collection does not exist, this exception is thrown.</exception> 
        public override void SetMemoryStream(string collectionPath, string propertyName, MemoryStream value)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");
            HelperMethods.CheckNullArgument(value, "value");

            byte[] valueBuffer = value.ToArray();
            int hr = this.writableSettingsStore.SetBinary(collectionPath, propertyName, (uint)valueBuffer.Length, valueBuffer);
            Marshal.ThrowExceptionForHR(hr);
        }        

        /// <summary>
        /// Creates the given collection path by creating each nested collection while skipping the ones that already exist. 
        /// If the full path of collections already exist, the method simply returns.
        /// </summary>
        /// <param name="collectionPath">Path of the collection.</param>
        /// <exception cref="ArgumentException">If empty string ("") is passed to the method then it throws this exception.
        /// </exception>
        public override void CreateCollection(string collectionPath)
        {
            HelperMethods.CheckNullOrEmptyString(collectionPath, "collectionPath");

            int hr = this.writableSettingsStore.CreateCollection(collectionPath);
            Marshal.ThrowExceptionForHR(hr);
        }           

        /// <summary>
        /// Deletes the given collection recursively deleting all of the sub collections and properties in it. If the collection 
        /// does not exist or an empty string ("") is passed then the method returns false.
        /// </summary>
        /// <param name="collectionPath">Path of the collection to be deleted.</param>
        /// <returns>Result of the deletion.</returns>
        public override bool DeleteCollection(string collectionPath)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");

            int hr = this.writableSettingsStore.DeleteCollection(collectionPath);
            Marshal.ThrowExceptionForHR(hr);

            Debug.Assert(hr == VSConstants.S_OK || hr == VSConstants.S_FALSE);

            return hr == VSConstants.S_OK;
        }        

        /// <summary>         
        /// Deletes the given property from the collection. If the property or the collection does not exist then the method 
        /// returns false.
        /// </summary>
        /// <param name="collectionPath">Collection that contains the property to be deleted.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <returns>Result of the deletion.</returns>
        public override bool DeleteProperty(string collectionPath, string propertyName)
        {
            HelperMethods.CheckNullArgument(collectionPath, "collectionPath");
            HelperMethods.CheckNullArgument(propertyName, "propertyName");

            int hr = this.writableSettingsStore.DeleteProperty(collectionPath, propertyName);
            Marshal.ThrowExceptionForHR(hr);

            Debug.Assert(hr == VSConstants.S_OK || hr == VSConstants.S_FALSE);

            return hr == VSConstants.S_OK;
        }

        #endregion

        /// <summary>
        /// Internal constructor that takes the COM interface that provides the functionality of this class.
        /// </summary>
        /// <param name="writableSettingsStore">COM interface wrapped by this class.</param>
        internal ShellWritableSettingsStore(IVsWritableSettingsStore writableSettingsStore)
        {
            HelperMethods.CheckNullArgument(writableSettingsStore, "writableSettingsStore");
            this.writableSettingsStore = writableSettingsStore;
            this.settingsStore = new ShellSettingsStore(this.writableSettingsStore);
        }

        // Thunked interop COM interface.
        private IVsWritableSettingsStore writableSettingsStore;

        // Thunked SettingsStore instance.
        private SettingsStore settingsStore;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Flavor\FlavoredProjectBase.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

namespace Microsoft.VisualStudio.Shell.Flavor
{
    using System;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell;
    using ErrorHandler = Microsoft.VisualStudio.ErrorHandler;

    /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject"]/*' />
    /// <devdoc>
    /// A project that is a subtype/flavor of an inner project.
    /// The default behavior of all methods is to delegate to the
    /// inner project. For any behavior you want to change, simply
    /// handle the request yourself.
    /// </devdoc>
    [CLSCompliant(false)]
    public abstract class FlavoredProjectBase : 
        IVsAggregatableProjectCorrected,
        System.IServiceProvider,
        IVsHierarchy,
        IVsUIHierarchy,
        IOleCommandTarget
    {
        // Keep interface reference for all interface we override

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject._innerVsAggregatableProject"]/*' />
        protected IVsAggregatableProjectCorrected _innerVsAggregatableProject;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject._innerVsHierarchy"]/*' />
        protected IVsHierarchy _innerVsHierarchy;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject._innerVsUIHierarchy"]/*' />
        protected IVsUIHierarchy _innerVsUIHierarchy;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject._innerOleCommandTarget"]/*' />
        protected IOleCommandTarget _innerOleCommandTarget;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.serviceProvider"]/*' />
        protected System.IServiceProvider serviceProvider;

        private OleMenuCommandService _menuService;
        private DocumentsEventsSink _documentsEventsSink;
        private bool _hierarchyClosed = false;
        private int _inExecCommand = 0;

        uint cookie = 0;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FlavoredProject"]/*' />
        public FlavoredProjectBase()
        {
            _documentsEventsSink = new FlavoredProjectBase.DocumentsEventsSink(this);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetComInterface"]/*' />
        /// <devdoc>
        /// A project derived from this base class will be aggregated with a native COM component (the ProjectAggregator object) 
        /// that can also aggregate an inner project in case of flavoring.
        /// Because of this structure, all the request for interfaces exposed to COM must be handled by the external object that 
        /// has a special implementation of QueryInterface that handles both inner and outer projects. 
        /// If you dont use this helper method when requesting an interface you can get unexpected InvalidCast exceptions.
        /// Note that if you want to get the implementation of an interface implemented by your FlavoredProjectBase-derived
        /// object, then you must use the standard cast operator.
        /// </devdoc>
        public Interface_T GetComInterface<Interface_T>() where Interface_T : class
        {
            IntPtr thisUnknown = IntPtr.Zero;
            IntPtr interfacePtr = IntPtr.Zero;
            try
            {
                thisUnknown = Marshal.GetIUnknownForObject(this);
                Guid iid = typeof(Interface_T).GUID;
                if (ErrorHandler.Failed(Marshal.QueryInterface(thisUnknown, ref iid, out interfacePtr)) || (IntPtr.Zero == interfacePtr))
                {
                    return null;
                }
                return Marshal.GetObjectForIUnknown(interfacePtr) as Interface_T;
            }
            finally
            {
                if (IntPtr.Zero != thisUnknown)
                {
                    Marshal.Release(thisUnknown);
                }
                if (IntPtr.Zero != interfacePtr)
                {
                    Marshal.Release(interfacePtr);
                }
            }
        }

        #region IVsAggregatableProjectCorrected

        /// <devdoc>
        /// This is where all QI for interface on the inner object should happen
        /// Then set the inner project
        /// wait for InitializeForOuter to be called to do the real initialization
        /// </devdoc>
        int IVsAggregatableProjectCorrected.SetInnerProject(IntPtr innerIUnknown)
        {
            // delegate to the protected method
            this.SetInnerProject(innerIUnknown);

            return VSConstants.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetInnerProject"]/*' />
        /// <devdoc>
        /// This is were all QI for interface on the inner object should happen
        /// Then set the inner project
        /// wait for InitializeForOuter to be called to do the real initialization
        /// </devdoc>
        protected virtual void SetInnerProject(IntPtr innerIUnknown)
        {
            object inner = null;

            inner = Marshal.GetObjectForIUnknown(innerIUnknown);

            // Keep a reference to each interface we want to call on the inner project
            // we must do it now as once we call SetInner the AddRef would be forwarded to ourselves
            _innerVsAggregatableProject = inner as IVsAggregatableProjectCorrected;
            Debug.Assert(inner != null, "Failed to retrieve IVsAggregatableProjectCorrected from inner Project");
            _innerVsHierarchy = (IVsHierarchy)inner;
            _innerVsUIHierarchy = (IVsUIHierarchy)inner;
            // "As" should return null without throwing in the event the base project does not implement the interface
            _innerOleCommandTarget = inner as IOleCommandTarget;

            // Setup our menu command service
            if (this.serviceProvider == null)
                throw new NotSupportedException("serviceProvider should have been set before SetInnerProject gets called.");
            _menuService = new OleMenuCommandService(this, _innerOleCommandTarget);

            // Pass the inner project pointer to the VisualStudio.ProjectAggregator2 object. This native object
            // has a special implementation of QueryInterface that delegates first to our managed FlavoredProjectBase
            // derived object and then to the inner project (either the base project or the next project flavor down).
            IntPtr thisIUnknown = IntPtr.Zero;
            IVsProjectAggregator2 vsProjectAggregator2 = null;
            try
            {
                thisIUnknown = Marshal.GetIUnknownForObject(this);
                vsProjectAggregator2 = (IVsProjectAggregator2)Marshal.GetObjectForIUnknown(thisIUnknown);
                if (vsProjectAggregator2 != null)
                    vsProjectAggregator2.SetInner(innerIUnknown);
            }
            finally
            {
                if (thisIUnknown != IntPtr.Zero)
                    Marshal.Release(thisIUnknown);
            }
        }

        /// <devdoc>
        /// Do the initialization here (such as loading flavor specific
        /// information from the project)
        /// </devdoc>
        int IVsAggregatableProjectCorrected.InitializeForOuter(string fileName, string location, string name,
            uint flags, ref Guid guidProject, out IntPtr project, out int canceled)
        {
            int hr = VSConstants.S_OK;
            project = IntPtr.Zero;
            canceled = 0;

            if (_innerVsAggregatableProject == null || guidProject != VSConstants.IID_IUnknown)
                throw new NotSupportedException();

            IntPtr thisIUnknown = IntPtr.Zero;
            try
            {
                thisIUnknown = Marshal.GetIUnknownForObject(this);
                if (thisIUnknown != IntPtr.Zero)
                    hr = Marshal.QueryInterface(thisIUnknown, ref guidProject, out project);
            }
            finally
            {
                if (thisIUnknown != IntPtr.Zero)
                    Marshal.Release(thisIUnknown);
            }

            bool cancel;
            this.InitializeForOuter(fileName, location, name, flags, ref guidProject, out cancel);
            if (cancel)
                canceled = 1;

            return hr;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.InitializeForOuter"]/*' />
        /// <devdoc>
        /// Allow the project to initialize itself.
        /// At this point it possible to call the inner project
        /// Also allow canceling the project creation
        /// </devdoc>
        /// <returns>Return true to cancel the project creation</returns>
        protected virtual void InitializeForOuter(string fileName, string location, string name, uint flags, ref Guid guidProject, out bool cancel)
        {
            cancel = false;
        }
        /// <devdoc>
        /// This is called when all object in aggregation have received InitializeForOuter calls.
        /// At this point the aggregation is complete and fully functional.
        /// </devdoc>
        int IVsAggregatableProjectCorrected.OnAggregationComplete()
        {
            this.OnAggregationComplete();
            if (_innerVsAggregatableProject != null)
                return _innerVsAggregatableProject.OnAggregationComplete();
            return VSConstants.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.OnAggregationComplete"]/*' />
        /// <devdoc>
        /// This is called when all object in aggregation have received InitializeForOuter calls.
        /// At this point the aggregation is complete and fully functional.
        /// </devdoc>
        protected virtual void OnAggregationComplete()
        {
            // This will subscribe to the IVsTrackProjectDocumentsEvents.
            // This is not required to flavor a project but makes it easier for derived class
            // to subscribe to these events.
            IVsTrackProjectDocuments2 trackDocuments = GetTrackProjectDocuments();
            ErrorHandler.ThrowOnFailure(trackDocuments.AdviseTrackProjectDocumentsEvents(_documentsEventsSink, out cookie));
        }

        /// <devdoc>
        /// This must be delegetated to the inner most project
        /// </devdoc>
        int IVsAggregatableProjectCorrected.SetAggregateProjectTypeGuids(string projectTypeGuids)
        {
            if (_innerVsAggregatableProject == null)
                throw new NotSupportedException();

            return _innerVsAggregatableProject.SetAggregateProjectTypeGuids(projectTypeGuids);
        }

        /// <devdoc>
        /// This must be delegetated to the inner most project
        /// </devdoc>
        int IVsAggregatableProjectCorrected.GetAggregateProjectTypeGuids(out string projectTypeGuids)
        {
            if (_innerVsAggregatableProject == null)
                throw new NotSupportedException();

            return _innerVsAggregatableProject.GetAggregateProjectTypeGuids(out projectTypeGuids);
        }

        #endregion

        #region IVsHierarchy
        //
        // Most methods call protected virtual methods which delegate to the inner project.
        // Derived classes should override those protected method if they want to change the
        // behavior.
        //

        int IVsHierarchy.AdviseHierarchyEvents(Microsoft.VisualStudio.Shell.Interop.IVsHierarchyEvents eventSink, out uint cookie)
        {
            cookie = this.AdviseHierarchyEvents(eventSink);
            return VSConstants.S_OK;
        }

        int IVsHierarchy.Close()
        {
            _hierarchyClosed = true;
            this.Close();

            if (cookie != 0)
            {
                // Unsubscribe to events
                IVsTrackProjectDocuments2 trackDocuments = GetTrackProjectDocuments();
                trackDocuments.UnadviseTrackProjectDocumentsEvents(cookie);
                cookie = 0;
            }

            if (this._menuService != null)
            {
                OleMenuCommandService tempService = this._menuService;
                this._menuService = null;
                tempService.Dispose();
            }

            if (_inExecCommand == 0)
                FreeInterfaces();

            return VSConstants.S_OK;
        }

        public virtual void FreeInterfaces()
        {
            if (this._menuService != null)
            {
                OleMenuCommandService tempService = this._menuService;
                this._menuService = null;
                tempService.Dispose();
            }

            _innerOleCommandTarget = null;
            _innerVsAggregatableProject = null;
            _innerVsUIHierarchy = null;
            _innerVsHierarchy = null;
        }



        int IVsHierarchy.GetCanonicalName(uint itemId, out string name)
        {
            return this.GetCanonicalName(itemId, out name);
        }

        int IVsHierarchy.GetGuidProperty(uint itemId, int propId, out System.Guid guid)
        {
            guid = this.GetGuidProperty(itemId, propId);
            return VSConstants.S_OK;
        }

        int IVsHierarchy.GetNestedHierarchy(uint itemId, ref System.Guid guidHierarchyNested, out System.IntPtr hierarchyNested, out uint itemIdNested)
        {
            return this.GetNestedHierarchy(itemId, ref guidHierarchyNested, out hierarchyNested, out itemIdNested);
        }

        int IVsHierarchy.GetProperty(uint itemId, int propId, out System.Object property)
        {
            // While other methods expect the protected method to throw, for GetProperty
            // we break this pattern as it is called much more often and it is legitimate to
            // return not implemented. Therefore it can help perf and debugging experience
            return this.GetProperty(itemId, propId, out property);
        }

        int IVsHierarchy.GetSite(out Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider)
        {
            serviceProvider = this.GetSite();
            return VSConstants.S_OK;
        }

        int IVsHierarchy.ParseCanonicalName(string name, out uint itemId)
        {
            return this.ParseCanonicalName(name, out itemId);
        }

        int IVsHierarchy.QueryClose(out int canClose)
        {
            canClose = 0;
            if (this.QueryClose())
                canClose = 1;
            return VSConstants.S_OK;
        }

        int IVsHierarchy.SetGuidProperty(uint itemId, int propId, ref System.Guid guid)
        {
            this.SetGuidProperty(itemId, propId, ref guid);
            return VSConstants.S_OK;
        }

        int IVsHierarchy.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider)
        {
            this.serviceProvider = (System.IServiceProvider)new ServiceProvider(serviceProvider);
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.SetSite(serviceProvider));
            return VSConstants.S_OK;
        }

        int IVsHierarchy.UnadviseHierarchyEvents(uint cookie)
        {
            this.UnadviseHierarchyEvents(cookie);
            return VSConstants.S_OK;
        }

        int IVsHierarchy.SetProperty(uint itemId, int propId, System.Object property)
        {
            return this.SetProperty(itemId, propId, property);
        }

        int IVsHierarchy.Unused0()
        {
            this.Unused0();
            return VSConstants.S_OK;
        }

        int IVsHierarchy.Unused1()
        {
            this.Unused1();
            return VSConstants.S_OK;
        }

        int IVsHierarchy.Unused2()
        {
            this.Unused2();
            return VSConstants.S_OK;
        }

        int IVsHierarchy.Unused3()
        {
            this.Unused3();
            return VSConstants.S_OK;
        }

        int IVsHierarchy.Unused4()
        {
            this.Unused4();
            return VSConstants.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.AdviseHierarchyEvents"]/*' />
        protected virtual uint AdviseHierarchyEvents(Microsoft.VisualStudio.Shell.Interop.IVsHierarchyEvents eventSink)
        {
            uint cookie=0;
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.AdviseHierarchyEvents(eventSink, out cookie));
            return cookie;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Close"]/*' />
        protected virtual void Close()
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.Close());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetCanonicalName"]/*' />
        protected virtual int GetCanonicalName(uint itemId, out string name)
        {
            return _innerVsHierarchy.GetCanonicalName(itemId, out name);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetGuidProperty"]/*' />
        protected virtual Guid GetGuidProperty(uint itemId, int propId)
        {
            Guid property = Guid.Empty;
            if (_innerVsHierarchy != null)
                ErrorHandler.ThrowOnFailure(_innerVsHierarchy.GetGuidProperty(itemId, propId, out property));
            else
                return Guid.Empty;
            return property;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetNestedHierarchy"]/*' />
        protected virtual int GetNestedHierarchy(uint itemId, ref System.Guid guidHierarchyNested, out System.IntPtr hierarchyNested, out uint itemIdNested)
        {
            if (_innerVsHierarchy != null)
                return _innerVsHierarchy.GetNestedHierarchy(itemId, ref guidHierarchyNested, out hierarchyNested, out itemIdNested);
            else
            {
                hierarchyNested = IntPtr.Zero;
                itemIdNested = VSConstants.VSITEMID_NIL;
                return VSConstants.E_NOINTERFACE;
            }
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetProperty"]/*' />
        protected virtual int GetProperty(uint itemId, int propId, out Object property)
        {
            if (_innerVsHierarchy != null)
                return _innerVsHierarchy.GetProperty(itemId, propId, out property);
            else
            {
                property = null;
                return VSConstants.E_UNEXPECTED;
            }
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetSite"]/*' />
        protected virtual Microsoft.VisualStudio.OLE.Interop.IServiceProvider GetSite()
        {
            Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider;
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.GetSite(out serviceProvider));
            return serviceProvider;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.ParseCanonicalName"]/*' />
        protected virtual int ParseCanonicalName(string name, out uint itemId)
        {
            return _innerVsHierarchy.ParseCanonicalName(name, out itemId);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.QueryClose"]/*' />
        protected virtual bool QueryClose()
        {
            int canClose;
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.QueryClose(out canClose));
            return (canClose != 0);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetGuidProperty"]/*' />
        protected virtual void SetGuidProperty(uint itemId, int propId, ref System.Guid guid)
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.SetGuidProperty(itemId, propId, ref guid));
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.UnadviseHierarchyEvents"]/*' />
        protected virtual void UnadviseHierarchyEvents(uint cookie)
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.UnadviseHierarchyEvents(cookie));
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetProperty"]/*' />
        protected virtual int SetProperty(uint itemId, int propId, System.Object property)
        {
            return _innerVsHierarchy.SetProperty(itemId, propId, property);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused0"]/*' />
        protected virtual void Unused0()
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.Unused0());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused1"]/*' />
        protected virtual void Unused1()
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.Unused1());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused2"]/*' />
        protected virtual void Unused2()
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.Unused2());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused3"]/*' />
        protected virtual void Unused3()
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.Unused3());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused4"]/*' />
        protected virtual void Unused4()
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.Unused4());
        }
        #endregion

        #region IVsUIHierarchy Members
        //
        // All methods (except for QueryStatusCommand and ExecCommand) call the IVsHierarchy implementation.
        // QueryStatusCommand and ExecCommand call a protected virtual method that the base class can override.
        // Note that we QI for IVsUIHierarchy on this so that if we are flavored we call the outer IVsHierarchy.
        //

        int IVsUIHierarchy.QueryStatusCommand(uint itemid, ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            return this.QueryStatusCommand(itemid, ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.QueryStatusCommand"]/*' />
        protected virtual int QueryStatusCommand(uint itemid, ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            return _innerVsUIHierarchy.QueryStatusCommand(itemid, ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }

        int IVsUIHierarchy.ExecCommand(uint itemid, ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            int hr = VSConstants.S_OK;
            try
            {
                _inExecCommand++;
                hr = this.ExecCommand(itemid, ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
            }
            finally
            {
                _inExecCommand--;
                Debug.Assert(_inExecCommand >= 0);
                if (_hierarchyClosed && _inExecCommand == 0)
                {
                    FreeInterfaces();
                }
            }
            return hr;
        }
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.ExecCommand"]/*' />
        protected virtual int ExecCommand(uint itemid, ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            return _innerVsUIHierarchy.ExecCommand(itemid, ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
        }

        int IVsUIHierarchy.AdviseHierarchyEvents(IVsHierarchyEvents pEventSink, out uint pdwCookie)
        {
            return ((IVsHierarchy)this).AdviseHierarchyEvents(pEventSink, out pdwCookie);
        }

        int IVsUIHierarchy.Close()
        {
            return ((IVsHierarchy)this).Close();
        }

        int IVsUIHierarchy.GetCanonicalName(uint itemid, out string pbstrName)
        {
            return ((IVsHierarchy)this).GetCanonicalName(itemid, out pbstrName);
        }

        int IVsUIHierarchy.GetGuidProperty(uint itemid, int propid, out Guid pguid)
        {
            return ((IVsHierarchy)this).GetGuidProperty(itemid, propid, out pguid);
        }

        int IVsUIHierarchy.GetNestedHierarchy(uint itemid, ref Guid iidHierarchyNested, out IntPtr ppHierarchyNested, out uint pitemidNested)
        {
            return ((IVsHierarchy)this).GetNestedHierarchy(itemid, ref iidHierarchyNested, out ppHierarchyNested, out pitemidNested);
        }

        int IVsUIHierarchy.GetProperty(uint itemid, int propid, out object pvar)
        {
            return ((IVsHierarchy)this).GetProperty(itemid, propid, out pvar);
        }

        int IVsUIHierarchy.GetSite(out Microsoft.VisualStudio.OLE.Interop.IServiceProvider ppSP)
        {
            return ((IVsHierarchy)this).GetSite(out ppSP);
        }

        int IVsUIHierarchy.ParseCanonicalName(string pszName, out uint pitemid)
        {
            return ((IVsHierarchy)this).ParseCanonicalName(pszName, out pitemid);
        }

        int IVsUIHierarchy.QueryClose(out int pfCanClose)
        {
            return ((IVsHierarchy)this).QueryClose(out pfCanClose);
        }

        int IVsUIHierarchy.SetGuidProperty(uint itemid, int propid, ref Guid rguid)
        {
            return ((IVsHierarchy)this).SetGuidProperty(itemid, propid, ref rguid);
        }

        int IVsUIHierarchy.SetProperty(uint itemid, int propid, object var)
        {
            return ((IVsHierarchy)this).SetProperty(itemid, propid, var);
        }

        int IVsUIHierarchy.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider psp)
        {
            return ((IVsHierarchy)this).SetSite(psp);
        }

        int IVsUIHierarchy.UnadviseHierarchyEvents(uint dwCookie)
        {
            return ((IVsHierarchy)this).UnadviseHierarchyEvents(dwCookie);
        }

        int IVsUIHierarchy.Unused0()
        {
            return ((IVsHierarchy)this).Unused0();
        }

        int IVsUIHierarchy.Unused1()
        {
            return ((IVsHierarchy)this).Unused1();
        }

        int IVsUIHierarchy.Unused2()
        {
            return ((IVsHierarchy)this).Unused2();
        }

        int IVsUIHierarchy.Unused3()
        {
            return ((IVsHierarchy)this).Unused3();
        }

        int IVsUIHierarchy.Unused4()
        {
            return ((IVsHierarchy)this).Unused4();
        }

        #endregion


        #region IOleCommandTarget Members

        int IOleCommandTarget.Exec(ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            int hr = ((IOleCommandTarget)_menuService).Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
            return hr;
        }

        int IOleCommandTarget.QueryStatus(ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            int hr = ((IOleCommandTarget)_menuService).QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
            return hr;
        }

        #endregion

        #region IServiceProvider Members

        object System.IServiceProvider.GetService(Type serviceType)
        {
            if (serviceType.IsEquivalentTo(typeof(IOleCommandTarget)))
                return ((IOleCommandTarget)_menuService);
            else if (serviceType.IsEquivalentTo(typeof(System.ComponentModel.Design.IMenuCommandService)))
                return ((System.ComponentModel.Design.IMenuCommandService)_menuService);
            else 
                return this.serviceProvider.GetService(serviceType);

        }

        #endregion

        #region Events (subset of IVsTrackProjectDocumentsEvents)
        // This makes it easier for the derived class to subscribe to only the events it
        // is really interested in and get one event per file. This also filter events
        // and only send events that have to do with this project

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.EventHandler"]/*' />
        public delegate void EventHandler<ProjectDocumentsChangeEventArgs>(object sender, ProjectDocumentsChangeEventArgs e);

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileAdded"]/*' />
        /// <devdoc>
        /// Called after a file was added to this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileAdded;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileRemoved"]/*' />
        /// <devdoc>
        /// Called after a file was remove from this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileRemoved;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileRenamed"]/*' />
        /// <devdoc>
        /// Called after a file was renamed in this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileRenamed;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryAdded"]/*' />
        /// <devdoc>
        /// Called after a directory was added to this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryAdded;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryRemoved"]/*' />
        /// <devdoc>
        /// Called after a directory was remove from this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryRemoved;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryRenamed"]/*' />
        /// <devdoc>
        /// Called after a directory was renamed in this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryRenamed;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SccStatusChanged"]/*' />
        /// <devdoc>
        /// Called after the source code control status of a file in this project changed.
        /// </devdoc>
        // Below suppression cannot be added to the fxcop baseline file as the code analysis phase just ignores it.
        [SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="Scc", Justification="VSIP Shell MPF")]
        public event EventHandler<ProjectDocumentsChangeEventArgs> SccStatusChanged;
        #endregion

        #region IVsTrackProjectDocumentsEvents2 Members
        internal class DocumentsEventsSink : IVsTrackProjectDocumentsEvents2
        {
            private FlavoredProjectBase _flavoredProjectBase; 

            internal DocumentsEventsSink(FlavoredProjectBase flavoredProjectBase)
            {
                _flavoredProjectBase = flavoredProjectBase;
            }

            /// We subscribes to IVsTrackProjectDocumentsEvents and trigger the
            /// corresponding event once per file per event.
            /// We filters the events to only reports those related to our project.
            /// This is NOT required for flavoring, but simplify the work the
            /// derived classes have to do when subscribing to these events

            int IVsTrackProjectDocumentsEvents2.OnAfterAddDirectoriesEx(int cProjects, int cDirectories, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSADDDIRECTORYFLAGS[] rgFlags)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, _flavoredProjectBase.DirectoryAdded, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnAfterAddFilesEx(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSADDFILEFLAGS[] rgFlags)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, _flavoredProjectBase.FileAdded, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnAfterRemoveDirectories(int cProjects, int cDirectories, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSREMOVEDIRECTORYFLAGS[] rgFlags)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, _flavoredProjectBase.DirectoryRemoved, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnAfterRemoveFiles(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSREMOVEFILEFLAGS[] rgFlags)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, _flavoredProjectBase.FileRemoved, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnAfterRenameDirectories(int cProjects, int cDirs, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgszMkOldNames, string[] rgszMkNewNames, VSRENAMEDIRECTORYFLAGS[] rgFlags)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgszMkNewNames, _flavoredProjectBase.DirectoryRenamed, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnAfterRenameFiles(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgszMkOldNames, string[] rgszMkNewNames, VSRENAMEFILEFLAGS[] rgFlags)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgszMkNewNames, _flavoredProjectBase.FileRenamed, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnAfterSccStatusChanged(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, uint[] rgdwSccStatus)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, _flavoredProjectBase.SccStatusChanged, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnQueryAddDirectories(IVsProject pProject, int cDirectories, string[] rgpszMkDocuments, VSQUERYADDDIRECTORYFLAGS[] rgFlags, VSQUERYADDDIRECTORYRESULTS[] pSummaryResult, VSQUERYADDDIRECTORYRESULTS[] rgResults)
            {
                return VSConstants.S_OK; // We are not interested in this one
            }

            int IVsTrackProjectDocumentsEvents2.OnQueryAddFiles(IVsProject pProject, int cFiles, string[] rgpszMkDocuments, VSQUERYADDFILEFLAGS[] rgFlags, VSQUERYADDFILERESULTS[] pSummaryResult, VSQUERYADDFILERESULTS[] rgResults)
            {
                return VSConstants.S_OK; // We are not interested in this one
            }

            int IVsTrackProjectDocumentsEvents2.OnQueryRemoveDirectories(IVsProject pProject, int cDirectories, string[] rgpszMkDocuments, VSQUERYREMOVEDIRECTORYFLAGS[] rgFlags, VSQUERYREMOVEDIRECTORYRESULTS[] pSummaryResult, VSQUERYREMOVEDIRECTORYRESULTS[] rgResults)
            {
                return VSConstants.S_OK; // We are not interested in this one
            }

            int IVsTrackProjectDocumentsEvents2.OnQueryRemoveFiles(IVsProject pProject, int cFiles, string[] rgpszMkDocuments, VSQUERYREMOVEFILEFLAGS[] rgFlags, VSQUERYREMOVEFILERESULTS[] pSummaryResult, VSQUERYREMOVEFILERESULTS[] rgResults)
            {
                return VSConstants.S_OK; // We are not interested in this one
            }

            int IVsTrackProjectDocumentsEvents2.OnQueryRenameDirectories(IVsProject pProject, int cDirs, string[] rgszMkOldNames, string[] rgszMkNewNames, VSQUERYRENAMEDIRECTORYFLAGS[] rgFlags, VSQUERYRENAMEDIRECTORYRESULTS[] pSummaryResult, VSQUERYRENAMEDIRECTORYRESULTS[] rgResults)
            {
                return VSConstants.S_OK; // We are not interested in this one
            }

            int IVsTrackProjectDocumentsEvents2.OnQueryRenameFiles(IVsProject pProject, int cFiles, string[] rgszMkOldNames, string[] rgszMkNewNames, VSQUERYRENAMEFILEFLAGS[] rgFlags, VSQUERYRENAMEFILERESULTS[] pSummaryResult, VSQUERYRENAMEFILERESULTS[] rgResults)
            {
                return VSConstants.S_OK; // We are not interested in this one
            }
        }

        #endregion

        #region Helpers for IVsTrackProjectDocumentsEvents2

        /// <devdoc>
        /// Used to subscribe/unsubscribe to those events
        /// </devdoc>
        private IVsTrackProjectDocuments2 GetTrackProjectDocuments()
        {
            IVsTrackProjectDocuments2 trackDocuments = ((System.IServiceProvider)this).GetService(typeof(SVsTrackProjectDocuments)) as IVsTrackProjectDocuments2;
            Debug.Assert(trackDocuments != null, "Could not get the IVsTrackProjectDocuments2 object");
            if (trackDocuments == null)
            {
                throw new InvalidOperationException();
            }
            return trackDocuments;
        }

        /// <devdoc>
        /// Look at the list of projects and files and for each file that is part of this
        /// project, set the MkDocument on the event argument and trigger the event.
        /// </devdoc>
        private void GenerateEvents(
            IVsProject[] projects,
            int[] firstFiles,
            string[] mkDocuments,
            EventHandler<ProjectDocumentsChangeEventArgs> eventToGenerate,
            ProjectDocumentsChangeEventArgs e)
        {
            if (eventToGenerate == null)
                return; // no event = nothing to do

            if (projects == null || firstFiles == null || mkDocuments == null)
                throw new ArgumentNullException();
            if (projects.Length != firstFiles.Length)
                throw new ArgumentException();

            // First find out which range of the array (if any) include the files that belong to this project
            int first = -1;
            int last = mkDocuments.Length - 1; // default to the last document
            for (int i = 0; i < projects.Length; ++i)
            {
                if (first > -1)
                {
                    // We get here if there is 1 or more project(s) after ours in the list
                    last = firstFiles[i] - 1;
                    break;
                }
                if (IsThisProject(projects[i]))
                    first = firstFiles[i];
            }
            if (last >= mkDocuments.Length)
                throw new ArgumentException();
            // See if we have any documents
            if (first < 0)
                return; // Nothing that belongs to this project

            // For each file, generate the event
            for (int i = first; i <= last; ++i)
            {
                try
                {
                    e.MkDocument = mkDocuments[i];
                    eventToGenerate(this, e);
                }
                catch(Exception error)
                {
                    Debug.Fail(error.Message);
                }
            }
        }

        private bool IsThisProject(IVsProject prj)
        {
            bool areSame = false;
            Guid IID_IUnknown = VSConstants.IID_IUnknown;
            IntPtr otherPtr = IntPtr.Zero;
            IntPtr otherIUnk = IntPtr.Zero;
            IntPtr thisPtr = IntPtr.Zero;
            IntPtr thisIUnk = IntPtr.Zero;
            try
            {
                otherPtr = Marshal.GetIUnknownForObject(prj);
                Marshal.QueryInterface(otherPtr, ref IID_IUnknown, out otherIUnk);

                thisPtr = Marshal.GetIUnknownForObject(this);
                Marshal.QueryInterface(thisPtr, ref IID_IUnknown, out thisIUnk);
                areSame = (otherIUnk == thisIUnk);
            }
            finally
            {
                if (IntPtr.Zero != otherPtr)
                {
                    Marshal.Release(otherPtr);
                }
                if (IntPtr.Zero != otherIUnk)
                {
                    Marshal.Release(otherIUnk);
                }
                if (IntPtr.Zero != thisPtr)
                {
                    Marshal.Release(thisPtr);
                }
                if (IntPtr.Zero != thisIUnk)
                {
                    Marshal.Release(thisIUnk);
                }
            }
            return areSame;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\IConfigureToolboxItem.cs ===
//------------------------------------------------------------------------------
// <copyright file="IConfigureToolboxItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using System.Drawing.Design;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\IConfigureToolboxItem.uex' path='docs/doc[@for="IConfigureToolboxItem"]' />
    /// <devdoc>
    ///    This interface can be implemented on a creatable object.  The toolbox service will call
    ///    ConfigureToolboxItem on this interface when a new toolbox item is first added to the
    ///    toolbox.  This gives an external party a chance to add additional data to the toolbox item's
    ///    Properties dictionary.  This data then gets serialized as a permanent part of the toolbox item.
    /// 
    ///    Objects that implement this interface should be declared through a 
    ///    ProvideToolboxItemConfigurationAttribute attached to the package.  This attribute will register 
    ///    the object under the local CLSID hive in the VS registry and also add a reference to the GUID in
    ///    VSREGROOT\ToolboxItemConfiguration.  The data contained in this registry entry
    ///    is as follows:
    /// 
    ///    VSREGROOT\ToolboxItemConfiguration
    ///        AssemblyName
    ///             ConfigurationTypeName={guid}
    /// 
    ///    As an example:
    /// 
    ///    VSREGROOT\ToolboxItemConfiguration
    ///        System, Version=2.0.3500
    ///            CompactFrameworkProvider = {GUID}
    /// 
    /// 
    ///    The assembly name is parsed and the various keys are matched.  Keys can have a
    ///    "*" in them to be taken as wildcards.  So, for example, to cover all versions
    ///    of System.WindowsForms you would specify:
    /// 
    ///    System.Windows.Forms, Version=*, PublicKeyToken=969...
    /// 
    ///    The assembly name may also be a wildcard to load the configuration object
    ///    for all toolbox items (not recommended).
    /// </devdoc>
    public interface IConfigureToolboxItem {

        /// <include file='doc\IConfigureToolboxItem.uex' path='docs/doc[@for="IConfigureToolboxItem.ConfigureToolboxItem"]' />
        /// <devdoc>
        ///     Adds extra configuration information to thish toolbox item.
        /// </devdoc>
        void ConfigureToolboxItem(ToolboxItem item);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\EventSinkCollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="LogicalView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Collections;
    using System.Diagnostics;

    /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection"]/*' />
    /// <summary>
    /// Maps objects to and from integer "cookies".  This helps in the implementation
    /// of VS interfaces that have Advise/Unadvise methods, for example, IVsHierarchy,
    /// IVsCfgProvider2, IVsBuildableProjectCfg and so on.
    /// </summary>
    [CLSCompliant(false)]
    public class EventSinkCollection : IEnumerable {
        ArrayList map;

        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.EventSinkCollection"]/*' />
        public EventSinkCollection() {
        }

        ArrayList GetMap() {
            if (this.map == null) this.map = new ArrayList();
            return this.map;
        }

        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.Count"]/*' />
        /// <devdov>
        /// Returns the total number of sinks in the collection.  Some of these might be null though.
        /// </devdov>
        public int Count {
            get { return (this.map == null) ? 0 : this.map.Count; }
        }

        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.Add"]/*' />
        /// <devdov>
        /// Add an event sink and return it's cookie which can be used in the RemoveAt method.
        /// </devdov>
        public uint Add(Object o) {
            if (o == null)
                throw new ArgumentNullException("o");

            // re-use empty slots so the ArrayList doesn't grow infinitely.
            for (int i = 0, n = this.GetMap().Count; i < n; i++) {
                if (map[i] == null) {
                    map[i] = o;
                    return (uint)i+1; // cookie must be one based else VS doesn't call Unadvise
                }
            }
            this.map.Add(o);
            return (uint)this.map.Count;
        }
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.Remove"]/*' />
        /// <devdov>
        /// Remove the specified event sink from the collection
        /// </devdov>
        public void Remove(Object obj) {
            if (obj == null)
                throw new ArgumentNullException("obj");

            if (this.map != null)
            {
                for (int i = 0, n = map.Count; i < n; i++)
                {
                    if (this.map[i] == obj)
                    {
                        this.map[i] = null; // these gap will be reused.
                        if (i == n - 1)
                        {
                            // compact the array list whenever possible.
                            while (i > 0 && this.map[i - 1] == null)
                            {
                                i--;
                            }
                            this.map.RemoveRange(i, n - i);
                        }
                        return;
                    }
                }
            }
            throw new ArgumentOutOfRangeException("obj");
        }
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.RemoveAt"]/*' />
        /// <devdov>
        /// Remove the specified event sink by the cookie integer returned from the Add method.
        /// </devdov>
        public void RemoveAt(uint cookie) {
            if (this.map != null){
                this.map[(int)cookie - 1] = null;  // cookie is 1-based
            }
        }
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.SetAt"]/*' />
        /// <devdov>
        /// Update the event sink associated with the given cookie.
        /// </devdov>
        public void SetAt(uint cookie, object value) {
            this.GetMap()[(int)cookie - 1] = value;
        }
        
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.this"]/*' />
        /// <devdov>
        /// Indexor access to the event sink.  Cookie is 1-based.
        /// </devdov>
        public object this[uint cookie] {
            get {
                return (this.map != null && cookie > 0 && cookie <= this.map.Count) ? this.map[(int)cookie-1] : null;
            }
            set {
                this.GetMap()[(int)cookie-1] = value;
            }
        }
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.Clear"]/*' />
        /// <devdov>
        /// Remove all event sinks.
        /// </devdov>
        public void Clear() {
            if (this.map != null) this.map.Clear();
        }

        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return new EventSinkEnumerator(map);
        }
        internal class EventSinkEnumerator : IEnumerator {
            ArrayList map;            
            int pos;

            public EventSinkEnumerator(ArrayList map) {
                this.map = map; 
                this.pos = -1;
            }
            object IEnumerator.Current {
                get { return (this.map != null && this.pos >= 0 && this.pos < this.map.Count) ? this.map[this.pos] : null; }
            }
            bool IEnumerator.MoveNext() {
                if (this.map == null) return false;
                int n = this.map.Count;
                if (this.pos < n) {
                    this.pos++;
                    while (this.pos < n && this.map[this.pos] == null) // skip nulls
                        this.pos++;

                    if (this.pos < n) {
                        return true;
                    }
                    return false;
                }
                return false;
            }
            void IEnumerator.Reset() {
                this.pos = -1;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Flavor\Project.cs ===
/***************************************************************************
         Copyright (c) Microsoft Corporation, All rights reserved.             
    This code sample is provided "AS IS" without warranty of any kind, 
    it is not recommended for use in a production environment.
***************************************************************************/

namespace Microsoft.VisualStudio.Shell.Flavor
{
    using System;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell;

    /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject"]/*' />
    /// <devdoc>
    /// A project that is a subtype/flavor of an inner project.
    /// The default behavior of all methods is to delegate to the
    /// inner project. For any behavior you want to change, simply
    /// handle the request yourself.
    /// </devdoc>
    [CLSCompliant(false)]
    public abstract class FlavoredProject : 
        Microsoft.VisualStudio.ProjectAggregator.CProjectAggregatorClass, // Provide aggregation support
        IVsAggregatableProject,
        System.IServiceProvider,
        IVsHierarchy,
        IVsUIHierarchy,
        IOleCommandTarget,
        IVsTrackProjectDocumentsEvents2
    {
        // Keep interface reference for all interface we override

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.innerVsAggregatableProject"]/*' />
        protected IVsAggregatableProject innerVsAggregatableProject;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.innerVsHierarchy"]/*' />
        protected IVsHierarchy innerVsHierarchy;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.innerVsUIHierarchy"]/*' />
        protected IVsUIHierarchy innerVsUIHierarchy;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.innerOleCommandTarget"]/*' />
        protected IOleCommandTarget innerOleCommandTarget;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.serviceProvider"]/*' />
        protected System.IServiceProvider serviceProvider;

        private OleMenuCommandService menuService;

        uint cookie = 0;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FlavoredProject"]/*' />
        public FlavoredProject()
        {
        }

        #region IVsAggregatableProject

        /// <devdoc>
        /// This is were all QI for interface on the inner object should happen
        /// Then set the inner project
        /// wait for InitializeForOuter to be called to do the real initialization
        /// </devdoc>
        int IVsAggregatableProject.SetInnerProject(object inner)
        {
            // delegate to the protected method
            this.SetInnerProject(inner);

            return NativeMethods.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetInnerProject"]/*' />
        /// <devdoc>
        /// This is were all QI for interface on the inner object should happen
        /// Then set the inner project
        /// wait for InitializeForOuter to be called to do the real initialization
        /// </devdoc>
        protected virtual void SetInnerProject(object inner)
        {
            // Keep a reference to each interface we want to call on the inner project
            // we must do it now as once we call SetInner the AddRef would be forwarded to ourselves
            innerVsAggregatableProject = (IVsAggregatableProject)inner;
            innerVsHierarchy = (IVsHierarchy)inner;
            innerVsUIHierarchy = (IVsUIHierarchy)inner;
            // As should return null without throwing in the event the base project does not implement the interface
            innerOleCommandTarget = inner as IOleCommandTarget;

            // Setup our menu command service
            if (this.serviceProvider == null)
                throw new NotSupportedException("serviceProvider should have been set before SetInnerProject gets called.");
            menuService = new OleMenuCommandService(this, innerOleCommandTarget);

            // Aggregate the project
            this.SetInner(inner);
        }

        /// <devdoc>
        /// Do the initialization here (such as loading flavor specific
        /// information from the project)
        /// </devdoc>
        int IVsAggregatableProject.InitializeForOuter(string fileName, string location, string name,
            uint flags, ref Guid guidProject, out IntPtr project, out int canceled)
        {
            if (innerVsAggregatableProject == null || guidProject != NativeMethods.IID_IUnknown)
                throw new NotSupportedException();

            Marshal.QueryInterface(Marshal.GetIUnknownForObject(this), ref guidProject, out project);

            canceled = 0;
            bool cancel;
            this.InitializeForOuter(fileName, location, name, flags, ref guidProject, out cancel);
            if (cancel)
                canceled = 1;

            return NativeMethods.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.InitializeForOuter"]/*' />
        /// <devdoc>
        /// Allow the project to initialize itself.
        /// At this point it possible to call the inner project
        /// Also allow canceling the project creation
        /// </devdoc>
        /// <returns>Return true to cancel the project creation</returns>
        protected virtual void InitializeForOuter(string fileName, string location, string name, uint flags, ref Guid guidProject, out bool cancel)
        {
            cancel = false;
        }
        /// <devdoc>
        /// This is called when all object in aggregation have received InitializeForOuter calls.
        /// At this point the aggregation is complete and fully functional.
        /// </devdoc>
        int IVsAggregatableProject.OnAggregationComplete()
        {
            this.OnAggregationComplete();
            if (innerVsAggregatableProject != null)
                return innerVsAggregatableProject.OnAggregationComplete();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.OnAggregationComplete"]/*' />
        /// <devdoc>
        /// This is called when all object in aggregation have received InitializeForOuter calls.
        /// At this point the aggregation is complete and fully functional.
        /// </devdoc>
        protected virtual void OnAggregationComplete()
        {
            // This will subscribe to the IVsTrackProjectDocumentsEvents.
            // This is not required to flavor a project but makes it easier for derived class
            // to subscribe to these events.
            IVsTrackProjectDocuments2 trackDocuments = GetTrackProjectDocuments();
            ErrorHandler.ThrowOnFailure(trackDocuments.AdviseTrackProjectDocumentsEvents(this, out cookie));
        }

        /// <devdoc>
        /// This must be delegetated to the inner most project
        /// </devdoc>
        int IVsAggregatableProject.SetAggregateProjectTypeGuids(string projectTypeGuids)
        {
            if (innerVsAggregatableProject == null)
                throw new NotSupportedException();

            return innerVsAggregatableProject.SetAggregateProjectTypeGuids(projectTypeGuids);
        }

        /// <devdoc>
        /// This must be delegetated to the inner most project
        /// </devdoc>
        int IVsAggregatableProject.GetAggregateProjectTypeGuids(out string projectTypeGuids)
        {
            if (innerVsAggregatableProject == null)
                throw new NotSupportedException();

            return innerVsAggregatableProject.GetAggregateProjectTypeGuids(out projectTypeGuids);
        }

        #endregion

        #region IVsHierarchy
        //
        // Most methods call protected virtual methods which delegate to the inner project.
        // Derived classes should override those protected method if they want to change the
        // behavior.
        //

        int IVsHierarchy.AdviseHierarchyEvents(Microsoft.VisualStudio.Shell.Interop.IVsHierarchyEvents eventSink, out uint cookie)
        {
            cookie = this.AdviseHierarchyEvents(eventSink);
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Close()
        {
            if (cookie != 0)
            {
                // Unsubscribe to events
                IVsTrackProjectDocuments2 trackDocuments = GetTrackProjectDocuments();
                trackDocuments.UnadviseTrackProjectDocumentsEvents(cookie);
                cookie = 0;
            }
            this.Close();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.GetCanonicalName(uint itemId, out string name)
        {
            return this.GetCanonicalName(itemId, out name);
        }

        int IVsHierarchy.GetGuidProperty(uint itemId, int propId, out System.Guid guid)
        {
            guid = this.GetGuidProperty(itemId, propId);
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.GetNestedHierarchy(uint itemId, ref System.Guid guidHierarchyNested, out System.IntPtr hierarchyNested, out uint itemIdNested)
        {
            return this.GetNestedHierarchy(itemId, ref guidHierarchyNested, out hierarchyNested, out itemIdNested);
        }

        int IVsHierarchy.GetProperty(uint itemId, int propId, out System.Object property)
        {
            // While other methods expect the protected method to throw, for GetProperty
            // we break this pattern as it is called much more often and it is legitimate to
            // return not implemented. Therefore it can help perf and debugging experience
            return this.GetProperty(itemId, propId, out property);
        }

        int IVsHierarchy.GetSite(out Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider)
        {
            serviceProvider = this.GetSite();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.ParseCanonicalName(string name, out uint itemId)
        {
            return this.ParseCanonicalName(name, out itemId);
        }

        int IVsHierarchy.QueryClose(out int canClose)
        {
            canClose = 0;
            if (this.QueryClose())
                canClose = 1;
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.SetGuidProperty(uint itemId, int propId, ref System.Guid guid)
        {
            this.SetGuidProperty(itemId, propId, ref guid);
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider)
        {
            this.serviceProvider = (System.IServiceProvider)new ServiceProvider(serviceProvider);
            NativeMethods.ThrowOnFailure(innerVsHierarchy.SetSite(serviceProvider));
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.UnadviseHierarchyEvents(uint cookie)
        {
            this.UnadviseHierarchyEvents(cookie);
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.SetProperty(uint itemId, int propId, System.Object property)
        {
            return this.SetProperty(itemId, propId, property);
        }

        int IVsHierarchy.Unused0()
        {
            this.Unused0();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Unused1()
        {
            this.Unused1();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Unused2()
        {
            this.Unused2();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Unused3()
        {
            this.Unused3();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Unused4()
        {
            this.Unused4();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.AdviseHierarchyEvents"]/*' />
        protected virtual uint AdviseHierarchyEvents(Microsoft.VisualStudio.Shell.Interop.IVsHierarchyEvents eventSink)
        {
            uint cookie=0;
            NativeMethods.ThrowOnFailure(innerVsHierarchy.AdviseHierarchyEvents(eventSink, out cookie));
            return cookie;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Close"]/*' />
        protected virtual void Close()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Close());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetCanonicalName"]/*' />
        protected virtual int GetCanonicalName(uint itemId, out string name)
        {
            return innerVsHierarchy.GetCanonicalName(itemId, out name);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetGuidProperty"]/*' />
        protected virtual Guid GetGuidProperty(uint itemId, int propId)
        {
            Guid property;
            NativeMethods.ThrowOnFailure(innerVsHierarchy.GetGuidProperty(itemId, propId, out property));
            return property;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetNestedHierarchy"]/*' />
        protected virtual int GetNestedHierarchy(uint itemId, ref System.Guid guidHierarchyNested, out System.IntPtr hierarchyNested, out uint itemIdNested)
        {
            return innerVsHierarchy.GetNestedHierarchy(itemId, ref guidHierarchyNested, out hierarchyNested, out itemIdNested);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetProperty"]/*' />
        protected virtual int GetProperty(uint itemId, int propId, out Object property)
        {
            return innerVsHierarchy.GetProperty(itemId, propId, out property);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetSite"]/*' />
        protected virtual Microsoft.VisualStudio.OLE.Interop.IServiceProvider GetSite()
        {
            Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider;
            NativeMethods.ThrowOnFailure(innerVsHierarchy.GetSite(out serviceProvider));
            return serviceProvider;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.ParseCanonicalName"]/*' />
        protected virtual int ParseCanonicalName(string name, out uint itemId)
        {
            return innerVsHierarchy.ParseCanonicalName(name, out itemId);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.QueryClose"]/*' />
        protected virtual bool QueryClose()
        {
            int canClose;
            NativeMethods.ThrowOnFailure(innerVsHierarchy.QueryClose(out canClose));
            return (canClose != 0);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetGuidProperty"]/*' />
        protected virtual void SetGuidProperty(uint itemId, int propId, ref System.Guid guid)
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.SetGuidProperty(itemId, propId, ref guid));
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.UnadviseHierarchyEvents"]/*' />
        protected virtual void UnadviseHierarchyEvents(uint cookie)
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.UnadviseHierarchyEvents(cookie));
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetProperty"]/*' />
        protected virtual int SetProperty(uint itemId, int propId, System.Object property)
        {
            return innerVsHierarchy.SetProperty(itemId, propId, property);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused0"]/*' />
        protected virtual void Unused0()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused0());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused1"]/*' />
        protected virtual void Unused1()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused1());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused2"]/*' />
        protected virtual void Unused2()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused2());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused3"]/*' />
        protected virtual void Unused3()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused3());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused4"]/*' />
        protected virtual void Unused4()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused4());
        }
        #endregion

        #region IVsUIHierarchy Members
        //
        // All methods (except for QueryStatusCommand and ExecCommand) call the IVsHierarchy implementation.
        // QueryStatusCommand and ExecCommand call a protected virtual method that the base class can override.
        // Note that we QI for IVsUIHierarchy on this so that if we are flavored we call the outer IVsHierarchy.
        //

        int IVsUIHierarchy.QueryStatusCommand(uint itemid, ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            return this.QueryStatusCommand(itemid, ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.QueryStatusCommand"]/*' />
        protected virtual int QueryStatusCommand(uint itemid, ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            return innerVsUIHierarchy.QueryStatusCommand(itemid, ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }

        int IVsUIHierarchy.ExecCommand(uint itemid, ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            return this.ExecCommand(itemid, ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
        }
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.ExecCommand"]/*' />
        protected virtual int ExecCommand(uint itemid, ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            return innerVsUIHierarchy.ExecCommand(itemid, ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
        }



        int IVsUIHierarchy.AdviseHierarchyEvents(IVsHierarchyEvents pEventSink, out uint pdwCookie)
        {
            return ((IVsHierarchy)this).AdviseHierarchyEvents(pEventSink, out pdwCookie);
        }

        int IVsUIHierarchy.Close()
        {
            return ((IVsHierarchy)this).Close();
        }

        int IVsUIHierarchy.GetCanonicalName(uint itemid, out string pbstrName)
        {
            return ((IVsHierarchy)this).GetCanonicalName(itemid, out pbstrName);
        }

        int IVsUIHierarchy.GetGuidProperty(uint itemid, int propid, out Guid pguid)
        {
            return ((IVsHierarchy)this).GetGuidProperty(itemid, propid, out pguid);
        }

        int IVsUIHierarchy.GetNestedHierarchy(uint itemid, ref Guid iidHierarchyNested, out IntPtr ppHierarchyNested, out uint pitemidNested)
        {
            return ((IVsHierarchy)this).GetNestedHierarchy(itemid, ref iidHierarchyNested, out ppHierarchyNested, out pitemidNested);
        }

        int IVsUIHierarchy.GetProperty(uint itemid, int propid, out object pvar)
        {
            return ((IVsHierarchy)this).GetProperty(itemid, propid, out pvar);
        }

        int IVsUIHierarchy.GetSite(out Microsoft.VisualStudio.OLE.Interop.IServiceProvider ppSP)
        {
            return ((IVsHierarchy)this).GetSite(out ppSP);
        }

        int IVsUIHierarchy.ParseCanonicalName(string pszName, out uint pitemid)
        {
            return ((IVsHierarchy)this).ParseCanonicalName(pszName, out pitemid);
        }

        int IVsUIHierarchy.QueryClose(out int pfCanClose)
        {
            return ((IVsHierarchy)this).QueryClose(out pfCanClose);
        }

        int IVsUIHierarchy.SetGuidProperty(uint itemid, int propid, ref Guid rguid)
        {
            return ((IVsHierarchy)this).SetGuidProperty(itemid, propid, ref rguid);
        }

        int IVsUIHierarchy.SetProperty(uint itemid, int propid, object var)
        {
            return ((IVsHierarchy)this).SetProperty(itemid, propid, var);
        }

        int IVsUIHierarchy.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider psp)
        {
            return ((IVsHierarchy)this).SetSite(psp);
        }

        int IVsUIHierarchy.UnadviseHierarchyEvents(uint dwCookie)
        {
            return ((IVsHierarchy)this).UnadviseHierarchyEvents(dwCookie);
        }

        int IVsUIHierarchy.Unused0()
        {
            return ((IVsHierarchy)this).Unused0();
        }

        int IVsUIHierarchy.Unused1()
        {
            return ((IVsHierarchy)this).Unused1();
        }

        int IVsUIHierarchy.Unused2()
        {
            return ((IVsHierarchy)this).Unused2();
        }

        int IVsUIHierarchy.Unused3()
        {
            return ((IVsHierarchy)this).Unused3();
        }

        int IVsUIHierarchy.Unused4()
        {
            return ((IVsHierarchy)this).Unused4();
        }

        #endregion


        #region IOleCommandTarget Members

        int IOleCommandTarget.Exec(ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            int hr = ((IOleCommandTarget)menuService).Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
            return hr;
        }

        int IOleCommandTarget.QueryStatus(ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            int hr = ((IOleCommandTarget)menuService).QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
            return hr;
        }

        #endregion

        #region IServiceProvider Members

        object System.IServiceProvider.GetService(Type serviceType)
        {
            if (serviceType.IsEquivalentTo(typeof(IOleCommandTarget)))
                return ((IOleCommandTarget)menuService);
            else if (serviceType.IsEquivalentTo(typeof(System.ComponentModel.Design.IMenuCommandService)))
                return ((System.ComponentModel.Design.IMenuCommandService)menuService);
            else 
                return this.serviceProvider.GetService(serviceType);

        }

        #endregion

        #region Events (subset of IVsTrackProjectDocumentsEvents)
        // This makes it easier for the derived class to subscribe to only the events it
        // is really interested in and get one event per file. This also filter events
        // and only send events that have to do with this project

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.EventHandler"]/*' />
        public delegate void EventHandler<ProjectDocumentsChangeEventArgs>(object sender, ProjectDocumentsChangeEventArgs e);

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileAdded"]/*' />
        /// <devdoc>
        /// Called after a file was added to this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileAdded;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileRemoved"]/*' />
        /// <devdoc>
        /// Called after a file was remove from this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileRemoved;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileRenamed"]/*' />
        /// <devdoc>
        /// Called after a file was renamed in this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileRenamed;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryAdded"]/*' />
        /// <devdoc>
        /// Called after a directory was added to this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryAdded;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryRemoved"]/*' />
        /// <devdoc>
        /// Called after a directory was remove from this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryRemoved;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryRenamed"]/*' />
        /// <devdoc>
        /// Called after a directory was renamed in this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryRenamed;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SccStatusChanged"]/*' />
        /// <devdoc>
        /// Called after the source code control status of a file in this project changed.
        /// </devdoc>
        // Below suppression cannot be added to the fxcop baseline file as the code analysis phase just ignores it.
        [SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="Scc", Justification="VSIP Shell MPF")]
        public event EventHandler<ProjectDocumentsChangeEventArgs> SccStatusChanged;
        #endregion

        #region IVsTrackProjectDocumentsEvents2 Members
        /// We subscribes to IVsTrackProjectDocumentsEvents and trigger the
        /// corresponding event once per file per event.
        /// We filters the events to only reports those related to our project.
        /// This is NOT required for flavoring, but simplify the work the
        /// derived classes have to do when subscribing to these events

        int IVsTrackProjectDocumentsEvents2.OnAfterAddDirectoriesEx(int cProjects, int cDirectories, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSADDDIRECTORYFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, DirectoryAdded, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterAddFilesEx(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSADDFILEFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, FileAdded, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterRemoveDirectories(int cProjects, int cDirectories, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSREMOVEDIRECTORYFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, DirectoryRemoved, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterRemoveFiles(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSREMOVEFILEFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, FileRemoved, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterRenameDirectories(int cProjects, int cDirs, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgszMkOldNames, string[] rgszMkNewNames, VSRENAMEDIRECTORYFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgszMkNewNames, DirectoryRenamed, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterRenameFiles(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgszMkOldNames, string[] rgszMkNewNames, VSRENAMEFILEFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgszMkNewNames, FileRenamed, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterSccStatusChanged(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, uint[] rgdwSccStatus)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, SccStatusChanged, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryAddDirectories(IVsProject pProject, int cDirectories, string[] rgpszMkDocuments, VSQUERYADDDIRECTORYFLAGS[] rgFlags, VSQUERYADDDIRECTORYRESULTS[] pSummaryResult, VSQUERYADDDIRECTORYRESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryAddFiles(IVsProject pProject, int cFiles, string[] rgpszMkDocuments, VSQUERYADDFILEFLAGS[] rgFlags, VSQUERYADDFILERESULTS[] pSummaryResult, VSQUERYADDFILERESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryRemoveDirectories(IVsProject pProject, int cDirectories, string[] rgpszMkDocuments, VSQUERYREMOVEDIRECTORYFLAGS[] rgFlags, VSQUERYREMOVEDIRECTORYRESULTS[] pSummaryResult, VSQUERYREMOVEDIRECTORYRESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryRemoveFiles(IVsProject pProject, int cFiles, string[] rgpszMkDocuments, VSQUERYREMOVEFILEFLAGS[] rgFlags, VSQUERYREMOVEFILERESULTS[] pSummaryResult, VSQUERYREMOVEFILERESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryRenameDirectories(IVsProject pProject, int cDirs, string[] rgszMkOldNames, string[] rgszMkNewNames, VSQUERYRENAMEDIRECTORYFLAGS[] rgFlags, VSQUERYRENAMEDIRECTORYRESULTS[] pSummaryResult, VSQUERYRENAMEDIRECTORYRESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryRenameFiles(IVsProject pProject, int cFiles, string[] rgszMkOldNames, string[] rgszMkNewNames, VSQUERYRENAMEFILEFLAGS[] rgFlags, VSQUERYRENAMEFILERESULTS[] pSummaryResult, VSQUERYRENAMEFILERESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        #endregion

        #region Helpers for IVsTrackProjectDocumentsEvents2

        /// <devdoc>
        /// Used to subscribe/unsubscribe to those events
        /// </devdoc>
        private IVsTrackProjectDocuments2 GetTrackProjectDocuments()
        {
            IVsTrackProjectDocuments2 trackDocuments = ((System.IServiceProvider)this).GetService(typeof(SVsTrackProjectDocuments)) as IVsTrackProjectDocuments2;
            if (trackDocuments == null)
            {
                throw new ApplicationException(string.Format(Resources.Culture, Resources.Flavor_FailedToGetService, "SVsTrackProjectDocuments"));
            }
            return trackDocuments;
        }

        /// <devdoc>
        /// Look at the list of projects and files and for each file that is part of this
        /// project, set the MkDocument on the event argument and trigger the event.
        /// </devdoc>
        private void GenerateEvents(
            IVsProject[] projects,
            int[] firstFiles,
            string[] mkDocuments,
            EventHandler<ProjectDocumentsChangeEventArgs> eventToGenerate,
            ProjectDocumentsChangeEventArgs e)
        {
            if (eventToGenerate == null)
                return; // no event = nothing to do

            if (projects == null || firstFiles == null || mkDocuments == null)
                throw new ArgumentNullException();
            if (projects.Length != firstFiles.Length)
                throw new ArgumentException();

            // First find out which range of the array (if any) include the files that belong to this project
            int first = -1;
            int last = mkDocuments.Length - 1; // default to the last document
            for (int i = 0; i < projects.Length; ++i)
            {
                if (first > -1)
                {
                    // We get here if there is 1 or more project(s) after ours in the list
                    last = firstFiles[i] - 1;
                    break;
                }
                if (Object.ReferenceEquals(projects[i], this))
                    first = firstFiles[i];
            }
            if (last >= mkDocuments.Length)
                throw new ArgumentException();
            // See if we have any documents
            if (first < 0)
                return; // Nothing that belongs to this project

            // For each file, generate the event
            for (int i = first; i <= last; ++i)
            {
                try
                {
                    e.MkDocument = mkDocuments[i];
                    eventToGenerate(this, e);
                }
                catch(Exception error)
                {
                    Debug.Fail(error.Message);
                }
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\IProfileManager.cs ===
//------------------------------------------------------------------------------
// <copyright file="IProfileManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\IProfileManager.uex' path='docs/doc[@for="IProfileManager"]' />
    /// <devdoc>
    /// Interface used to provide import/export capabilities of properties
    /// usually stored in the registry.
    /// </devdoc>
    [CLSCompliant(false)]
    public interface IProfileManager {
        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.SaveSettingsToXml]/*' />
        /// <devdoc>
        /// Summary of SaveSettingsToXml.
        /// </devdoc>
        /// <param name='writer'></param>
        void SaveSettingsToXml(IVsSettingsWriter writer);

        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.LoadSettingsFromXml]/*' />
        /// <devdoc>
        /// Summary of LoadSettingsFromXml.
        /// </devdoc>
        /// <param name='reader'></param>
        void LoadSettingsFromXml(IVsSettingsReader reader);

        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.SaveSettingsToStorage]/*' />
        /// <devdoc>
        /// Summary of SaveSettingsToStorage.
        /// </devdoc>
        void SaveSettingsToStorage();

        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.LoadSettingsFromStorage]/*' />
        /// <devdoc>
        /// Summary of LoadSettingsFromStorage.
        /// </devdoc>
        void LoadSettingsFromStorage();

        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.ResetSettings]/*' />
        /// <devdoc>
        /// Reset your settings (__UserSettingsFlags.USF_ResetOnImport was set).
        /// </devdoc>
        void ResetSettings();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Private\PackageRegistrationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="PackageRegistrationAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;
    using System.IO;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <devdoc>
    ///     This attribute is defined on a package to get it to be registered.  It
    ///     is internal because packages are meant to be registered, so it is
    ///     implicit just by having a package in the assembly.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited=true, AllowMultiple=false)]
    public sealed class PackageRegistrationAttribute : RegistrationAttribute
    {
        private RegistrationMethod registrationMethod = RegistrationMethod.Default;
        private bool useManagedResources = false;
        private string satellitePath = null;
        
        /// <devdoc>
        ///     Select between specifying the Codebase entry or the Assembly entry in the registry.
        ///     This can be overriden during registration
        /// </devdoc>
        public RegistrationMethod RegisterUsing
        {
            get
            {
                return registrationMethod;
            }
            set
            {
                registrationMethod = value;
            }
        }

        /// <summary>
        /// For managed resources, there should not be a native ui dll registered.
        /// </summary>
        public bool UseManagedResourcesOnly
        {
            get { return useManagedResources; }
            set { useManagedResources = value; }
        }

        /// <summary>
        /// To specify a resource dll located in a different location then the default,
        /// set this property. This can be useful if your package is installed in the GAC.
        /// If this is not set, the directory where the package is located will be use.
        /// 
        /// Note that the dll should be located at the following path:
        ///        SatellitePath\lcid\PackageDllNameUI.dll
        /// </summary>
        public string SatellitePath
        {
            get { return satellitePath; }
            set { satellitePath = value; }
        }

        private string RegKeyName(RegistrationContext context)
        {
            return String.Format(CultureInfo.InvariantCulture, "Packages\\{0}", context.ComponentType.GUID.ToString("B"));
        }

        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        /// <param name="context">
        ///     Contains the location where the registration inforomation should be placed.
        ///     It also contains other information such as the type being registered 
        ///     and path of the assembly.
        /// </param>
        public override void Register(RegistrationContext context) {
            Type t = context.ComponentType;
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyPackage, t.Name, t.GUID.ToString("B")));

            Key packageKey = null;
            try
            {
                packageKey = context.CreateKey(RegKeyName(context));

                //use a friendly description if it exists.
                DescriptionAttribute attr = TypeDescriptor.GetAttributes(t)[typeof(DescriptionAttribute)] as DescriptionAttribute;
                if (attr != null && !String.IsNullOrEmpty(attr.Description)) {
                    packageKey.SetValue(string.Empty, attr.Description);
                }
                else {
                    packageKey.SetValue(string.Empty, t.AssemblyQualifiedName);
                }

                packageKey.SetValue("InprocServer32", context.InprocServerPath);
                packageKey.SetValue("Class", t.FullName);

                // If specified on the command line, let the command line option override
                if (context.RegistrationMethod != RegistrationMethod.Default)
                {
                    registrationMethod = context.RegistrationMethod;
                }

                // Select registration method
                switch (registrationMethod)
                {
                    case RegistrationMethod.Assembly:
                    case RegistrationMethod.Default:
                        packageKey.SetValue("Assembly", t.Assembly.FullName);
                        break;

                    case RegistrationMethod.CodeBase:
                        packageKey.SetValue("CodeBase", context.CodeBase);
                        break;
                }

                Key childKey = null;
                if (!useManagedResources)
                {
                    try
                    {
                        childKey = packageKey.CreateSubkey("SatelliteDll");

                        // Register the satellite dll
                        string satelliteDllPath;
                        if (SatellitePath != null)
                        {
                            // Use provided path
                            satelliteDllPath = context.EscapePath(SatellitePath);
                        }
                        else
                        {
                            // Default to package path
                            satelliteDllPath = context.ComponentPath;
                        }
                        childKey.SetValue("Path", satelliteDllPath);
                        childKey.SetValue("DllName", String.Format(CultureInfo.InvariantCulture, "{0}UI.dll", Path.GetFileNameWithoutExtension(t.Assembly.ManifestModule.Name)));
                    }
                    finally
                    {
                        if (childKey != null)
                            childKey.Close();
                    }
                }
            }
            finally
            {
                if (packageKey != null)
                    packageKey.Close();
            }
        }

        /// <devdoc>
        ///     Unregister this package.
        /// </devdoc>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context) 
        {
            context.RemoveKey(RegKeyName(context));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\IProfileMigrator.cs ===
//------------------------------------------------------------------------------
// <copyright file="IProfileMigrator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\IProfileMigrator.uex' path='docs/doc[@for="IProfileMigrator"]' />
    /// <devdoc>
    /// Interface used to support custom migration of user settings from one version of the
    /// product to another.
    /// </devdoc>
    [CLSCompliant(false)]
    public interface IProfileMigrator {
        /// <include file='doc\IProfileMigrator.uex' path='docs/doc[@for=IProfileMigrator.MigrateSettings]/*' />
        /// <devdoc>
        /// Summary of MigrateSettings.
        /// </devdoc>
        /// <param name='reader'></param>
        /// <param name='writer'></param>
        void MigrateSettings(IVsSettingsReader reader, IVsSettingsWriter writer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\IResxResourceService.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResourcePicker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Security.Permissions;
    using Microsoft.Win32;
    using System.Collections;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;
    using System.Resources;
    using System.Resources.Tools;
    using System.Globalization;


    /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="IResXResourceService"]/*' />
    /// <devdoc>
    ///    <para>
    ///         This interface is an abstraction layer that allows various clients to control resxreaders and writers
    ///         that get used within Visual Studio.
    ///    </para>
    /// </devdoc>
    public interface IResXResourceService {

        /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="GetResXResourceReader"]/*' />
        /// <devdoc>
        ///    <para>
        ///         Returns a resx resource reader given a basepath and name
        ///    </para>
        /// </devdoc>
        IResourceReader GetResXResourceReader(string resXFullName, bool useResXDataNodes);

        /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="GetResXResourceReader"]/*' />
        /// <devdoc>
        ///    <para>
        ///         Returns a resx resource reader given a basepath and name
        ///    </para>
        /// </devdoc>
        IResourceReader GetResXResourceReader(TextReader textReader, bool useResXDataNodes, string basePath);

        /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="GetResXResourceWriter"]/*' />
        /// <devdoc>
        ///    <para>
        ///         Returns a resx resource writer given a basepath and name
        ///    </para>
        /// </devdoc>
        IResourceWriter GetResXResourceWriter(string resXFullName);

        /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="GetResXResourceWriter"]/*' />
        /// <devdoc>
        ///    <para>
        ///         Returns a resx resource writer given a basepath and name
        ///    </para>
        /// </devdoc>
        IResourceWriter GetResXResourceWriter(TextWriter textWriter, string basePath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\LocalizableProperties.cs ===
//--------------------------------------------------------------------------
//  <copyright file="LocalizableProperties.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Xml;
using System.Diagnostics;

namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties]/*' />
    [ComVisible(true)]
    public class LocalizableProperties : ICustomTypeDescriptor
	{
        #region ICustomTypeDescriptor
        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetAttributes]/*' />
        public AttributeCollection GetAttributes() 
		{
            AttributeCollection col = TypeDescriptor.GetAttributes(this, true);
            return col;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetDefaultEvent]/*' />
        public EventDescriptor GetDefaultEvent() 
		{
            EventDescriptor ed = TypeDescriptor.GetDefaultEvent(this, true);
            return ed;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetDefaultProperty]/*' />
        public PropertyDescriptor GetDefaultProperty() 
		{
            PropertyDescriptor pd = TypeDescriptor.GetDefaultProperty(this, true);
            return pd;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetEditor]/*' />
        public object GetEditor(Type editorBaseType) 
		{
            object o = TypeDescriptor.GetEditor(this, editorBaseType, true);
            return o;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetEvents]/*' />
        public EventDescriptorCollection GetEvents() 
		{
            EventDescriptorCollection edc = TypeDescriptor.GetEvents(this, true);
            return edc;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetEvents1]/*' />
        public EventDescriptorCollection GetEvents(System.Attribute[] attributes) 
		{
            EventDescriptorCollection edc = TypeDescriptor.GetEvents(this, attributes, true);
            return edc;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetPropertyOwner]/*' />
        public object GetPropertyOwner(PropertyDescriptor pd) 
		{
            return this;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetProperties]/*' />
        public PropertyDescriptorCollection GetProperties() 
		{
            PropertyDescriptorCollection pcol = GetProperties(null);
            return pcol;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetProperties1]/*' />
        public PropertyDescriptorCollection GetProperties(System.Attribute[] attributes) 
		{
            ArrayList newList = new ArrayList();
            PropertyDescriptorCollection props = TypeDescriptor.GetProperties(this, attributes, true);

            for (int i = 0; i < props.Count; i++)
                newList.Add(CreateDesignPropertyDescriptor(props[i]));

            return new PropertyDescriptorCollection((PropertyDescriptor[])newList.ToArray(typeof(PropertyDescriptor)));;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.CreateDesignPropertyDescriptor]/*' />
        public virtual DesignPropertyDescriptor CreateDesignPropertyDescriptor(PropertyDescriptor p) 
		{
            return new DesignPropertyDescriptor(p);
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetComponentName]/*' />
        public string GetComponentName() 
		{
            string name = TypeDescriptor.GetComponentName(this, true);
            return name;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetConverter]/*' />
        public virtual TypeConverter GetConverter() 
		{
            TypeConverter tc = TypeDescriptor.GetConverter(this, true);
            return tc;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetClassName]/*' />
        public virtual string GetClassName() 
		{
			return this.GetType().FullName;
		}

        #endregion ICustomTypeDescriptor
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\MsiComponentIdAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <summary>
    ///     This attribute defines the MSI component ID that is used by the 
    ///     MSI installer. This component ID is used to indicate the install
    ///     path to this component.  This must be placed on a package class
    ///     if the package is to be installed by MSI.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
    public sealed class MsiComponentIdAttribute : Attribute {

        private string _id;
    
        /// <summary>
        ///     Creates a new MsiComponentIdAttribute.
        /// </summary>
        public MsiComponentIdAttribute (string id) {
            if (id == null) {
                throw new ArgumentNullException("id");
            }
            _id = id;
        }
        
        /// <summary>
        ///     Returns the component registration ID.
        /// </summary>
        public string Id {
            get {
                return _id;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\LogicalView.cs ===
//------------------------------------------------------------------------------
// <copyright file="LogicalView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Globalization;

    /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView"]' />
    /// <devdoc>
    ///     This enum lists the supported logical views.
    /// </devdoc>
    [TypeConverter(typeof(LogicalViewConverter))]
    public enum LogicalView {

    	/// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Primary"]/*' />
    	Primary,
    	/// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Any"]/*' />
    	Any,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Debugging"]/*' />
        Debugging,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Code"]/*' />
        Code,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Designer"]/*' />
        Designer,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Text"]/*' />
        Text,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.UserChoose"]/*' />
        UserChoose,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.ProjectSpecific"]/*' />
        ProjectSpecific
    }

    /// <devdoc>
    ///     This type converter inherits from the normal enum
    ///     converter.  It adds the ability to convert to/from
    ///     GUID types.
    /// </devdoc>
    internal class LogicalViewConverter : EnumConverter {

        private Guid[] _guids = new Guid[] {
            new Guid("00000000-0000-0000-0000-000000000000"),
            new Guid("FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"),
            new Guid("7651A700-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("7651A701-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("7651A702-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("7651A703-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("7651A704-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("80A3471A-6B87-433E-A75A-9D461DE0645F")
        };

        private LogicalView[] _views = new LogicalView[] {
            LogicalView.Primary,
            LogicalView.Any,
            LogicalView.Debugging,
            LogicalView.Code,
            LogicalView.Designer,
            LogicalView.Text,
            LogicalView.UserChoose,
            LogicalView.ProjectSpecific
        };

        public LogicalViewConverter(Type enumType) : base(enumType) {
            Debug.Assert(_views.Length == _guids.Length, "Mismatch in view / guid relationship");
        }

        /// <devdoc>
        ///     Gets a value indicating whether this converter
        ///     can convert an object in the given source type to an enumeration object using
        ///     the specified context.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(Guid)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        /// <devdoc>
        ///     Gets a value indicating whether this converter can
        ///     convert an object to the given destination type using the context.
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(Guid)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <devdoc>
        ///     Converts the specified value object to an enumeration object.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is Guid) {
                for (int i = 0; i < _guids.Length; i++) {
                    if (value.Equals(_guids[i])) {
                        return _views[i];
                    }
                }
            }
            return base.ConvertFrom(context, culture, value);
        }
    
        /// <devdoc>
        ///     Converts the given value object to the specified destination type.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(Guid) && value != null) {
                for (int i = 0; i < _views.Length; i++) {
                    if (value.Equals(_views[i])) {
                        return _guids[i];
                    }
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\MsiTokenAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="MsiTokenAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <include file='doc\MsiTokenAttribute.uex' path='docs/doc[@for="MsiTokenAttribute"]' />
    /// <devdoc>
    ///     This attribute defines a token string for the MSI installer.  RegPkg
    ///     will search for these attributes on a package class to identify custom
    ///     replacement tokens when generating registry scripts for the Microsoft
    ///     Installer.  Possible token names vary, but RegPkg may query for the 
    ///     following tokens:
    ///
    ///     $ComponentPath  : the path to the component.
    ///     SystemFolder    : the path to the OS system folder (%systemroot%\system32)
    ///
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=false)]
    public sealed class MsiTokenAttribute : Attribute {

        private string _name;
        private string _value;
    
        /// <include file='doc\MsiTokenAttribute.uex' path='docs/doc[@for="MsiTokenAttribute.MsiTokenAttribute"]' />
        /// <devdoc>
        ///     Creates a new MsiTokenAttribute.
        /// </devdoc>
        public MsiTokenAttribute (string name, string value) {
            if (name == null) {
                throw new ArgumentNullException("name");
            }

            if (value == null) {
                throw new ArgumentNullException("value");
            }

            _name = name;
            _value = value;
        }
        
        /// <include file='doc\MsiTokenAttribute.uex' path='docs/doc[@for="MsiTokenAttribute.Name"]' />
        /// <devdoc>
        ///     Returns the MSI token name.
        /// </devdoc>
        public string Name {
            get {
                return _name;
            }
        }
        
        /// <include file='doc\MsiTokenAttribute.uex' path='docs/doc[@for="MsiTokenAttribute.Value"]' />
        /// <devdoc>
        ///     Returns the MSI token value.
        /// </devdoc>
        public string Value {
            get {
                return _value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\OleDataObject.cs ===
﻿//------------------------------------------------------------------------------
// <copyright file="VsToolboxService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using Microsoft.VisualStudio.Shell.Ole2Bcl;
using System;
using WinForms = System.Windows.Forms;

using IOleDataObject = Microsoft.VisualStudio.OLE.Interop.IDataObject;
using IComDataObject = System.Runtime.InteropServices.ComTypes.IDataObject;
using IDataObject = System.Windows.Forms.IDataObject;

namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject]/*' />
    [CLSCompliant(false)]
    public class OleDataObject : WinForms.DataObject, IOleDataObject
    {
        private IOleDataObject oleData;

        /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject.OleDataObject]/*' />
        public OleDataObject() 
        {
            oleData = (IOleDataObject)(new Ole2BclDataObject(this as IComDataObject));
        }

        /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject.OleDataObject1]/*' />
        public OleDataObject(IDataObject winData) :
            base (winData)
        {
            this.oleData = winData as IOleDataObject;
            if (null == this.oleData)
                oleData = (IOleDataObject)(new Ole2BclDataObject(this as IComDataObject));
        }

        /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject.OleDataObject2]/*' />
        public OleDataObject(IComDataObject comData) :
            base(comData)
        {
            oleData = comData as IOleDataObject;
            if (null == oleData)
                this.oleData = (IOleDataObject)(new Ole2BclDataObject(comData));
        }

        /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject.OleDataObject3]/*' />
        public OleDataObject(IOleDataObject oleData) :
            base( (oleData is IComDataObject) ? (IComDataObject)oleData : (IComDataObject)(new Ole2BclDataObject(oleData)) )
        {
            this.oleData = oleData;
        }

        #region IOleDataObject Members

        int IOleDataObject.DAdvise(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pFormatetc, uint ADVF, Microsoft.VisualStudio.OLE.Interop.IAdviseSink pAdvSink, out uint pdwConnection)
        {
            return oleData.DAdvise(pFormatetc, ADVF, pAdvSink, out pdwConnection);
        }

        void IOleDataObject.DUnadvise(uint dwConnection)
        {
            oleData.DUnadvise(dwConnection);
        }

        int IOleDataObject.EnumDAdvise(out Microsoft.VisualStudio.OLE.Interop.IEnumSTATDATA ppenumAdvise)
        {
            return oleData.EnumDAdvise(out ppenumAdvise);
        }

        int IOleDataObject.EnumFormatEtc(uint dwDirection, out Microsoft.VisualStudio.OLE.Interop.IEnumFORMATETC ppenumFormatEtc)
        {
            return oleData.EnumFormatEtc(dwDirection, out ppenumFormatEtc);
        }

        int IOleDataObject.GetCanonicalFormatEtc(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pformatectIn, Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pformatetcOut)
        {
            return oleData.GetCanonicalFormatEtc(pformatectIn, pformatetcOut);
        }

        void IOleDataObject.GetData(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pformatetcIn, Microsoft.VisualStudio.OLE.Interop.STGMEDIUM[] pRemoteMedium)
        {
            oleData.GetData(pformatetcIn, pRemoteMedium);
        }

        void IOleDataObject.GetDataHere(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pFormatetc, Microsoft.VisualStudio.OLE.Interop.STGMEDIUM[] pRemoteMedium)
        {
            oleData.GetDataHere(pFormatetc, pRemoteMedium);
        }

        int IOleDataObject.QueryGetData(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pFormatetc)
        {
            return oleData.QueryGetData(pFormatetc);
        }

        void IOleDataObject.SetData(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pFormatetc, Microsoft.VisualStudio.OLE.Interop.STGMEDIUM[] pmedium, int fRelease)
        {
            oleData.SetData(pFormatetc, pmedium, fRelease);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideAssemblyFilterAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideAssemblyFilterAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\ProvideAssemblyFilterAttribute.uex' path='docs/doc[@for="ProvideAssemblyFilterAttribute"]' />
    /// <devdoc>
    ///    Provides an assembly filter for a toolbox item configuration object.  Place this attribute on an object
    ///    that implements IConfigureToolboxItem to describe the assemblies the object wishes to filter.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited = true, AllowMultiple = true)]
    public sealed class ProvideAssemblyFilterAttribute : Attribute {
        private string _assemblyFilter;

        /// <include file='doc\ProvideAssemblyFilterAttribute.uex' path='docs/doc[@for="ProvideAssemblyFilterAttribute.ProvideAssemblyFilterAttribute"]' />
        /// <devdoc>
        ///    Constructor
        /// </devdoc>
        public ProvideAssemblyFilterAttribute(string assemblyFilter) {
            if (assemblyFilter == null) {
                throw new ArgumentNullException("assemblyFilter");
            }

            if (assemblyFilter.Length == 0) {
                throw new ArgumentException(Resources.General_ExpectedNonEmptyString, "assemblyFilter");
            }

            _assemblyFilter = assemblyFilter;
        }

        /// <include file='doc\ProvideAssemblyFilterAttribute.uex' path='docs/doc[@for="ProvideAssemblyFilterAttribute.AssemblyFilter"]' />
        /// <devdoc>
        ///    The filter for the toolbox item configuration object.  Filters are used to optimize which toolbox item configuration objects
        ///    are invoked when a new toolbox item is added.  Filters allow you to specify as much as as little of an assembly as you 
        ///    like.  Here are some examples:
        /// 
        ///    All Assemblies:  *
        ///    Any version of System.Windows.Forms: System.Windows.Forms
        ///    
        /// </devdoc>
        public string AssemblyFilter {
            get {
                return _assemblyFilter;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideAutoLoadAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <summary>
    ///     This attribute registers the package as an extender.  The GUID passed in determines
    ///     what is being extended. The attributes on a package do not control the behavior of
    ///     the package, but they can be used by registration tools to register the proper
    ///     information with Visual Studio.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideAutoLoadAttribute : RegistrationAttribute {

		private Guid loadGuid = Guid.Empty;

		/// <summary>
		///     Specify that the package should get loaded when this context is active.
		/// </summary>
		/// <param name="cmdUiContextGuid">Context which should trigger the loading of your package.</param>
		public ProvideAutoLoadAttribute(string cmdUiContextGuid) 
		{
			loadGuid = new Guid(cmdUiContextGuid);
		}

		/// <summary>
		/// Context Guid which triggers the loading of the package.
		/// </summary>
		public Guid LoadGuid
		{
			get
			{
				return loadGuid;
			}
		}

		/// <summary>
		///		The reg key name of this AutoLoad.
		/// </summary>
		private string RegKeyName 
		{
			get 
			{
				return string.Format(CultureInfo.InvariantCulture, "AutoLoadPackages\\{0}", loadGuid.ToString("B"));
			}
		}

		/// <summary>
		///     Called to register this attribute with the given context.  The context
		///     contains the location where the registration information should be placed.
		///     it also contains such as the type being registered, and path information.
		/// </summary>
		public override void Register(RegistrationContext context) 
		{
			context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyAutoLoad, loadGuid.ToString("B")));

			using (Key childKey = context.CreateKey(RegKeyName))
                        {
			    childKey.SetValue(context.ComponentType.GUID.ToString("B"), 0);
			}
		}

		/// <summary>
		/// Unregister this AutoLoad specification.
		/// </summary>
		public override void Unregister(RegistrationContext context)
		{
			context.RemoveValue(RegKeyName, context.ComponentType.GUID.ToString("B"));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideAutomationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideAutomationObjectAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
    
    /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="ProvideAutomationObjectAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package provides a particular automation object.  The attributes on a 
    ///     package do not control the behavior of the package, but they can be used by registration 
    ///     tools to register the proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideAutomationObjectAttribute : RegistrationAttribute {

        private string name;
        private string description;

        /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="ProvideAutomationAttribute.ProvideAutomationObjectAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideAutomationObjectAttribute.
        /// </devdoc>
        public ProvideAutomationObjectAttribute(string objectName)
        {
            if (objectName == null) {
                throw new ArgumentNullException("ObjectName");
            }

            name = objectName;
        }

        /// <include file='doc\ProvideAutomationAttribute.uex' path='docs/doc[@for="ProvideAutomationObjectAttribute.Name"]' />
        /// <devdoc>
        ///     Returns the name of the automation object declared in this attribute.
        /// </devdoc>
        public string Name {
            get {
                return name;
            }
        }

        /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="ProvideAutomationObjectAttribute.Description"]' />
        /// <devdoc>
        ///     The description of the automation object declared in this attribute.
        /// </devdoc>
        public string Description 
        {
            get {
                return description;
            }
            set {
                description = value;
            }
         }

        private string GetAutomationRegKey(Guid packageGuid)
        {
            return string.Format(CultureInfo.InvariantCulture, "Packages\\{0}\\Automation", packageGuid.ToString("B"));
        }

        /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains information such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) 
        {
            using (Key childKey = context.CreateKey(GetAutomationRegKey(context.ComponentType.GUID)))
            {
                string descValue = (Description == null) ? "" : Description;
                childKey.SetValue(Name, descValue);
            }
        }

        /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="ProvideAutomationObjectAttribute.Unregister"]' />
        /// <devdoc>
        /// Removes the registration information from the registration context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(GetAutomationRegKey(context.ComponentType.GUID));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\DialogContainerWithToolbar.cs ===
//------------------------------------------------------------------------------
// <copyright file="WindowPane.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Windows.Forms;
using System.Security.Permissions;

using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using IMessageFilter = System.Windows.Forms.IMessageFilter;

namespace Microsoft.VisualStudio.Shell {

    /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar"]/*' />
    /// <devdoc>
    /// This class is the base class for forms that need to be displayed as modal dialogs inside VisualStudio.
    /// </devdoc>
    [CLSCompliant(false)]
    public class DialogContainerWithToolbar : Form,
        IVsToolWindowToolbar,
        IServiceProvider,
        IMessageFilter
    {
        /// <devdoc>
        /// This class is used to change the control contained by the form to a
        /// IVsWindowPane. This is expecially needed if the control is a form,
        /// because WinForms will not allow us to make it child of another form.
        /// </devdoc>
        private class WindowPaneAdapter : WindowPane
        {
            private Control control;
            private DialogContainerWithToolbar container;
            private IntPtr paneHwnd;

            private int left;
            private int top;
            private int height;
            private int width;

            public WindowPaneAdapter(DialogContainerWithToolbar container, Control control) :
                base ((IServiceProvider)container)
            {
                this.container = container;
                this.paneHwnd = IntPtr.Zero;
                this.control = control;
            }

            protected override void Dispose(bool disposing)
            {
                if (disposing)
                {
                    if (null != control)
                    {
                        control.Dispose();
                        control = null;
                    }
                    paneHwnd = IntPtr.Zero;
                }
                base.Dispose(disposing);
            }

            public IntPtr Handle
            {
                get { return paneHwnd; }
            }

            public void Focus()
            {
                control.Focus();
            }

            // Create the pane at the specific coordinates.
            public void Create(int left, int top, int height, int width)
            {
                // Check if the pane was created before.
                if (IntPtr.Zero != paneHwnd)
                    throw new InvalidOperationException();

                // Create the object.
                NativeMethods.ThrowOnFailure(
                    ((IVsWindowPane)this).CreatePaneWindow(container.Handle, left, top, width, height, out paneHwnd));

                // Store the coordinates
                this.left = left;
                this.top = top;
                this.height = height;
                this.width = width;
            }

            // Returns the IWin32Window interface (used to access the handle of the control)
            public override IWin32Window Window
            {
                get { return (IWin32Window)control;  }
            }

            // Move the the pane to the specific coordinates.
            public void Move(int left, int top, int height, int width)
            {
                if (IntPtr.Zero == Handle)
                    return;

                bool result = UnsafeNativeMethods.SetWindowPos(
                                Handle, 
                                IntPtr.Zero, 
                                left, 
                                top,
                                width,
                                height,
                                NativeMethods.SWP_NOZORDER | NativeMethods.SWP_NOACTIVATE);

                if ( !result)
                    throw new Exception();

                this.left = left;
                this.top = top;
                this.height = height;
                this.width = width;
            }

            public int Left
            {
                get { return left; }
            }

            public int Top
            {
                get { return top; }
            }

            public int Height
            {
                get { return height; }
            }

            public int Width
            {
                get { return width; }
            }
        }

        private class ShowDialogContainer : Container
        {
            private IServiceProvider provider;
            public ShowDialogContainer(IServiceProvider sp)
            {
                provider = sp;
            }

            protected override object GetService(Type serviceType)
            {
                if (provider != null)
                {
                    object service = provider.GetService(serviceType);
                    if (null != service)
                        return service;
                }
                return base.GetService(serviceType);
            }
        }

        // Variables to handle the contained control
        private WindowPaneAdapter containedForm;
        private System.Drawing.Size controlSize;

        // Toolbar handling
        private IVsToolWindowToolbarHost toolbarHost;
        private RECT toolbarRect;
        private CommandID toolbarCommandId;
        private VSTWT_LOCATION toolbarLocation;

        // Services
        private IServiceProvider provider;
        private OleMenuCommandService commandService;
        private uint commandTargetCookie;

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.DialogContainerWithToolbar"]/*' />
        /// <devdoc>
        /// Constructor of the DialogContainerWithToolbar. This constructor allow the caller to set a IServiceProvider,
        /// the conatined control and an additional IOleCommandTarget implementation that will be chained to the one
        /// implemented by OleMenuCommandTarget.
        /// </devdoc>
        public DialogContainerWithToolbar(IServiceProvider sp, Control contained, IOleCommandTarget parentCommandTarget)
        {
            if (null == contained)
                throw new ArgumentNullException("contained");

            if (null == sp)
                throw new ArgumentNullException("sp");

            PrivateInit(sp, contained, parentCommandTarget);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.DialogContainerWithToolbar1"]/*' />
        /// <devdoc>
        /// Constructor of the DialogContainerWithToolbar. This constructor allow the caller to set a IServiceProvider and
        /// the conatined control.
        /// </devdoc>
        public DialogContainerWithToolbar(IServiceProvider sp, Control contained)
        {
            if (null == contained)
                throw new ArgumentNullException("contained");

            if (null == sp)
                throw new ArgumentNullException("sp");

            IOleCommandTarget parentTarget = contained as IOleCommandTarget;
            PrivateInit(sp, contained, parentTarget);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.DialogContainerWithToolbar2"]/*' />
        /// <devdoc>
        /// Constructor of the DialogContainerWithToolbar. This constructor allow the caller to set a IServiceProvider.
        /// </devdoc>
        public DialogContainerWithToolbar(IServiceProvider sp)
        {
            if (null == sp)
                throw new ArgumentNullException("sp");

            PrivateInit(sp, null, null);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.DialogContainerWithToolbar3"]/*' />
        /// <devdoc>
        /// Constructor of the DialogContainerWithToolbar.
        /// </devdoc>
        public DialogContainerWithToolbar()
        {
            PrivateInit(null, null, null);
        }

        private void RegisterCommandTarget()
        {
            if (null == provider)
                throw new InvalidOperationException();

            IVsRegisterPriorityCommandTarget registerCommandTarget = (IVsRegisterPriorityCommandTarget)provider.GetService(typeof(SVsRegisterPriorityCommandTarget));
            if (null != registerCommandTarget)
                NativeMethods.ThrowOnFailure(
                    registerCommandTarget.RegisterPriorityCommandTarget(
                        0,
                        (IOleCommandTarget)commandService,
                        out commandTargetCookie));
        }

        private void PrivateInit(IServiceProvider sp, Control contained, IOleCommandTarget parentTarget)
        {
            provider = sp;

            commandTargetCookie = 0;
            if (null == parentTarget)
            {
                commandService = new OleMenuCommandService(sp);
            }
            else
            {
                commandService = new OleMenuCommandService(sp, parentTarget);
            }
            if (null != sp)
            {
                // Now we have to register the IOleCommandTarget implemented by the OleCommandService
                // as a priority command target, so it will be called by the shell.
                RegisterCommandTarget();
            }

            // Set the defaults for the toolbar (empty toolbar placed at the top)
            toolbarRect.left = 0;
            toolbarRect.top = 0;
            toolbarRect.right = 0;
            toolbarRect.bottom = 0;
            toolbarCommandId = null;
            toolbarLocation = VSTWT_LOCATION.VSTWT_TOP;

            if (null == contained)
            {
                containedForm = null;
            }
            else
            {
                controlSize = contained.ClientSize;
                containedForm = new WindowPaneAdapter(this, contained);
                this.Site = contained.Site;
                Form innerForm = contained as Form;
                if (null != innerForm)
                {
                    // If the contained control is a form, then copy some
                    // of its property to this one.
                    this.AcceptButton = innerForm.AcceptButton;
                    this.AccessibleDefaultActionDescription = innerForm.AccessibleDefaultActionDescription;
                    this.AccessibleDescription = innerForm.AccessibleDescription;
                    this.AccessibleName = innerForm.AccessibleName;
                    this.AccessibleRole = innerForm.AccessibleRole;
                    this.AllowDrop = innerForm.AllowDrop;
                    this.AllowTransparency = innerForm.AllowTransparency;
                    this.AutoScaleDimensions = innerForm.AutoScaleDimensions;
                    this.AutoScaleMode = innerForm.AutoScaleMode;
                    this.AutoScroll = innerForm.AutoScroll;
                    this.AutoScrollMargin = innerForm.AutoScrollMargin;
                    this.AutoScrollMinSize = innerForm.AutoScrollMinSize;
                    this.AutoScrollPosition = innerForm.AutoScrollPosition;
                    this.BindingContext = innerForm.BindingContext;
                    this.Bounds = innerForm.Bounds;
                    this.CancelButton = innerForm.CancelButton;
                    this.ContextMenu = innerForm.ContextMenu;
                    this.ControlBox = innerForm.ControlBox;
                    this.Cursor = innerForm.Cursor;
                    this.DesktopBounds = innerForm.DesktopBounds;
                    this.DesktopLocation = innerForm.DesktopLocation;
                    this.Font = innerForm.Font;
                    this.FormBorderStyle = innerForm.FormBorderStyle;
                    this.Icon = innerForm.Icon;
                    this.IsAccessible = innerForm.IsAccessible;
                    this.MaximizeBox = innerForm.MaximizeBox;
                    this.MaximumSize = innerForm.MaximumSize;
                    this.Menu = innerForm.Menu;
                    this.MinimizeBox = innerForm.MinimizeBox;
                    this.MinimumSize = innerForm.MinimumSize;
                    this.Opacity = innerForm.Opacity;
                    this.Region = innerForm.Region;
                    this.RightToLeft = innerForm.RightToLeft;
                    this.ShowInTaskbar = innerForm.ShowInTaskbar;
                    this.SizeGripStyle = innerForm.SizeGripStyle;
                    this.StartPosition = innerForm.StartPosition;
                    this.Text = innerForm.Text;
                    this.TopLevel = innerForm.TopLevel;
                    this.TopMost = innerForm.TopMost;
                    this.TransparencyKey = innerForm.TransparencyKey;
                }
            }
            // At the end of the copy we have to set the properties that we want
            // to enforse (right now only the HelpButton on the command bar).
            this.HelpButton = true;

            // Set the callbacks for the events that this default implementation will handle.
            this.Load += new EventHandler(FormLoad);
            this.Closing += new System.ComponentModel.CancelEventHandler(OnClosing);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.SetSite"]/*' />
        /// <devdoc>
        /// Set the site for this window.
        /// </devdoc>
        public void SetSite(IServiceProvider sp)
        {
            if (null != provider)
                throw new InvalidOperationException();

            provider = sp;
            RegisterCommandTarget();
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.Dispose"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                // Make sure that all the resources are closed.
                OnClosing(this, new System.ComponentModel.CancelEventArgs());
            }
            base.Dispose(disposing);
        }

        private void OnClosing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            // Close the toolbar host.
            if (null != toolbarHost)
            {
                toolbarHost.Close(0);
                toolbarHost = null;
            }
            // Close and dispose the main pane.
            if (null != containedForm)
            {
                ((IVsWindowPane)containedForm).ClosePane();
                containedForm = null;
            }
            // Check if we are still registered as priority command target
            if ( (0 != commandTargetCookie) && (null != provider) )
            {
                IVsRegisterPriorityCommandTarget registerCommandTarget = GetService(typeof(SVsRegisterPriorityCommandTarget)) as IVsRegisterPriorityCommandTarget;
                if (null != registerCommandTarget)
                    registerCommandTarget.UnregisterPriorityCommandTarget(commandTargetCookie);
                commandTargetCookie = 0;
            }
            if (null != e)
                e.Cancel = false;
        }

        object IServiceProvider.GetService(System.Type serviceType)
        {
            if ( serviceType == typeof(IVsToolWindowToolbar) )
                return this;

            if ( serviceType == typeof(IOleCommandTarget) )
                return commandService;

            if ( (serviceType == typeof(IVsToolWindowToolbarHost)) && (null != ToolbarHost) )
                return ToolbarHost;

            return provider.GetService(serviceType);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.ToolbarID"]/*' />
        /// <devdoc>
        /// Gets or Sets the CommandID of the toolbar contained in this dialog.
        /// </devdoc>
        public CommandID ToolbarID
        {
            get { return toolbarCommandId; }
            set { toolbarCommandId = value; }
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.ToolbarLocation"]/*' />
        /// <devdoc>
        /// Location of the toolbar (Top, left, right ot bottom).
        /// </devdoc>
        public VSTWT_LOCATION ToolbarLocation
        {
            get { return toolbarLocation; }
            set { toolbarLocation = value; }
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.ToolbarHost"]/*' />
        /// <devdoc>
        /// Gets the IVsToolWindowToolbarHost interface for this window.
        /// </devdoc>
        public IVsToolWindowToolbarHost ToolbarHost
        {
            get
            {
                // Check if there is a cached pointer to the interface.
                if (null != toolbarHost)
                    return toolbarHost;

                // If no cached version exist, we have to get a new one
                // from the UIShell service.
                IVsUIShell uiShell = (IVsUIShell)provider.GetService(typeof(SVsUIShell));
                NativeMethods.ThrowOnFailure(
                    uiShell.SetupToolbar(Handle, (IVsToolWindowToolbar)this, out toolbarHost));
                return toolbarHost;
            }
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.CommandService"]/*' />
        /// <devdoc>
        /// Returns the command service used to check the status or execute
        /// the toolbar's commands.
        /// </devdoc>
        public IMenuCommandService CommandService
        {
            get { return commandService as IMenuCommandService; }
        }

        int IVsToolWindowToolbar.GetBorder(RECT[] rect)
        {
            // Check that the parameter is correct.
            if ((null == rect) || (rect.Length != 1))
                throw new ArgumentException("rect");

            // Return the client area of this form.
            rect[0].left = 0;
            rect[0].top = 0;
            rect[0].right = this.ClientSize.Width;
            rect[0].bottom = this.ClientSize.Height;

            return NativeMethods.S_OK;
        }

        int IVsToolWindowToolbar.SetBorderSpace(RECT[] rect)
        {
            // Check input parameter.
            if ((null == rect) || (rect.Length != 1))
                throw new ArgumentException("rect");

            // Store the toolbar informations and resize the main pane to leave room
            // for the commandbar.
            toolbarRect = rect[0];
            ResizePane();

            return NativeMethods.S_OK;
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        bool IMessageFilter.PreFilterMessage(ref Message m)
        {
            if (null != ToolbarHost)
            {
                int lResult;
                int hr = ToolbarHost.ProcessMouseActivationModal(m.HWnd,(uint)m.Msg, (uint)m.WParam, (int)m.LParam, out lResult);
                // Check for errors.
                if ( NativeMethods.Failed(hr) )
                    return false;
                // ProcessMouseActivationModal returns S_FALSE to stop the message processing, but this
                // function have to return true in this case.
                return (hr==NativeMethods.S_FALSE);
            }

            return false;
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.ShowDialog"]/*' />
        /// <devdoc>
        /// Show this window as modal dialog.
        /// </devdoc>
        public new DialogResult ShowDialog()
        {
            // if we don't have a service provider we can not show the dialog correctly
            if (null == provider)
                throw new InvalidOperationException();

            DialogResult result;
            IMessageFilter filter = this as IMessageFilter;

            // Make sure that there is non visual containment for this form
            ShowDialogContainer dialogContainer = null;
            if (this.Site == null)
            {
                dialogContainer = new ShowDialogContainer((IServiceProvider)this);
                dialogContainer.Add(this);
            }

            try
            {
                // This form needs to install its message filter in order to
                // let the toolbar process the mouse events.
                Application.AddMessageFilter(filter);

                // Show the modal dialog
                result = base.ShowDialog();
            }
            finally
            {
                if (dialogContainer != null)
                    dialogContainer.Remove(this);
                Application.RemoveMessageFilter(filter);
            }

            return result;
        }

        private void ResizePane()
        {
            // Get the size of the window.
            System.Drawing.Size mySize = this.ClientSize;

            // toolbarRect is not a real rectangle, it store the space that we have
            // to free at the left, top, right and bottom of this form for the toolbar.
            // So we have to move the main pane out of the way.
            int x = toolbarRect.left;
            int y = toolbarRect.top;
            int width = mySize.Width - toolbarRect.left - toolbarRect.right;
            int height = mySize.Height - toolbarRect.top - toolbarRect.bottom;

            containedForm.Move(x, y, height, width);
        }

        private void ResizeForm(object sender, EventArgs e)
        {
            ResizePane();
            if (ToolbarHost != null)
                ToolbarHost.BorderChanged();
        }

        private void FormLoad(object sender, EventArgs e)
        {
            if (this.DesignMode)
                return;

            if (null == containedForm)
            {
                // Handle the case that the class was constructed with the parameterless
                // constructor, so no container control is created.
                // In this case we have to create a new control that will contain all the
                // controls contained by this form and use it to create the window pane.
                Control paneControl = new UserControl();
                while (this.Controls.Count > 0)
                {
                    Control ctl = this.Controls[0];
                    ctl.Parent = paneControl;
                }
                containedForm = new WindowPaneAdapter(this, paneControl);
                controlSize = this.ClientSize;
            }

            System.Drawing.Size mySize = this.ClientSize;

            // Check if this window has a toolbar.
            if (null != toolbarCommandId)
            {
                Guid toolbarCommandSet = toolbarCommandId.Guid;
                NativeMethods.ThrowOnFailure(
                    ToolbarHost.AddToolbar(toolbarLocation, ref toolbarCommandSet, (uint)toolbarCommandId.ID));
                NativeMethods.ThrowOnFailure(ToolbarHost.Show(0));
                NativeMethods.ThrowOnFailure(ToolbarHost.ForceUpdateUI());
            }

            // Now we have to resize the form to make room for the toolbar.
            mySize.Width = controlSize.Width + toolbarRect.left + toolbarRect.right;
            mySize.Height = controlSize.Height + toolbarRect.top + toolbarRect.bottom;
            this.ClientSize = mySize;

            // Find the coordinate of the main pane.
            int x = toolbarRect.left;
            int y = toolbarRect.top;
            int width = mySize.Width - toolbarRect.left - toolbarRect.right;
            int height = mySize.Height - toolbarRect.top - toolbarRect.bottom;

            // Make sure that the pane is created.
            containedForm.Create(x, y, height, width);
            // Set the focus to the control
            containedForm.Focus();

            // Install the handler for the resize.
            this.Resize += new EventHandler(ResizeForm);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\DialogPage.cs ===
//------------------------------------------------------------------------------
// <copyright file="DialogPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using System.Windows.Forms.Design;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage"]' />
    /// <devdoc>
    ///     DialogPage encompasses a tools dialog page.  The default dialog page 
    ///     examines itself for public properties, and offers these properties 
    ///     to the user in a property grid.  You can customize this behavior, 
    ///     however by overriding various methods on the page.  The dialog 
    ///     page will automatically persist any changes made to it to the user's 
    ///     section of the registry, provided that those properties provide 
    ///     support for to/from string conversions on their type converter.
    /// </devdoc>
    [CLSCompliant(false),ComVisible(true)]
    public class DialogPage : Component,
        IWin32Window,
        IProfileManager {

        private IWin32Window     _window;
        private DialogSubclass   _subclass;
        private DialogContainer _container;
        private string           _settingsPath;
        private bool             _initializing = false;
        private bool             _uiActive = false;
        private bool             _propertyChangedHooked = false;
        private EventHandler     _onPropertyChanged;

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.DialogPage"]' />
        /// <devdoc>
        /// Constructs the Dialog Page.
        /// </devdoc>
        public DialogPage() {
            HookProperties(true);
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.AutomationObject"]' />
        /// <devdoc>
        ///     The object the dialog page is going to browse.  The
        ///     default returns "this", but you can change it to
        ///     browse any object you want.
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public virtual object AutomationObject {
            get {
                return this;
            }
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage".Site]' />
        /// <devdoc>
        ///     Override for the site property.  This override is used so we can
        ///     load and save our settings at the appropriate time.
        /// </devdoc>
        public override ISite Site {
            get {
                return base.Site;
                
            }
            set {
                if (value == null && base.Site != null) {
                    // This is dangerous at shut down time and is causing
                    // bad ExecutionEngineExceptions. It's also entirely redundant.
                    //SaveSettingsToStorage();
                }

                base.Site = value;

                if (value != null) {
                    LoadSettingsFromStorage();
                }
            }
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage".Window]' />
        /// <devdoc>
        ///     The window this dialog page will use for its UI.
        ///     This window handle must be constant, so if you are
        ///     returning a Windows Forms control you must make sure
        ///     it does not recreate its handle.  If the window object
        ///     implements IComponent it will be sited by the 
        ///     dialog page so it can get access to global services.
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        protected virtual IWin32Window Window {
            get {
                PropertyGrid grid = new PropertyGrid();
                grid.Location = new Point(0,0);
                grid.ToolbarVisible = false;
                grid.CommandsVisibleIfAvailable = false;
                grid.SelectedObject = AutomationObject;
                return grid;
            }
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.Dispose"]' />
        /// <devdoc>
        ///     Disposes this object.
        /// </devdoc>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {

                if (_container != null)
                {
                    try
                    {
                        _container.Dispose();
                    }
                    catch (Exception)
                    {
                        Debug.Fail("Failed to dispose container");
                    }
                    _container = null;
                }

                if (_window != null && _window is IDisposable)
                {
                    try
                    {
                    ((IDisposable)_window).Dispose();
                    }
                    catch (Exception)
                    {
                        Debug.Fail("Failed to dispose window");
                    }
                    _window = null;
                }

                if (_subclass != null)
                {
                    _subclass = null;
                }

                HookProperties(false);
            }
            base.Dispose(disposing);
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.LoadSettingsFromStorage"]' />
        /// <devdoc>
        ///     This method is called when the dialog page should load
        ///     its default settings from the registry.  The default
        ///     implementation gets the Package service, gets the
        ///     user registry key, and reads in all properties for this
        ///     page that could be converted from strings.
        /// </devdoc>
        public virtual void LoadSettingsFromStorage() {
            _initializing = true;
            try {
                Package package = (Package)GetService(typeof(Package));
                Debug.Assert(package != null, "No package service; we cannot load settings");
                if (package != null) {
                    using (RegistryKey rootKey = package.UserRegistryRoot) {

                        string path = this.SettingsRegistryPath;
                        object automationObject = this.AutomationObject;

                        RegistryKey key = rootKey.OpenSubKey(path, false /* writable */);
                        if (key != null) {
                            using (key) {

                                string[] valueNames = key.GetValueNames();
                                PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject);

                                foreach(string valueName in valueNames) {
                                    string value = key.GetValue(valueName).ToString();

                                    PropertyDescriptor prop = properties[valueName];
                                    if (prop != null && prop.Converter.CanConvertFrom(typeof(string))) {
                                        prop.SetValue(automationObject, prop.Converter.ConvertFromInvariantString(value));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            finally {
                _initializing = false;
            }
            HookProperties(true); //hook if this failed during construction.
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.LoadSettingsFromXml"]' />
        /// <devdoc>
        ///     This method is called when the dialog page should load
        ///     its default settings from the profile XML file.  
        /// </devdoc>
        public virtual void LoadSettingsFromXml(IVsSettingsReader reader) {
            _initializing = true;
            try {
                object automationObject = this.AutomationObject;
                PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject, new Attribute[] {DesignerSerializationVisibilityAttribute.Visible});

                foreach(PropertyDescriptor property in properties) {
                    TypeConverter converter = property.Converter;
                    if (converter.CanConvertTo(typeof(string)) && converter.CanConvertFrom(typeof(string))) {
                        // read from the xml feed
                        string value = null;
                        object cv = null;
                        try {
                            if ( NativeMethods.Succeeded(reader.ReadSettingString(property.Name, out value)) && (value != null) )
                            {
                                cv = property.Converter.ConvertFromInvariantString(value);
                            }
                        } catch (Exception) {
                            // ReadSettingString throws an exception if the property 
                            // is not found and we also catch ConvertFromInvariantString
                            // exceptions so that we gracefully handle bad vssettings.
                        }
                        //not all values have to be present
                        if (cv != null) { 
                            property.SetValue(automationObject, cv);
                        }
                    }
                }
            }
            finally {
                _initializing = false;    //we have loaded from storage
            }
            HookProperties(true); //hook if this failed during construction.
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.ResetSettings"]' />
        /// <devdoc>Override this method in order to reset your settings to your default values.</devdoc>
        public virtual void ResetSettings() {
        }

        /// <devdoc>
        /// This function hooks property change events so that we automatically serialize
        /// if the value changes outside of UI and loading
        /// </devdoc>
        private void HookProperties(bool hook) {
            if (_propertyChangedHooked != hook)  {
                
                if (_onPropertyChanged == null)
                    _onPropertyChanged = new EventHandler(OnPropertyChanged);

                object automationObject = null;
                try
                {
                    automationObject = this.AutomationObject;
                }
                catch (Exception e)
                {
                    Debug.Fail(e.ToString());  //assert this so we don't ship bad code.
                }

                if (automationObject!= null)  {
                    PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject, new Attribute[] {DesignerSerializationVisibilityAttribute.Visible});

                    foreach(PropertyDescriptor property in properties) {
                        if (hook) 
                            property.AddValueChanged(automationObject, _onPropertyChanged);
                        else
                            property.RemoveValueChanged(automationObject, _onPropertyChanged);
                    }
                    _propertyChangedHooked = hook;
                }
            }
        }

        // Convert an item property value changed event into a list changed event
        private void OnPropertyChanged(object sender, EventArgs e)  {
            if (!_initializing && !_uiActive)
                SaveSettingsToStorage();
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.OnActivate"]' />
        /// <devdoc>
        ///     This method is called when VS wants to activate this
        ///     page.  If true is returned, the page is activated.
        /// </devdoc>
        protected virtual void OnActivate(CancelEventArgs e) {
            _uiActive = true;
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.OnClosed"]' />
        /// <devdoc>
        ///     This event is raised when the page is closed.   
        /// </devdoc>
        protected virtual void OnClosed(EventArgs e) {
            _uiActive = false;
            LoadSettingsFromStorage(); //reload whatever is saved in storage so if someone is accessing this object, it will have the correct values.
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.OnDeactivate"]' />
        /// <devdoc>
        ///     This method is called when VS wants to deatviate this
        ///     page.  If true is returned, the page is deactivated.
        /// </devdoc>
        protected virtual void OnDeactivate(CancelEventArgs e) {
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.OnApply"]' />
        /// <devdoc>
        ///     This method is called when VS wants to save the user's 
        ///     changes then the dialog is dismissed.
        /// </devdoc>
        protected virtual void OnApply(PageApplyEventArgs e) {
            SaveSettingsToStorage();
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.SaveSettingsToStorage"]' />
        /// <devdoc>
        ///     This method does the reverse of LoadSettingsFromStorage.
        /// </devdoc>
        public virtual void SaveSettingsToStorage() {
            Package package = (Package)GetService(typeof(Package));
            Debug.Assert(package != null, "No package service; we cannot load settings");
            if (package != null) {
                using (RegistryKey rootKey = package.UserRegistryRoot) {

                    string path = SettingsRegistryPath;
                    object automationObject = this.AutomationObject;
                    RegistryKey key = rootKey.OpenSubKey(path, true /* writable */);
                    if (key == null) {
                        key = rootKey.CreateSubKey(path);
                    }

                    using (key) {

                        PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject, new Attribute[] { DesignerSerializationVisibilityAttribute.Visible });

                        foreach(PropertyDescriptor property in properties) {
                            TypeConverter converter = property.Converter;
                            if (converter.CanConvertTo(typeof(string)) && converter.CanConvertFrom(typeof(string))) {
                                key.SetValue(property.Name, converter.ConvertToInvariantString(property.GetValue(automationObject)));
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.SaveSettingsToXml"]' />
        /// <devdoc>
        ///     This method does the reverse of LoadSettingsFromXml.
        /// </devdoc>
        public virtual void SaveSettingsToXml(IVsSettingsWriter writer) {
            object automationObject = this.AutomationObject;
            PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject, new Attribute[] {DesignerSerializationVisibilityAttribute.Visible});
            // [clovett] Sort the names so that tests can depend on the order returned, otherwise the order changes
            // randomly based on some internal hashtable seed.  Besides it makes it easier for the user to
            // read the .vssettings files.
            ArrayList sortedNames = new ArrayList();
            foreach (PropertyDescriptor property in properties) {
                sortedNames.Add(property.Name);
            }
            sortedNames.Sort();
            foreach(string name in sortedNames) {
                PropertyDescriptor property = properties[name];
                TypeConverter converter = property.Converter;
                if (converter.CanConvertTo(typeof(string)) && converter.CanConvertFrom(typeof(string))) {
                    NativeMethods.ThrowOnFailure(
                        writer.WriteSettingString(property.Name, converter.ConvertToInvariantString(property.GetValue(automationObject)))
                    );
                }
            }
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.SettingsRegistryPath"]' />
        /// <devdoc>
        /// This is where the settings are stored under [UserRegistryRoot]\DialogPage, the default
        /// is the full type name of your AutomationObject.
        /// </devdoc>
        protected string SettingsRegistryPath {
            get {
                if (this._settingsPath == null) {
                    this._settingsPath = "DialogPage\\" + this.AutomationObject.GetType().FullName;
                }
                return this._settingsPath;
            }
            set {
                this._settingsPath = value;
            }
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.IWin32Window.Handle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IWin32Window implementation.  This just delegates to the Window property.
        /// </devdoc>
        IntPtr IWin32Window.Handle {
            get {

                if (_window == null) {
                    _window = Window;
                    if (_window is IComponent) {
                        if (_container == null) {
                            _container = new DialogContainer(Site);
                        }
                        _container.Add((IComponent)_window);
                    }
                    if (_subclass == null) {
                        _subclass = new DialogSubclass(this);
                    }
                }

                if (_subclass.Handle != _window.Handle) {
                    _subclass.AssignHandle(_window.Handle);
                }

                return _window.Handle;
            }
        }

        internal void ResetContainer() {
            if (_container != null && _window is IComponent) {
                // This resets the AmbientProperties.
                _container._ambientProperties = null;
                _container.Remove((IComponent)_window);                
                _container.Add((IComponent)_window);
            }
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.ApplyKind"]/*' />
        /// <devdoc>
        /// Apply behavior.  Allows the OnApply event to be canceled with optional navigation instructions.
        /// </devdoc>
        public enum ApplyKind { 
            /// <summary>
            /// Apply - Allows the changes to be applied
            /// </summary>
            Apply = 0, 

            /// <summary>
            /// CancelNavigate - Cancels the apply event and navigates to the page cancelling the event.
            /// </summary>
            Cancel = 1, 
            
            /// <summary>
            /// CancelNoNavigate - Cancels the apply event and returns the active page, not the page cancelling the event.
            /// </summary>
            CancelNoNavigate = 2 
        };

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.PageApplyEventArgs"]/*' />
        /// <devdoc>
        /// Event arguments to allow the OnApply method to indicate how to handle the apply event.
        /// </devdoc>
        protected class PageApplyEventArgs : EventArgs
        {
            private ApplyKind _apply = ApplyKind.Apply;

            /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.AutomationObject.ApplyBehavior"]' />
            public ApplyKind ApplyBehavior
            {
                get
                {
                    return _apply;
                }
                set
                {
                    _apply = value;
                }
            }
        }

        /// <devdoc>
        ///     This class derives from container to provide a service provider
        ///     connection to the dialog page.
        /// </devdoc>
        private sealed class DialogContainer : Container {

            private IServiceProvider _provider;
            internal AmbientProperties _ambientProperties;

            /// <devdoc>
            ///     Creates a new container using the given service provider.
            /// </devdoc>
            public DialogContainer(IServiceProvider provider) {
                _provider = provider;
            }

            /// <devdoc>
            ///     Override to GetService so we can route requests
            ///     to the package's service provider.
            /// </devdoc>
            protected override object GetService(Type serviceType) {
                if (serviceType == null) {
                    throw new ArgumentNullException("serviceType");
                }
                if (serviceType == typeof(AmbientProperties)) {
                    if (_ambientProperties == null) {
                        IUIService uis = GetService(typeof(IUIService)) as IUIService;
                        _ambientProperties = new AmbientProperties();
                        _ambientProperties.Font = (Font)uis.Styles["DialogFont"];
                    }
                    return _ambientProperties;
                }
                if (_provider != null) {
                    object service = _provider.GetService(serviceType);
                    if (service != null) {
                        return service;
                    }
                }
                return base.GetService(serviceType);
            }
        }

        /// <devdoc>
        ///     This class derives from NativeWindow to provide a hook
        ///     into the window handle.  We use this hook so we can
        ///     respond to property sheet window messages that VS
        ///     will send us.
        /// </devdoc>
        private sealed class DialogSubclass : NativeWindow {

            private DialogPage _page;
            private bool       _closeCalled;

            /// <devdoc>
            ///     Create a new DialogSubclass
            /// </devdoc>
            internal DialogSubclass(DialogPage page) {
                _page = page;
                _closeCalled = false;
            }

            /// <devdoc>
            ///     Override for WndProc to handle our PSP messages
            /// </devdoc>
            protected override void WndProc(ref Message m) {

                CancelEventArgs ce;

                switch (m.Msg) { 
                    case NativeMethods.WM_NOTIFY:
                        NativeMethods.NMHDR nmhdr = (NativeMethods.NMHDR)Marshal.PtrToStructure(m.LParam, typeof(NativeMethods.NMHDR));
                        switch (nmhdr.code) {
                            case NativeMethods.PSN_RESET:
                                _closeCalled = true;
                                _page.OnClosed(EventArgs.Empty);
                                return;
                            case NativeMethods.PSN_APPLY:
                                PageApplyEventArgs pae = new PageApplyEventArgs(); 
                                _page.OnApply(pae);
                                switch (pae.ApplyBehavior)
                                {    
                                    case ApplyKind.Cancel:
                                        m.Result = (IntPtr)NativeMethods.PSNRET_INVALID;
                                        break;

                                    case ApplyKind.CancelNoNavigate:
                                        m.Result = (IntPtr)NativeMethods.PSNRET_INVALID_NOCHANGEPAGE;
                                        break;

                                    case ApplyKind.Apply:
                                    default:
                                        m.Result = IntPtr.Zero;
                                        break;
                                }
                                UnsafeNativeMethods.SetWindowLong(m.HWnd, NativeMethods.DWL_MSGRESULT, m.Result);
                                return;
                            case NativeMethods.PSN_KILLACTIVE:
                                ce = new CancelEventArgs();
                                _page.OnDeactivate(ce);
                                m.Result = (IntPtr)(ce.Cancel ? 1 : 0);
                                UnsafeNativeMethods.SetWindowLong(m.HWnd, NativeMethods.DWL_MSGRESULT, m.Result);
                                return;
                            case NativeMethods.PSN_SETACTIVE:
                                _closeCalled = false;
                                ce = new CancelEventArgs();
                                _page.OnActivate(ce);
                                m.Result = (IntPtr)(ce.Cancel ? -1 : 0);
                                UnsafeNativeMethods.SetWindowLong(m.HWnd, NativeMethods.DWL_MSGRESULT, m.Result);
                                return;
                        }
                        break;
                    case NativeMethods.WM_DESTROY:

                        // we can't tell the difference between OK and Apply (see above), so
                        // if we get a destroy and close hasn't been called, make sure we call it
                        //
                        if (!_closeCalled && _page != null) {
                            _page.OnClosed(EventArgs.Empty);
                        }
                        break;
                }

                base.WndProc(ref m);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\OleMenuCommandService.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleMenuCommandService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Shell {
    
    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;
    using VSConstants = Microsoft.VisualStudio.VSConstants;

    /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService"]/*' />
    /// <devdoc>
    ///    
    /// </devdoc>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class OleMenuCommandService : System.ComponentModel.Design.MenuCommandService, IOleCommandTarget {

        internal static TraceSwitch MENUSERVICE = new TraceSwitch("MENUSERVICE", "MenuCommandService: Track menu command routing");

        private IOleCommandTarget _parentTarget;
        private IServiceProvider _provider;

        private static uint _queryStatusCount = 0;

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.OleMenuCommandService"]/*' />
        /// <devdoc>
        ///     Creates a new menu command service.
        /// </devdoc>
        public OleMenuCommandService(IServiceProvider serviceProvider) : base(serviceProvider){   
            _provider = serviceProvider;
        }


        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.OleMenuCommandService1"]/*' />
        /// <devdoc>
        ///     Creates a new menu command service.
        /// </devdoc>
        public OleMenuCommandService(IServiceProvider serviceProvider, IOleCommandTarget parentCommandTarget) : base(serviceProvider) {
            if (parentCommandTarget == null) {
                throw new ArgumentNullException("parentCommandTarget");
            }
            _parentTarget = parentCommandTarget;
            _provider = serviceProvider;
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.ServiceProvider"]/*' />
        /// <devdoc>
        ///     Returns the service provider.
        /// </devdoc>
        [Obsolete("This method is obsolete and will be removed before the end of M3.2.  Use the proected GetService method instead.")]
        protected IServiceProvider ServiceProvider {
            get {
                return _provider;
            }
        }

        public IOleCommandTarget ParentTarget {
            get { return _parentTarget; }
            set { _parentTarget = value; }
        }

        private MenuCommand FindCommand(Guid guid, int id, ref int hrReturn) {
            hrReturn = (int)Microsoft.VisualStudio.OLE.Interop.Constants.OLECMDERR_E_UNKNOWNGROUP;

            MenuCommand result = null;

            //first query the IMenuCommandService and ask it to FindCommand
            IMenuCommandService menuCommandService = GetService(typeof(IMenuCommandService)) as IMenuCommandService;
            if (menuCommandService != null)
            {
            	result = menuCommandService.FindCommand(new CommandID(guid, (int)id));	
            }
            //if the IMenuCommandService cames back w/o a command, then ask ourselves
            if (result == null && this != menuCommandService)
            {
            	result = FindCommand(guid, (int)id);
            }

            if(result == null) {
                ICollection commands = GetCommandList(guid);
                if(commands != null) {                
                    // The default error now must be "Not Supported" because the command group is known
                    hrReturn = (int)Microsoft.VisualStudio.OLE.Interop.Constants.OLECMDERR_E_NOTSUPPORTED;
                    Debug.WriteLineIf(MENUSERVICE.TraceVerbose, "\t...VSMCS Found group");
                    // Get the list of command inside this group
                    foreach (MenuCommand command in commands) {
                        // we are looping again on the list of commands to check the DynamicItemMatch
                        // but this is unavoidable in this context....
                        // If the command is a OleMenuCommand, then we can try to do a dynamic match
                        IOleMenuCommand vsCommand = command as IOleMenuCommand;
                        if ( (null != vsCommand) && (vsCommand.DynamicItemMatch(id)) )
                        {
                            Debug.WriteLineIf(MENUSERVICE.TraceVerbose, "\t...VSMCS Found command2");
                            hrReturn = NativeMethods.S_OK;
                            result = command;
                        }
                    }            
                }
            }else {
                Debug.WriteLineIf(MENUSERVICE.TraceVerbose, "\t... VSMCS Found command");
                hrReturn = NativeMethods.S_OK;
            }
            return result;
        }


        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.GlobalInvoke"]/*' />
        /// <devdoc>
        ///     Invokes a command on the local form or in the global environment.
        ///     The local form is first searched for the given command ID.  If it is
        ///     found, it is invoked.  Otherwise the the command ID is passed to the
        ///     global environment command handler, if one is available.
        /// </devdoc>
        public override bool GlobalInvoke(CommandID commandID) {

            // is it local?
            if(base.GlobalInvoke(commandID)) {
                return true;
            }
            
            // pass it to the global handler
            IVsUIShell uiShellSvc = GetService(typeof(SVsUIShell)) as IVsUIShell;
            if (uiShellSvc != null) {
                Object dummy = null;
                Guid tmpGuid = commandID.Guid;
                if ( NativeMethods.Failed(uiShellSvc.PostExecCommand(ref tmpGuid, (uint)commandID.ID, 0, ref dummy)) )
                    return false;
                return true;
            }
            return false;
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.GlobalInvoke1"]/*' />
        /// <devdoc>
        ///     Invokes a command on the local form or in the global environment.
        ///     The local form is first searched for the given command ID.  If it is
        ///     found, it is invoked.  Otherwise the the command ID is passed to the
        ///     global environment command handler, if one is available.
        /// </devdoc>
        public override bool GlobalInvoke(CommandID commandID, object arg) {

            // is it local?
            if(base.GlobalInvoke(commandID, arg)) {
                return true;
            }

            // pass it to the global handler
            IVsUIShell uiShellSvc = GetService(typeof(SVsUIShell)) as IVsUIShell;
            if (uiShellSvc == null)
                return false;

            Object dummy = arg;
            Guid tmpGuid = commandID.Guid;
            if ( NativeMethods.Failed(uiShellSvc.PostExecCommand(ref tmpGuid, (uint)commandID.ID, 0, ref dummy)) )
                return false;
            return true;
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.OnCommandChanged"]/*' />
        /// <devdoc>
        ///     This is called by a menu command when it's status has changed.
        /// </devdoc>
        protected override void OnCommandsChanged(MenuCommandsChangedEventArgs e) {

            base.OnCommandsChanged(e);

            if (0 == _queryStatusCount) {
                // UpdateCommandUI(0) can not be called inside QueryStatus because this will cause an infinite
                // sequence of calls to QueryStatus during idle time.
                IVsUIShell uiShellSvc = GetService(typeof(SVsUIShell)) as IVsUIShell;
                if (uiShellSvc != null) {
                    NativeMethods.ThrowOnFailure(uiShellSvc.UpdateCommandUI(0));
                }
            }
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.ShowContextMenu"]/*' />
        /// <devdoc>
        ///     Shows the context menu with the given command ID at the given
        ///     location.
        /// </devdoc>
        public override void ShowContextMenu(CommandID menuID, int x, int y) {
            
            IOleComponentUIManager cui = GetService(typeof(NativeMethods.OleComponentUIManager)) as IOleComponentUIManager;
            Debug.Assert(cui != null, "no component UI manager, so we can't display a context menu");
            if (cui != null) {
                POINTS[] pt = new POINTS[] { new POINTS() };
                pt[0].x = (short)x;
                pt[0].y = (short)y;

                Guid tmpGuid = menuID.Guid;
                NativeMethods.ThrowOnFailure( cui.ShowContextMenu(0, ref tmpGuid, menuID.ID, pt, this) );
            }
        }

        private uint HiWord(uint val) {
            return ((val >> 16) & 0xFFFF);
        }
        private uint LoWord(uint val) {
            return (val & 0xFFFF);
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.IOleCommandTarget.Exec"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Executes the given command.
        /// </devdoc>
        int IOleCommandTarget.Exec(ref Guid guidGroup, uint nCmdId, uint nCmdExcept, IntPtr pIn, IntPtr vOut) {
            const uint vsCmdOptQueryParameterList = 1;

            Guid commandGroup = Guid.Empty;
            try {
                commandGroup = guidGroup;
            }
            catch (NullReferenceException) {
                // Here we assume that the only reason for the exception is a null guidGroup.
                // We do not handle the default command group as definied in the spec for IOleCommandTarget,
                // so we have to return OLECMDERR_E_NOTSUPPORTED.
                return (int)Microsoft.VisualStudio.OLE.Interop.Constants.OLECMDERR_E_NOTSUPPORTED;
            }

            int hr = NativeMethods.S_OK;

            MenuCommand cmd = FindCommand(commandGroup, (int)nCmdId, ref hr);
            // If the command is not supported check if it can be handled by the parent command service
            if ( (cmd== null || !cmd.Supported) && _parentTarget != null) 
            {
                return _parentTarget.Exec(ref commandGroup, nCmdId, nCmdExcept, pIn, vOut);
            }
            else if (cmd != null) {
                // Try to see if the command is a IOleMenuCommand.
                IOleMenuCommand vsCmd = cmd as IOleMenuCommand;
                // Check the execution flags;
                uint loWord = LoWord(nCmdExcept);
                // If the command is not an OleMenuCommand, it can not handle the show help option.
                if (((uint)OLECMDEXECOPT.OLECMDEXECOPT_SHOWHELP == loWord) && (null == vsCmd))
                {
                    return NativeMethods.S_OK;
                }
                object o = null;
                if (pIn != IntPtr.Zero)
                {
                    o = Marshal.GetObjectForNativeVariant(pIn);
                }
                if (null == vsCmd)
                {
                    cmd.Invoke(o);
                }
                else
                {
                    switch (loWord)
                    {
                        // Default execution of the command: call the Invoke method
                        case (uint)OLECMDEXECOPT.OLECMDEXECOPT_PROMPTUSER:
                        case (uint)OLECMDEXECOPT.OLECMDEXECOPT_DONTPROMPTUSER:
                        case (uint)OLECMDEXECOPT.OLECMDEXECOPT_DODEFAULT:
                            {
                                IMenuCommandInvokeEx invokeEx = vsCmd as IMenuCommandInvokeEx;
                                if (null != invokeEx)
                                {
                                    invokeEx.Invoke(o, vOut, (OLECMDEXECOPT)loWord);
                                }
                                else
                                {
                                    vsCmd.Invoke(o, vOut);
                                }
                            }
                            break;

                        case (uint)OLECMDEXECOPT.OLECMDEXECOPT_SHOWHELP:
                            // Check the hi word of the flags to see what kind of help
                            // is needed. We handle only the request for the parameters list.
                            if (vsCmdOptQueryParameterList == HiWord(nCmdExcept) && IntPtr.Zero != vOut)
                            {
                                // In this case vOut is a pointer to a VARIANT that will receive
                                // the parameters description.
                                if (!string.IsNullOrEmpty(vsCmd.ParametersDescription))
                                {
                                    Marshal.GetNativeVariantForObject(vsCmd.ParametersDescription, vOut);
                                }
                            }
                            break;

                        default:
                            break;
                    }
                }
            }

            return hr;

        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.IOleCommandTarget.QueryStatus"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Inquires about the status of a command.  A command's status indicates
        /// it's availability on the menu, it's visibility, and it's checked state.
        /// The exception thrown by this method indicates the current command status.
        /// </devdoc>
        int IOleCommandTarget.QueryStatus(ref Guid guidGroup, uint nCmdId, OLECMD[] oleCmd, IntPtr oleText) {
            // According with MSDN the Guid for the command group can be null and in this case the default
            // command group should be used. Given the interop definition of IOleCommandTarget, the only way
            // to detect a null guid is to try to access it and catch the NullReferenceExeption.
            Guid commandGroup = Guid.Empty;
            try {
                commandGroup = guidGroup;
            }
            catch (NullReferenceException) {
                // Here we assume that the only reason for the exception is a null guidGroup.
                // We do not handle the default command group as definied in the spec for IOleCommandTarget,
                // so we have to return OLECMDERR_E_NOTSUPPORTED.
                return (int)Microsoft.VisualStudio.OLE.Interop.Constants.OLECMDERR_E_NOTSUPPORTED;
            }

            _queryStatusCount += 1;
            int hr = NativeMethods.S_OK;
            try {
                for (uint i = 0; i < oleCmd.Length && NativeMethods.Succeeded(hr); i++)
                {
                    MenuCommand cmd = FindCommand(commandGroup, (int)oleCmd[i].cmdID, ref hr);

                    oleCmd[i].cmdf = 0;
                    if ((cmd != null) && NativeMethods.Succeeded(hr))
                    {
                        oleCmd[i].cmdf = (uint)cmd.OleStatus;
                    }

                    if ((oleCmd[i].cmdf & (int)NativeMethods.tagOLECMDF.OLECMDF_SUPPORTED) != 0)
                    {
                        // Find if the caller needs the text of the command
                        if ((IntPtr.Zero != oleText) && (NativeMethods.OLECMDTEXT.GetFlags(oleText) == NativeMethods.OLECMDTEXT.OLECMDTEXTF.OLECMDTEXTF_NAME))
                        {
                            string textToSet = null;
                            if (cmd is DesignerVerb)
                            {
                                textToSet = ((DesignerVerb)cmd).Text;
                            }
                            else if (cmd is IOleMenuCommand)
                            {
                                textToSet = ((IOleMenuCommand)cmd).Text;
                            }
                            if (null != textToSet)
                            {
                                NativeMethods.OLECMDTEXT.SetText(oleText, textToSet);
                            }
                        }
                    }
                    else if (_parentTarget != null)
                    {
                        // If the command is not supported and this command service has a parent,
                        // ask the parent about the command.
                        OLECMD[] newOleArray = { oleCmd[i] };
                        hr = _parentTarget.QueryStatus(ref commandGroup, 1, newOleArray, oleText);
                        oleCmd[i] = newOleArray[0];
                    }
                    // SBurke, if the flags are zero, the shell prefers
                    // that we return not supported, or else no one else will
                    // get asked
                    //
                    if (oleCmd[i].cmdf == 0) {
                        hr = NativeMethods.OLECMDERR_E_NOTSUPPORTED;
                    }
                }
            }
            finally {
                if (0 < _queryStatusCount)
                    _queryStatusCount -= 1;
            }
            return hr;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideEditorFactoryAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideEditorFactoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.ComponentModel;
    using System.Globalization;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers an editor factory.  A single 
    ///     package can provide multiple editor factories.  If a package declares that 
    ///     it provides an editor factory, it should create the factory and offer it 
    ///     to Visual Studio in the Initialize method of Package.
    /// </devdoc>
    [CLSCompliant(false)]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideEditorFactoryAttribute : RegistrationAttribute {

        private Type    _factoryType;
        private short   _nameResourceID;
        private __VSEDITORTRUSTLEVEL _trustLevel;

        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute.ProvideEditorFactoryAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideEditorFactoryAttribute.
        /// </devdoc>
        public ProvideEditorFactoryAttribute (Type factoryType, short nameResourceID) {
            if (factoryType == null) {
                throw new ArgumentNullException("factoryType");
            }

            _factoryType = factoryType;
            _nameResourceID = nameResourceID;
            _trustLevel = __VSEDITORTRUSTLEVEL.ETL_NeverTrusted;
        }
        
        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute.FactoryType"]' />
        /// <devdoc>
        ///     Returns the editor factory type this attribute declares.
        /// </devdoc>
        public Type FactoryType {
            get {
                return _factoryType;
            }
        }

        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute.TrustLevel"]' />
        /// <devdoc>
        ///     Gets or Sets the trust level for the editor.
        /// </devdoc>
        public __VSEDITORTRUSTLEVEL TrustLevel
        {
            get { return _trustLevel; }
            set { _trustLevel = value; }
        }
        
        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute.NameResourceID"]' />
        /// <devdoc>
        ///     Returns the native resource ID for the factory name.
        /// </devdoc>
        public short NameResourceID {
            get {
                return _nameResourceID;
            }
        }

        private string EditorRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}", FactoryType.GUID.ToString("B")); }
        }

        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyEditorFactory, FactoryType.Name));

            using (Key childKey = context.CreateKey(EditorRegKey))
            {
                childKey.SetValue(string.Empty, FactoryType.Name);
                childKey.SetValue("DisplayName", string.Format(CultureInfo.InvariantCulture, "#{0}", NameResourceID));
                childKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                childKey.SetValue("EditorTrustLevel", (int)_trustLevel);

                // Now report logical views for the editor factory.
                //
                using (Key viewKey = childKey.CreateSubkey("LogicalViews"))
                {
                    TypeConverter converter = TypeDescriptor.GetConverter(typeof(LogicalView));
                    foreach(ProvideViewAttribute pva in FactoryType.GetCustomAttributes(typeof(ProvideViewAttribute), true)) {
                        if (pva.LogicalView != LogicalView.Primary) {
                            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyEditorView, converter.ConvertToString(pva.LogicalView)));
                            Guid logicalView = (Guid)converter.ConvertTo(pva.LogicalView, typeof(Guid));
                            string physicalView = pva.PhysicalView;
                            if (physicalView == null) {
                                physicalView = string.Empty;
                            }
                            viewKey.SetValue(logicalView.ToString("B"), physicalView);
                        }
                    }
                }
            }
        }

        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="Unregister"]' />
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(EditorRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideEditorLogicalViewAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute adds a logical view to the editor created by an editor factory.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideEditorLogicalViewAttribute : RegistrationAttribute
    {
        private Guid factory;
        private Guid logicalView;
        private bool isTrusted;

        /// <summary>
        /// Creates a new RegisterEditorLogicalView attribute to register a logical
        /// view provided by your editor.
        /// </summary>
        /// <param name="factoryType">The type of factory; can be a Type, a GUID or a string representation of a GUID</param>
        /// <param name="logicalViewGuid">The guid of the logical view to register.</param>
        public ProvideEditorLogicalViewAttribute(object factoryType, string logicalViewGuid)
        {
            this.isTrusted = true;
            this.logicalView = new Guid(logicalViewGuid);
			
            // figure out what type of object they passed in and get the GUID from it
            if (factoryType is string)
                this.factory = new Guid((string)factoryType);
            else if (factoryType is Type)
                this.factory = ((Type)factoryType).GUID;
            else if (factoryType is Guid)
                this.factory = (Guid)factoryType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, factoryType));

        }

        /// <summary>
        /// Get the Guid representing the type of the editor factory
        /// </summary>
        public Guid FactoryType
        {
            get {return factory;}
        }

        /// <summary>
        /// Get the Guid representing the logical view
        /// </summary>
        public Guid LogicalView
        {
            get {return logicalView;}
        }

        /// <summary>
        /// Get or set the trust flag for this logical view. If a view is not trusted, it can not be opened
        /// from a wizard or automation code.
        /// </summary>
        public bool IsTrusted
        {
            get { return isTrusted; }
            set { isTrusted = value; }
        }

        private string EditorPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}", factory.ToString("B")); }
        }

        private string LogicalViewPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "{0}\\LogicalViews", EditorPath); }
        }

        private string UntrustedViewsPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "{0}\\UntrustedLogicalViews", EditorPath); }
        }

        /// <summary>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     It also contains other information such as the type being registered and path information.
        /// </summary>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyEditorView, logicalView.ToString("B")));

            using (Key childKey = context.CreateKey( LogicalViewPath ))
            {
                childKey.SetValue(logicalView.ToString("B"), "");
            }

            // Check if this view can be trusted for automation code.
            if (!IsTrusted)
            {
                // This logical view is not trusted, so we have to add it to the list of the untrusted ones.
                using (Key untrustedViewsKey = context.CreateKey(UntrustedViewsPath))
                {
                    untrustedViewsKey.SetValue(logicalView.ToString("B"), "");
                }

                // Now we should to check the trust level of the editor: if it has an untrusted view its tust
                // level can not be full trust. The problem is that the Key object provided by the context has
                // no GetValue method, so we can not do any check on the previous value of the trust level and
                // all we can do is overwrite it with ETL_HasUntrustedLogicalViews.
                using (Key editorKey = context.CreateKey(EditorPath))
                {
                    editorKey.SetValue("EditorTrustLevel", (int)Microsoft.VisualStudio.Shell.Interop.__VSEDITORTRUSTLEVEL.ETL_HasUntrustedLogicalViews);
                }
            }
        }

        /// <summary>
        /// Unregister this logical view.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveValue(LogicalViewPath, logicalView.ToString("B"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideExtenderAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <summary>
    /// This attribute registers the package as an extender.  The GUID passed in determines
    /// what is being extended. The attributes on a package do not control the behavior of
    /// the package, but they can be used by registration tools to register the proper
    /// information with Visual Studio.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideExtenderAttribute : RegistrationAttribute {

        private Guid CATID = Guid.Empty;
        private Guid extender = Guid.Empty;
        private string name;

        /// <summary>
        /// Creates a new ProvideExtenderAttribute.
        /// </summary>
        /// <param name="extendeeCatId">CatId of the element you want to extend.</param>
        /// <param name="extenderGuid">GUID of the extender.</param>
        /// <param name="extenderName">Name of the element you want to extend.</param>
        public ProvideExtenderAttribute(string extendeeCatId, string extenderGuid, string extenderName) 
        {
            CATID = new Guid(extendeeCatId);
            extender = new Guid(extenderGuid);
            name = extenderName;
        }

        /// <summary>
        /// The CatID of the element being extended.
        /// </summary>
        public Guid ExtendeeCatId {
            get {
                return CATID;
            }
        }

        /// <summary>
        /// The Guid of the extender.
        /// </summary>
        public Guid Extender {
            get {
                return extender;
            }
        }

        /// <summary>
        /// The name of the extender.
        /// </summary>
        public string ExtenderName {
            get {
                return name ;
            }
        }

        /// <summary>
        /// The reg key name of this Extender.
        /// </summary>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "Extenders\\{0}\\{1}", CATID.ToString("B"), name);
            }
        }

        /// <summary>
        /// Called to register this attribute with the given context.  The context
        /// contains the location where the registration information should be placed.
        /// it also contains such as the type being registered, and path information.
        /// </summary>
        public override void Register(RegistrationContext context) 
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyExtender, name, CATID.ToString("B")));

            using (Key childKey = context.CreateKey(RegKeyName))
            {
                // Set default value for the Key = Extender GUID
                childKey.SetValue(string.Empty, extender.ToString("B"));
            }
        }

        /// <summary>
        /// Unregister this Extender specification.
        /// </summary>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideKeyBindingTableAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideKeyBindingTableAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package has a key binding table declared within its 
    ///     CTO file.  This attribute is only used for registration purposes.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideKeyBindingTableAttribute : RegistrationAttribute {
        
        private short   _nameResourceID;
        private Guid    _tableGuid;
        private bool    _allowNavKeys = false;
    
        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.ProvideKeyBindingTableAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideKeyBindingTableAttribute.
        /// </devdoc>
        public ProvideKeyBindingTableAttribute (string tableGuid, short nameResourceID) {
            if (tableGuid == null) {
                throw new ArgumentNullException("tableGuid");
            }
            _tableGuid = new Guid(tableGuid);
            _nameResourceID = nameResourceID;
        }
        
        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.NameResourceID"]' />
        /// <devdoc>
        ///     Returns the key binding table's name resource ID.
        /// </devdoc>
        public short NameResourceID {
            get {
                return _nameResourceID;
            }
        }

        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.TableGuid"]' />
        /// <devdoc>
        ///     Returns the key binding table guid.
        /// </devdoc>
        public Guid TableGuid {
            get {
                return _tableGuid;
            }
        }

        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.AllowNavKeyBinding"]/*' />
        /// <summary>
        /// Set to true if the user can bind new commands of the nagivation keys
        /// </summary>
        public bool AllowNavKeyBinding
        {
            get { return _allowNavKeys; }
            set { _allowNavKeys = value; }
        }

        private string KeyBindingRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "KeyBindingTables\\{0}", TableGuid.ToString("B")); }
        }

        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyKeyBinding, TableGuid.ToString("B"), NameResourceID));

            using (Key childKey = context.CreateKey(KeyBindingRegKey))
            {
                childKey.SetValue(string.Empty, string.Format(CultureInfo.InvariantCulture, "#{0}", NameResourceID));
                childKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                childKey.SetValue("AllowNavKeyBinding", _allowNavKeys ? 1 : 0);
            }
        }

        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.Unregister"]/*' />
        public override void Unregister(RegistrationContext context) {
            context.RemoveKey(KeyBindingRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\OleToBCL.cs ===
//------------------------------------------------------------------------------
// <copyright file="VsToolboxService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;

using OleInterop = Microsoft.VisualStudio.OLE.Interop;
using BclComTypes = System.Runtime.InteropServices.ComTypes;

using IOleAdviseSink = Microsoft.VisualStudio.OLE.Interop.IAdviseSink;
using IBclAdviseSink = System.Runtime.InteropServices.ComTypes.IAdviseSink;

namespace Microsoft.VisualStudio.Shell.Ole2Bcl
{
    internal sealed class StructConverter
    {
        // Private constructor to avoid creation of instances of this class
        private StructConverter() { }

        ///////////////////////////////////////////////////////////////////////////////////
        // FORMATETC
        static internal OleInterop.FORMATETC BclFormatETC2Ole(ref BclComTypes.FORMATETC bclFormat)
        {
            OleInterop.FORMATETC oleFormat;
            oleFormat.cfFormat = (ushort)bclFormat.cfFormat;
            oleFormat.dwAspect = (uint)bclFormat.dwAspect;
            oleFormat.lindex = bclFormat.lindex;
            oleFormat.ptd = bclFormat.ptd;
            oleFormat.tymed = (uint)bclFormat.tymed;
            return oleFormat;
        }
        static internal BclComTypes.FORMATETC OleFormatETC2Bcl(ref OleInterop.FORMATETC oleFormat)
        {
            BclComTypes.FORMATETC bclFormat;
            bclFormat.cfFormat = (short)oleFormat.cfFormat;
            bclFormat.dwAspect = (BclComTypes.DVASPECT)oleFormat.dwAspect;
            bclFormat.lindex = oleFormat.lindex;
            bclFormat.ptd = oleFormat.ptd;
            bclFormat.tymed = (BclComTypes.TYMED)oleFormat.tymed;
            return bclFormat;
        }
        //                                                                       FORMATETC
        ///////////////////////////////////////////////////////////////////////////////////

        ///////////////////////////////////////////////////////////////////////////////////
        // STGMEDIUM
        static internal OleInterop.STGMEDIUM BclSTGMEDIUM2Ole(ref BclComTypes.STGMEDIUM bclMedium)
        {
            OleInterop.STGMEDIUM oleMedium;
            oleMedium.pUnkForRelease = bclMedium.pUnkForRelease;
            oleMedium.tymed = (uint)bclMedium.tymed;
            oleMedium.unionmember = bclMedium.unionmember;
            return oleMedium;
        }
        static internal BclComTypes.STGMEDIUM OleSTGMEDIUM2Bcl(ref OleInterop.STGMEDIUM oleMedium)
        {
            BclComTypes.STGMEDIUM bclMedium;
            bclMedium.pUnkForRelease = oleMedium.pUnkForRelease;
            bclMedium.tymed = (BclComTypes.TYMED)oleMedium.tymed;
            bclMedium.unionmember = oleMedium.unionmember;
            return bclMedium;
        }
        //                                                                      STGMEDIUM
        ///////////////////////////////////////////////////////////////////////////////////

        ///////////////////////////////////////////////////////////////////////////////////
        // STATDATA
        static internal OleInterop.STATDATA BclSTATDATA2Ole(ref BclComTypes.STATDATA bclData)
        {
            OleInterop.STATDATA oleData;
            if (null == bclData.advSink)
            {
                oleData.pAdvSink = null;
            }
            else
            {
                oleData.pAdvSink = bclData.advSink as OleInterop.IAdviseSink;
                if (null == oleData.pAdvSink)
                    oleData.pAdvSink = (new AdviseSink(bclData.advSink));
            }
            oleData.ADVF = (uint)bclData.advf;
            oleData.dwConnection = (uint)bclData.connection;
            oleData.FORMATETC = BclFormatETC2Ole(ref bclData.formatetc);
            return oleData;
        }
        static internal BclComTypes.STATDATA OleSTATDATA2Bcl(ref OleInterop.STATDATA oleData)
        {
            BclComTypes.STATDATA bclData;
            if (null == oleData.pAdvSink)
            {
                bclData.advSink = null;
            }
            else
            {
                bclData.advSink = oleData.pAdvSink as BclComTypes.IAdviseSink;
                if (null == bclData.advSink)
                    bclData.advSink = (BclComTypes.IAdviseSink)(new AdviseSink(oleData.pAdvSink));
            }
            bclData.advf = (BclComTypes.ADVF)oleData.ADVF;
            bclData.connection = (int)oleData.dwConnection;
            bclData.formatetc = OleFormatETC2Bcl(ref oleData.FORMATETC);
            return bclData;
        }
        //                                                                        STATDATA
        ///////////////////////////////////////////////////////////////////////////////////
    }

    internal sealed class AdviseSink : IOleAdviseSink, IBclAdviseSink
    {
        private IOleAdviseSink oleSink;
        private IBclAdviseSink bclSink;

        // This class in a converter and it doesn't make sense to build it
        // without an interface to convert, so we make the default constructor
        // private to avoid that the compiler build a public one for us.
        private AdviseSink()
        {
        }

        internal AdviseSink(IOleAdviseSink oleSink)
        {
            if (null == oleSink)
                throw new ArgumentNullException("Microsoft.VisualStudio.OLE.Interop.IAdviseSink");
            this.oleSink = oleSink;
            this.bclSink = oleSink as IBclAdviseSink;
        }

        internal AdviseSink(IBclAdviseSink bclSink)
        {
            if (null == bclSink)
                throw new ArgumentNullException("System.Runtime.InteropServices.ComTypes.IAdviseSink");
            this.oleSink = bclSink as IOleAdviseSink;
            this.bclSink = bclSink;
        }

        //////////////////////////////////////////////////////////////
        // OnClose
        //
        void IOleAdviseSink.OnClose()
        {
            if (null != oleSink)
            {
                oleSink.OnClose();
            }
            else
            {
                bclSink.OnClose();
            }
        }
        void IBclAdviseSink.OnClose()
        {
            ((IOleAdviseSink)this).OnClose();
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // OnDataChange
        //
        void IOleAdviseSink.OnDataChange(OleInterop.FORMATETC[] pFormatetc, OleInterop.STGMEDIUM[] pStgmed)
        {
            if (null != oleSink)
            {
                oleSink.OnDataChange(pFormatetc, pStgmed);
            }
            else
            {
                // In order to call the version of this interface defined in the BCL
                // each array must contain exactly one object.
                if ((null == pFormatetc) || (null == pStgmed))
                    throw new ArgumentNullException("");
                if ((1 != pFormatetc.Length) || (1 != pStgmed.Length))
                    throw new InvalidOperationException();

                // Convert the parameters
                BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
                BclComTypes.STGMEDIUM bclMedium = StructConverter.OleSTGMEDIUM2Bcl(ref pStgmed[0]);

                // Now we can call the method on the BCL interface
                bclSink.OnDataChange(ref bclFormat, ref bclMedium);

                // Now we have to copy the parameters back into the original structures.
                pFormatetc[0] = StructConverter.BclFormatETC2Ole(ref bclFormat);
                pStgmed[0] = StructConverter.BclSTGMEDIUM2Ole(ref bclMedium);
            }
        }
        void IBclAdviseSink.OnDataChange(ref BclComTypes.FORMATETC format, ref BclComTypes.STGMEDIUM stgmedium)
        {
            if (null != bclSink)
            {
                bclSink.OnDataChange(ref format, ref stgmedium);
            }
            else
            {
                // As in the previous case we have to copy the parameters.
                OleInterop.FORMATETC[] pFormatetc = new OleInterop.FORMATETC[1];
                pFormatetc[0] = StructConverter.BclFormatETC2Ole(ref format);

                OleInterop.STGMEDIUM[] pStgmed = new OleInterop.STGMEDIUM[1];
                pStgmed[0] = StructConverter.BclSTGMEDIUM2Ole(ref stgmedium);

                // Call the original interface.
                oleSink.OnDataChange(pFormatetc, pStgmed);
            }
        }
        //
        //////////////////////////////////////////////////////////////

        void IOleAdviseSink.OnRename(OleInterop.IMoniker pmk)
        {
            if (null != oleSink)
            {
                oleSink.OnRename(pmk);
            }
            else
            {
                // TODO: Use the IMoniker converter when ready.
                bclSink.OnRename(null);
            }
        }
        void IBclAdviseSink.OnRename(BclComTypes.IMoniker moniker)
        {
            if (null != bclSink)
            {
                bclSink.OnRename(moniker);
            }
            else
            {
                // TODO: Use the IMoniker converter when ready.
                oleSink.OnRename(null);
            }
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // OnSave
        //
        void IOleAdviseSink.OnSave()
        {
            if (null != oleSink)
            {
                oleSink.OnSave();
            }
            else
            {
                bclSink.OnSave();
            }
        }
        void IBclAdviseSink.OnSave()
        {
            ((IOleAdviseSink)this).OnSave();
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // OnViewChange
        //
        void IOleAdviseSink.OnViewChange(uint aspect, int index)
        {
            if (null != oleSink)
            {
                oleSink.OnViewChange(aspect, index);
            }
            else
            {
                bclSink.OnViewChange((int)aspect, index);
            }
        }
        void IBclAdviseSink.OnViewChange(int aspect, int index)
        {
            ((IOleAdviseSink)this).OnViewChange((uint)aspect, index);
        }
        //
        //////////////////////////////////////////////////////////////

    }

    internal sealed class EnumSTATDATA : OleInterop.IEnumSTATDATA, BclComTypes.IEnumSTATDATA
    {
        private OleInterop.IEnumSTATDATA oleEnum;
        private BclComTypes.IEnumSTATDATA bclEnum;

        private EnumSTATDATA() { }

        internal EnumSTATDATA(OleInterop.IEnumSTATDATA oleEnum)
        {
            if (null == oleEnum)
                throw new ArgumentNullException("Microsoft.VisualStudio.OLE.Interop.IEnumSTATDATA");
            this.oleEnum = oleEnum;
            this.bclEnum = oleEnum as BclComTypes.IEnumSTATDATA;
        }

        internal EnumSTATDATA(BclComTypes.IEnumSTATDATA bclEnum)
        {
            if (null == bclEnum)
                throw new ArgumentNullException("System.Runtime.InteropServices.ComTypes.IEnumSTATDATA");
            this.oleEnum = bclEnum as OleInterop.IEnumSTATDATA;
            this.bclEnum = bclEnum;
        }

        //////////////////////////////////////////////////////////////
        // Clone
        void OleInterop.IEnumSTATDATA.Clone(out OleInterop.IEnumSTATDATA ppEnum)
        {
            ppEnum = null;
            if (null != oleEnum)
            {
                oleEnum.Clone(out ppEnum);
            }
            else
            {
                BclComTypes.IEnumSTATDATA bclCloned;
                bclEnum.Clone(out bclCloned);
                ppEnum = bclCloned as OleInterop.IEnumSTATDATA;
                if (null == ppEnum)
                    ppEnum = (OleInterop.IEnumSTATDATA)(new EnumSTATDATA(bclCloned));
            }
        }
        void BclComTypes.IEnumSTATDATA.Clone(out BclComTypes.IEnumSTATDATA newEnum)
        {
            newEnum = null;
            if (null != bclEnum)
            {
                bclEnum.Clone(out newEnum);
            }
            else
            {
                OleInterop.IEnumSTATDATA oleCloned;
                oleEnum.Clone(out oleCloned);
                newEnum = oleCloned as BclComTypes.IEnumSTATDATA;
                if (null == newEnum)
                    newEnum = (BclComTypes.IEnumSTATDATA)(new EnumSTATDATA(oleCloned));
            }
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Next
        int OleInterop.IEnumSTATDATA.Next(uint celt, OleInterop.STATDATA[] rgelt, out uint pceltFetched)
        {
            pceltFetched = 0;
            if (null != oleEnum)
            {
                return oleEnum.Next(celt, rgelt, out pceltFetched);
            }

            BclComTypes.STATDATA[] bclStat = new BclComTypes.STATDATA[celt];
            int[] fetched = { (int)pceltFetched };
            int hr = bclEnum.Next((int)celt, bclStat, fetched);
            if (NativeMethods.Failed(hr))
                return hr;
            pceltFetched = (uint)fetched[0];
            for (int i = 0; i < pceltFetched; i++)
            {
                rgelt[i] = StructConverter.BclSTATDATA2Ole(ref bclStat[i]);
            }
            return hr;
        }
        int BclComTypes.IEnumSTATDATA.Next(int celt, BclComTypes.STATDATA[] rgelt, int[] pceltFetched)
        {
            if (null != bclEnum)
            {
                return bclEnum.Next(celt, rgelt, pceltFetched);
            }

            OleInterop.STATDATA[] oleStat = new OleInterop.STATDATA[celt];
            uint fetched;
            int hr = oleEnum.Next((uint)celt, oleStat, out fetched);
            if (NativeMethods.Failed(hr))
                return hr;
            if (null != pceltFetched)
                pceltFetched[0] = (int)fetched;
            for (int i = 0; i < fetched; i++)
            {
                rgelt[i] = StructConverter.OleSTATDATA2Bcl(ref oleStat[i]);
            }
            return hr;
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Reset
        int OleInterop.IEnumSTATDATA.Reset()
        {
            if (null != oleEnum)
                return oleEnum.Reset();
            return bclEnum.Reset();
        }
        int BclComTypes.IEnumSTATDATA.Reset()
        {
            if (null != bclEnum)
                return bclEnum.Reset();
            return oleEnum.Reset();
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Skip
        int OleInterop.IEnumSTATDATA.Skip(uint celt)
        {
            if (null != oleEnum)
                return oleEnum.Skip(celt);
            return bclEnum.Skip((int)celt);
        }
        int BclComTypes.IEnumSTATDATA.Skip(int celt)
        {
            if (null != bclEnum)
                return bclEnum.Skip(celt);
            return oleEnum.Skip((uint)celt);
        }
        //
        //////////////////////////////////////////////////////////////
    }

    internal sealed class EnumFORMATETC : OleInterop.IEnumFORMATETC, BclComTypes.IEnumFORMATETC
    {
        private OleInterop.IEnumFORMATETC oleEnum;
        private BclComTypes.IEnumFORMATETC bclEnum;

        private EnumFORMATETC() { }

        internal EnumFORMATETC(OleInterop.IEnumFORMATETC oleEnum)
        {
            if (null == oleEnum)
                throw new ArgumentNullException("Microsoft.VisualStudio.OLE.Interop.IEnumFORMATETC");
            this.oleEnum = oleEnum;
            this.bclEnum = oleEnum as BclComTypes.IEnumFORMATETC;
        }

        internal EnumFORMATETC(BclComTypes.IEnumFORMATETC bclEnum)
        {
            if (null == bclEnum)
                throw new ArgumentNullException("System.Runtime.InteropServices.ComTypes.IEnumFORMATETC");
            this.oleEnum = bclEnum as OleInterop.IEnumFORMATETC;
            this.bclEnum = bclEnum;
        }

        //////////////////////////////////////////////////////////////
        // Clone
        void OleInterop.IEnumFORMATETC.Clone(out OleInterop.IEnumFORMATETC ppEnum)
        {
            ppEnum = null;
            if (null != oleEnum)
            {
                oleEnum.Clone(out ppEnum);
            }
            else
            {
                BclComTypes.IEnumFORMATETC bclCloned;
                bclEnum.Clone(out bclCloned);
                ppEnum = bclCloned as OleInterop.IEnumFORMATETC;
                if (null == ppEnum)
                    ppEnum = (OleInterop.IEnumFORMATETC)(new EnumFORMATETC(bclCloned));
            }
        }
        void BclComTypes.IEnumFORMATETC.Clone(out BclComTypes.IEnumFORMATETC newEnum)
        {
            newEnum = null;
            if (null != bclEnum)
            {
                bclEnum.Clone(out newEnum);
            }
            else
            {
                OleInterop.IEnumFORMATETC oleCloned;
                oleEnum.Clone(out oleCloned);
                newEnum = oleCloned as BclComTypes.IEnumFORMATETC;
                if (null == newEnum)
                    newEnum = (BclComTypes.IEnumFORMATETC)(new EnumFORMATETC(oleCloned));
            }
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Next
        int OleInterop.IEnumFORMATETC.Next(uint celt, OleInterop.FORMATETC[] rgelt, uint[] pceltFetched)
        {
            if (null != oleEnum)
            {
                return oleEnum.Next(celt, rgelt, pceltFetched);
            }

            BclComTypes.FORMATETC[] bclStat = new BclComTypes.FORMATETC[celt];
            int[] fetched = new int[1];
            int hr = bclEnum.Next((int)celt, bclStat, fetched);
            if (NativeMethods.Failed(hr))
                return hr;
            if (null != pceltFetched)
                pceltFetched[0] = (uint)fetched[0];
            for (int i = 0; i < fetched[0]; i++)
            {
                rgelt[i] = StructConverter.BclFormatETC2Ole(ref bclStat[i]);
            }
            return hr;
        }
        int BclComTypes.IEnumFORMATETC.Next(int celt, BclComTypes.FORMATETC[] rgelt, int[] pceltFetched)
        {
            if (null != bclEnum)
            {
                return bclEnum.Next(celt, rgelt, pceltFetched);
            }

            OleInterop.FORMATETC[] oleStat = new OleInterop.FORMATETC[celt];
            uint[] fetched = new uint[1];
            int hr = oleEnum.Next((uint)celt, oleStat, fetched);
            if (NativeMethods.Failed(hr))
                return hr;
            if (null != pceltFetched)
                pceltFetched[0] = (int)fetched[0];
            for (uint i = 0; i < fetched[0]; i++)
            {
                rgelt[i] = StructConverter.OleFormatETC2Bcl(ref oleStat[i]);
            }
            return hr;
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Reset
        int OleInterop.IEnumFORMATETC.Reset()
        {
            if (null != oleEnum)
                return oleEnum.Reset();
            return bclEnum.Reset();
        }
        int BclComTypes.IEnumFORMATETC.Reset()
        {
            if (null != bclEnum)
                return bclEnum.Reset();
            return oleEnum.Reset();
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Skip
        int OleInterop.IEnumFORMATETC.Skip(uint celt)
        {
            if (null != oleEnum)
                return oleEnum.Skip(celt);
            return bclEnum.Skip((int)celt);
        }
        int BclComTypes.IEnumFORMATETC.Skip(int celt)
        {
            if (null != bclEnum)
                return bclEnum.Skip(celt);
            return oleEnum.Skip((uint)celt);
        }
        //
        //////////////////////////////////////////////////////////////
    }

    internal sealed class Ole2BclDataObject : OleInterop.IDataObject, BclComTypes.IDataObject
    {
        private OleInterop.IDataObject oleData;
        private BclComTypes.IDataObject bclData;

        // Private default constructor: it is not allow to build instances of this class without
        // providing an interface to convert.
        private Ole2BclDataObject() { }

        internal Ole2BclDataObject(OleInterop.IDataObject oleData)
        {
            if (null == oleData)
                throw new ArgumentNullException("Microsoft.VisualStudio.OLE.Interop.IDataObject");
            this.oleData = oleData;
            //this.bclData = oleData as BclComTypes.IDataObject;
            this.bclData = null;
        }

        internal Ole2BclDataObject(BclComTypes.IDataObject bclData)
        {
            if (null == bclData)
                throw new ArgumentNullException("System.Runtime.InteropServices.ComTypes.IDataObject");
            //this.oleData = bclData as OleInterop.IDataObject;
            this.oleData = null;
            this.bclData = bclData;
        }

        #region OleInterop.IDataObject Members

        int OleInterop.IDataObject.DAdvise(OleInterop.FORMATETC[] pFormatetc, uint ADVF, OleInterop.IAdviseSink pAdvSink, out uint pdwConnection)
        {
            if (null != oleData)
                return oleData.DAdvise(pFormatetc, ADVF, pAdvSink, out pdwConnection);

            // We have to call the method in the BCL version of the interface, so we need to
            // convert the parameters to the other type of structure.

            // As first make sure that the array contains exactly one element.
            if ((null == pFormatetc) || (pFormatetc.Length != 1))
                throw new ArgumentException();

            // Now convert the patameters
            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
            BclComTypes.IAdviseSink bclSink = pAdvSink as BclComTypes.IAdviseSink;
            if (null == bclSink)
                bclSink = new AdviseSink(pAdvSink);

            int connection;
            int hr = bclData.DAdvise(ref bclFormat, (BclComTypes.ADVF)(ADVF), bclSink, out connection);
            pdwConnection = (uint)connection;
            return hr;
        }

        void OleInterop.IDataObject.DUnadvise(uint dwConnection)
        {
            if (null != oleData)
                oleData.DUnadvise(dwConnection);
            else
                bclData.DUnadvise((int)dwConnection);
        }

        int OleInterop.IDataObject.EnumDAdvise(out OleInterop.IEnumSTATDATA ppenumAdvise)
        {
            if (null != oleData)
                return oleData.EnumDAdvise(out ppenumAdvise);

            // Call the BCL version of the method
            BclComTypes.IEnumSTATDATA bclEnum;
            int hr = bclData.EnumDAdvise(out bclEnum);
            NativeMethods.ThrowOnFailure(hr);
            if (null == bclEnum)
            {
                ppenumAdvise = null;
            }
            else
            {
                ppenumAdvise = bclEnum as OleInterop.IEnumSTATDATA;
                if (null == ppenumAdvise)
                    ppenumAdvise = (OleInterop.IEnumSTATDATA)(new EnumSTATDATA(bclEnum));
            }
            return hr;
        }

        int OleInterop.IDataObject.EnumFormatEtc(uint dwDirection, out OleInterop.IEnumFORMATETC ppenumFormatEtc)
        {
            if (null != oleData)
                return oleData.EnumFormatEtc(dwDirection, out ppenumFormatEtc);

            BclComTypes.IEnumFORMATETC bclEnum = bclData.EnumFormatEtc((BclComTypes.DATADIR)dwDirection);
            if (null == bclEnum)
            {
                ppenumFormatEtc = null;
            }
            else
            {
                ppenumFormatEtc = bclEnum as OleInterop.IEnumFORMATETC;
                if (null == ppenumFormatEtc)
                    ppenumFormatEtc = (OleInterop.IEnumFORMATETC)(new EnumFORMATETC(bclEnum));
            }
            return NativeMethods.S_OK;
        }

        int OleInterop.IDataObject.GetCanonicalFormatEtc(OleInterop.FORMATETC[] pformatectIn, OleInterop.FORMATETC[] pformatetcOut)
        {
            if (null != oleData)
                return oleData.GetCanonicalFormatEtc(pformatectIn, pformatetcOut);

            // Check that the arrays are not null and with only one element.
            if ((null == pformatectIn) || (pformatectIn.Length != 1) ||
                 (null == pformatetcOut) || (pformatetcOut.Length != 1))
                throw new ArgumentException();

            BclComTypes.FORMATETC bclFormatIn = StructConverter.OleFormatETC2Bcl(ref pformatectIn[0]);
            BclComTypes.FORMATETC bclFormatOut;
            int hr = bclData.GetCanonicalFormatEtc(ref bclFormatIn, out bclFormatOut);
            NativeMethods.ThrowOnFailure(hr);
            pformatetcOut[0] = StructConverter.BclFormatETC2Ole(ref bclFormatOut);
            return hr;
        }

        void OleInterop.IDataObject.GetData(OleInterop.FORMATETC[] pformatetcIn, OleInterop.STGMEDIUM[] pRemoteMedium)
        {
            if (null != oleData)
            {
                oleData.GetData(pformatetcIn, pRemoteMedium);
                return;
            }

            // Check that the arrays are not null and with only one element.
            if ((null == pformatetcIn) || (pformatetcIn.Length != 1) ||
                 (null == pRemoteMedium) || (pRemoteMedium.Length != 1))
                throw new ArgumentException();

            // Call the method on the BCL interface
            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pformatetcIn[0]);
            BclComTypes.STGMEDIUM bclMedium;
            bclData.GetData(ref bclFormat, out bclMedium);
            pRemoteMedium[0] = StructConverter.BclSTGMEDIUM2Ole(ref bclMedium);
        }

        void OleInterop.IDataObject.GetDataHere(OleInterop.FORMATETC[] pFormatetc, OleInterop.STGMEDIUM[] pRemoteMedium)
        {
            if (null != oleData)
            {
                oleData.GetDataHere(pFormatetc, pRemoteMedium);
                return;
            }

            // Check that the arrays are not null and with only one element.
            if ((null == pFormatetc) || (pFormatetc.Length != 1) ||
                 (null == pRemoteMedium) || (pRemoteMedium.Length != 1))
                throw new ArgumentException();

            // Call the method on the BCL interface
            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
            BclComTypes.STGMEDIUM bclMedium = StructConverter.OleSTGMEDIUM2Bcl(ref pRemoteMedium[0]);
            bclData.GetDataHere(ref bclFormat, ref bclMedium);
            pRemoteMedium[0] = StructConverter.BclSTGMEDIUM2Ole(ref bclMedium);
        }

        int OleInterop.IDataObject.QueryGetData(OleInterop.FORMATETC[] pFormatetc)
        {
            if (null != oleData)
                return oleData.QueryGetData(pFormatetc);

            if ((null == pFormatetc) || (1 != pFormatetc.Length))
                throw new ArgumentException();

            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
            return bclData.QueryGetData(ref bclFormat);
        }

        void OleInterop.IDataObject.SetData(OleInterop.FORMATETC[] pFormatetc, OleInterop.STGMEDIUM[] pmedium, int fRelease)
        {
            if (null != oleData)
            {
                oleData.SetData(pFormatetc, pmedium, fRelease);
                return;
            }

            if ((null == pFormatetc) || (1 != pFormatetc.Length) ||
                (null == pmedium) || (1 != pmedium.Length))
                throw new ArgumentException();

            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
            BclComTypes.STGMEDIUM bclMedium = StructConverter.OleSTGMEDIUM2Bcl(ref pmedium[0]);
            bclData.SetData(ref bclFormat, ref bclMedium, (fRelease == 0) ? false : true);
        }

        #endregion

        #region IDataObject Members

        int BclComTypes.IDataObject.DAdvise(ref BclComTypes.FORMATETC pFormatetc, BclComTypes.ADVF advf, BclComTypes.IAdviseSink adviseSink, out int connection)
        {
            if (null != bclData)
                return bclData.DAdvise(ref pFormatetc, advf, adviseSink, out connection);

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref pFormatetc);
            uint result;
            OleInterop.IAdviseSink oleSink = adviseSink as OleInterop.IAdviseSink;
            if (null == oleSink)
                oleSink = (OleInterop.IAdviseSink)(new AdviseSink(adviseSink));
            int hr = oleData.DAdvise(oleFormat, (uint)advf, oleSink, out result);
            NativeMethods.ThrowOnFailure(hr);
            connection = (int)result;
            return hr;
        }

        void BclComTypes.IDataObject.DUnadvise(int connection)
        {
            if (bclData != null)
                bclData.DUnadvise(connection);
            else
                oleData.DUnadvise((uint)connection);
        }

        int BclComTypes.IDataObject.EnumDAdvise(out BclComTypes.IEnumSTATDATA enumAdvise)
        {
            if (null != bclData)
                return bclData.EnumDAdvise(out enumAdvise);

            OleInterop.IEnumSTATDATA oleEnum;
            int hr = oleData.EnumDAdvise(out oleEnum);
            NativeMethods.ThrowOnFailure(hr);
            if (null == oleEnum)
            {
                enumAdvise = null;
            }
            else
            {
                enumAdvise = oleEnum as BclComTypes.IEnumSTATDATA;
                if (null == enumAdvise)
                    enumAdvise = (BclComTypes.IEnumSTATDATA)(new EnumSTATDATA(oleEnum));
            }
            return hr;
        }

        BclComTypes.IEnumFORMATETC BclComTypes.IDataObject.EnumFormatEtc(BclComTypes.DATADIR direction)
        {
            if (bclData != null)
                return bclData.EnumFormatEtc(direction);

            OleInterop.IEnumFORMATETC oleEnum;
            NativeMethods.ThrowOnFailure(oleData.EnumFormatEtc((uint)direction, out oleEnum));
            if (null == oleEnum)
                return null;
            BclComTypes.IEnumFORMATETC bclEnum = oleEnum as BclComTypes.IEnumFORMATETC;
            if (null == bclEnum)
                bclEnum = (BclComTypes.IEnumFORMATETC)(new EnumFORMATETC(oleEnum));
            return bclEnum;
        }

        int BclComTypes.IDataObject.GetCanonicalFormatEtc(ref BclComTypes.FORMATETC formatIn, out BclComTypes.FORMATETC formatOut)
        {
            if (null != bclData)
                return bclData.GetCanonicalFormatEtc(ref formatIn, out formatOut);

            OleInterop.FORMATETC[] oleFormatIn = new OleInterop.FORMATETC[1];
            OleInterop.FORMATETC[] oleFormatOut = new OleInterop.FORMATETC[1];
            oleFormatIn[0] = StructConverter.BclFormatETC2Ole(ref formatIn);
            int hr = oleData.GetCanonicalFormatEtc(oleFormatIn, oleFormatOut);
            NativeMethods.ThrowOnFailure(hr);
            formatOut = StructConverter.OleFormatETC2Bcl(ref oleFormatOut[0]);
            return hr;
        }

        void BclComTypes.IDataObject.GetData(ref BclComTypes.FORMATETC format, out BclComTypes.STGMEDIUM medium)
        {
            if (null != bclData)
            {
                bclData.GetData(ref format, out medium);
                return;
            }

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref format);
            OleInterop.STGMEDIUM[] oleMedium = new OleInterop.STGMEDIUM[1];
            oleData.GetData(oleFormat, oleMedium);
            medium = StructConverter.OleSTGMEDIUM2Bcl(ref oleMedium[0]);
        }

        void BclComTypes.IDataObject.GetDataHere(ref BclComTypes.FORMATETC format, ref BclComTypes.STGMEDIUM medium)
        {
            if (null != bclData)
            {
                bclData.GetDataHere(ref format, ref medium);
                return;
            }

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref format);
            OleInterop.STGMEDIUM[] oleMedium = new OleInterop.STGMEDIUM[1];
            oleMedium[0] = StructConverter.BclSTGMEDIUM2Ole(ref medium);
            oleData.GetDataHere(oleFormat, oleMedium);
            medium = StructConverter.OleSTGMEDIUM2Bcl(ref oleMedium[0]);
        }

        int BclComTypes.IDataObject.QueryGetData(ref BclComTypes.FORMATETC format)
        {
            if (null != bclData)
                return bclData.QueryGetData(ref format);

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref format);
            return oleData.QueryGetData(oleFormat);
        }

        void BclComTypes.IDataObject.SetData(ref BclComTypes.FORMATETC formatIn, ref BclComTypes.STGMEDIUM medium, bool release)
        {
            if (null != bclData)
            {
                bclData.SetData(ref formatIn, ref medium, release);
                return;
            }

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref formatIn);
            OleInterop.STGMEDIUM[] oleMedium = new OleInterop.STGMEDIUM[1];
            oleMedium[0] = StructConverter.BclSTGMEDIUM2Ole(ref medium);
            oleData.SetData(oleFormat, oleMedium, release ? 1 : 0);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideLanguageExtensionAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideLanguageExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute"]' />
    /// <devdoc>
    ///     This attribute associates a file extension to a given editor factory.  
    ///     The editor factory may be specified as either a GUID or a type and 
    ///     is placed on a package.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideLanguageExtensionAttribute : RegistrationAttribute {

        private Guid languageService;
        private string extension;
        
        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute.ProvideLanguageExtensionAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public ProvideLanguageExtensionAttribute (string languageServiceGuid, string extension) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_ExtensionNeedsDot, extension));
            }

            this.languageService = new Guid(languageServiceGuid);
            this.extension = extension;
        }
        
        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute.ProvideLanguageExtensionAttribute1"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public ProvideLanguageExtensionAttribute (Type languageService, string extension) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_ExtensionNeedsDot, extension));
            }

            this.languageService = languageService.GUID;
            this.extension = extension;
        }
        
        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute.Extension"]' />
        /// <devdoc>
        ///     The file extension of the file.
        /// </devdoc>
        public string Extension {
            get {
                return extension;
            }
        }
        
        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute.LanguageService"]' />
        /// <devdoc>
        ///     The language service SID.
        /// </devdoc>
        public Guid LanguageService {
            get {
                return languageService;
            }
        }

        private string ExtensionsRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Languages\\File Extensions\\{0}", Extension); }
        }

        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLanguageExtension, Extension, LanguageService.ToString("B")));

            using (Key childKey = context.CreateKey(ExtensionsRegKey))
            {
                childKey.SetValue(string.Empty, LanguageService.ToString("B"));
            }
        }

        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="Unregister"]' />
        public override void Unregister(RegistrationContext context) {
            context.RemoveKey(ExtensionsRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\OleMenuCommand.cs ===
using System;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using Microsoft.VisualStudio.OLE.Interop;

namespace Microsoft.VisualStudio.Shell
{
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs"]/*' />
    /// <summary>
    /// This is the set of arguments passed to a OleMenuCommand object when the
    /// Invoke function is called
    /// </summary>
    [CLSCompliant(false)]
    public class OleMenuCmdEventArgs : System.EventArgs
    {
        private object inParam;
        private IntPtr outParam;
        private OLECMDEXECOPT execOptions;

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs.OleMenuCmdEventArgs"]/*' />
        /// <summary>
        /// Builds the OleMenuCmdEventArgs
        /// </summary>
        /// <param name="inParam">The input parameter to the command function.</param>
        /// <param name="outParam">A pointer to the parameter returned by the function</param>
        public OleMenuCmdEventArgs(object inParam, IntPtr outParam) :
            this(inParam, outParam, OLECMDEXECOPT.OLECMDEXECOPT_DODEFAULT)
        {
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs.OleMenuCmdEventArgs"]/*' />
        /// <summary>
        /// Builds the OleMenuCmdEventArgs
        /// </summary>
        /// <param name="inParam">The input parameter to the command function.</param>
        /// <param name="outParam">A pointer to the parameter returned by the function</param>
        /// <param name="options">Execution options for the command.</param>
        public OleMenuCmdEventArgs(object inParam, IntPtr outParam, OLECMDEXECOPT options) : base()
        {
            this.execOptions = options;
            this.inParam = inParam;
            this.outParam = outParam;
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs.InValue"]/*' />
        /// <summary>
        /// Gets the parameter passed as input to the command function
        /// </summary>
        public object InValue
        {
            get { return inParam; }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs.Options"]/*' />
        /// <summary>
        /// Gets the execution options for the command.
        /// </summary>
        public OLECMDEXECOPT Options
        {
            get { return execOptions; }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs.OutValue"]/*' />
        /// <summary>
        /// Gets a pointer to the parameter used as output by the command function
        /// </summary>
        public IntPtr OutValue
        {
            get { return outParam; }
        }
    }

    /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand"]/*' />
    /// <summary>
    /// This class is an expansion of MenuCommand.
    /// </summary>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class OleMenuCommand : MenuCommand, IOleMenuCommand, IMenuCommandInvokeEx
    {
        /// <summary>The event handler called to execute the command.</summary>
        private EventHandler execHandler;
        /// <summary>
        /// The event handler caller before getting the command status; it can be used to
        /// implement a command with a dynamic status.
        /// </summary>
        private EventHandler beforeQueryStatusHandler;
        private string text;
        // Used in the case of dynamic menu (created with the DYNAMICITEMSTART option)
        private int matchedCommandId;
        // If the command supports parameters, then this string will contain the description
        // of the parameters
        private string parametersDescription;

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand"]/*' />
        /// <summary>
        /// Builds a new OleMenuCommand.
        /// </summary>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="id">ID of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, CommandID id) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, null, null, String.Empty);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand1"]/*' />
        /// <summary>
        /// Builds a new OleMenuCommand.
        /// </summary>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="id">ID of the command.</param>
        /// <param name="Text">The text of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, CommandID id, string Text) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, null, null, Text);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand2"]/*' />
        /// <devdoc>
        /// Builds a new OleMenuCommand.
        /// </devdoc>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="changeHandler">The event handler called when the command's status changes.</param>
        /// <param name="id">ID of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, EventHandler changeHandler, CommandID id) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, changeHandler, null, String.Empty);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand3"]/*' />
        /// <devdoc>
        /// Builds a new OleMenuCommand.
        /// </devdoc>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="changeHandler">The event handler called when the command's status changes.</param>
        /// <param name="id">ID of the command.</param>
        /// <param name="Text">The text of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, EventHandler changeHandler, CommandID id, string Text) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, changeHandler, null, Text);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand4"]/*' />
        /// <devdoc>
        /// Builds a new OleMenuCommand.
        /// </devdoc>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="changeHandler">The event handler called when the command's status changes.</param>
        /// <param name="beforeQueryStatus">Event handler called when a lient asks for the command status.</param>
        /// <param name="id">ID of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, EventHandler changeHandler, EventHandler beforeQueryStatus, CommandID id) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, changeHandler, beforeQueryStatus, String.Empty);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand5"]/*' />
        /// <devdoc>
        /// Builds a new OleMenuCommand.
        /// </devdoc>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="changeHandler">The event handler called when the command's status changes.</param>
        /// <param name="beforeQueryStatus">Event handler called when a lient asks for the command status.</param>
        /// <param name="id">ID of the command.</param>
        /// <param name="Text">The text of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, EventHandler changeHandler, EventHandler beforeQueryStatus, CommandID id, string Text) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, changeHandler, beforeQueryStatus, Text);
        }

        private void PrivateInit(EventHandler handler, EventHandler changeHandler, EventHandler beforeQS, string Text)
        {
            execHandler = handler;
            if (changeHandler != null)
            {
                this.CommandChanged += changeHandler;
            }
            beforeQueryStatusHandler = beforeQS;
            text = Text;
            parametersDescription = null;
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.BeforeQueryStatus"]/*' />
        /// <devdoc>
        /// Event fired when a client asks for the status of the command.
        /// </devdoc>
        /// <value></value>
        public event EventHandler BeforeQueryStatus
        {
            add { beforeQueryStatusHandler += value; }
            remove { beforeQueryStatusHandler -= value; }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleStatus"]/*' />
        public override int OleStatus
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
            get
            {
                if (null != beforeQueryStatusHandler)
                {
                    beforeQueryStatusHandler(this, EventArgs.Empty);
                }
                return base.OleStatus;
            }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.ParametersDescription"]/*' />
        /// <devdoc>
        /// Get or set the string that describes the paraeters accepted by the command.
        /// </devdoc>
        public string ParametersDescription
        {
            get { return parametersDescription; }
            set { parametersDescription = value; }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.Invoke"]/*' />
        /// <devdoc>
        /// Executes the command.
        /// </devdoc>
        /// <param name="inArg">The parameter passed to the command.</param>
        [PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
        public override void Invoke(object inArg)
        {
            try
            {
                OleMenuCmdEventArgs args = new OleMenuCmdEventArgs(inArg, NativeMethods.InvalidIntPtr);
                execHandler(this, args);
            }
            catch (CheckoutException ex)
            {
                if (CheckoutException.Canceled != ex)
                    throw;
            }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.Invoke1"]/*' />
        /// <devdoc>
        /// Executes the command.
        /// </devdoc>
        /// <param name="inArg">The parameter passed to the command.</param>
        /// <param name="outArg">The parameter returned by the command.</param>
        [EnvironmentPermission(SecurityAction.LinkDemand, Unrestricted = true)]
        public virtual void Invoke(object inArg, IntPtr outArg)
        {
            Invoke(inArg, outArg, OLECMDEXECOPT.OLECMDEXECOPT_DODEFAULT);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.Invoke2"]/*' />
        /// <summary>
        /// Executes the command with execution options.
        /// </summary>
        /// <param name="inArg">The parameter passed to the command.</param>
        /// <param name="outArg">The parameter returned by the command.</param>
        /// <param name="options">The execution options for the command.</param>
        [EnvironmentPermission(SecurityAction.LinkDemand, Unrestricted = true)]
        [CLSCompliant(false)]
        public virtual void Invoke(object inArg, IntPtr outArg, OLECMDEXECOPT options)
        {
            try
            {
                OleMenuCmdEventArgs args = new OleMenuCmdEventArgs(inArg, outArg, options);
                execHandler(this, args);
            }
            catch (CheckoutException ex)
            {
                if (CheckoutException.Canceled != ex)
                    throw;
            }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.Text"]/*' />
        /// <devdoc>
        /// Gets or sets the text for the command.
        /// </devdoc>
        /// <value></value>
        public virtual string Text
        {
            get { return text; }
            set { if (text != value) { text = value; OnCommandChanged(EventArgs.Empty); } }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.DynamicItemMatch"]/*' />
        /// <devdoc>
        /// Allows a dynamic item command to match the subsequent items in its list.  This must be overriden
        /// when implementing a menu via DYNAMICITEMSTART.
        /// </devdoc>
        /// <param name="cmdId"></param>
        /// <returns></returns>
        public virtual bool DynamicItemMatch(int cmdId)
        {
            return false;
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.MatchedCommandId"]/*' />
        /// <devdoc>
        /// The command id that was most recently used to match this command.  This must be set by the sub-class
        /// when a match occurs and can be used to identify the actual command being invoked.
        /// </devdoc>
        /// <value></value>
        public int MatchedCommandId
        {
            get { return matchedCommandId; }
            set { matchedCommandId = value; }
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideLoadKeyAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideLoadKeyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute"]' />
    /// <devdoc>
    ///     This attribute registers a package load key for your package.  
    ///     Package load keys are used by Visual Studio to validate that 
    ///     a package can be loaded.    
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited=false, AllowMultiple=false)]
    public sealed class ProvideLoadKeyAttribute : RegistrationAttribute {

        private string _minimumEdition;
        private string _productVersion;
        private string _productName;
        private string _companyName;
        private short  _resourceId;
    
        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.ProvideLoadKeyAttribute"]/*' />
        public ProvideLoadKeyAttribute (string minimumEdition, string productVersion, string productName, string companyName, short resourceId) {
            if (minimumEdition == null) {
                throw new ArgumentNullException("minimumEdition");
            }
            if (productVersion == null) {
                throw new ArgumentNullException("productVersion");
            }
            if (productName == null) {
                throw new ArgumentNullException("productName");
            }
            if (companyName == null) {
                throw new ArgumentNullException("companyName");
            }
            
            _minimumEdition = minimumEdition;
            _productVersion = productVersion;
            _productName = productName;
            _companyName = companyName;
            _resourceId = resourceId;
        }
        
        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.MinEdition"]' />
        /// <devdoc>
        ///     Minimum edition of Visual Studio on which
        ///     VSPackage is loaded. This must be the literal 
        ///     edition value provided by Microsoft when 
        ///     obtaining your PLK.
        /// </devdoc>
        public string MinimumEdition {
            get {
                return _minimumEdition;
            }
        }

        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.ProductVersion"]' />
        /// <devdoc>
        ///     Version of the product that this VSPackage
        ///     implements.
        /// </devdoc>
        public string ProductVersion {
            get {
                return _productVersion;
            }
        }
        
        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.ProductName"]' />
        /// <devdoc>
        ///     Name of the product that this VSPackage 
        ///     delivers. Note that one product might be
        ///     comprised of multiple VSPackages, in which 
        ///     case each will need its own PLK.
        /// </devdoc>
        public string ProductName {
            get {
                return _productName;
            }
        }

        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.CompanyName"]' />
        /// <devdoc>
        ///     VSIP Partner/creator of the VSPackage. 
        ///     The literal name (case-sensitive) provided 
        ///     to Microsoft when registering for a PLK.
        /// </devdoc>
        public string CompanyName {
            get {
                return _companyName;
            }
        }
        
        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.ResourceId"]' />
        /// <devdoc>
        ///     Resource ID for VSPackage load key.
        /// </devdoc>
        public short ResourceId {
            get {
                return _resourceId;
            }
        }

        /// <summary>
        /// Registry Key name for this package's load key information.
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        public string RegKeyName (RegistrationContext context)
        {
            return string.Format(CultureInfo.InvariantCulture, "Packages\\{0}", context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLoadKey, CompanyName, ProductName, ProductVersion, MinimumEdition));

            using (Key packageKey = context.CreateKey(RegKeyName(context)))
            {
                packageKey.SetValue("ID", ResourceId);
                packageKey.SetValue("MinEdition", MinimumEdition);
                packageKey.SetValue("ProductVersion", ProductVersion);
                packageKey.SetValue("ProductName", ProductName);
                packageKey.SetValue("CompanyName", CompanyName);
            }
        }

        /// <summary>
        /// Unregisters this package's load key information
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName(context));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\InstalledProductRegistrationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell 
{

    /// <summary>
    ///     This attribute registers an 'installed product' for your package.  
    ///     This enables your package to present information on the VS
    ///     Splash Screen or Help About.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=false)]
    public sealed class InstalledProductRegistrationAttribute : RegistrationAttribute 
    {

        private string _productName;
        private string _name;
        private string _productId;
        private string _productDetails;
        private string _iconResourceId;
        private bool _useInterface = false;
        private bool _usePackage = false;
    
        /// <summary>
        /// Creates a new InstalledProductRegistrationAttribute to register your package with  
        /// Help/About and enables it to present informations on the VS Splash Screen.
        /// </summary>
        public InstalledProductRegistrationAttribute (bool useInterface, string productName, string productDetails, string productId) 
        {
            _usePackage = false;
            _useInterface = useInterface;
            if (_useInterface)
            {
                // If the object uses the interface in order to expose its informations to the
                // Help/About page, then the registration must use the package, otherwise there
                // is no way to know where to find such interface.
                _usePackage = true;
            }
            else
            {
                // We are not using the interface, so we need the other parameters.
                // Let's check that they are not null or empty.
                if ((null == productName) || (productName.Trim().Length == 0))
                    throw new ArgumentNullException("productName");
                productName = productName.Trim();

                if ((null == productDetails) || (productDetails.Trim().Length == 0))
                    throw new ArgumentNullException("productDetails");
                productDetails = productDetails.Trim();

                if ((null == productId) || (productId.Trim().Length == 0))
                    throw new ArgumentNullException("productId");
                productId = productId.Trim();

                // Assign the values to the member variables
                _productName = productName;
                _productDetails = productDetails;
                _productId = productId;

                // Now that we know that the parameters are not empty, let's do a final
                // validation: the Help/About code assumes that if a registration is made
                // using a package, then both the product name and the product details are
                // id of resources (so they are supposed to be in the form "#nnn"), but if 
                // they are strings, then they both must be string.
                if (((ProductNameResourceID != 0) && (ProductDetailsResourceID == 0)) ||
                    ((ProductNameResourceID == 0) && (ProductDetailsResourceID != 0)))
                {
                    // If we are here we have the resource id for only one entry and,
                    // according with the Help/About code, this is bad, so we have to
                    // throw an exception.
                    string errorMessage = string.Format(Resources.Culture, Resources.Reg_ErrorIncompatibleParametersTypes, "productName", "productDetails");
                    throw new ArgumentException(errorMessage);
                }

                // Now check if the name and details are resource id because in this case
                // we have to use the package to register. Actually we check only the name
                // because of the previous test.
                _usePackage = (ProductNameResourceID != 0) ;
            }
        }

        #region Properties
        /// <summary>
        /// Resource ID corresponding to the product name.
        /// </summary>
        public int ProductNameResourceID
        {
            get
            {
                if (_productName == null || _productName.Length < 2 || _productName[0]!='#' || !char.IsDigit(_productName[1]))
                    return 0;
                return int.Parse( _productName.Substring(1), CultureInfo.InvariantCulture);
            }
        }
        /// <summary>
        /// Resource ID for the details.
        /// </summary>
        public int ProductDetailsResourceID
        {
            get
            {
                if (_productDetails == null || _productDetails.Length < 2 || _productDetails[0]!='#' || !char.IsDigit(_productDetails[1]))
                    return 0;
                return int.Parse( _productDetails.Substring(1), CultureInfo.InvariantCulture);
            }
        }
        /// <summary>
        /// Resource ID of the icon.
        /// </summary>
        public int IconResourceID
        {
            get
            {
                if (String.IsNullOrEmpty(_iconResourceId) || _iconResourceId.Length < 2)
                    return 0;
                return int.Parse( _iconResourceId.Substring(1), CultureInfo.InvariantCulture);
            }
            set
            {
                _iconResourceId = @"#" + value.ToString(CultureInfo.InvariantCulture);
            }
        }
        /// <summary>
        /// Your product ID.
        /// </summary>
        public string ProductId
        {
            get {return _productId;}
        }
        /// <summary>
        /// The name of your product.
        /// </summary>
        public string ProductName
        {
            get { return _productName; }
        }

        /// <summary>
        /// The name of your product.
        /// </summary>
        public string LanguageIndependentName
        {
            get { return _name; }
            set { _name = value; }
        }

        private string GetNonEmptyName(RegistrationContext context)
        {
            string product = LanguageIndependentName;
            if (product != null)
                product = product.Trim();
            if (String.IsNullOrEmpty(product))
                product = context.ComponentType.Name;
            return product;
        }
        /// <summary>
        /// Detailed description of your product.
        /// </summary>
        public string ProductDetails
        {
            get {return _productDetails;}
        }
        /// <summary>
        /// Use IVsInstalledProduct to fill in the Help about dialog.
        /// The package must implement IVsInstalledProduct.
        /// </summary>
        public bool UseInterface
        {
            get {return _useInterface;}
        }
        /// <summary>
        /// True is the product installation will use the package ID
        /// </summary>
        public bool UsePackage {
            get 
            {
                return _usePackage;
            }
        }
        #endregion

        private string RegKeyName (RegistrationContext context)
        {
            return string.Format(CultureInfo.InvariantCulture, "InstalledProducts\\{0}", GetNonEmptyName(context));
        }



        /// <summary>
        ///     Called to register this attribute with the given context.
        /// </summary>
        /// <param name="context">
        ///     Contains the location where the registration information should be placed.
        ///     It also contains other information such as the type being registered and path information.
        /// </param>
        public override void Register(RegistrationContext context) 
        {
            if (UseInterface)
            {
                context.Log.WriteLine(Resources.Reg_NotifyInstalledProductInterface);
            }
            else
            {
                context.Log.WriteLine(Resources.Reg_NotifyInstalledProduct, GetNonEmptyName(context), ProductId);
            }

            using (Key packageKey = context.CreateKey(RegKeyName(context)))
            {

                // Set the 'Package' value if necessary
                if (UsePackage)
                {
                    packageKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                }

                // Set the 'UseRegNameAsSplashName' flag if the user provided a short name that should be used on the splash screen
                if (!String.IsNullOrEmpty(_name))
                {
                    packageKey.SetValue("UseRegNameAsSplashName", 1);
                }

                // Set the 'UseInterface' value if necessary
                if (UseInterface)
                {
                    packageKey.SetValue("UseInterface", 1);
                }
                else
                {
                    // If UseInterface is 0, then the following are required for HelpAbout
                    packageKey.SetValue("", ProductName);
                    packageKey.SetValue("ProductDetails", ProductDetails);
                    packageKey.SetValue("PID", ProductId);

                    // The icon resource id reg entry is only valid if there 
                    // is a package satellite and not using the interface
                    if (UsePackage && !String.IsNullOrEmpty(_iconResourceId))
                    {
                        packageKey.SetValue("LogoID", _iconResourceId);
                    }
                }
            }
        }

        /// <summary>
        /// Unregister this InstalledProducts entry.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context) 
        {
            context.RemoveKey(RegKeyName(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideMenuResourceAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideMenuResourceAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers menu resources.  When Visual Studio encounters 
    ///     such a package it will merge the menu resource information in its menus.  The attributes on a 
    ///     package do not control the behavior of the package, but they can be used by registration 
    ///     tools to register the proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideMenuResourceAttribute : RegistrationAttribute {

        private string _resourceID;
        private int   _version;
    
        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute.ProvideMenuResourceAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideMenuResourceAttribute.
        /// </devdoc>
        public ProvideMenuResourceAttribute (short resourceID, int version) {
            _resourceID = resourceID.ToString();
            _version = version;
        }
        
        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute.ProvideMenuResourceAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideMenuResourceAttribute.
        /// </devdoc>
        public ProvideMenuResourceAttribute (string resourceID, int version) {
            if (string.IsNullOrEmpty(resourceID)) {
                throw new ArgumentNullException("resourceID");
            }
            _resourceID = resourceID;
            _version = version;
        }

        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute.ResourceID"]' />
        /// <devdoc>
        ///     Returns the native resource ID for the menu resource.
        /// </devdoc>
        public string ResourceID {
            get {
                return _resourceID;
            }
        }
        
        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute.Version"]' />
        /// <devdoc>
        ///     Returns the version of this menu resource.
        /// </devdoc>
        public int Version {
            get {
                return _version;
            }
        }

        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyMenuResource, ResourceID, Version));

            using (Key childKey = context.CreateKey("Menus"))
            {
                childKey.SetValue(context.ComponentType.GUID.ToString("B"), string.Format(CultureInfo.InvariantCulture, ", {0}, {1}", ResourceID, Version));
            }
        }

        /// <summary>
        ///     Called to unregister this attribute with the given context.
        /// </summary>
        /// <param name="context">
        ///     Contains the location where the registration inforomation should be placed.
        ///     It also contains other informations as the type being registered and path information.
        /// </param>
        public override void Unregister(RegistrationContext context) {
            context.RemoveValue("Menus", context.ComponentType.GUID.ToString("B"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideObjectAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideObjectAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideObjectAttribute.uex' path='docs/doc[@for="ProvideObjectAttribute"]' />
    /// <devdoc>
    ///     This attribute declares a class as creatable through Visual Studio.  
    ///     A creatable class will be given an entry in Visual Studio's local 
    ///     registry at install time.  The objectType parameter specifies the
    ///     data type of the object that will be created.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideObjectAttribute : RegistrationAttribute {

        private Type _objectType;
        private RegistrationMethod registrationMethod = RegistrationMethod.Default;
    
        /// <include file='doc\ProvideObjectAttribute.uex' path='docs/doc[@for="ProvideObjectAttribute.ProvideObjectAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideObjectAttribute.
        /// </devdoc>
        public ProvideObjectAttribute (Type objectType) {
            if (objectType == null) {
                throw new ArgumentNullException("objectType");
            }
            _objectType = objectType;
        }
        
        /// <include file='doc\ProvideObjectAttribute.uex' path='docs/doc[@for="ProvideObjectAttribute.ObjectType"]' />
        /// <devdoc>
        ///     The type of object that can be created from this package.
        /// </devdoc>
        public Type ObjectType {
            get {
                return _objectType;
            }
        }

        /// <summary>
        /// Select between specifying the Codebase entry or the Assembly entry in the registry.
        /// This can be overriden during registration
        /// </summary>
        public RegistrationMethod RegisterUsing
        {
            get
            {
                return registrationMethod;
            }
            set
            {
                registrationMethod = value;
            }
        }

        private string CLSIDRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "CLSID\\{0}", ObjectType.GUID.ToString("B")); }
        }

        /// <include file='doc\ProvideObjectAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyCreateObject, ObjectType.Name));

            using (Key childKey = context.CreateKey(CLSIDRegKey))
            {
                childKey.SetValue(string.Empty, ObjectType.FullName);
                childKey.SetValue("InprocServer32", context.InprocServerPath);
                childKey.SetValue("Class", ObjectType.FullName);

                // If specified on the command line, let the command line option override
                if (context.RegistrationMethod != RegistrationMethod.Default) {
                    registrationMethod = context.RegistrationMethod;
                }

            switch(registrationMethod) {
                case RegistrationMethod.Default:
                case RegistrationMethod.Assembly:
                    childKey.SetValue("Assembly", ObjectType.Assembly.FullName);
                    break;
                
                    case RegistrationMethod.CodeBase:
                        childKey.SetValue("CodeBase", context.CodeBase);
                        break;
                }

                childKey.SetValue("ThreadingModel", "Both");
            }
        }
        /// <summary>
        /// Unregisters this attribute.
        /// </summary>
        /// <param name="context">
        ///     Contains the location from where the registration inforomation should be removed.
        ///     It also contains other informations as the type being unregistered and path information.
        /// </param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(CLSIDRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideEditorExtensionAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideEditorExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.IO;
    using System.Globalization;


    /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute"]' />
    /// <devdoc>
    ///     This attribute associates a file extension to a given editor factory.  
    ///     The editor factory may be specified as either a GUID or a type and 
    ///     is placed on a package.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideEditorExtensionAttribute : RegistrationAttribute {

        private Guid factory;
        private string extension;
        private int priority;
        private Guid project;
        private string templateDir;
        private int resId;
        private bool editorFactoryNotify;
        private string editorName;
        
        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.ProvideEditorExtensionAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public ProvideEditorExtensionAttribute (object factoryType, string extension, int priority) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_ExtensionNeedsDot, extension));
            }

            // figure out what type of object they passed in and get the GUID from it
            if (factoryType is string)
                this.factory = new Guid((string)factoryType);
            else if (factoryType is Type)
                this.factory = ((Type)factoryType).GUID;
            else if (factoryType is Guid)
                this.factory = (Guid)factoryType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, factoryType));

            this.extension = extension;
            this.priority = priority;
            this.project = Guid.Empty;
            this.templateDir = "";
            this.resId = 0;
            this.editorFactoryNotify = false;
        }
        
        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.Extension"]' />
        /// <devdoc>
        ///     The file extension of the file.
        /// </devdoc>
        public string Extension {
            get {
                return extension;
            }
        }
        
        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.Factory"]' />
        /// <devdoc>
        ///     The editor factory guid.
        /// </devdoc>
        public Guid Factory {
            get {
                return factory;
            }
        }
        
        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.Priority"]' />
        /// <devdoc>
        ///     The priority of this extension registration.
        /// </devdoc>
        public int Priority {
            get {
                return priority;
            }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.ProjectGuid"]/*' />
        public string ProjectGuid {
            set { project = new System.Guid(value); }
            get { return project.ToString(); }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.EditorFactoryNotify"]/*' />
        public bool EditorFactoryNotify {
            get { return this.editorFactoryNotify; }
            set { this.editorFactoryNotify = value; }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.TemplateDir"]/*' />
        public string TemplateDir {
            get { return templateDir; }
            set { templateDir = value; }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.NameResourceID"]/*' />
        public int NameResourceID {
            get { return resId; }
            set { resId = value; }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.DefaultName"]/*' />
        public string DefaultName {
            get { return editorName; }
            set { editorName = value; }
        }

        /// <summary>
        ///        The reg key name of this extension.
        /// </summary>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}", Factory.ToString("B"));
            }
        }

        /// <summary>
        ///        The reg key name of the project.
        /// </summary>
        private string ProjectRegKeyName(RegistrationContext context) 
        {
            return string.Format(CultureInfo.InvariantCulture,
                                 "Projects\\{0}\\AddItemTemplates\\TemplateDirs\\{1}",
                                 project.ToString("B"),
                                 context.ComponentType.GUID.ToString("B"));
        }

        private string EditorFactoryNotifyKey {
            get { return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\FileExtensions\\{1}",
                                       project.ToString("B"),
                                       Extension);
            }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyEditorExtension, Extension, Factory.ToString("B")));

            using (Key editorKey = context.CreateKey(RegKeyName))
            {
                if (!string.IsNullOrEmpty(DefaultName))
                {
                    editorKey.SetValue(null, DefaultName);
                }
                if (0 != resId)
                    editorKey.SetValue("DisplayName", "#" + resId.ToString(CultureInfo.InvariantCulture));
                editorKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
            }

            using (Key extensionKey = context.CreateKey(RegKeyName + "\\Extensions"))
            {
                extensionKey.SetValue(Extension.Substring(1), Priority);
            }

            // Build the path of the registry key for the "Add file to project" entry
            if (project != Guid.Empty)
            {
                string prjRegKey = ProjectRegKeyName(context) + "\\/1";
                using (Key projectKey = context.CreateKey( prjRegKey ))
                {
                    if (0 != resId)
                        projectKey.SetValue("", "#" + resId.ToString(CultureInfo.InvariantCulture));
                    if (templateDir.Length != 0)
                    {
                        Uri url = new Uri(context.ComponentType.Assembly.CodeBase);
                        string templates = url.LocalPath;
                        templates = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(templates), templateDir);
                        templates = context.EscapePath( System.IO.Path.GetFullPath(templates) );
                        projectKey.SetValue("TemplatesDir", templates);
                    }
                    projectKey.SetValue("SortPriority", Priority);
                }
            }

            // Register the EditorFactoryNotify
            if ( EditorFactoryNotify )
            {
                // The IVsEditorFactoryNotify interface is called by the project system, so it doesn't make sense to
                // register it if there is no project associated to this editor.
                if (project == Guid.Empty)
                    throw new ArgumentException(Resources.Attributes_NoPrjForEditorFactoryNotify);

                // Create the registry key
                using (Key edtFactoryNotifyKey = context.CreateKey(EditorFactoryNotifyKey))
                {
                    edtFactoryNotifyKey.SetValue("EditorFactoryNotify", Factory.ToString("B"));
                }
            }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Unregister this editor.
        /// </devdoc>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName);
            if (project != Guid.Empty)
            {
                context.RemoveKey(ProjectRegKeyName(context));
                if (EditorFactoryNotify)
                    context.RemoveKey(EditorFactoryNotifyKey);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideOptionDialogPageAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideOptionPageAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideOptionDialogPageAttribute.uex' path='docs/doc[@for="ProvideOptionDialogPageAttribute"]' />
    /// <devdoc>
    /// This is the base class for all the attributes that are used to register an option page.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public abstract class ProvideOptionDialogPageAttribute : RegistrationAttribute {

        // The type of the option page provided with this attribute. This type must derive from DialogPage.
        private Type _pageType;
        // The id of the resource storing the localized name of the option page.
        private string _pageNameResourceId;

        /// <include file='doc\ProvideOptionDialogPageAttribute.uex' path='docs/doc[@for="ProvideOptionDialogPageAttribute.ProvideOptionDialogPageAttribute"]' />
        /// <devdoc>
        /// This is the constructor of this attribute; it will set the type of the proferred option page.
        /// </devdoc>
        /// <param name="pageType"></param>
        /// <param name="pageNameResourceId"></param>
        public ProvideOptionDialogPageAttribute(Type pageType, string pageNameResourceId)
        {
            // Check the input type: as first make sure this is not null...
            if (pageType == null) {
                throw new ArgumentNullException("pageType");
            }
            // .. then make sure that it derives from DialogPage.
            if (!typeof(DialogPage).IsAssignableFrom(pageType)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Package_PageNotDialogPage, pageType.FullName));
            }
            _pageType = pageType;
            _pageNameResourceId = pageNameResourceId;
        }

        /// <include file='doc\ProvideOptionDialogPageAttribute.uex' path='docs/doc[@for="ProvideOptionDialogPageAttribute.PageType"]' />
        /// <devdoc>
        /// Gets the type of the option page provided with this attribute.
        /// </devdoc>
        public Type PageType {
            get { return _pageType; }
        }

        /// <include file='doc\ProvideOptionDialogPageAttribute.uex' path='docs/doc[@for="ProvideOptionDialogPageAttribute.PageNameResourceId"]' />
        /// <devdoc>
        /// Gets the id of the resource storing the localized name of the option page.
        /// </devdoc>
        public string PageNameResourceId {
            get { return _pageNameResourceId; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideOptionPageAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideOptionPageAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers one or more option pages.  
    ///     Option pages are exposed to the user through Visual Studio's Tools->Options 
    ///     dialog.  The first parameter to this attribute is the type of option page, 
    ///     which is a type that must derive from DialogPage.  Option page attributes 
    ///     are read by the package class when Visual Studio requests a particular option 
    ///     page GUID.  Package will walk the attributes and try to match the requested 
    ///     GUID to a GUID on a type in the package. 
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideOptionPageAttribute : ProvideOptionDialogPageAttribute {

        private string  _categoryName;
        private string  _pageName;
        private short   _categoryResourceID;
        private bool    _supportsAutomation;
        private bool    _noShowAllView;
        private bool    _supportsProfiles = false;
        private ProfileMigrationType _migrationType = ProfileMigrationType.None;
        
        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.ProvideOptionPageAttribute"]' />
        /// <devdoc>
        ///     The page type is a type that derives from
        ///     DialogPage.  The nameResourceID
        ///     parameter specifies a Win32 resource ID in the 
        ///     stored in the native UI resource satellite
        ///     that describes the name of this page.
        ///     The categoryResourceID specifies the page
        ///     category name.
        /// </devdoc>        
        public ProvideOptionPageAttribute(Type pageType, string categoryName, string pageName, short categoryResourceID, short pageNameResourceID, bool supportsAutomation) 
            : base (pageType, "#"+pageNameResourceID.ToString()) {
            if (categoryName == null) {
                throw new ArgumentNullException("categoryName");
            }
            if (pageName == null) {
                throw new ArgumentNullException("pageName");
            }

            _categoryName = categoryName;
            _pageName = pageName;
            _categoryResourceID = categoryResourceID;
            _supportsAutomation = supportsAutomation;
        }

        /// <devdoc>
        /// The VB Simplified option page is visible only for "simply" pages, that is a page that sets this
        /// parameter to true.
        /// </devdoc>
        public bool NoShowAllView {
            get { return _noShowAllView;  }
            set { _noShowAllView = value; }
        }

        
        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.TypeId"]' />
        /// <devdoc>
        /// Identity of this instance of the attribute.
        /// </devdoc>
        public override object TypeId {
            get {
                return this;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.CategoryName"]' />
        /// <devdoc>
        ///     The programmatic name for this category (non localized).
        /// </devdoc>
        public string CategoryName {
            get {
                return _categoryName;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.CategoryResourceID"]' />
        /// <devdoc>
        ///     The native resourceID of the category name for this page.
        /// </devdoc>
        public short CategoryResourceID {
            get {
                return _categoryResourceID;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.PageName"]' />
        /// <devdoc>
        ///     The programmatic name for this page (non localized).
        /// </devdoc>
        public string PageName {
            get {
                return _pageName;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.SupportsAutomation"]' />
        /// <devdoc>
        ///     True if this page should be registered as supporting automation.
        /// </devdoc>
        public bool SupportsAutomation {
            get {
                return _supportsAutomation;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.SupportsProfiles"]' />
        /// <devdoc>
        ///     True if this page should be registered as supporting profiles.  
        ///     Note: Only works if SupportsAutomation is true.  The ProvideProfile attribute 
        ///     can also be used to specify profile support for Tools/Options pages.
        /// </devdoc>
        public bool SupportsProfiles {
            get {
                return _supportsProfiles;
            }
            set {
                _supportsProfiles = value;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.ProfileMigrationType"]' />
        /// <devdoc>
        ///     Specifies the migration action to take for this category.
        /// </devdoc>
        public ProfileMigrationType ProfileMigrationType
        {
            get { return _migrationType; }
            set { _migrationType = value; }
        }

        private string ToolsOptionsPagesRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "ToolsOptionsPages\\{0}", CategoryName); }
        }

        private string AutomationCategoryRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "AutomationProperties\\{0}", CategoryName); }
        }
        private string AutomationRegKey
        {
            get { return String.Format(CultureInfo.InvariantCulture, "{0}\\{1}", AutomationCategoryRegKey, PageName); }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyOptionPage, CategoryName, PageName));

            using (Key toolsOptionsKey = context.CreateKey(ToolsOptionsPagesRegKey))
            {
                toolsOptionsKey.SetValue(string.Empty, string.Format(CultureInfo.InvariantCulture, "#{0}", CategoryResourceID));
                toolsOptionsKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));

                using (Key pageKey = toolsOptionsKey.CreateSubkey(PageName))
                {
                    pageKey.SetValue(string.Empty, PageNameResourceId);
                    pageKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                    pageKey.SetValue("Page", PageType.GUID.ToString("B"));
                    if ( NoShowAllView )
                        pageKey.SetValue("NoShowAllView", 1);
                }
            }

            if (SupportsAutomation) {
                using (Key automationKey = context.CreateKey(AutomationRegKey))
                {
                    automationKey.SetValue("Name", string.Format(CultureInfo.InvariantCulture, "{0}.{1}", CategoryName, PageName));
                    automationKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                    if ( SupportsProfiles ) {
                        automationKey.SetValue("ProfileSave", 1);
                        automationKey.SetValue("VSSettingsMigration", (int)ProfileMigrationType);
                    }
                }
            }

        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ToolsOptionsPagesRegKey);

            if (SupportsAutomation)
            {
                context.RemoveKey(AutomationRegKey);
                context.RemoveKeyIfEmpty(AutomationCategoryRegKey);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideProfileAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideProfileAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProfileMigrationType"]/*' />
    public enum ProfileMigrationType
    {
        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProfileMigrationType.None"]/*' />
        None,
        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProfileMigrationType.PassThrough"]/*' />
        PassThrough,
        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProfileMigrationType.Custom"]/*' />
        Custom
    };

    /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute"]' />
    /// <devdoc>
    ///     This attribute declares a class as a Visual Studio Profile item and
    ///     places items in the VS registry for the User Settings.
    ///     This may optionally specify a Tools Options page.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideProfileAttribute : RegistrationAttribute {
        
        private Type    _objectType;
        private string  _groupName;
        private string  _categoryName;
        private string  _objectName;
        private string  _alternateParent;
        private string  _resourcePackageGuid;
        private short   _groupResourceID = 0;
        private short   _categoryResourceID = 0;
        private short   _objectNameResourceID = 0;
        private short   _descriptionResourceID = 0;
        private bool    _isToolsOptionPage;
        private ProfileMigrationType _migrationType = ProfileMigrationType.None;

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.ProvideProfileAttribute1"]' />
        /// <devdoc>
        /// </devdoc>        
        public ProvideProfileAttribute(Type objectType, string categoryName, string objectName, short categoryResourceID, short objectNameResourceID, bool isToolsOptionPage) {
            if (objectType == null) {
                throw new ArgumentNullException("objectType");
            }
            if (categoryName == null) {
                throw new ArgumentNullException("categoryName");
            }
            if (objectName == null) {
                throw new ArgumentNullException("objectName");
            }
            if (!typeof(IProfileManager).IsAssignableFrom(objectType)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.General_InvalidType, typeof(IProfileManager).FullName), objectType.FullName);
            }

            _objectType = objectType;
            _categoryName = categoryName;
            _objectName = objectName;
            _categoryResourceID = categoryResourceID;
            _objectNameResourceID = objectNameResourceID;
            _isToolsOptionPage = isToolsOptionPage;
        }


        /// <devdoc>
        ///     The programmatic name for this Group (non localized).
        /// </devdoc>
        public string GroupName
        {
            get { return _groupName; }
            set { _groupName = value; }
        }

        /// <devdoc>
        ///     The native resourceID of the group name for this page in the Profile.
        /// </devdoc>
        public short GroupResourceID
        {
            get { return _groupResourceID; }
            set { _groupResourceID = value; }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.CategoryName"]' />
        /// <devdoc>
        ///     The programmatic name for this category (non localized).
        /// </devdoc>
        public string CategoryName {
            get {
                return _categoryName;
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.CategoryResourceID"]' />
        /// <devdoc>
        ///     The native resourceID of the category name for this page.
        /// </devdoc>
        public short CategoryResourceID {
            get {
                return _categoryResourceID;
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.PageName"]' />
        /// <devdoc>
        ///     The programmatic name for this page (non localized).
        /// </devdoc>
        public string ObjectName {
            get {
                return _objectName;
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.PageNameResourceID"]' />
        /// <devdoc>
        ///     The native resourceID of the name for this page in the Profile.
        /// </devdoc>
        public short ObjectNameResourceID {
            get {
                return _objectNameResourceID;
            }
        }
        
        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.PageType"]' />
        /// <devdoc>
        ///     The type of this object.
        /// </devdoc>
        public Type ObjectType {
            get {
                return _objectType;
            }
        }
    
        /// <devdoc>
        ///     The Guid of a package providing the resource strings (only need to specify if this a different package).
        /// </devdoc>
        public string ResourcePackageGuid
        {
            get { return _resourcePackageGuid; }
            set { _resourcePackageGuid = value; }
        }

        /// <devdoc>
        ///     The native resourceID of the description for this page in the Profile.
        /// </devdoc>
        public short DescriptionResourceID
        {
            get { return _descriptionResourceID; }
            set { _descriptionResourceID = value; }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.AlternateParent"]' />
        /// <devdoc>
        ///     Allows the data to be parented under a different category in profile data.
        /// </devdoc>
        public string AlternateParent
        {
            get { return _alternateParent; }
            set { _alternateParent = value; }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.IsToolsOptionPage"]' />
        /// <devdoc>
        ///     Is this a Tools->Option page.
        /// </devdoc>

        public bool IsToolsOptionPage {
            get {
                return _isToolsOptionPage;
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.MigrationType"]' />
        /// <devdoc>
        ///     Specifies the migration action to take for this category.
        /// </devdoc>
        public ProfileMigrationType MigrationType
        {
            get { return _migrationType; }
            set { _migrationType = value; }
        }

        private string SettingsRegKey
        {
            get
            {
                if (String.IsNullOrEmpty(GroupName))
                    return string.Format(CultureInfo.InvariantCulture, "UserSettings\\{0}_{1}", CategoryName, ObjectName);
                else
                    return string.Format(CultureInfo.InvariantCulture, "UserSettings\\{0}\\{1}_{2}", GroupName, CategoryName, ObjectName);
            }
        }
     
        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyCreateObject, ObjectType.Name));

            if (!String.IsNullOrEmpty(GroupName) && GroupResourceID>0)
            {
                using (Key groupKey = context.CreateKey(String.Format(CultureInfo.InvariantCulture, "UserSettings\\{0}", GroupName)))
                {
                    groupKey.SetValue(string.Empty, GroupResourceID.ToString(CultureInfo.InvariantCulture));
                }
            }

            using (Key childKey = context.CreateKey(SettingsRegKey))
            {
                childKey.SetValue(string.Empty, ObjectNameResourceID.ToString(CultureInfo.InvariantCulture));
                childKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                childKey.SetValue("Category", ObjectType.GUID.ToString("B"));
                if(IsToolsOptionPage) {
                    childKey.SetValue("ToolsOptionsPath", CategoryName);
                }
                if (!String.IsNullOrEmpty(AlternateParent))
                    childKey.SetValue("AlternateParent", AlternateParent);
                if (!String.IsNullOrEmpty(ResourcePackageGuid))
                    childKey.SetValue("ResourcePackage", ResourcePackageGuid);
                if (DescriptionResourceID > 0)
                    childKey.SetValue("Description", DescriptionResourceID.ToString(CultureInfo.InvariantCulture));

                childKey.SetValue("VSSettingsMigration", (int)MigrationType);
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(SettingsRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideProjectItemAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideProjectItemAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell
{
    using System;
    using System.IO;
    using System.Diagnostics;
    using System.Globalization;


    /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute"]' />
    /// <devdoc>
    ///     This attribute associates register items to be included in the Add New Item.  
    ///     dialog for the specified project type. It is placed on a package.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideProjectItemAttribute : RegistrationAttribute
    {
        private int priority;
        private Guid factory;
        private string templateDir;
        private string itemType;

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.ProvideProjectItemAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public ProvideProjectItemAttribute(object projectFactoryType, string itemCategoryName, string templatesDir, int priority)
        {
            if (templatesDir == null || templatesDir.Length == 0)
                throw new ArgumentNullException("templatesDir");

            if (itemCategoryName == null || itemCategoryName.Length == 0)
                throw new ArgumentNullException("itemCategoryName");

            // figure out what type of object they passed in and get the GUID from it
            if (projectFactoryType is string)
                this.factory = new Guid((string)projectFactoryType);
            else if (projectFactoryType is Type)
                this.factory = ((Type)projectFactoryType).GUID;
            else if (projectFactoryType is Guid)
                this.factory = (Guid)projectFactoryType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, projectFactoryType));

            this.priority = priority;
            this.templateDir = templatesDir;
            this.itemType = itemCategoryName;
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.ProjectFactoryType"]' />
        /// <devdoc>
        ///     The Project factory guid.
        /// </devdoc>
        public Guid ProjectFactoryType
        {
            get {return factory;}
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.Priority"]' />
        /// <devdoc>
        ///     The priority of this item.
        /// </devdoc>
        public int Priority
        {
            get {return priority;}
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.TemplateDir"]/*' />
        public string TemplateDir
        {
            get { return templateDir; }
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.ItemType"]/*' />
        /// <summary>
        /// String describing the item type. This string is used as the folder in the
        /// left side of the "Add New Items" dialog.
        /// </summary>
        public string ItemType
        {
            get { return itemType; }
        }


        /// <summary>
        ///        The reg key name of the project.
        /// </summary>
        private string ProjectRegKeyName(RegistrationContext context) 
        {
            return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\AddItemTemplates\\TemplateDirs\\{1}\\/1",
                                factory.ToString("B"),
                                context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyProjectItems, factory.ToString("B")));

            using (Key childKey = context.CreateKey(ProjectRegKeyName(context)))
            {
                childKey.SetValue("", itemType);

                Uri url = new Uri(context.ComponentType.Assembly.CodeBase);
                string templates = url.LocalPath;
                templates = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(templates), templateDir);
                templates = context.EscapePath(System.IO.Path.GetFullPath(templates));
                childKey.SetValue("TemplatesDir", templates);

                childKey.SetValue("SortPriority", Priority);
            }
        }

        /// <include file='doc\ProvideProjectItemAttributeProjectItem.uex' path='docs/doc[@for="ProvideProjectItemAttribute.Unregister"]/*' />
        /// <summary>
        /// Unregister this editor.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ProjectRegKeyName(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideLanguageCodeExpansionAttribute.cs ===
﻿//////////////////////////////////////////////////////////////////////////////
// ProvideLanguageCodeExpansionAttribute
//
// This attribute class will ease the pain of registering a language
// service's support for code snippets written with the managed
// package framework.
//
// Usage:
// [ProvideLanguageCodeExpansionAttribute(<type> or "<GUID>",
//                                        <language name>,
//                                        <language name id>,
//                                        "<language identifier>",
//                                        "<Path to snippet index file>",
//   ShowRoots = true | false
//   SearchPaths = "<semi-colon-delimited path list to snippet index
//                  files>"
//   ForceCreateDirs = "<semi-colon-delimited list of dirs that the
//                  expansion manager will create>
// )]
//
//////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.Globalization;
using System.Runtime.InteropServices;
using System.ComponentModel.Design;
using Microsoft.Win32;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;

//namespace Vsip.TestPackage
namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute"]' />
    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideLanguageCodeExpansionAttribute : RegistrationAttribute
    {
        //////////////////////////////////////////////////////////////////////
        // ProvideLanguageServiceAttribute Private fields.
        //
        private Guid   languageServiceGuid;
        private string languageName;
        private string snippetIndexPath;
        private string searchPaths;
        private string forceCreateDirs;
        private string languageIdString;
        private string displayName;
        private bool   showRoots = false;


        //////////////////////////////////////////////////////////////////////
        // ProvideLanguageServiceAttribute Public Methods

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.ProvideLanguageCodeExpansionAttribute"]' />
        /// <devdoc>
        /// Registers a language service's support for code snippets.
        /// </devdoc>
        /// <param name="languageService">Language Service class. This can be a string with the value of the Guid or the Type of the language service.</param>
        /// <param name="languageName">Name of the language service.  Used in the registry so cannot be localized.</param>
        /// <param name="languageResourceId">Resource ID of the localized name of the language service.</param>
        /// <param name="languageIdentifier">String used to identify snippets and the snippets index file.</param>
        /// <param name="pathToSnippetIndexFile">Full path to a snippets index file.</param>
        public ProvideLanguageCodeExpansionAttribute(
            object languageService,
            string languageName,
            int languageResourceId,
            string languageIdentifier,
            string pathToSnippetIndexFile)
        {
            // Get the guid of the language service.
            if (languageService is Type)
            {
                this.languageServiceGuid = ((Type)languageService).GUID;
            }
            else if (languageService is string)
            {
                this.languageServiceGuid = new Guid((string)languageService);
            }
            else
                throw new ArgumentException();

            this.languageName     = languageName;
            this.snippetIndexPath = pathToSnippetIndexFile;
            this.displayName      = languageResourceId.ToString(CultureInfo.InvariantCulture);
            this.languageIdString = languageIdentifier;
        }

        // ProvideLanguageCodeExpansionAttribute Properties.

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.LanguageServiceSid"]' />
        public Guid LanguageServiceSid
        {
            get { return languageServiceGuid; }
        }

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.LanguageName"]' />
        public string LanguageName
        {
            get { return languageName; }
        }


        //////////////////////////////////////////////////////////////////////
        // The following properties are entries in the language key.  These
        // are all optional (however, if they are specified by the user, they
        // will be created in the registry, regardless if they have a value or
        // not).

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.ShowRoots"]' />
        public bool ShowRoots
        {
            get { return showRoots; }
            set { showRoots = value; }
        }

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.SearchPaths"]' />
        public string SearchPaths
        {
            get { return searchPaths; }
            set { searchPaths = value; }
        }

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.ForceCreateDirs"]' />
        public string ForceCreateDirs
        {
            get { return forceCreateDirs; }
            set { forceCreateDirs = value; }
        }
        //////////////////////////////////////////////////////////////////////
        // Helper property
        private string LanguageRegistryKey
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0}\\{1}",
                                     RegistryPaths.codeExpansion,
                                     LanguageName);
            }
        }

        
        //////////////////////////////////////////////////////////////////////
        // ProvideLanguageCodeExpansionAttribute Public Methods.

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.Register"]' />
        public override void Register(RegistrationAttribute.RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLanguageCodeExpansion, LanguageServiceSid.ToString("B")));

            string packageGuid = context.ComponentType.GUID.ToString("B");
            // Create our top-most language key
            using (Key serviceKey = context.CreateKey(LanguageRegistryKey))
            {
                // Add specific entries corresponding to arguments to
                // ProvideLanguageCodeExpansionAttribute constructor.
                serviceKey.SetValue(string.Empty, LanguageServiceSid.ToString("B"));
                serviceKey.SetValue(RegistryPaths.package, packageGuid);
                serviceKey.SetValue(RegistryPaths.displayName, displayName);
                serviceKey.SetValue(RegistryPaths.languageStringId, languageIdString);
                serviceKey.SetValue(RegistryPaths.indexPath, snippetIndexPath);
                serviceKey.SetValue(RegistryPaths.showRoots, showRoots ? 1 : 0);
                if (!string.IsNullOrEmpty(SearchPaths))
                {
                    using (Key pathsKey = serviceKey.CreateSubkey(RegistryPaths.paths))
                    {
                        pathsKey.SetValue(LanguageName, SearchPaths);
                    }
                }
                if (!string.IsNullOrEmpty(ForceCreateDirs))
                {
                    using (Key forceCreateKey = serviceKey.CreateSubkey(RegistryPaths.forceCreateDirs))
                    {
                        forceCreateKey.SetValue(LanguageName, ForceCreateDirs);
                    }
                }
            }
        }

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.Unregister"]' />
        public override void Unregister(RegistrationAttribute.RegistrationContext context)
        {
            context.RemoveKey(LanguageRegistryKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideToolboxItemConfigurationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideToolboxItemConfigurationAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using System.Globalization;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="ProvideToolboxItemConfigurationAttribute"]' />
    /// <devdoc>
    ///    Registers a confugration object for toolbox items.
    ///    ProvideToolboxItemConfigurationAttribute attached to the package.  This attribute will register 
    ///    the object under the local CLSID hive in the VS registry and also add a reference to the GUID in
    ///    VSREGROOT\ToolboxItemConfiguration.  The data contained in this registry entry
    ///    is as follows:
    /// 
    ///    VSREGROOT\ToolboxItemConfiguration
    ///        AssemblyName
    ///             ConfigurationTypeName={guid}
    /// 
    ///    As an example:
    /// 
    ///    VSREGROOT\ToolboxItemConfiguration
    ///        System, Version=2.0.3500
    ///            CompactFrameworkProvider = {GUID}
    /// 
    /// 
    ///    The assembly name is parsed and the various keys are matched.  Keys can have a
    ///    "*" in them to be taken as wildcards.  So, for example, to cover all versions
    ///    of System.WindowsForms you would specify:
    /// 
    ///    System.Windows.Forms, Version=*, PublicKeyToken=969...
    /// 
    ///    The assembly name may also be a wildcard to load the configuration object
    ///    for all toolbox items (not recommended).  
    /// 
    ///    Place this attribute on your package, and then place one or more ProvideAssemblyFilter attributes
    ///    on the class that implements IConfigureToolboxItem.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited = true, AllowMultiple = true)]
    public sealed class ProvideToolboxItemConfigurationAttribute : RegistrationAttribute {
        private Type _objectType;

        /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="ProvideToolboxItemConfigurationAttribute.ProvideToolboxItemConfigurationAttribute"]' />
        /// <devdoc>
        ///    Constructor
        /// </devdoc>
        public ProvideToolboxItemConfigurationAttribute(Type objectType) {
            if (objectType == null) {
                throw new ArgumentNullException("objectType");
            }

            _objectType = objectType;
        }

        /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="ProvideToolboxItemConfigurationAttribute.ConfigurationType"]' />
        /// <devdoc>
        ///    The configuration type to use.
        /// </devdoc>
        public Type ObjectType {
            get {
                return _objectType;
            }
        }

        private string CLSIDRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "CLSID\\{0}", ObjectType.GUID.ToString("B")); }
        }

        private string GetItemCfgFilterKey(string filter)
        {
            return string.Format(CultureInfo.InvariantCulture, "ToolboxItemConfiguration\\{0}", filter);
        }

        /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyToolboxItemConfiguration, ObjectType.Name));

            using (Key childKey = context.CreateKey(CLSIDRegKey))
            {
                childKey.SetValue(string.Empty, ObjectType.FullName);
                childKey.SetValue("InprocServer32", context.InprocServerPath);
                childKey.SetValue("Class", ObjectType.FullName);
                if (context.RegistrationMethod == RegistrationMethod.CodeBase)
                {
                    childKey.SetValue("Codebase", context.CodeBase);
                }
                else
                {
                    childKey.SetValue("Assembly", ObjectType.Assembly.FullName);
                }
                childKey.SetValue("ThreadingModel", "Both");
            }
            
            string guid = ObjectType.GUID.ToString("B");
            // Now, look up the object type and look for assembly filters.
            foreach (object attr in ObjectType.GetCustomAttributes(typeof(ProvideAssemblyFilterAttribute), true)) {
                ProvideAssemblyFilterAttribute filter = (ProvideAssemblyFilterAttribute)attr;
                context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyToolboxItemFilter, filter.AssemblyFilter)); 
                using (Key itemCfgKey = context.CreateKey(GetItemCfgFilterKey(filter.AssemblyFilter)))
                {
                    itemCfgKey.SetValue(ObjectType.FullName, guid);
                }
            }
        }

        /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(CLSIDRegKey);

            // Now, look up the object type and remove assembly filters.
            foreach (object attr in ObjectType.GetCustomAttributes(typeof(ProvideAssemblyFilterAttribute), true)) {
                ProvideAssemblyFilterAttribute filter = (ProvideAssemblyFilterAttribute)attr;
                context.RemoveKey(GetItemCfgFilterKey(filter.AssemblyFilter));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideToolboxFormatAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideToolboxFormatAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <include file='doc\ProvideToolboxFormatAttribute.uex' path='docs/doc[@for="ProvideToolboxFormatAttribute"]' />
    /// <devdoc>
    ///     This attribute declares a single toolbox clipboard format that
    ///     the package supports.  Multiple attributes can be added to
    ///     a package to allow more than one clipboard format.  By
    ///     providing this attribute on your package, you enable
    ///     users to drag data objects containing this format onto the
    ///     toolbox. You must still handle the drop notifications 
    ///     yourself.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited=true, AllowMultiple=true)]
    public sealed class ProvideToolboxFormatAttribute : Attribute {

        private string _format;
    
        /// <include file='doc\ProvideToolboxFormatAttribute.uex' path='docs/doc[@for="ProvideToolboxFormatAttribute.ProvideToolboxFormatAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideToolboxFormatAttribute.
        /// </devdoc>
        public ProvideToolboxFormatAttribute(string format) {

            if (format == null) {
                throw new ArgumentNullException("format");
            }

            _format = format;
        }
    
        /// <include file='doc\ProvideToolboxFormatAttribute.uex' path='docs/doc[@for="ProvideToolboxFormatAttribute.Format"]' />
        /// <devdoc>
        ///     Returns the clipboard format to enable for this package.
        /// </devdoc>
        public string Format {
            get {
                return _format;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideServiceAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideServiceAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideServiceAttribute.uex' path='docs/doc[@for="ProvideServiceAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package provides a particular service.  The attributes on a 
    ///     package do not control the behavior of the package, but they can be used by registration 
    ///     tools to register the proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideServiceAttribute : RegistrationAttribute {

        private string _name;
        private Guid _serviceGuid;
        private Type _serviceType;

        /// <param name="serviceType"></param>
        public ProvideServiceAttribute(object serviceType)
        {
            _serviceType = null;
            // figure out what type of object they passed in and get the GUID from it
            if (serviceType is string)
                _serviceGuid = new Guid((string)serviceType);
            else if (serviceType is Type)
            {
                _serviceType = (Type)serviceType;
                _serviceGuid = _serviceType.GUID;
                _name = _serviceType.Name;
            }
            else if (serviceType is Guid)
                _serviceGuid = (Guid)serviceType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, serviceType));
        }

        /// <summary>
        /// Name of the service
        /// </summary>
        public string ServiceName
        {
            get {return _name;}
            set {_name = value;}
        }

        /// <summary>
        /// Type of the service.
        /// </summary>
        public Type Service
        {
            get { return _serviceType; }
        }

        /// <include file='doc\ProvideServiceAttribute.uex' path='docs/doc[@for="ProvideServiceAttribute.ServiceType"]' />
        /// <devdoc>
        ///     Returns the service's Guid declared in this attribute.
        /// </devdoc>
        public Guid ServiceType {
            get {
                return _serviceGuid;
            }
        }

        private string ServiceRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Services\\{0}", ServiceType.ToString("B")); }
        }

        /// <include file='doc\ProvideServiceAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyService, ServiceName));

            using (Key serviceKey = context.CreateKey(ServiceRegKey))
            {
                serviceKey.SetValue(string.Empty, context.ComponentType.GUID.ToString("B"));
                serviceKey.SetValue("Name", ServiceName);
            }
        }

        /// <summary>
        /// Unregisters this attribute.
        /// </summary>
        /// <param name="context">
        ///     Contains the location from where the registration inforomation should be removed.
        ///     It also contains other informations as the type being unregistered and path information.
        /// </param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ServiceRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideToolWindowVisibilityAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterToolWindowVisibilityAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// Declares that a tool window is should be visible when a certain command
    /// UI guid becomes active.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideToolWindowVisibilityAttribute : RegistrationAttribute {

        private string _name;
        private Guid _toolwindow;
        private Guid _commandUIGuid;

        /// <summary>
        /// Creates a new attribute for a specific tool window and a command UI guid.
        /// </summary>
        /// <param name="toolWindow">The tool window Type or Guid (as string).</param>
        /// <param name="commandUIGuid">The command UI guid that controls the tool window's visibility.</param>
        public ProvideToolWindowVisibilityAttribute(object toolWindow, string commandUIGuid)
        {
            if (toolWindow is Type)
            {
                Type t = (Type)toolWindow;
                _toolwindow = t.GUID;
                _name = t.Name;
            }
            else if (toolWindow is string)
                _toolwindow = new Guid(toolWindow as string);
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.General_InvalidType, typeof(System.Type).FullName), "toolWindow");
            _commandUIGuid = new Guid(commandUIGuid);
        }

        /// <summary>
        /// Get the command UI guid controlling the visibility of the tool window.
        /// </summary>
        public Guid CommandUIGuid
        {
            get { return _commandUIGuid; }
        }

        /// <summary>
        /// Get or Set name of the toolwindow.
        /// This does not impact the runtime behavior.
        /// </summary>
        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }

        private string RegistryPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "ToolWindows\\{0}\\Visibility", _toolwindow.ToString("B")); }
        }

        /// <summary>
        /// Called to register this attribute with the given context.  The context
        /// contains the location where the registration information should be placed.
        /// it also contains such as the type being registered, and path information.
        /// </summary>
        public override void Register(RegistrationContext context)
        {
            // Write to the context's log what we are about to do
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyToolVisibility, _name, CommandUIGuid.ToString("B")));

            // Create the visibility key.
            using (Key childKey = context.CreateKey(RegistryPath))
            {
                // Set the value for the command UI guid.
                childKey.SetValue(CommandUIGuid.ToString("B"), 0);
            }
        }

        /// <summary>
        /// Unregister this visibility entry.
        /// </summary>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveValue(RegistryPath, CommandUIGuid.ToString("B"));
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideToolboxPageAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideToolboxPageAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers one or more toolbox pages.  Toolbox pages are 
    ///     exposed to the user through Visual Studio's customize toolbox dialog.  A toolbox page must 
    ///     derive from DialogPage. Toolbox page 
    ///     attributes are read by the package class when Visual Studio requests a particular property 
    ///     page GUID.  Package will walk the attributes and try to match the requested GUID to a 
    ///     GUID on a type in the package. 
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideToolboxPageAttribute : ProvideOptionDialogPageAttribute {

        private short   _pageOrder;
        private string  _helpKeyword;

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.ProvideToolboxPageAttribute"]' />
        /// <devdoc>
        ///     The page type is a type that implements
        ///     IWin32Window.  The nameResourceID
        ///     parameter specifies a Win32 resource ID in the 
        ///     stored in the native UI resource satellite
        ///     that describes the name of this page.
        /// </devdoc>
        public ProvideToolboxPageAttribute(Type pageType, short nameResourceID) : this(pageType, nameResourceID, 0) {
        }
        
        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.TypeId"]' />
        /// <devdoc>
        /// Identity of this instance of the attribute.
        /// </devdoc>
        public override object TypeId {
            get {
                return this;
            }
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.ProvideToolboxPageAttribute1"]' />
        /// <devdoc>
        ///     The page type is a type that implements
        ///     IWin32Window.  The nameResourceID
        ///     parameter specifies a Win32 resource ID in the 
        ///     stored in the native UI resource satellite
        ///     that describes the name of this page.  Page order is 
        ///     optional and defaults to zero.  If non-zero, a registry entry will be
        ///     created named DefaultTbx, which specifies the sort order of the
        ///     toolbox pages.
        /// </devdoc>
        public ProvideToolboxPageAttribute(Type pageType, short nameResourceID, short pageOrder) : this(pageType, nameResourceID, pageOrder, null) {
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.ProvideToolboxPageAttribute1"]' />
        /// <devdoc>
        ///     The page type is a type that implements
        ///     IWin32Window.  The nameResourceID
        ///     parameter specifies a Win32 resource ID in the 
        ///     stored in the native UI resource satellite
        ///     that describes the name of this page.  Page order is 
        ///     optional and defaults to zero.  If non-zero, a registry entry will be
        ///     created named DefaultTbx, which specifies the sort order of the
        ///     toolbox pages.
        ///     Helpkeyword is a keyword exposed to F1 help (support for this was added by joshs -- reference VS Whidbey#262176)
        /// </devdoc>
        public ProvideToolboxPageAttribute(Type pageType, short nameResourceID, short pageOrder, string helpKeyword) 
            : base(pageType, "#"+nameResourceID.ToString()) {

            _pageOrder = pageOrder;
            _helpKeyword = helpKeyword;
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.HelpKeyword"]' />
        /// <devdoc>
        /// Returns the help keyword associated with this toolbox page.
        /// </devdoc>
        public string HelpKeyword {
            get {
                return _helpKeyword;
            }
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.PageOrder"]' />
        /// <devdoc>
        ///     The sort order of the page or zero if this page should be left unsorted.
        /// </devdoc>
        public short PageOrder {
            get {
                return _pageOrder;
            }
        }
        
        private string ToolboxPageRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "ToolboxPages\\{0}", PageType.FullName); }
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyToolboxPage, PageType.Name));

            using (Key childKey = context.CreateKey(ToolboxPageRegKey))
            {
                childKey.SetValue(string.Empty, PageNameResourceId);
                childKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                childKey.SetValue("Page", PageType.GUID.ToString("B"));
                if (PageOrder != 0) {
                    childKey.SetValue("DefaultTbx", PageOrder);
                }
                if (_helpKeyword != null && _helpKeyword.Length > 0) {
                    childKey.SetValue("HelpKeyword", _helpKeyword);
                }
            }
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ToolboxPageRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideViewAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideViewAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <include file='doc\ProvideViewAttribute.uex' path='docs/doc[@for="ProvideViewAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that an editor factory offers a particular logical view.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideViewAttribute : Attribute {

        private LogicalView _logicalView;
        private string      _physicalView;

        /// <include file='doc\ProvideViewAttribute.uex' path='docs/doc[@for="ProvideViewAttribute.ProvideViewAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideViewAttribute.
        /// </devdoc>
	    public ProvideViewAttribute (LogicalView logicalView, string physicalView) {
            _logicalView = logicalView;
            _physicalView = physicalView;   // NULL is valid here.
        }

        /// <include file='doc\ProvideViewAttribute.uex' path='docs/doc[@for="ProvideViewAttribute.LogicalView"]' />
        /// <devdoc>
        ///     Returns the logical view in this attribute.
        /// </devdoc>
	    public LogicalView LogicalView {
            get {
                return _logicalView;
            }
        }

        /// <include file='doc\ProvideViewAttribute.uex' path='docs/doc[@for="ProvideViewAttribute.PhysicalView"]' />
        /// <devdoc>
        ///     Returns the physical view that is mapped to the logical view.
        /// </devdoc>
	    public string PhysicalView {
            get {
                return _physicalView;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\RegisterAutoLoadAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <summary>
    ///     This attribute registers the package as an extender.  The GUID passed in determines
    ///     what is being extended. The attributes on a package do not control the behavior of
    ///     the package, but they can be used by registration tools to register the proper
    ///     information with Visual Studio.
    /// </summary>
    [Obsolete("RegisterAutoLoadAttribute has been deprecated. Please use ProvideAutoLoadAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterAutoLoadAttribute : RegistrationAttribute {

        private Guid loadGuid = Guid.Empty;

        /// <summary>
        ///     Specify that the package should get loaded when this context is active.
        /// </summary>
        /// <param name="cmdUiContextGuid">Context which should trigger the loading of your package.</param>
        public RegisterAutoLoadAttribute(string cmdUiContextGuid) 
        {
            loadGuid = new Guid(cmdUiContextGuid);
        }

        /// <summary>
        /// Context Guid which triggers the loading of the package.
        /// </summary>
        public Guid LoadGuid
        {
            get
            {
                return loadGuid;
            }
        }

        /// <summary>
        ///        The reg key name of this AutoLoad.
        /// </summary>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "AutoLoadPackages\\{0}", loadGuid.ToString("B"));
            }
        }

        /// <summary>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration information should be placed.
        ///     it also contains such as the type being registered, and path information.
        /// </summary>
        public override void Register(RegistrationContext context) 
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyAutoLoad, loadGuid.ToString("B")));

            using (Key childKey = context.CreateKey(RegKeyName))
                        {
                childKey.SetValue(context.ComponentType.GUID.ToString("B"), 0);
            }
        }

        /// <summary>
        /// Unregister this AutoLoad specification.
        /// </summary>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveValue(RegKeyName, context.ComponentType.GUID.ToString("B"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\providelanguageServiceAttribute.cs ===
﻿//////////////////////////////////////////////////////////////////////////////
// ProvideLanguageServiceAttribute
//
// This attribute class will ease the pain of registering a language service
// written in managed code.
//
// To add editor Tool Options Pages, use ProvideLanguageEditorOptionPageAttribute.
// To add code expansion support, use ProvideLanguageCodeExpansionAttribute.
//
// Usage:
// [ProvideLanguageServiceAttribute(<type>,<language name>,<language name id>,
//    DebuggerLanguageExpressionEvaluator = "{guid}"
//    ShowCompetion = true | false
//    ShowSmartIndent = true | false
//    RequestStockColors = true | false
//    ShowHotURLs = true | false
//    DefaultToNonHotURLs = true | false
//    DefaultToInsertSpaces = true | false
//    ShowDropDownOptions = true | false
//    SingleCodeWindowOnly = true | false
//    EnableAdvancedMembersOption = true | false
//    SupportCopyPasteOfHTML = true | false
//    EnableLineNumbers = true | false
//    HideAdvancedMembersByDefault = true | false
//    CodeSense = true | false
//    MatchBraces = true | false
//    QuickInfo = true | false
//    ShowMatchingBrace = true | false
//    MatchBracesAtCaret = true | false
//    MaxErrorMessages = <number>
//    CodeSenseDelay = <number>
//    EnableAsyncCompletion = true | false
//    EnableCommenting = true | false
//    EnableFormatSelection = true | false
//    AutoOutlining = true | false
// )]
//
// Notes:
// * All named options are optional.
// 
//
// <type>             is the type of the class implementing the language
//                    service.  The language GUID is obtained from this.
// <language name>    Name of the language to be used as a registry key name.
// <language name id> resource id of localized language name which Visual
//                    Studio will show to the user.
//
// LocalizedName      literal text or #ddd (resource id of localized name)
//                    This name is used for the string put into the tree list
//                    of options in Visual Studio's Tools Options dialog.
//                    This value appears as the default value for the
//                    GroupName and ItemName registry keys.  If not specified,
//                    the GroupName or ItemName is substituted.
// GroupName          Registry key name.  This acts as a node in the tree list
//                    of options.
// ItemName           Registry key name which has a registry entry that
//                    specifies the guid of an option page to show.
//
// Note: All GroupName and ItemName keys contain an additional registry entry
//       for the package guid (which is derived internally and does not have
//       to be specified in the attribute).
//////////////////////////////////////////////////////////////////////////////

#region Using directives

using System;
using System.Diagnostics;
using System.Collections;
using System.Globalization;
using System.Runtime.InteropServices;
using System.ComponentModel.Design;
using Microsoft.Win32;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;

#endregion

namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute"]' />
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideLanguageServiceAttribute : RegistrationAttribute
    {
        // ProvideLanguageServiceAttribute Private fields.
        //
        private Guid                languageServiceGuid;
        private string              strLanguageName;
        private int                 languageResourceID;
        private Hashtable           optionsTable;
        private DebuggerLanguages   debuggerLanguages;


        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ProvideLanguageServiceAttribute"]' />
        /// <devdoc>
        /// Registers a language service.
        /// </devdoc>
        /// <param name="languageService"></param>
        /// <param name="strLanguageName"></param>
        /// <param name="languageResourceID"></param>
        public ProvideLanguageServiceAttribute(
            object languageService,
            string strLanguageName,
            int languageResourceID)
        {
            if (languageService is Type)
                this.languageServiceGuid = ((Type)languageService).GUID;
            else if (languageService is string)
                this.languageServiceGuid = new Guid((string)languageService);
            else
                throw new ArgumentException();
            this.strLanguageName     = strLanguageName;
            this.languageResourceID  = languageResourceID;

            debuggerLanguages   = new DebuggerLanguages(strLanguageName);
            optionsTable = new Hashtable();
        }

        // ProvideLanguageServiceAttribute Properties.

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.LanguageServiceSid"]' />
        public Guid LanguageServiceSid
        {
            get { return languageServiceGuid; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.LanguageName"]' />
        public string LanguageName
        {
            get { return strLanguageName; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.LanguageResourceID"]' />
        public int LanguageResourceID
        {
            get { return languageResourceID; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.DebuggerLanguageExpressionEvaluator"]' />
        /// <devdoc>
        /// Establish an expression evaluator for debugging languages.
        /// </devdoc>
        public string DebuggerLanguageExpressionEvaluator
        {
            get { return debuggerLanguages.ExpressionEvaluator.ToString("B"); }
            set { debuggerLanguages.ExpressionEvaluator = new Guid(value); }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowCompletion"]' />
        public bool ShowCompletion
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showCompletion];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showCompletion] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowSmartIndent"]' />
        public bool ShowSmartIndent
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showIndentOptions];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showIndentOptions] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.RequestStockColors"]' />
        public bool RequestStockColors
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.useStockColors];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.useStockColors] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowHotURLs"]' />
        public bool ShowHotURLs
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showHotURLs];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showHotURLs] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.DefaultToNonHotURLs"]' />
        public bool DefaultToNonHotURLs
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.nonHotURLs];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.nonHotURLs] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.DefaultToInsertSpaces"]' />
        public bool DefaultToInsertSpaces
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.insertSpaces];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.insertSpaces] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowDropDownOptions"]' />
        public bool ShowDropDownOptions
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showDropDownBar];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showDropDownBar] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.SingleCodeWindowOnly"]' />
        public bool SingleCodeWindowOnly
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.disableWindowNewWindow];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.disableWindowNewWindow] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableAdvancedMembersOption"]' />
        public bool EnableAdvancedMembersOption
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableAdvMembersOption];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableAdvMembersOption] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.SupportCopyPasteOfHTML"]' />
        public bool SupportCopyPasteOfHTML
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.supportCF_HTML];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.supportCF_HTML] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableLineNumbers"]' />
        public bool EnableLineNumbers
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableLineNumbersOption];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableLineNumbersOption] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.HideAdvancedMembersByDefault"]' />
        public bool HideAdvancedMembersByDefault
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.hideAdvancedMembersByDefault];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.hideAdvancedMembersByDefault] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.CodeSense"]' />
        public bool CodeSense
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.codeSense];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.codeSense] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.MatchBraces"]' />
        public bool MatchBraces
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.matchBraces];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.matchBraces] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.QuickInfo"]' />
        public bool QuickInfo
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.quickInfo];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.quickInfo] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowMatchingBrace"]' />
        public bool ShowMatchingBrace
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showMatchingBrace];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showMatchingBrace] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.MatchBracesAtCaret"]' />
        public bool MatchBracesAtCaret
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.matchBracesAtCaret];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.matchBracesAtCaret] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.MaxErrorMessages"]' />
        public int MaxErrorMessages
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.maxErrorMessages];
                return (null == val) ? 0 : (int)val;
            }
            set { optionsTable[LanguageOptionKeys.maxErrorMessages] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.CodeSenseDelay"]' />
        public int CodeSenseDelay
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.codeSenseDelay];
                return (null == val) ? 0 : (int)val;
            }
            set { optionsTable[LanguageOptionKeys.codeSenseDelay] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableAsyncCompletion"]' />
        public bool EnableAsyncCompletion
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableAsyncCompletion];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableAsyncCompletion] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableCommenting"]' />
        public bool EnableCommenting
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableCommenting];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableCommenting] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableFormatSelection"]' />
        public bool EnableFormatSelection
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableFormatSelection];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableFormatSelection] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.AutoOutlining"]' />
        public bool AutoOutlining
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.autoOutlining];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.autoOutlining] = value; }
        }


        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.LanguageServicesKeyName"]' />
        private string LanguageServicesKeyName
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0}\\{1}",
                                     RegistryPaths.languageServices,
                                     LanguageName);
            }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.Register"]' />
        public override void Register(RegistrationAttribute.RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLanguageService, LanguageName, LanguageServiceSid.ToString("B")));

            // Create our top-most language key
            using (Key serviceKey = context.CreateKey(LanguageServicesKeyName))
            {
                // Add specific entries corresponding to arguments to
                // ProvideLanguageServiceAttribute constructor.
                serviceKey.SetValue(string.Empty, LanguageServiceSid.ToString("B"));
                serviceKey.SetValue(RegistryPaths.package, context.ComponentType.GUID.ToString("B"));
                serviceKey.SetValue(RegistryPaths.languageResourceId, languageResourceID);

                // Now add any explicitly specified options.
                string name;
                string value;
                foreach(object item in optionsTable.Keys)
                {
                    name = item.ToString();
                    if (optionsTable[item] is bool)
                    {
                        // Bool values are special-cased as they need to
                        // be written as 0 or 1 instead of false or true.
                        int nValue = 0;
                        if ((bool)optionsTable[item])
                        {
                            nValue = 1;
                        }
                        serviceKey.SetValue(name, nValue);
                    }
                    else if (optionsTable[item] is int)
                    {
                        serviceKey.SetValue(name, (int)optionsTable[item]);
                    }
                    else
                    {
                        // If not bool type, always write the value as a
                        // string.
                        value = optionsTable[item].ToString();
                        serviceKey.SetValue(name, value);
                    }
                }
                if (debuggerLanguages.IsValid())
                {
                    // If any debugger language options have been specified then...
                    // Note: we are assuming there can be only one of these entries
                    // for each language service.
                    string eeRegName = string.Format(CultureInfo.InvariantCulture, 
                                                     "{0}\\{1}", 
                                                     RegistryPaths.debuggerLanguages, 
                                                     debuggerLanguages.ExpressionEvaluator.ToString("B"));
                    using (Key dbgLangKey = serviceKey.CreateSubkey(eeRegName))
                    {
                        dbgLangKey.SetValue(null, debuggerLanguages.LanguageName);
                    }
                }
            }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.Unregister"]' />
        public override void Unregister(RegistrationAttribute.RegistrationContext context)
        {
            context.RemoveKey(LanguageServicesKeyName);
        }

        // Local classes.

        // DebuggerLanguages encapsulates all elements under the
        // "Debugger Languages" registry key.  There are only two entries
        // ever under this key and that's a language name and a guid of an
        // expression evaluator.
        private class DebuggerLanguages
        {
            //////////////////////////////////////////////////////////////////
            // DebuggerLanguages Private fields.
            private Guid   guidEE;    // Expression Evaluator Guid
            private string languageName;

            //////////////////////////////////////////////////////////////////
            // DebuggerLanguages Public methods.
            public DebuggerLanguages(string languageName)
            {
                this.languageName = languageName;
                guidEE = Guid.Empty;
            }
            /// <summary>
            /// Guid of the expression evaluator.
            /// </summary>
            /// <value>Guid</value>
            public Guid ExpressionEvaluator
            {
                get { return guidEE; }
                set { guidEE = value; }
            }

            public string LanguageName
            {
                get { return languageName; }
            }

            /// <summary>
            /// Determine whether the debugger language options have been set.
            /// </summary>
            /// <returns>bool</returns>
            public bool IsValid()
            {
                return guidEE != Guid.Empty;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideLanguageEditorOptionPageAttribute.cs ===
﻿//////////////////////////////////////////////////////////////////////////////
// RegisterLanguageServiceAttribute
//
// Provide a general method for setting a language service's editor tool
// option page.
//
// This information is stored in the registry key
// <RegistrationRoot>\Languages\Language Services\[language]\EditorToolsOptions
// where [language] is the name of the language.
//
// Under EditorToolsOptions is a tree of pages and sub-pages that can
// nest any number of levels.  These pages correspond to options pages
// displayed in the Visual Studio Tools Options for editors (where the
// language name is displayed under which is a tree of option pages, each
// page containing appropriate options).
//
// Each key in this option page list contains a resoure id or literal
// string containing the localized name of the page (this is what is
// actually shown in the Tools Options dialog).  In addition, it also
// contains a package GUID and optionally a GUID of an option page.
//
// If there is no option page GUID then the key is considered a node in the
// tree of options and has no associated page.  Otherwise, the key is
// a leaf in the tree and its option page will be shown.
//
// Example:
// root base key: HKLM\Software\Microsoft\VisualStudio\8.0
//   Languages\
//     Language Services\
//       CSharp\
//         EditorToolsOptions\
//           Formatting\ = sz:#242
//             General\ = sz:#255
//               Package = sz:{GUID}
//               Page = sz:{GUID}
//             Indentation\ = sz:#250
//               Package = sz:{GUID}
//               Page = sz:{GUID}
//
// Goal:
// LanguageEditorOptionPage("CSharp","Formatting","#242");
// LanguageEditorOptionPage("CSharp","Formatting\General","#255","{PAGE GUID}");
// LanguageEditorOptionPage("CSharp","Formatting\Indentation","#250","{PAGE GUID}");
//
//////////////////////////////////////////////////////////////////////////////

#region Using directives

using System;
using System.Diagnostics;
using System.Collections;
using System.Globalization;
using System.Runtime.InteropServices;
using System.ComponentModel.Design;
using Microsoft.Win32;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;
using MSVSIP = Microsoft.VisualStudio.Shell;

#endregion

namespace Microsoft.VisualStudio.Shell
{
    internal class LanguageToolsOptionCreator {
        // This class is used only to expose some static member, so we declare a private constructor
        // to avoid the creation of any instance of it.
        private LanguageToolsOptionCreator() { }

        private static string FormatRegKey(string languageName, string categoryName) {

            string strRegKey =
                string.Format(CultureInfo.InvariantCulture,
                              "{0}\\{1}\\{2}\\{3}",
                              RegistryPaths.languageServices,
                              languageName,
                              RegistryPaths.editorToolsOptions,
                              categoryName);
            return strRegKey;
        }

        internal static void CreateRegistryEntries(RegistrationAttribute.RegistrationContext context, string languageName, string categoryName, string categoryResourceId, Guid pageGuid)
        {

            using (RegistrationAttribute.Key serviceKey = context.CreateKey(FormatRegKey(languageName, categoryName))) {
                // Add specific entries corresponding to arguments to
                // constructor.
                serviceKey.SetValue(string.Empty, categoryResourceId);
                serviceKey.SetValue(RegistryPaths.package, context.ComponentType.GUID.ToString("B"));
                if (pageGuid != Guid.Empty) {
                    serviceKey.SetValue(RegistryPaths.page, pageGuid.ToString("B"));
                }
            }
        }

        internal static void RemoveRegistryEntries(RegistrationAttribute.RegistrationContext context, string languageName, string categoryName) {

            context.RemoveKey(FormatRegKey(languageName, categoryName));
        }
    }

    /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorToolsOptionCategoryAttribute"]' />
    /// <devdoc>
    /// This attribute is used to declare a ToolsOption category for a language.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideLanguageEditorToolsOptionCategoryAttribute : RegistrationAttribute {
        private string languageName;
        private string categoryName;
        private string categoryResourceId;

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorToolsOptionCategoryAttribute.ProvideLanguageEditorToolsOptionCategoryAttribute"]' />
        /// <devdoc>
        /// Creates a new ProvideLanguageEditorToolsOptionCategory attribute for a given language and category.
        /// </devdoc>
        /// <param name="languageName">The name of the language.</param>
        /// <param name="categoryName">The name of the category.</param>
        /// <param name="categoryResourceId">The id of the resource with the localized name for the category.</param>
        public ProvideLanguageEditorToolsOptionCategoryAttribute(string languageName, string categoryName, string categoryResourceId) {
            this.languageName = languageName;
            this.categoryName = categoryName;
            this.categoryResourceId = categoryResourceId;
        }

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorToolsOptionCategoryAttribute.Register"]' />
        public override void Register(RegistrationAttribute.RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLanguageOptionCategory, languageName, categoryName));

            // Create the registry entries using the creator object.
            LanguageToolsOptionCreator.CreateRegistryEntries(context, languageName, categoryName, categoryResourceId, Guid.Empty);
        }

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorToolsOptionCategoryAttribute.Unregister"]' />
        public override void Unregister(RegistrationAttribute.RegistrationContext context) {
            // Remove the entries using the creator object.
            LanguageToolsOptionCreator.RemoveRegistryEntries(context, languageName, categoryName);
        }
    }

    /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute"]' />
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideLanguageEditorOptionPageAttribute : ProvideOptionDialogPageAttribute
    {
        private string languageName;
        private string pageName;
        private string category;

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.ProvideLanguageEditorOptionPageAttribute"]' />
        /// <devdoc>
        /// Constructor for node with child option pages (to be added with
        /// additional ProvideLanguageEditorOptionPageAttribute).
        /// </devdoc>
        public ProvideLanguageEditorOptionPageAttribute(
            Type pageType,
            string languageName,
            string category,
            string pageName,
            string pageNameResourceId
            ) : base(pageType, pageNameResourceId)
        {
            this.languageName = languageName;
            this.pageName = pageName;
            this.category = category;
        }

        //////////////////////////////////////////////////////////////////////
        // Properties.

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.LanguageName"]' />
        public string LanguageName
        {
            get { return languageName; }
        }

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.PageGuid"]' />
        public Guid PageGuid
        {
            get { return PageType.GUID; }
        }

        private string FullPathToPage {
            get {
                if (string.IsNullOrEmpty(category))
                    return pageName;
                return string.Format("{0}\\{1}", category, pageName);
            }
        }
        //////////////////////////////////////////////////////////////////////
        // Public methods.

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.Register"]' />
        public override void Register(RegistrationAttribute.RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLanguageOptionPage, LanguageName, PageNameResourceId));

            // Create the registry entries using the creator object.
            LanguageToolsOptionCreator.CreateRegistryEntries(context, LanguageName, FullPathToPage, PageNameResourceId, PageGuid);
        }

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.Unregister"]' />
        public override void Unregister(RegistrationAttribute.RegistrationContext context)
        {
            // Remove the registry entries for this page.
            LanguageToolsOptionCreator.RemoveRegistryEntries(context, LanguageName, FullPathToPage);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\RegisterEditorLogicalViewAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute adds a logical view to the editor created by an editor factory.
    /// </summary>
    [Obsolete("RegisterEditorLogicalViewAttribute has been deprecated. Please use ProvideEditorLogicalViewAttribute instead.")]
	[AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterEditorLogicalViewAttribute : RegistrationAttribute
    {
        private Guid factory;
        private Guid logicalView;

        /// <summary>
        /// Creates a new RegisterEditorLogicalView attribute to register a logical
        /// view provided by your editor.
        /// </summary>
        /// <param name="factoryType">The type of factory; can be a Type, a GUID or a string representation of a GUID</param>
        /// <param name="logicalViewGuid">The guid of the logical view to register.</param>
        public RegisterEditorLogicalViewAttribute(object factoryType, string logicalViewGuid)
        {
            this.logicalView = new Guid(logicalViewGuid);
			
            // figure out what type of object they passed in and get the GUID from it
            if (factoryType is string)
                this.factory = new Guid((string)factoryType);
            else if (factoryType is Type)
                this.factory = ((Type)factoryType).GUID;
            else if (factoryType is Guid)
                this.factory = (Guid)factoryType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, factoryType));

        }

        /// <summary>
        /// Get the Guid representing the type of the editor factory
        /// </summary>
        public Guid FactoryType
        {
            get {return factory;}
        }

        /// <summary>
        /// Get the Guid representing the logical view
        /// </summary>
        public Guid LogicalView
        {
            get {return logicalView;}
        }

        private string LogicalViewPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}\\LogicalViews", factory.ToString("B")); }
        }


        /// <summary>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     It also contains other information such as the type being registered and path information.
        /// </summary>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyEditorView, logicalView.ToString("B")));

            using (Key childKey = context.CreateKey( LogicalViewPath ))
            {
                childKey.SetValue(logicalView.ToString("B"), "");
            }
        }

        /// <summary>
        /// Unregister this logical view.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveValue(LogicalViewPath, logicalView.ToString("B"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\RegisterExtenderAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <summary>
    ///     This attribute registers the package as an extender.  The GUID passed in determines
    ///     what is being extended. The attributes on a package do not control the behavior of
    ///     the package, but they can be used by registration tools to register the proper
    ///     information with Visual Studio.
    /// </summary>
    [Obsolete("RegisterExtenderAttribute has been deprecated. Please use ProvideExtenderAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterExtenderAttribute : RegistrationAttribute {

        private Guid CATID = Guid.Empty;
        private Guid extender = Guid.Empty;
        private string name;

        /// <summary>
        ///     Creates a new RegisterExtenderAttribute.
        /// </summary>
        /// <param name="extendeeCatId">CatId of the element you want to extend.</param>
        /// <param name="extenderGuid">GUID of the extender.</param>
        /// <param name="extenderName">Name of the element you want to extend.</param>
        public RegisterExtenderAttribute(string extendeeCatId, string extenderGuid, string extenderName) 
        {
            CATID = new Guid(extendeeCatId);
            extender = new Guid(extenderGuid);
            name = extenderName;
        }

        /// <summary>
        /// The CatID of the element being extended.
        /// </summary>
        public Guid ExtendeeCatId {
            get {
                return CATID;
            }
        }

        /// <summary>
        /// The Guid of the extender.
        /// </summary>
        public Guid Extender {
            get {
                return extender;
            }
        }

        /// <summary>
        /// The name of the extender.
        /// </summary>
        public string ExtenderName {
            get {
                return name ;
            }
        }

        /// <summary>
        ///        The reg key name of this Extender.
        /// </summary>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "Extenders\\{0}\\{1}", CATID.ToString("B"), name);
            }
        }

        /// <summary>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration information should be placed.
        ///     it also contains such as the type being registered, and path information.
        /// </summary>
        public override void Register(RegistrationContext context) 
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyExtender, name, CATID.ToString("B")));

            using (Key childKey = context.CreateKey(RegKeyName))
            {
                // Set default value for the Key = Extender GUID
                childKey.SetValue(string.Empty, extender.ToString("B"));
            }
        }

        /// <summary>
        /// Unregister this Extender specification.
        /// </summary>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\RegisterLanguageExtensionAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterLanguageExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute"]' />
    /// <devdoc>
    ///     This attribute associates a file extension to a given editor factory.  
    ///     The editor factory may be specified as either a GUID or a type and 
    ///     is placed on a package.
    /// </devdoc>
    [Obsolete("RegisterLanguageExtensionAttribute has been deprecated. Please use ProvideLanguageExtensionAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterLanguageExtensionAttribute : RegistrationAttribute {

        private Guid languageService;
        private string extension;
        
        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute.RegisterLanguageExtensionAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public RegisterLanguageExtensionAttribute (string languageServiceGuid, string extension) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_ExtensionNeedsDot, extension));
            }

            this.languageService = new Guid(languageServiceGuid);
            this.extension = extension;
        }
        
        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute.RegisterLanguageExtensionAttribute1"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public RegisterLanguageExtensionAttribute (Type languageService, string extension) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_ExtensionNeedsDot, extension));
            }

            this.languageService = languageService.GUID;
            this.extension = extension;
        }
        
        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute.Extension"]' />
        /// <devdoc>
        ///     The file extension of the file.
        /// </devdoc>
        public string Extension {
            get {
                return extension;
            }
        }
        
        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute.LanguageService"]' />
        /// <devdoc>
        ///     The language service SID.
        /// </devdoc>
        public Guid LanguageService {
            get {
                return languageService;
            }
        }

        private string ExtensionsRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Languages\\File Extensions\\{0}", Extension); }
        }

        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLanguageExtension, Extension, LanguageService.ToString("B")));

            using (Key childKey = context.CreateKey(ExtensionsRegKey))
            {
                childKey.SetValue(string.Empty, LanguageService.ToString("B"));
            }
        }

        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context) {
            context.RemoveKey(ExtensionsRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\RegisterLoadKeyAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterLoadKeyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute"]' />
    /// <devdoc>
    ///     This attribute registers a package load key for your package.  
    ///     Package load keys are used by Visual Studio to validate that 
    ///     a package can be loaded.    
    /// </devdoc>
    [Obsolete("RegisterLoadKeyAttribute has been deprecated. Please use ProvideLoadKeyAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, Inherited=false, AllowMultiple=false)]
    public sealed class RegisterLoadKeyAttribute : RegistrationAttribute {

        private string _minimumEdition;
        private string _productVersion;
        private string _productName;
        private string _companyName;
        private short  _resourceId;
    
        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.RegisterLoadKeyAttribute"]/*' />
        public RegisterLoadKeyAttribute (string minimumEdition, string productVersion, string productName, string companyName, short resourceId) {
            if (minimumEdition == null) {
                throw new ArgumentNullException("minimumEdition");
            }
            if (productVersion == null) {
                throw new ArgumentNullException("productVersion");
            }
            if (productName == null) {
                throw new ArgumentNullException("productName");
            }
            if (companyName == null) {
                throw new ArgumentNullException("companyName");
            }
            
            _minimumEdition = minimumEdition;
            _productVersion = productVersion;
            _productName = productName;
            _companyName = companyName;
            _resourceId = resourceId;
        }
        
        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.MinEdition"]' />
        /// <devdoc>
        ///     Minimum edition of Visual Studio on which
        ///     VSPackage is loaded. This must be the literal 
        ///     edition value provided by Microsoft when 
        ///     obtaining your PLK.
        /// </devdoc>
        public string MinimumEdition {
            get {
                return _minimumEdition;
            }
        }

        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.ProductVersion"]' />
        /// <devdoc>
        ///     Version of the product that this VSPackage
        ///     implements.
        /// </devdoc>
        public string ProductVersion {
            get {
                return _productVersion;
            }
        }
        
        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.ProductName"]' />
        /// <devdoc>
        ///     Name of the product that this VSPackage 
        ///     delivers. Note that one product might be
        ///     comprised of multiple VSPackages, in which 
        ///     case each will need its own PLK.
        /// </devdoc>
        public string ProductName {
            get {
                return _productName;
            }
        }

        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.CompanyName"]' />
        /// <devdoc>
        ///     VSIP Partner/creator of the VSPackage. 
        ///     The literal name (case-sensitive) provided 
        ///     to Microsoft when registering for a PLK.
        /// </devdoc>
        public string CompanyName {
            get {
                return _companyName;
            }
        }
        
        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.ResourceId"]' />
        /// <devdoc>
        ///     Resource ID for VSPackage load key.
        /// </devdoc>
        public short ResourceId {
            get {
                return _resourceId;
            }
        }

        /// <summary>
        /// Registry Key name for this package's load key information.
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        public string RegKeyName (RegistrationContext context)
        {
            return string.Format(CultureInfo.InvariantCulture, "Packages\\{0}", context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyLoadKey, CompanyName, ProductName, ProductVersion, MinimumEdition));

            using (Key packageKey = context.CreateKey(RegKeyName(context)))
            {
                packageKey.SetValue("ID", ResourceId);
                packageKey.SetValue("MinEdition", MinimumEdition);
                packageKey.SetValue("ProductVersion", ProductVersion);
                packageKey.SetValue("ProductName", ProductName);
                packageKey.SetValue("CompanyName", CompanyName);
            }
        }

        /// <summary>
        /// Unregisters this package's load key information
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName(context));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\RegisterProjectItem.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterProjectItemAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell
{
    using System;
    using System.IO;
    using System.Diagnostics;
    using System.Globalization;


    /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute"]' />
    /// <devdoc>
    ///     This attribute associates register items to be included in the Add New Item.  
    ///     dialog for the specified project type. It is placed on a package.
    /// </devdoc>
	[Obsolete("RegisterProjectItemAttribute has been deprecated. Please use ProvideProjectItemAttribute instead.")]    
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterProjectItemAttribute : RegistrationAttribute
    {
        private int priority;
        private Guid factory;
        private string templateDir;
        private string itemType;

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.RegisterProjectItemAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public RegisterProjectItemAttribute(object projectFactoryType, string itemCategoryName, string templatesDir, int priority)
        {
            if (templatesDir == null || templatesDir.Length == 0)
                throw new ArgumentNullException("templatesDir");

            if (itemCategoryName == null || itemCategoryName.Length == 0)
                throw new ArgumentNullException("itemCategoryName");

            // figure out what type of object they passed in and get the GUID from it
            if (projectFactoryType is string)
                this.factory = new Guid((string)projectFactoryType);
            else if (projectFactoryType is Type)
                this.factory = ((Type)projectFactoryType).GUID;
            else if (projectFactoryType is Guid)
                this.factory = (Guid)projectFactoryType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, projectFactoryType));

            this.priority = priority;
            this.templateDir = templatesDir;
            this.itemType = itemCategoryName;
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.ProjectFactoryType"]' />
        /// <devdoc>
        ///     The Project factory guid.
        /// </devdoc>
        public Guid ProjectFactoryType
        {
            get {return factory;}
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.Priority"]' />
        /// <devdoc>
        ///     The priority of this item.
        /// </devdoc>
        public int Priority
        {
            get {return priority;}
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.TemplateDir"]/*' />
        public string TemplateDir
        {
            get { return templateDir; }
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.ItemType"]/*' />
        /// <summary>
        /// String describing the item type. This string is used as the folder in the
        /// left side of the "Add New Items" dialog.
        /// </summary>
        public string ItemType
        {
            get { return itemType; }
        }


        /// <summary>
        ///        The reg key name of the project.
        /// </summary>
        private string ProjectRegKeyName(RegistrationContext context) 
        {
            return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\AddItemTemplates\\TemplateDirs\\{1}\\/1",
                                factory.ToString("B"),
                                context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyProjectItems, factory.ToString("B")));

            using (Key childKey = context.CreateKey(ProjectRegKeyName(context)))
            {
                childKey.SetValue("", itemType);

                Uri url = new Uri(context.ComponentType.Assembly.CodeBase, true);
                string templates = url.LocalPath;
                templates = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(templates), templateDir);
                templates = context.EscapePath(System.IO.Path.GetFullPath(templates));
                childKey.SetValue("TemplatesDir", templates);

                childKey.SetValue("SortPriority", Priority);
            }
        }

        /// <include file='doc\RegisterProjectItem.uex' path='docs/doc[@for="RegisterProjectItemAttribute.Unregister"]/*' />
        /// <summary>
        /// Unregister this editor.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ProjectRegKeyName(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\Package.cs ===
//------------------------------------------------------------------------------
// <copyright file="Package.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing.Design;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Resources;
    using System.Runtime.InteropServices;
    using System.Threading;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;

    using AssemblyEnumerationService = Microsoft.VisualStudio.AssemblyEnumerationService;
    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\Package.uex' path='docs/doc[@for="Package"]' />
    /// <devdoc>
    ///     This class implements IVsPackage.  It provides a 
    ///     framework-friendly way to define a package and its associated 
    ///     services.
    /// </devdoc>
    [PackageRegistrationAttribute()]
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class Package : 

        IVsPackage, 
        IOleServiceProvider,
        IOleCommandTarget,
        IVsPersistSolutionOpts, 
        IServiceContainer,
        IVsUserSettings,
        IVsUserSettingsMigration,
        IVsToolWindowFactory
    {

        static private int          _sitedPackageCount = 0;
        static private ServiceProvider _globalProvider = null;
        private ServiceProvider     _provider;
        private Hashtable           _services;
        private Hashtable           _editorFactories;
        private Hashtable           _projectFactories;
        private ToolWindowCollection _toolWindows;         // this is the list of all toolwindows
        private Container           _componentToolWindows; // this is the toolwindows that implement IComponent
        private Container           _pagesAndProfiles;
        private ArrayList           _optionKeys;

        private enum ProfileManagerLoadAction
        {
            None,
            LoadPropsFromRegistry,
            ResetSettings
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.Package"]' />
        /// <devdoc>
        ///     Simple constructor.
        /// </devdoc>
        protected Package() {
            ServiceCreatorCallback callback = new ServiceCreatorCallback(OnCreateService);
            ((IServiceContainer)this).AddService(typeof(IMenuCommandService), callback);
            ((IServiceContainer)this).AddService(typeof(IOleCommandTarget), callback);
        }
    
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ToolboxInitialized"]' />
        /// <devdoc>
        ///     This event is raised when the toolbox is freshly initialized.
        ///     If you provide tools for the toolbox you should add them when
        ///     this event is raised.
        /// </devdoc>
        protected event EventHandler ToolboxInitialized;
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ToolboxUpgraded"]' />
        /// <devdoc>
        ///     This event is raised when the toolbox is upgraded to a
        ///     new version.  You should perform any work needed to
        ///     upgrade the toolbox here.
        /// </devdoc>
        protected event EventHandler ToolboxUpgraded;

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ApplicationRegistryRoot"]' />
        /// <devdoc>
        ///     This property returns the registry root for the application.
        ///     Typically this is HKLM\Software\Microsoft\VisualStudio\[ver]
        ///     but this can change based on any alternate root that the
        ///     shell was initialized with.  This key is read-only.
        /// </devdoc>
        public RegistryKey ApplicationRegistryRoot {
            get {
                return VSRegistry.RegistryRoot(_provider, __VsLocalRegistryType.RegType_Configuration, false);
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.UserDataPath"]' />
        /// <devdoc>
        ///     This property returns the path to user data storage for
        ///     Visual Studio.  Typically this is %USERPROFILE%\Application Data\
        ///     Visual Studio\[ver] but this can change based on any
        ///     alternate root that the shell was initialized with.
        /// </devdoc>
        public string UserDataPath {
            get {
                // Get the registry root and remove the SOFTWARE\ part
                string registryRoot = GetRegistryRoot();
                registryRoot = registryRoot.Substring("SOFTWARE\\".Length);
    
                string appData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
    
                return Path.Combine(appData, registryRoot);
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.UserDataPath"]' />
        /// <devdoc>
        ///     This property returns the path to user data storage for
        ///     Visual Studio.  Typically this is %USERPROFILE%\Local Settings\Application Data\
        ///     Visual Studio\[ver] but this can change based on any
        ///     alternate root that the shell was initialized with.
        /// </devdoc>
        public string UserLocalDataPath {
            get {
                // Get the registry root and remove the SOFTWARE\ part
                string registryRoot = GetRegistryRoot();
                registryRoot = registryRoot.Substring("SOFTWARE\\".Length);
    
                string appData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
    
                return Path.Combine(appData, registryRoot);
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.UserRegistryRoot"]' />
        /// <devdoc>
        ///     This property returns the registry root for the current
        ///     user.  Typically this is HKCU\Software\Microsoft\VisualStudio\[ver]
        ///     but this can change based on any alternate root that the shell
        ///     is initialized with.  This key is read-write.
        /// </devdoc>
        public RegistryKey UserRegistryRoot {
            get {
                return VSRegistry.RegistryRoot(_provider, __VsLocalRegistryType.RegType_UserSettings, true);
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.AddOptionKey"]' />
        /// <devdoc>
        ///     This method adds a user option key name into the list of
        ///     option keys that we will load and save from the solution
        ///     file.  You should call this early in your constructor.
        ///     Calling this will cause the OnLoadOptions and
        ///     OnSaveOptions methods to be invoked for each key you
        ///     add.
        /// </devdoc>
        protected void AddOptionKey(string name) {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (name == null) {
                throw new ArgumentNullException("name");
            }

            // the key is the class name of the service interface.  Note that
            // while it would be a lot more correct to use the fully-qualified class
            // name, IStorage won't have it and returns STG_E_INVALIDNAME.  The
            // doc's don't have any information here; I can only assume it is because
            // of the '.'.

            // clovett: According to the docs for IStorage::CreateStream, the name
            // cannot be longer than 31 characters.
            if (name.IndexOf('.') != -1 || name.Length > 31) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Package_BadOptionName, name));
            }

            if (_optionKeys == null) {
                _optionKeys = new ArrayList();
            }
            else {
                if (_optionKeys.Contains(name)) {
                    throw new ArgumentException(string.Format(Resources.Culture, Resources.Package_OptionNameUsed, name));
                }
            }
            _optionKeys.Add(name);
        }



        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ExportSettings"]' />
        /// <devdoc>
        ///     This method implements the IVsUserSettings Interface
        ///     used to manage profiles and import/export settings
        ///     to XML files.
        /// </devdoc>
        int IVsUserSettings.ExportSettings(string strPageGuid, IVsSettingsWriter writer) {
            Debug.Assert(strPageGuid != null && strPageGuid.Length > 0, "Passed page guid cannot be null");
            Debug.Assert(writer != null, "IVsSettingsWriter cannot be null");

            Guid requestPageGuid = new Guid(strPageGuid);
            IProfileManager profileManager = GetProfileManager(requestPageGuid, ProfileManagerLoadAction.LoadPropsFromRegistry);
            if(profileManager != null) {
                profileManager.SaveSettingsToXml(writer);
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.MigrateSettings"]' />
        /// <devdoc>
        ///     This method implements the IVsUserSettingsMigration Interface
        ///     used to bring forward user settings from a previous version.
        /// </devdoc>
        int IVsUserSettingsMigration.MigrateSettings(IVsSettingsReader reader, IVsSettingsWriter writer, string strPageGuid) {
            
            Debug.Assert(strPageGuid != null && strPageGuid.Length > 0, "Passed page guid cannot be null");
            Debug.Assert(reader != null, "IVsSettingsReader cannot be null");
            Debug.Assert(writer != null, "IVsSettingsWriter cannot be null");

            Guid requestPageGuid = Guid.Empty;

            try
            {
                requestPageGuid = new Guid(strPageGuid);
            }
            catch (FormatException)
            {
                // If this is thrown, it means strPageGuid is not really a GUID, but rather a
                // tools options page name like "Environment.General".
            }

            IProfileMigrator profileMigrator = null;

            if (requestPageGuid == Guid.Empty)
            {
                profileMigrator = GetAutomationObject(strPageGuid) as IProfileMigrator;
            }
            else
            {
                profileMigrator = GetProfileManager(requestPageGuid, ProfileManagerLoadAction.None) as IProfileMigrator;
            }

            if(profileMigrator != null) {
                profileMigrator.MigrateSettings(reader, writer);
            }
            return NativeMethods.S_OK;
        }


        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ImportSettings"]' />
        /// <devdoc>
        ///     This method implements the IVsUserSettings Interface
        ///     used to manage profiles and import/export settings
        ///     to XML files.
        /// </devdoc>
        int IVsUserSettings.ImportSettings(string strPageGuid, IVsSettingsReader reader, uint flags, ref int restartRequired) {

            // nobody should require a restart...
            if (restartRequired > 0)
                restartRequired = 0;

            Debug.Assert(strPageGuid != null && strPageGuid.Length > 0, "Passed page guid cannot be null");
            Debug.Assert(reader != null, "IVsSettingsReader cannot be null");

            bool loadPropsFromRegistry = (flags & (uint)__UserSettingsFlags.USF_ResetOnImport) == 0;

            Guid requestPageGuid = new Guid(strPageGuid);
            IProfileManager profileManager = GetProfileManager(requestPageGuid, loadPropsFromRegistry ? ProfileManagerLoadAction.LoadPropsFromRegistry : ProfileManagerLoadAction.ResetSettings);
            if(profileManager != null) {
                // we get the live instance (if any) when we load
                profileManager.LoadSettingsFromXml(reader);
                // update the store
                profileManager.SaveSettingsToStorage();
            }
            return NativeMethods.S_OK;
        }


        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.Dispose"]' />
        /// <devdoc>
        ///     This method will be called by Visual Studio in reponse
        ///     to a package close (disposing will be true in this
        ///     case).  The default implementation revokes all
        ///     services and calls Dispose() on any created services
        ///     that implement IDisposable.
        /// </devdoc>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        protected virtual void Dispose(bool disposing) {
            if (disposing) {

                // Unregister any registered editor factories.
                //
                if (_editorFactories != null)
                {
                    Hashtable editorFactories = _editorFactories;
                    _editorFactories = null;

                    try {
                        IVsRegisterEditors registerEditors = GetService(typeof(SVsRegisterEditors)) as IVsRegisterEditors;
                        foreach (DictionaryEntry de in editorFactories) {
                            try {
                                if (registerEditors != null) {
                                    // Don't check for the return value because, even if this unregister fails,
                                    // we have anyway to try to unregister the others.
                                    registerEditors.UnregisterEditor((uint)de.Value);
                                }
                            }
                            catch (Exception) { /* do nothing */ }
                            finally {
                                IDisposable disposable = de.Key as IDisposable;
                                if (disposable != null) {
                                    disposable.Dispose();
                                }
                            }
                        }
                    }
                    catch (Exception e) {
                        Debug.Fail(String.Format("Failed to dispose editor factories for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }
                // Unregister any registered project factories.
                //
                if (_projectFactories != null)
                {
                    Hashtable projectFactories = _projectFactories;
                    _projectFactories = null;
                    try
                    {
                        IVsRegisterProjectTypes registerProjects = GetService(typeof(SVsRegisterProjectTypes)) as IVsRegisterProjectTypes;

                        foreach (DictionaryEntry de in projectFactories)
                        {
                            try
                            {
                                if (registerProjects != null)
                                {
                                    // As above, don't check for the return value.
                                    registerProjects.UnregisterProjectType((uint)de.Value);
                                }
                            }
                            finally
                            {
                                IDisposable disposable = de.Key as IDisposable;
                                if (disposable != null)
                                {
                                    disposable.Dispose();
                                }
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        Debug.Fail(String.Format("Failed to dispose project factories for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }

                // Dispose all IComponent ToolWindows
                //
                if (_componentToolWindows != null)
                {
                    Container componentToolWindows = _componentToolWindows;
                    _componentToolWindows = null;
                    try
                    {
                        componentToolWindows.Dispose();
                    }
                    catch (Exception e)
                    {
                        Debug.Fail(String.Format("Failed to dispose component toolwindows for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }

                // Dispose all pages.
                //
                if (_pagesAndProfiles != null)
                {
                    Container pagesAndProfiles = _pagesAndProfiles;
                    _pagesAndProfiles = null;
                    try
                    {
                        pagesAndProfiles.Dispose();
                    }
                    catch (Exception e)
                    {
                        Debug.Fail(String.Format("Failed to dispose component toolwindows for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }

                // Enumerate the service list and destroy all services.  This should
                // always be done last.
                //
                if (_services != null)
                {
                    try
                    {
                        IProfferService ps = (IProfferService)GetService(typeof(SProfferService));
                        Hashtable services = _services;
                        _services = null;

                        foreach (object value in services.Values)
                        {

                            object service = value;
                            ProfferedService proffer = service as ProfferedService;
                            try
                            {
                                if (null != proffer)
                                {
                                    service = proffer.Instance;
                                    if (proffer.Cookie != 0 && ps != null)
                                    {
                                        int hr = ps.RevokeService(proffer.Cookie);
                                        if (NativeMethods.Failed(hr))
                                        {
                                            Debug.Fail(String.Format(CultureInfo.CurrentUICulture, "Failed to unregister service {0}", service.GetType().FullName));
                                            Trace.WriteLine(String.Format(CultureInfo.CurrentUICulture, "Failed to unregister service {0}", service.GetType().FullName));
                                        }
                                    }
                                }
                            }
                            finally
                            {
                                if (service is IDisposable)
                                {
                                    ((IDisposable)service).Dispose();
                                }
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        Debug.Fail(String.Format("Failed to dispose proffered service for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }

                // Disallow any service requests after this.
                //
                if (_provider != null)
                {
                    // If the service provider for the current package is the service provider that we use globally
                    // do not dispose yet. Once all packages deriving from Package are disposed we will dispose it.
                    if (_provider != _globalProvider)
                    {
                        try
                        {
                            _provider.Dispose();
                        }
                        catch (Exception e)
                        {
                            Debug.Fail(String.Format("Failed to dispose the global service provider for package {0}\n{1}", this.GetType().FullName, e.Message));
                        }
                    }
                    _provider = null;
                }

                if (_toolWindows != null)
                {
                    _toolWindows.Dispose();
                    _toolWindows = null;
                }

                if (_optionKeys != null)
                {
                    _optionKeys = null;
                }

                // Disconnect user preference change events
                //
                SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(OnUserPreferenceChanged);
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetAutomationObject"]' />
        /// <devdoc>
        ///     This method returns the automation object for this package.
        ///     The default implementation will return null if name is null, indicating there
        ///     is no default automation object.  If name is non null, this will walk metadata
        ///     attributes searching for an option page that has a name of the format
        ///     &lt;Category&gt;.&lt;Name&gt;.  If the option page has this format and indicates that it
        ///     supports automation, its automation object will be returned.
        /// </devdoc>
        protected virtual object GetAutomationObject(string name) {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (name == null) {
                return null;
            }

            string[] nameParts = name.Split(new char[] {'.'});
            if (nameParts.Length != 2) {
                return null;
            }

            nameParts[0] = nameParts[0].Trim();
            nameParts[1] = nameParts[1].Trim();

            AttributeCollection attributes = TypeDescriptor.GetAttributes(this);
            foreach(Attribute attr in attributes) {
                ProvideOptionPageAttribute pa = attr as ProvideOptionPageAttribute;
                if (pa != null && pa.SupportsAutomation) {

                    // Check to see if the name matches.
                    //
                    if (string.Compare(pa.CategoryName, nameParts[0], StringComparison.OrdinalIgnoreCase) != 0) {
                        continue;
                    }

                    if (string.Compare(pa.PageName, nameParts[1], StringComparison.OrdinalIgnoreCase) != 0) {
                        continue;
                    }

                    // Ok, the name matches.  Return this page's automation object.
                    //
                    DialogPage page = GetDialogPage(pa.PageType);
                    return page.AutomationObject;
                }
            }

            // Failed.
            //
            return null;
        }

        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetDialogPage"]' />
        /// <devdoc>
        ///     This method returns the requested dialog page.  Dialog
        ///     pages are cached so they can keep a single instance
        ///     of their state.  This method allows a deriving class
        ///     to get a cached dialog page.  The object will be 
        ///     dynamically created if it is not in the cache.
        /// </devdoc>
        protected DialogPage GetDialogPage(Type dialogPageType) {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (dialogPageType == null) {
                throw new ArgumentNullException("dialogPageType");
            }

            if (!typeof(DialogPage).IsAssignableFrom(dialogPageType)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Package_BadDialogPageType, dialogPageType.FullName));
            }

            if (_pagesAndProfiles != null) {
                foreach(object page in _pagesAndProfiles.Components) {
                    if (page.GetType() == dialogPageType) {
                        return (DialogPage)page;
                    }
                }
            }

            // Create a new instance of this option page.
            //
            ConstructorInfo ctor = dialogPageType.GetConstructor(new Type[] {});
            if (ctor == null) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Package_PageCtorMissing, dialogPageType.FullName));
            }

            DialogPage p = (DialogPage)ctor.Invoke(new object[] {});
            
                        
            if (_pagesAndProfiles == null) {
                _pagesAndProfiles = new PackageContainer(this);
            }
            _pagesAndProfiles.Add(p);

            return p;
        }


        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetProfileManager"]' />
        /// <devdoc>
        ///     This method returns the requested profile manager based on its guid.
        ///     Profile managers are cached so they can keep a single instance
        ///     of their state.  This method allows a deriving class
        ///     to get a cached profile manager.  The object will be 
        ///     dynamically created if it is not in the cache.
        /// </devdoc>
        private IProfileManager GetProfileManager(Guid objectGuid, ProfileManagerLoadAction loadAction) {
            
            IProfileManager result = null;

            if(objectGuid == Guid.Empty) {
                throw new ArgumentNullException("objectGuid");
            }
            if (_pagesAndProfiles != null) {
                foreach(object profileManager in _pagesAndProfiles.Components) {
                    if (profileManager.GetType().GUID.Equals(objectGuid)) {
                        if (profileManager is IProfileManager)
                        {
                            result = profileManager as IProfileManager;
                            if (result != null)
                            {
                                switch (loadAction) {
                                    case ProfileManagerLoadAction.LoadPropsFromRegistry:
                                        result.LoadSettingsFromStorage();
                                        break;
                                    case ProfileManagerLoadAction.ResetSettings:
                                        result.ResetSettings();
                                        break;
                                }
                            }
                        }

                        // No need to keep on looking in the attributes since
                        // we've found the one we were looking for.

                        break;
                    }
                }
            }

            if (result == null) {

                // Didn't find it in our cache.  Now look in the metadata attributes
                // for the class.  Look at all types at the same time.
                //
                AttributeCollection attributes = TypeDescriptor.GetAttributes(this);
                foreach(Attribute attr in attributes) {
                    if (attr is ProvideProfileAttribute) {
                        Type objectType = ((ProvideProfileAttribute)attr).ObjectType;
                        if (objectType.GUID.Equals(objectGuid)) {

                            // found it... now instanciate since it was not in the cache
                            // if not build a constructor for it

                            ConstructorInfo ctor = objectType.GetConstructor(new Type[] {});
                            if (ctor == null) {
                                throw new ArgumentException(string.Format(Resources.Culture, Resources.Package_PageCtorMissing, objectType.FullName));
                            }
                            result = (IProfileManager)ctor.Invoke(new object[] {});

                            // if it's a DialogPage cache it
                            if(result != null) {
                                if(_pagesAndProfiles == null) {
                                    _pagesAndProfiles = new PackageContainer(this);
                                }
                                _pagesAndProfiles.Add((IComponent)result);
                            }

                            // No need to load settings from storage on first creation
                            // since that happens because of the Add above.

                            break;
                        }
                    }
                }
            }
            return result;
        }

        
        /// <devdoc>
        ///     Retrieves the shell's root key for VS options, or uses the value of
        ///     the DefaultRegistryRootAttribute if we coundn't get the shell service.
        /// </devdoc>
        private string GetRegistryRoot() {
            string regisrtyRoot;
    
            IVsShell vsh = (IVsShell)GetService(typeof(SVsShell));
            if (vsh == null) {
                // Search our custom attributes for an instance of DefaultRegistryRoot
                //
                DefaultRegistryRootAttribute regRootAttr = (DefaultRegistryRootAttribute)TypeDescriptor.GetAttributes(this.GetType())[typeof(DefaultRegistryRootAttribute)];
                if (regRootAttr == null) {
                    Debug.Fail("Package should have a registry root attribute");
                    throw new NotSupportedException();
                }
    
                regisrtyRoot = @"SOFTWARE\Microsoft\VisualStudio\" + regRootAttr.Root;
            }
            else {
                object obj;
                NativeMethods.ThrowOnFailure( vsh.GetProperty((int)__VSSPROPID.VSSPROPID_VirtualRegistryRoot, out obj) );
                regisrtyRoot = obj.ToString();
            }
    
            return regisrtyRoot;
        }
    
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetService"]' />
        /// <devdoc>
        ///     IServiceProvider implementation.
        /// </devdoc>
        protected object GetService(Type serviceType) {
            if (zombie)
                return null;

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            // Check for the sepecial services we provide.
            //
            if (serviceType == typeof(IServiceContainer) || serviceType == typeof(Package) || serviceType == this.GetType()) {
                return this;
            }

            object value = null;

            // Check our service list
            //
            if (_services != null) {
                lock (serviceType) {
                    value = _services[serviceType];

                    if (value is ProfferedService) {
                        value = ((ProfferedService)value).Instance;
                    }

                    if (value is ServiceCreatorCallback) {

                        // In case someone recursively requests the same service, 
                        // null out the service type here.  That way they'll just
                        // fail instead of stack fault.
                        //
                        _services[serviceType] = null;

                        value = ((ServiceCreatorCallback)value)(this, serviceType);
                        if (value != null && !value.GetType().IsCOMObject && !serviceType.IsAssignableFrom(value.GetType())) {
                            // Callback passed us a bad service.  NULL it, rather than throwing an exception.
                            // Callers here do not need to be prepared to handle bad callback implemetations.
                            Debug.Fail("Object " + value.GetType().Name + " was returned from a service creator callback but it does not implement the registered type of " + serviceType.Name);
                            value = null;
                        }
                        _services[serviceType] = value;
                    }
                }
            }

            // Delegate to the parent provider, but only if we have verified that _services doesn't actually contain our key
            // if it does, that means that we're in the middle of trying to resolve this service, and the service resolution
            // has recursed.
            //
            Debug.Assert(value != null || _services == null || !_services.ContainsKey(serviceType), "GetService is recursing on itself while trying to resolve the service " + serviceType.Name + ". This means that someone is asking for this service while the service is trying to create itself.  Breaking the recursion now and aborting this GetService call.");
            if (value == null && _provider != null && (_services == null || !_services.ContainsKey(serviceType))) {
                value = _provider.GetService(serviceType);
            }

            return value;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.Initialize"]/*' />
        /// <devdoc>
        /// This method is called when the package is first 
        /// initialized.  Override it if you need to do work
        /// that happens as part of package initialization.
        /// </devdoc>
        protected virtual void Initialize() {
            // If we have services to proffer, do that now.
            //
            if (_services != null)
            {

                IProfferService ps = (IProfferService)GetService(typeof(SProfferService));

                Debug.Assert(ps != null, "We have services to proffer but IProfferService is not available.");
                if (ps != null) {

                    foreach(DictionaryEntry de in _services) {
                        ProfferedService service = de.Value as ProfferedService;

                        if (service != null) {
                            Type serviceType = (Type)de.Key;
                            uint cookie;
                            Guid serviceGuid = (Guid)serviceType.GUID;
                            NativeMethods.ThrowOnFailure(
                                ps.ProfferService(ref serviceGuid, this, out cookie)
                            );
                            service.Cookie= cookie;
                        }
                    }
                }
            }

            // Initialize this thread's culture info with that of the shell's LCID
            //
            int locale = GetProviderLocale();
            Thread.CurrentThread.CurrentUICulture = new CultureInfo(locale);

            // Begin listening to user preference change events
            //
            SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(OnUserPreferenceChanged);
            
            // Be sure to load the package user options from the solution in case
            // the package was not already loaded when the solution was opened.
            if (null != _optionKeys)
            {
                try {
                    IVsSolutionPersistence pPersistance = (IVsSolutionPersistence)this.GetService(typeof(SVsSolutionPersistence));
                    if (pPersistance != null) {
                        foreach (string key in _optionKeys) {
                            // NOTE: don't check for the error code because a failure here is
                            // expected and not a problem.
                            pPersistance.LoadPackageUserOpts(this, key);
                        }
                    }
                } catch (Exception) {
                    // no settings found, no problem.
                }
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.QueryClose"]/*' />
        /// <devdoc>
        /// Called to ask the package if the shell can be closed.
        /// </devdoc>
        /// <param name="canClose">Set canClose to false if you want to prevent the shell from closing</param>
        /// <returns>HRESULT</returns>
        protected virtual int QueryClose(out bool canClose)
        {
            canClose = true;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetProviderLocale"]' />
        /// <devdoc>
        /// Return the locale associated with this IServiceProvider.
        /// </devdoc>
        public int GetProviderLocale() {
            CultureInfo ci = CultureInfo.CurrentCulture;
            int lcid = ci.LCID;
            IUIHostLocale loc = (IUIHostLocale)GetService(typeof(IUIHostLocale));
            Debug.Assert(loc != null, "Unable to get IUIHostLocale, defaulting CLR designer to current thread LCID");
            if (loc != null) {
                uint locale;
                NativeMethods.ThrowOnFailure(loc.GetUILocale(out locale));
                lcid = (int)locale;
            }
            return lcid;
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.CreateInstance"]/*' />
        /// <devdoc>
        /// Create the specified COM object using Visual Studio's ILocalRegistry
        /// and cast it to the given managed type.  If VS cannot create it, then
        /// fall back to Activator.CreateInstance.  This allows managed classes
        /// to be registered in local to the particular VS version in 
        /// HKLM\Software\Microsoft\VisualStudio\8.0\clsid.
        /// </devdoc>
        public object CreateInstance(ref Guid clsid, ref Guid iid, Type type) {
            object result = null;
            IntPtr pUnk = this.CreateInstance(ref clsid, ref iid);
            if (pUnk != IntPtr.Zero) {
                try {
                    result = Marshal.GetTypedObjectForIUnknown(pUnk, type);
                } finally {
                    Marshal.Release(pUnk);
                }
            } else {
                result = Activator.CreateInstance(type);
            }
            return result;
        }

        private IntPtr CreateInstance(ref Guid clsid, ref Guid iid) {
            ILocalRegistry3 localRegistry = this.GetService(typeof(SLocalRegistry)) as ILocalRegistry3;
            IntPtr pUnk;
            NativeMethods.ThrowOnFailure(localRegistry.CreateInstance(clsid, null, ref iid, NativeMethods.CLSCTX_INPROC_SERVER, out pUnk));
            localRegistry = null;
            return pUnk;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetOutputPane"]/*' />
        /// <devdoc>
        /// Return the specified output window pane.  If the pane is not found, 
        /// create it with the given caption.
        /// </devdoc>
        public IVsOutputWindowPane GetOutputPane(Guid page, string caption) {
            IVsOutputWindow outputWindow = this.GetService(typeof(SVsOutputWindow)) as IVsOutputWindow;
            Debug.Assert(outputWindow != null, "Cannot find IVsOutputWindow");
            IVsOutputWindowPane pane = null;
            int hr = outputWindow.GetPane(ref page, out pane);
            if ( NativeMethods.Failed(hr) )
            {
                if (caption != null) {
                    hr = outputWindow.CreatePane(ref page, caption, 1, 1);
                    if ( NativeMethods.Succeeded(hr) ) {
                        // Don't throw or fail here: a null pane is an expected value.
                        outputWindow.GetPane(ref page, out pane);
                    }
                }
            }
            if (pane != null) 
                NativeMethods.ThrowOnFailure( pane.Activate() );
            return pane;
        }

        /// <devdoc>
        ///     ServiceCreatorCallback implementation for the services we offer on demand.
        /// </devdoc>
        private object OnCreateService(IServiceContainer container, Type serviceType) {

            // Menu commands.  IOleCommandTarget is implemented on IMenuCommandService,
            // so we offer both as services and delegate the creation of IOleCommandTarget
            // to IMenuCommandService.
            //
            if (serviceType == typeof(IOleCommandTarget)) {
                object commandService = GetService(typeof(IMenuCommandService));
                if (commandService is IOleCommandTarget) {
                    return commandService;
                }
                Debug.Fail("IMenuCommandService is either unavailable or does not implement IOleCommandTarget");
            }
            else if (serviceType == typeof(IMenuCommandService)) {
                return new OleMenuCommandService(this);
            }

            Debug.Fail("OnCreateService invoked for a service we didn't add");
            return null;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.OnLoadOptions"]/*' />
        /// <devdoc>
        /// This method can be overridden by the deriving
        /// class to load solution options.
        /// </devdoc>
        protected virtual void OnLoadOptions(string key, Stream stream) {
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.OnSaveOptions"]/*' />
        /// <devdoc>
        /// This method can be overridden by the deriving
        /// class to save solution options.
        /// </devdoc>
        protected virtual void OnSaveOptions(string key, Stream stream) {
        }

        /// <devdoc>
        ///     Invoked when a user setting has changed.  Here we invalidate
        ///     the cached locale data so we can obtain updated culture information.
        /// </devdoc>
        private void OnUserPreferenceChanged(object sender, UserPreferenceChangedEventArgs e) {
            if (e.Category == UserPreferenceCategory.Locale) {
                CultureInfo.CurrentCulture.ClearCachedData();
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ParseToolboxResource"]/*' />
        /// <devdoc>
        /// Parses a toolbox resource format and adds the toolbox items to the toolbox.  This
        /// method can be used to automatically add items to the toolbox.  The resource data
        /// is passed in through the resourceData parameter and consists of a text file with
        /// the following format:
        /// ; Comment
        /// [CategoryName]
        /// &lt;class name&gt;, &lt;assembly name&gt;
        /// The category name can be localized through the localizedCategorized resource
        /// manager that is passed into this method.  The localizedCategories parameter
        /// may be null, in which case the category names will not be localized.
        /// The assembly name may either be a fully qualified name, or a partial name.
        /// If a partial name is passed, the latest assembly of that partial name will
        /// be loaded.
        /// </devdoc>
        protected void ParseToolboxResource(TextReader resourceData, ResourceManager localizedCategories) {
            ParseToolboxResource(resourceData, localizedCategories, Guid.Empty);
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ParseToolboxResource"]/*' />
        /// <devdoc>
        /// Parses a toolbox resource format and adds the toolbox items to the toolbox.  This
        /// method can be used to automatically add items to the toolbox.  The resource data
        /// is passed in through the resourceData parameter and consists of a text file with
        /// the following format:
        /// ; Comment
        /// [CategoryName]
        /// &lt;class name&gt;, &lt;assembly name&gt;
        /// The category name can be localized through the localizedCategorized resource
        /// manager that is passed into this method.  The localizedCategories parameter
        /// may be null, in which case the category names will not be localized.
        /// The assembly name may either be a fully qualified name, or a partial name.
        /// If a partial name is passed, the latest assembly of that partial name will
        /// be loaded.
        /// </devdoc>
        protected void ParseToolboxResource(TextReader resourceData, Guid packageGuid) {
            ParseToolboxResource(resourceData, null, packageGuid);
        }


        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ParseToolboxResource"]/*' />
        /// <devdoc>
        /// Parses a toolbox resource format and adds the toolbox items to the toolbox.  This
        /// method can be used to automatically add items to the toolbox.  The resource data
        /// is passed in through the resourceData parameter and consists of a text file with
        /// the following format:
        /// ; Comment
        /// [CategoryName]
        /// &lt;class name&gt;, &lt;assembly name&gt;
        /// The category name can be localized through the localizedCategorized resource
        /// manager that is passed into this method.  The localizedCategories parameter
        /// may be null, in which case the category names will not be localized.
        /// The assembly name may either be a fully qualified name, or a partial name.
        /// If a partial name is passed, the latest assembly of that partial name will
        /// be loaded.
        /// </devdoc>
        private void ParseToolboxResource(TextReader resourceData, ResourceManager localizedCategories, Guid packageGuid) {

            if (resourceData == null) {
                throw new ArgumentNullException("resourceData");
            }

            IToolboxService tbx = GetService(typeof(IToolboxService)) as IToolboxService;
            if (tbx == null) {
                Debug.Fail("Missing toolbox service");
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.General_MissingService, typeof(IToolboxService).FullName));
            }

            IVsToolbox vstbx = GetService(typeof(SVsToolbox)) as IVsToolbox;
            IVsToolbox2 vsToolbox2 = vstbx as IVsToolbox2;
            IVsToolbox3 vsToolbox = vstbx as IVsToolbox3;
            if (vsToolbox == null) {
                Debug.Fail("Missing VS toolbox service");
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.General_MissingService, typeof(SVsToolbox).FullName));
            }

            string line = resourceData.ReadLine();
            string currentCategory = null;
            string rawCategory = null;

            while(line != null) {

                try
                {
                    line = line.Trim();

                    if (line.Length != 0)
                    {
                        if (line.StartsWith(";", StringComparison.OrdinalIgnoreCase))
                        {
                            // Ignore this comment
                        }
                        else if (line.StartsWith("[", StringComparison.OrdinalIgnoreCase) && line.EndsWith("]", StringComparison.OrdinalIgnoreCase))
                        {

                            // This line is a toolbox category name.  Create a new category.
                            //
                            currentCategory = line.Trim(new char[] { '[', ']' }).Trim();
                            rawCategory = currentCategory;

                            if (localizedCategories != null) {
                                string locCategory = localizedCategories.GetString(currentCategory);
                                if (locCategory == null) {
                                    Debug.Fail("Category name " + currentCategory + " has not been localized");
                                }
                                else {
                                    currentCategory = locCategory;
                                }
                            }

                            bool categoryAdded = false;
                            if (!String.IsNullOrEmpty(currentCategory)) {
                                if (packageGuid != Guid.Empty && vsToolbox2 != null) {
                                    vsToolbox2.AddTab2(currentCategory, ref packageGuid);   //represents a native resource when package is sent in.
                                    if (!String.IsNullOrEmpty(rawCategory) && vsToolbox != null)
                                    {
                                        vsToolbox.SetIDOfTab(currentCategory, packageGuid.ToString("B") + "-" + rawCategory);
                                        rawCategory = null;
                                    }
                                    categoryAdded = true;
                                }
                                else if (vstbx != null) {
                                    //add the tab -- even if there are no items...
                                    vstbx.AddTab(currentCategory);
                                    categoryAdded = true;
                                }
                                if (categoryAdded && !String.IsNullOrEmpty(rawCategory) && vsToolbox != null)
                                {
                                    vsToolbox.SetIDOfTab(currentCategory, rawCategory);
                                    rawCategory = null;
                                }
                            }
                        }
                        else {

                            // The line is a toolbox item class.  Discover the type.  The
                            // type name is an assembly qualified name.  If it is fully 
                            // qualified we can load it directly.  If it isn't, then we must use the
                            // sdk enumeration service to find the assembly with the matching name.
                            // This allows toolbox item providers to list simple names in their toolbox item
                            // definition files, but do a strong bind.
                            //
                            int idx = line.IndexOf(",");
                            if (idx == -1)
                            {
                                Debug.Fail("Bad line: " + line);
                            }
                            else
                            {
                                string typeName = line.Substring(0, idx).Trim();
                                string assemblyName = line.Substring(idx + 1).Trim();

                                if (assemblyName.IndexOf(",") == -1)
                                {
                                    // Must use the assembly enumeration service to locate the
                                    // assembly.
                                    AssemblyEnumerationService enumSvc = new AssemblyEnumerationService(this);
                                    foreach (AssemblyName an in enumSvc.GetAssemblyNames(assemblyName))
                                    {
                                        assemblyName = an.FullName;
                                        break;
                                    }
                                }

                                Assembly a = Assembly.Load(assemblyName);
                                Debug.Assert(a != null, "Assembly " + assemblyName + " not found on machine");

                                if (a != null)
                                {
                                    Type t = a.GetType(typeName);
                                    Debug.Assert(t != null, "Type " + typeName + " not found on machine");
                                    if (t != null)
                                    {
                                        ToolboxItem item = ToolboxService.GetToolboxItem(t);
                                        Debug.Assert(item != null, "Tool " + line + " does not offer a toolbox item");
                                        if (item != null)
                                        {

                                            if (currentCategory == null)
                                            {
                                                tbx.AddToolboxItem(item);
                                            }
                                            else
                                            {
                                                tbx.AddToolboxItem(item, currentCategory);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    Debug.Fail("Exception during toolbox processing: " + ex.ToString());
                }

                line = resourceData.ReadLine();
            }
        }


        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.RegisterEditorFactory"]/*' />
        /// <devdoc>
        /// Registers this editor factory with Visual Studio.
        /// If you are providing an editor factory, you should register
        /// it by overriding the Initialize method. Call 
        /// base.Initialize first, and then call RegisterEditorFactory
        /// for each editor factory.  There is no need to unregister
        /// an editor factory as Package will handle this for you.
        /// Also, if your editor factory is IDisposable, it will be
        /// disposed when it is unregistered.
        /// </devdoc>
        protected void RegisterEditorFactory(IVsEditorFactory factory) {
            IVsRegisterEditors registerEditors = GetService(typeof(SVsRegisterEditors)) as IVsRegisterEditors;
            if (registerEditors == null) {
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Package_MissingService, typeof(SVsRegisterEditors).FullName));
            }

            uint cookie;
            Guid riid = factory.GetType().GUID;

            NativeMethods.ThrowOnFailure( registerEditors.RegisterEditor(ref riid, factory, out cookie) );

            if (_editorFactories == null) {
                _editorFactories = new Hashtable();
            }

            _editorFactories[factory] = cookie;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.RegisterEditorFactory"]/*' />
        /// <devdoc>
        /// Registers this project factory with Visual Studio.
        /// If you are providing an project factory, you should register
        /// it by overriding the Initialize method. Call 
        /// base.Initialize first, and then call RegisterProjectFactory
        /// for each project factory.  There is no need to unregister
        /// an project factory as the Package base class will handle this for you.
        /// Also, if your project factory is IDisposable, it will be
        /// disposed when it is unregistered.
        /// </devdoc>
        protected void RegisterProjectFactory(IVsProjectFactory factory) {
            IVsRegisterProjectTypes registerProjects = GetService(typeof(SVsRegisterProjectTypes)) as IVsRegisterProjectTypes;
            if (registerProjects == null) {
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Package_MissingService, typeof(SVsRegisterProjectTypes).FullName));
            }

            uint cookie;
            Guid riid = factory.GetType().GUID;

            NativeMethods.ThrowOnFailure( registerProjects.RegisterProjectType(ref riid, factory, out cookie) );

            if (_projectFactories == null) {
                _projectFactories = new Hashtable();
            }

            _projectFactories[factory] = cookie;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ShowOptionPage"]/*' />
        /// <devdoc>
        /// Displays the Tools->Options dialog with the given
        /// options page selected.
        /// </devdoc>
        public void ShowOptionPage(Type optionsPageType) {

            if (optionsPageType == null) {
                throw new ArgumentNullException("optionsPageType");
            }

            System.ComponentModel.Design.MenuCommandService mcs = GetService(typeof(IMenuCommandService)) as System.ComponentModel.Design.MenuCommandService;
            if (mcs != null) {
                CommandID cmd = new CommandID(NativeMethods.GUID_VSStandardCommandSet97, NativeMethods.cmdidToolsOptions);
                mcs.GlobalInvoke(cmd, optionsPageType.GUID.ToString());
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IOleCommandTarget.Exec"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IOleCommandTarget implementation.
        /// </devdoc>
        int IOleCommandTarget.Exec(ref Guid guidGroup, uint nCmdId, uint nCmdExcept, IntPtr pIn, IntPtr vOut) {
            IOleCommandTarget tgt = (IOleCommandTarget)GetService(typeof(IOleCommandTarget));
            if (tgt != null) {
                return tgt.Exec(ref guidGroup, nCmdId, nCmdExcept, pIn, vOut);
            }
            else {
                return NativeMethods.OLECMDERR_E_NOTSUPPORTED;
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IOleCommandTarget.QueryStatus"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IOleCommandTarget implementation.
        /// </devdoc>
        int IOleCommandTarget.QueryStatus(ref Guid guidGroup, uint nCmdId, OLECMD[] oleCmd, IntPtr oleText) {
            IOleCommandTarget tgt = (IOleCommandTarget)GetService(typeof(IOleCommandTarget));
            if (tgt != null) {
                return tgt.QueryStatus(ref guidGroup, nCmdId, oleCmd, oleText);
            }
            return(NativeMethods.OLECMDERR_E_NOTSUPPORTED);
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IOleServiceProvider.QueryService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IOleServiceProvider implementation.
        /// </devdoc>
        int IOleServiceProvider.QueryService(ref Guid sid, ref Guid iid, out IntPtr ppvObj) {
            
            ppvObj = (IntPtr)0;
            int hr = NativeMethods.S_OK;

            object service = null;

            if (_services != null) {
                foreach(Type serviceType in _services.Keys) {
                    if (serviceType.GUID.Equals(sid)) {
                        service = GetService(serviceType);
                        break;
                    }
                }
            }

            if (service == null) {
                hr = NativeMethods.E_NOINTERFACE;
            }
            else {
                // Now check to see if the user asked for an IID other than
                // IUnknown.  If so, we must do another QI.
                //
                if (iid.Equals(NativeMethods.IID_IUnknown)) {
                    ppvObj = Marshal.GetIUnknownForObject(service);
                }
                else {
                    IntPtr pUnk = Marshal.GetIUnknownForObject(service);
                    hr = Marshal.QueryInterface(pUnk, ref iid, out ppvObj);
                    Marshal.Release(pUnk);
                }
            }

            return hr;
        }
    
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.AddService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, object serviceInstance) {
            ((IServiceContainer)this).AddService(serviceType, serviceInstance, false);
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.AddService1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, object serviceInstance, bool promote) {

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            if (serviceInstance == null) {
                throw new ArgumentNullException("serviceInstance");
            }

            if (_services == null) {
                _services = new Hashtable();
            }

            // Disallow the addition of duplicate services.
            //
            if (_services.ContainsKey(serviceType)) {
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Package_DuplicateService, serviceType.FullName));
            }

            if (promote) {

                // If we're promoting, we need to store this guy in a promoted service
                // object because we need to manage additional state.  We attempt
                // to proffer at this time if we have a service provider.  If we don't,
                // we will proffer when we get one.
                //
                ProfferedService service = new ProfferedService();
                service.Instance = serviceInstance;
                
                if (_provider != null) {
                    IProfferService ps = (IProfferService)GetService(typeof(SProfferService));
                    if (ps != null) {
                        uint cookie;
                        Guid serviceGuid = (Guid)serviceType.GUID;
                        NativeMethods.ThrowOnFailure( ps.ProfferService(ref serviceGuid, this, out cookie) );
                        service.Cookie= cookie;
                        _services[serviceType] = service;
                    }
                }
            }
            else {
                _services[serviceType] = serviceInstance;
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.AddService2"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, ServiceCreatorCallback callback) {
            ((IServiceContainer)this).AddService(serviceType, callback, false);
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.AddService3"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, ServiceCreatorCallback callback, bool promote) {

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            if (callback == null) {
                throw new ArgumentNullException("callback");
            }

            if (_services == null) {
                _services = new Hashtable();
            }

            // Disallow the addition of duplicate services.
            //
            if (_services.ContainsKey(serviceType)) {
                throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Package_DuplicateService, serviceType.FullName));
            }

            if (promote) {

                // If we're promoting, we need to store this guy in a promoted service
                // object because we need to manage additional state.  We attempt
                // to proffer at this time if we have a service provider.  If we don't,
                // we will proffer when we get one.
                //
                ProfferedService service = new ProfferedService();
                _services[serviceType] = service;
                service.Instance = callback;
                
                if (_provider != null) {
                    IProfferService ps = (IProfferService)GetService(typeof(SProfferService));
                    if (ps != null) {
                        uint cookie;
                        Guid serviceGuid = (Guid)serviceType.GUID;
                        NativeMethods.ThrowOnFailure( ps.ProfferService(ref serviceGuid, this, out cookie) );
                        service.Cookie= cookie;
                    }
                }
            }
            else {
                _services[serviceType] = callback;
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.RemoveService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Removes the given service type from the service container.
        /// </devdoc>
        void IServiceContainer.RemoveService(Type serviceType) {
            ((IServiceContainer)this).RemoveService(serviceType, false);
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.RemoveService1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Removes the given service type from the service container.
        /// </devdoc>
        void IServiceContainer.RemoveService(Type serviceType, bool promote) {
            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            if (_services != null) {
                object value = _services[serviceType];
                if (value != null) {
                    _services.Remove(serviceType);

                    try {
                        ProfferedService service = value as ProfferedService;
                        if (null != service) {
                            value = service.Instance;
                            if (service.Cookie != 0) {
                                IProfferService ps = (IProfferService)GetService(typeof(SProfferService));
                                if (ps != null) {
                                    NativeMethods.ThrowOnFailure(ps.RevokeService(service.Cookie));
                                }
                                service.Cookie = 0;
                            }
                        }
                    } 
                    finally {
                        if (value is IDisposable) {
                            ((IDisposable)value).Dispose();
                        }
                    }
                }
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceProvider.GetService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IServiceProvider implementation.  We just delegate to
        /// the Package implementation for this.
        /// </devdoc>
        object IServiceProvider.GetService(Type serviceType) {
            return GetService(serviceType);
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.Close"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.Close() {
            if (!zombie)
            {
                Dispose(true);
            }

            zombie = true;

            return NativeMethods.S_OK;
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.CreateTool"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// graysonm : temporarily remove explicit implementation syntax in order to allow hiding of this method
        /// in a derived class until tool window support is implemented.
        /// </devdoc>
        public int CreateTool(ref Guid persistenceSlot)
        {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            // Let the factory do the work
            int hr = ((IVsToolWindowFactory)this).CreateToolWindow(ref persistenceSlot, 0);
            return hr;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsToolWindowFactory.CreateToolWindow"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Create a tool window of the specified type with the specified ID.
        /// </devdoc>
        /// <param name="toolWindowType">Type of the window to be created</param>
        /// <param name="id">Instance ID</param>
        int IVsToolWindowFactory.CreateToolWindow(ref Guid toolWindowType, uint id)
        {
            if (id > int.MaxValue)
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentUICulture, "Instance ID cannot be more then {0}", int.MaxValue));
            int instanceID = (int)id;

            // Find the Type for this GUID
            Attribute[] attributes = Attribute.GetCustomAttributes(this.GetType());
            foreach (Attribute attribute in attributes)
            {
                if (attribute is ProvideToolWindowAttribute)
                {
                    ProvideToolWindowAttribute tool = (ProvideToolWindowAttribute)attribute;
                    if (tool.ToolType.GUID == toolWindowType)
                    {
                        // We found the corresponding type
                        // If a window get created this way, FindToolWindow should be used to get a reference to it
                        FindToolWindow(tool.ToolType, instanceID, true, tool);
                        break;
                    }
                }
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.CreateToolWindow"]/*' />
        /// <devdoc>
        /// Create a tool window of the specified type with the specified ID.
        /// </devdoc>
        /// <param name="toolWindowType">Type of the window to be created</param>
        /// <param name="id">Instance ID</param>
        /// <returns>An instance of a class derived from ToolWindowPane</returns>
        protected ToolWindowPane CreateToolWindow(Type toolWindowType, int id)
        {
            if (toolWindowType == null)
                throw new ArgumentNullException("toolWindowType");
            if (id < 0)
                throw new ArgumentOutOfRangeException(string.Format(Resources.Culture, Resources.Package_InvalidInstanceID, id));
            if (!toolWindowType.IsSubclassOf(typeof(ToolWindowPane)))
                throw new ArgumentException(Resources.Package_InvalidToolWindowClass);

            // Look in the Attributes of this package and see if this package
            // support this type of ToolWindow
            Attribute[] attributes = Attribute.GetCustomAttributes(this.GetType());
            foreach (Attribute attribute in attributes)
            {
                if (attribute is ProvideToolWindowAttribute)
                {
                    ProvideToolWindowAttribute tool = (ProvideToolWindowAttribute)attribute;
                    if (tool.ToolType == toolWindowType)
                    {
                        // We found the corresponding attribute on the package,
                        // so create the toolwindow
                        return CreateToolWindow(toolWindowType, id, tool);
                    }
                }
            }

            return null;
        }

        /// <devdoc>
        /// This is the only method that should be calling IVsUiShell.CreateToolWindow()
        /// </devdoc>
        private ToolWindowPane CreateToolWindow(Type toolWindowType, int id, ProvideToolWindowAttribute tool)
        {
            if (toolWindowType == null)
                throw new ArgumentNullException("toolWindowType");
            if (id < 0)
                throw new ArgumentOutOfRangeException(string.Format(Resources.Culture, Resources.Package_InvalidInstanceID, id));
            if (!toolWindowType.IsSubclassOf(typeof(ToolWindowPane)))
                throw new ArgumentException(Resources.Package_InvalidToolWindowClass);
            if (tool == null)
                throw new ArgumentNullException("tool");

            // First create an instance of the ToolWindowPane
            ToolWindowPane window = (ToolWindowPane)Activator.CreateInstance(toolWindowType);

            // Check if this window has a ToolBar
            bool hasToolBar = (window.ToolBar != null);

            uint flags = (uint)__VSCREATETOOLWIN.CTW_fInitNew;
            if (!tool.Transient)
                flags |= (uint)__VSCREATETOOLWIN.CTW_fForceCreate;
            if (hasToolBar)
                flags |= (uint)__VSCREATETOOLWIN.CTW_fToolbarHost;
            if (tool.MultiInstances)
                flags |= (uint)__VSCREATETOOLWIN.CTW_fMultiInstance;
            Guid emptyGuid = Guid.Empty;
            Guid toolClsid = window.ToolClsid;
            IVsWindowPane windowPane = null;
            if (toolClsid.CompareTo(Guid.Empty) == 0)
            {
                // If a tool CLSID is not specified, then host the IVsWindowPane
                windowPane = window.GetIVsWindowPane() as IVsWindowPane;
            }
            Guid persistenceGuid = toolWindowType.GUID;
            IVsWindowFrame windowFrame;
            // Use IVsUIShell to create frame.
            IVsUIShell vsUiShell = (IVsUIShell)GetService(typeof(SVsUIShell));
            if (vsUiShell == null)
                throw new Exception(string.Format(Resources.Culture, Resources.General_MissingService, typeof(SVsUIShell).FullName));

            int hr = vsUiShell.CreateToolWindow(flags,         // flags
                (uint)id,               // instance ID
                windowPane,             // IVsWindowPane to host in the toolwindow (null if toolClsid is specified)
                ref toolClsid,          // toolClsid to host in the toolwindow (Guid.Empty if windowPane is not null)
                ref persistenceGuid,    // persistence Guid
                ref emptyGuid,          // auto activate Guid
                null,                   // service provider
                window.Caption,         // Window title
                null,
                out windowFrame);
            NativeMethods.ThrowOnFailure(hr);

            window.Package = this;

            // If the toolwindow is a component, site it.
            IComponent component = null;
            if (window.Window is IComponent)
                component = (IComponent)window.Window;
            else if (windowPane is IComponent)
                component = (IComponent)windowPane;
            if (component != null)
            {
                if (_componentToolWindows == null)
                    _componentToolWindows = new PackageContainer(this);
                _componentToolWindows.Add((IComponent)component);
            }

            // This generates the OnToolWindowCreated event on the ToolWindowPane
            window.Frame = windowFrame;

            if (hasToolBar && windowFrame != null)
            {
                // Set the toolbar
                IVsToolWindowToolbarHost toolBarHost;
                object obj;
                NativeMethods.ThrowOnFailure(windowFrame.GetProperty((int)__VSFPROPID.VSFPROPID_ToolbarHost, out obj));
                toolBarHost = (IVsToolWindowToolbarHost)obj;
                if (toolBarHost != null)
                {
                    Guid toolBarCommandSet = window.ToolBar.Guid;
                    NativeMethods.ThrowOnFailure(toolBarHost.AddToolbar((VSTWT_LOCATION)window.ToolBarLocation, ref toolBarCommandSet, (uint)window.ToolBar.ID));
                }
            }

            window.OnToolBarAdded();

            // If the ToolWindow was created successfully, keep track of it
            if (window != null)
            {
                if (_toolWindows == null)
                    _toolWindows = new ToolWindowCollection();
                _toolWindows.Add(toolWindowType.GUID, id, window);
            }
            return window;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.0lWindow"]/*' />
        /// <devdoc>
        /// Return the tool window corresponding to the specified type and ID.
        /// If it does not exist, it returns creates one if create is true,
        /// or null if create is false.
        /// </devdoc>
        /// <param name="toolWindowType">Type of the window to be created</param>
        /// <param name="id">Instance ID</param>
        /// <param name="create">Create if none exist?</param>
        /// <returns>An instance of a class derived from ToolWindowPane</returns>
        public ToolWindowPane FindToolWindow(Type toolWindowType, int id, bool create)
        {
            return FindToolWindow(toolWindowType, id, create, null);
        }

        private ToolWindowPane FindToolWindow(Type toolWindowType, int id, bool create, ProvideToolWindowAttribute tool)
        {
            if (toolWindowType == null)
                throw new ArgumentNullException("toolWindowType");

            ToolWindowPane window = null;

            // Try to get the window from the cache.
            if (null != _toolWindows)
            {
                // This will return null if the window is not in the collection.
                window = _toolWindows.GetToolWindowPane(toolWindowType.GUID, id);
            }

            if ((null == window) && create)
            {
                if (tool != null)
                    window = CreateToolWindow(toolWindowType, id, tool);
                else
                    window = CreateToolWindow(toolWindowType, id);
            }

            return window;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.GetAutomationObject"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.GetAutomationObject(string propName, out object auto) {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            auto = GetAutomationObject(propName);
            if (auto == null) {
                Marshal.ThrowExceptionForHR(NativeMethods.E_NOTIMPL);
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.GetPropertyPage"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.GetPropertyPage(ref Guid rguidPage, VSPROPSHEETPAGE[] ppage) {
            if (ppage == null || ppage.Length < 1)
                throw new ArgumentException(string.Format(Resources.Culture, Resources.General_ArraySizeShouldBeAtLeast1), "ppage");

            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            IWin32Window pageWindow = null;

            // First, check out the active pages.
            //
            if (_pagesAndProfiles != null) {
                foreach(object page in _pagesAndProfiles.Components) {
                    if (page.GetType().GUID.Equals(rguidPage)) {

                        // Found a match.
                        //
                        IWin32Window w = page as IWin32Window;
                        if (w != null) {
                            if (w is DialogPage) {
                                ((DialogPage)w).ResetContainer();
                            }
                            pageWindow = w;
                            break;
                        }
                    }
                }
            }

            if (pageWindow == null) {

                DialogPage page = null;

                // Didn't find it in our cache.  Now look in the metadata attributes
                // for the class.  Look at all types at the same time.
                //
                AttributeCollection attributes = TypeDescriptor.GetAttributes(this);
                foreach(Attribute attr in attributes) {
                    if (attr is ProvideOptionDialogPageAttribute) {
                        Type pageType = ((ProvideOptionDialogPageAttribute)attr).PageType;
                        if (pageType.GUID.Equals(rguidPage)) {

                            // Found a matching attribute.  Now go get the DialogPage with GetDialogPage.
                            // This has a side-effect of storing the page in
                            // _pagesAndProfiles for us.
                            //
                            page = GetDialogPage(pageType);
                            pageWindow = page;
                            break;
                        }
                    }

                    if (page != null)
                    {
                        if (_pagesAndProfiles == null)       
                        {
                            _pagesAndProfiles = new PackageContainer(this);
                        }
                        _pagesAndProfiles.Add(page);

                        // No need to continue looking in the attributes, 
                        // we've already found the one we're looking for
                        break;
                    }
                }
            }

            // We should now have a page window. If we don't then the requested page
            // doesn't exist.
            //
            if (pageWindow == null) {
                Marshal.ThrowExceptionForHR(NativeMethods.E_NOTIMPL);
            }

            ppage[0].dwSize = (uint)Marshal.SizeOf(typeof(VSPROPSHEETPAGE));
            ppage[0].hwndDlg = pageWindow.Handle;
            // zero-out all the fields we aren't using.
            ppage[0].dwFlags = 0;
            ppage[0].HINSTANCE = 0;
            ppage[0].dwTemplateSize = 0;
            ppage[0].pTemplate = IntPtr.Zero;
            ppage[0].pfnDlgProc = IntPtr.Zero;
            ppage[0].lParam = IntPtr.Zero;
            ppage[0].pfnCallback = IntPtr.Zero;
            ppage[0].pcRefParent = IntPtr.Zero;
            ppage[0].dwReserved = 0;
            ppage[0].wTemplateId = (ushort)0;

            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.QueryClose"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.QueryClose(out int close)
        {
            // Default to true as we don't want an error to prevent the shell from closing
            close = 1;
            bool canClose = true;
            int hr = this.QueryClose(out canClose);
            if (!canClose)
                close = 0;
            return hr;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.ResetDefaults"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.ResetDefaults(uint grfFlags) {

            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (grfFlags == (uint)__VSPKGRESETFLAGS.PKGRF_TOOLBOXITEMS) {
                if (ToolboxInitialized != null) {
                    ToolboxInitialized(this, EventArgs.Empty);
                }
            }
            else if (grfFlags == (uint)__VSPKGRESETFLAGS.PKGRF_TOOLBOXSETUP) {
                if (ToolboxUpgraded != null) {
                    ToolboxUpgraded(this, EventArgs.Empty);
                }
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.SetSite"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.SetSite(IOleServiceProvider sp) {

            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (sp != null) {
                if (_provider != null) {
                    throw new InvalidOperationException(string.Format(Resources.Culture, Resources.Package_SiteAlreadySet, GetType().FullName));
                }
                _provider = new ServiceProvider(sp);
                // Initialize the static service provider
                if (_globalProvider == null)
                    _globalProvider = _provider;
                // Increment the number of package that have been sited.
                // This allows us to know when to let go of our _globalProvider
                ++_sitedPackageCount;
                Initialize();
            }
            else if (_provider != null)
            {
                // No SP, dispose us.
                //
                Dispose(true);

                // Decrement the number of package that have been sited.
                --_sitedPackageCount;
                // Dispose of our  _globalProvider once all packages have been unsited
                if (_sitedPackageCount <= 0 && _globalProvider != null)
                {
                    Debug.Assert(_sitedPackageCount == 0, "We should not have unsited more package then we sited");
                    _globalProvider.Dispose();
                    _globalProvider = null;
                }
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPersistSolutionOpts.LoadUserOptions"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPersistSolutionOpts implementation.
        /// Called when a solution is opened, and allows us to inspect our options.
        /// </devdoc>
        int IVsPersistSolutionOpts.LoadUserOptions(IVsSolutionPersistence pPersistance, uint options) {

            int hr = NativeMethods.S_OK;
            if ((options & (uint)__VSLOADUSEROPTS.LUO_OPENEDDSW) != 0) {
                return hr;
            }

            if (_optionKeys != null) {
                foreach(string key in _optionKeys) {
                    hr = pPersistance.LoadPackageUserOpts(this, key);
                    if (NativeMethods.Failed(hr))
                        break;
                }
            }

            // Shell relies on this being released when we're done with it.  If you see strange
            // faults in the shell when saving the solution, suspect this!
            //
            Marshal.ReleaseComObject(pPersistance);

            NativeMethods.ThrowOnFailure(hr);
            return hr;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPersistSolutionOpts.ReadUserOptions"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPersistSolutionOpts implementation.
        /// Called by the shell to load our solution options.
        /// </devdoc>
        int IVsPersistSolutionOpts.ReadUserOptions(IStream pStream, string pszKey) {

            try {
                NativeMethods.DataStreamFromComStream stream = new NativeMethods.DataStreamFromComStream(pStream);
                using (stream) {
                    OnLoadOptions(pszKey, stream);
                }
            }
            finally {
                // Release the pointer because VS expects it to be released upon
                // function return.
                //
                Marshal.ReleaseComObject(pStream);
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPersistSolutionOpts.SaveUserOptions"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPersistSolutionOpts implementation.
        /// Called by the shell when we are to persist our service options
        /// </devdoc>
        int IVsPersistSolutionOpts.SaveUserOptions(IVsSolutionPersistence pPersistance) {

            if (_optionKeys != null) {
                foreach(string key in _optionKeys) {
                    NativeMethods.ThrowOnFailure( pPersistance.SavePackageUserOpts(this, key) );
                }
            }

            // Shell relies on this being released when we're done with it.  If you see strange
            // faults in the shell when saving the solution, suspect this!
            //
            Marshal.ReleaseComObject(pPersistance);

            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPersistSolutionOpts.WriteUserOptions"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPersistSolutionOpts implementation.
        /// Called by the shell to persist our solution options.  Here is where the service
        /// can persist any goo that it cares about.
        /// </devdoc>
        int IVsPersistSolutionOpts.WriteUserOptions(IStream pStream, string pszKey) {

            try {
                NativeMethods.DataStreamFromComStream stream = new NativeMethods.DataStreamFromComStream(pStream);
                using (stream) {
                    OnSaveOptions(pszKey, stream);
                }
            }
            finally {
                // Release the pointer because VS expects it to be released upon
                // function return.
                //
                Marshal.ReleaseComObject(pStream);
            }
            return NativeMethods.S_OK;
        }

        /// <devdoc>
        ///     This class derives from container to provide a service provider
        ///     connection to the package.
        /// </devdoc>
        private sealed class PackageContainer : Container {
            private IUIService _uis;
            private AmbientProperties _ambientProperties;

            private IServiceProvider _provider;

            /// <devdoc>
            ///     Creates a new container using the given service provider.
            /// </devdoc>
            internal PackageContainer(IServiceProvider provider) {
                _provider = provider;
            }

            /// <devdoc>
            ///     Override to GetService so we can route requests
            ///     to the package's service provider.
            /// </devdoc>
            protected override object GetService(Type serviceType) {
                if (serviceType == null) {
                    throw new ArgumentNullException("serviceType");
                }
                if (_provider != null) {
                    if (serviceType == typeof(AmbientProperties)) {
                        if (_uis == null) {
                            _uis = (IUIService)_provider.GetService(typeof(IUIService));
                        }
                        if (_ambientProperties == null) {
                            _ambientProperties = new AmbientProperties();
                        }
                        if (_uis != null) {
                            // update the _ambientProperties in case the styles have changed
                            // since last time.
                            _ambientProperties.Font = (Font)_uis.Styles["DialogFont"];
                        }
                        return _ambientProperties;
                    }
                    object service = _provider.GetService(serviceType);

                    if (service != null) {
                        return service;
                    }
                }
                return base.GetService(serviceType);
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetGlobalService"]' />
        /// <devdoc>
        /// Get a service proffered globally by VisualStudio or one of its package.
        /// This is equivalent to calling GetService() on an instance of a package 
        /// that proffer no service itself.
        /// </devdoc>
        /// <param name="serviceType">Type corresponding to the Service being requested</param>
        /// <returns>The service being requested if available, otherwise null</returns>
        static public object GetGlobalService(Type serviceType)
        {
            object service = null;
            Debug.Assert(_globalProvider != null, "You are calling GetGlobalService before any package derived from the managed package framework has been sited. This is not supported");

            if (_globalProvider != null)
            {
                service = _globalProvider.GetService(serviceType);
            }
            return service;
        }

        /// <devdoc>
        ///     This class contains a service that is being promoted to vS.  
        /// </devdoc>
        private sealed class ProfferedService {
            public object Instance;
            public uint   Cookie;
        }

        /// <devdoc>
        /// Internal zombie flag indicates that VS is shutting us down.
        /// </devdoc>
        private bool zombie = false;

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.Zombied"]/*' />
        /// <devdoc>
        /// Zombie flag indicates that the package is being closed.
        /// </devdoc>
        public bool Zombied {
            get {
                return zombie;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\RegistryPaths.cs ===
namespace Microsoft.VisualStudio.Shell
{
    // These string names and definitions are from vscommon\inc\vsregkeynames.h
    internal class RegistryPaths
    {
        private RegistryPaths() { }

        internal static string package            = "Package";
        internal static string displayName        = "DisplayName";
        internal static string languageStringId   = "LangStringID";
        internal static string languageResourceId = "LangResID";
        internal static string showRoots          = "ShowRoots";
        internal static string indexPath          = "IndexPath";
        internal static string paths              = "Paths";
        internal static string languages          = "Languages";
        internal static string languageServices   = languages + "\\Language Services";
        internal static string codeExpansion      = languages + "\\CodeExpansions";
        internal static string forceCreateDirs    = "ForceCreateDirs";
        internal static string debuggerLanguages  = "Debugger Languages";
        internal static string editorToolsOptions = "EditorToolsOptions";
        internal static string page               = "Page";
    }

    internal class LanguageOptionKeys
    {
        private LanguageOptionKeys() { }

        internal static string showCompletion               = "ShowCompletion";
        internal static string showIndentOptions            = "ShowSmartIndent";
        internal static string useStockColors               = "RequestStockColors";
        internal static string showHotURLs                  = "ShowHotURLs";
        internal static string nonHotURLs                   = "Default to Non Hot URLs";
        internal static string insertSpaces                 = "DefaultToInsertSpaces";
        internal static string showDropDownBar              = "ShowDropdownBarOption";
        internal static string disableWindowNewWindow       = "Single Code Window Only";
        internal static string enableAdvMembersOption       = "EnableAdvancedMembersOption";
        internal static string supportCF_HTML               = "Support CF_HTML";
        internal static string enableLineNumbersOption      = "EnableLineNumbersOption";
        internal static string hideAdvancedMembersByDefault = "HideAdvancedMembersByDefault";
        internal static string codeSense                    = "CodeSense";
        internal static string matchBraces                  = "MatchBraces";
        internal static string quickInfo                    = "QuickInfo";
        internal static string showMatchingBrace            = "ShowMatchingBrace";
        internal static string matchBracesAtCaret           = "MatchBracesAtCaret";
        internal static string maxErrorMessages             = "MaxErrorMessages";
        internal static string codeSenseDelay               = "CodeSenseDelay";
        internal static string enableAsyncCompletion        = "EnableAsyncCompletion";
        internal static string enableCommenting             = "EnableCommenting";
        internal static string enableFormatSelection        = "EnableFormatSelection";
        internal static string autoOutlining                = "AutoOutlining";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\SelectionContainer.cs ===
namespace Microsoft.VisualStudio.Shell
{
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    using ISelectionContainer = Microsoft.VisualStudio.Shell.Interop.ISelectionContainer;

    /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer"]/*' />
    /// <devdoc>
    /// This class implements the ISelectionContainer interface. It can be used to show
    /// informations on the property window.
    /// </devdoc>
    [CLSCompliant(false)]
    public class SelectionContainer : 
        ISelectionContainer
    {
        private ICollection     _selectableObjects;
        private ICollection     _selectedObjects;
        private readonly bool   _selectableReadOnly;
        private readonly bool   _selectedReadOnly;

        private static ICollection _emptyCollection = new Object[0];

        // Constants for selection container flags.
        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ALL"]/*' />
        public const uint ALL = 0x1;
        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SELECTED"]/*' />
        public const uint SELECTED = 0x2;

        private const int SELOBJ_ACTIVATE_WINDOW = 0x1;


        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectionContainer"]/*' />
        /// <devdoc>
        /// Creates a container with empty collections of selected and selectable objects.
        /// </devdoc>
        public SelectionContainer()
        {
            _selectableObjects = _emptyCollection;
            _selectedObjects = _emptyCollection;
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectionContainer1"]/*' />
        /// <devdoc>
        /// Creates a selection container with empty collections of selected and selectable objects.
        /// </devdoc>
        /// <param name="selectableReadOnly">Specifies if the collection of the selectable objects is read only.</param>
        /// <param name="selectedReadOnly">Specifies if the selection is read only.</param>
        public SelectionContainer(bool selectableReadOnly, bool selectedReadOnly) : this()
        {
            _selectableReadOnly = selectableReadOnly;
            _selectedReadOnly = selectedReadOnly;
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectableObjects"]/*' />
        /// <devdoc>
        /// Get or set the collection of the selectable objects
        /// </devdoc>
        public ICollection SelectableObjects
        {
            get
            {
                return _selectableObjects;
            }
            set
            {
                if (value == null)
                {
                    value = _emptyCollection;
                }
                _selectableObjects = value;
            }
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectedObjects"]/*' />
        /// <devdoc>
        /// Get or set the collection of the selected objects.
        /// </devdoc>
        public ICollection SelectedObjects
        {
            get
            {
                return _selectedObjects;
            }
            set
            {
                if (value == null)
                {
                    value = _emptyCollection;
                }
                _selectedObjects = value;
            }
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectedObjectsChanged"]/*' />
        /// <devdoc>
        /// This event is fired when the selection changes.
        /// </devdoc>
        public event EventHandler SelectedObjectsChanged;

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ActivateObjects"]/*' />
        /// <devdoc>
        /// Activates the selected objects. Its default implementation is empty.
        /// </devdoc>
        protected virtual void ActivateObjects()
        {
            // This default implementation of this function is empty.
        }

        // Helper function to change the selected objects
        private void ChangeSelection(object[] prgUnkObjects, int dwFlags)
        {
            // Check if it is possible to change the selection.
            if (_selectedReadOnly) throw new InvalidOperationException();
            // Store the array of selected object in the internal array
            SelectedObjects = prgUnkObjects;
            // Raise the "Selected objects changed" event.
            if (SelectedObjectsChanged != null) SelectedObjectsChanged(this, EventArgs.Empty);
            // Check if the objects need to be activated
            if ( (dwFlags & SELOBJ_ACTIVATE_WINDOW) != 0 )
            {
                ActivateObjects();
            }
        }

   
    
#region ISelectionContainer Members

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ISelectionContainer.CountObjects"]/*' />
        /// <internalonly/>
        int ISelectionContainer.CountObjects(uint dwFlags, out uint pc)
        {
            switch (dwFlags)
            {
                case ALL:
                    pc = (uint)SelectableObjects.Count;
                    break;

                case SELECTED:
                    pc = (uint)SelectedObjects.Count;
                    break;

                default:
                    throw new ArgumentException(string.Format(Resources.Culture, Resources.General_UnsupportedValue, dwFlags), "dwFlags");
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ISelectionContainer.GetObjects"]/*' />
        /// <internalonly/>
        int ISelectionContainer.GetObjects(uint dwFlags, uint cObjects, object[] apUnkObjects)
        {
            ICollection objects = null;

            switch (dwFlags)
            {
                case ALL:
                    objects = SelectableObjects;
                    break;

                case SELECTED:
                    objects = SelectedObjects;
                    break;

                default:
                    throw new ArgumentException(string.Format(Resources.Culture, Resources.General_UnsupportedValue, dwFlags), "dwFlags");
            }

            int idx = 0;
            foreach (object obj in objects)
            {
                if (idx >= cObjects || idx >= apUnkObjects.Length)
                {
                    break;
                }
                apUnkObjects[idx++] = obj;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ISelectionContainer.SelectObjects"]/*' />
        /// <internalonly/>
        int ISelectionContainer.SelectObjects(uint cSelect, object[] apUnkSelect, uint dwFlags)
        {
            ChangeSelection(apUnkSelect, (int)dwFlags);
            return NativeMethods.S_OK;
        }

#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideProjectFactoryAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideProjectFactoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.ComponentModel;
    using System.Globalization;

    /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers an project factory.  A single 
    ///     package can provide multiple project factories.  If a package declares that 
    ///     it provides an project factory, it should create the factory and offer it 
    ///     to Visual Studio in the Initialize method of Package.
    /// 
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideProjectFactoryAttribute : RegistrationAttribute {

        private Type    _factoryType;
        private string   _displayProjectFileExtensions;
        private string  _name;
        private string  _defaultProjectExtension;
        private string  _possibleProjectExtensions;
        private string  _projectTemplatesDirectory;
        private int     _sortPriority = 100;
        private Guid    _folderGuid = Guid.Empty;

        private string languageVsTemplate;
        private string templateGroupIDsVsTemplate;
        private string templateIDsVsTemplate;
        private string displayProjectTypeVsTemplate;
        private string projectSubTypeVsTemplate;
        private bool newProjectRequireNewFolderVsTemplate = false;
        private bool showOnlySpecifiedTemplatesVsTemplate = false;

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.ProvideProjectFactoryAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideProjectFactoryAttribute.
        /// </devdoc>
        public ProvideProjectFactoryAttribute(Type factoryType, string name, string displayProjectFileExtensionsResourceID, string defaultProjectExtension, string possibleProjectExtensions, string projectTemplatesDirectory) {
            if (factoryType == null) {
                throw new ArgumentNullException("factoryType");
            }

            _factoryType = factoryType;
            _name = name;
            _displayProjectFileExtensions = displayProjectFileExtensionsResourceID;
            _defaultProjectExtension = defaultProjectExtension;
            _possibleProjectExtensions = possibleProjectExtensions;
            _projectTemplatesDirectory = projectTemplatesDirectory;
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.Name"]/*' />
        /// <summary>
        /// The tree node name in the create new project and add new item dialogs.
        /// Take precendence over the nameResourceID value
        /// </summary>
        /// <value>Name to be used</value>
        public string Name
        {
            get { return _name; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.SortPriority"]/*' />
        /// <summary>
        /// Affect the order in which project are displayed in the new project dialog
        /// </summary>
        /// <value>Default is 100</value>
        public int SortPriority
        {
            get { return _sortPriority; }
            set { _sortPriority = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.FactoryType"]' />
        /// <devdoc>
        ///     Returns the project factory type this attribute declares.
        /// </devdoc>
        public Type FactoryType {
            get {
                return _factoryType;
            }            
        }
        
        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.DisplayProjectFileExtensionsResourceID"]' />
        /// <devdoc>
        ///     Returns the display project files extensions string.
        /// </devdoc>
        public string DisplayProjectFileExtensions {
            get {
                return _displayProjectFileExtensions;
            }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.DefaultProjectExtension"]' />
        /// <devdoc>
        ///     Returns the default project extension.
        /// </devdoc>
        public string DefaultProjectExtension {
            get {
                return _defaultProjectExtension;
            }
        }


        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.PossibleProjectExtensions"]' />
        /// <devdoc>
        ///     Returns the default project extension.
        /// </devdoc>
        public string PossibleProjectExtensions {
            get {
                return _possibleProjectExtensions;
            }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.ProjectTemplatesDirectory"]' />
        /// <devdoc>
        ///     Returns the default project extension.
        /// </devdoc>
        public string ProjectTemplatesDirectory {
            get {
                return _projectTemplatesDirectory;
            }
        }

        /// <summary>
        /// Get or Set the Folder guid.
        /// This can be used to control where the project node appear in the New Project dialog
        /// </summary>
        public string FolderGuid
        {
            get { return _folderGuid.ToString("B"); }
            set { _folderGuid = new Guid(value); }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.LanguageVsTemplate"]/*' />
        public string LanguageVsTemplate
        {
            get { return languageVsTemplate; }
            set { languageVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.DisplayProjectTypeVsTemplate"]/*' />
        public string DisplayProjectTypeVsTemplate
        {
            get { return displayProjectTypeVsTemplate; }
            set { displayProjectTypeVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.ProjectSubTypeVsTemplate"]/*' />
        public string ProjectSubTypeVsTemplate
        {
            get { return projectSubTypeVsTemplate; }
            set { projectSubTypeVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.NewProjectRequireNewFolderVsTemplate"]/*' />
        public bool NewProjectRequireNewFolderVsTemplate
        {
            get { return newProjectRequireNewFolderVsTemplate; }
            set { newProjectRequireNewFolderVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.ShowOnlySpecifiedTemplatesVsTemplate"]/*' />
        public bool ShowOnlySpecifiedTemplatesVsTemplate
        {
            get { return showOnlySpecifiedTemplatesVsTemplate; }
            set { showOnlySpecifiedTemplatesVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.TemplateGroupIDsVsTemplate"]/*' />
        public string TemplateGroupIDsVsTemplate
        {
            get { return templateGroupIDsVsTemplate; }
            set { templateGroupIDsVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.TemplateIDsVsTemplate"]/*' />
        public string TemplateIDsVsTemplate
        {
            get { return templateIDsVsTemplate; }
            set { templateIDsVsTemplate = value; }
        }


        private string ProjectRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}", FactoryType.GUID.ToString("B")); }
        }

        private string NewPrjTemplateRegKey(RegistrationContext context)
        {
            return string.Format(CultureInfo.InvariantCulture, "NewProjectTemplates\\TemplateDirs\\{0}\\/1", context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyProjectFactory, FactoryType.Name));

            using (Key projectKey = context.CreateKey(ProjectRegKey))
            {
                projectKey.SetValue(string.Empty, FactoryType.Name);
                if (_name != null)
                    projectKey.SetValue("DisplayName", _name);
                if (_displayProjectFileExtensions != null)
                    projectKey.SetValue("DisplayProjectFileExtensions", _displayProjectFileExtensions);
                projectKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                if (_defaultProjectExtension != null)
                    projectKey.SetValue("DefaultProjectExtension", _defaultProjectExtension);
                if (_possibleProjectExtensions != null)
                    projectKey.SetValue("PossibleProjectExtensions", _possibleProjectExtensions);
                if (_projectTemplatesDirectory != null)
                {
                    if (!System.IO.Path.IsPathRooted(_projectTemplatesDirectory))
                    {
                        // If path is not rooted, make it relative to package path
                        _projectTemplatesDirectory = System.IO.Path.Combine(context.ComponentPath, _projectTemplatesDirectory);
                    }
                    projectKey.SetValue("ProjectTemplatesDir", _projectTemplatesDirectory);
                }

                // VsTemplate Specific Keys
                if (languageVsTemplate != null)
                    projectKey.SetValue("Language(VsTemplate)", languageVsTemplate);
                if (showOnlySpecifiedTemplatesVsTemplate)
                    projectKey.SetValue("ShowOnlySpecifiedTemplates(VsTemplate)", (int)1);
                if (templateGroupIDsVsTemplate != null)
                    projectKey.SetValue("TemplateGroupIDs(VsTemplate)", templateGroupIDsVsTemplate);
                if (templateIDsVsTemplate != null)
                    projectKey.SetValue("TemplateIDs(VsTemplate)", templateIDsVsTemplate);
                if (displayProjectTypeVsTemplate != null)
                    projectKey.SetValue("DisplayProjectType(VsTemplate)", displayProjectTypeVsTemplate);
                if (projectSubTypeVsTemplate != null)
                    projectKey.SetValue("ProjectSubType(VsTemplate)", projectSubTypeVsTemplate);
                if (newProjectRequireNewFolderVsTemplate)
                    projectKey.SetValue("NewProjectRequireNewFolder(VsTemplate)", (int)1);
            }

            using (Key prjTemplateKey = context.CreateKey(NewPrjTemplateRegKey(context)))
            {

                string keyName = String.Empty;
                if (_name != null)
                    prjTemplateKey.SetValue(keyName, _name);
                prjTemplateKey.SetValue("SortPriority", _sortPriority);
                if (_projectTemplatesDirectory != null)
                {
                    prjTemplateKey.SetValue("TemplatesDir", _projectTemplatesDirectory);
                }
                if (_folderGuid != Guid.Empty)
                {
                    prjTemplateKey.SetValue("Folder", FolderGuid);
                }
            }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.Unregister"]/*' />
        public override void Unregister(RegistrationContext context) {
            context.RemoveKey(ProjectRegKey);
            context.RemoveKey(NewPrjTemplateRegKey(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideToolboxItemsAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideToolboxItemsAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="ProvideToolboxItemsAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers toolbox items and should be provided time 
    ///     during setup to install these items.  The attributes on a package do not control the 
    ///     behavior of the package, but they can be used by registration tools to register the 
    ///     proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    public class ProvideToolboxItemsAttribute : RegistrationAttribute {

        private int   _version;
        private bool  _needsCallbackAfterReset = false;
    
        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="ProvideToolboxItemsAttribute.ProvideToolboxItemsAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideToolboxItemsAttribute.
        /// </devdoc>
        public ProvideToolboxItemsAttribute(int version) {
            _version = version;
            _needsCallbackAfterReset = false;
        }

        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="ProvideToolboxItemsAttribute.ProvideToolboxItemsAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideToolboxItemsAttribute.
        ///     If needsCallbackAfterReset is true, then it will write out the "needsCallbackAfterReset" regkey which
        ///     tells the shell we have transient items to add and need to be called after resetdefaults is complete.
        /// </devdoc>
        public ProvideToolboxItemsAttribute(int version, bool needsCallbackAfterReset) {
            _version = version;
            _needsCallbackAfterReset = needsCallbackAfterReset;
        }

        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="ProvideToolboxItemsAttribute.Version"]' />
        /// <devdoc>
        ///     Returns the version of items on the toolbox.
        ///     The first time a package get loaded after this version change,
        ///     the ToolboxInitialized event will be generated.
        /// </devdoc>
        public int Version {
            get {
                return _version;
            }
        }

        /// <summary>
        /// Setting this to true will force a ToolboxInitialized event after each
        /// toolbox reset.
        /// This can be used when developing your package to force the toolbox to
        /// ask the list of items to the package everytime (in case it has changed).
        /// For shipped products, it is best to leave it to false so that the cache can
        /// be used for better performances. Some scenario (such as item list that cannot
        /// cannot be persisted to the cache) may need to have this flag set to true
        /// </summary>
        public bool NeedsCallBackAfterReset
        {
            get { return _needsCallbackAfterReset; }
            set { _needsCallbackAfterReset = value; }
        }

        private string GetPackageRegKey(Guid packageGuid)
        {
            return string.Format(CultureInfo.InvariantCulture, "Packages\\{0}", packageGuid.ToString("B"));
        }

        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        /// </devdoc>
        public override void Register(RegistrationContext context) {

            using (Key packageKey = context.CreateKey(GetPackageRegKey(context.ComponentType.GUID)))
            {
                using (Key childKey = packageKey.CreateSubkey("Toolbox"))
                {
                    childKey.SetValue("Default Items", Version);

                    // Search the package for the AllowToolboxFormat attribute.
                    //
                    string format = string.Empty;
                    foreach(ProvideToolboxFormatAttribute pfa in context.ComponentType.GetCustomAttributes(typeof(ProvideToolboxFormatAttribute), true)) {
                        if (format.Length == 0) {
                            format = pfa.Format;
                        }
                        else {
                            format = string.Format(CultureInfo.InvariantCulture, "{0}, {1}", format, pfa.Format);
                        }
                    }

                    if (format.Length > 0) {
                        childKey.SetValue("Formats", format);
                    }

                    if (_needsCallbackAfterReset) {
                        childKey.SetValue("NeedsCallbackAfterReset", (int)1);
                    }

                    context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyToolboxItem, Version, format));
                }
            }
        }

        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Removes the registration data.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(GetPackageRegKey(context.ComponentType.GUID));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ServiceProviderHierarchy.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceProviderHierarchy.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Collections.Generic;

    /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchy"]' />
    /// <devdoc>
    ///     This class acts as a hierarchical service provider.  It stores IServiceProviders in a sorted dictionary
    ///     for an ordered retrieval.  When GetService is called to retrieve a service, the service providers are queried
    ///     in a specific order.  This is useful when multiple service providers are combined such as in 
    ///     the WindowPane implementation
    /// </devdoc>
    [CLSCompliant(false)]
    public sealed class ServiceProviderHierarchy : SortedList<int, IServiceProvider>, IServiceProvider {
        
        /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchy.GetService"]' />
        /// <devdoc>
        ///     Retrieves the requested service by walking the hierarchy of service providers.
        /// </devdoc>
        public object GetService(Type serviceType) {
            
            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            object service = null;

            if (serviceType == typeof(ServiceProviderHierarchy)) {
                service = this;
            }
            else {
                foreach(IServiceProvider provider in Values) {
                    service = provider.GetService(serviceType);
                    if (service != null) {
                        break;
                    }
                }
            }

            return service;
        }
    }

    /// <include file='doc\ServiceProviderHierarchyOrder.uex' path='docs/doc[@for="ServiceProviderHierarchyOrder"]' />
    /// <devdoc>
    ///     When multiple service providers are combined in a service provider hierarchy they 
    ///     are ordered according to a numeric ordering.  This class provides recommended service
    ///     resolution order for common service providers.
    /// </devdoc>
    public sealed class ServiceProviderHierarchyOrder {
        /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchyOrder.PackageSite"]/*' />
        public const int PackageSite = 100;
        /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchyOrder.WindowPaneSite"]/*' />
        public const int WindowPaneSite = 50;
        /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchyOrder.ProjectItemContext"]/*' />
        public const int ProjectItemContext = 25;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ProvideToolWindowAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterToolWindowResourceAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell
{

    using System;
    using System.Drawing;
    using System.ComponentModel.Design;
    using System.Globalization;

    /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle"]/*' />
    public enum VsDockStyle {
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.none"]/*' />
        none,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.MDI"]/*' />
        MDI,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.Float"]/*' />
        Float,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.Linked"]/*' />
        Linked,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.Tabbed"]/*' />
        Tabbed,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.AlwaysFloat"]/*' />
        AlwaysFloat
    };
    /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation"]/*' />
    public enum ToolWindowOrientation {
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.none"]/*' />
        none,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.Top"]/*' />
        Top,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.Left"]/*' />
        Left,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.Right"]/*' />
        Right,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.Bottom"]/*' />
        Bottom
    };

    /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute"]/*' />
    /// <devdoc>
    /// This attribute declares that a package own a tool window.  Visual Studio uses this 
    /// information to handle the positioning and persistance of your window. The attributes on a 
    /// package do not control the behavior of the package, but they can be used by registration 
    /// tools to register the proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideToolWindowAttribute: RegistrationAttribute {

        private Type tool;
        private string name = null;
        private ToolWindowOrientation orientation = ToolWindowOrientation.none;
        private VsDockStyle style = VsDockStyle.none;
        private Guid dockedWith = Guid.Empty;
        private Rectangle position = Rectangle.Empty;
        private bool multiInstances = false;
        private bool transient = false;

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.ProvideToolWindowAttribute"]/*' />
        /// <devdoc>
        /// Constructor
        /// Creates a new RegisterToolWindowResourceAttribute.
        /// </devdoc>
        /// <param name="toolType">Type of the tool window</param>
        public ProvideToolWindowAttribute(Type toolType) 
        {
            tool = toolType;
            name = tool.FullName;
        }

        #region Properties
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Style"]/*' />
        /// <devdoc>
        /// Default DockStyle for the ToolWindow
        /// </devdoc>
        public VsDockStyle Style
        {
            get { return style; }
            set { style = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.PositionX"]/*' />
        /// <devdoc>
        /// Default horizontal component of the position for the to top left corner of the ToolWindow
        /// </devdoc>
        public int PositionX
        {
            get { return position.X; }
            set { position.X = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.PositionY"]/*' />
        /// <devdoc>
        /// Default vertical component of the position for the to top left corner of the ToolWindow
        /// </devdoc>
        public int PositionY
        {
            get { return position.Y; }
            set { position.Y = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Width"]/*' />
        /// <devdoc>
        /// Default width of the ToolWindow
        /// </devdoc>
        public int Width
        {
            get { return position.Width; }
            set { position.Width = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Height"]/*' />
        /// <devdoc>
        /// Default height of the ToolWindow
        /// </devdoc>
        public int Height
        {
            get { return position.Height; }
            set { position.Height = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Orientation"]/*' />
        /// <devdoc>
        /// Default Orientation for the ToolWindow, relative to the window specified by the Window Property
        /// </devdoc>
        public ToolWindowOrientation Orientation
        {
            get { return orientation; }
            set { orientation = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.ToolType"]/*' />
        /// <devdoc>
        /// Type of the ToolWindow
        /// </devdoc>
        public Type ToolType
        {
            get { return tool; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Window"]/*' />
        /// <devdoc>
        /// Default Window that the ToolWindow will be docked with
        /// </devdoc>
        public string Window
        {
            get { return dockedWith.ToString(); }
            set { dockedWith = new Guid(value); }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.MultiInstances"]/*' />
        /// <devdoc>
        /// Default Window that the ToolWindow will be docked with
        /// </devdoc>
        public bool MultiInstances
        {
            get { return multiInstances; }
            set { multiInstances = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Transient"]/*' />
        /// <devdoc>
        /// Set to true if you want to prevent window from loading on IDE start up
        /// Default is false which makes the toolwindow persistent (if the IDE is closed
        /// while the window is showing, the window will show up the next time the IDE
        /// starts).
        /// </devdoc>
        public bool Transient
        {
            get { return transient; }
            set { transient = value; }
        }

        #endregion


        /// <devdoc>
        ///        The reg key name of this Tool Window.
        /// </devdoc>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "ToolWindows\\{0}", tool.GUID.ToString("B"));
            }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Register"]/*' />
        /// <devdoc>
        /// Called to register this attribute with the given context.  The context
        /// contains the location where the registration information should be placed.
        /// it also contains such as the type being registered, and path information.
        /// </devdoc>
        public override void Register(RegistrationContext context) 
        {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyToolResource, name, tool.GUID.ToString("B")));

            using (Key childKey = context.CreateKey(RegKeyName))
            {
                // Package owning this tool window
                childKey.SetValue(string.Empty, context.ComponentType.GUID.ToString("B"));
                if (name != null)
                    childKey.SetValue("Name", name);
                if (orientation != ToolWindowOrientation.none)
                    childKey.SetValue("Orientation", OrientationToString(orientation));
                if (style != VsDockStyle.none)
                    childKey.SetValue("Style", StyleToString(style));
                if (dockedWith != Guid.Empty)
                    childKey.SetValue("Window", dockedWith.ToString("B"));
                if (position.Width != 0 && position.Height != 0)
                {
                    string positionString = string.Format(CultureInfo.InvariantCulture, "{0}, {1}, {2}, {3}",
                                position.Left,
                                position.Top,
                                position.Right,
                                position.Bottom);
                    childKey.SetValue("Float", positionString);
                }
                if (transient)
                    childKey.SetValue("DontForceCreate", 1);
            }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Unregister"]/*' />
        /// <devdoc>
        /// Unregister this Tool Window.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName);
        }

        /// <devdoc>
        /// Convert enum to string
        /// </devdoc>
        private string StyleToString(VsDockStyle style)
        {
            switch (style)
            {
                case VsDockStyle.MDI:
                {
                    return "MDI";
                }
                case VsDockStyle.Float:
                {
                    return "Float";
                }
                case VsDockStyle.Linked:
                {
                    return "Linked";
                }
                case VsDockStyle.Tabbed:
                {
                    return "Tabbed";
                }
                case VsDockStyle.AlwaysFloat:
                {
                    return "AlwaysFloat";
                }
                case VsDockStyle.none:
                {
                    return string.Empty;
                }
                default:
                    throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_UnknownDockingStyle, style));
            }
        }

        /// <devdoc>
        /// Convert enum to string
        /// </devdoc>
        private string OrientationToString(ToolWindowOrientation position)
        {
            switch (position)
            {
                case ToolWindowOrientation.Top:
                {
                    return "Top";
                }
                case ToolWindowOrientation.Left:
                {
                    return "Left";
                }
                case ToolWindowOrientation.Right:
                {
                    return "Right";
                }
                case ToolWindowOrientation.Bottom:
                {
                    return "Bottom";
                }
                case ToolWindowOrientation.none:
                {
                    return string.Empty;
                }
                default:
                    throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_UnknownPosition, position));
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\TaskCategory.cs ===
//------------------------------------------------------------------------------
// <copyright file="TaskCategory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory"]' />
    /// <devdoc>
    ///     This class implements IVsTask.  It provides a 
    ///     framework-friendly way to define a package and its associated 
    ///     services.
    /// </devdoc>
    public enum TaskCategory {
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.All"]/*' />
        All = VSTASKCATEGORY.CAT_ALL,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.BuildCompile"]/*' />
        BuildCompile = VSTASKCATEGORY.CAT_BUILDCOMPILE,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.Comments"]/*' />
        Comments = VSTASKCATEGORY.CAT_COMMENTS,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.CodeSense"]/*' />
        CodeSense = VSTASKCATEGORY.CAT_CODESENSE,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.ShortCuts"]/*' />
        ShortCuts = VSTASKCATEGORY.CAT_SHORTCUTS,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.User"]/*' />
        User = VSTASKCATEGORY.CAT_USER,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.Misc"]/*' />
        Misc = VSTASKCATEGORY.CAT_MISC,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.Html"]/*' />
        Html = VSTASKCATEGORY.CAT_HTML
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\TaskErrorCategory.cs ===
//------------------------------------------------------------------------------
// <copyright file="TaskErrorCategory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\TaskErrorCategory.uex' path='docs/doc[@for="TaskErrorCategory"]' />
    /// <devdoc>
    /// </devdoc>
    public enum TaskErrorCategory {
        /// <include file='doc\TaskErrorCategory.uex' path='docs/doc[@for="TaskErrorCategory.Error"]' />
        Error = __VSERRORCATEGORY.EC_ERROR,
        /// <include file='doc\TaskErrorCategory.uex' path='docs/doc[@for="TaskErrorCategory.Warning"]' />
        Warning = __VSERRORCATEGORY.EC_WARNING,
        /// <include file='doc\TaskErrorCategory.uex' path='docs/doc[@for="TaskErrorCategory.Message"]' />
        Message = __VSERRORCATEGORY.EC_MESSAGE
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\TaskPriority.cs ===
//------------------------------------------------------------------------------
// <copyright file="TaskPriority.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\TaskPriority.uex' path='docs/doc[@for="TaskPriority"]' />
    /// <devdoc>
    ///     This class implements IVsTask.  It provides a 
    ///     framework-friendly way to define a package and its associated 
    ///     services.
    /// </devdoc>
    public enum TaskPriority {
    	/// <include file='doc\TaskPriority.uex' path='docs/doc[@for="TaskPriority.High"]/*' />
    	High = VSTASKPRIORITY.TP_HIGH,
    	/// <include file='doc\TaskPriority.uex' path='docs/doc[@for="TaskPriority.Normal"]/*' />
    	Normal = VSTASKPRIORITY.TP_NORMAL,
    	/// <include file='doc\TaskPriority.uex' path='docs/doc[@for="TaskPriority.Low"]/*' />
    	Low = VSTASKPRIORITY.TP_LOW
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\RegistrationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegistrationAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.IO;

    /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationMethod"]/*' />
    /// <summary>
    /// How should the assembly be registered/located
    /// </summary>
    public enum RegistrationMethod {
        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationMethod.Default"]/*' />
        /// <summary>
        /// Default should only be used by tools
        /// </summary>
        Default = 0, 
        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationMethod.CodeBase"]/*' />
        /// <summary>
        /// The path to the assembly should be stored in the registry and used to locate the assembly at runtime
        /// </summary>
        CodeBase,
        /// <summary>
        /// The assembly should be in the GAC or in PrivateAssemblies
        /// </summary>
        Assembly};

    /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationAttribute"]' />
    /// <devdoc>
    ///     This attribute is the basis for all other attributes that can be registered by RegPkg.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    public abstract class RegistrationAttribute : Attribute {

        /// <summary>
        /// Override the TypeID property in order to let the RegistrationAttribute derived
        /// classes to work with System.ComponentModel.TypeDescriptor.GetAttributes(...).
        /// An attribute derived from this one will have to override this property only if
        /// it needs a better control on the instances that can be applied to a class.
        /// </summary>
        public override object TypeId
        {
            get
            {
                Type t = this.GetType();
                // Only one AttributeUsage attribute can be applyed to an attribute and the default
                // value is AllowMultiple = false. If both a base and derived attribute have an
                // AttributeUsage, only the one of the derived one will be returned by GetCustomAttributes.
                // We use a foreach because it will protect us from an empty collection
                // (it should never happen, but it is better to be safe) and because it will do
                // all the casts.
                bool isMultiple = false;
                foreach (AttributeUsageAttribute au in t.GetCustomAttributes(typeof(AttributeUsageAttribute), true))
                {
                    isMultiple = au.AllowMultiple;
                    // It should not be possible to have more than one AttributeUsageAttribute, but just in case...
                    break;
                }
                if (isMultiple)
                    return this;
                return t;
            }
        }

        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration information should be placed.
        ///     It also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public abstract void Register(RegistrationContext context);

        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        ///     Called to unregister this attribute with the given context.  The context
        ///     contains the location where the registration information should be removed.
        ///     It also contains things such as the type being unregistered, and path information.
        /// </devdoc>
        public abstract void Unregister(RegistrationContext context);
        
        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key"]' />
        /// <devdoc>
        ///     Abstraction around a registry key.  This may or may not actually
        ///     point to a real registry key.  It could point to a file.
        /// </devdoc>
        public abstract class Key : IDisposable {
            
            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key.Close"]' />
            /// <devdoc>
            ///     Called to close this key.  Alternately, you may use the C# "using"
            ///     syntax on keys, since they are IDisposable. Always close keys when you
            ///     are done with them.
            /// </devdoc>
            public abstract void Close();

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key.CreateSubkey"]' />
            /// <devdoc>
            ///     Creates a subkey of the given name.
            /// </devdoc>
            public abstract Key CreateSubkey(string name);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key.SetValue"]' />
            /// <devdoc>
            ///     Sets the name to the given value. Pass an empty string or null into this to
            ///     set the default value for a key.
            /// </devdoc>
            public abstract void SetValue(string valueName, object value);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key.IDisposable.Dispose"]/*' />
            /// <internalonly/>
            /// <devdoc>
            /// Closes the key.
            /// </devdoc>
            void IDisposable.Dispose() {
                Close();
            }
        }

        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext"]' />
        /// <devdoc>
        ///     Abstraction around the registry itself.
        /// </devdoc>
        public abstract class RegistrationContext {
            
            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.ComponentPath"]' />
            /// <devdoc>
            ///     The path to the compnent that is being registered.  You should always use this rather than the 
            ///     codebase of the component type, and you should never assume that this is a physical path on
            ///     disk.  It may be a token that identifies the path at install time.  The "component"
            ///     is the type that the registration attribute was found on.
            /// </devdoc>
            public abstract string ComponentPath { get; }

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RegisteringType"]' />
            /// <devdoc>
            ///     The type of the component that is being registered.
            /// </devdoc>
            public abstract Type ComponentType { get; }

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.InprocServerPath"]' />
            /// <devdoc>
            ///     The path to the COM object supplying the class factory.
            /// </devdoc>
            public abstract string InprocServerPath { get;}

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.CodeBase"]' />
            /// <devdoc>
            ///     The path to the object being registered (including filename).
            /// </devdoc>
            public abstract string CodeBase { get;}

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RootFolder"]' />
            /// <devdoc>
            ///     The path to the installation for the host application (e.g. Visual Studio "C:\Program Files\Microsoft Visual Studio <version>\").
            /// </devdoc>
            public abstract string RootFolder { get; }

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RegistrationMethod"]' />
            /// <devdoc>
            /// Specify if the assembly should be located using CodeBase or Assembly
            /// </devdoc>
            public abstract RegistrationMethod RegistrationMethod{get;}

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.Log"]' />
            /// <devdoc>
            ///     Returns a text writer that can be used to log registration information.  This should 
            ///     be a human readable (and ideally localized) bit of text that describes the
            ///     current registration process.
            /// </devdoc>
            public abstract TextWriter Log { get; }

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.CreateKey"]' />
            /// <devdoc>
            ///     Creates a new key of the given name.  The key is created at the appropriate registration
            ///     point in the registry.  Always close or dispose this key when finished with it.
            /// </devdoc>
            public abstract Key CreateKey(string name);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RemoveKey"]' />
            /// <devdoc>
            /// Removes the key of the given name.
            /// </devdoc>
            public abstract void RemoveKey(string name);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RemoveValue"]' />
            /// <devdoc>
            /// Removes the value of the given name under the key of the given keyname
            /// </devdoc>
            public abstract void RemoveValue(string keyname, string valuename);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RemoveKey"]' />
            /// <devdoc>
            /// Removes the key of the given name if it has no child key and
            /// no value.
            /// </devdoc>
            public abstract void RemoveKeyIfEmpty(string name);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.EscapePath"]' />
            /// <devdoc>
            /// Escape the string if needed
            /// This is used by the implementation of the Register method on attributes so that paths be escaped when
            /// needed. The attribute itself does not know if we are writting to a .reg file or directly to the registry.
            /// </devdoc>
            public abstract string EscapePath(string str);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\RegisterEditorExtensionAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterEditorExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.IO;
    using System.Globalization;


    /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute"]' />
    /// <devdoc>
    ///     This attribute associates a file extension to a given editor factory.  
    ///     The editor factory may be specified as either a GUID or a type and 
    ///     is placed on a package.
    /// </devdoc>
    [Obsolete("RegisterEditorExtensionAttribute has been deprecated. Please use ProvideEditorExtensionAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterEditorExtensionAttribute : RegistrationAttribute {

        private Guid factory;
        private string extension;
        private int priority;
        private Guid project;
        private string templateDir;
        private int resId;
        private bool editorFactoryNotify;
        
        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.RegisterEditorExtensionAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public RegisterEditorExtensionAttribute (object factoryType, string extension, int priority) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_ExtensionNeedsDot, extension));
            }

            // figure out what type of object they passed in and get the GUID from it
            if (factoryType is string)
                this.factory = new Guid((string)factoryType);
            else if (factoryType is Type)
                this.factory = ((Type)factoryType).GUID;
            else if (factoryType is Guid)
                this.factory = (Guid)factoryType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, factoryType));

            this.extension = extension;
            this.priority = priority;
            this.project = Guid.Empty;
            this.templateDir = "";
            this.resId = 0;
            this.editorFactoryNotify = false;
        }
        
        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.Extension"]' />
        /// <devdoc>
        ///     The file extension of the file.
        /// </devdoc>
        public string Extension {
            get {
                return extension;
            }
        }
        
        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.Factory"]' />
        /// <devdoc>
        ///     The editor factory guid.
        /// </devdoc>
        public Guid Factory {
            get {
                return factory;
            }
        }
        
        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.Priority"]' />
        /// <devdoc>
        ///     The priority of this extension registration.
        /// </devdoc>
        public int Priority {
            get {
                return priority;
            }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.ProjectGuid"]/*' />
        public string ProjectGuid {
            set { project = new System.Guid(value); }
            get { return project.ToString(); }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.EditorFactoryNotify"]/*' />
        public bool EditorFactoryNotify {
            get { return this.editorFactoryNotify; }
            set { this.editorFactoryNotify = value; }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.TemplateDir"]/*' />
        public string TemplateDir {
            get { return templateDir; }
            set { templateDir = value; }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.NameResourceID"]/*' />
        public int NameResourceID {
            get { return resId; }
            set { resId = value; }
        }

        /// <devdoc>
        ///        The reg key name of this extension.
        /// </devdoc>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}", Factory.ToString("B"));
            }
        }

        /// <devdoc>
        ///        The reg key name of the project.
        /// </devdoc>
        private string ProjectRegKeyName(RegistrationContext context) 
        {
            return string.Format(CultureInfo.InvariantCulture,
                                 "Projects\\{0}\\AddItemTemplates\\TemplateDirs\\{1}",
                                 project.ToString("B"),
                                 context.ComponentType.GUID.ToString("B"));
        }

        private string EditorFactoryNotifyKey {
            get { return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\FileExtensions\\{1}",
                                       project.ToString("B"),
                                       Extension);
            }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyEditorExtension, Extension, Factory.ToString("B")));

            using (Key editorKey = context.CreateKey(RegKeyName))
            {
                if (0 != resId)
                    editorKey.SetValue("DisplayName", "#" + resId.ToString(CultureInfo.InvariantCulture));
                editorKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
            }

            using (Key extensionKey = context.CreateKey(RegKeyName + "\\Extensions"))
            {
                extensionKey.SetValue(Extension.Substring(1), Priority);
            }

            // Build the path of the registry key for the "Add file to project" entry
            if (project != Guid.Empty)
            {
                string prjRegKey = ProjectRegKeyName(context) + "\\/1";
                using (Key projectKey = context.CreateKey( prjRegKey ))
                {
                    if (0 != resId)
                        projectKey.SetValue("", "#" + resId.ToString(CultureInfo.InvariantCulture));
                    if (templateDir.Length != 0)
                    {
                        Uri url = new Uri(context.ComponentType.Assembly.CodeBase, true);
                        string templates = url.LocalPath;
                        templates = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(templates), templateDir);
                        templates = context.EscapePath( System.IO.Path.GetFullPath(templates) );
                        projectKey.SetValue("TemplatesDir", templates);
                    }
                    projectKey.SetValue("SortPriority", Priority);
                }
            }

            // Register the EditorFactoryNotify
            if ( EditorFactoryNotify )
            {
                // The IVsEditorFactoryNotify interface is called by the project system, so it doesn't make sense to
                // register it if there is no project associated to this editor.
                if (project == Guid.Empty)
                    throw new ArgumentException(Resources.Attributes_NoPrjForEditorFactoryNotify);

                // Create the registry key
                using (Key edtFactoryNotifyKey = context.CreateKey(EditorFactoryNotifyKey))
                {
                    edtFactoryNotifyKey.SetValue("EditorFactoryNotify", context.ComponentType.GUID.ToString("B"));
                }
            }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Unregister this editor.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName);
            if (project != Guid.Empty)
            {
                context.RemoveKey(ProjectRegKeyName(context));
                if (EditorFactoryNotify)
                    context.RemoveKey(EditorFactoryNotifyKey);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ToolWindowPane.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolWindowPane.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;

using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;

namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane"]/*' />
    /// <summary>
    /// Summary description for ToolWindowPane.
    /// </summary>
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class ToolWindowPane : WindowPane
    {
        private string caption;
        private IVsWindowFrame frame = null;
        private Microsoft.VisualStudio.Shell.Package package = null;
        private CommandID toolBarCommandID = null;
        private VSTWT_LOCATION toolBarLocation;
        private int bitmapResourceID;
        private int bitmapIndex;
        private Guid toolClsid;

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.ToolWindowPane"]/*' />
        /// <summary>
        /// Constructor
        /// </summary>
        protected ToolWindowPane(IServiceProvider provider)
        :
        base(provider)
        {
            toolClsid = Guid.Empty;
            bitmapIndex = -1;
            bitmapResourceID = -1;
            toolBarLocation = VSTWT_LOCATION.VSTWT_TOP;
        }
    
        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.Caption"]/*' />
        /// <summary>
        /// Get or Set the text on the title bar of the ToolWindow
        /// </summary>
        /// <value></value>
        public string Caption
        {
            get { return caption; }
            set
            {
                caption = value;
                if (frame != null && caption != null)
                {
                    // Since the window is already created, set the coresponding property
                    int hr = NativeMethods.S_OK;
                    try {
                        hr = frame.SetProperty((int)__VSFPROPID.VSFPROPID_Caption, caption);
                    } catch (COMException e) {
                        hr = e.ErrorCode;
                    }
                    Debug.Assert(hr >= 0, "Failed to set caption on toolwindow");
                }
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.Frame"]/*' />
        /// <summary>
        /// Get or Set the Frame (IvsWindowFrame) hosting the ToolWindow
        /// </summary>
        public object Frame
        {
            get { return frame; }
            set
            {
                frame = (IVsWindowFrame)value;
                // Fire the event to let any custom creation code run
                OnToolWindowCreated();
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.Package"]/*' />
        /// <summary>
        /// Get or Set the Package (Microsoft.VisualStudio.Shell.Package) owning the ToolWindow.
        /// This should only be set by the base Package class when it creates the toolwindow.
        /// </summary>
        public object Package
        {
            get { return package; }
            set
            {
                if (frame != null || package != null)
                    throw new NotSupportedException(Resources.ToolWindow_PackageOnlySetByCreator);
                package = (Microsoft.VisualStudio.Shell.Package)value;
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.ToolBar"]/*' />
        /// <summary>
        /// If the toolwindow has a ToolBar, it is described by this parameter.
        /// Otherwise this is null
        /// </summary>
        public CommandID ToolBar
        {
            get { return toolBarCommandID; }
            set
            {
                if (frame != null)
                    throw new Exception(Resources.ToolWindow_TooLateToAddToolbar);
                toolBarCommandID = value;
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.ToolBarLocation"]/*' />
        /// <summary>
        /// Get or Set where the toolbar should be in the tool window (Up, down, left, right).
        /// This parameter is based on VSTWT_LOCATION
        /// </summary>
        public int ToolBarLocation
        {
            get { return (int)toolBarLocation; }
            set
            {
                if (frame != null)
                    throw new Exception(Resources.ToolWindow_TooLateToAddToolbar);
                toolBarLocation = (VSTWT_LOCATION)value;
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.ToolClsid"]/*' />
        /// <summary>
        /// This is used to specify the CLSID of a tool that should be used for this toolwindow
        /// </summary>
        public Guid ToolClsid
        {
            get { return toolClsid; }
            set
            {
                if (frame != null)
                    throw new Exception(Resources.ToolWindow_TooLateToAddTool);
                toolClsid = value;
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.BitmapResourceID"]/*' />
        /// <summary>
        /// Get or Set the resource ID for the bitmap strip from which to take the window frame icon
        /// </summary>
        public int BitmapResourceID
        {
            get { return bitmapResourceID; }
            set
            {
                bitmapResourceID = value;
                if (frame != null && bitmapResourceID != -1)
                {
                    int hr = NativeMethods.S_OK;
                    // Since the window is already created, set the coresponding property
                    try {
                        hr = frame.SetProperty((int)__VSFPROPID.VSFPROPID_BitmapResource, bitmapResourceID);
                    } catch (COMException e) {
                        hr = e.ErrorCode;
                    }
                    Debug.Assert(hr >= 0, "Failed to set bitmap resource on toolwindow");
                }
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.BitmapIndex"]/*' />
        /// <summary>
        /// Get or Set the index of the image to use in the bitmap strip for the window frame icon
        /// </summary>
        public int BitmapIndex
        {
            get { return bitmapIndex; }
            set
            {
                bitmapIndex = value;
                if (frame != null && bitmapIndex != -1)
                {
                    int hr = NativeMethods.S_OK;
                    // Since the window is already created, set the coresponding property
                    try {
                        hr = frame.SetProperty((int)__VSFPROPID.VSFPROPID_BitmapIndex, bitmapIndex);
                    } catch (COMException e) {
                        hr = e.ErrorCode;
                    }
                    Debug.Assert(hr >= 0, "Failed to set bitmap index on toolwindow");
                }
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.GetIVsWindowPane"]/*' />
        /// <summary>
        /// This method make it possible to provide an IVsWindowPane not derived from ToolWindowPane
        /// To support that scenario one would override this method and create their IVsWindowPane and
        /// return it.
        /// </summary>
        /// <returns>IVsWindowPane to be hosted in the toolwindow frame</returns>
        public virtual object GetIVsWindowPane()
        {
            return (IVsWindowPane)this;
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.OnToolWindowCreated"]/*' />
        /// <summary>
        /// This method can be overriden by the derived class to execute
        /// any code that needs to run after the IVsWindowFrame is created.
        /// If the toolwindow has a toolbar with a combobox, it should make
        /// sure its command handler are set by the time they return from
        /// this method.
        /// This is called when someone set the Frame property.
        /// </summary>
        public virtual void OnToolWindowCreated()
        {
            Debug.Assert(frame != null, "Frame should be set before this method is called");

            // If any property were set, set them on the frame (setting our properties will take care of it)
            Caption = caption;
            BitmapResourceID = bitmapResourceID;
            BitmapIndex = bitmapIndex;
        }

        /// <summary>
        /// This should be overriden if you want to run code before the window is shown
        /// but after its toolbar is added.
        /// </summary>
        public virtual void OnToolBarAdded()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\ServiceProvider.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider"]' />
    /// <devdoc>
    ///     This class acts as a bridge between Microsoft.VisualStudio.OLE.Interop.IServiceProvider 
    ///     and System.IServiceProvider.  It implements System.IServiceProvider and takes 
    ///     as a constructor argument an instance of Microsoft.VisualStudio.OLE.Interop.IServiceProvider.  
    ///     It supports both GUID and type based lookups and also has debug code to assert 
    ///     for common native implementation pitfalls, like not implementing IUnknown on 
    ///     an object or requiring a specific IID along with a matching SID.
    /// </devdoc>
    [CLSCompliant(false)]
	[System.Runtime.InteropServices.ComVisible(true)]
    public sealed class ServiceProvider : IServiceProvider, IDisposable, IObjectWithSite {
        
        private static TraceSwitch TRACESERVICE = new TraceSwitch("TRACESERVICE", "ServiceProvider: Trace service provider requests.");

        private IOleServiceProvider    serviceProvider;
        private bool                   defaultServices;

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.ServiceProvider"]' />
        /// <devdoc>
        ///     Creates a new ServiceProvider object and uses the given interface to resolve
        ///     services.
        /// </devdoc>
        public ServiceProvider(IOleServiceProvider sp) : this(sp, true){
        }
        
        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.ServiceProvider1"]' />
        /// <devdoc>
        ///     Creates a new ServiceProvider object and uses the given interface to resolve
        ///     services.  If defaultServices is true (the default) this service  provider will
        ///     respond to Microsoft.VisualStudio.OLE.Interop.IServiceProvider and IObjectWithSite
        ///     as services.  A query for Microsoft.VisualStudio.OLE.Interop.IServiceProvider will
        ///     return the underlying COM service provider and a query for IObjectWithSite will
        ///     return this object.  If false is passed into defaultServices these two services
        ///     will not be provided and the service provider will be "transparent".
        /// </devdoc>
        public ServiceProvider(IOleServiceProvider sp, bool defaultServices) {
            if (sp == null) {
                throw new ArgumentNullException("sp");
            }
            this.serviceProvider = sp;
            this.defaultServices = defaultServices;
        }
        
        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.Dispose"]' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dispose() {
            if (serviceProvider != null) {
                serviceProvider = null;
            }
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.GetService"]' />
        /// <devdoc>
        ///     Retrieves the requested service.
        /// </devdoc>
        public object GetService(Type serviceType) {

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            // If we have already been disposed, disallow all service
            // requests.
            //
            if (serviceProvider == null) {
                return null;
            }
            
            // First, can we resolve this service class into a GUID?  If not, then
            // we have nothing to pass.
            //
            Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Resolving service '" + serviceType.FullName + " through the service provider " + serviceProvider.ToString() + ".");
            return GetService(serviceType.GUID, serviceType);
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.GetService1"]' />
        /// <devdoc>
        ///     Retrieves the requested service.
        /// </devdoc>
        public object GetService(Guid guid) {
            return GetService(guid, null);
        }

        /// <devdoc>
        ///     Retrieves the requested service.  The guid must be specified; the class is only
        ///     used when debugging and it may be null.
        /// </devdoc>
        private object GetService(Guid guid, Type serviceType) {
            object service = null;

            // No valid guid on the passed in class, so there is no service for it.
            //
            if (guid.Equals(Guid.Empty)) {
                Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "\tNo SID -- Guid is empty");
                return null;
            }

            // We provide a couple of services of our own.
            //
            if (defaultServices) {
                if (guid.Equals(NativeMethods.IID_IServiceProvider)) {
                    return serviceProvider;
                }
                if (guid.Equals(NativeMethods.IID_IObjectWithSite)) {
                    return (IObjectWithSite)this;
                }
            }

            IntPtr pUnk = IntPtr.Zero;
            Guid guidUnk = NativeMethods.IID_IUnknown;
            int hr = serviceProvider.QueryService(ref guid, ref guidUnk, out pUnk);

            if ( (NativeMethods.Succeeded(hr)) && (IntPtr.Zero != pUnk) ) {
                try {
                    service = Marshal.GetObjectForIUnknown(pUnk);
                }
                finally {
                    Marshal.Release(pUnk);
                }
            }
            else {
                service = null;

                // These may be interesting to log.
                //
                Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "\tQueryService failed");

                #if DEBUG
                // Ensure that this service failure was not the result of a bad QI implementation.
                // In C++, 99% of a service query uses SID == IID, but for us, we always use IID = IUnknown
                // first.  If the service didn't implement IUnknown correctly, we'll fail the service request
                // and it's very difficult to track this down. 
                //
                pUnk = IntPtr.Zero;
                hr = serviceProvider.QueryService(ref guid, ref guid, out pUnk);

                if ( (NativeMethods.Succeeded(hr)) && (IntPtr.Zero != pUnk) ) {
                    object obj = null;
                    try {
                        obj = Marshal.GetObjectForIUnknown(pUnk);
                    }
                    finally {
                        Marshal.Release(pUnk);
                    }

                    // Note that I do not return this service if we succeed -- I don't
                    // want to make debug work correctly when retail doesn't!
                    Debug.Assert(!System.Runtime.InteropServices.Marshal.IsComObject(obj),
                                 "The service " + (serviceType != null ? serviceType.Name : guid.ToString()) +
                                 " implements it's own interface, but does not implement IUnknown!\r\n" +
                                 "This is a bad service implementation, not a problem in the CLR service provider mechanism." + obj.ToString());
                }

                #endif
            }

            return service;
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.IObjectWithSite.GetSite"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the current site object we're using to
        /// resolve services.
        /// </devdoc>
        void IObjectWithSite.GetSite(ref Guid riid, out IntPtr ppv) {
            object o = GetService(riid);
            if (o == null) {
                Marshal.ThrowExceptionForHR(NativeMethods.E_NOINTERFACE);
            }

            IntPtr punk = Marshal.GetIUnknownForObject(o);
            int hr = Marshal.QueryInterface(punk, ref riid, out ppv);
            Marshal.Release(punk);
            if (NativeMethods.Failed(hr)) {
                Marshal.ThrowExceptionForHR(hr);
            }
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.IObjectWithSite.SetSite"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Sets the site object we will be using to resolve services.
        /// </devdoc>
        void IObjectWithSite.SetSite(object pUnkSite) {
            if (pUnkSite is IOleServiceProvider) {
                serviceProvider = (IOleServiceProvider)pUnkSite;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To register the {0} file extension, you must prefix the extension with a &apos;.&apos;..
        /// </summary>
        internal static string Attributes_ExtensionNeedsDot {
            get {
                return ResourceManager.GetString("Attributes_ExtensionNeedsDot", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The factoryType must be of one of those type: Type, Guid, string (representing a Guid)..
        /// </summary>
        internal static string Attributes_InvalidFactoryType {
            get {
                return ResourceManager.GetString("Attributes_InvalidFactoryType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No project guid provided, but it is needed to register the extension for EditorFactoryNotify..
        /// </summary>
        internal static string Attributes_NoPrjForEditorFactoryNotify {
            get {
                return ResourceManager.GetString("Attributes_NoPrjForEditorFactoryNotify", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No Product Name was specified.  To register as an Installed Product, a Product Name is required..
        /// </summary>
        internal static string Attributes_ProductNameNotSpecified {
            get {
                return ResourceManager.GetString("Attributes_ProductNameNotSpecified", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unknown docking style: {0}..
        /// </summary>
        internal static string Attributes_UnknownDockingStyle {
            get {
                return ResourceManager.GetString("Attributes_UnknownDockingStyle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unknown relative position: {0}..
        /// </summary>
        internal static string Attributes_UnknownPosition {
            get {
                return ResourceManager.GetString("Attributes_UnknownPosition", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Failed to retrieve service {0}..
        /// </summary>
        internal static string Flavor_FailedToGetService {
            get {
                return ResourceManager.GetString("Flavor_FailedToGetService", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Expecting an array of size greater than zero..
        /// </summary>
        internal static string General_ArraySizeShouldBeAtLeast1 {
            get {
                return ResourceManager.GetString("General_ArraySizeShouldBeAtLeast1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Expected string that is not empty..
        /// </summary>
        internal static string General_ExpectedNonEmptyString {
            get {
                return ResourceManager.GetString("General_ExpectedNonEmptyString", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Expected object of type {0}..
        /// </summary>
        internal static string General_InvalidType {
            get {
                return ResourceManager.GetString("General_InvalidType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The service &apos;{0}&apos; must be installed for this feature to work.  Ensure that this service is available..
        /// </summary>
        internal static string General_MissingService {
            get {
                return ResourceManager.GetString("General_MissingService", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method called on a disposed object of type {0}..
        /// </summary>
        internal static string General_ObjectDisposed {
            get {
                return ResourceManager.GetString("General_ObjectDisposed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unsupported value: {0}..
        /// </summary>
        internal static string General_UnsupportedValue {
            get {
                return ResourceManager.GetString("General_UnsupportedValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The dialog page type {0} does not derive from DialogPage..
        /// </summary>
        internal static string Package_BadDialogPageType {
            get {
                return ResourceManager.GetString("Package_BadDialogPageType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The solution option name {0} is invalid.  It cannot contain &apos;.&apos;, &apos;/&apos; or other special characters..
        /// </summary>
        internal static string Package_BadOptionName {
            get {
                return ResourceManager.GetString("Package_BadOptionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The service {0} already exists in the service container..
        /// </summary>
        internal static string Package_DuplicateService {
            get {
                return ResourceManager.GetString("Package_DuplicateService", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Instance ID {0} is invalid..
        /// </summary>
        internal static string Package_InvalidInstanceID {
            get {
                return ResourceManager.GetString("Package_InvalidInstanceID", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The service instance must derive from or implement {0}..
        /// </summary>
        internal static string Package_InvalidServiceInstance {
            get {
                return ResourceManager.GetString("Package_InvalidServiceInstance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to CreateToolWindow only creates Tool Windows derived from ToolWindowPane..
        /// </summary>
        internal static string Package_InvalidToolWindowClass {
            get {
                return ResourceManager.GetString("Package_InvalidToolWindowClass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The package requires that service &apos;{0}&apos; be installed.  Ensure that this service is available..
        /// </summary>
        internal static string Package_MissingService {
            get {
                return ResourceManager.GetString("Package_MissingService", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The solution option name {0} is already used by this package..
        /// </summary>
        internal static string Package_OptionNameUsed {
            get {
                return ResourceManager.GetString("Package_OptionNameUsed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The page type {0} does not offer an empty constructor..
        /// </summary>
        internal static string Package_PageCtorMissing {
            get {
                return ResourceManager.GetString("Package_PageCtorMissing", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The page type {0} does not implement {1}..
        /// </summary>
        internal static string Package_PageMissingInterface {
            get {
                return ResourceManager.GetString("Package_PageMissingInterface", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The page class {0} must derive from DialogPage..
        /// </summary>
        internal static string Package_PageNotDialogPage {
            get {
                return ResourceManager.GetString("Package_PageNotDialogPage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A site has already been set on package {0}..
        /// </summary>
        internal static string Package_SiteAlreadySet {
            get {
                return ResourceManager.GetString("Package_SiteAlreadySet", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameters {0} and {1} have incompatible types.
        /// </summary>
        internal static string Reg_ErrorIncompatibleParametersTypes {
            get {
                return ResourceManager.GetString("Reg_ErrorIncompatibleParametersTypes", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Autoload package:         {0}.
        /// </summary>
        internal static string Reg_NotifyAutoLoad {
            get {
                return ResourceManager.GetString("Reg_NotifyAutoLoad", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Creatable Object: {0}.
        /// </summary>
        internal static string Reg_NotifyCreateObject {
            get {
                return ResourceManager.GetString("Reg_NotifyCreateObject", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Editor Extension: {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyEditorExtension {
            get {
                return ResourceManager.GetString("Reg_NotifyEditorExtension", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Editor Factory:   {0}.
        /// </summary>
        internal static string Reg_NotifyEditorFactory {
            get {
                return ResourceManager.GetString("Reg_NotifyEditorFactory", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Logical View:     {0}.
        /// </summary>
        internal static string Reg_NotifyEditorView {
            get {
                return ResourceManager.GetString("Reg_NotifyEditorView", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Extender:         {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyExtender {
            get {
                return ResourceManager.GetString("Reg_NotifyExtender", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Installed Product:   {0}, Version {1}.
        /// </summary>
        internal static string Reg_NotifyInstalledProduct {
            get {
                return ResourceManager.GetString("Reg_NotifyInstalledProduct", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Installed Product:   Using IVsInstalledProduct interface.
        /// </summary>
        internal static string Reg_NotifyInstalledProductInterface {
            get {
                return ResourceManager.GetString("Reg_NotifyInstalledProductInterface", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Key Binding: {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyKeyBinding {
            get {
                return ResourceManager.GetString("Reg_NotifyKeyBinding", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Language Code Expansion: {0}.
        /// </summary>
        internal static string Reg_NotifyLanguageCodeExpansion {
            get {
                return ResourceManager.GetString("Reg_NotifyLanguageCodeExpansion", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Language Extension: {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyLanguageExtension {
            get {
                return ResourceManager.GetString("Reg_NotifyLanguageExtension", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LanguageOptionCategory: {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyLanguageOptionCategory {
            get {
                return ResourceManager.GetString("Reg_NotifyLanguageOptionCategory", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Language Option Page: {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyLanguageOptionPage {
            get {
                return ResourceManager.GetString("Reg_NotifyLanguageOptionPage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Language Service: {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyLanguageService {
            get {
                return ResourceManager.GetString("Reg_NotifyLanguageService", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LoadKey:          {0} {1}
        ///Version {2}
        ///Edition Required: {3}.
        /// </summary>
        internal static string Reg_NotifyLoadKey {
            get {
                return ResourceManager.GetString("Reg_NotifyLoadKey", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Menu:             {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyMenuResource {
            get {
                return ResourceManager.GetString("Reg_NotifyMenuResource", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Option Page:      {0}\{1}.
        /// </summary>
        internal static string Reg_NotifyOptionPage {
            get {
                return ResourceManager.GetString("Reg_NotifyOptionPage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Package:          {0} {1}.
        /// </summary>
        internal static string Reg_NotifyPackage {
            get {
                return ResourceManager.GetString("Reg_NotifyPackage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Project Factory:  {0}.
        /// </summary>
        internal static string Reg_NotifyProjectFactory {
            get {
                return ResourceManager.GetString("Reg_NotifyProjectFactory", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Project Items:    {0}.
        /// </summary>
        internal static string Reg_NotifyProjectItems {
            get {
                return ResourceManager.GetString("Reg_NotifyProjectItems", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Service:          {0}.
        /// </summary>
        internal static string Reg_NotifyService {
            get {
                return ResourceManager.GetString("Reg_NotifyService", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Toolbox Items:    Version {0} (Formats: {1}).
        /// </summary>
        internal static string Reg_NotifyToolboxItem {
            get {
                return ResourceManager.GetString("Reg_NotifyToolboxItem", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Toolbox Config:   {0}.
        /// </summary>
        internal static string Reg_NotifyToolboxItemConfiguration {
            get {
                return ResourceManager.GetString("Reg_NotifyToolboxItemConfiguration", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to                    Filter: {0}.
        /// </summary>
        internal static string Reg_NotifyToolboxItemFilter {
            get {
                return ResourceManager.GetString("Reg_NotifyToolboxItemFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Toolbox Page:     {0}.
        /// </summary>
        internal static string Reg_NotifyToolboxPage {
            get {
                return ResourceManager.GetString("Reg_NotifyToolboxPage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ToolWindow:       {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyToolResource {
            get {
                return ResourceManager.GetString("Reg_NotifyToolResource", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Tool Visibility:  {0}, {1}.
        /// </summary>
        internal static string Reg_NotifyToolVisibility {
            get {
                return ResourceManager.GetString("Reg_NotifyToolVisibility", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The package property of the tool window should only be set by the creator of the tool window..
        /// </summary>
        internal static string ToolWindow_PackageOnlySetByCreator {
            get {
                return ResourceManager.GetString("ToolWindow_PackageOnlySetByCreator", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to toolClsid cannot be added after the Frame is created.
        ///Add the toolClsid in the ToolWindow constructor..
        /// </summary>
        internal static string ToolWindow_TooLateToAddTool {
            get {
                return ResourceManager.GetString("ToolWindow_TooLateToAddTool", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Toolbar cannot be added after the Frame is created.
        ///Add the ToolBar in the ToolWindow constructor..
        /// </summary>
        internal static string ToolWindow_TooLateToAddToolbar {
            get {
                return ResourceManager.GetString("ToolWindow_TooLateToAddToolbar", resourceCulture);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\RunningDocumentTable.cs ===
//--------------------------------------------------------------------------
//  <copyright file="RunningDocumentTable.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Collections;
using System.Xml;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using Microsoft.VisualStudio.Shell;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;

namespace Microsoft.VisualStudio.Shell {

    public class RunningDocumentTable : IEnumerable<RunningDocumentInfo> {
        IServiceProvider site;
        IVsRunningDocumentTable rdt;

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.RunningDocumentTable"]/*' />
        public RunningDocumentTable(IServiceProvider site) {
            this.site = site;
            this.rdt = site.GetService(typeof(SVsRunningDocumentTable)) as IVsRunningDocumentTable;
            if (this.rdt == null){
                throw new System.NotSupportedException(typeof(SVsRunningDocumentTable).FullName);
            }
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.FindDocument"]/*' />
        public object FindDocument(string moniker) {
            IVsHierarchy hierarchy;
            uint itemid;
            uint docCookie;
            return FindDocument(moniker, out hierarchy, out itemid, out docCookie);
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.FindDocument1"]/*' />
        [CLSCompliant(false)]
        public object FindDocument(string moniker, out uint docCookie) {
            IVsHierarchy hierarchy;
            uint itemid;
            return FindDocument(moniker, out hierarchy, out itemid, out docCookie);
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.FindDocument2"]/*' />
        [CLSCompliant(false)]
        public object FindDocument(string moniker, out IVsHierarchy hierarchy, out uint itemid, out uint docCookie){
            itemid = 0;
            hierarchy = null;
            docCookie = 0;
            if (this.rdt == null) return null;
            IntPtr docData = IntPtr.Zero;
            NativeMethods.ThrowOnFailure(rdt.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, moniker, out hierarchy, out itemid, out docData, out docCookie));
            if (docData == IntPtr.Zero) return null;
            try {
                return Marshal.GetObjectForIUnknown(docData);
            } finally {
                Marshal.Release(docData);
            }
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.GetHierarchyItem"]/*' />
        [CLSCompliant(false)]
        public IVsHierarchy GetHierarchyItem(string moniker) {                      
            uint docCookie;
            uint itemid;
            IVsHierarchy hierarchy;
            object docData = this.FindDocument(moniker, out hierarchy, out itemid, out docCookie);
            return hierarchy;
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.GetRunningDocumentContents"]/*' />
        /// Return the document contents if it is loaded, otherwise return null.
        public string GetRunningDocumentContents(string path) {
            object docDataObj = this.FindDocument(path);
            if (docDataObj != null) {
                return GetBufferContents(docDataObj);
            }
            return null;
        }

        private static string GetBufferContents(object docDataObj) {
            string text = null;
            IVsTextLines buffer = null;
            if (docDataObj is IVsTextLines) {
                buffer = (IVsTextLines)docDataObj;
            } else if (docDataObj is IVsTextBufferProvider) {
                IVsTextBufferProvider tp = (IVsTextBufferProvider)docDataObj;
                if (tp.GetTextBuffer(out buffer) != NativeMethods.S_OK)
                    buffer = null;
            }
            if (buffer != null) {
                int endLine, endIndex;
                NativeMethods.ThrowOnFailure(buffer.GetLastLineIndex(out endLine, out endIndex));
                NativeMethods.ThrowOnFailure(buffer.GetLineText(0, 0, endLine, endIndex, out text));
                buffer = null;
            }
            return text;
        }

        [CLSCompliant(false)]
        public string GetRunningDocumentContents(uint docCookie) {
            uint flags, readLocks, editLocks, itemid;
            string moniker;
            IVsHierarchy hierarchy;
            IntPtr docData;
            int hr = this.rdt.GetDocumentInfo(docCookie, out flags, out readLocks, out editLocks, out moniker, out hierarchy, out itemid, out docData);
            if (hr == VSConstants.S_OK && docData != IntPtr.Zero) {
                try {
                    object data = Marshal.GetObjectForIUnknown(docData);
                    return GetBufferContents(data);
                } finally {
                    Marshal.Release(docData);
                }
            }
            return "";
        }

        [CLSCompliant(false)]
        public RunningDocumentInfo GetDocumentInfo(uint docCookie) {
            RunningDocumentInfo info = new RunningDocumentInfo();
            IntPtr docData;
            int hr = this.rdt.GetDocumentInfo(docCookie, out info.Flags,
                out info.ReadLocks, out info.EditLocks, out info.Moniker,
                out info.Hierarchy, out info.ItemId, out docData);
            if (hr == VSConstants.S_OK) {
                try {
                    if (docData != IntPtr.Zero)
                        info.DocData = Marshal.GetObjectForIUnknown(docData);
                    return info;
                } finally {
                    Marshal.Release(docData);
                }
            }
            return info;
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="VsShell.SaveFileIfDirty"]/*' />
        public string SaveFileIfDirty(string fullPath) {
            object docData = this.FindDocument(fullPath);
            if (docData is IVsPersistDocData2) {
                IVsPersistDocData2 pdd = (IVsPersistDocData2)docData;
                int dirty = 0;
                int hr = pdd.IsDocDataDirty(out dirty);
                if (NativeMethods.Succeeded(hr) && dirty != 0) {
                    string newdoc;
                    int cancelled;
                    NativeMethods.ThrowOnFailure(pdd.SaveDocData(VSSAVEFLAGS.VSSAVE_Save, out newdoc, out cancelled));
                    return newdoc;
                }
            }
            return fullPath;
        }

        [CLSCompliant(false)]
        public void RenameDocument(string oldName, string newName, IVsHierarchy pIVsHierarchy, uint itemId){
            IntPtr pUnk = Marshal.GetIUnknownForObject(pIVsHierarchy);
            if (pUnk != IntPtr.Zero) {
                try {
                    IntPtr pHier = IntPtr.Zero;
                    Guid guid = typeof(IVsHierarchy).GUID;
                    NativeMethods.ThrowOnFailure(Marshal.QueryInterface(pUnk, ref guid, out pHier));
                    try {
                        NativeMethods.ThrowOnFailure(this.rdt.RenameDocument(oldName, newName, pHier, itemId));
                    } finally {
                        Marshal.Release(pHier);
                    }
                } finally {
                    Marshal.Release(pUnk);
                }
            }
        }

        [CLSCompliant(false)]
        public uint Advise(IVsRunningDocTableEvents sink) {
            uint cookie;
            NativeMethods.ThrowOnFailure(this.rdt.AdviseRunningDocTableEvents(sink, out cookie));
            return cookie;
        }

        [CLSCompliant(false)]
        public void Unadvise(uint cookie) {
            NativeMethods.ThrowOnFailure(this.rdt.UnadviseRunningDocTableEvents(cookie));
        }

        [CLSCompliant(false)]
        public uint RegisterAndLockDocument(_VSRDTFLAGS lockType, string mkDocument, IVsHierarchy hierarchy, uint itemid, IntPtr docData) {
            uint cookie;
            NativeMethods.ThrowOnFailure(rdt.RegisterAndLockDocument((uint)lockType, mkDocument, hierarchy, itemid, docData, out cookie));
            return cookie;           
        }

        [CLSCompliant(false)]
        public void LockDocument(_VSRDTFLAGS lockType, uint cookie) {
            NativeMethods.ThrowOnFailure(rdt.LockDocument((uint)lockType, cookie));
        }

        [CLSCompliant(false)]
        public void UnlockDocument(_VSRDTFLAGS lockType, uint cookie) {
            NativeMethods.ThrowOnFailure(rdt.UnlockDocument((uint)lockType, cookie));
        }

        // Enumerate the running documents
        public IEnumerator<RunningDocumentInfo> GetEnumerator() {
            IList<RunningDocumentInfo> list = new List<RunningDocumentInfo>();
            IEnumRunningDocuments ppenum;
            if (NativeMethods.Succeeded(rdt.GetRunningDocumentsEnum(out ppenum))) {
                uint[] rgelt = new uint[1];
                uint fetched = 0;
                while (true) {
                    if (NativeMethods.Succeeded(ppenum.Next(1, rgelt, out fetched)) && fetched == 1) {
                        list.Add(GetDocumentInfo(rgelt[0]));
                    } else {
                        break;
                    }
                }
            }
            return list.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }
    }

    [CLSCompliant(false)]
    public struct RunningDocumentInfo {
        public uint Flags;
        public uint ReadLocks;
        public uint EditLocks;
        public IVsHierarchy Hierarchy;
        public uint ItemId;
        public string Moniker;
        public object DocData;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\VsMenus.cs ===
//--------------------------------------------------------------------------
//  <copyright file="VsCommands.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using System;

namespace Microsoft.VisualStudio.Shell
{

    /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus"]/*' />
    public class VsMenus
	{
		// menu command guids.
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidStandardCommandSet97"]/*' />
        public static Guid guidStandardCommandSet97 = new Guid("5efc7975-14bc-11cf-9b2b-00aa00573819");
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidStandardCommandSet2K"]/*' />
        public static Guid guidStandardCommandSet2K = new Guid("1496A755-94DE-11D0-8C3F-00C04FC2AAE2");
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidVsVbaPkg"]/*' />
        public static Guid guidVsVbaPkg = new Guid(0xa659f1b3, 0xad34, 0x11d1, 0xab, 0xad, 0x0, 0x80, 0xc7, 0xb8, 0x9c, 0x95);
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidSHLMainMenu"]/*' />
        public static Guid guidSHLMainMenu = new Guid(0xd309f791, 0x903f, 0x11d0, 0x9e, 0xfc, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f);
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidVSUISet"]/*' />
        public static Guid guidVSUISet = new Guid("60481700-078b-11d1-aaf8-00a0c9055a90");
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidCciSet"]/*' />
        public static Guid guidCciSet = new Guid("2805D6BD-47A8-4944-8002-4e29b9ac2269");
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidVsUIHierarchyWindowCmds"]/*' />
        public static Guid guidVsUIHierarchyWindowCmds = new Guid("60481700-078B-11D1-AAF8-00A0C9055A90");
		
        // Special Menus.
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_CODEWIN"]/*' />
        public const int IDM_VS_CTXT_CODEWIN = 0x040D;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_ITEMNODE"]/*' />
        public const int IDM_VS_CTXT_ITEMNODE = 0x0430;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_PROJNODE"]/*' />
        public const int IDM_VS_CTXT_PROJNODE = 0x0402;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_REFERENCEROOT"]/*' />
        public const int IDM_VS_CTXT_REFERENCEROOT = 0x0450;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_REFERENCE"]/*' />
        public const int IDM_VS_CTXT_REFERENCE = 0x0451;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_FOLDERNODE"]/*' />
        public const int IDM_VS_CTXT_FOLDERNODE = 0x0431;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_NOCOMMANDS"]/*' />
        public const int IDM_VS_CTXT_NOCOMMANDS = 0x041A;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.VSCmdOptQueryParameterList"]/*' />
        public const int VSCmdOptQueryParameterList = 1;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_XPROJ_MULTIITEM"]/*' />
        public const int IDM_VS_CTXT_XPROJ_MULTIITEM = 0x0419;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_XPROJ_PROJITEM"]/*' />
        public const int IDM_VS_CTXT_XPROJ_PROJITEM = 0x0417;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\Task.cs ===
//------------------------------------------------------------------------------
// <copyright file="Task.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\Task.uex' path='docs/doc[@for="Task"]' />
    /// <devdoc>
    ///     This class implements IVsTaskItem.  
    /// </devdoc>
    [ComVisible(true)]
    [CLSCompliant(false)]
    public class Task :

        IVsTaskItem,
        IVsProvideUserContext
    {
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.contextNameKeyword"]/*' />
        public const string contextNameKeyword = "Keyword";

        private TaskProvider owner;
        private bool canDelete;
        private bool checkedEditable;
        private bool priorityEditable;
        private bool textEditable;
        private TaskPriority priority;
        private TaskCategory category;
        private int          subCategoryIndex;
        private string       text; 
        private string       document;
        private string       caption;
        private string       helpKeyword;
        private int          line;
        private int          imageIndex;
        private int          column;
        private bool         isChecked;
        private IVsUserContext context = null;

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Task"]/*' />
        public Task() {
            priority = TaskPriority.Normal;
            subCategoryIndex = -1;
            // Initializing the imageIndex to -1 tells VS to not expect to get
            // an imageList from us either, and instead use the default images.
            // This fixes bug 172354.
            imageIndex = -1;
            line = -1;
            column = -1;
            text = string.Empty;
            helpKeyword = string.Empty;
            document = string.Empty;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Task1"]/*' />
        public Task(Exception error) : this() {
    
            // Now use the exception to fill in the 
            // task data.
            if (error == null) {
                throw new ArgumentNullException("error");
            }

            Text = error.Message;
            HelpKeyword = error.HelpLink;

            if (Text.Length == 0) {
                Text = error.ToString();
            }

            // UNDONE: How do we generate this info for non-code thingies?  This must be
            // generic, or at least extensible.

            while(error != null) {
                System.ComponentModel.Design.Serialization.CodeDomSerializerException cdex;
                System.Xml.XmlException xmlex;
                 
                if ((cdex = error as System.ComponentModel.Design.Serialization.CodeDomSerializerException) != null) {
                    System.CodeDom.CodeLinePragma lp = cdex.LinePragma;
                    if (lp != null) {
                        Document = lp.FileName;
                        Line = lp.LineNumber;
                    }
                    break;
                }
                else if ((xmlex = error as System.Xml.XmlException) != null) {
                    Line = xmlex.LineNumber - 1;
                    break;
                }
                error = error.InnerException;
            }
        }


        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.CanDelete"]/*' />
        public bool CanDelete {
            get {
                return canDelete;
            }
            set {
                if (canDelete != value) {
                    canDelete = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Category"]/*' />
        public TaskCategory Category {
            get {
                return category; 
            }
            set {
                if (category != value) {
                    category = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Checked"]/*' />
        public bool Checked {
            get {
                return isChecked;
            }
            set {
                if (isChecked != value) {
                    isChecked = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Column"]/*' />
        public int Column {
            get {
                return column;
            }
            set {
                if (column != value) {
                    column = value;
                    UpdateOwner();
                }
            }
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Document"]/*' />
        public string Document { 
            get {
                return document;
            }
            set {
                if (value == null) {
                    value = string.Empty;
                }
                if (document != value) {
                    document = value;
                    UpdateOwner();
                }
            }
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.HelpKeyword"]/*' />
        public string HelpKeyword {
            get {
                return helpKeyword;
            }
            set {
                if (value == null) {
                    value = string.Empty;
                }

                if (helpKeyword != value) {
                    helpKeyword = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.ImageIndex"]/*' />
        public int ImageIndex {
            get {
                return imageIndex;
            }
            set {
                if (imageIndex != value) {
                    imageIndex = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IsCheckedEditable"]/*' />
        public bool IsCheckedEditable {
            get {
                return checkedEditable;
            }
            set {
                if (checkedEditable != value) {
                    checkedEditable = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IsPriorityEditable"]/*' />
        public bool IsPriorityEditable {
            get {
                return priorityEditable;
            }
            set {
                if (priorityEditable != value) {
                    priorityEditable = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IsTextEditable"]/*' />
        public bool IsTextEditable {
            get {
                return textEditable;
            }
            set {
                if (textEditable != value) {
                    textEditable = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Line"]/*' />
        public int Line {
            get {
                return line;
            }
            set {
                if (line != value) {
                    line = value;
                    UpdateOwner();
                }
            }
        }

        internal TaskProvider Owner {
            get {
                return owner;
            }
            set {
                if (owner != null && value == null) {
                    OnRemoved(EventArgs.Empty);
                }
                owner = value;
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Priority"]/*' />
        public TaskPriority Priority {
            get {
                return priority;
            }
            set {
                if (priority != value) {
                    priority = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.SubcategoryIndex"]/*' />
        public int SubcategoryIndex {
            get {
                return subCategoryIndex;
            }
            set {
                if (subCategoryIndex != value) {
                    subCategoryIndex = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Text"]/*' />
        public string Text {
            get {
                return text;
            }
            set {
                if (value == null) {
                    value = string.Empty;
                }
                if (text != value) {
                    text = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Deleted"]/*' />
        public event EventHandler Deleted;

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Removed"]/*' />
        public event EventHandler Removed;
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Help"]/*' />
        public event EventHandler Help;
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Navigate"]/*' />
        public event EventHandler Navigate;
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.OnDeleted"]/*' />
        protected virtual void OnDeleted(EventArgs e) {
            if (Deleted != null) {
                Deleted(this, e);
            }
        }
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.OnRemoved"]/*' />
        protected virtual void OnRemoved(EventArgs e) {
            if (Removed != null) {
                Removed(this, e);
            }
        }        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.OnHelp"]/*' />
        protected virtual void OnHelp(EventArgs e) {

            if (HelpKeyword.Length > 0 && owner != null) {
                IHelpService help = owner.GetService(typeof(IHelpService)) as IHelpService;
                Debug.Assert(help != null, "We can't find a help service in the service provider");
                if (help != null) {
                    help.ShowHelpFromKeyword(HelpKeyword);
                }
            }

            if (Help != null) {
                Help(this, e);
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.OnNavigate"]/*' />
        protected virtual void OnNavigate(EventArgs e) {
            if (Navigate != null) {
                Navigate(this, e);
            }
        }

        private void UpdateOwner() {
            if (owner != null) {
                owner.Refresh();
            }
        }

        private string GetDisplayName(string fileName) {
            if (owner != null) {
            IVsRunningDocumentTable pRDT = (IVsRunningDocumentTable)owner.GetService(typeof(SVsRunningDocumentTable));
            if (pRDT != null) {
                IntPtr punkDocData;
                uint docCookie;
                uint[] pitemid = new uint[1];
                IVsHierarchy ppIVsHierarchy;
                int hr = pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, fileName, out ppIVsHierarchy, out pitemid[0], out punkDocData, out docCookie);
                if (NativeMethods.Succeeded(hr) && punkDocData != IntPtr.Zero && ppIVsHierarchy != null)
                {
                    Marshal.Release(punkDocData);
                    object isNew;
                    hr = ppIVsHierarchy.GetProperty(pitemid[0], (int)__VSHPROPID.VSHPROPID_IsNewUnsavedItem, out isNew);
                    if (NativeMethods.Succeeded(hr) && (bool)isNew) {
                        object fileCaption;
                        hr = ppIVsHierarchy.GetProperty(pitemid[0], (int)__VSHPROPID.VSHPROPID_Caption, out fileCaption);
                        string caption = fileCaption as string;
                        if (NativeMethods.Succeeded(hr) && !String.IsNullOrEmpty(caption))
                        {
                            return caption;
                        }
                    }
                }
            }
            }
            return fileName;
        }

        private string GetCaption() {
            if (caption == null) {
                caption = GetDisplayName(document);
            }
            return caption;
        }

        #region IVsTaskItem

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.CanDelete"]/*' />
        /// <internalonly/>
        int IVsTaskItem.CanDelete(out int fdelete) {
            fdelete = (CanDelete) ? 1 : 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.Category"]/*' />
        /// <internalonly/>
        int IVsTaskItem.Category(VSTASKCATEGORY[] cat) {
            if (cat != null) {
                cat[0] = (VSTASKCATEGORY)(uint)Category;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.Column"]/*' />
        /// <internalonly/>
        int IVsTaskItem.Column(out int col) {
            col = Column;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.Document"]/*' />
        /// <internalonly/>
        int IVsTaskItem.Document(out string doc) {
            doc = GetCaption();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.HasHelp"]/*' />
        /// <internalonly/>
        int IVsTaskItem.HasHelp(out int fHelp) {
            fHelp = (Help != null || (HelpKeyword != null && owner!=null)) ? 1 : 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.ImageListIndex"]/*' />
        /// <internalonly/>
        int IVsTaskItem.ImageListIndex(out int index) {
            index = ImageIndex;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.IsReadOnly"]/*' />
        /// <internalonly/>
        int IVsTaskItem.IsReadOnly(VSTASKFIELD field, out int fReadOnly) {

            bool readOnly = true;

            switch(field) {
                case VSTASKFIELD.FLD_CHECKED:
                    readOnly = !IsCheckedEditable;
                    break;
                case VSTASKFIELD.FLD_PRIORITY:
                    readOnly = !IsPriorityEditable;
                    break;
                case VSTASKFIELD.FLD_DESCRIPTION:
                    readOnly = !IsTextEditable;
                    break;
            }

            fReadOnly = (readOnly) ? 1 : 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.Line"]/*' />
        /// <internalonly/>
        int IVsTaskItem.Line(out int line) {
            line = Line;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.NavigateTo"]/*' />
        /// <internalonly/>
        int IVsTaskItem.NavigateTo() {
            OnNavigate(EventArgs.Empty);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.NavigateToHelp"]/*' />
        /// <internalonly/>
        int IVsTaskItem.NavigateToHelp() {
            OnHelp(EventArgs.Empty);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.OnDeleteTask"]/*' />
        /// <internalonly/>
        int IVsTaskItem.OnDeleteTask() {
            OnDeleted(EventArgs.Empty);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.OnFilterTask"]/*' />
        /// <internalonly/>
        int IVsTaskItem.OnFilterTask(int f) {
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.SubcategoryIndex"]/*' />
        /// <internalonly/>
        int IVsTaskItem.SubcategoryIndex(out int index) {
            index = SubcategoryIndex;
            if ( index < 0 )
            {
                return NativeMethods.E_FAIL;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.get_Checked"]/*' />
        /// <internalonly/>
        int IVsTaskItem.get_Checked(out int f) {
            f = Checked ? 1 : 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.get_Priority"]/*' />
        /// <internalonly/>
        int IVsTaskItem.get_Priority(VSTASKPRIORITY[] pri) {
            if (pri != null) {
                pri[0] = (VSTASKPRIORITY)(uint)Priority;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.get_Text"]/*' />
        /// <internalonly/>
        int IVsTaskItem.get_Text(out string text) {
            text = Text;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.put_Checked"]/*' />
        /// <internalonly/>
        int IVsTaskItem.put_Checked(int f) {
            isChecked = f != 0;  // don't call property, as it will call back to the task list
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.put_Priority"]/*' />
        /// <internalonly/>
        int IVsTaskItem.put_Priority(VSTASKPRIORITY pri) {
            priority = (TaskPriority)(uint)pri;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.put_Text"]/*' />
        /// <internalonly/>
        int IVsTaskItem.put_Text(string t) {
            text = t;
            return NativeMethods.S_OK;
        }
        #endregion

        #region IVsProvideUserContext Members

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.GetUserContext"]/*' />
        public int GetUserContext(out IVsUserContext ppctx)
        {
            int hr = NativeMethods.S_OK;
            if (context == null)
            {
                // Create an empty context
                IVsMonitorUserContext monitorContext = owner.GetService(typeof(SVsMonitorUserContext)) as IVsMonitorUserContext;
                NativeMethods.ThrowOnFailure(monitorContext.CreateEmptyContext(out context));

                // Add the required information to the context
                hr = context.AddAttribute(VSUSERCONTEXTATTRIBUTEUSAGE.VSUC_Usage_LookupF1, contextNameKeyword, this.HelpKeyword);
            }
            ppctx = context;

            return hr;
        }

        #endregion
    }


    /// <include file='doc\Task.uex' path='docs/doc[@for="ErrorTask"]' />
    /// <devdoc>
    ///     This class implements IVsErrorItem.  
    /// </devdoc>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class ErrorTask : Task, IVsErrorItem {

        IVsHierarchy        item;
        TaskErrorCategory   category;

        /// <include file='doc\Task.uex' path='docs/doc[@for="ErrorTask.ErrorTask"]/*' />
        public ErrorTask() {
            category = TaskErrorCategory.Error;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="ErrorTask.ErrorTask1"]/*' />
        public ErrorTask(Exception error) : base(error) {
        }

        /// Get/Set the error category associated with this task.
        public TaskErrorCategory ErrorCategory {
            get {
                return category;
            }
            set {
                category = value;
            }
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="ErrorTask.Project"]/*' />
        /// Get/Set the hierarchy item associated with this task.
        public IVsHierarchy HierarchyItem {
            get { return this.item; }
            set { this.item = value; }
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsErrorItem.GetProject"]/*' />
        /// todo: This method will soon switch to out IVsHierarchy ppProject
        int IVsErrorItem.GetHierarchy(out IVsHierarchy ppHier) {
            ppHier = this.item;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsErrorItem.GetCategory"]/*' />
        int IVsErrorItem.GetCategory(out uint pCategory) {
            pCategory = (uint)ErrorCategory;
            return NativeMethods.S_OK;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\Url.cs ===
//--------------------------------------------------------------------------
//  <copyright file="Url.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using System;
using System.Windows.Forms;
using System.Diagnostics;
using Microsoft.Win32;
using System.Globalization;
using System.IO;
using System.Collections;
using System.Xml;
using System.Text;
using System.Net;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;

namespace Microsoft.VisualStudio.Shell
{	
	/// <summary>
	/// This class wraps the Uri class and provides an unescaped "LocalPath" for file URL's
	/// and an unescaped AbsoluteUri for other schemes, plus it also returned an un-hex-escaped
	/// result from MakeRelative so it can be presented to the user.
	/// </summary>
	public class Url
	{
		private Uri uri = null;
		private bool isFile;
		private string cachedAbsUrl;

		
		public Url(string path)
		{
			Init(path);
		}
		
		void Init(string path)
		{
			// Must try absolute first, then fall back on relative, otherwise it
			// makes some absolute UNC paths like (\\lingw11\Web_test\) relative!
			if (path != null)
			{

				if (!Uri.TryCreate(path, UriKind.Absolute, out this.uri))
				{
					Uri.TryCreate(path, UriKind.Relative, out this.uri);
				} 
				
				this.CheckIsFile();
			}
		}

		void CheckIsFile()
		{
			this.isFile = false;
			if (this.uri != null)
			{
				if (this.uri.IsAbsoluteUri)
				{
					this.isFile = this.uri.IsFile;
				}
				else
				{
					string[] test1 = this.uri.OriginalString.Split('/');
					string[] test2 = this.uri.OriginalString.Split('\\');
					if (test1.Length < test2.Length)
					{
						this.isFile = true;
					}
				}
			}
		}

		// allows relpath to be null, in which case it just returns the baseUrl.
		
		public Url(Url baseUrl, string relpath)
		{
			if (baseUrl.uri == null || !baseUrl.uri.IsAbsoluteUri)
			{
				Init(relpath);
			}
			else if (string.IsNullOrEmpty(relpath))
			{
				this.uri = baseUrl.uri;
			}
			else
			{
				this.uri = new Uri(baseUrl.uri, relpath);
			}
			CheckIsFile();
		}
		
		
		public string AbsoluteUrl
		{
			get
			{
				if (this.uri == null) return null;
				if (cachedAbsUrl != null) return cachedAbsUrl;
				if (this.uri.IsAbsoluteUri)
				{
					if (this.isFile)
					{
						// Fix for build break. UriComponents.LocalPath is no longer available.
						// return uri.GetComponents(UriComponents.LocalPath, UriFormat.SafeUnescaped);
						cachedAbsUrl = uri.LocalPath;
					}
					else
					{
						cachedAbsUrl = uri.GetComponents(UriComponents.AbsoluteUri, UriFormat.SafeUnescaped);
					}
				}
				else
				{
					cachedAbsUrl = uri.OriginalString;
				}
			return cachedAbsUrl;
			}
		}

		
		/// <summary>Returns the AbsoluteUrl for the parent directory containing the file 
		/// referenced by this URL object, where the Directory string is also unescaped.</summary>
		public string Directory
		{
            get 
            {
                string path = this.AbsoluteUrl;
                if (path == null) return null;
                if (this.isFile) {
                    return Path.GetDirectoryName(path);
                }

                int i = path.LastIndexOf('/');
                int len = (i > 0) ? i : path.Length;
                return path.Substring(0, len);
            }
		}

		
		public bool IsFile
		{
			get { return this.isFile; }
		}

		
		public Url Move(Url oldBase, Url newBase)
		{
			if (this.uri == null || oldBase.uri == null) return null;
			string rel = oldBase.uri.MakeRelativeUri(this.uri).ToString();
			return new Url(newBase, rel);
		}

		// return an un-escaped relative path
		
		public string MakeRelative(Url url)
		{
			if (this.uri == null || url.uri == null) return null;
			if (this.uri.Scheme != url.uri.Scheme || this.uri.Host != url.uri.Host)
			{
				// Then it cannot be relatavized (e.g from file:// to http://).
				return url.AbsoluteUrl;
			}
			// This will return a hex-escaped string.
			string rel = this.uri.MakeRelativeUri(url.uri).ToString();

			// So unescape it.
			return Unescape(rel, this.isFile);
		}

		const char c_DummyChar = (char)0xFFFF;

		private static char EscapedAscii(char digit, char next)
		{
			// Only accept hexadecimal characters
			if (!(((digit >= '0') && (digit <= '9'))
				|| ((digit >= 'A') && (digit <= 'F'))
				|| ((digit >= 'a') && (digit <= 'f'))))
			{
				return c_DummyChar;
			}

			int res = 0;
			if (digit <= '9')
				res = (int)digit - (int)'0';
			else if (digit <= 'F')
				res = ((int)digit - (int)'A') + 10;
			else
				res = ((int)digit - (int)'a') + 10;

			// Only accept hexadecimal characters
			if (!(((next >= '0') && (next <= '9'))
				|| ((next >= 'A') && (next <= 'F'))
			   || ((next >= 'a') && (next <= 'f'))))
			{
				return c_DummyChar;
			}

			res = res << 4;
			if (next <= '9')
				res += (int)next - (int)'0';
			else if (digit <= 'F')
				res += ((int)next - (int)'A') + 10;
			else
				res += ((int)next - (int)'a') + 10;

			return (char)(res);
		}

		
		public static string Unescape(string escaped, bool isFile)
		{
			if (String.IsNullOrEmpty(escaped))
			{
				return String.Empty;
			}

			byte[] bytes = null;
			char[] dest = new char[escaped.Length];
			int j = 0;

			for (int i = 0, end = escaped.Length; i < end; i++)
			{
				char ch = escaped[i];
				if (ch != '%')
				{
					if (ch == '/' && isFile)
					{
						ch = Path.DirectorySeparatorChar;
					}
					dest[j++] = ch;
				}
				else
				{
					int byteCount = 0;
					// lazy initialization of max size, will reuse the array for next sequences
					if (bytes == null)
					{
						bytes = new byte[end - i];
					}

					do
					{
						// Check on exit criterion
						if ((ch = escaped[i]) != '%' || (end - i) < 3)
						{
							break;
						}
						// already made sure we have 3 characters in str
						ch = EscapedAscii(escaped[i + 1], escaped[i + 2]);
						if (ch == c_DummyChar)
						{
							//invalid hex sequence, we will out '%' character
							ch = '%';
							break;
						}
						else if (ch < '\x80')
						{
							// character is not part of a UTF-8 sequence
							i += 2;
							break;
						}
						else
						{
							//a UTF-8 sequence
							bytes[byteCount++] = (byte)ch;
							i += 3;
						}
					} while (i < end);

					if (byteCount != 0)
					{

						int charCount = Encoding.UTF8.GetCharCount(bytes, 0, byteCount);
						if (charCount != 0)
						{
							Encoding.UTF8.GetChars(bytes, 0, byteCount, dest, j);
							j += charCount;
						}
						else
						{
							// the encoded, high-ANSI characters are not UTF-8 encoded
							for (int k = 0; k < byteCount; ++k)
							{
								dest[j++] = (char)bytes[k];
							}
						}
					}
					if (i < end)
					{
						dest[j++] = ch;
					}
				}
			}
			return new string(dest, 0, j);
		}

		
		public Uri Uri
		{
			get { return this.uri; }
		}

		/// Return unescaped path up to (but not including) segment i.
		public string GetPartial(int i)
		{
            return GetPartial(0, i);
		}

        public string GetPartial(int i, int j) {
            string path = JoinSegments(i, j);
            if (i == 0)
                if (!this.isFile) {
                    // prepend "http://host/"
                    path = this.uri.Scheme + "://" + this.uri.Host + '/' + path;
                } else if (this.uri.IsAbsoluteUri && this.uri.IsUnc && this.AbsoluteUrl.StartsWith(@"\\", StringComparison.OrdinalIgnoreCase)) {
                    path = @"\\" + path;
                }
            return path;
        }

		
		/// Return unescaped relative path starting segment i.
		public string GetRemainder(int i)
		{
			return JoinSegments(i, -1);
		}
		
		// Unlike the Uri class, this ALWAYS succeeds, even on relative paths, and it
		// strips out the path separator characters
		public string[] Segments
		{
			get
			{
				if (this.uri == null)
					return null;
				string path = this.AbsoluteUrl;
				if (this.isFile)
				{
					if (path.EndsWith(@"\", StringComparison.OrdinalIgnoreCase))
					{
						path = path.Substring(0, path.Length - 1);
					}
					if (this.uri.IsAbsoluteUri && this.uri.IsUnc && path.StartsWith(@"\\", StringComparison.OrdinalIgnoreCase))
					{
						path = path.Substring(2);
					}
					return path.Split(Path.DirectorySeparatorChar);
				}
				else
				{
					// strip off "http://" and host name, since those are not part of the path.
					path = path.Substring(this.uri.Scheme.Length + 3 + this.uri.Host.Length + 1);
					if (path.EndsWith("/", StringComparison.OrdinalIgnoreCase))
						path = path.Substring(0, path.Length - 1);
					return path.Split('/');
				}
			}
		}

		public string JoinSegments(int i, int j)
		{
			if (i < 0)
				throw new ArgumentOutOfRangeException("i");

			StringBuilder sb = new StringBuilder();
			string[] segments = this.Segments;
			if (segments == null)
				return null;
			if (j < 0)
				j = segments.Length;
			int len = segments.Length;
			for (; i < j && i < len; i++)
			{
				if (sb.Length > 0)
					sb.Append(this.isFile ? Path.DirectorySeparatorChar : '/');
				string s = segments[i];
				sb.Append(s);
			}
			return Unescape(sb.ToString(), isFile);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\Flavor\AggregatableProjectInterops.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

namespace Microsoft.VisualStudio.Shell.Flavor
{
    using System;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.OLE.Interop;

    // We need to define a corrected version of the IA for this interface so that IUnknown pointers are passed
    // as "IntPtr" instead of "object". This ensures that we get the actual IUnknown pointer and not a wrapped
    // managed proxy pointer.
    [ComImport]
    [Guid("ffb2e715-7312-4b93-83d7-d37bcc561c90")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    [CLSCompliant(false)]
    public interface IVsAggregatableProjectCorrected
    {
        [PreserveSig]
        int SetInnerProject(IntPtr punkInnerIUnknown);
        [PreserveSig]
        int InitializeForOuter([MarshalAs(UnmanagedType.LPWStr)]string pszFilename, 
                               [MarshalAs(UnmanagedType.LPWStr)]string pszLocation, 
                               [MarshalAs(UnmanagedType.LPWStr)]string pszName, 
                               uint grfCreateFlags, ref Guid iidProject, out IntPtr ppvProject, out int pfCanceled);
        [PreserveSig]
        int OnAggregationComplete();
        [PreserveSig]
        int GetAggregateProjectTypeGuids([MarshalAs(UnmanagedType.BStr)]out string pbstrProjTypeGuids);
        [PreserveSig]
        int SetAggregateProjectTypeGuids([MarshalAs(UnmanagedType.LPWStr)]string lpstrProjTypeGuids);
    }

    // We need to define a corrected version of the IA for this interface so that IUnknown pointers are passed
    // as "IntPtr" instead of "object". This ensures that we get the actual IUnknown pointer and not a wrapped
    // managed proxy pointer.
    [ComImport()]
    [Guid("6d5140d3-7436-11ce-8034-00aa006009fa")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    [CLSCompliant(false)]
    public interface ILocalRegistryCorrected
    {
        [PreserveSig]
        int CreateInstance(Guid clsid, IntPtr punkOuterIUnknown, ref Guid riid, uint dwFlags, out IntPtr ppvObj);
        [PreserveSig]
        int GetClassObjectOfClsid(ref Guid clsid, uint dwFlags, IntPtr lpReserved, ref Guid riid, out IntPtr ppvClassObject);
        [PreserveSig]
        int GetTypeLibOfClsid(Guid clsid, out ITypeLib pptLib);
    }

    // We need to define a corrected version of the IA for this interface so that IUnknown pointers are passed
    // as "IntPtr" instead of "object". This ensures that we get the actual IUnknown pointer and not a wrapped
    // managed proxy pointer.
    [ComImport]
    [Guid("44569501-2ad0-4966-9bac-12b799a1ced6")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IVsAggregatableProjectFactoryCorrected
    {
        [PreserveSig]
        int GetAggregateProjectType([MarshalAs(UnmanagedType.LPWStr)]string fileName, [MarshalAs(UnmanagedType.BStr)]out string projectTypeGuid);
        [PreserveSig]
        int PreCreateForOuter(IntPtr outerProjectIUnknown, out IntPtr projectIUnknown);
    }

    [ComImport]
    [Guid("D6CEA324-8E81-4e0e-91DE-E5D7394A45CE")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IVsProjectAggregator2
    {
        #region IVsProjectAggregator2 Members

        [PreserveSig]
        int SetInner(IntPtr innerIUnknown);
        [PreserveSig]
        int SetMyProject(IntPtr projectIUnknown);

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\TaskProvider.cs ===
//------------------------------------------------------------------------------
// <copyright file="TaskProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.VisualStudio.TextManager.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider"]' />
    /// <devdoc>
    ///     This class implements IVsTaskProvider.  It provides a 
    ///     framework-friendly way to define a package and its associated 
    ///     services.  
    /// </devdoc>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class TaskProvider :

        IVsTaskProvider,
        IVsTaskProvider2,
        IVsTaskProvider3,
        IDisposable {

        internal IServiceProvider       provider;
        internal ImageList              imageList;
        internal IVsTaskList            taskList;
        internal uint                   taskListCookie;
        internal TaskCollection         tasks;
        internal StringCollection       subCategories;
        internal int                    suspended;
        internal bool                   dirty;
        internal Guid                   providerGuid;
        internal string                 name;
        internal bool                   alwaysVisible;
        internal bool                   disableAutoRoute;
        internal Guid                   toolbarGroup;
        internal int                    toolbarId;
        internal bool                   maintainOrder;
        private  bool                   inFinalRelease;


        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.TaskProvider"]/*' />
        public TaskProvider(IServiceProvider provider) {
            this.provider = provider;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Finalize"]/*' />
        ~TaskProvider() {
            Dispose(false);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.MaintainTaskOrder"]/*' />
        /// Determines whether or not the task list should maintain the task order given to it by the task provider.
        public bool MaintainInitialTaskOrder {
            get { return this.maintainOrder; }
            set { this.maintainOrder = value; }
        }

        /// The TaskList groups all tasks from multiple providers
        /// that provide the same GUID into one list.  
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ProviderGuid"]/*' />
        public Guid ProviderGuid {
            get { return this.providerGuid; }
            set { this.providerGuid = value; }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ProviderName"]/*' />
        /// Returns a localized human-readable name for this data provider.
        public string ProviderName {
            get { return this.name; }
            set { this.name = value; }
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.AlwaysVisible"]/*' />
        /// Provider is always visible in dropdown even if it has no tasks.
        public bool AlwaysVisible {
            get { return this.alwaysVisible; }
            set { this.alwaysVisible = value; }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.DisableAutoRoute"]/*' />
        /// Provider is always visible in dropdown even if it has no tasks.
        public bool DisableAutoRoute
        {
            get { return this.disableAutoRoute; }
            set { this.disableAutoRoute = value; }
        }

        // Returns a group GUID and toolbar ID indicating which toolbar should be displayed when this
        // provider is active.  Set pguidGroup and pdwID to GUID_NULL and 0, respectively, to indicate
        // that this provider has no toolbar.  If you do provide a toolbar, you must include the
        // provider dropdown as the first group, by including this line in your CTC file:
        //     guidSHLMainMenu:IDG_VS_TASKLIST_PROVIDERLIST, <your toolbar's group>:<your toolbar menu ID>, 0x0100;
        // See vscommon\appid\inc\ShellCmdPlace.ctc for examples.
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.ToolbarGroup"]/*' />
        public Guid ToolbarGroup {
            get { return this.toolbarGroup; }
            set { this.toolbarGroup = value; }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.ToolbarId"]/*' />
        public int ToolbarId {
            get { return this.toolbarId; }
            set { this.toolbarId = value; }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.ImageList"]/*' />
        public ImageList ImageList {
            get {
                return imageList;
            }
            set {
                if (imageList != value) {
                    imageList = value;
                    UpdateProviderInfo();
                }
            }
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Subcategories"]/*' />
        public StringCollection Subcategories {
            get {
                if (subCategories == null) {
                    subCategories = new StringCollection();
                }
                return subCategories;
            }
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Tasks"]/*' />
        public TaskCollection Tasks {
            get {
                if (tasks == null) {
                    tasks = new TaskCollection(this);
                }
                return tasks;
            }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.VsTaskList"]/*' />
        protected virtual IVsTaskList VsTaskList {
            get {
                if (taskList == null) {
                    taskList = GetService(typeof(SVsTaskList)) as IVsTaskList;
                    if (taskList == null) {
                        throw new InvalidOperationException(string.Format(Resources.Culture, Resources.General_MissingService, typeof(IVsTaskList).FullName));
                    }
                    NativeMethods.ThrowOnFailure( taskList.RegisterTaskProvider(this, out taskListCookie) );
                }

                return taskList;
            }
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Dispose"]/*' />
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Dispose1"]/*' />
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        protected virtual void Dispose(bool disposing)
        {
			if (disposing)
			{
				if (tasks != null && !inFinalRelease)
				{
					tasks.Clear();
					tasks = null;
				}

				if (taskList != null)
				{
					try
					{
						// Don't check for the result code because here we can't do anything in case of failure
						taskList.UnregisterTaskProvider(taskListCookie);
					}
					catch (Exception)
					{ /* do nothing */ }
					taskList = null;
				}

				if (imageList != null)
				{
					imageList.Dispose();
					imageList = null;
				}
			}
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.GetService"]/*' />
        protected internal object GetService(Type serviceType) {
            if (provider != null) {
                return provider.GetService(serviceType);
            }
            return null;
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="Navigate"]/*' />
        /// <devdoc>
        ///     Navigates the document in the given task to the given logical view.
        /// </devdoc>
        public bool Navigate(Task task, Guid logicalView) {

            if (task == null) {
                throw new ArgumentNullException("task");
            }

            // Get the doc data for the task's document
            if (task.Document == null || task.Document.Length == 0) {
                return false;
            }

            IVsUIShellOpenDocument openDoc = GetService(typeof(IVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            if (openDoc == null) {
                return false;
            }

            IVsWindowFrame frame;
            IOleServiceProvider sp;
            IVsUIHierarchy hier;
            uint itemid;
            Guid logView = logicalView;

            if (NativeMethods.Failed(openDoc.OpenDocumentViaProject(task.Document, ref logView, out sp, out hier, out itemid, out frame)) || frame == null) {
                return false;
            }

            object docData;
            frame.GetProperty((int)__VSFPROPID.VSFPROPID_DocData, out docData);

            VsTextBuffer buffer = docData as VsTextBuffer;
            if (buffer == null) {
                IVsTextBufferProvider bufferProvider = docData as IVsTextBufferProvider;
                if (bufferProvider != null) {
                    IVsTextLines lines;
                    NativeMethods.ThrowOnFailure(bufferProvider.GetTextBuffer(out lines));
                    buffer = lines as VsTextBuffer;
                    Debug.Assert(buffer != null, "IVsTextLines does not implement IVsTextBuffer");
                    if (buffer == null) {
                        return false;
                    }
                }
            }

            // Finally, perform the navigation.
            IVsTextManager mgr = GetService(typeof(VsTextManagerClass)) as IVsTextManager;

            if (mgr == null) {
                return false;
            }

            int line = task.Line;
            // Buffer is zero based
            if (line > 0) line--;

            mgr.NavigateToLineAndColumn(buffer, ref logicalView, line, 0, line, 0);
            return true;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Refresh"]/*' />
        public void Refresh() {
            if (suspended == 0) {
                dirty = false;
                NativeMethods.ThrowOnFailure( VsTaskList.RefreshTasks(taskListCookie) );
            } else {
                dirty = true;
            }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Show"]/*' />
        public virtual void Show() {
            IUIService uis = GetService(typeof(IUIService)) as IUIService;
            if (uis != null) {
                uis.ShowToolWindow(new Guid(EnvDTE.Constants.vsWindowKindTaskList));
            }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.SuspendRefresh"]/*' />
        /// <devdoc>
        /// SuspendRefresh stops refresh of the task list from happening until ResumeRefresh
        /// is called.  It supports nested Suspend/Resume.  The reason for this method is because
        /// by default, every change to the TaskCollection results in a call to Refresh, and
        /// the task list updates synchronously when Refresh() is called, so this allows 
        /// batching of the updates to occur which results in cleaner UI experience.  For
        /// example, without this refreshing a long task list will cause the task list scrollbar 
        /// to shrink and grow in a very visible way. By calling Suspend/Resume instead the
        /// the update of the a longs task list happens with very little visual noise.
        /// </devdoc>
        public void SuspendRefresh()
        {
            if (suspended < int.MaxValue)
                suspended++;
            else
                Debug.Fail("TaskProvider.SuspendRefresh() was called int.MaxValue times.\nYou may want to change the counter to something bigger then an int");
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.ResumeRefresh"]/*' />
        public void ResumeRefresh() {
            if (suspended > 0) {
                suspended--;
                if (suspended == 0 && dirty) {
                    Refresh();
                }
            }
        }

        private void TasksChanged() {
            Refresh();
        }

        private void UpdateProviderInfo() {
            if (taskList != null) {
                NativeMethods.ThrowOnFailure( taskList.UpdateProviderInfo(taskListCookie) );
            }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.EnumTaskItems"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.EnumTaskItems(out IVsEnumTaskItems items) {
            items = new VsEnumTaskItems(Tasks);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.ImageList"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.ImageList(out IntPtr himagelist) {
            if (ImageList != null) {
                HandleRef hRef = new HandleRef(null, ImageList.Handle);
                himagelist = UnsafeNativeMethods.ImageList_Duplicate(hRef);
            }
            else {
                himagelist = IntPtr.Zero;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.OnTaskListFinalRelease"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.OnTaskListFinalRelease(IVsTaskList taskList) {
            inFinalRelease = true;
            Dispose(true);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.ReRegistrationKey"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.ReRegistrationKey(out string key) {
            key = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}.{1}", this.GetType().Name, this.GetHashCode());
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.SubcategoryList"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.SubcategoryList(uint cbstr, string[] rgbstr, out uint cnt) {
            cnt = 0;
            if (null == rgbstr) {
                if (0 == cbstr) {
                    cnt = (null == subCategories) ? 0 : (uint)subCategories.Count;
                    return NativeMethods.S_OK;
                }
                throw new ArgumentNullException("rgbstr");
            }
            if (subCategories != null) {
                for (cnt = 0; cnt < cbstr && cnt < subCategories.Count; ++cnt) {
                    rgbstr[(int)cnt] = subCategories[(int)cnt];
                }

            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.EnumTaskItems"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.EnumTaskItems(out IVsEnumTaskItems items) {
            return ((IVsTaskProvider)this).EnumTaskItems(out items);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.ImageList"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.ImageList(out IntPtr himagelist) {
            return ((IVsTaskProvider)this).ImageList(out himagelist);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.OnTaskListFinalRelease"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.OnTaskListFinalRelease(IVsTaskList taskList) {
            return ((IVsTaskProvider)this).OnTaskListFinalRelease(taskList);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.ReRegistrationKey"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.ReRegistrationKey(out string key) {
            return ((IVsTaskProvider)this).ReRegistrationKey(out key);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.SubcategoryList"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.SubcategoryList(uint cbstr, string[] rgbstr, out uint cnt) {
            return ((IVsTaskProvider)this).SubcategoryList(cbstr, rgbstr, out cnt);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.MaintainInitialTaskOrder"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.MaintainInitialTaskOrder(out int fMaintainOrder) {
            fMaintainOrder = this.maintainOrder ? 1 : 0;
            return NativeMethods.S_OK;
        }

        // Returns the behavior flags for this provider.
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider3.GetProviderFlags"]/*' />
        /// <internalonly/>
        int IVsTaskProvider3.GetProviderFlags(out uint tpfFlags){
            tpfFlags = (this.alwaysVisible) ? (uint)__VSTASKPROVIDERFLAGS.TPF_ALWAYSVISIBLE : 0;
            if (disableAutoRoute)
                tpfFlags |= (uint)__VSTASKPROVIDERFLAGS.TPF_NOAUTOROUTING;
            return NativeMethods.S_OK; 
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider3.GetProviderName"]/*' />
        /// <internalonly/>
        int IVsTaskProvider3.GetProviderName(out string pbstrName){
            pbstrName = this.name;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider3.GetProviderGuid"]/*' />
        /// <devdoc>
        /// Returns a unique ID for this provider.  This is used to persist and restore per-provider
        /// data managed by the task list, such as user customizations of column width and order.
        /// </devdoc>
        /// <internalonly/>
        int IVsTaskProvider3.GetProviderGuid(out Guid pguidProvider) {
            pguidProvider = this.GetType().GUID;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider3.GetProviderToolbar"]/*' />
        /// <internalonly/>
        int IVsTaskProvider3.GetProviderToolbar(out Guid pguidGroup, out uint pdwID) {
            pguidGroup = this.toolbarGroup;
            pdwID = (uint)this.toolbarId;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.GetColumnCount"]/*' />
        // Returns the total number of columns supported by this provider, including columns that are
        // not visible by default.
        int IVsTaskProvider3.GetColumnCount(out int count) {
            // todo: provide a way to define custom columns
            // right now it is getting default behavior for free.
            count = 0;
            return NativeMethods.E_FAIL;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.GetColumn"]/*' />
        // Gets the definition of an indexed column (0 <= iColumn < nColumns).
        int IVsTaskProvider3.GetColumn(int iColumn, VSTASKCOLUMN[] pColumn) {
            return NativeMethods.E_FAIL;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.GetSurrogateProviderGuid"]/*' />
        int IVsTaskProvider3.GetSurrogateProviderGuid(out System.Guid guid) {
            guid = Guid.Empty;
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.OnBeginTaskEdit"]/*' />
        // Called when the user begins editing a task in-place.  Providers may want to avoid scrolling
        // the tasklist or changing the selection during editing, since these actions can force in-
        // place edit mode to be canceled abruptly.
        int IVsTaskProvider3.OnBeginTaskEdit(IVsTaskItem item) {
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.OnEndTaskEdit"]/*' />
        // Called when the user finishes editing a task in-place.  fCommitChanges indicates whether the
        // user chose to commit the changes or discard them.  This method may set *pfAllowChanges to
        // FALSE to disallow the user from exiting edit mode.  If fCommitChanges is TRUE, the changes
        // will have already been persisted down to the task item.
        int IVsTaskProvider3.OnEndTaskEdit(IVsTaskItem item, int fCommitChanges, out int fAllowChanges) {
            fAllowChanges = 1;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection"]/*' />
        public sealed class TaskCollection :

            IList {

            private TaskProvider owner;
            private ArrayList list;

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.TaskCollection"]/*' />
            public TaskCollection(TaskProvider owner) {
                if (null == owner) {
                    throw new ArgumentNullException("owner");
                }
                this.owner = owner;
                this.list = new ArrayList();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Count"]/*' />
            public int Count {
                get {
                    return list.Count;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.this"]/*' />
            public Task this[int index] {
                get {
                    return (Task)list[index];
                }
                set {
                    if (value == null) {
                        throw new ArgumentNullException("value");
                    }
                    Task t = this[index];
                    if (t != null) {
                        t.Owner = null;
                    }
                    list[index] = value;
                    value.Owner = owner;
                    owner.TasksChanged();
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Add"]/*' />
            public int Add(Task task) {
                if (task == null) {
                    throw new ArgumentNullException("task");
                }
                int index = list.Add(task);
                task.Owner = owner;
                owner.TasksChanged();
                return index;
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Clear"]/*' />
            public void Clear() {
                if (list.Count > 0) {
                    foreach (Task t in list) {
                        t.Owner = null;
                    }
                    list.Clear();
                    owner.TasksChanged();
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Contains"]/*' />
            public bool Contains(Task task) {
                return list.Contains(task);
            }

            private void EnsureTask(object obj) {
                if (!(obj is Task)) {
                    throw new ArgumentException(string.Format(Resources.Culture, Resources.General_InvalidType, typeof(Task).FullName), "obj");
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.GetEnumerator"]/*' />
            public IEnumerator GetEnumerator() {
                return list.GetEnumerator();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IndexOf"]/*' />
            public int IndexOf(Task task) {
                return list.IndexOf(task);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Insert"]/*' />
            public void Insert(int index, Task task) {
                if (task == null) {
                    throw new ArgumentNullException("task");
                }
                list.Insert(index, task);
                task.Owner = owner;
                owner.TasksChanged();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Remove"]/*' />
            public void Remove(Task task) {
                if (task == null) {
                    throw new ArgumentNullException("task");
                }
                list.Remove(task);
                task.Owner = null;
                owner.TasksChanged();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.RemoveAt"]/*' />
            public void RemoveAt(int index) {
                Task t = this[index];
                t.Owner = null;
                list.RemoveAt(index);
                owner.TasksChanged();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array array, int index) {
                list.CopyTo(array, index);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.IsReadOnly"]/*' />
            /// <internalonly/>
            bool IList.IsReadOnly {
                get {
                    return false;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    EnsureTask(value);
                    this[index] = (Task)value;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object obj) {
                EnsureTask(obj);
                return Add((Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Clear"]/*' />
            /// <internalonly/>
            void IList.Clear() {
                Clear();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object obj) {
                EnsureTask(obj);
                return Contains((Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object obj) {
                EnsureTask(obj);
                return IndexOf((Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object obj) {
                EnsureTask(obj);
                Insert(index, (Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object obj) {
                EnsureTask(obj);
                Remove((Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.RemoveAt"]/*' />
            /// <internalonly/>
            void IList.RemoveAt(int index) {
                RemoveAt(index);
            }
        }

        private class VsEnumTaskItems : IVsEnumTaskItems {

            private TaskCollection tasks;
            private IEnumerator taskEnum;

            internal VsEnumTaskItems(TaskCollection tasks) {
                this.tasks = tasks;
                this.taskEnum = tasks.GetEnumerator();
            }

            public int Clone(out IVsEnumTaskItems newItems) {
                newItems = new VsEnumTaskItems(tasks);
                return NativeMethods.S_OK;
            }

            public int Next(uint celt, IVsTaskItem[] items, uint[] pceltFetched) {
                if (items == null || items.Length < celt)
                    throw new ArgumentException(String.Empty, "items");

                uint fetched = 0;

                while (fetched < celt && taskEnum.MoveNext()) {
                    items[fetched++] = (IVsTaskItem)taskEnum.Current;
                }

                if (pceltFetched != null && pceltFetched.Length > 0) {
                    pceltFetched[0] = fetched;
                }

                if (fetched == 0 && celt > 0) {
                    return NativeMethods.S_FALSE;
                }

                return NativeMethods.S_OK;
            }

            public int Reset() {
                taskEnum.Reset();
                return NativeMethods.S_OK;
            }

            public int Skip(uint count) {
                while (count != 0) {
                    count--;
                    if (!taskEnum.MoveNext() && count != 0) {
                        return NativeMethods.S_FALSE;
                    }
                }

                return NativeMethods.S_OK;
            }
        }
    }


    // <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider"]' />
    /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider"]/*' />
    /// <devdoc>
    /// Use this provider to provide tasks for the Visual Studio Error List
    /// window. This task provider also has a Guid which is returned from
    /// </devdoc>
    [CLSCompliant(false)]
    public class ErrorListProvider : TaskProvider {
        IVsErrorList errorList;


        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.TaskProvider"]/*' />
        public ErrorListProvider(IServiceProvider provider) : base(provider) {
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.Finalize"]/*' />
        ~ErrorListProvider() {
            Dispose(false);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.Dispose1"]/*' />
        protected override void Dispose(bool disposing) {
            base.Dispose(disposing);
            this.errorList = null;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.VsTaskList"]/*' />
        protected override IVsTaskList VsTaskList {
            get {
                if (taskList == null) {

                    this.errorList = GetService(typeof(SVsErrorList)) as IVsErrorList;
                    if (errorList == null) {
                        return base.VsTaskList;
                    }
                    this.taskList = errorList as IVsTaskList;
                    if (taskList == null) {
                        throw new InvalidOperationException(string.Format(Resources.Culture, Resources.General_MissingService, typeof(IVsTaskList).FullName));
                    }
                    NativeMethods.ThrowOnFailure(taskList.RegisterTaskProvider(this, out taskListCookie));
                }

                return taskList;
            }
        }

        // Activates the window and makes it visible.  This should only be called
        // at the completion of a build process.
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.BringToFront"]/*' />
        public void BringToFront() {
            IVsTaskList tasklist = this.VsTaskList;
            NativeMethods.ThrowOnFailure( errorList.BringToFront() );
            tasklist = null;
        }

        // Forces the error toggle "on", so that errors are visible in the list.  Warnings and
        // informational messages are not affected.
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.ForceShowErrors"]/*' />
        public void ForceShowErrors() {
            IVsTaskList tasklist = this.VsTaskList;
            NativeMethods.ThrowOnFailure( errorList.ForceShowErrors() );
            tasklist = null;
        }
    
        /// <include file='doc\ErrorListProvider.uex' path='docs/doc[@for="ErrorListProvider.Show"]/*' />
        public override void Show() {
            IUIService uis = GetService(typeof(IUIService)) as IUIService;
            if (uis != null) {
                Guid errorList = new Guid(EnvDTE80.WindowKinds.vsWindowKindErrorList);
                uis.ShowToolWindow(errorList);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\Utilities.cs ===
//--------------------------------------------------------------------------
//  <copyright file="utilities.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Diagnostics;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Collections;
using System.Xml;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Reflection;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using Microsoft.VisualStudio.Shell;
using Microsoft.Win32;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;

namespace Microsoft.VisualStudio.Shell
{


    /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities"]' />
    public static class PackageUtilities
	{

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetSystemAssemblyPath"]' />
        public static string GetSystemAssemblyPath()
		{
			return Path.GetDirectoryName(typeof(object).Assembly.Location);
#if SYSTEM_COMPILER 
      // To support true cross-platform compilation we really need to use
      // the System.Compiler.dll SystemTypes class which statically loads
      // mscorlib type information from "TargetPlatform" location.
      return Path.GetDirectoryName(SystemTypes.SystemAssembly.Location);
#endif

		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.EnsureOutputPath"]' />
        public static void EnsureOutputPath(string path)
		{
			if (!String.IsNullOrEmpty(path) && !Directory.Exists(path))
			{
				try
				{
					Directory.CreateDirectory(path);
				}
				catch (IOException e)
				{
					Trace.WriteLine("Exception : " + e.Message);
				}
				catch (UnauthorizedAccessException e)
				{
					Trace.WriteLine("Exception : " + e.Message);
				}
				catch (ArgumentException e)
				{
					Trace.WriteLine("Exception : " + e.Message);
				}
				catch (NotSupportedException e)
				{
					Trace.WriteLine("Exception : " + e.Message);
				}

			}
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.ContainsInvalidFileNameChars"]' />
        /// <devdoc>
		/// Returns true if thename that can represent a path, absolut or relative, or a file name contains invalid filename characters.
		/// </devdoc>
		/// <param name="name">File name</param>
		/// <returns>true if file name is invalid</returns>
		public static bool ContainsInvalidFileNameChars(string name)
		{
			if (String.IsNullOrEmpty(name))
			{
				return true;
			}

			if (Path.IsPathRooted(name))
			{
				string root = Path.GetPathRoot(name);
				name = name.Substring(root.Length);
			}

			Url uri = new Url(name);

			string[] segments = uri.Segments;
			if (segments != null)
			{
				foreach (string segment in segments)
				{
					if (IsFilePartInValid(segment))
					{
						return true;
					}
				}
			}
			else
			{
				return IsFilePartInValid(name);
			}

			return false;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.IsFileNameInvalid"]' />
        /// <devdoc>
		/// Cehcks if a file name is valid.
		/// </devdoc>
		/// <param name="fileName">The name of the file</param>
		/// <returns>True if the file is valid.</returns>
		public static bool IsFileNameInvalid(string fileName)
		{
			if (String.IsNullOrEmpty(fileName))
			{
				return true;
			}

			if (IsFileNameAllGivenCharacter('.', fileName) || IsFileNameAllGivenCharacter(' ', fileName))
			{
				return true;
			}


			return IsFilePartInValid(fileName);

		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.CopyUrlToLocal"]' />
        ///<devdoc>
        /// Copy the specified file to the local project directory.  Also supports downloading
		/// of HTTP resources (so be prepared for a delay in that case!).
		/// </devdoc>
		public static  void CopyUrlToLocal(Uri uri, string local)
		{
			if (uri.IsFile)
			{
				// now copy file
				FileInfo fiOrg = new FileInfo(uri.LocalPath);
				FileInfo fiNew = fiOrg.CopyTo(local, true);
			}
			else
			{
				FileStream localFile = new FileStream(local, FileMode.OpenOrCreate, FileAccess.Write, FileShare.None);
				try
				{
					WebRequest wr = WebRequest.Create(uri);
					wr.Timeout = 10000;
					wr.Credentials = CredentialCache.DefaultCredentials;
					WebResponse resp = wr.GetResponse();
					Stream s = resp.GetResponseStream();
					byte[] buffer = new byte[10 * 1024];
					int len;
					while ((len = s.Read(buffer, 0, buffer.Length)) != 0)
					{
						localFile.Write(buffer, 0, len);
					}
				}
				finally
				{
					localFile.Close();
				}
			}
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.MakeRelativeIfRooted"]' />
        /// <devdoc>
		/// If this file is in the same folder the Url or below make it relative to the current Url
		/// </devdoc>
        /// <param name="fileName">filename (is rooted) to be transformed</param>
		/// <param name="url">the location to make the filename relative to</param>
		/// <returns>the relative path to the url or returns filename if not rooted</returns>
		public static string MakeRelativeIfRooted(string fileName, Url url)
		{
			string relativePath = fileName;
			if (Path.IsPathRooted(relativePath))
			{
				string path = new Url(relativePath).AbsoluteUrl;
				string basePath = url.AbsoluteUrl;
				if (path.StartsWith(basePath, StringComparison.OrdinalIgnoreCase))
				{
					relativePath = path.Substring(basePath.Length);
				}
			}
			return relativePath;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetPathDistance"]' />
        /// <devdoc>
		/// Given two uris calculates the distance from the second path top the first one.
		/// </devdoc>
		/// <returns>The distance in path, if it can make it or the fullpath of the second uri if there if relative path does not make sense.</returns>
		public static string GetPathDistance(Uri uriBase, Uri uriRelativeTo)
		{
			string diff = String.Empty;

			if (uriRelativeTo != null && uriBase != null)
			{
				// MakeRelative only really works if on the same drive.
				if (uriRelativeTo.Segments.Length > 0 && uriBase.Segments.Length > 0 && String.Compare(uriRelativeTo.Segments[1], uriBase.Segments[1], StringComparison.OrdinalIgnoreCase) == 0)
				{
					Uri uriRelative = uriBase.MakeRelativeUri(uriRelativeTo);
					if (uriRelative != null)
					{
						diff = Url.Unescape(uriRelative.ToString(), true);
					}
				}
				else
				{
					diff = uriRelativeTo.LocalPath;
				}
			}

			return diff;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.MakeRelative"]' />
        public static string MakeRelative(string filename, string filename2)
		{
			string[] parts = filename.Split(Path.DirectorySeparatorChar);
			string[] parts2 = filename2.Split(Path.DirectorySeparatorChar);

			if (parts.Length == 0 || parts2.Length == 0 || parts[0] != parts2[0])
			{
				return filename2; // completely different paths.
			}

			int i;

			for (i = 1; i < parts.Length && i < parts2.Length; i++)
			{
				if (parts[i] != parts2[i]) break;
			}

			StringBuilder sb = new StringBuilder();

			for (int j = i; j < parts.Length - 1; j++)
			{
				sb.Append("..");
				sb.Append(Path.DirectorySeparatorChar);
			}

			for (int j = i; j < parts2.Length; j++)
			{
				sb.Append(parts2[j]);
				if (j < parts2.Length - 1)
					sb.Append(Path.DirectorySeparatorChar);
			}

			return sb.ToString();
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.CreateCAUUIDFromGuidArray"]' />
        /// <devdoc>
		/// Creates a CAUUID from a guid array. Memory is allocated for the elems. 
		/// It is the responsability of the caller to release this memory.
		/// </devdoc>
		/// <param name="guids"></param>
		/// <returns></returns>
		[CLSCompliant(false)]
		public static CAUUID CreateCAUUIDFromGuidArray(Guid[] guids)
		{
			CAUUID cauuid = new CAUUID();

			if (guids != null)
			{
				cauuid.cElems = (uint)guids.Length;

				int size = Marshal.SizeOf(typeof(Guid));

				cauuid.pElems = Marshal.AllocCoTaskMem(guids.Length * size);

				IntPtr ptr = cauuid.pElems;

				for (int i = 0; i < guids.Length; i++)
				{
					Marshal.StructureToPtr(guids[i], ptr, false);
					ptr = new IntPtr(ptr.ToInt64() + size);
				}
			}

			return cauuid;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetIntPointerFromImage"]' />
        public static int GetIntPointerFromImage(Image image)
		{
			Debug.Assert(image is Bitmap);
			Bitmap bitmap = image as Bitmap;
			if (bitmap != null)
			{
				IntPtr ptr = bitmap.GetHicon();
				// todo: this is not 64bit safe, but is a work around until whidbey bug 172595 is fixed.
				return ptr.ToInt32();
			}
			return 0;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetImageList"]' />
        /// <devdoc>
		/// Creates an imagelist from resourcenames that are assumed to be icons.
		/// </devdoc>
		/// <param name="assembly"></param>
		/// <param name="resourceNames"></param>
		/// <returns></returns>
		public static ImageList GetImageList(Assembly assembly, string[] resourceNames)
		{
			if (resourceNames == null || resourceNames.Length == 0 || assembly == null)
			{
				return null;
			}

			ImageList ilist = new ImageList();
			ilist.ImageSize = new Size(16, 16);

			foreach (string imageName in resourceNames)
			{
				Stream stream = assembly.GetManifestResourceStream(imageName);
				if (stream != null)
				{
					Icon icon = new Icon(stream);
					ilist.Images.Add(icon.ToBitmap());
				}
			}

			return ilist;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetImageList"]' />
        public static ImageList GetImageList(Stream imageStream)
		{
			ImageList ilist = new ImageList();

			if (imageStream == null)
			{
				return ilist;
			}
			ilist.ImageSize = new Size(16, 16);
			Bitmap bitmap = new Bitmap(imageStream);
			ilist.Images.AddStrip(bitmap);
			ilist.TransparentColor = Color.Magenta;
			return ilist;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetImageList"]' />
        public static ImageList GetImageList(object imageListAsPointer)
		{
			ImageList images = null;

			IntPtr intPtr = new IntPtr((int)imageListAsPointer);
			HandleRef hImageList = new HandleRef(null, intPtr);
			int count = UnsafeNativeMethods.ImageList_GetImageCount(hImageList);

			if (count > 0)
			{
				// Create a bitmap big enough to hold all the images
				Bitmap b = new Bitmap(16 * count, 16);
				Graphics g = Graphics.FromImage(b);

				// Loop through and extract each image from the imagelist into our own bitmap
				IntPtr hDC = IntPtr.Zero;
				try
				{
					hDC = g.GetHdc();
					HandleRef handleRefDC = new HandleRef(null, hDC);
					for (int i = 0; i < count; i++)
					{
						UnsafeNativeMethods.ImageList_Draw(hImageList, i, handleRefDC, i * 16, 0, NativeMethods.ILD_NORMAL);
					}
				}
				finally
				{
					if (g != null && hDC != IntPtr.Zero)
					{
						g.ReleaseHdc(hDC);
					}
				}

				// Create a new imagelist based on our stolen images
				images = new ImageList();
				images.ImageSize = new Size(16, 16);
				images.Images.AddStrip(b);
			}
			return images;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.ConvertToType"]' />
        /// <devdoc>
		/// Helper method to call a converter explicitely to convert to an enum type
		/// </devdoc>
		/// <typeparam name="T">The enum to convert to</typeparam>
		/// <param name="value">The enum value to be converted to</param>
		/// <param name="typeToConvert">The type to convert</param>
		/// <param name="culture">The culture to use to read the localized strings</param>
		/// <returns></returns>
		[CLSCompliant(false)]
		public static object ConvertToType<T>(T value, Type typeToConvert, CultureInfo culture)
			where T : struct
		{
			EnumConverter converter = GetEnumConverter<T>();
			if (converter == null)
			{
				return null;
			}
			if (converter.CanConvertTo(typeToConvert))
			{
				return converter.ConvertTo(null, culture, value, typeToConvert);
			}
			
			return null;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.ConvertFromType"]' />
        /// <devdoc>
		/// Helper method for converting from a string to an enum using a converter.
		/// </devdoc>
		/// <typeparam name="T"></typeparam>
		/// <param name="value"></param>
		/// <param name="culture">The culture to use to read the localized strings</param>
		/// <returns></returns>
		[CLSCompliant(false)]
		public static Nullable<T> ConvertFromType<T>(string value, CultureInfo culture)
			where T : struct
		{
			Nullable<T> returnValue = new Nullable<T>();

			returnValue = returnValue.GetValueOrDefault();

			if (value == null)
			{
				return returnValue;
			}

			EnumConverter converter = GetEnumConverter<T>();
			if (converter == null)
			{
				return returnValue;
			}
			
			if (converter.CanConvertFrom(value.GetType()))
			{
				object converted = converter.ConvertFrom(null, culture, value);

				if (converted != null && (converted is T))
				{
					returnValue = (T)converted;
				}
			}

			return returnValue;
		}


        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.SetStringValueFromConvertedEnum"]' />
        /// <devdoc>
		/// Sets a string value from an enum
		/// </devdoc>
		/// <typeparam name="T">The enum type</typeparam>
		/// <param name="enumValue">The value of the enum.</param>
        /// <param name="culture"></param>
        /// <returns></returns>
		[CLSCompliant(false)]
		public static string SetStringValueFromConvertedEnum<T>(T enumValue, CultureInfo culture)
			where T : struct
		{
			object convertToType = PackageUtilities.ConvertToType<T>(enumValue, typeof(string), culture);
			if (convertToType == null || !(convertToType is string))
			{
				return String.Empty;
			}
			
			return (string)convertToType;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetEnumConverter"]' />
        /// <devdoc>
		/// Gets an instance 
		/// </devdoc>
		/// <typeparam name="T"></typeparam>
		/// <returns></returns>
		private static EnumConverter GetEnumConverter<T>()
			where T : struct
		{
			object[] attributes = typeof(T).GetCustomAttributes(typeof(PropertyPageTypeConverterAttribute), true);

			// There should be only one PropertyPageTypeConverterAttribute defined on T
			if (attributes != null && attributes.Length == 1)
			{
				
				Debug.Assert(attributes[0] is PropertyPageTypeConverterAttribute, "The returned attribute must be an attribute is PropertyPageTypeConverterAttribute");
				PropertyPageTypeConverterAttribute converterAttribute = (PropertyPageTypeConverterAttribute)attributes[0];

				if (converterAttribute.ConverterType.IsSubclassOf(typeof(EnumConverter)))
				{
					return Activator.CreateInstance(converterAttribute.ConverterType) as EnumConverter;
				}
			}

			return null;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.IsFilePartInValid"]' />
        /// <devdoc>
		/// Checks whether a file part contains valid characters. The file part can be any part of a non rooted path.
		/// </devdoc>
		/// <param name="filePart"></param>
		/// <returns></returns>
		private static bool IsFilePartInValid(string filePart)
		{
			if (String.IsNullOrEmpty(filePart))
			{
				return true;
			}

			// Define a regular expression that covers all characters that are not in the safe character sets.
			// It is compiled for performance.
			Regex unsafeCharactersRegex = new Regex(@"[/?:&\\*<>|#%" + '\"' + "]", RegexOptions.Compiled);
			return unsafeCharactersRegex.IsMatch(filePart);
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.IsFileNameAllGivenCharacter"]' />
        /// <devdoc>
		/// Checks if the file name is all the given character.
		/// </devdoc>
		private static bool IsFileNameAllGivenCharacter(char c, string fileName)
		{
			// A valid file name cannot be all "c" .
			int charFound = 0;
			for (charFound = 0; charFound < fileName.Length && fileName[charFound] == c; ++charFound) ;
			if (charFound >= fileName.Length)
			{
				return true;
			}

			return false;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\VsShellUtilities.cs ===
//--------------------------------------------------------------------------
//  <copyright file="VSShellUtilities.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <devdoc>
//  </devdoc>
//--------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using Microsoft.VisualStudio.Shell;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Diagnostics;
using Microsoft.Win32;
using System.Globalization;
using System.IO;
using System.Collections;
using System.Xml;
using System.Text;
using System.Net;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;
using EnvDTE;

namespace Microsoft.VisualStudio.Shell
{

    /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities"]/*' />
    /// <devdoc>
    ///This class provides some useful static shell based methods. 
    /// </devdoc>
    [CLSCompliant(false)]
    public static class VsShellUtilities
    {

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.RenameDocument"]/*' />
        /// <devdoc>
        /// Rename document in the running document table from oldName to newName.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="oldName">Full path to the old name of the document.</param>        
        /// <param name="newName">Full path to the new name of the document.</param>        
        public static void RenameDocument(IServiceProvider site, string oldName, string newName)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(oldName))
            { 
                throw new ArgumentException("oldName");
            }

            if (String.IsNullOrEmpty(newName))
            {
                throw new ArgumentException("newName");
            }

            IVsRunningDocumentTable pRDT = site.GetService(typeof(SVsRunningDocumentTable)) as IVsRunningDocumentTable;
            IVsUIShellOpenDocument doc = site.GetService(typeof(SVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            IVsUIShell uiShell = site.GetService(typeof(SVsUIShell)) as IVsUIShell;

            if (pRDT == null || doc == null) return;

            IVsHierarchy pIVsHierarchy;
            uint itemId;
            IntPtr docData;
            uint uiVsDocCookie;
            ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, oldName, out pIVsHierarchy, out itemId, out docData, out uiVsDocCookie));

            if (docData != IntPtr.Zero)
            {
                try
                {
                    IntPtr pUnk = Marshal.GetIUnknownForObject(pIVsHierarchy);
                    Guid iid = typeof(IVsHierarchy).GUID;
                    IntPtr pHier;
                    Marshal.QueryInterface(pUnk, ref iid, out pHier);
                    try
                    {
                        ErrorHandler.ThrowOnFailure(pRDT.RenameDocument(oldName, newName, pHier, itemId));
                    }
                    finally
                    {
                        Marshal.Release(pHier);
                        Marshal.Release(pUnk);
                    }

                    string newCaption = Path.GetFileName(newName);
                    // now we need to tell the windows to update their captions. 
                    List<IVsWindowFrame> windowFrames = GetFramesForDocument(site, Marshal.GetObjectForIUnknown(docData));
                    foreach (IVsWindowFrame frame in windowFrames) {
                        ErrorHandler.ThrowOnFailure(frame.SetProperty((int)__VSFPROPID.VSFPROPID_OwnerCaption, newCaption));
                    }
                }
                finally
                {
                    Marshal.Release(docData);
                }
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocument"]/*' />
        /// <devdoc>
        /// Open document using the appropriate project. 
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document.</param>
        /// <param name="logicalView">In MultiView case determines view to be activated by IVsMultiViewDocumentView. For a list of logical view GUIDS, see constants starting with LOGVIEWID_ defined in NativeMethods class</param>
        /// <param name="hierarchy">Reference to the IVsUIHierarchy interface of the project that can open the document.</param>
        /// <param name="itemID"> Reference to the hierarchy item identifier of the document in the project.</param>
        /// <param name="windowFrame">A reference to the window frame that is mapped to the document.</param>
        /// <param name="view">A reference to the primary view of the document.</param>
        public static void OpenDocument(IServiceProvider provider, string fullPath, Guid logicalView, out IVsUIHierarchy hierarchy, out uint itemID, out IVsWindowFrame windowFrame, out IVsTextView view)
        {
            itemID = VSConstants.VSITEMID_NIL;
            windowFrame = null;
            hierarchy = null;
            view = null;

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            OpenDocument(provider, fullPath, logicalView, out hierarchy, out itemID, out windowFrame);
            view = GetTextView(windowFrame);
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocument"]/*' />
        /// <devdoc>
        /// Open document using the appropriate project. 
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document.</param>
        /// <param name="logicalView">GUID identifying the logical view.</param>
        /// <param name="hierarchy">Reference to the IVsUIHierarchy interface of the project that contains the Open document.</param>
        /// <param name="itemID"> Reference to the hierarchy item identifier of the document in the project.</param>
        /// <param name="windowFrame">A reference to the window frame that is mapped to the document.</param>
        public static void OpenDocument(IServiceProvider provider, string fullPath, Guid logicalView, out IVsUIHierarchy hierarchy, out uint itemID, out IVsWindowFrame windowFrame)
        {
            windowFrame = null;
            itemID = VSConstants.VSITEMID_NIL;
            hierarchy = null;

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            //open document
            if (!IsDocumentOpen(provider, fullPath, logicalView, out hierarchy, out itemID, out windowFrame))
            {
                IVsUIShellOpenDocument shellOpenDoc = provider.GetService(typeof(IVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
                if (shellOpenDoc != null)
                {
                    IOleServiceProvider psp;
                    uint itemid;
                    ErrorHandler.ThrowOnFailure(shellOpenDoc.OpenDocumentViaProject(fullPath, ref logicalView, out psp, out hierarchy, out itemid, out windowFrame));
                }
            }
            if (windowFrame != null)
            {
                ErrorHandler.ThrowOnFailure(windowFrame.Show());
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetTextView"]/*' />
        /// <devdoc>
        /// Get primary view for a window frame.
        /// </devdoc>
        /// <param name="windowFrame">The window frame</param>
        /// <returns>A refererence to an IVsTextView if successfull. Otherwise null.</returns>
        public static IVsTextView GetTextView(IVsWindowFrame windowFrame)
        {
            if (windowFrame == null)
            {
                throw new ArgumentException("windowFrame");
            }

            object pvar;
            ErrorHandler.ThrowOnFailure(windowFrame.GetProperty((int)__VSFPROPID.VSFPROPID_DocView, out pvar));

            IVsTextView textView = pvar as IVsTextView;

            if (textView == null)
            {
                IVsCodeWindow codeWin = pvar as IVsCodeWindow;
                if (codeWin != null)
                {
                    ErrorHandler.ThrowOnFailure(codeWin.GetPrimaryView(out textView));
                }
            }
            return textView;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetWindowObject"]/*' />
        /// <devdoc>
        /// Get Window interface for the window frame.
        /// </devdoc>
        /// <param name="windowFrame">The window frame.</param>
        /// <returns>A reference to the Window interaface if succesfull. Otherwise null.</returns>
        public static EnvDTE.Window GetWindowObject(IVsWindowFrame windowFrame)
        {
            if (windowFrame == null)
            {
                throw new ArgumentException("windowFrame");
            }

            EnvDTE.Window window = null;
            object pvar;
            ErrorHandler.ThrowOnFailure(windowFrame.GetProperty((int)__VSFPROPID.VSFPROPID_ExtWindowObject, out pvar));
            if (pvar is EnvDTE.Window)
            {
                window = (EnvDTE.Window)pvar;
            }
            return window;

        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.IsDocumentOpen"]/*' />
        /// <devdoc>
        /// Determine if a document is opened with a given logical view.  
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document</param>
        /// <param name="logicalView">GUID identifying the logical view. If logicalView is set to Guid.Empty, it will return true if any view is open.</param>
        /// <param name="hierarchy">Reference to the IVsUIHierarchy interface of the project that contains the Open document</param>
        /// <param name="itemID"> Reference to the hierarchy item identifier of the document in the project</param>
        /// <param name="windowFrame">A reference to the window frame that is mapped to the document</param>
        /// <returns>true if the document is open with the given logical view</returns>
        public static bool IsDocumentOpen(IServiceProvider provider, string fullPath, Guid logicalView, out IVsUIHierarchy hierarchy, out uint itemID, out IVsWindowFrame windowFrame)
        {
            windowFrame = null;
            itemID = VSConstants.VSITEMID_NIL;
            hierarchy = null;

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            //open document
            IVsUIShellOpenDocument shellOpenDoc = provider.GetService(typeof(IVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            IVsRunningDocumentTable pRDT = provider.GetService(typeof(IVsRunningDocumentTable)) as IVsRunningDocumentTable;
            if (pRDT != null && shellOpenDoc != null)
            {
                IntPtr punkDocData = IntPtr.Zero;
                uint docCookie;
                uint[] pitemid = new uint[1];
                IVsHierarchy ppIVsHierarchy;
                try
                {
                    ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, fullPath, out ppIVsHierarchy, out pitemid[0], out punkDocData, out docCookie));
                    int pfOpen;
                    uint flags = (logicalView == Guid.Empty) ? (uint)__VSIDOFLAGS.IDO_IgnoreLogicalView : 0;
                    ErrorHandler.ThrowOnFailure(shellOpenDoc.IsDocumentOpen((IVsUIHierarchy)ppIVsHierarchy, pitemid[0], fullPath, ref logicalView, flags, out hierarchy, pitemid, out windowFrame, out pfOpen));
                    if (windowFrame != null)
                    {
                        itemID = pitemid[0];
                        return (pfOpen == 1);
                    }
                }
                finally
                {
                    if (punkDocData != IntPtr.Zero)
                    {
                        Marshal.Release(punkDocData);
                    }
                }
            }
            return false;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenAsMiscellaneousFile"]/*' />
        /// <devdoc>
        /// Open a file using the miscellaneous project.
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="path">Path to the item to open.</param>
        /// <param name="caption">Caption of the item.</param>
        /// <param name="editor">Unique identifier of the editor type.</param>
        /// <param name="physicalView">Name of physical view.</param>
        /// <param name="logicalView">Name of logical view.</param>
        public static void OpenAsMiscellaneousFile(IServiceProvider provider, string path, string caption, Guid editor, string physicalView, Guid logicalView)
        {

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(path))
            {
                throw new ArgumentException("path");
            }

            IVsProject3 proj = VsShellUtilities.GetMiscellaneousProject(provider);
            VSADDRESULT[] result = new VSADDRESULT[1];
            // NOTE: This method must use VSADDITEMOPERATION.VSADDITEMOP_CLONEFILE.
            // VSADDITEMOPERATION.VSADDITEMOP_OPENFILE doesn't work.
            VSADDITEMOPERATION op = VSADDITEMOPERATION.VSADDITEMOP_CLONEFILE;
            __VSCREATEEDITORFLAGS flags = __VSCREATEEDITORFLAGS.CEF_CLONEFILE;
            ErrorHandler.ThrowOnFailure(proj.AddItemWithSpecific(VSConstants.VSITEMID_NIL, op, caption, 1, new string[1] { path }, IntPtr.Zero,
                (uint)flags, ref editor, physicalView, ref logicalView, result));

            if (result[0] != VSADDRESULT.ADDRESULT_Success)
            {
                throw new ApplicationException(result[0].ToString());
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetMiscellaneousProject"]/*' />
        /// <devdoc>
        /// Get miscellaneous project from current solution
        /// </devdoc>
        /// <param name="provider">The service provider</param>
        /// <returns>A refernce to the IVsProject3 interface for the misceleneous project.</returns>
        public static IVsProject3 GetMiscellaneousProject(IServiceProvider provider)
        {
            if (provider == null)
            {
                throw new ArgumentNullException("provider");
            }

            // Get the IVsExternalFilesManager interface on the SVsExternalFilesManager service.
            IVsExternalFilesManager externalFileMgr = (IVsExternalFilesManager)provider.GetService(typeof(SVsExternalFilesManager));
            if (null == externalFileMgr)
            {
                return null;
            }

            // Now use the external file manager to the the external file project.
            // Note that this project will be created if it does not exist.
            IVsProject prj;
            ErrorHandler.ThrowOnFailure(externalFileMgr.GetExternalFilesProject(out prj));

            // QI for IVsProject3 and return it.
            return prj as IVsProject3;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetMiscellaneousProject"]/*' />
        /// <devdoc>
        /// Get miscellaneous project from current solution
        /// </devdoc>
        /// <param name="provider">The service provider</param>
        /// <param name="create">If false, does not force creation of the misc project</param>
        /// <returns>A refernce to the IVsProject3 interface for the misceleneous project.</returns>
        public static IVsProject3 GetMiscellaneousProject(IServiceProvider provider, bool create)
        {
            if (provider == null)
            {
                throw new ArgumentNullException("provider");
            }

            IVsHierarchy miscHierarchy = null;
            Guid miscProj = VSConstants.CLSID_MiscellaneousFilesProject;
            IVsSolution2 sln = (IVsSolution2)provider.GetService(typeof(SVsSolution));
            int hr = sln.GetProjectOfGuid(ref miscProj, out miscHierarchy);

            if ((NativeMethods.Failed(hr) || miscHierarchy == null) && create)
            {
                return GetMiscellaneousProject(provider);
            }
            return miscHierarchy as IVsProject3;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocument"]/*' />
        /// <devdoc>
        /// Open a document.
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="path">Full path to the document.</param>
        public static void OpenDocument(IServiceProvider provider, string path)
        {
            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(path))
            {
                throw new ArgumentException("path");
            }

            IVsUIHierarchy hierarchy;
            uint itemID;
            IVsWindowFrame windowFrame;
            Guid logicalView = Guid.Empty;
            VsShellUtilities.OpenDocument(provider, path, logicalView, out hierarchy, out itemID, out windowFrame);
            windowFrame = null;
            hierarchy = null;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocumentWithSpecificEditor"]/*' />
        /// <devdoc>
        /// Open a document using a specific editor. 
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document.</param>
        /// <param name="editorType">Unique identifier of the editor type.</param>
        /// <param name="logicalView">In MultiView case determines view to be activated by IVsMultiViewDocumentView. For a list of logical view GUIDS, see constants starting with LOGVIEWID_ defined in NativeMethods class</param>
        /// <returns>A reference to the window frame that is mapped to the document.</returns>
        public static IVsWindowFrame OpenDocumentWithSpecificEditor(IServiceProvider provider, string fullPath, Guid editorType, Guid logicalView)
        {
            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            IVsUIHierarchy hierarchy;
            uint itemID;
            IVsWindowFrame windowFrame;
            OpenDocumentWithSpecificEditor(provider, fullPath, editorType, logicalView, out hierarchy, out itemID, out windowFrame);
            hierarchy = null;
            return windowFrame;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocumentWithSpecificEditor"]/*' />
        /// <devdoc>
        /// Open a document using a specific editor. 
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document.</param>
        /// <param name="editorType">Unique identifier of the editor type.</param>
        /// <param name="logicalView">In MultiView case determines view to be activated by IVsMultiViewDocumentView. For a list of logical view GUIDS, see constants starting with LOGVIEWID_ defined in NativeMethods class</param>
        /// <param name="hierarchy">Reference to the IVsUIHierarchy interface of the project that can open the document.</param>
        /// <param name="itemID"> Reference to the hierarchy item identifier of the document in the project.</param>
        /// <param name="windowFrame">A reference to the window frame that is mapped to the document.</param>
        public static void OpenDocumentWithSpecificEditor(IServiceProvider provider, string fullPath, Guid editorType, Guid logicalView, out IVsUIHierarchy hierarchy, out uint itemID, out IVsWindowFrame windowFrame)
        {
            windowFrame = null;
            itemID = VSConstants.VSITEMID_NIL;
            hierarchy = null;

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            //open document
            IVsUIShellOpenDocument shellOpenDoc = provider.GetService(typeof(IVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            IVsRunningDocumentTable pRDT = provider.GetService(typeof(IVsRunningDocumentTable)) as IVsRunningDocumentTable;
            string physicalView = null;
            if (pRDT != null && shellOpenDoc != null)
            {
                ErrorHandler.ThrowOnFailure(shellOpenDoc.MapLogicalView(ref editorType, ref logicalView, out physicalView));
                // See if the requested editor is already open with the requested view.
                IntPtr punkDocData = IntPtr.Zero;
                uint docCookie;
                IVsHierarchy ppIVsHierarchy;
                try
                {
                    ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, fullPath, out ppIVsHierarchy, out itemID, out punkDocData, out docCookie));                    
                    int pfOpen;
                    uint flags = (uint)__VSIDOFLAGS.IDO_ActivateIfOpen;
                    int hr = shellOpenDoc.IsSpecificDocumentViewOpen((IVsUIHierarchy)ppIVsHierarchy, itemID, fullPath, ref editorType, physicalView, flags, out hierarchy, out itemID, out windowFrame, out pfOpen);
                    if (ErrorHandler.Succeeded(hr) && pfOpen == 1)
                    {
                        return;
                    }
                }
                finally
                { 
                    if (punkDocData != IntPtr.Zero)
                    {
                        Marshal.Release(punkDocData);
                    }
                }

                IOleServiceProvider psp;
                uint editorFlags = (uint)__VSSPECIFICEDITORFLAGS.VSSPECIFICEDITOR_UseEditor | (uint)__VSSPECIFICEDITORFLAGS.VSSPECIFICEDITOR_DoOpen;
                ErrorHandler.ThrowOnFailure(shellOpenDoc.OpenDocumentViaProjectWithSpecific(fullPath, editorFlags, ref editorType, physicalView, ref logicalView, out psp, out hierarchy, out itemID, out windowFrame));
                if (windowFrame != null)
                    ErrorHandler.ThrowOnFailure(windowFrame.Show());
                psp = null;
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetProject"]/*' />
        /// <devdoc>
        /// Get reference to the IVsHierarchy interface for project that owns the document.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="moniker">The document moniker.</param>
        /// <returns>
        /// If the document is open, this is a reference to the IVsUIHierarchy Interface implementation of the project that owns the document. 
        /// If the document is not open, the value of this parameter is NULL. 
        /// </returns>
        public static IVsHierarchy GetProject(IServiceProvider site, string moniker)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(moniker))
            {
                throw new ArgumentException("moniker");
            }

            IVsUIShellOpenDocument opendoc = site.GetService(typeof(SVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            IVsUIHierarchy hierarchy = null;
            uint pitemid;
            IOleServiceProvider sp;
            int docInProj;
            int rc = opendoc.IsDocumentInAProject(moniker, out hierarchy, out pitemid, out sp, out docInProj);
            ErrorHandler.ThrowOnFailure(rc);
            return hierarchy as IVsHierarchy;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetRunningDocumentContents"]/*' />
        /// <devdoc>
        /// Get contents of file loaded by the running document table.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="path">Path to the file.</param>
        /// <returns>The contents of the file if it is loaded by RDT. Otherwise it returns null.</returns>
        public static string GetRunningDocumentContents(IServiceProvider site, string path)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(path))
            {
                throw new ArgumentException("path");
            }

            string text = null;
            IVsRunningDocumentTable pRDT = (IVsRunningDocumentTable)site.GetService(typeof(SVsRunningDocumentTable));
            if (pRDT != null)
            {
                IntPtr punkDocData = IntPtr.Zero;
                uint pitemid;
                uint docCookie;
                IVsHierarchy ppIVsHierarchy;
                try
                {
                    ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, path, out ppIVsHierarchy, out pitemid, out punkDocData, out docCookie));
                    if (punkDocData != IntPtr.Zero)
                    {
                        object docDataObj = Marshal.GetObjectForIUnknown(punkDocData);
                        IVsTextLines buffer = null;
                        if (docDataObj is IVsTextLines)
                        {
                            buffer = (IVsTextLines)docDataObj;
                        }
                        else if (docDataObj is IVsTextBufferProvider)
                        {
                            IVsTextBufferProvider tp = (IVsTextBufferProvider)docDataObj;
                            if (tp.GetTextBuffer(out buffer) != VSConstants.S_OK)
                                buffer = null;
                        }
                        if (buffer != null)
                        {
                            int endLine, endIndex;
                            ErrorHandler.ThrowOnFailure(buffer.GetLastLineIndex(out endLine, out endIndex));
                            ErrorHandler.ThrowOnFailure(buffer.GetLineText(0, 0, endLine, endIndex, out text));
                            buffer = null;
                            return text;
                        }
                    }
                }
                finally
                {
                    if (punkDocData != IntPtr.Zero)
                    {
                        Marshal.Release(punkDocData);
                    }
                }
            }

            return null;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetRDTDocumentInfo"]/*' />
        /// <devdoc>
        /// Get a reference to the IVsPersistDocData interface associated to a document in the Running Document Table.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="documentName">Path to the document.</param>
        /// <param name="hierarchy">[out, optional] Reference to the IVsHierarchy interface for the project who owns the document.</param>
        /// <param name="itemid">[out, optional] Reference to an item identifier in the hierarchy. </param>
        /// <param name="persistDocData">[out] A reference to the IVsPersistDocData interface associated to the document</param>
        /// <param name="docCookie">[out, optional] A reference to an abstract handle to the document. </param>
        public static void GetRDTDocumentInfo(IServiceProvider site, string documentName, out IVsHierarchy hierarchy, out uint itemid, out IVsPersistDocData persistDocData, out uint docCookie)
        {
            hierarchy = null;
            itemid = VSConstants.VSITEMID_NIL;
            persistDocData = null;
            docCookie = (uint)ShellConstants.VSDOCCOOKIE_NIL;

            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(documentName))
            {
                throw new ArgumentException("documentName");
            }

            // Get the document info.
            IVsRunningDocumentTable rdt = site.GetService(typeof(IVsRunningDocumentTable)) as IVsRunningDocumentTable;
            if (rdt == null) return;

            IntPtr docData = IntPtr.Zero;
            try
            {
                ErrorHandler.ThrowOnFailure(rdt.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, documentName, out hierarchy, out itemid, out docData, out docCookie));


                if (docData != IntPtr.Zero)
                {
                    // if interface is not supported, return null
                    persistDocData = Marshal.GetObjectForIUnknown(docData) as IVsPersistDocData;
                }
            }
            finally
            {

                if (docData != IntPtr.Zero)
                {
                    Marshal.Release(docData);
                }
            }
        }

        private static List<IVsWindowFrame> GetFramesForDocument(IServiceProvider site, object docData) {
            List<IVsWindowFrame> result = new List<IVsWindowFrame>();
            IVsRunningDocumentTable rdt = site.GetService(typeof(SVsRunningDocumentTable)) as IVsRunningDocumentTable;
            IVsUIShell uiShell = site.GetService(typeof(SVsUIShell)) as IVsUIShell;

            if (uiShell == null || rdt == null)
                return result;

            IEnumWindowFrames framesEnum;
            ErrorHandler.ThrowOnFailure(uiShell.GetDocumentWindowEnum(out framesEnum));
            IVsWindowFrame[] frames = new IVsWindowFrame[16];
            uint retrieved;

            while (true) {
                ErrorHandler.ThrowOnFailure(framesEnum.Next((uint)frames.Length, frames, out retrieved));
                if (retrieved == 0)
                    break;

                for (int idx = 0; idx < retrieved; idx++) {
                    IVsWindowFrame windowFrame = frames[idx];
                    object data = ErrorHandler.ThrowOnFailure(windowFrame.GetProperty((int)__VSFPROPID.VSFPROPID_DocData, out data));
                    if (NativeMethods.IsSameComObject(data, docData)) {
                        result.Add(windowFrame);
                    }
                }
            }

            return result;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.SaveFileIfDirty"]/*' />
        /// <devdoc>
        /// Save file if it is dirty.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="fullPath">The full path of the file to be saved.</param>
        public static void SaveFileIfDirty(IServiceProvider site, string fullPath)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            IVsRunningDocumentTable pRDT = (IVsRunningDocumentTable)site.GetService(typeof(SVsRunningDocumentTable));
            if (pRDT != null)
            {
                IntPtr punkDocData;
                uint pitemid;
                uint docCookie;
                IVsHierarchy vsHierarchy;
                ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, fullPath, out vsHierarchy, out pitemid, out punkDocData, out docCookie));
                if (punkDocData != IntPtr.Zero)
                {
                    try
                    {
                        object docDataObj = Marshal.GetObjectForIUnknown(punkDocData);
                        IVsPersistDocData2 pdd = (IVsPersistDocData2)docDataObj;
                        int dirty;
                        ErrorHandler.ThrowOnFailure(pdd.IsDocDataDirty(out dirty));
                        if (dirty != 0)
                        {
                            string newdoc;
                            int cancelled;
                            int hr = pdd.SaveDocData(VSSAVEFLAGS.VSSAVE_Save, out newdoc, out cancelled);
                            if (cancelled <= 0) {
                                ErrorHandler.ThrowOnFailure(hr);
                            }

                            // If the document is saved with a different name then update caption on windowFrames
                            if (!String.IsNullOrEmpty(newdoc)) {
                                string newCaption = Path.GetFileName(newdoc);

                                List<IVsWindowFrame> windowFrames = GetFramesForDocument(site, docDataObj);
                                foreach (IVsWindowFrame frame in windowFrames) {
                                    ErrorHandler.ThrowOnFailure(frame.SetProperty((int)__VSFPROPID.VSFPROPID_OwnerCaption, newCaption));
                                }
                            }
                        }
                    }
                    finally
                    {
                        Marshal.Release(punkDocData);
                    }
                }
                vsHierarchy = null;
            }
            pRDT = null;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.SaveFileIfDirty"]/*' />
        /// <devdoc>
        /// Save document data for a text view.
        /// </devdoc>
        /// <param name="view">The view to be saved</param>
        public static void SaveFileIfDirty(IVsTextView view)
        {
            if (view == null)
            {
                throw new ArgumentException("view");
            }


            IVsTextLines buffer;
            ErrorHandler.ThrowOnFailure(view.GetBuffer(out buffer));
            IVsPersistDocData2 pdd = (IVsPersistDocData2)buffer;
            int dirty;
            ErrorHandler.ThrowOnFailure(pdd.IsDocDataDirty(out dirty));
            if (dirty != 0)
            {
                string newdoc;
                int cancelled;
                int hr = pdd.SaveDocData(VSSAVEFLAGS.VSSAVE_Save, out newdoc, out cancelled);
                if (cancelled <= 0) {
                    ErrorHandler.ThrowOnFailure(hr);
                }

                // If the document is saved with a different name then update caption on windowFrame
                if (!String.IsNullOrEmpty(newdoc)) {
                    string newCaption = Path.GetFileName(newdoc);

                    IVsTextViewEx viewEx = view as IVsTextViewEx;
                    if (viewEx != null) {
                        object window;
                        viewEx.GetWindowFrame(out window);
                        IVsWindowFrame frame = window as IVsWindowFrame;
                        if (frame != null) {
                            ErrorHandler.ThrowOnFailure(frame.SetProperty((int)__VSFPROPID.VSFPROPID_OwnerCaption, newCaption));
                        }
                    }
                }
            }
            pdd = null;
            buffer = null;
        }


        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.PromptYesNo"]/*' />
        /// <devdoc>
        /// Prompt the user with the specified message.
        /// </devdoc>
        /// <param name="message">The message to show.</param>
        /// <param name="title">The title of the message box.</param>
        /// <param name="icon">The icon to show on the message box.</param>
        /// <param name="uiShell">A reference to a IVsUIShell interface.</param>        
        /// <returns>Return true if the result is Yes, false otherwise.</returns>
        public static bool PromptYesNo(string message, string title, OLEMSGICON icon, IVsUIShell uiShell)
        {
            Guid emptyGuid = Guid.Empty;
            int result = 0;
            ErrorHandler.ThrowOnFailure(uiShell.ShowMessageBox(
                0,
                ref emptyGuid,
                title,
                message,
                null,
                0,
                OLEMSGBUTTON.OLEMSGBUTTON_YESNO,
                OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_SECOND,
                icon,
                0,
                out result));

            return (result == NativeMethods.IDYES);
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.ShowMessageBox"]/*' />
        /// <devdoc>
        /// Show message box.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider</param>
        /// <param name="message">The message to show</param>
        /// <param name="title">The title of the message box</param>
        /// <param name="icon">The icon to show on the message box</param>
        /// <param name="msgButton">The button type</param>
        /// <param name="defaultButton">The default button</param>
        /// <returns>If the method succeeds, it returns S_OK. If it fails, it returns an error code. If a referernce to the IVsUIShell interface cannot be retrived from the service provider then InvalidOperationException is thrown.</returns>
        public static int ShowMessageBox(IServiceProvider serviceProvider, string message, string title, OLEMSGICON icon, OLEMSGBUTTON msgButton, OLEMSGDEFBUTTON defaultButton)
        {
            Debug.Assert(serviceProvider != null, "Could not create MessageBox for a null serviceprovider");
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsUIShell uiShell = serviceProvider.GetService(typeof(IVsUIShell)) as IVsUIShell;
            Debug.Assert(uiShell != null, "Could not get the IVsUIShell object from the services exposed by this serviceprovider");
            if (uiShell == null)
            {
                throw new InvalidOperationException();
            }
            Guid emptyGuid = Guid.Empty;
            int result = 0;
            ErrorHandler.ThrowOnFailure(uiShell.ShowMessageBox(
                0,
                ref emptyGuid,
                title,
                message,
                null,
                0,
                msgButton,
                defaultButton,
                icon,
                0,
                out result));

            return result;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetTaskItems"]/*' />
        /// <devdoc>
        /// Get list of all tasks items.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>A list of task items.</returns>
        public static IList<IVsTaskItem2> GetTaskItems(IServiceProvider serviceProvider)
        {
            IList<IVsTaskItem2> tasks = new List<IVsTaskItem2>();

            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsTaskList taskList = serviceProvider.GetService(typeof(IVsTaskList)) as IVsTaskList;

            if (taskList == null)
            {
                throw new InvalidOperationException();
            }

            IVsEnumTaskItems enumTaskItems;
            try
            {
                ErrorHandler.ThrowOnFailure(taskList.EnumTaskItems(out enumTaskItems));

                if (enumTaskItems == null)
                {
                    return tasks;
                }

                int result = VSConstants.E_FAIL;
                uint[] fetched = new uint[1];
                do
                {
                    IVsTaskItem[] taskItems = new IVsTaskItem[1];

                    result = enumTaskItems.Next(1, taskItems, fetched);

                    if (fetched[0] == 1)
                    {
                        IVsTaskItem2 taskItem = taskItems[0] as IVsTaskItem2;
                        tasks.Add(taskItem);
                    }

                } while (result == VSConstants.S_OK && fetched[0] == 1);
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception : " + e.Message);
            }

            return tasks;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.EmptyTaskList"]/*' />
        /// <devdoc>
        /// Empty the task list.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>If the method succeeds, it returns S_OK. If it fails, it returns an error code. </returns>
        public static int EmptyTaskList(IServiceProvider serviceProvider)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsTaskList taskList = serviceProvider.GetService(typeof(IVsTaskList)) as IVsTaskList;

            if (taskList == null)
            {
                throw new InvalidOperationException();
            }

            IVsEnumTaskItems enumTaskItems;
            int result = VSConstants.S_OK;
            try
            {
                ErrorHandler.ThrowOnFailure(taskList.EnumTaskItems(out enumTaskItems));

                if (enumTaskItems == null)
                {
                    throw new InvalidOperationException();
                }

                // Retrieve the task item text and check whether it is equal with one that supposed to be thrown.
                
                uint[] fetched = new uint[1];
                do
                {
                    IVsTaskItem[] taskItems = new IVsTaskItem[1];

                    result = enumTaskItems.Next(1, taskItems, fetched);

                    if (fetched[0] == 1)
                    {
                        IVsTaskItem2 taskItem = taskItems[0] as IVsTaskItem2;
                        if (taskItem != null)
                        {
                            int canDelete;
                            ErrorHandler.ThrowOnFailure(taskItem.CanDelete(out canDelete));
                            if (canDelete == 1)
                            {
                                ErrorHandler.ThrowOnFailure(taskItem.OnDeleteTask());
                            }
                        }
                    }

                } while (result == VSConstants.S_OK && fetched[0] == 1);

            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception : " + e.Message);
                result = e.ErrorCode;
            }

            return result;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.LaunchDebugger"]/*' />
        /// <devdoc>
        /// Launch the debugger.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <param name="info">A reference to a VsDebugTargetInfo object.</param>
        public static void LaunchDebugger(IServiceProvider serviceProvider, VsDebugTargetInfo info)
        {
            Debug.Assert(serviceProvider != null, "Cannot launch the debugger on an empty service provider");
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            info.cbSize = (uint)Marshal.SizeOf(info);
            IntPtr ptr = Marshal.AllocCoTaskMem((int)info.cbSize);
            Marshal.StructureToPtr(info, ptr, false);
            try
            {
                IVsDebugger d = serviceProvider.GetService(typeof(IVsDebugger)) as IVsDebugger;
                Debug.Assert(d != null, "Could not retrieve IVsDebugger from " + serviceProvider.GetType().Name);

                if (d == null)
                {
                    throw new InvalidOperationException();
                }
                
                ErrorHandler.ThrowOnFailure(d.LaunchDebugTargets(1, ptr));
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception : " + e.Message);
            }
            finally
            {
                if (ptr != IntPtr.Zero)
                {
                    Marshal.FreeCoTaskMem(ptr);
                }
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetHierarchy"]/*' />
        /// <devdoc>
        /// Get reference to IVsHierarchy interface from project guid.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="projectGuid">A project guid.</param>
        ///<returns>A reference to an IVsHierarchy interface.</returns>
        public static IVsHierarchy GetHierarchy(IServiceProvider site, Guid projectGuid)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (projectGuid == Guid.Empty)
            {
                throw new ArgumentException("projectGuid");
            }

            IVsHierarchy hierarchy = null;

            IVsSolution solution = site.GetService(typeof(SVsSolution)) as IVsSolution;

            if (solution == null)
            {
                throw new InvalidOperationException();
            }

            try
            {
                solution.GetProjectOfGuid(ref projectGuid, out hierarchy);
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }
            // If the project is not loaded this is the exception thrown.
            catch (InvalidCastException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }

            return hierarchy;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetUIHierarchyWindow"]/*' />
        /// <devdoc>
        /// Get reference to IVsUIHierarchyWindow interface from guid persistence slot.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <param name="guidPersistenceSlot">Unique identifier for a tool window created using IVsUIShell::CreateToolWindow. The caller of this method can use predefined identifiers that map to tool windows if those tool windows are known to the caller. </param>
        /// <returns>A reference to an IVsUIHierarchyWindow interface.</returns>
        public static IVsUIHierarchyWindow GetUIHierarchyWindow(IServiceProvider serviceProvider, Guid guidPersistenceSlot)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsUIShell shell = serviceProvider.GetService(typeof(SVsUIShell)) as IVsUIShell;

            Debug.Assert(shell != null, "Could not get the ui shell from the project");
            if (shell == null)
            {
                throw new InvalidOperationException();
            }

            object pvar = null;
            IVsWindowFrame frame = null;
            IVsUIHierarchyWindow uiHierarchyWindow = null;

            try
            {
                ErrorHandler.ThrowOnFailure(shell.FindToolWindow(0, ref guidPersistenceSlot, out frame));
                ErrorHandler.ThrowOnFailure(frame.GetProperty((int)__VSFPROPID.VSFPROPID_DocView, out pvar));
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }
            finally
            {
                if (pvar != null)
                {
                    IVsWindowPane pane = (IVsWindowPane)pvar;

                    uiHierarchyWindow = (IVsUIHierarchyWindow)pane;
                }
            }

            return uiHierarchyWindow;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetOutputWindowPane"]/*' />
        /// <devdoc>
        /// Get reference to IVsOutputWindowPane interface from pane guid.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <param name="guidPane">A guid for the pane.</param>
        /// <returns>A reference to an IVsOutputWindowPane interface.</returns>
        public static IVsOutputWindowPane GetOutputWindowPane(IServiceProvider serviceProvider, Guid guidPane)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsOutputWindow outputWindow = serviceProvider.GetService(typeof(IVsOutputWindow)) as IVsOutputWindow;
            if (outputWindow == null)
            {
                throw new InvalidOperationException();
            }

            IVsOutputWindowPane outputWindowPane = null;
            try
            {
                ErrorHandler.ThrowOnFailure(outputWindow.GetPane(ref guidPane, out outputWindowPane));
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }

            return outputWindowPane;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetDebugMode"]/*' />
        /// <devdoc>
        /// Get debug mode of the shell (design/break/shell).
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>A DBGMODE enumeration.</returns>
        public static DBGMODE GetDebugMode(IServiceProvider serviceProvider)
        {
            DBGMODE[] dbgmode = new DBGMODE[1] { DBGMODE.DBGMODE_Design };

            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsDebugger debugger = serviceProvider.GetService(typeof(IVsDebugger)) as IVsDebugger;

            if (debugger == null)
            {
                throw new InvalidOperationException();
            }

            try
            {
                ErrorHandler.ThrowOnFailure(debugger.GetMode(dbgmode));
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }

            return dbgmode[0];
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.IsVisualStudioInDesignMode"]/*' />
        /// <devdoc>
        /// Is Visual Studio in design mode.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>true if visual studio is in design mode</returns>
        public static bool IsVisualStudioInDesignMode(IServiceProvider serviceProvider)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            DBGMODE dbgMode = GetDebugMode(serviceProvider) & ~DBGMODE.DBGMODE_EncMask;

            return dbgMode == DBGMODE.DBGMODE_Design;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.IsSolutionBuilding"]/*' />
        /// <devdoc>
        /// Is current solution building or deploying
        /// </devdoc>
        /// <param name="serviceProvider">The service provider</param>
        /// <returns>true if solution is building or deploying.</returns>
        public static bool IsSolutionBuilding(IServiceProvider serviceProvider)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsSolutionBuildManager solutionBuildManager = serviceProvider.GetService(typeof(IVsSolutionBuildManager)) as IVsSolutionBuildManager;

            if (solutionBuildManager == null)
            {
                throw new InvalidOperationException();
            }

            int returnValueAsInteger = 0;
            ErrorHandler.ThrowOnFailure(solutionBuildManager.QueryBuildManagerBusy(out returnValueAsInteger));
            return (returnValueAsInteger == 1);
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.IsInAutomationFunction"]/*' />
        /// <devdoc>
        /// Is an extensibility object executing an automation function.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>true if the extensiblity object is executing an automation function.</returns>
        public static bool IsInAutomationFunction(IServiceProvider serviceProvider)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsExtensibility extensibility = serviceProvider.GetService(typeof(IVsExtensibility)) as IVsExtensibility;

            if (extensibility == null)
            {
                throw new InvalidOperationException();
            }

            return (extensibility.IsInAutomationFunction() == 0) ? false : true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\VSRegistry.cs ===
//------------------------------------------------------------------------------
// <copyright file="Package.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
using System;
using Microsoft.Win32;

using Microsoft.VisualStudio.Shell.Interop;

using ErrorHandler = Microsoft.VisualStudio.ErrorHandler;
using IServiceProvider = System.IServiceProvider;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;

namespace Microsoft.VisualStudio.Shell {
    /// <summary>
    /// Helper class to handle the registry of the instance of VS that is
    /// hosting this code.
    /// </summary>
    [System.CLSCompliant(false)]
    public static class VSRegistry {
        // ServiceProvider object that wraps the global service provider of VS.
        private static ServiceProvider globalProvider;

        private static ServiceProvider GlobalProvider {
            get {
                if (null == globalProvider) {
                    // Try to get the global service provider from the Package class.
                    IOleServiceProvider sp = Package.GetGlobalService(typeof(IOleServiceProvider)) as IOleServiceProvider;
                    if (null != sp) {
                        globalProvider = new ServiceProvider(sp);
                    }
                }
                return globalProvider;
            }
        }

        /// <summary>
        /// Returns a read-only RegistryKey object for the root of a given storage type.
        /// It is up to the caller to dispose the returned object.
        /// </summary>
        /// <param name="registryType">The type of registry storage to open.</param>
        public static RegistryKey RegistryRoot(__VsLocalRegistryType registryType) {
            return RegistryRoot(GlobalProvider, registryType, false);
        }

        /// <summary>
        /// Returns a RegistryKey object for the root of a given storage type.
        /// It is up to the caller to dispose the returned object.
        /// </summary>
        /// <param name="registryType">The type of registry storage to open.</param>
        /// <param name="writable">Flag to indicate is the key should be writable.</param>
        public static RegistryKey RegistryRoot(__VsLocalRegistryType registryType, bool writable) {
            return RegistryRoot(GlobalProvider, registryType, writable);
        }

        /// <summary>
        /// Returns a RegistryKey object for the root of a given storage type.
        /// It is up to the caller to dispose the returned object.
        /// </summary>
        /// <param name="provider">The service provider to use to access the Visual Studio's services.</param>
        /// <param name="registryType">The type of registry storage to open.</param>
        /// <param name="writable">Flag to indicate is the key should be writable.</param>
        public static RegistryKey RegistryRoot(IServiceProvider provider, __VsLocalRegistryType registryType, bool writable) {
            if (null == provider) {
                throw new ArgumentNullException("provider");
            }

            // The current implementation of the shell supports only RegType_UserSettings and
            // RegType_Configuration, so for any other values we have to return not implemented.
            if ((__VsLocalRegistryType.RegType_UserSettings != registryType) &&
                (__VsLocalRegistryType.RegType_Configuration != registryType))
            {
                throw new NotSupportedException();
            }

            // Try to get the new ILocalRegistry4 interface that is able to handle the new
            // registry paths.
            ILocalRegistry4 localRegistry = provider.GetService(typeof(SLocalRegistry)) as ILocalRegistry4;
            if (null != localRegistry) {
                uint rootHandle;
                string rootPath;
                if (ErrorHandler.Succeeded(localRegistry.GetLocalRegistryRootEx((uint)registryType, out rootHandle, out rootPath))) {
                    // Check if we have valid data.
                    __VsLocalRegistryRootHandle handle = (__VsLocalRegistryRootHandle)rootHandle;
                    if (!string.IsNullOrEmpty(rootPath) && (__VsLocalRegistryRootHandle.RegHandle_Invalid != handle)) {
                        // Check if the root is inside HKLM or HKCU. Note that this does not depends only from
                        // the registry type, but also from instance-specific data like the RANU flag.
                        RegistryKey root = (__VsLocalRegistryRootHandle.RegHandle_LocalMachine == handle) ? Registry.LocalMachine : Registry.CurrentUser;
                        return root.OpenSubKey(rootPath, writable);
                    }
                }
            }

            // We are here if the usage of the new interface failed for same reason, so we have to fall back to
            // the ond way to access the registry.
            ILocalRegistry2 oldRegistry = provider.GetService(typeof(SLocalRegistry)) as ILocalRegistry2;
            if (null == oldRegistry) {
                // There is something wrong with this installation or this service provider.
                return null;
            }
            string registryPath;
            NativeMethods.ThrowOnFailure(oldRegistry.GetLocalRegistryRoot(out registryPath));
            if (string.IsNullOrEmpty(registryPath)) {
                return null;
            }

            RegistryKey regRoot = (__VsLocalRegistryType.RegType_Configuration == registryType) ? Registry.LocalMachine : Registry.CurrentUser;
            return regRoot.OpenSubKey(registryPath, writable);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\Flavor\ProjectDocumentsChangeEventsArgs.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace Microsoft.VisualStudio.Shell.Flavor
{
    /// <include file='doc\ProjectDocumentsChangeEventArgs.uex' path='docs/doc[@for="ProjectDocumentsChangeEventArgs"]/*' />
    public sealed class ProjectDocumentsChangeEventArgs : EventArgs
	{
		private string mkDocument = null;
        /// <include file='doc\ProjectDocumentsChangeEventArgs.uex' path='docs/doc[@for="ProjectDocumentsChangeEventArgs.MkDocument"]/*' />
        /// <devdoc>
		/// Unique name of the Project item that was changed.
		/// Use IVsProject.IsDocumentInProject() to map to an itemid.
		/// </devdoc>
		public string MkDocument
		{
			get { return mkDocument; }
			set { mkDocument = value; }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\Flavor\FlavoredProjectFactoryBase.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

namespace Microsoft.VisualStudio.Shell.Flavor
{
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.VisualStudio.OLE.Interop;

    /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase"]/*' />
    /// <devdoc>
    /// The project factory for the project flavor.
    /// Note that this is also known as Project Subtype
    /// </devdoc>
    [CLSCompliant(false)]
    public abstract class FlavoredProjectFactoryBase : IVsAggregatableProjectFactoryCorrected, IVsProjectFactory
    {
        private ServiceProvider _serviceProvider;
        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.ServiceProvider"]/*' />
        protected ServiceProvider serviceProvider
        {
            get { return _serviceProvider; }
        }

        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.FlavoredProjectFactoryBase"]/*' />
        public FlavoredProjectFactoryBase()
        {
        }

        #region IVsProjectFactory

        int IVsProjectFactory.CanCreateProject(string fileName, uint flags, out int canCreate)
        {
            canCreate = this.CanCreateProject(fileName, flags) ? 1 : 0;
            return VSConstants.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.CanCreateProject"]/*' />
        /// <devdoc>
        /// This is called to ask the factory if it can create a project based on the current parameters
        /// </devdoc>
        /// <returns>True if the project can be created</returns>
        protected virtual bool CanCreateProject(string fileName, uint flags)
        {
            // Validate the filename
            bool canCreate = !string.IsNullOrEmpty(fileName);
            canCreate |= !PackageUtilities.ContainsInvalidFileNameChars(fileName);
            return canCreate;
        }

        /// <devdoc>
        /// This is not expected to be called unless using an extension other then the base project
        /// </devdoc>
        int IVsProjectFactory.CreateProject(string fileName, string location, string name, uint flags, ref Guid projectGuid, out System.IntPtr project, out int canceled)
        {
            this.CreateProject(fileName, location, name, flags, ref projectGuid, out project, out canceled);
            return VSConstants.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.CreateProject"]/*' />
        /// <devdoc>
        /// If you want to use your own extension, you will need to call IVsCreateAggregatedProject.CreateAggregatedProject()
        /// </devdoc>
        /// <returns>HRESULT</returns>
        protected virtual void CreateProject(string fileName, string location, string name, uint flags, ref Guid projectGuid, out System.IntPtr project, out int canceled)
        {
            // If the extension is that of the base project then we don't get called
            project = IntPtr.Zero;
            canceled = 0;
        }

        int IVsProjectFactory.Close()
        {
            this.Dispose(true);

            return VSConstants.S_OK;
        }

        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.Dispose"]/*' />
        protected virtual void Dispose(bool disposing)
        {
            if (_serviceProvider != null)
            {
                _serviceProvider.Dispose();
                _serviceProvider = null;
            }
        }

        int IVsProjectFactory.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider provider)
        {
            // keep track of our service provider
            this._serviceProvider = new ServiceProvider(provider);

            this.Initialize();

            return VSConstants.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.Initialize"]/*' />
        /// <devdoc>
        /// Called by SetSite after setting our service provider
        /// </devdoc>
        protected virtual void Initialize()
        {
        }

        #endregion

        #region IVsAggregatableProjectFactory

        int IVsAggregatableProjectFactoryCorrected.GetAggregateProjectType(string fileName, out string projectTypeGuid)
        {
            projectTypeGuid = this.ProjectTypeGuids(fileName);
            return VSConstants.S_OK;
        }

        int IVsAggregatableProjectFactoryCorrected.PreCreateForOuter(IntPtr outerProjectIUnknown, out IntPtr projectIUnknown)
        {
            projectIUnknown = IntPtr.Zero;  // always initialize out parameters of COM interfaces!

            object newProject = PreCreateForOuter(outerProjectIUnknown);

            IntPtr newProjectIUnknown = IntPtr.Zero;
            ILocalRegistryCorrected localRegistry = (ILocalRegistryCorrected)Package.GetGlobalService(typeof(SLocalRegistry));
            Debug.Assert(localRegistry != null, "Could not get the ILocalRegistry object");
            if (localRegistry == null)
            {
                throw new InvalidOperationException();
            }
            Guid clsid = typeof(Microsoft.VisualStudio.ProjectAggregator.CProjectAggregatorClass).GUID;
            Guid riid = VSConstants.IID_IUnknown;
            uint dwClsCtx = (uint)CLSCTX.CLSCTX_INPROC_SERVER;
            IntPtr aggregateProjectIUnknown = IntPtr.Zero;
            IVsProjectAggregator2 vsProjectAggregator2 = null;

            try
            {
                ErrorHandler.ThrowOnFailure(localRegistry.CreateInstance(clsid, outerProjectIUnknown, ref riid, dwClsCtx, out aggregateProjectIUnknown));

                // If we have a non-NULL punkOuter then we need to create a COM aggregated object with that punkOuter,
                // if not then we are the top of the aggregation.
                if (outerProjectIUnknown != IntPtr.Zero)
                {
                    newProjectIUnknown = Marshal.CreateAggregatedObject(outerProjectIUnknown, newProject);
                }
                else
                {
                    newProjectIUnknown = Marshal.CreateAggregatedObject(aggregateProjectIUnknown, newProject); ;
                }

                vsProjectAggregator2 = (IVsProjectAggregator2)Marshal.GetObjectForIUnknown(aggregateProjectIUnknown);
                if (vsProjectAggregator2 != null)
                {
                    vsProjectAggregator2.SetMyProject(newProjectIUnknown);
                }

                // We return the native ProjectAggregator COM object as the project created by our project
                // factory. This ProjectAggregator main purpose is to manage the fact that the punkInner pointer
                // for the project aggregation is not known until after IVsAggregateProject::SetInnerProject is 
                // called. This native object has a special implementation of QueryInterface that can handle 
                // the SetInnerProject mechanism. The ProjectAggregator will first delegate QueryInterface 
                // calls to our managed project and then delegates to the inner Project.
                // Note: we need to return an AddRef'ed IUnknown (AddRef comes from CreateInstance call).
                projectIUnknown = aggregateProjectIUnknown;
                aggregateProjectIUnknown = IntPtr.Zero;
            }
            finally
            {
                if (newProjectIUnknown != IntPtr.Zero)
                    Marshal.Release(newProjectIUnknown);
                if (aggregateProjectIUnknown != IntPtr.Zero)
                    Marshal.Release(aggregateProjectIUnknown);
            }

            if (projectIUnknown == IntPtr.Zero)
                return VSConstants.E_FAIL;

            return VSConstants.S_OK;
        }

        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.PreCreateForOuter"]/*' />
        /// <devdoc>
        /// This function returns an instance of the project. This is just creating the object,
        /// VS will later call SetInner and InitializeForOuter to initialize it.
        /// </devdoc>
        /// <param name="outerProjectIUnknown"></param>
        /// <returns>The project subtype</returns>
        protected abstract object PreCreateForOuter(IntPtr outerProjectIUnknown);
        #endregion

        /// <include file='doc\FlavoredProjectFactoryBase.uex' path='docs/doc[@for="FlavoredProjectFactoryBase.ProjectTypeGuids"]/*' />
        protected virtual string ProjectTypeGuids(string file)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\Flavor\ProjectFactory.cs ===
/***************************************************************************
         Copyright (c) Microsoft Corporation, All rights reserved.             
    This code sample is provided "AS IS" without warranty of any kind, 
    it is not recommended for use in a production environment.
***************************************************************************/

namespace Microsoft.VisualStudio.Shell.Flavor
{
    using System;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell;


    /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory"]/*' />
    /// <devdoc>
    /// The project factory for the project flavor.
    /// Note that this is also known as Project Subtype
    /// </devdoc>
    [CLSCompliant(false)]
    public abstract class FlavoredProjectFactory : IVsAggregatableProjectFactory, IVsProjectFactory
    {
        private ServiceProvider _serviceProvider;
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.ServiceProvider"]/*' />
        protected ServiceProvider serviceProvider
        {
            get { return _serviceProvider; }
        }

        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.FlavoredProjectFactory"]/*' />
        public FlavoredProjectFactory()
        {
        }

        #region IVsProjectFactory

        int IVsProjectFactory.CanCreateProject(string fileName, uint flags, out int canCreate)
        {
            canCreate = this.CanCreateProject(fileName, flags) ? 1 : 0;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.CanCreateProject"]/*' />
        /// <devdoc>
        /// This is called to ask the factory if it can create a project based on the current parameters
        /// </devdoc>
        /// <returns>True if the project can be created</returns>
        protected virtual bool CanCreateProject(string fileName, uint flags)
        {
            // Validate the filename
            bool canCreate = !string.IsNullOrEmpty(fileName);
            canCreate |= !PackageUtilities.ContainsInvalidFileNameChars(fileName);
            return canCreate;
        }

        /// <devdoc>
        /// This is not expected to be called unless using an extension other then the base project
        /// </devdoc>
        int IVsProjectFactory.CreateProject(string fileName, string location, string name, uint flags, ref Guid projectGuid, out System.IntPtr project, out int canceled)
        {
            this.CreateProject(fileName, location, name, flags, ref projectGuid, out project, out canceled);
            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.CreateProject"]/*' />
        /// <devdoc>
        /// If you want to use your own extension, you will need to call IVsCreateAggregatedProject.CreateAggregatedProject()
        /// </devdoc>
        /// <returns>HRESULT</returns>
        protected virtual void CreateProject(string fileName, string location, string name, uint flags, ref Guid projectGuid, out System.IntPtr project, out int canceled)
        {
            // If the extension is that of the base project then we don't get called
            project = IntPtr.Zero;
            canceled = 0;
        }

        int IVsProjectFactory.Close()
        {
            this.Dispose(true);

            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.Dispose"]/*' />
        protected virtual void Dispose(bool disposing)
        {
            if (_serviceProvider != null)
            {
                _serviceProvider.Dispose();
                _serviceProvider = null;
            }
        }

        int IVsProjectFactory.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider provider)
        {
            // keep track of our service provider
            this._serviceProvider = new ServiceProvider(provider);

            this.Initialize();

            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.Initialize"]/*' />
        /// <devdoc>
        /// Called by SetSite after setting our service provider
        /// </devdoc>
        protected virtual void Initialize()
        {
        }

        #endregion

        #region IVsAggregatableProjectFactory

        int IVsAggregatableProjectFactory.GetAggregateProjectType(string fileName, out string projectTypeGuid)
        {
            projectTypeGuid = this.ProjectTypeGuids(fileName);
            return NativeMethods.S_OK;
        }

        int IVsAggregatableProjectFactory.PreCreateForOuter(object outerProject, out object project)
        {
            project = null;
            project = PreCreateForOuter(outerProject);

            if (!(project is FlavoredProject))
            {
                // We are not throwing in this case as someone could create 1 factory that support creating both
                // flavored project and full project. Also, someone could have implemented their flavored project
                // without using our base class. Never the less, if executing in the debugger, we should log this
                // to the output window.
                string warning = String.Format(CultureInfo.InvariantCulture, "Expected to recieve a FlavoredProject from PreCreateForOuter.\n Recieved a {0}", project.GetType().FullName);
                Trace.WriteLine(warning);
                // If you build your own version of this assembly and you intend to use FlavoredProject, uncomment
                // the following line as this will make any problem more obvious on debug builds
                //Debug.Fail(warning);
            }

            if (project == null)
                return NativeMethods.E_FAIL;

            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.PreCreateForOuter"]/*' />
        /// <devdoc>
        /// This function returns an instance of the project. This is just creating the object,
        /// VS will later call SetInner and InitializeForOuter to initialize it.
        /// </devdoc>
        /// <param name="outerProject"></param>
        /// <returns>The project subtype</returns>
        protected abstract object PreCreateForOuter(object outerProject);
        #endregion

        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.ProjectTypeGuids"]/*' />
        protected virtual string ProjectTypeGuids(string file)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\WindowPane.cs ===
//------------------------------------------------------------------------------
// <copyright file="WindowPane.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane"]' />
    /// <devdoc>
    ///     This is a quick way to implement a tool window pane.  This class 
    ///     implements IVsWindowPane; you must provide an implementation of an 
    ///     object that returns an IWin32Window, however.  In addition to 
    ///     IVsWindowPane this object implements IOleCommandTarget, mapping 
    ///     it to IMenuCommandService and IObjectWithSite, mapping the site 
    ///     to services that can be querried through its protected GetService 
    ///     method.
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class WindowPane : 

        IVsWindowPane,
        IOleCommandTarget,
        IVsBroadcastMessageEvents,
        IServiceProvider,
        IDisposable {

        private IServiceProvider        _parentProvider;
        private ServiceProvider         _provider;
        private IVsShell                _vsShell;
        private uint                    _broadcastEventCookie;

        private IMenuCommandService     _commandService;
        private HelpService             _helpService;

        private bool                    _zombie = false;

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.WindowPane"]' />
        /// <devdoc>
        ///     Creates a new window pane.  The window pane can accept a service provider
        ///     to use when resolving services.  This provider can be null.
        /// </devdoc>
        protected WindowPane(IServiceProvider provider) {
            _parentProvider = provider;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.Window"]' />
        /// <devdoc>
        ///     Retrieves the window associated with this window pane.
        /// </devdoc>
        public abstract IWin32Window Window { get; }
        
        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.Dispose"]' />
        /// <devdoc>
        ///     Can be called to dispose this editing window.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.Dispose1"]' />
        /// <devdoc>
        ///     Called when this window pane is being disposed.
        /// </devdoc>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        protected virtual void Dispose(bool disposing) {

            if (disposing) {

                if (_vsShell != null) {
                    try {
                        // Don't check for return code because here we can't do anything in case of failure.
                        _vsShell.UnadviseBroadcastMessages(_broadcastEventCookie);
                    } catch (Exception) { /* do nothing */ }
                    _vsShell = null;
                    _broadcastEventCookie = 0;
                }

                IWin32Window window = Window;
                if (window is IDisposable) {
                    try {
                    ((IDisposable)window).Dispose();
                    } catch (Exception) {
                        Debug.Fail("Failed to dispose window");
                    }
                }
                window = null;

                if (_commandService != null && _commandService is IDisposable) {
                    try {
                    ((IDisposable)_commandService).Dispose();
                    } catch (Exception) {
                        Debug.Fail("Failed to dispose command service");
                    }
                }
                _commandService = null;

                if (_parentProvider != null)
                    _parentProvider = null;

                if (_helpService != null)
                    _helpService = null;

                // Do not clear _provider.  SetSite will do it for us.

                _zombie = true;
            }
        }

        /// <devdoc>
        /// This is a separate method so the jitter doesn't see MenuCommandService (from system.design.dll) in
        /// the GetService call and load the assembly.
        /// </devdoc> 
        private void EnsureCommandService() {
            if (_commandService == null) {
                _commandService = new OleMenuCommandService(this);
            }
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.GetService"]' />
        /// <devdoc>
        ///     Maps to IServiceProvider for service routing.
        /// </devdoc>
        protected virtual object GetService(Type serviceType) {

            if (_zombie)
            {
                Debug.Fail("GetService called after WindowPane was zombied");
                return null;
            }

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            // We provide IMenuCommandService, so we will
            // demand create it.  MenuCommandService also
            // implements IOleCommandTarget, but unless
            // someone requested IMenuCommandService no commands
            // will exist, so we don't demand create for
            // IOleCommandTarget
            //
            if (serviceType == typeof(IMenuCommandService)) {
                EnsureCommandService();
                return _commandService;
            }
            else if (serviceType == typeof(IOleCommandTarget)) {
                return _commandService;
            }
            else if (serviceType == typeof(IHelpService)) {
                if (_helpService == null) {
                    _helpService = new HelpService(this);
                }
                return _helpService;
            }

            if (_provider != null) {
                object service = _provider.GetService(serviceType);
                if (service != null) {
                    return service;
                }
            }

            if (_parentProvider != null) {
                return _parentProvider.GetService(serviceType);
            }

            return null;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.Initialize"]' />
        /// <devdoc>
        ///     This method is called after the window pane has been sited.  Any initialization
        ///     that requires window frame services from VS can be done by overriding this
        ///     method.
        /// </devdoc>
        protected virtual void Initialize() {
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.OnClose"]/*' />
        /// <devdoc>
        ///     The OnClose method is called in response to the ClosePane method on
        ///     IVsWindowPane.  The default implementation calls Dispose();
        /// </devdoc>
        protected virtual void OnClose() {
            Dispose();
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.OnCreate"]/*' />
        /// <devdoc>
        ///     The OnCreate method is called during the CreatePaneWindow method of
        ///     IVsWindowPane.  This provides a handy hook for knowing when VS wants
        ///     the window.  The default implementation does nothing.
        /// </devdoc>
        protected virtual void OnCreate() {
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.PreProcessMessage"]' />
        /// <devdoc>
        ///     This method will be called to pre-process keyboard
        ///     messages before VS handles them.  It is directly
        ///     attached to IVsWindowPane::TranslateAccellerator.
        ///     The default implementation calls the PreProcessMessage
        ///     method on a Windows Forms control.  You may override this if your
        ///     window pane is not based on Windows Forms.
        ///     Arguments and return values are the
        ///     same as for Windows Forms:  return true if you handled
        ///     the message, false if you want the default processing
        ///     to occur.
        /// </devdoc>
        protected virtual bool PreProcessMessage(ref Message m) {
            Control c = Control.FromChildHandle(m.HWnd);
            if (c != null) {
                return c.PreProcessControlMessage(ref m) == PreProcessControlState.MessageProcessed;
            }
            else {
                return false;
            }
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IOleCommandTarget.Exec"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// This is called by Visual Studio when the user has requested to execute a particular
        /// command.  There is no need to override this method.  If you need access to menu
        /// commands use IMenuCommandService.
        /// </devdoc>
        int IOleCommandTarget.Exec(ref Guid guidGroup, uint nCmdId, uint nCmdExcept, IntPtr pIn, IntPtr vOut) {

            // Always redirect through GetService for this.  That way outside users can replace
            // it.
            //
            IOleCommandTarget cmdTarget = GetService(typeof(IOleCommandTarget)) as IOleCommandTarget;
            if (cmdTarget != null) {
                return cmdTarget.Exec(ref guidGroup, nCmdId, nCmdExcept, pIn, vOut);
            }
            else {
                return NativeMethods.OLECMDERR_E_NOTSUPPORTED;
            }
        }
        
        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IOleCommandTarget.QueryStatus"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// This is called by Visual Studio when it needs the status of our menu commands.  There
        /// is no need to override this method.  If you need access to menu commands use
        /// IMenuCommandService.
        /// </devdoc>
        int IOleCommandTarget.QueryStatus(ref Guid guidGroup, uint nCmdId, OLECMD[] oleCmd, IntPtr oleText) {

            // Always redirect through GetService for this.  That way outside users can replace
            // it.
            //
            IOleCommandTarget cmdTarget = GetService(typeof(IOleCommandTarget)) as IOleCommandTarget;
            if (cmdTarget != null) {
                return cmdTarget.QueryStatus(ref guidGroup, nCmdId, oleCmd, oleText);
            }
            else {
                return NativeMethods.OLECMDERR_E_NOTSUPPORTED;
            }
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IServiceProvider.GetService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IServiceProvider implementation.
        /// </devdoc>
        object IServiceProvider.GetService(Type serviceType) {
            return GetService(serviceType);
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsBroadcastMessageEvents.OnBroadcastMessage"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Receives broadcast messages from the shell
        /// </devdoc>
        int IVsBroadcastMessageEvents.OnBroadcastMessage(uint msg, IntPtr wParam, IntPtr lParam) {
            int hr = NativeMethods.S_OK;
            IntPtr hwnd = Window.Handle;
            bool result = UnsafeNativeMethods.PostMessage(hwnd, (int)msg, wParam, wParam);
            if ( !result )
                hr = NativeMethods.E_FAIL;
            return hr;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.ClosePane"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.ClosePane() {

            if (_vsShell != null) {
                NativeMethods.ThrowOnFailure(_vsShell.UnadviseBroadcastMessages(_broadcastEventCookie));
                _vsShell = null;
                _broadcastEventCookie = 0;
            }

            OnClose();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.CreatePaneWindow"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.CreatePaneWindow(IntPtr hwndParent, int   x, int   y, int   cx, int   cy, out IntPtr pane) {
            
            OnCreate();
            IntPtr hwnd = Window.Handle;
            int style = (int)UnsafeNativeMethods.GetWindowLong(hwnd, NativeMethods.GWL_STYLE);

            // set up the required styles of an IVsWindowPane
            style |= (NativeMethods.WS_CLIPSIBLINGS | NativeMethods.WS_CHILD | NativeMethods.WS_VISIBLE);
            style &= ~(NativeMethods.WS_POPUP |
                       NativeMethods.WS_MINIMIZE |
                       NativeMethods.WS_MAXIMIZE |
                       NativeMethods.WS_DLGFRAME |
                       NativeMethods.WS_SYSMENU |
                       NativeMethods.WS_THICKFRAME |
                       NativeMethods.WS_MINIMIZEBOX |
                       NativeMethods.WS_MAXIMIZEBOX);

            UnsafeNativeMethods.SetWindowLong(hwnd, NativeMethods.GWL_STYLE, (IntPtr)style);

            style = (int)UnsafeNativeMethods.GetWindowLong(hwnd, NativeMethods.GWL_EXSTYLE);

            style &= ~(NativeMethods.WS_EX_DLGMODALFRAME  |
                       NativeMethods.WS_EX_NOPARENTNOTIFY |
                       NativeMethods.WS_EX_TOPMOST        |
                       NativeMethods.WS_EX_MDICHILD       |
                       NativeMethods.WS_EX_TOOLWINDOW     |
                       NativeMethods.WS_EX_CONTEXTHELP    |
                       NativeMethods.WS_EX_APPWINDOW);

            UnsafeNativeMethods.SetWindowLong(hwnd, NativeMethods.GWL_EXSTYLE, (IntPtr)style);
            UnsafeNativeMethods.SetParent(hwnd, (IntPtr)hwndParent);
            UnsafeNativeMethods.SetWindowPos(hwnd, IntPtr.Zero, x, y, cx, cy, NativeMethods.SWP_NOZORDER | NativeMethods.SWP_NOACTIVATE);
            UnsafeNativeMethods.ShowWindow(hwnd, NativeMethods.SW_SHOWNORMAL);
            
            // Sync broadcast events so we update our UI when colors/fonts change.
            //
            if (_vsShell == null) {
                _vsShell = (IVsShell)GetService(typeof(SVsShell));
                if (_vsShell != null) {
                    NativeMethods.ThrowOnFailure(_vsShell.AdviseBroadcastMessages(this, out _broadcastEventCookie));
                }
            }
            
            pane = hwnd;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.GetDefaultSize"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.GetDefaultSize(SIZE[] size) {
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.LoadViewState(IStream pstream) {
            Marshal.ReleaseComObject(pstream);
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.SaveViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.SaveViewState(IStream pstream) {
            Marshal.ReleaseComObject(pstream);
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.SetSite"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.SetSite(IOleServiceProvider p) {

            // The siting mechanism works as follows:  If the
            // parent provider provides ServiceProviderHierarchy
            // as a service we will insert our service provider in
            // the WindowPaneSite slot of the hierarchy.
            // If, however, it does not provide
            // this service, we will create a new 
            // ServiceProvider that will be used to resolve
            // services through this site.  
            //
            if (_provider != null) {
                _provider.Dispose();
                _provider = null;
            }

            IObjectWithSite ows = GetService(typeof(IObjectWithSite)) as IObjectWithSite;
            ServiceProviderHierarchy serviceHierarchy = GetService(typeof(ServiceProviderHierarchy)) as ServiceProviderHierarchy;
            if (serviceHierarchy != null) {
                ServiceProvider sp = (p == null ? null : new ServiceProvider(p));
                serviceHierarchy[ServiceProviderHierarchyOrder.WindowPaneSite] = sp;             
            }
            else if (ows != null) {
               ows.SetSite(p);
            }
            else {
                if (p != null) {
                    _provider = new ServiceProvider(p);
                }
            }

            if (p != null) {
                Initialize();
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.TranslateAccelerator"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.TranslateAccelerator(Microsoft.VisualStudio.OLE.Interop.MSG[] msg) {
            Message m = Message.Create(msg[0].hwnd, (int)msg[0].message, msg[0].wParam, msg[0].lParam);
            bool eat = PreProcessMessage(ref m);

            msg[0].message = (uint)m.Msg;
            msg[0].wParam = m.WParam;
            msg[0].lParam = m.LParam;

            if (eat) {
                return NativeMethods.S_OK;
            }
            else {
                return NativeMethods.E_FAIL;
            }
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\Private\PackageRegistrationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="PackageRegistrationAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;
    using System.IO;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <devdoc>
    ///     This attribute is defined on a package to get it to be registered.  It
    ///     is internal because packages are meant to be registered, so it is
    ///     implicit just by having a package in the assembly.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited=true, AllowMultiple=false)]
    public sealed class PackageRegistrationAttribute : RegistrationAttribute
    {
        private RegistrationMethod registrationMethod = RegistrationMethod.Default;
        private bool useManagedResources = false;
        private string satellitePath = null;
        
        /// <devdoc>
        ///     Select between specifying the Codebase entry or the Assembly entry in the registry.
        ///     This can be overriden during registration
        /// </devdoc>
        public RegistrationMethod RegisterUsing
        {
            get
            {
                return registrationMethod;
            }
            set
            {
                registrationMethod = value;
            }
        }

        /// <summary>
        /// For managed resources, there should not be a native ui dll registered.
        /// </summary>
        public bool UseManagedResourcesOnly
        {
            get { return useManagedResources; }
            set { useManagedResources = value; }
        }

        /// <summary>
        /// To specify a resource dll located in a different location then the default,
        /// set this property. This can be useful if your package is installed in the GAC.
        /// If this is not set, the directory where the package is located will be use.
        /// 
        /// Note that the dll should be located at the following path:
        ///        SatellitePath\lcid\PackageDllNameUI.dll
        /// </summary>
        public string SatellitePath
        {
            get { return satellitePath; }
            set { satellitePath = value; }
        }

        private string RegKeyName(RegistrationContext context)
        {
            return String.Format(CultureInfo.InvariantCulture, "Packages\\{0}", context.ComponentType.GUID.ToString("B"));
        }

        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        /// <param name="context">
        ///     Contains the location where the registration inforomation should be placed.
        ///     It also contains other information such as the type being registered 
        ///     and path of the assembly.
        /// </param>
        public override void Register(RegistrationContext context) {
            Type t = context.ComponentType;
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyPackage, t.Name, t.GUID.ToString("B")));

            Key packageKey = null;
            try
            {
                packageKey = context.CreateKey(RegKeyName(context));

                //use a friendly description if it exists.
                DescriptionAttribute attr = TypeDescriptor.GetAttributes(t)[typeof(DescriptionAttribute)] as DescriptionAttribute;
                if (attr != null && !String.IsNullOrEmpty(attr.Description)) {
                    packageKey.SetValue(string.Empty, attr.Description);
                }
                else {
                    packageKey.SetValue(string.Empty, t.AssemblyQualifiedName);
                }

                packageKey.SetValue("InprocServer32", context.InprocServerPath);
                packageKey.SetValue("Class", t.FullName);

                // If specified on the command line, let the command line option override
                if (context.RegistrationMethod != RegistrationMethod.Default)
                {
                    registrationMethod = context.RegistrationMethod;
                }

                // Select registration method
                switch (registrationMethod)
                {
                    case RegistrationMethod.Assembly:
                    case RegistrationMethod.Default:
                        packageKey.SetValue("Assembly", t.Assembly.FullName);
                        break;

                    case RegistrationMethod.CodeBase:
                        packageKey.SetValue("CodeBase", context.CodeBase);
                        break;
                }

                Key childKey = null;
                if (!useManagedResources)
                {
                    try
                    {
                        childKey = packageKey.CreateSubkey("SatelliteDll");

                        // Register the satellite dll
                        string satelliteDllPath;
                        if (SatellitePath != null)
                        {
                            // Use provided path
                            satelliteDllPath = context.EscapePath(SatellitePath);
                        }
                        else
                        {
                            // Default to package path
                            satelliteDllPath = context.ComponentPath;
                        }
                        childKey.SetValue("Path", satelliteDllPath);
                        childKey.SetValue("DllName", String.Format(CultureInfo.InvariantCulture, "{0}UI.dll", Path.GetFileNameWithoutExtension(t.Assembly.ManifestModule.Name)));
                    }
                    finally
                    {
                        if (childKey != null)
                            childKey.Close();
                    }
                }
            }
            finally
            {
                if (packageKey != null)
                    packageKey.Close();
            }
        }

        /// <devdoc>
        ///     Unregister this package.
        /// </devdoc>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context) 
        {
            context.RemoveKey(RegKeyName(context));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\VSConstants.cs ===
//------------------------------------------------------------------------------
// <copyright file="VSConstants.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio {

    using System;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.TextManager.Interop;
    using Microsoft.VisualStudio.OLE.Interop;



    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants"]/*' />
    [CLSCompliant(false)]
    public sealed class VSConstants {

        private VSConstants() { }

        // VS Command ID's

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.cmdidToolsOptions"]/*' />
        public const int cmdidToolsOptions = 264;

        /// Common OLE GUIDs
        /// <include file='doc\VSContants.uex' path='docs/doc[@for="VSConstants.IID_IUnknown"]/*' />
        public static readonly Guid IID_IUnknown = new Guid("{00000000-0000-0000-C000-000000000046}");


        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VSStandardCommandSet97"]/*' />
        /// <summary>This GUID identifies the standard set of commands known by VisualStudio 97 (version 6).</summary>
        public static readonly Guid GUID_VSStandardCommandSet97 = new Guid("{5EFC7975-14BC-11CF-9B2B-00AA00573819}");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSStd97CmdID"]/*' />
        [Guid("5EFC7975-14BC-11CF-9B2B-00AA00573819")]
        public enum VSStd97CmdID
        {
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignBottom"]/*' />
            AlignBottom = 1,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignHorizontalCenters"]/*' />
            AlignHorizontalCenters = 2,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignLeft"]/*' />
            AlignLeft = 3,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignRight"]/*' />
            AlignRight = 4,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignToGrid"]/*' />
            AlignToGrid = 5,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignTop"]/*' />
            AlignTop = 6,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignVerticalCenters"]/*' />
            AlignVerticalCenters = 7,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ArrangeBottom"]/*' />
            ArrangeBottom = 8,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ArrangeRight"]/*' />
            ArrangeRight = 9,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BringForward"]/*' />
            BringForward = 10,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BringToFront"]/*' />
            BringToFront = 11,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CenterHorizontally"]/*' />
            CenterHorizontally = 12,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CenterVertically"]/*' />
            CenterVertically = 13,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Code"]/*' />
            Code = 14,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Copy"]/*' />
            Copy = 15,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Cut"]/*' />
            Cut = 16,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Delete"]/*' />
            Delete = 17,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FontName"]/*' />
            FontName = 18,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FontNameGetList"]/*' />
            FontNameGetList = 500,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FontSize"]/*' />
            FontSize = 19,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FontSizeGetList"]/*' />
            FontSizeGetList = 501,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Group"]/*' />
            Group = 20,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HorizSpaceConcatenate"]/*' />
            HorizSpaceConcatenate = 21,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HorizSpaceDecrease"]/*' />
            HorizSpaceDecrease = 22,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HorizSpaceIncrease"]/*' />
            HorizSpaceIncrease = 23,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HorizSpaceMakeEqual"]/*' />
            HorizSpaceMakeEqual = 24,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.LockControls"]/*' />
            LockControls = 369,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InsertObject"]/*' />
            InsertObject = 25,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Paste"]/*' />
            Paste = 26,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Print"]/*' />
            Print = 27,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Properties"]/*' />
            Properties = 28,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Redo"]/*' />
            Redo = 29,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MultiLevelRedo"]/*' />
            MultiLevelRedo = 30,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SelectAll"]/*' />
            SelectAll = 31,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SendBackward"]/*' />
            SendBackward = 32,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SendToBack"]/*' />
            SendToBack = 33,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowTable"]/*' />
            ShowTable = 34,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SizeToControl"]/*' />
            SizeToControl = 35,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SizeToControlHeight"]/*' />
            SizeToControlHeight = 36,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SizeToControlWidth"]/*' />
            SizeToControlWidth = 37,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SizeToFit"]/*' />
            SizeToFit = 38,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SizeToGrid"]/*' />
            SizeToGrid = 39,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SnapToGrid"]/*' />
            SnapToGrid = 40,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TabOrder"]/*' />
            TabOrder = 41,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Toolbox"]/*' />
            Toolbox = 42,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Undo"]/*' />
            Undo = 43,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MultiLevelUndo"]/*' />
            MultiLevelUndo = 44,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Ungroup"]/*' />
            Ungroup = 45,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VertSpaceConcatenate"]/*' />
            VertSpaceConcatenate = 46,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VertSpaceDecrease"]/*' />
            VertSpaceDecrease = 47,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VertSpaceIncrease"]/*' />
            VertSpaceIncrease = 48,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VertSpaceMakeEqual"]/*' />
            VertSpaceMakeEqual = 49,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ZoomPercent"]/*' />
            ZoomPercent = 50,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BackColor"]/*' />
            BackColor = 51,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Bold"]/*' />
            Bold = 52,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderColor"]/*' />
            BorderColor = 53,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderDashDot"]/*' />
            BorderDashDot = 54,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderDashDotDot"]/*' />
            BorderDashDotDot = 55,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderDashes"]/*' />
            BorderDashes = 56,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderDots"]/*' />
            BorderDots = 57,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderShortDashes"]/*' />
            BorderShortDashes = 58,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderSolid"]/*' />
            BorderSolid = 59,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderSparseDots"]/*' />
            BorderSparseDots = 60,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidth1"]/*' />
            BorderWidth1 = 61,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidth2"]/*' />
            BorderWidth2 = 62,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidth3"]/*' />
            BorderWidth3 = 63,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidth4"]/*' />
            BorderWidth4 = 64,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidth5"]/*' />
            BorderWidth5 = 65,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidth6"]/*' />
            BorderWidth6 = 66,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidthHairline"]/*' />
            BorderWidthHairline = 67,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Flat"]/*' />
            Flat = 68,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ForeColor"]/*' />
            ForeColor = 69,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Italic"]/*' />
            Italic = 70,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.JustifyCenter"]/*' />
            JustifyCenter = 71,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.JustifyGeneral"]/*' />
            JustifyGeneral = 72,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.JustifyLeft"]/*' />
            JustifyLeft = 73,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.JustifyRight"]/*' />
            JustifyRight = 74,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Raised"]/*' />
            Raised = 75,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Sunken"]/*' />
            Sunken = 76,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Underline"]/*' />
            Underline = 77,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Chiseled"]/*' />
            Chiseled = 78,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Etched"]/*' />
            Etched = 79,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Shadowed"]/*' />
            Shadowed = 80,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug1"]/*' />
            CompDebug1 = 81,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug2"]/*' />
            CompDebug2 = 82,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug3"]/*' />
            CompDebug3 = 83,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug4"]/*' />
            CompDebug4 = 84,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug5"]/*' />
            CompDebug5 = 85,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug6"]/*' />
            CompDebug6 = 86,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug7"]/*' />
            CompDebug7 = 87,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug8"]/*' />
            CompDebug8 = 88,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug9"]/*' />
            CompDebug9 = 89,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug10"]/*' />
            CompDebug10 = 90,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug11"]/*' />
            CompDebug11 = 91,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug12"]/*' />
            CompDebug12 = 92,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug13"]/*' />
            CompDebug13 = 93,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug14"]/*' />
            CompDebug14 = 94,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug15"]/*' />
            CompDebug15 = 95,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExistingSchemaEdit"]/*' />
            ExistingSchemaEdit = 96,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Find"]/*' />
            Find = 97,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GetZoom"]/*' />
            GetZoom = 98,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.QueryOpenDesign"]/*' />
            QueryOpenDesign = 99,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.QueryOpenNew"]/*' />
            QueryOpenNew = 100,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SingleTableDesign"]/*' />
            SingleTableDesign = 101,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SingleTableNew"]/*' />
            SingleTableNew = 102,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowGrid"]/*' />
            ShowGrid = 103,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewTable"]/*' />
            NewTable = 104,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CollapsedView"]/*' />
            CollapsedView = 105,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FieldView"]/*' />
            FieldView = 106,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VerifySQL"]/*' />
            VerifySQL = 107,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HideTable"]/*' />
            HideTable = 108,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PrimaryKey"]/*' />
            PrimaryKey = 109,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Save"]/*' />
            Save = 110,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveAs"]/*' />
            SaveAs = 111,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SortAscending"]/*' />
            SortAscending = 112,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SortDescending"]/*' />
            SortDescending = 113,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AppendQuery"]/*' />
            AppendQuery = 114,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CrosstabQuery"]/*' />
            CrosstabQuery = 115,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeleteQuery"]/*' />
            DeleteQuery = 116,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MakeTableQuery"]/*' />
            MakeTableQuery = 117,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SelectQuery"]/*' />
            SelectQuery = 118,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.UpdateQuery"]/*' />
            UpdateQuery = 119,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Parameters"]/*' />
            Parameters = 120,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Totals"]/*' />
            Totals = 121,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewCollapsed"]/*' />
            ViewCollapsed = 122,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewFieldList"]/*' />
            ViewFieldList = 123,


            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewKeys"]/*' />
            ViewKeys = 124,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewGrid"]/*' />
            ViewGrid = 125,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InnerJoin"]/*' />
            InnerJoin = 126,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RightOuterJoin"]/*' />
            RightOuterJoin = 127,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.LeftOuterJoin"]/*' />
            LeftOuterJoin = 128,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FullOuterJoin"]/*' />
            FullOuterJoin = 129,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.UnionJoin"]/*' />
            UnionJoin = 130,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowSQLPane"]/*' />
            ShowSQLPane = 131,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowGraphicalPane"]/*' />
            ShowGraphicalPane = 132,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowDataPane"]/*' />
            ShowDataPane = 133,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowQBEPane"]/*' />
            ShowQBEPane = 134,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SelectAllFields"]/*' />
            SelectAllFields = 135,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OLEObjectMenuButton"]/*' />
            OLEObjectMenuButton = 136,

            // ids on the ole verbs menu - these must be sequential ie verblist0-verblist9
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList0"]/*' />
            ObjectVerbList0 = 137,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList1"]/*' />
            ObjectVerbList1 = 138,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList2"]/*' />
            ObjectVerbList2 = 139,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList3"]/*' />
            ObjectVerbList3 = 140,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList4"]/*' />
            ObjectVerbList4 = 141,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList5"]/*' />
            ObjectVerbList5 = 142,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList6"]/*' />
            ObjectVerbList6 = 143,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList7"]/*' />
            ObjectVerbList7 = 144,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList8"]/*' />
            ObjectVerbList8 = 145,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList9"]/*' />
            ObjectVerbList9 = 146,  // Unused on purpose!

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ConvertObject"]/*' />
            ConvertObject = 147,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CustomControl"]/*' />
            CustomControl = 148,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CustomizeItem"]/*' />
            CustomizeItem = 149,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rename"]/*' />
            Rename = 150,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Import"]/*' />
            Import = 151,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewPage"]/*' />
            NewPage = 152,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Move"]/*' />
            Move = 153,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Cancel"]/*' />
            Cancel = 154,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Font"]/*' />
            Font = 155,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExpandLinks"]/*' />
            ExpandLinks = 156,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExpandImages"]/*' />
            ExpandImages = 157,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExpandPages"]/*' />
            ExpandPages = 158,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RefocusDiagram"]/*' />
            RefocusDiagram = 159,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TransitiveClosure"]/*' />
            TransitiveClosure = 160,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CenterDiagram"]/*' />
            CenterDiagram = 161,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ZoomIn"]/*' />
            ZoomIn = 162,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ZoomOut"]/*' />
            ZoomOut = 163,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RemoveFilter"]/*' />
            RemoveFilter = 164,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HidePane"]/*' />
            HidePane = 165,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeleteTable"]/*' />
            DeleteTable = 166,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeleteRelationship"]/*' />
            DeleteRelationship = 167,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Remove"]/*' />
            Remove = 168,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.JoinLeftAll"]/*' />
            JoinLeftAll = 169,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.JoinRightAll"]/*' />
            JoinRightAll = 170,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddToOutput"]/*' />
            AddToOutput = 171,      // Add selected fields to query output
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OtherQuery"]/*' />
            OtherQuery = 172,      // change query type to 'other'
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GenerateChangeScript"]/*' />
            GenerateChangeScript = 173,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveSelection"]/*' />
            SaveSelection = 174,     // Save current selection
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutojoinCurrent"]/*' />
            AutojoinCurrent = 175,     // Autojoin current tables
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutojoinAlways"]/*' />
            AutojoinAlways = 176,     // Toggle Autojoin state
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditPage"]/*' />
            EditPage = 177,     // Launch editor for url
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewLinks"]/*' />
            ViewLinks = 178,     // Launch new webscope for url
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Stop"]/*' />
            Stop = 179,     // Stope webscope rendering
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Pause"]/*' />
            Pause = 180,     // Pause webscope rendering
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Resume"]/*' />
            Resume = 181,     // Resume webscope rendering
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FilterDiagram"]/*' />
            FilterDiagram = 182,     // Filter webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowAllObjects"]/*' />
            ShowAllObjects = 183,     // Show All objects in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowApplications"]/*' />
            ShowApplications = 184,     // Show Application objects in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowOtherObjects"]/*' />
            ShowOtherObjects = 185,     // Show other objects in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowPrimRelationships"]/*' />
            ShowPrimRelationships = 186,     // Show primary relationships
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Expand"]/*' />
            Expand = 187,     // Expand links
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Collapse"]/*' />
            Collapse = 188,     // Collapse links
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Refresh"]/*' />
            Refresh = 189,     // Refresh Webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Layout"]/*' />
            Layout = 190,     // Layout websope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowResources"]/*' />
            ShowResources = 191,     // Show resouce objects in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InsertHTMLWizard"]/*' />
            InsertHTMLWizard = 192,     // Insert HTML using a Wizard
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowDownloads"]/*' />
            ShowDownloads = 193,     // Show download objects in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowExternals"]/*' />
            ShowExternals = 194,     // Show external objects in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowInBoundLinks"]/*' />
            ShowInBoundLinks = 195,     // Show inbound links in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowOutBoundLinks"]/*' />
            ShowOutBoundLinks = 196,     // Show out bound links in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowInAndOutBoundLinks"]/*' />
            ShowInAndOutBoundLinks = 197,     // Show in and out bound links in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Preview"]/*' />
            Preview = 198,     // Preview page
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Open"]/*' />
            Open = 261,     // Open
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenWith"]/*' />
            OpenWith = 199,     // Open with
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowPages"]/*' />
            ShowPages = 200,     // Show HTML pages
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RunQuery"]/*' />
            RunQuery = 201,      // Runs a query
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ClearQuery"]/*' />
            ClearQuery = 202,      // Clears the query's associated cursor
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RecordFirst"]/*' />
            RecordFirst = 203,      // Go to first record in set
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RecordLast"]/*' />
            RecordLast = 204,      // Go to last record in set
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RecordNext"]/*' />
            RecordNext = 205,      // Go to next record in set
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RecordPrevious"]/*' />
            RecordPrevious = 206,      // Go to previous record in set
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RecordGoto"]/*' />
            RecordGoto = 207,      // Go to record via dialog
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RecordNew"]/*' />
            RecordNew = 208,      // Add a record to set

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InsertNewMenu"]/*' />
            InsertNewMenu = 209,     // menu designer
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InsertSeparator"]/*' />
            InsertSeparator = 210,     // menu designer
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditMenuNames"]/*' />
            EditMenuNames = 211,     // menu designer

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DebugExplorer"]/*' />
            DebugExplorer = 212,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DebugProcesses"]/*' />
            DebugProcesses = 213,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewThreadsWindow"]/*' />
            ViewThreadsWindow = 214,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WindowUIList"]/*' />
            WindowUIList = 215,

            // ids on the file menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewProject"]/*' />
            NewProject = 216,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenProject"]/*' />
            OpenProject = 217,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenProjectFromWeb"]/*' />
            OpenProjectFromWeb = 450,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenSolution"]/*' />
            OpenSolution = 218,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CloseSolution"]/*' />
            CloseSolution = 219,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FileNew"]/*' />
            FileNew = 221,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewProjectFromExisting"]/*' />
            NewProjectFromExisting = 385,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FileOpen"]/*' />
            FileOpen = 222,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FileOpenFromWeb"]/*' />
            FileOpenFromWeb = 451,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FileClose"]/*' />
            FileClose = 223,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveSolution"]/*' />
            SaveSolution = 224,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveSolutionAs"]/*' />
            SaveSolutionAs = 225,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveProjectItemAs"]/*' />
            SaveProjectItemAs = 226,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PageSetup"]/*' />
            PageSetup = 227,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PrintPreview"]/*' />
            PrintPreview = 228,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Exit"]/*' />
            Exit = 229,

            // ids on the edit menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Replace"]/*' />
            Replace = 230,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Goto"]/*' />
            Goto = 231,

            // ids on the view menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PropertyPages"]/*' />
            PropertyPages = 232,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FullScreen"]/*' />
            FullScreen = 233,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ProjectExplorer"]/*' />
            ProjectExplorer = 234,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PropertiesWindow"]/*' />
            PropertiesWindow = 235,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListWindow"]/*' />
            TaskListWindow = 236,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OutputWindow"]/*' />
            OutputWindow = 237,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectBrowser"]/*' />
            ObjectBrowser = 238,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DocOutlineWindow"]/*' />
            DocOutlineWindow = 239,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ImmediateWindow"]/*' />
            ImmediateWindow = 240,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WatchWindow"]/*' />
            WatchWindow = 241,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.LocalsWindow"]/*' />
            LocalsWindow = 242,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CallStack"]/*' />
            CallStack = 243,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutosWindow"]/*' />
            AutosWindow = DebugReserved1,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ThisWindow"]/*' />
            ThisWindow = DebugReserved2,

            // ids on project menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddNewItem"]/*' />
            AddNewItem = 220,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddExistingItem"]/*' />
            AddExistingItem = 244,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewFolder"]/*' />
            NewFolder = 245,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SetStartupProject"]/*' />
            SetStartupProject = 246,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ProjectSettings"]/*' />
            ProjectSettings = 247,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ProjectReferences"]/*' />
            ProjectReferences = 367,

            // ids on the debug menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.StepInto"]/*' />
            StepInto = 248,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.StepOver"]/*' />
            StepOver = 249,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.StepOut"]/*' />
            StepOut = 250,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RunToCursor"]/*' />
            RunToCursor = 251,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddWatch"]/*' />
            AddWatch = 252,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditWatch"]/*' />
            EditWatch = 253,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.QuickWatch"]/*' />
            QuickWatch = 254,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToggleBreakpoint"]/*' />
            ToggleBreakpoint = 255,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ClearBreakpoints"]/*' />
            ClearBreakpoints = 256,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowBreakpoints"]/*' />
            ShowBreakpoints = 257,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SetNextStatement"]/*' />
            SetNextStatement = 258,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowNextStatement"]/*' />
            ShowNextStatement = 259,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditBreakpoint"]/*' />
            EditBreakpoint = 260,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DetachDebugger"]/*' />
            DetachDebugger = 262,

            // ids on the tools menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CustomizeKeyboard"]/*' />
            CustomizeKeyboard = 263,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolsOptions"]/*' />
            ToolsOptions = 264,

            // ids on the windows menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewWindow"]/*' />
            NewWindow = 265,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Split"]/*' />
            Split = 266,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Cascade"]/*' />
            Cascade = 267,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TileHorz"]/*' />
            TileHorz = 268,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TileVert"]/*' />
            TileVert = 269,

            // ids on the help menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TechSupport"]/*' />
            TechSupport = 270,

            // NOTE cmdidAbout and cmdidDebugOptions must be consecutive
            //      cmd after cmdidDebugOptions (ie 273) must not be used
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.About"]/*' />
            About = 271,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DebugOptions"]/*' />
            DebugOptions = 272,

            // ids on the watch context menu
            // CollapseWatch appears as 'Collapse Parent', on any
            // non-top-level item
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeleteWatch"]/*' />
            DeleteWatch = 274,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CollapseWatch"]/*' />
            CollapseWatch = 275,
            // ids 276, 277, 278, 279, 280 are in use
            // below 
            // ids on the property browser context menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PbrsToggleStatus"]/*' />
            PbrsToggleStatus = 282,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PropbrsHide"]/*' />
            PropbrsHide = 283,

            // ids on the docking context menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DockingView"]/*' />
            DockingView = 284,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HideActivePane"]/*' />
            HideActivePane = 285,
            // ids for window selection via keyboard
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PaneNextPane"]/*' />
            PaneNextPane = 316,  //(listed below in order)
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PanePrevPane"]/*' />
            PanePrevPane = 317,  //(listed below in order)
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PaneNextTab"]/*' />
            PaneNextTab = 286,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PanePrevTab"]/*' />
            PanePrevTab = 287,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PaneCloseToolWindow"]/*' />
            PaneCloseToolWindow = 288,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PaneActivateDocWindow"]/*' />
            PaneActivateDocWindow = 289,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DockingViewMDI"]/*' />
            DockingViewMDI = 290,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DockingViewFloater"]/*' />
            DockingViewFloater = 291,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideWindow"]/*' />
            AutoHideWindow = 292,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveToDropdownBar"]/*' />
            MoveToDropdownBar = 293,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindCmd"]/*' />
            FindCmd = 294,  // internal Find commands
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Start"]/*' />
            Start = 295,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Restart"]/*' />
            Restart = 296,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddinManager"]/*' />
            AddinManager = 297,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MultiLevelUndoList"]/*' />
            MultiLevelUndoList = 298,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MultiLevelRedoList"]/*' />
            MultiLevelRedoList = 299,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxAddTab"]/*' />
            ToolboxAddTab = 300,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxDeleteTab"]/*' />
            ToolboxDeleteTab = 301,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxRenameTab"]/*' />
            ToolboxRenameTab = 302,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxTabMoveUp"]/*' />
            ToolboxTabMoveUp = 303,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxTabMoveDown"]/*' />
            ToolboxTabMoveDown = 304,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxRenameItem"]/*' />
            ToolboxRenameItem = 305,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxListView"]/*' />
            ToolboxListView = 306,
            //(below) cmdidSearchSetCombo        307

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WindowUIGetList"]/*' />
            WindowUIGetList = 308,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InsertValuesQuery"]/*' />
            InsertValuesQuery = 309,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowProperties"]/*' />
            ShowProperties = 310,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ThreadSuspend"]/*' />
            ThreadSuspend = 311,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ThreadResume"]/*' />
            ThreadResume = 312,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ThreadSetFocus"]/*' />
            ThreadSetFocus = 313,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DisplayRadix"]/*' />
            DisplayRadix = 314,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenProjectItem"]/*' />
            OpenProjectItem = 315,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ClearPane"]/*' />
            ClearPane = 318,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GotoErrorTag"]/*' />
            GotoErrorTag = 319,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListSortByCategory"]/*' />
            TaskListSortByCategory = 320,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListSortByFileLine"]/*' />
            TaskListSortByFileLine = 321,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListSortByPriority"]/*' />
            TaskListSortByPriority = 322,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListSortByDefaultSort"]/*' />
            TaskListSortByDefaultSort = 323,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListShowTooltip"]/*' />
            TaskListShowTooltip = 324,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByNothing"]/*' />
            TaskListFilterByNothing = 325,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CancelEZDrag"]/*' />
            CancelEZDrag = 326,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByCategoryCompiler"]/*' />
            TaskListFilterByCategoryCompiler = 327,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByCategoryComment"]/*' />
            TaskListFilterByCategoryComment = 328,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxAddItem"]/*' />
            ToolboxAddItem = 329,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxReset"]/*' />
            ToolboxReset = 330,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveProjectItem"]/*' />
            SaveProjectItem = 331,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveOptions"]/*' />
            SaveOptions = 959,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewForm"]/*' />
            ViewForm = 332,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewCode"]/*' />
            ViewCode = 333,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PreviewInBrowser"]/*' />
            PreviewInBrowser = 334,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BrowseWith"]/*' />
            BrowseWith = 336,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SearchSetCombo"]/*' />
            SearchSetCombo = 307,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SearchCombo"]/*' />
            SearchCombo = 337,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditLabel"]/*' />
            EditLabel = 338,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Exceptions"]/*' />
            Exceptions = 339,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DefineViews"]/*' />
            DefineViews = 340,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToggleSelMode"]/*' />
            ToggleSelMode = 341,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToggleInsMode"]/*' />
            ToggleInsMode = 342,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.LoadUnloadedProject"]/*' />
            LoadUnloadedProject = 343,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.UnloadLoadedProject"]/*' />
            UnloadLoadedProject = 344,

            // ids on the treegrids (watch/local/threads/stack)
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ElasticColumn"]/*' />
            ElasticColumn = 345,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HideColumn"]/*' />
            HideColumn = 346,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListPreviousView"]/*' />
            TaskListPreviousView = 347,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ZoomDialog"]/*' />
            ZoomDialog = 348,

            // find/replace options
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindHiddenText"]/*' />
            FindHiddenText = 349,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindMatchCase"]/*' />
            FindMatchCase = 350,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindWholeWord"]/*' />
            FindWholeWord = 351,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindSimplePattern"]/*' />
            FindSimplePattern = 276,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindRegularExpression"]/*' />
            FindRegularExpression = 352,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindBackwards"]/*' />
            FindBackwards = 353,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindInSelection"]/*' />
            FindInSelection = 354,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindStop"]/*' />
            FindStop = 355,
            // UNUSED                               356
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindInFiles"]/*' />
            FindInFiles = 277,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ReplaceInFiles"]/*' />
            ReplaceInFiles = 278,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NextLocation"]/*' />
            NextLocation = 279,  // next item in task list, find in files results, etc.
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PreviousLocation"]/*' />
            PreviousLocation = 280,  // prev item "
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GotoQuick"]/*' />
            GotoQuick = 281,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListNextError"]/*' />
            TaskListNextError = 357,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListPrevError"]/*' />
            TaskListPrevError = 358,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByCategoryUser"]/*' />
            TaskListFilterByCategoryUser = 359,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByCategoryShortcut"]/*' />
            TaskListFilterByCategoryShortcut = 360,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByCategoryHTML"]/*' />
            TaskListFilterByCategoryHTML = 361,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByCurrentFile"]/*' />
            TaskListFilterByCurrentFile = 362,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByChecked"]/*' />
            TaskListFilterByChecked = 363,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByUnchecked"]/*' />
            TaskListFilterByUnchecked = 364,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListSortByDescription"]/*' />
            TaskListSortByDescription = 365,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListSortByChecked"]/*' />
            TaskListSortByChecked = 366,

            // 367 is used above in cmdidProjectReferences
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.StartNoDebug"]/*' />
            StartNoDebug = 368,
            // 369 is used above in cmdidLockControls

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindNext"]/*' />
            FindNext = 370,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindPrev"]/*' />
            FindPrev = 371,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindSelectedNext"]/*' />
            FindSelectedNext = 372,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindSelectedPrev"]/*' />
            FindSelectedPrev = 373,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SearchGetList"]/*' />
            SearchGetList = 374,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InsertBreakpoint"]/*' />
            InsertBreakpoint = 375,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EnableBreakpoint"]/*' />
            EnableBreakpoint = 376,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.F1Help"]/*' />
            F1Help = 377,

            //UNUSED 378-396

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveToNextEZCntr"]/*' />
            MoveToNextEZCntr = 384,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.UpdateMarkerSpans"]/*' />
            UpdateMarkerSpans = 386,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveToPreviousEZCntr"]/*' />
            MoveToPreviousEZCntr = 393,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ProjectProperties"]/*' />
            ProjectProperties = 396,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PropSheetOrProperties"]/*' />
            PropSheetOrProperties = 397,

            // NOTE - the next items are debug only !!
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TshellStep"]/*' />
            TshellStep = 398,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TshellRun"]/*' />
            TshellRun = 399,

            // marker commands on the codewin menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd0"]/*' />
            MarkerCmd0 = 400,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd1"]/*' />
            MarkerCmd1 = 401,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd2"]/*' />
            MarkerCmd2 = 402,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd3"]/*' />
            MarkerCmd3 = 403,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd4"]/*' />
            MarkerCmd4 = 404,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd5"]/*' />
            MarkerCmd5 = 405,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd6"]/*' />
            MarkerCmd6 = 406,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd7"]/*' />
            MarkerCmd7 = 407,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd8"]/*' />
            MarkerCmd8 = 408,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd9"]/*' />
            MarkerCmd9 = 409,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerLast"]/*' />
            MarkerLast = 409,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerEnd"]/*' />
            MarkerEnd = 410,  // list terminator reserved

            // user-invoked project reload and unload
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ReloadProject"]/*' />
            ReloadProject = 412,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.UnloadProject"]/*' />
            UnloadProject = 413,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewBlankSolution"]/*' />
            NewBlankSolution = 414,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SelectProjectTemplate"]/*' />
            SelectProjectTemplate = 415,

            // document outline commands
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DetachAttachOutline"]/*' />
            DetachAttachOutline = 420,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowHideOutline"]/*' />
            ShowHideOutline = 421,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SyncOutline"]/*' />
            SyncOutline = 422,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RunToCallstCursor"]/*' />
            RunToCallstCursor = 423,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NoCmdsAvailable"]/*' />
            NoCmdsAvailable = 424,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ContextWindow"]/*' />
            ContextWindow = 427,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Alias"]/*' />
            Alias = 428,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GotoCommandLine"]/*' />
            GotoCommandLine = 429,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EvaluateExpression"]/*' />
            EvaluateExpression = 430,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ImmediateMode"]/*' />
            ImmediateMode = 431,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EvaluateStatement"]/*' />
            EvaluateStatement = 432,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindResultWindow1"]/*' />
            FindResultWindow1 = 433,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindResultWindow2"]/*' />
            FindResultWindow2 = 434,

            // 500 is used above in cmdidFontNameGetList
            // 501 is used above in cmdidFontSizeGetList

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RenameBookmark"]/*' />
            RenameBookmark = 559,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToggleBookmark"]/*' />
            ToggleBookmark = 560,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeleteBookmark"]/*' />
            DeleteBookmark = 561,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BookmarkWindowGoToBookmark"]/*' />
            BookmarkWindowGoToBookmark = 562,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EnableBookmark"]/*' />
            EnableBookmark = 564,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewBookmarkFolder"]/*' />
            NewBookmarkFolder = 565,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NextBookmarkFolder"]/*' />
            NextBookmarkFolder = 568,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PrevBookmarkFolder"]/*' />
            PrevBookmarkFolder = 569,

            // ids on the window menu - these must be sequential ie window1-morewind
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window1"]/*' />
            Window1 = 570,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window2"]/*' />
            Window2 = 571,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window3"]/*' />
            Window3 = 572,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window4"]/*' />
            Window4 = 573,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window5"]/*' />
            Window5 = 574,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window6"]/*' />
            Window6 = 575,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window7"]/*' />
            Window7 = 576,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window8"]/*' />
            Window8 = 577,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window9"]/*' />
            Window9 = 578,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window10"]/*' />
            Window10 = 579,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window11"]/*' />
            Window11 = 580,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window12"]/*' />
            Window12 = 581,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window13"]/*' />
            Window13 = 582,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window14"]/*' />
            Window14 = 583,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window15"]/*' />
            Window15 = 584,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window16"]/*' />
            Window16 = 585,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window17"]/*' />
            Window17 = 586,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window18"]/*' />
            Window18 = 587,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window19"]/*' />
            Window19 = 588,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window20"]/*' />
            Window20 = 589,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window21"]/*' />
            Window21 = 590,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window22"]/*' />
            Window22 = 591,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window23"]/*' />
            Window23 = 592,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window24"]/*' />
            Window24 = 593,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window25"]/*' />
            Window25 = 594,    // note cmdidWindow25 is unused on purpose!
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoreWindows"]/*' />
            MoreWindows = 595,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideAllWindows"]/*' />
            AutoHideAllWindows = 597,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListTaskHelp"]/*' />
            TaskListTaskHelp = 598,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ClassView"]/*' />
            ClassView = 599,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj1"]/*' />
            MRUProj1 = 600,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj2"]/*' />
            MRUProj2 = 601,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj3"]/*' />
            MRUProj3 = 602,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj4"]/*' />
            MRUProj4 = 603,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj5"]/*' />
            MRUProj5 = 604,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj6"]/*' />
            MRUProj6 = 605,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj7"]/*' />
            MRUProj7 = 606,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj8"]/*' />
            MRUProj8 = 607,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj9"]/*' />
            MRUProj9 = 608,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj10"]/*' />
            MRUProj10 = 609,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj11"]/*' />
            MRUProj11 = 610,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj12"]/*' />
            MRUProj12 = 611,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj13"]/*' />
            MRUProj13 = 612,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj14"]/*' />
            MRUProj14 = 613,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj15"]/*' />
            MRUProj15 = 614,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj16"]/*' />
            MRUProj16 = 615,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj17"]/*' />
            MRUProj17 = 616,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj18"]/*' />
            MRUProj18 = 617,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj19"]/*' />
            MRUProj19 = 618,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj20"]/*' />
            MRUProj20 = 619,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj21"]/*' />
            MRUProj21 = 620,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj22"]/*' />
            MRUProj22 = 621,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj23"]/*' />
            MRUProj23 = 622,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj24"]/*' />
            MRUProj24 = 623,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj25"]/*' />
            MRUProj25 = 624,   // note cmdidMRUProj25 is unused on purpose!

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SplitNext"]/*' />
            SplitNext = 625,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SplitPrev"]/*' />
            SplitPrev = 626,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CloseAllDocuments"]/*' />
            CloseAllDocuments = 627,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NextDocument"]/*' />
            NextDocument = 628,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PrevDocument"]/*' />
            PrevDocument = 629,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool1"]/*' />
            Tool1 = 630,   // note cmdidTool1 - cmdidTool24 must be
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool2"]/*' />
            Tool2 = 631,   // consecutive
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool3"]/*' />
            Tool3 = 632,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool4"]/*' />
            Tool4 = 633,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool5"]/*' />
            Tool5 = 634,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool6"]/*' />
            Tool6 = 635,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool7"]/*' />
            Tool7 = 636,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool8"]/*' />
            Tool8 = 637,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool9"]/*' />
            Tool9 = 638,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool10"]/*' />
            Tool10 = 639,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool11"]/*' />
            Tool11 = 640,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool12"]/*' />
            Tool12 = 641,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool13"]/*' />
            Tool13 = 642,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool14"]/*' />
            Tool14 = 643,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool15"]/*' />
            Tool15 = 644,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool16"]/*' />
            Tool16 = 645,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool17"]/*' />
            Tool17 = 646,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool18"]/*' />
            Tool18 = 647,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool19"]/*' />
            Tool19 = 648,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool20"]/*' />
            Tool20 = 649,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool21"]/*' />
            Tool21 = 650,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool22"]/*' />
            Tool22 = 651,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool23"]/*' />
            Tool23 = 652,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool24"]/*' />
            Tool24 = 653,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExternalCommands"]/*' />
            ExternalCommands = 654,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PasteNextTBXCBItem"]/*' />
            PasteNextTBXCBItem = 655,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxShowAllTabs"]/*' />
            ToolboxShowAllTabs = 656,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ProjectDependencies"]/*' />
            ProjectDependencies = 657,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CloseDocument"]/*' />
            CloseDocument = 658,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxSortItems"]/*' />
            ToolboxSortItems = 659,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView1"]/*' />
            ViewBarView1 = 660,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView2"]/*' />
            ViewBarView2 = 661,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView3"]/*' />
            ViewBarView3 = 662,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView4"]/*' />
            ViewBarView4 = 663,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView5"]/*' />
            ViewBarView5 = 664,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView6"]/*' />
            ViewBarView6 = 665,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView7"]/*' />
            ViewBarView7 = 666,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView8"]/*' />
            ViewBarView8 = 667,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView9"]/*' />
            ViewBarView9 = 668,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView10"]/*' />
            ViewBarView10 = 669,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView11"]/*' />
            ViewBarView11 = 670,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView12"]/*' />
            ViewBarView12 = 671,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView13"]/*' />
            ViewBarView13 = 672,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView14"]/*' />
            ViewBarView14 = 673,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView15"]/*' />
            ViewBarView15 = 674,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView16"]/*' />
            ViewBarView16 = 675,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView17"]/*' />
            ViewBarView17 = 676,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView18"]/*' />
            ViewBarView18 = 677,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView19"]/*' />
            ViewBarView19 = 678,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView20"]/*' />
            ViewBarView20 = 679,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView21"]/*' />
            ViewBarView21 = 680,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView22"]/*' />
            ViewBarView22 = 681,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView23"]/*' />
            ViewBarView23 = 682,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView24"]/*' />
            ViewBarView24 = 683,    //UNUSED

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SolutionCfg"]/*' />
            SolutionCfg = 684,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SolutionCfgGetList"]/*' />
            SolutionCfgGetList = 685,

            //
            // Schema table commands:
            // All invoke table property dialog and select appropriate page.
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ManageIndexes"]/*' />
            ManageIndexes = 675,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ManageRelationships"]/*' />
            ManageRelationships = 676,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ManageConstraints"]/*' />
            ManageConstraints = 677,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView1"]/*' />
            TaskListCustomView1 = 678,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView2"]/*' />
            TaskListCustomView2 = 679,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView3"]/*' />
            TaskListCustomView3 = 680,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView4"]/*' />
            TaskListCustomView4 = 681,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView5"]/*' />
            TaskListCustomView5 = 682,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView6"]/*' />
            TaskListCustomView6 = 683,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView7"]/*' />
            TaskListCustomView7 = 684,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView8"]/*' />
            TaskListCustomView8 = 685,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView9"]/*' />
            TaskListCustomView9 = 686,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView10"]/*' />
            TaskListCustomView10 = 687,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView11"]/*' />
            TaskListCustomView11 = 688,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView12"]/*' />
            TaskListCustomView12 = 689,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView13"]/*' />
            TaskListCustomView13 = 690,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView14"]/*' />
            TaskListCustomView14 = 691,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView15"]/*' />
            TaskListCustomView15 = 692,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView16"]/*' />
            TaskListCustomView16 = 693,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView17"]/*' />
            TaskListCustomView17 = 694,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView18"]/*' />
            TaskListCustomView18 = 695,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView19"]/*' />
            TaskListCustomView19 = 696,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView20"]/*' />
            TaskListCustomView20 = 697,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView21"]/*' />
            TaskListCustomView21 = 698,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView22"]/*' />
            TaskListCustomView22 = 699,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView23"]/*' />
            TaskListCustomView23 = 700,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView24"]/*' />
            TaskListCustomView24 = 701,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView25"]/*' />
            TaskListCustomView25 = 702,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView26"]/*' />
            TaskListCustomView26 = 703,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView27"]/*' />
            TaskListCustomView27 = 704,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView28"]/*' />
            TaskListCustomView28 = 705,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView29"]/*' />
            TaskListCustomView29 = 706,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView30"]/*' />
            TaskListCustomView30 = 707,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView31"]/*' />
            TaskListCustomView31 = 708,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView32"]/*' />
            TaskListCustomView32 = 709,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView33"]/*' />
            TaskListCustomView33 = 710,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView34"]/*' />
            TaskListCustomView34 = 711,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView35"]/*' />
            TaskListCustomView35 = 712,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView36"]/*' />
            TaskListCustomView36 = 713,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView37"]/*' />
            TaskListCustomView37 = 714,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView38"]/*' />
            TaskListCustomView38 = 715,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView39"]/*' />
            TaskListCustomView39 = 716,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView40"]/*' />
            TaskListCustomView40 = 717,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView41"]/*' />
            TaskListCustomView41 = 718,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView42"]/*' />
            TaskListCustomView42 = 719,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView43"]/*' />
            TaskListCustomView43 = 720,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView44"]/*' />
            TaskListCustomView44 = 721,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView45"]/*' />
            TaskListCustomView45 = 722,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView46"]/*' />
            TaskListCustomView46 = 723,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView47"]/*' />
            TaskListCustomView47 = 724,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView48"]/*' />
            TaskListCustomView48 = 725,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView49"]/*' />
            TaskListCustomView49 = 726,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView50"]/*' />
            TaskListCustomView50 = 727,  //not used on purpose, ends the list

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WhiteSpace"]/*' />
            WhiteSpace = 728,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CommandWindow"]/*' />
            CommandWindow = 729,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CommandWindowMarkMode"]/*' />
            CommandWindowMarkMode = 730,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.LogCommandWindow"]/*' />
            LogCommandWindow = 731,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Shell"]/*' />
            Shell = 732,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SingleChar"]/*' />
            SingleChar = 733,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ZeroOrMore"]/*' />
            ZeroOrMore = 734,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OneOrMore"]/*' />
            OneOrMore = 735,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BeginLine"]/*' />
            BeginLine = 736,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EndLine"]/*' />
            EndLine = 737,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BeginWord"]/*' />
            BeginWord = 738,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EndWord"]/*' />
            EndWord = 739,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CharInSet"]/*' />
            CharInSet = 740,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CharNotInSet"]/*' />
            CharNotInSet = 741,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Or"]/*' />
            Or = 742,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Escape"]/*' />
            Escape = 743,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TagExp"]/*' />
            TagExp = 744,

            // Regex builder context help menu commands
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PatternMatchHelp"]/*' />
            PatternMatchHelp = 745,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RegExList"]/*' />
            RegExList = 746,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DebugReserved1"]/*' />
            DebugReserved1 = 747,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DebugReserved2"]/*' />
            DebugReserved2 = 748,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DebugReserved3"]/*' />
            DebugReserved3 = 749,
            //USED ABOVE                        750
            //USED ABOVE                        751
            //USED ABOVE                        752
            //USED ABOVE                        753

            //Regex builder wildcard menu commands
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WildZeroOrMore"]/*' />
            WildZeroOrMore = 754,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WildSingleChar"]/*' />
            WildSingleChar = 755,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WildSingleDigit"]/*' />
            WildSingleDigit = 756,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WildCharInSet"]/*' />
            WildCharInSet = 757,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WildCharNotInSet"]/*' />
            WildCharNotInSet = 758,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindWhatText"]/*' />
            FindWhatText = 759,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp1"]/*' />
            TaggedExp1 = 760,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp2"]/*' />
            TaggedExp2 = 761,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp3"]/*' />
            TaggedExp3 = 762,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp4"]/*' />
            TaggedExp4 = 763,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp5"]/*' />
            TaggedExp5 = 764,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp6"]/*' />
            TaggedExp6 = 765,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp7"]/*' />
            TaggedExp7 = 766,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp8"]/*' />
            TaggedExp8 = 767,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp9"]/*' />
            TaggedExp9 = 768,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditorWidgetClick"]/*' />
            EditorWidgetClick = 769,  // param 0 is the moniker as VT_BSTR, param 1 is the buffer line as VT_I4, and param 2 is the buffer index as VT_I4
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CmdWinUpdateAC"]/*' />
            CmdWinUpdateAC = 770,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SlnCfgMgr"]/*' />
            SlnCfgMgr = 771,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddNewProject"]/*' />
            AddNewProject = 772,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddExistingProject"]/*' />
            AddExistingProject = 773,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddExistingProjFromWeb"]/*' />
            AddExistingProjFromWeb = 774,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext1"]/*' />
            AutoHideContext1 = 776,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext2"]/*' />
            AutoHideContext2 = 777,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext3"]/*' />
            AutoHideContext3 = 778,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext4"]/*' />
            AutoHideContext4 = 779,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext5"]/*' />
            AutoHideContext5 = 780,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext6"]/*' />
            AutoHideContext6 = 781,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext7"]/*' />
            AutoHideContext7 = 782,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext8"]/*' />
            AutoHideContext8 = 783,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext9"]/*' />
            AutoHideContext9 = 784,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext10"]/*' />
            AutoHideContext10 = 785,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext11"]/*' />
            AutoHideContext11 = 786,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext12"]/*' />
            AutoHideContext12 = 787,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext13"]/*' />
            AutoHideContext13 = 788,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext14"]/*' />
            AutoHideContext14 = 789,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext15"]/*' />
            AutoHideContext15 = 790,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext16"]/*' />
            AutoHideContext16 = 791,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext17"]/*' />
            AutoHideContext17 = 792,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext18"]/*' />
            AutoHideContext18 = 793,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext19"]/*' />
            AutoHideContext19 = 794,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext20"]/*' />
            AutoHideContext20 = 795,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext21"]/*' />
            AutoHideContext21 = 796,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext22"]/*' />
            AutoHideContext22 = 797,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext23"]/*' />
            AutoHideContext23 = 798,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext24"]/*' />
            AutoHideContext24 = 799,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext25"]/*' />
            AutoHideContext25 = 800,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext26"]/*' />
            AutoHideContext26 = 801,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext27"]/*' />
            AutoHideContext27 = 802,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext28"]/*' />
            AutoHideContext28 = 803,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext29"]/*' />
            AutoHideContext29 = 804,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext30"]/*' />
            AutoHideContext30 = 805,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext31"]/*' />
            AutoHideContext31 = 806,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext32"]/*' />
            AutoHideContext32 = 807,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext33"]/*' />
            AutoHideContext33 = 808,   // must remain unused

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavBackward"]/*' />
            ShellNavBackward = 809,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavForward"]/*' />
            ShellNavForward = 810,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate1"]/*' />
            ShellNavigate1 = 811,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate2"]/*' />
            ShellNavigate2 = 812,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate3"]/*' />
            ShellNavigate3 = 813,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate4"]/*' />
            ShellNavigate4 = 814,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate5"]/*' />
            ShellNavigate5 = 815,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate6"]/*' />
            ShellNavigate6 = 816,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate7"]/*' />
            ShellNavigate7 = 817,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate8"]/*' />
            ShellNavigate8 = 818,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate9"]/*' />
            ShellNavigate9 = 819,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate10"]/*' />
            ShellNavigate10 = 820,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate11"]/*' />
            ShellNavigate11 = 821,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate12"]/*' />
            ShellNavigate12 = 822,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate13"]/*' />
            ShellNavigate13 = 823,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate14"]/*' />
            ShellNavigate14 = 824,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate15"]/*' />
            ShellNavigate15 = 825,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate16"]/*' />
            ShellNavigate16 = 826,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate17"]/*' />
            ShellNavigate17 = 827,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate18"]/*' />
            ShellNavigate18 = 828,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate19"]/*' />
            ShellNavigate19 = 829,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate20"]/*' />
            ShellNavigate20 = 830,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate21"]/*' />
            ShellNavigate21 = 831,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate22"]/*' />
            ShellNavigate22 = 832,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate23"]/*' />
            ShellNavigate23 = 833,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate24"]/*' />
            ShellNavigate24 = 834,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate25"]/*' />
            ShellNavigate25 = 835,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate26"]/*' />
            ShellNavigate26 = 836,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate27"]/*' />
            ShellNavigate27 = 837,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate28"]/*' />
            ShellNavigate28 = 838,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate29"]/*' />
            ShellNavigate29 = 839,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate30"]/*' />
            ShellNavigate30 = 840,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate31"]/*' />
            ShellNavigate31 = 841,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate32"]/*' />
            ShellNavigate32 = 842,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate33"]/*' />
            ShellNavigate33 = 843,   // must remain unused

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate1"]/*' />
            ShellWindowNavigate1 = 844,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate2"]/*' />
            ShellWindowNavigate2 = 845,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate3"]/*' />
            ShellWindowNavigate3 = 846,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate4"]/*' />
            ShellWindowNavigate4 = 847,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate5"]/*' />
            ShellWindowNavigate5 = 848,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate6"]/*' />
            ShellWindowNavigate6 = 849,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate7"]/*' />
            ShellWindowNavigate7 = 850,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate8"]/*' />
            ShellWindowNavigate8 = 851,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate9"]/*' />
            ShellWindowNavigate9 = 852,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate10"]/*' />
            ShellWindowNavigate10 = 853,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate11"]/*' />
            ShellWindowNavigate11 = 854,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate12"]/*' />
            ShellWindowNavigate12 = 855,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate13"]/*' />
            ShellWindowNavigate13 = 856,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate14"]/*' />
            ShellWindowNavigate14 = 857,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate15"]/*' />
            ShellWindowNavigate15 = 858,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate16"]/*' />
            ShellWindowNavigate16 = 859,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate17"]/*' />
            ShellWindowNavigate17 = 860,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate18"]/*' />
            ShellWindowNavigate18 = 861,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate19"]/*' />
            ShellWindowNavigate19 = 862,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate20"]/*' />
            ShellWindowNavigate20 = 863,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate21"]/*' />
            ShellWindowNavigate21 = 864,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate22"]/*' />
            ShellWindowNavigate22 = 865,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate23"]/*' />
            ShellWindowNavigate23 = 866,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate24"]/*' />
            ShellWindowNavigate24 = 867,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate25"]/*' />
            ShellWindowNavigate25 = 868,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate26"]/*' />
            ShellWindowNavigate26 = 869,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate27"]/*' />
            ShellWindowNavigate27 = 870,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate28"]/*' />
            ShellWindowNavigate28 = 871,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate29"]/*' />
            ShellWindowNavigate29 = 872,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate30"]/*' />
            ShellWindowNavigate30 = 873,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate31"]/*' />
            ShellWindowNavigate31 = 874,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate32"]/*' />
            ShellWindowNavigate32 = 875,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate33"]/*' />
            ShellWindowNavigate33 = 876,   // must remain unused

            // ObjectSearch cmds
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSDoFind"]/*' />
            OBSDoFind = 877,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSMatchCase"]/*' />
            OBSMatchCase = 878,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSMatchSubString"]/*' />
            OBSMatchSubString = 879,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSMatchWholeWord"]/*' />
            OBSMatchWholeWord = 880,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSMatchPrefix"]/*' />
            OBSMatchPrefix = 881,

            // build cmds
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BuildSln"]/*' />
            BuildSln = 882,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RebuildSln"]/*' />
            RebuildSln = 883,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeploySln"]/*' />
            DeploySln = 884,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CleanSln"]/*' />
            CleanSln = 885,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BuildSel"]/*' />
            BuildSel = 886,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RebuildSel"]/*' />
            RebuildSel = 887,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeploySel"]/*' />
            DeploySel = 888,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CleanSel"]/*' />
            CleanSel = 889,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CancelBuild"]/*' />
            CancelBuild = 890,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BatchBuildDlg"]/*' />
            BatchBuildDlg = 891,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BuildCtx"]/*' />
            BuildCtx = 892,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RebuildCtx"]/*' />
            RebuildCtx = 893,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeployCtx"]/*' />
            DeployCtx = 894,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CleanCtx"]/*' />
            CleanCtx = 895,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.QryManageIndexes"]/*' />
            QryManageIndexes = 896,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PrintDefault"]/*' />
            PrintDefault = 897,         // quick print
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BrowseDoc"]/*' />
            BrowseDoc = 898,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowStartPage"]/*' />
            ShowStartPage = 899,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile1"]/*' />
            MRUFile1 = 900,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile2"]/*' />
            MRUFile2 = 901,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile3"]/*' />
            MRUFile3 = 902,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile4"]/*' />
            MRUFile4 = 903,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile5"]/*' />
            MRUFile5 = 904,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile6"]/*' />
            MRUFile6 = 905,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile7"]/*' />
            MRUFile7 = 906,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile8"]/*' />
            MRUFile8 = 907,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile9"]/*' />
            MRUFile9 = 908,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile10"]/*' />
            MRUFile10 = 909,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile11"]/*' />
            MRUFile11 = 910,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile12"]/*' />
            MRUFile12 = 911,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile13"]/*' />
            MRUFile13 = 912,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile14"]/*' />
            MRUFile14 = 913,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile15"]/*' />
            MRUFile15 = 914,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile16"]/*' />
            MRUFile16 = 915,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile17"]/*' />
            MRUFile17 = 916,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile18"]/*' />
            MRUFile18 = 917,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile19"]/*' />
            MRUFile19 = 918,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile20"]/*' />
            MRUFile20 = 919,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile21"]/*' />
            MRUFile21 = 920,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile22"]/*' />
            MRUFile22 = 921,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile23"]/*' />
            MRUFile23 = 922,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile24"]/*' />
            MRUFile24 = 923,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile25"]/*' />
            MRUFile25 = 924,   // note cmdidMRUFile25 is unused on purpose!

            //External Tools Context Menu Commands
            // continued at 1109
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurPath"]/*' />
            ExtToolsCurPath = 925,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurDir"]/*' />
            ExtToolsCurDir = 926,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurFileName"]/*' />
            ExtToolsCurFileName = 927,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurExtension"]/*' />
            ExtToolsCurExtension = 928,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsProjDir"]/*' />
            ExtToolsProjDir = 929,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsProjFileName"]/*' />
            ExtToolsProjFileName = 930,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsSlnDir"]/*' />
            ExtToolsSlnDir = 931,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsSlnFileName"]/*' />
            ExtToolsSlnFileName = 932,


            // Object Browsing & ClassView cmds
            // Shared shell cmds (for accessing Object Browsing functionality)
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GotoDefn"]/*' />
            GotoDefn = 935,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GotoDecl"]/*' />
            GotoDecl = 936,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BrowseDefn"]/*' />
            BrowseDefn = 937,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SyncClassView"]/*' />
            SyncClassView = 938,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowMembers"]/*' />
            ShowMembers = 939,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowBases"]/*' />
            ShowBases = 940,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowDerived"]/*' />
            ShowDerived = 941,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowDefns"]/*' />
            ShowDefns = 942,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowRefs"]/*' />
            ShowRefs = 943,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowCallers"]/*' />
            ShowCallers = 944,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowCallees"]/*' />
            ShowCallees = 945,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddClass"]/*' />
            AddClass = 946,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddNestedClass"]/*' />
            AddNestedClass = 947,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddInterface"]/*' />
            AddInterface = 948,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddMethod"]/*' />
            AddMethod = 949,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddProperty"]/*' />
            AddProperty = 950,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddEvent"]/*' />
            AddEvent = 951,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddVariable"]/*' />
            AddVariable = 952,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ImplementInterface"]/*' />
            ImplementInterface = 953,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Override"]/*' />
            Override = 954,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddFunction"]/*' />
            AddFunction = 955,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddConnectionPoint"]/*' />
            AddConnectionPoint = 956,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddIndexer"]/*' />
            AddIndexer = 957,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BuildOrder"]/*' />
            BuildOrder = 958,
            //959 used above for cmdidSaveOptions

            // Object Browser Tool Specific cmds
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBShowHidden"]/*' />
            OBShowHidden = 960,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBEnableGrouping"]/*' />
            OBEnableGrouping = 961,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSetGroupingCriteria"]/*' />
            OBSetGroupingCriteria = 962,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBBack"]/*' />
            OBBack = 963,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBForward"]/*' />
            OBForward = 964,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBShowPackages"]/*' />
            OBShowPackages = 965,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSearchCombo"]/*' />
            OBSearchCombo = 966,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSearchOptWholeWord"]/*' />
            OBSearchOptWholeWord = 967,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSearchOptSubstring"]/*' />
            OBSearchOptSubstring = 968,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSearchOptPrefix"]/*' />
            OBSearchOptPrefix = 969,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSearchOptCaseSensitive"]/*' />
            OBSearchOptCaseSensitive = 970,

            // ClassView Tool Specific cmds
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CVGroupingNone"]/*' />
            CVGroupingNone = 971,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CVGroupingSortOnly"]/*' />
            CVGroupingSortOnly = 972,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CVGroupingGrouped"]/*' />
            CVGroupingGrouped = 973,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CVShowPackages"]/*' />
            CVShowPackages = 974,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CVNewFolder"]/*' />
            CVNewFolder = 975,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CVGroupingSortAccess"]/*' />
            CVGroupingSortAccess = 976,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectSearch"]/*' />
            ObjectSearch = 977,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectSearchResults"]/*' />
            ObjectSearchResults = 978,

            // Further Obj Browsing cmds at 1095

            // build cascade menus
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build1"]/*' />
            Build1 = 979,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build2"]/*' />
            Build2 = 980,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build3"]/*' />
            Build3 = 981,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build4"]/*' />
            Build4 = 982,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build5"]/*' />
            Build5 = 983,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build6"]/*' />
            Build6 = 984,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build7"]/*' />
            Build7 = 985,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build8"]/*' />
            Build8 = 986,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build9"]/*' />
            Build9 = 987,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BuildLast"]/*' />
            BuildLast = 988,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild1"]/*' />
            Rebuild1 = 989,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild2"]/*' />
            Rebuild2 = 990,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild3"]/*' />
            Rebuild3 = 991,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild4"]/*' />
            Rebuild4 = 992,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild5"]/*' />
            Rebuild5 = 993,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild6"]/*' />
            Rebuild6 = 994,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild7"]/*' />
            Rebuild7 = 995,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild8"]/*' />
            Rebuild8 = 996,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild9"]/*' />
            Rebuild9 = 997,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RebuildLast"]/*' />
            RebuildLast = 998,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean1"]/*' />
            Clean1 = 999,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean2"]/*' />
            Clean2 = 1000,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean3"]/*' />
            Clean3 = 1001,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean4"]/*' />
            Clean4 = 1002,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean5"]/*' />
            Clean5 = 1003,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean6"]/*' />
            Clean6 = 1004,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean7"]/*' />
            Clean7 = 1005,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean8"]/*' />
            Clean8 = 1006,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean9"]/*' />
            Clean9 = 1007,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CleanLast"]/*' />
            CleanLast = 1008,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy1"]/*' />
            Deploy1 = 1009,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy2"]/*' />
            Deploy2 = 1010,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy3"]/*' />
            Deploy3 = 1011,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy4"]/*' />
            Deploy4 = 1012,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy5"]/*' />
            Deploy5 = 1013,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy6"]/*' />
            Deploy6 = 1014,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy7"]/*' />
            Deploy7 = 1015,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy8"]/*' />
            Deploy8 = 1016,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy9"]/*' />
            Deploy9 = 1017,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeployLast"]/*' />
            DeployLast = 1018,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BuildProjPicker"]/*' />
            BuildProjPicker = 1019,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RebuildProjPicker"]/*' />
            RebuildProjPicker = 1020,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CleanProjPicker"]/*' />
            CleanProjPicker = 1021,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeployProjPicker"]/*' />
            DeployProjPicker = 1022,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ResourceView"]/*' />
            ResourceView = 1023,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowHomePage"]/*' />
            ShowHomePage = 1024,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditMenuIDs"]/*' />
            EditMenuIDs = 1025,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.LineBreak"]/*' />
            LineBreak = 1026,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CPPIdentifier"]/*' />
            CPPIdentifier = 1027,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.QuotedString"]/*' />
            QuotedString = 1028,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SpaceOrTab"]/*' />
            SpaceOrTab = 1029,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Integer"]/*' />
            Integer = 1030,
            //unused 1031-1035

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CustomizeToolbars"]/*' />
            CustomizeToolbars = 1036,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveToTop"]/*' />
            MoveToTop = 1037,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WindowHelp"]/*' />
            WindowHelp = 1038,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewPopup"]/*' />
            ViewPopup = 1039,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CheckMnemonics"]/*' />
            CheckMnemonics = 1040,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PRSortAlphabeticaly"]/*' />
            PRSortAlphabeticaly = 1041,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PRSortByCategory"]/*' />
            PRSortByCategory = 1042,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewNextTab"]/*' />
            ViewNextTab = 1043,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CheckForUpdates"]/*' />
            CheckForUpdates = 1044,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser1"]/*' />
            Browser1 = 1045,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser2"]/*' />
            Browser2 = 1046,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser3"]/*' />
            Browser3 = 1047,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser4"]/*' />
            Browser4 = 1048,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser5"]/*' />
            Browser5 = 1049,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser6"]/*' />
            Browser6 = 1050,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser7"]/*' />
            Browser7 = 1051,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser8"]/*' />
            Browser8 = 1052,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser9"]/*' />
            Browser9 = 1053,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser10"]/*' />
            Browser10 = 1054,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser11"]/*' />
            Browser11 = 1055,  //note unused on purpose to end list

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenDropDownOpen"]/*' />
            OpenDropDownOpen = 1058,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenDropDownOpenWith"]/*' />
            OpenDropDownOpenWith = 1059,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolsDebugProcesses"]/*' />
            ToolsDebugProcesses = 1060,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PaneNextSubPane"]/*' />
            PaneNextSubPane = 1062,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PanePrevSubPane"]/*' />
            PanePrevSubPane = 1063,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject1"]/*' />
            MoveFileToProject1 = 1070,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject2"]/*' />
            MoveFileToProject2 = 1071,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject3"]/*' />
            MoveFileToProject3 = 1072,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject4"]/*' />
            MoveFileToProject4 = 1073,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject5"]/*' />
            MoveFileToProject5 = 1074,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject6"]/*' />
            MoveFileToProject6 = 1075,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject7"]/*' />
            MoveFileToProject7 = 1076,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject8"]/*' />
            MoveFileToProject8 = 1077,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject9"]/*' />
            MoveFileToProject9 = 1078,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProjectLast"]/*' />
            MoveFileToProjectLast = 1079,  // unused in order to end list
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProjectPick"]/*' />
            MoveFileToProjectPick = 1081,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DefineSubset"]/*' />
            DefineSubset = 1095,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SubsetCombo"]/*' />
            SubsetCombo = 1096,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SubsetGetList"]/*' />
            SubsetGetList = 1097,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSortObjectsAlpha"]/*' />
            OBSortObjectsAlpha = 1098,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSortObjectsType"]/*' />
            OBSortObjectsType = 1099,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSortObjectsAccess"]/*' />
            OBSortObjectsAccess = 1100,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBGroupObjectsType"]/*' />
            OBGroupObjectsType = 1101,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBGroupObjectsAccess"]/*' />
            OBGroupObjectsAccess = 1102,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSortMembersAlpha"]/*' />
            OBSortMembersAlpha = 1103,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSortMembersType"]/*' />
            OBSortMembersType = 1104,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSortMembersAccess"]/*' />
            OBSortMembersAccess = 1105,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PopBrowseContext"]/*' />
            PopBrowseContext = 1106,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GotoRef"]/*' />
            GotoRef = 1107,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSLookInReferences"]/*' />
            OBSLookInReferences = 1108,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsTargetPath"]/*' />
            ExtToolsTargetPath = 1109,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsTargetDir"]/*' />
            ExtToolsTargetDir = 1110,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsTargetFileName"]/*' />
            ExtToolsTargetFileName = 1111,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsTargetExtension"]/*' />
            ExtToolsTargetExtension = 1112,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurLine"]/*' />
            ExtToolsCurLine = 1113,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurCol"]/*' />
            ExtToolsCurCol = 1114,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurText"]/*' />
            ExtToolsCurText = 1115,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BrowseNext"]/*' />
            BrowseNext = 1116,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BrowsePrev"]/*' />
            BrowsePrev = 1117,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BrowseUnload"]/*' />
            BrowseUnload = 1118,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.QuickObjectSearch"]/*' />
            QuickObjectSearch = 1119,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExpandAll"]/*' />
            ExpandAll = 1120,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsBinDir"]/*' />
            ExtToolsBinDir = 1121,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BookmarkWindow"]/*' />
            BookmarkWindow = 1122,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CodeExpansionWindow"]/*' />
            CodeExpansionWindow = 1123,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NextDocumentNav"]/*' />
            NextDocumentNav = 1124,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PrevDocumentNav"]/*' />
            PrevDocumentNav = 1125,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ForwardBrowseContext"]/*' />
            ForwardBrowseContext = 1126,
            
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.StandardMax"]/*' />
            StandardMax = 1500,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindReferences"]/*' />
            FindReferences = 1915,

            ///////////////////////////////////////////
            //
            // cmdidStandardMax is now thought to be
            // obsolete. Any new shell commands should
            // be added to the end of StandardCommandSet2K
            // which appears below.
            //
            // If you are not adding shell commands,
            // you shouldn't be doing it in this file! 
            //
            ///////////////////////////////////////////


            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FormsFirst"]/*' />
            FormsFirst = 0x00006000,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FormsLast"]/*' />
            FormsLast = 0x00006FFF,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VBEFirst"]/*' />
            VBEFirst = 0x00008000,


            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom200"]/*' />
            Zoom200 = 0x00008002,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom150"]/*' />
            Zoom150 = 0x00008003,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom100"]/*' />
            Zoom100 = 0x00008004,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom75"]/*' />
            Zoom75 = 0x00008005,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom50"]/*' />
            Zoom50 = 0x00008006,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom25"]/*' />
            Zoom25 = 0x00008007,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom10"]/*' />
            Zoom10 = 0x00008010,


            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VBELast"]/*' />
            VBELast = 0x00009FFF,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SterlingFirst"]/*' />
            SterlingFirst = 0x0000A000,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SterlingLast"]/*' />
            SterlingLast = 0x0000BFFF,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.uieventidFirst"]/*' />
            uieventidFirst = 0xC000,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.uieventidSelectRegion"]/*' />
            uieventidSelectRegion = 0xC001,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.uieventidDrop"]/*' />
            uieventidDrop = 0xC002,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.uieventidLast"]/*' />
            uieventidLast = 0xDFFF,
        }

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSStd2K"]/*' />
        /// <summary>
        /// GUID for the 2K command set. This is a set of standard editor commands.
        /// </summary>
        public static readonly Guid VSStd2K = new Guid("{1496A755-94DE-11D0-8C3F-00C04FC2AAE2}");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSStd2KCmdID"]/*' />
        /// <summary>
        /// Set of the standard, shared editor commands in StandardCommandSet2k.
        /// </summary>
        [Guid("1496A755-94DE-11D0-8C3F-00C04FC2AAE2")]
        public enum VSStd2KCmdID
        {
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TYPECHAR"]/*' />
            TYPECHAR = 1,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BACKSPACE"]/*' />
            BACKSPACE = 2,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RETURN"]/*' />
            RETURN = 3,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TAB"]/*' />
            TAB = 4,  // test
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_TAB"]/*' />
            ECMD_TAB = 4,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BACKTAB"]/*' />
            BACKTAB = 5,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETE"]/*' />
            DELETE = 6,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFT"]/*' />
            LEFT = 7,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFT_EXT"]/*' />
            LEFT_EXT = 8,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RIGHT"]/*' />
            RIGHT = 9,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RIGHT_EXT"]/*' />
            RIGHT_EXT = 10,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UP"]/*' />
            UP = 11,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UP_EXT"]/*' />
            UP_EXT = 12,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOWN"]/*' />
            DOWN = 13,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOWN_EXT"]/*' />
            DOWN_EXT = 14,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HOME"]/*' />
            HOME = 15,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HOME_EXT"]/*' />
            HOME_EXT = 16,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.END"]/*' />
            END = 17,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.END_EXT"]/*' />
            END_EXT = 18,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BOL"]/*' />
            BOL = 19,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BOL_EXT"]/*' />
            BOL_EXT = 20,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FIRSTCHAR"]/*' />
            FIRSTCHAR = 21,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FIRSTCHAR_EXT"]/*' />
            FIRSTCHAR_EXT = 22,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EOL"]/*' />
            EOL = 23,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EOL_EXT"]/*' />
            EOL_EXT = 24,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LASTCHAR"]/*' />
            LASTCHAR = 25,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LASTCHAR_EXT"]/*' />
            LASTCHAR_EXT = 26,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PAGEUP"]/*' />
            PAGEUP = 27,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PAGEUP_EXT"]/*' />
            PAGEUP_EXT = 28,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PAGEDN"]/*' />
            PAGEDN = 29,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PAGEDN_EXT"]/*' />
            PAGEDN_EXT = 30,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOPLINE"]/*' />
            TOPLINE = 31,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOPLINE_EXT"]/*' />
            TOPLINE_EXT = 32,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BOTTOMLINE"]/*' />
            BOTTOMLINE = 33,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BOTTOMLINE_EXT"]/*' />
            BOTTOMLINE_EXT = 34,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLUP"]/*' />
            SCROLLUP = 35,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLDN"]/*' />
            SCROLLDN = 36,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLPAGEUP"]/*' />
            SCROLLPAGEUP = 37,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLPAGEDN"]/*' />
            SCROLLPAGEDN = 38,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLLEFT"]/*' />
            SCROLLLEFT = 39,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLRIGHT"]/*' />
            SCROLLRIGHT = 40,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLBOTTOM"]/*' />
            SCROLLBOTTOM = 41,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLCENTER"]/*' />
            SCROLLCENTER = 42,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLTOP"]/*' />
            SCROLLTOP = 43,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTALL"]/*' />
            SELECTALL = 44,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELTABIFY"]/*' />
            SELTABIFY = 45,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELUNTABIFY"]/*' />
            SELUNTABIFY = 46,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELLOWCASE"]/*' />
            SELLOWCASE = 47,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELUPCASE"]/*' />
            SELUPCASE = 48,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELTOGGLECASE"]/*' />
            SELTOGGLECASE = 49,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELTITLECASE"]/*' />
            SELTITLECASE = 50,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELSWAPANCHOR"]/*' />
            SELSWAPANCHOR = 51,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOTOLINE"]/*' />
            GOTOLINE = 52,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOTOBRACE"]/*' />
            GOTOBRACE = 53,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOTOBRACE_EXT"]/*' />
            GOTOBRACE_EXT = 54,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOBACK"]/*' />
            GOBACK = 55,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTMODE"]/*' />
            SELECTMODE = 56,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLE_OVERTYPE_MODE"]/*' />
            TOGGLE_OVERTYPE_MODE = 57,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CUT"]/*' />
            CUT = 58,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COPY"]/*' />
            COPY = 59,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PASTE"]/*' />
            PASTE = 60,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CUTLINE"]/*' />
            CUTLINE = 61,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETELINE"]/*' />
            DELETELINE = 62,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEBLANKLINES"]/*' />
            DELETEBLANKLINES = 63,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEWHITESPACE"]/*' />
            DELETEWHITESPACE = 64,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETETOEOL"]/*' />
            DELETETOEOL = 65,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETETOBOL"]/*' />
            DELETETOBOL = 66,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPENLINEABOVE"]/*' />
            OPENLINEABOVE = 67,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPENLINEBELOW"]/*' />
            OPENLINEBELOW = 68,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INDENT"]/*' />
            INDENT = 69,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UNINDENT"]/*' />
            UNINDENT = 70,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UNDO"]/*' />
            UNDO = 71,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UNDONOMOVE"]/*' />
            UNDONOMOVE = 72,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REDO"]/*' />
            REDO = 73,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REDONOMOVE"]/*' />
            REDONOMOVE = 74,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEALLTEMPBOOKMARKS"]/*' />
            DELETEALLTEMPBOOKMARKS = 75,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLETEMPBOOKMARK"]/*' />
            TOGGLETEMPBOOKMARK = 76,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOTONEXTBOOKMARK"]/*' />
            GOTONEXTBOOKMARK = 77,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOTOPREVBOOKMARK"]/*' />
            GOTOPREVBOOKMARK = 78,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FIND"]/*' />
            FIND = 79,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REPLACE"]/*' />
            REPLACE = 80,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REPLACE_ALL"]/*' />
            REPLACE_ALL = 81,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FINDNEXT"]/*' />
            FINDNEXT = 82,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FINDNEXTWORD"]/*' />
            FINDNEXTWORD = 83,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FINDPREV"]/*' />
            FINDPREV = 84,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FINDPREVWORD"]/*' />
            FINDPREVWORD = 85,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FINDAGAIN"]/*' />
            FINDAGAIN = 86,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TRANSPOSECHAR"]/*' />
            TRANSPOSECHAR = 87,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TRANSPOSEWORD"]/*' />
            TRANSPOSEWORD = 88,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TRANSPOSELINE"]/*' />
            TRANSPOSELINE = 89,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTCURRENTWORD"]/*' />
            SELECTCURRENTWORD = 90,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEWORDRIGHT"]/*' />
            DELETEWORDRIGHT = 91,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEWORDLEFT"]/*' />
            DELETEWORDLEFT = 92,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORDPREV"]/*' />
            WORDPREV = 93,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORDPREV_EXT"]/*' />
            WORDPREV_EXT = 94,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORDNEXT"]/*' />
            WORDNEXT = 96,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORDNEXT_EXT"]/*' />
            WORDNEXT_EXT = 97,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMMENTBLOCK"]/*' />
            COMMENTBLOCK = 98,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UNCOMMENTBLOCK"]/*' />
            UNCOMMENTBLOCK = 99,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETREPEATCOUNT"]/*' />
            SETREPEATCOUNT = 100,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WIDGETMARGIN_LBTNDOWN"]/*' />
            WIDGETMARGIN_LBTNDOWN = 101,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWCONTEXTMENU"]/*' />
            SHOWCONTEXTMENU = 102,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CANCEL"]/*' />
            CANCEL = 103,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PARAMINFO"]/*' />
            PARAMINFO = 104,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLEVISSPACE"]/*' />
            TOGGLEVISSPACE = 105,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLECARETPASTEPOS"]/*' />
            TOGGLECARETPASTEPOS = 106,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMPLETEWORD"]/*' />
            COMPLETEWORD = 107,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWMEMBERLIST"]/*' />
            SHOWMEMBERLIST = 108,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FIRSTNONWHITEPREV"]/*' />
            FIRSTNONWHITEPREV = 109,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FIRSTNONWHITENEXT"]/*' />
            FIRSTNONWHITENEXT = 110,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HELPKEYWORD"]/*' />
            HELPKEYWORD = 111,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FORMATSELECTION"]/*' />
            FORMATSELECTION = 112,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPENURL"]/*' />
            OPENURL = 113,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTFILE"]/*' />
            INSERTFILE = 114,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLESHORTCUT"]/*' />
            TOGGLESHORTCUT = 115,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.QUICKINFO"]/*' />
            QUICKINFO = 116,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFT_EXT_COL"]/*' />
            LEFT_EXT_COL = 117,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RIGHT_EXT_COL"]/*' />
            RIGHT_EXT_COL = 118,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UP_EXT_COL"]/*' />
            UP_EXT_COL = 119,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOWN_EXT_COL"]/*' />
            DOWN_EXT_COL = 120,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLEWORDWRAP"]/*' />
            TOGGLEWORDWRAP = 121,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ISEARCH"]/*' />
            ISEARCH = 122,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ISEARCHBACK"]/*' />
            ISEARCHBACK = 123,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BOL_EXT_COL"]/*' />
            BOL_EXT_COL = 124,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EOL_EXT_COL"]/*' />
            EOL_EXT_COL = 125,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORDPREV_EXT_COL"]/*' />
            WORDPREV_EXT_COL = 126,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORDNEXT_EXT_COL"]/*' />
            WORDNEXT_EXT_COL = 127,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_HIDE_SELECTION"]/*' />
            OUTLN_HIDE_SELECTION = 128,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_TOGGLE_CURRENT"]/*' />
            OUTLN_TOGGLE_CURRENT = 129,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_TOGGLE_ALL"]/*' />
            OUTLN_TOGGLE_ALL = 130,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_STOP_HIDING_ALL"]/*' />
            OUTLN_STOP_HIDING_ALL = 131,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_STOP_HIDING_CURRENT"]/*' />
            OUTLN_STOP_HIDING_CURRENT = 132,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_COLLAPSE_TO_DEF"]/*' />
            OUTLN_COLLAPSE_TO_DEF = 133,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOUBLECLICK"]/*' />
            DOUBLECLICK = 134,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXTERNALLY_HANDLED_WIDGET_CLICK"]/*' />
            EXTERNALLY_HANDLED_WIDGET_CLICK = 135,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMMENT_BLOCK"]/*' />
            COMMENT_BLOCK = 136,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UNCOMMENT_BLOCK"]/*' />
            UNCOMMENT_BLOCK = 137,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPENFILE"]/*' />
            OPENFILE = 138,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NAVIGATETOURL"]/*' />
            NAVIGATETOURL = 139,

            // For editor internal use only
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HANDLEIMEMESSAGE"]/*' />
            HANDLEIMEMESSAGE = 140,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELTOGOBACK"]/*' />
            SELTOGOBACK = 141,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMPLETION_HIDE_ADVANCED"]/*' />
            COMPLETION_HIDE_ADVANCED = 142,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FORMATDOCUMENT"]/*' />
            FORMATDOCUMENT = 143,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_START_AUTOHIDING"]/*' />
            OUTLN_START_AUTOHIDING = 144,

            // Last Standard Editor Command (+1)
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FINAL"]/*' />
            FINAL = 145,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_DECREASEFILTER"]/*' />
            ECMD_DECREASEFILTER = 146,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_COPYTIP"]/*' />
            ECMD_COPYTIP = 148,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_PASTETIP"]/*' />
            ECMD_PASTETIP = 149,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_LEFTCLICK"]/*' />
            ECMD_LEFTCLICK = 150,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_GOTONEXTBOOKMARKINDOC"]/*' />
            ECMD_GOTONEXTBOOKMARKINDOC = 151,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_GOTOPREVBOOKMARKINDOC"]/*' />
            ECMD_GOTOPREVBOOKMARKINDOC = 152,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_INVOKESNIPPETFROMSHORTCUT"]/*' />
            ECMD_INVOKESNIPPETFROMSHORTCUT = 154,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOCOMPLETE"]/*' />
            AUTOCOMPLETE = 155,

            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_INVOKESNIPPETPICKER2"]/*' />
            ECMD_INVOKESNIPPETPICKER2 = 156,
            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_DELETEALLBOOKMARKSINDOC"]/*' />
            ECMD_DELETEALLBOOKMARKSINDOC = 157,
            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONVERTTABSTOSPACES"]/*' />
            ECMD_CONVERTTABSTOSPACES = 158,
            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONVERTSPACESTOTABS"]/*' />
            ECMD_CONVERTSPACESTOTABS = 159,
            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_FINAL"]/*' />
            ECMD_FINAL = 160,

            ///////////////////////////////////////////////////////////////
            // Some new commands created during CTC file rationalisation
            ///////////////////////////////////////////////////////////////
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STOP"]/*' />
            STOP = 220,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REVERSECANCEL"]/*' />
            REVERSECANCEL = 221,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SLNREFRESH"]/*' />
            SLNREFRESH = 222,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SAVECOPYOFITEMAS"]/*' />
            SAVECOPYOFITEMAS = 223,
            //
            // Shareable commands originating in the HTML editor
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWELEMENT"]/*' />
            NEWELEMENT = 224,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWATTRIBUTE"]/*' />
            NEWATTRIBUTE = 225,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWCOMPLEXTYPE"]/*' />
            NEWCOMPLEXTYPE = 226,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWSIMPLETYPE"]/*' />
            NEWSIMPLETYPE = 227,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWGROUP"]/*' />
            NEWGROUP = 228,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWATTRIBUTEGROUP"]/*' />
            NEWATTRIBUTEGROUP = 229,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWKEY"]/*' />
            NEWKEY = 230,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWRELATION"]/*' />
            NEWRELATION = 231,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITKEY"]/*' />
            EDITKEY = 232,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITRELATION"]/*' />
            EDITRELATION = 233,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MAKETYPEGLOBAL"]/*' />
            MAKETYPEGLOBAL = 234,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PREVIEWDATASET"]/*' />
            PREVIEWDATASET = 235,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GENERATEDATASET"]/*' />
            GENERATEDATASET = 236,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CREATESCHEMA"]/*' />
            CREATESCHEMA = 237,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LAYOUTINDENT"]/*' />
            LAYOUTINDENT = 238,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LAYOUTUNINDENT"]/*' />
            LAYOUTUNINDENT = 239,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REMOVEHANDLER"]/*' />
            REMOVEHANDLER = 240,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITHANDLER"]/*' />
            EDITHANDLER = 241,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDHANDLER"]/*' />
            ADDHANDLER = 242,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STYLE"]/*' />
            STYLE = 243,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STYLEGETLIST"]/*' />
            STYLEGETLIST = 244,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FONTSTYLE"]/*' />
            FONTSTYLE = 245,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FONTSTYLEGETLIST"]/*' />
            FONTSTYLEGETLIST = 246,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PASTEASHTML"]/*' />
            PASTEASHTML = 247,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWBORDERS"]/*' />
            VIEWBORDERS = 248,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWDETAILS"]/*' />
            VIEWDETAILS = 249,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXPANDCONTROLS"]/*' />
            EXPANDCONTROLS = 250,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COLLAPSECONTROLS"]/*' />
            COLLAPSECONTROLS = 251,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWSCRIPTONLY"]/*' />
            SHOWSCRIPTONLY = 252,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTTABLE"]/*' />
            INSERTTABLE = 253,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTCOLLEFT"]/*' />
            INSERTCOLLEFT = 254,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTCOLRIGHT"]/*' />
            INSERTCOLRIGHT = 255,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTROWABOVE"]/*' />
            INSERTROWABOVE = 256,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTROWBELOW"]/*' />
            INSERTROWBELOW = 257,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETETABLE"]/*' />
            DELETETABLE = 258,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETECOLS"]/*' />
            DELETECOLS = 259,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEROWS"]/*' />
            DELETEROWS = 260,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTTABLE"]/*' />
            SELECTTABLE = 261,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTTABLECOL"]/*' />
            SELECTTABLECOL = 262,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTTABLEROW"]/*' />
            SELECTTABLEROW = 263,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTTABLECELL"]/*' />
            SELECTTABLECELL = 264,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MERGECELLS"]/*' />
            MERGECELLS = 265,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPLITCELL"]/*' />
            SPLITCELL = 266,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTCELL"]/*' />
            INSERTCELL = 267,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETECELLS"]/*' />
            DELETECELLS = 268,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SEAMLESSFRAME"]/*' />
            SEAMLESSFRAME = 269,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWFRAME"]/*' />
            VIEWFRAME = 270,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEFRAME"]/*' />
            DELETEFRAME = 271,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETFRAMESOURCE"]/*' />
            SETFRAMESOURCE = 272,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWLEFTFRAME"]/*' />
            NEWLEFTFRAME = 273,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWRIGHTFRAME"]/*' />
            NEWRIGHTFRAME = 274,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWTOPFRAME"]/*' />
            NEWTOPFRAME = 275,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWBOTTOMFRAME"]/*' />
            NEWBOTTOMFRAME = 276,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWGRID"]/*' />
            SHOWGRID = 277,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SNAPTOGRID"]/*' />
            SNAPTOGRID = 278,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BOOKMARK"]/*' />
            BOOKMARK = 279,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HYPERLINK"]/*' />
            HYPERLINK = 280,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMAGE"]/*' />
            IMAGE = 281,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTFORM"]/*' />
            INSERTFORM = 282,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTSPAN"]/*' />
            INSERTSPAN = 283,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SMARTTASKS"]/*' />
            DIV = 284,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HTMLCLIENTSCRIPTBLOCK"]/*' />
            HTMLCLIENTSCRIPTBLOCK = 285,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HTMLSERVERSCRIPTBLOCK"]/*' />
            HTMLSERVERSCRIPTBLOCK = 286,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BULLETEDLIST"]/*' />
            BULLETEDLIST = 287,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NUMBEREDLIST"]/*' />
            NUMBEREDLIST = 288,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITSCRIPT"]/*' />
            EDITSCRIPT = 289,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITCODEBEHIND"]/*' />
            EDITCODEBEHIND = 290,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOCOUTLINEHTML"]/*' />
            DOCOUTLINEHTML = 291,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOCOUTLINESCRIPT"]/*' />
            DOCOUTLINESCRIPT = 292,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RUNATSERVER"]/*' />
            RUNATSERVER = 293,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WEBFORMSVERBS"]/*' />
            WEBFORMSVERBS = 294,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WEBFORMSTEMPLATES"]/*' />
            WEBFORMSTEMPLATES = 295,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ENDTEMPLATE"]/*' />
            ENDTEMPLATE = 296,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITDEFAULTEVENT"]/*' />
            EDITDEFAULTEVENT = 297,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SUPERSCRIPT"]/*' />
            SUPERSCRIPT = 298,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SUBSCRIPT"]/*' />
            SUBSCRIPT = 299,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITSTYLE"]/*' />
            EDITSTYLE = 300,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDIMAGEHEIGHTWIDTH"]/*' />
            ADDIMAGEHEIGHTWIDTH = 301,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REMOVEIMAGEHEIGHTWIDTH"]/*' />
            REMOVEIMAGEHEIGHTWIDTH = 302,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LOCKELEMENT"]/*' />
            LOCKELEMENT = 303,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWSTYLEORGANIZER"]/*' />
            VIEWSTYLEORGANIZER = 304,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_AUTOCLOSEOVERRIDE"]/*' />
            ECMD_AUTOCLOSEOVERRIDE = 305,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWANY"]/*' />
            NEWANY = 306,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWANYATTRIBUTE"]/*' />
            NEWANYATTRIBUTE = 307,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEKEY"]/*' />
            DELETEKEY = 308,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOARRANGE"]/*' />
            AUTOARRANGE = 309,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VALIDATESCHEMA"]/*' />
            VALIDATESCHEMA = 310,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWFACET"]/*' />
            NEWFACET = 311,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VALIDATEXMLDATA"]/*' />
            VALIDATEXMLDATA = 312,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOCOUTLINETOGGLE"]/*' />
            DOCOUTLINETOGGLE = 313,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VALIDATEHTMLDATA"]/*' />
            VALIDATEHTMLDATA = 314,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWXMLSCHEMAOVERVIEW"]/*' />
            VIEWXMLSCHEMAOVERVIEW = 315,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWDEFAULTVIEW"]/*' />
            SHOWDEFAULTVIEW = 316,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXPAND_CHILDREN"]/*' />
            EXPAND_CHILDREN = 317,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COLLAPSE_CHILDREN"]/*' />
            COLLAPSE_CHILDREN = 318,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOPDOWNLAYOUT"]/*' />
            TOPDOWNLAYOUT = 319,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFTRIGHTLAYOUT"]/*' />
            LEFTRIGHTLAYOUT = 320,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTCELLRIGHT"]/*' />
            INSERTCELLRIGHT = 321,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITMASTER"]/*' />
            EDITMASTER = 322,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTSNIPPET"]/*' />
            INSERTSNIPPET = 323,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FORMATANDVALIDATION"]/*' />
            FORMATANDVALIDATION = 324,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COLLAPSETAG"]/*' />
            COLLAPSETAG = 325,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECT_TAG"]/*' />
            SELECT_TAG = 329,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECT_TAG_CONTENT"]/*' />
            SELECT_TAG_CONTENT = 330,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CHECK_ACCESSIBILITY"]/*' />
            CHECK_ACCESSIBILITY = 331,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UNCOLLAPSETAG"]/*' />
            UNCOLLAPSETAG = 332,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GENERATEPAGERESOURCE"]/*' />
            GENERATEPAGERESOURCE = 333,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWNONVISUALCONTROLS"]/*' />
            SHOWNONVISUALCONTROLS = 334,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESIZECOLUMN"]/*' />
            RESIZECOLUMN = 335,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESIZEROW"]/*' />
            RESIZEROW = 336,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MAKEABSOLUTE"]/*' />
            MAKEABSOLUTE = 337,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MAKERELATIVE"]/*' />
            MAKERELATIVE = 338,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MAKESTATIC"]/*' />
            MAKESTATIC = 339,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTLAYER"]/*' />
            INSERTLAYER = 340,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UPDATEDESIGNVIEW"]/*' />
            UPDATEDESIGNVIEW = 341,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UPDATESOURCEVIEW"]/*' />
            UPDATESOURCEVIEW = 342,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTCAPTION"]/*' />
            INSERTCAPTION = 343,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETECAPTION"]/*' />
            DELETECAPTION = 344,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MAKEPOSITIONNOTSET"]/*' />
            MAKEPOSITIONNOTSET = 345,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOPOSITIONOPTIONS"]/*' />
            AUTOPOSITIONOPTIONS = 346,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITIMAGE"]/*' />
            EDITIMAGE = 347,
            //
            // Shareable commands originating in the VC project
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMPILE"]/*' />
            COMPILE = 350,
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROJSETTINGS"]/*' />
            PROJSETTINGS = 352,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINKONLY"]/*' />
            LINKONLY = 353,
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REMOVE"]/*' />
            REMOVE = 355,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROJSTARTDEBUG"]/*' />
            PROJSTARTDEBUG = 356,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROJSTEPINTO"]/*' />
            PROJSTEPINTO = 357,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_UPDATEMGDRES"]/*' />
            ECMD_UPDATEMGDRES = 358,
            //
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UPDATEWEBREF"]/*' />
            UPDATEWEBREF = 360,
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDRESOURCE"]/*' />
            ADDRESOURCE = 362,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WEBDEPLOY"]/*' />
            WEBDEPLOY = 363,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_PROJTOOLORDER"]/*' />
            ECMD_PROJTOOLORDER = 367,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_PROJECTTOOLFILES"]/*' />
            ECMD_PROJECTTOOLFILES = 368,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_OTB_PGO_INSTRUMENT"]/*' />
            ECMD_OTB_PGO_INSTRUMENT = 369,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_OTB_PGO_OPT"]/*' />
            ECMD_OTB_PGO_OPT = 370,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_OTB_PGO_UPDATE"]/*' />
            ECMD_OTB_PGO_UPDATE = 371,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_OTB_PGO_RUNSCENARIO"]/*' />
            ECMD_OTB_PGO_RUNSCENARIO = 372,

            //
            // Shareable commands originating in the VB and VBA projects
            // Note that there are two versions of each command. One
            // version is originally from the main (project) menu and the
            // other version from a cascading "Add" context menu. The main
            // difference between the two commands is that the main menu
            // version starts with the text "Add" whereas this is not
            // present on the context menu version.
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDHTMLPAGE"]/*' />
            ADDHTMLPAGE = 400,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDHTMLPAGECTX"]/*' />
            ADDHTMLPAGECTX = 401,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDMODULE"]/*' />
            ADDMODULE = 402,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDMODULECTX"]/*' />
            ADDMODULECTX = 403,
            // unused 404
            // unused 405
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDWFCFORM"]/*' />
            ADDWFCFORM = 406,
            // unused 407
            // unused 408
            // unused 409
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDWEBFORM"]/*' />
            ADDWEBFORM = 410,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDMASTERPAGE"]/*' />
            ECMD_ADDMASTERPAGE = 411,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDUSERCONTROL"]/*' />
            ADDUSERCONTROL = 412,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDCONTENTPAGE"]/*' />
            ECMD_ADDCONTENTPAGE = 413,
            // unused 414 to 425
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDDHTMLPAGE"]/*' />
            ADDDHTMLPAGE = 426,
            // unused 427 to 431
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDIMAGEGENERATOR"]/*' />
            ADDIMAGEGENERATOR = 432,
            // unused 433
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDINHERWFCFORM"]/*' />
            ADDINHERWFCFORM = 434,
            // unused 435
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDINHERCONTROL"]/*' />
            ADDINHERCONTROL = 436,
            // unused 437
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDWEBUSERCONTROL"]/*' />
            ADDWEBUSERCONTROL = 438,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BUILDANDBROWSE"]/*' />
            BUILDANDBROWSE = 439,
            // unused 440
            // unused 441
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDTBXCOMPONENT"]/*' />
            ADDTBXCOMPONENT = 442,
            // unused 443
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDWEBSERVICE"]/*' />
            ADDWEBSERVICE = 444,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDSTYLESHEET"]/*' />
            ECMD_ADDSTYLESHEET = 445,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_SETBROWSELOCATION"]/*' />
            ECMD_SETBROWSELOCATION = 446,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_REFRESHFOLDER"]/*' />
            ECMD_REFRESHFOLDER = 447,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_SETBROWSELOCATIONCTX"]/*' />
            ECMD_SETBROWSELOCATIONCTX = 448,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_VIEWMARKUP"]/*' />
            ECMD_VIEWMARKUP = 449,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_NEXTMETHOD"]/*' />
            ECMD_NEXTMETHOD = 450,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_PREVMETHOD"]/*' />
            ECMD_PREVMETHOD = 451,
            //
            // VB refactoring commands
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_RENAMESYMBOL"]/*' />
            ECMD_RENAMESYMBOL = 452,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_SHOWREFERENCES"]/*' />
            ECMD_SHOWREFERENCES = 453,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CREATESNIPPET"]/*' />
            ECMD_CREATESNIPPET = 454,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CREATEREPLACEMENT"]/*' />
            ECMD_CREATEREPLACEMENT = 455,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_INSERTCOMMENT"]/*' />
            ECMD_INSERTCOMMENT = 456,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWCOMPONENTDESIGNER"]/*' />   
            VIEWCOMPONENTDESIGNER = 457,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOTOTYPEDEF"]/*' />   
            GOTOTYPEDEF = 458,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWSNIPPETHIGHLIGHTING"]/*' />   
            SHOWSNIPPETHIGHLIGHTING = 459,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HIDESNIPPETHIGHLIGHTING"]/*' />   
            HIDESNIPPETHIGHLIGHTING = 460,
            //
            // Shareable commands originating in the VFP project
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDVFPPAGE"]/*' />
            ADDVFPPAGE = 500,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETBREAKPOINT"]/*' />
            SETBREAKPOINT = 501,
            //
            // Shareable commands originating in the HELP WORKSHOP project
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWALLFILES"]/*' />
            SHOWALLFILES = 600,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDTOPROJECT"]/*' />
            ADDTOPROJECT = 601,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDBLANKNODE"]/*' />
            ADDBLANKNODE = 602,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDNODEFROMFILE"]/*' />
            ADDNODEFROMFILE = 603,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CHANGEURLFROMFILE"]/*' />
            CHANGEURLFROMFILE = 604,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITTOPIC"]/*' />
            EDITTOPIC = 605,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITTITLE"]/*' />
            EDITTITLE = 606,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MOVENODEUP"]/*' />
            MOVENODEUP = 607,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MOVENODEDOWN"]/*' />
            MOVENODEDOWN = 608,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MOVENODELEFT"]/*' />
            MOVENODELEFT = 609,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MOVENODERIGHT"]/*' />
            MOVENODERIGHT = 610,
            //
            // Shareable commands originating in the Deploy project
            //
            // Note there are two groups of deploy project commands.
            // The first group of deploy commands.
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDOUTPUT"]/*' />
            ADDOUTPUT = 700,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDFILE"]/*' />
            ADDFILE = 701,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MERGEMODULE"]/*' />
            MERGEMODULE = 702,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDCOMPONENTS"]/*' />
            ADDCOMPONENTS = 703,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LAUNCHINSTALLER"]/*' />
            LAUNCHINSTALLER = 704,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LAUNCHUNINSTALL"]/*' />
            LAUNCHUNINSTALL = 705,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LAUNCHORCA"]/*' />
            LAUNCHORCA = 706,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILESYSTEMEDITOR"]/*' />
            FILESYSTEMEDITOR = 707,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REGISTRYEDITOR"]/*' />
            REGISTRYEDITOR = 708,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILETYPESEDITOR"]/*' />
            FILETYPESEDITOR = 709,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERINTERFACEEDITOR"]/*' />
            USERINTERFACEEDITOR = 710,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CUSTOMACTIONSEDITOR"]/*' />
            CUSTOMACTIONSEDITOR = 711,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LAUNCHCONDITIONSEDITOR"]/*' />
            LAUNCHCONDITIONSEDITOR = 712,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITOR"]/*' />
            EDITOR = 713,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXCLUDE"]/*' />
            EXCLUDE = 714,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REFRESHDEPENDENCIES"]/*' />
            REFRESHDEPENDENCIES = 715,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWOUTPUTS"]/*' />
            VIEWOUTPUTS = 716,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWDEPENDENCIES"]/*' />
            VIEWDEPENDENCIES = 717,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWFILTER"]/*' />
            VIEWFILTER = 718,

            //
            // The Second group of deploy commands.
            // Note that there is a special sub-group in which the relative 
            // positions are important (see below)
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.KEY"]/*' />
            KEY = 750,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STRING"]/*' />
            STRING = 751,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BINARY"]/*' />
            BINARY = 752,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DWORD"]/*' />
            DWORD = 753,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.KEYSOLO"]/*' />
            KEYSOLO = 754,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPORT"]/*' />
            IMPORT = 755,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FOLDER"]/*' />
            FOLDER = 756,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROJECTOUTPUT"]/*' />
            PROJECTOUTPUT = 757,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILE"]/*' />
            FILE = 758,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDMERGEMODULES"]/*' />
            ADDMERGEMODULES = 759,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CREATESHORTCUT"]/*' />
            CREATESHORTCUT = 760,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LARGEICONS"]/*' />
            LARGEICONS = 761,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SMALLICONS"]/*' />
            SMALLICONS = 762,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LIST"]/*' />
            LIST = 763,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DETAILS"]/*' />
            DETAILS = 764,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDFILETYPE"]/*' />
            ADDFILETYPE = 765,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDACTION"]/*' />
            ADDACTION = 766,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETASDEFAULT"]/*' />
            SETASDEFAULT = 767,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MOVEUP"]/*' />
            MOVEUP = 768,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MOVEDOWN"]/*' />
            MOVEDOWN = 769,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDDIALOG"]/*' />
            ADDDIALOG = 770,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPORTDIALOG"]/*' />
            IMPORTDIALOG = 771,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDFILESEARCH"]/*' />
            ADDFILESEARCH = 772,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDREGISTRYSEARCH"]/*' />
            ADDREGISTRYSEARCH = 773,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDCOMPONENTSEARCH"]/*' />
            ADDCOMPONENTSEARCH = 774,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDLAUNCHCONDITION"]/*' />
            ADDLAUNCHCONDITION = 775,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDCUSTOMACTION"]/*' />
            ADDCUSTOMACTION = 776,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTPUTS"]/*' />
            OUTPUTS = 777,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DEPENDENCIES"]/*' />
            DEPENDENCIES = 778,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILTER"]/*' />
            FILTER = 779,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMPONENTS"]/*' />
            COMPONENTS = 780,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ENVSTRING"]/*' />
            ENVSTRING = 781,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CREATEEMPTYSHORTCUT"]/*' />
            CREATEEMPTYSHORTCUT = 782,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDFILECONDITION"]/*' />
            ADDFILECONDITION = 783,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDREGISTRYCONDITION"]/*' />
            ADDREGISTRYCONDITION = 784,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDCOMPONENTCONDITION"]/*' />
            ADDCOMPONENTCONDITION = 785,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDURTCONDITION"]/*' />
            ADDURTCONDITION = 786,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDIISCONDITION"]/*' />
            ADDIISCONDITION = 787,

            //
            // The relative positions of the commands within the following deploy
            // subgroup must remain unaltered, although the group as a whole may
            // be repositioned. Note that the first and last elements are special
            // boundary elements.
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPECIALFOLDERBASE"]/*' />
            SPECIALFOLDERBASE = 800,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSAPPLICATIONDATAFOLDER"]/*' />
            USERSAPPLICATIONDATAFOLDER = 800,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMMONFILES64FOLDER"]/*' />
            COMMONFILES64FOLDER = 801,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMMONFILESFOLDER"]/*' />
            COMMONFILESFOLDER = 802,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CUSTOMFOLDER"]/*' />
            CUSTOMFOLDER = 803,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSDESKTOP"]/*' />
            USERSDESKTOP = 804,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSFAVORITESFOLDER"]/*' />
            USERSFAVORITESFOLDER = 805,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FONTSFOLDER"]/*' />
            FONTSFOLDER = 806,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GLOBALASSEMBLYCACHEFOLDER"]/*' />
            GLOBALASSEMBLYCACHEFOLDER = 807,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MODULERETARGETABLEFOLDER"]/*' />
            MODULERETARGETABLEFOLDER = 808,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSPERSONALDATAFOLDER"]/*' />
            USERSPERSONALDATAFOLDER = 809,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROGRAMFILES64FOLDER"]/*' />
            PROGRAMFILES64FOLDER = 810,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROGRAMFILESFOLDER"]/*' />
            PROGRAMFILESFOLDER = 811,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSPROGRAMSMENU"]/*' />
            USERSPROGRAMSMENU = 812,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSSENDTOMENU"]/*' />
            USERSSENDTOMENU = 813,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHAREDCOMPONENTSFOLDER"]/*' />
            SHAREDCOMPONENTSFOLDER = 814,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSSTARTMENU"]/*' />
            USERSSTARTMENU = 815,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSSTARTUPFOLDER"]/*' />
            USERSSTARTUPFOLDER = 816,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SYSTEM64FOLDER"]/*' />
            SYSTEM64FOLDER = 817,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SYSTEMFOLDER"]/*' />
            SYSTEMFOLDER = 818,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.APPLICATIONFOLDER"]/*' />
            APPLICATIONFOLDER = 819,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSTEMPLATEFOLDER"]/*' />
            USERSTEMPLATEFOLDER = 820,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WEBCUSTOMFOLDER"]/*' />
            WEBCUSTOMFOLDER = 821,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WINDOWSFOLDER"]/*' />
            WINDOWSFOLDER = 822,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPECIALFOLDERLAST"]/*' />
            SPECIALFOLDERLAST = 823,
            // End of deploy sub-group
            //
            // Shareable commands originating in the Visual Studio Analyzer project
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXPORTEVENTS"]/*' />
            EXPORTEVENTS = 900,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPORTEVENTS"]/*' />
            IMPORTEVENTS = 901,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWEVENT"]/*' />
            VIEWEVENT = 902,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWEVENTLIST"]/*' />
            VIEWEVENTLIST = 903,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWCHART"]/*' />
            VIEWCHART = 904,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWMACHINEDIAGRAM"]/*' />
            VIEWMACHINEDIAGRAM = 905,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWPROCESSDIAGRAM"]/*' />
            VIEWPROCESSDIAGRAM = 906,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWSOURCEDIAGRAM"]/*' />
            VIEWSOURCEDIAGRAM = 907,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWSTRUCTUREDIAGRAM"]/*' />
            VIEWSTRUCTUREDIAGRAM = 908,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWTIMELINE"]/*' />
            VIEWTIMELINE = 909,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWSUMMARY"]/*' />
            VIEWSUMMARY = 910,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.APPLYFILTER"]/*' />
            APPLYFILTER = 911,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CLEARFILTER"]/*' />
            CLEARFILTER = 912,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STARTRECORDING"]/*' />
            STARTRECORDING = 913,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STOPRECORDING"]/*' />
            STOPRECORDING = 914,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PAUSERECORDING"]/*' />
            PAUSERECORDING = 915,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ACTIVATEFILTER"]/*' />
            ACTIVATEFILTER = 916,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWFIRSTEVENT"]/*' />
            SHOWFIRSTEVENT = 917,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWPREVIOUSEVENT"]/*' />
            SHOWPREVIOUSEVENT = 918,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWNEXTEVENT"]/*' />
            SHOWNEXTEVENT = 919,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWLASTEVENT"]/*' />
            SHOWLASTEVENT = 920,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REPLAYEVENTS"]/*' />
            REPLAYEVENTS = 921,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STOPREPLAY"]/*' />
            STOPREPLAY = 922,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INCREASEPLAYBACKSPEED"]/*' />
            INCREASEPLAYBACKSPEED = 923,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DECREASEPLAYBACKSPEED"]/*' />
            DECREASEPLAYBACKSPEED = 924,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDMACHINE"]/*' />
            ADDMACHINE = 925,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDREMOVECOLUMNS"]/*' />
            ADDREMOVECOLUMNS = 926,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SORTCOLUMNS"]/*' />
            SORTCOLUMNS = 927,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SAVECOLUMNSETTINGS"]/*' />
            SAVECOLUMNSETTINGS = 928,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESETCOLUMNSETTINGS"]/*' />
            RESETCOLUMNSETTINGS = 929,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SIZECOLUMNSTOFIT"]/*' />
            SIZECOLUMNSTOFIT = 930,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOSELECT"]/*' />
            AUTOSELECT = 931,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOFILTER"]/*' />
            AUTOFILTER = 932,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOPLAYTRACK"]/*' />
            AUTOPLAYTRACK = 933,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOTOEVENT"]/*' />
            GOTOEVENT = 934,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOMTOFIT"]/*' />
            ZOOMTOFIT = 935,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDGRAPH"]/*' />
            ADDGRAPH = 936,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REMOVEGRAPH"]/*' />
            REMOVEGRAPH = 937,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CONNECTMACHINE"]/*' />
            CONNECTMACHINE = 938,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DISCONNECTMACHINE"]/*' />
            DISCONNECTMACHINE = 939,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXPANDSELECTION"]/*' />
            EXPANDSELECTION = 940,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COLLAPSESELECTION"]/*' />
            COLLAPSESELECTION = 941,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDFILTER"]/*' />
            ADDFILTER = 942,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED0"]/*' />
            ADDPREDEFINED0 = 943,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED1"]/*' />
            ADDPREDEFINED1 = 944,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED2"]/*' />
            ADDPREDEFINED2 = 945,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED3"]/*' />
            ADDPREDEFINED3 = 946,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED4"]/*' />
            ADDPREDEFINED4 = 947,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED5"]/*' />
            ADDPREDEFINED5 = 948,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED6"]/*' />
            ADDPREDEFINED6 = 949,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED7"]/*' />
            ADDPREDEFINED7 = 950,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED8"]/*' />
            ADDPREDEFINED8 = 951,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TIMELINESIZETOFIT"]/*' />
            TIMELINESIZETOFIT = 952,

            //
            // Shareable commands originating with Crystal Reports
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FIELDVIEW"]/*' />
            FIELDVIEW = 1000,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTEXPERT"]/*' />
            SELECTEXPERT = 1001,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOPNEXPERT"]/*' />
            TOPNEXPERT = 1002,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SORTORDER"]/*' />
            SORTORDER = 1003,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROPPAGE"]/*' />
            PROPPAGE = 1004,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HELP"]/*' />
            HELP = 1005,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SAVEREPORT"]/*' />
            SAVEREPORT = 1006,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTSUMMARY"]/*' />
            INSERTSUMMARY = 1007,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTGROUP"]/*' />
            INSERTGROUP = 1008,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTSUBREPORT"]/*' />
            INSERTSUBREPORT = 1009,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTCHART"]/*' />
            INSERTCHART = 1010,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTPICTURE"]/*' />
            INSERTPICTURE = 1011,
            //
            // Shareable commands from the common project area (DirPrj)
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETASSTARTPAGE"]/*' />
            SETASSTARTPAGE = 1100,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RECALCULATELINKS"]/*' />
            RECALCULATELINKS = 1101,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WEBPERMISSIONS"]/*' />
            WEBPERMISSIONS = 1102,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMPARETOMASTER"]/*' />
            COMPARETOMASTER = 1103,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORKOFFLINE"]/*' />
            WORKOFFLINE = 1104,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SYNCHRONIZEFOLDER"]/*' />
            SYNCHRONIZEFOLDER = 1105,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SYNCHRONIZEALLFOLDERS"]/*' />
            SYNCHRONIZEALLFOLDERS = 1106,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COPYPROJECT"]/*' />
            COPYPROJECT = 1107,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPORTFILEFROMWEB"]/*' />
            IMPORTFILEFROMWEB = 1108,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INCLUDEINPROJECT"]/*' />
            INCLUDEINPROJECT = 1109,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXCLUDEFROMPROJECT"]/*' />
            EXCLUDEFROMPROJECT = 1110,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BROKENLINKSREPORT"]/*' />
            BROKENLINKSREPORT = 1111,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPROJECTOUTPUTS"]/*' />
            ADDPROJECTOUTPUTS = 1112,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDREFERENCE"]/*' />
            ADDREFERENCE = 1113,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDWEBREFERENCE"]/*' />
            ADDWEBREFERENCE = 1114,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDWEBREFERENCECTX"]/*' />
            ADDWEBREFERENCECTX = 1115,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UPDATEWEBREFERENCE"]/*' />
            UPDATEWEBREFERENCE = 1116,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RUNCUSTOMTOOL"]/*' />
            RUNCUSTOMTOOL = 1117,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETRUNTIMEVERSION"]/*' />
            SETRUNTIMEVERSION = 1118,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWREFINOBJECTBROWSER"]/*' />
            VIEWREFINOBJECTBROWSER = 1119,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PUBLISH"]/*' />
            PUBLISH = 1120,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PUBLISHCTX"]/*' />
            PUBLISHCTX = 1121,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STARTOPTIONS"]/*' />
            STARTOPTIONS = 1124,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDREFERENCECTX"]/*' />
            ADDREFERENCECTX = 1125,
            // note cmdidPropertyManager is consuming 1126  and it shouldn't
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STARTOPTIONSCTX"]/*' />
            STARTOPTIONSCTX = 1127,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DETACHLOCALDATAFILECTX"]/*' />
            DETACHLOCALDATAFILECTX = 1128,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDSERVICEREFERENCE"]/*' />
            ADDSERVICEREFERENCE = 1129,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDSERVICEREFERENCECTX"]/*' />
            ADDSERVICEREFERENCECTX = 1130,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UPDATESERVICEREFERENCE"]/*' />
            UPDATESERVICEREFERENCE = 1131,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CONFIGURESERVICEREFERENCE"]/*' />
            CONFIGURESERVICEREFERENCE = 1132,
            //
            // Shareable commands for right drag operations
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DRAG_MOVE"]/*' />
            DRAG_MOVE = 1140,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DRAG_COPY"]/*' />
            DRAG_COPY = 1141,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DRAG_CANCEL"]/*' />
            DRAG_CANCEL = 1142,

            //
            // Shareable commands from the VC resource editor
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TESTDIALOG"]/*' />
            TESTDIALOG = 1200,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPACEACROSS"]/*' />
            SPACEACROSS = 1201,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPACEDOWN"]/*' />
            SPACEDOWN = 1202,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLEGRID"]/*' />
            TOGGLEGRID = 1203,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLEGUIDES"]/*' />
            TOGGLEGUIDES = 1204,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SIZETOTEXT"]/*' />
            SIZETOTEXT = 1205,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CENTERVERT"]/*' />
            CENTERVERT = 1206,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CENTERHORZ"]/*' />
            CENTERHORZ = 1207,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FLIPDIALOG"]/*' />
            FLIPDIALOG = 1208,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETTABORDER"]/*' />
            SETTABORDER = 1209,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BUTTONRIGHT"]/*' />
            BUTTONRIGHT = 1210,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BUTTONBOTTOM"]/*' />
            BUTTONBOTTOM = 1211,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOLAYOUTGROW"]/*' />
            AUTOLAYOUTGROW = 1212,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOLAYOUTNORESIZE"]/*' />
            AUTOLAYOUTNORESIZE = 1213,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOLAYOUTOPTIMIZE"]/*' />
            AUTOLAYOUTOPTIMIZE = 1214,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GUIDESETTINGS"]/*' />
            GUIDESETTINGS = 1215,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESOURCEINCLUDES"]/*' />
            RESOURCEINCLUDES = 1216,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESOURCESYMBOLS"]/*' />
            RESOURCESYMBOLS = 1217,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPENBINARY"]/*' />
            OPENBINARY = 1218,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESOURCEOPEN"]/*' />
            RESOURCEOPEN = 1219,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESOURCENEW"]/*' />
            RESOURCENEW = 1220,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESOURCENEWCOPY"]/*' />
            RESOURCENEWCOPY = 1221,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERT"]/*' />
            INSERT = 1222,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXPORT"]/*' />
            EXPORT = 1223,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVELEFT"]/*' />
            CTLMOVELEFT = 1224,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVEDOWN"]/*' />
            CTLMOVEDOWN = 1225,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVERIGHT"]/*' />
            CTLMOVERIGHT = 1226,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVEUP"]/*' />
            CTLMOVEUP = 1227,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZEDOWN"]/*' />
            CTLSIZEDOWN = 1228,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZEUP"]/*' />
            CTLSIZEUP = 1229,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZELEFT"]/*' />
            CTLSIZELEFT = 1230,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZERIGHT"]/*' />
            CTLSIZERIGHT = 1231,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWACCELERATOR"]/*' />
            NEWACCELERATOR = 1232,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CAPTUREKEYSTROKE"]/*' />
            CAPTUREKEYSTROKE = 1233,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTACTIVEXCTL"]/*' />
            INSERTACTIVEXCTL = 1234,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INVERTCOLORS"]/*' />
            INVERTCOLORS = 1235,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FLIPHORIZONTAL"]/*' />
            FLIPHORIZONTAL = 1236,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FLIPVERTICAL"]/*' />
            FLIPVERTICAL = 1237,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ROTATE90"]/*' />
            ROTATE90 = 1238,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWCOLORSWINDOW"]/*' />
            SHOWCOLORSWINDOW = 1239,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWSTRING"]/*' />
            NEWSTRING = 1240,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWINFOBLOCK"]/*' />
            NEWINFOBLOCK = 1241,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEINFOBLOCK"]/*' />
            DELETEINFOBLOCK = 1242,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADJUSTCOLORS"]/*' />
            ADJUSTCOLORS = 1243,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LOADPALETTE"]/*' />
            LOADPALETTE = 1244,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SAVEPALETTE"]/*' />
            SAVEPALETTE = 1245,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CHECKMNEMONICS"]/*' />
            CHECKMNEMONICS = 1246,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DRAWOPAQUE"]/*' />
            DRAWOPAQUE = 1247,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOOLBAREDITOR"]/*' />
            TOOLBAREDITOR = 1248,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GRIDSETTINGS"]/*' />
            GRIDSETTINGS = 1249,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWDEVICEIMAGE"]/*' />
            NEWDEVICEIMAGE = 1250,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPENDEVICEIMAGE"]/*' />
            OPENDEVICEIMAGE = 1251,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEDEVICEIMAGE"]/*' />
            DELETEDEVICEIMAGE = 1252,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWASPOPUP"]/*' />
            VIEWASPOPUP = 1253,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CHECKMENUMNEMONICS"]/*' />
            CHECKMENUMNEMONICS = 1254,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWIMAGEGRID"]/*' />
            SHOWIMAGEGRID = 1255,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWTILEGRID"]/*' />
            SHOWTILEGRID = 1256,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MAGNIFY"]/*' />
            MAGNIFY = 1257,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ResProps"]/*' />
            ResProps = 1258,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPORTICONIMAGE"]/*' />
            IMPORTICONIMAGE = 1259,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXPORTICONIMAGE"]/*' />
            EXPORTICONIMAGE = 1260,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPENEXTERNALEDITOR"]/*' />
            OPENEXTERNALEDITOR = 1261,

            //
            // Shareable commands from the VC resource editor (Image editor toolbar)
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PICKRECTANGLE"]/*' />
            PICKRECTANGLE = 1300,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PICKREGION"]/*' />
            PICKREGION = 1301,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PICKCOLOR"]/*' />
            PICKCOLOR = 1302,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ERASERTOOL"]/*' />
            ERASERTOOL = 1303,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILLTOOL"]/*' />
            FILLTOOL = 1304,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PENCILTOOL"]/*' />
            PENCILTOOL = 1305,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BRUSHTOOL"]/*' />
            BRUSHTOOL = 1306,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AIRBRUSHTOOL"]/*' />
            AIRBRUSHTOOL = 1307,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINETOOL"]/*' />
            LINETOOL = 1308,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CURVETOOL"]/*' />
            CURVETOOL = 1309,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TEXTTOOL"]/*' />
            TEXTTOOL = 1310,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RECTTOOL"]/*' />
            RECTTOOL = 1311,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLINERECTTOOL"]/*' />
            OUTLINERECTTOOL = 1312,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILLEDRECTTOOL"]/*' />
            FILLEDRECTTOOL = 1313,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ROUNDRECTTOOL"]/*' />
            ROUNDRECTTOOL = 1314,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLINEROUNDRECTTOOL"]/*' />
            OUTLINEROUNDRECTTOOL = 1315,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILLEDROUNDRECTTOOL"]/*' />
            FILLEDROUNDRECTTOOL = 1316,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ELLIPSETOOL"]/*' />
            ELLIPSETOOL = 1317,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLINEELLIPSETOOL"]/*' />
            OUTLINEELLIPSETOOL = 1318,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILLEDELLIPSETOOL"]/*' />
            FILLEDELLIPSETOOL = 1319,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETHOTSPOT"]/*' />
            SETHOTSPOT = 1320,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOMTOOL"]/*' />
            ZOOMTOOL = 1321,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOM1X"]/*' />
            ZOOM1X = 1322,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOM2X"]/*' />
            ZOOM2X = 1323,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOM6X"]/*' />
            ZOOM6X = 1324,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOM8X"]/*' />
            ZOOM8X = 1325,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TRANSPARENTBCKGRND"]/*' />
            TRANSPARENTBCKGRND = 1326,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPAQUEBCKGRND"]/*' />
            OPAQUEBCKGRND = 1327,
            //---------------------------------------------------
            // The commands ECMD_ERASERSMALL thru ECMD_LINELARGER
            // must be left in the same order for the use of the
            // Resource Editor - They may however be relocated as
            // a complete block
            //---------------------------------------------------
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ERASERSMALL"]/*' />
            ERASERSMALL = 1328,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ERASERMEDIUM"]/*' />
            ERASERMEDIUM = 1329,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ERASERLARGE"]/*' />
            ERASERLARGE = 1330,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ERASERLARGER"]/*' />
            ERASERLARGER = 1331,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CIRCLELARGE"]/*' />
            CIRCLELARGE = 1332,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CIRCLEMEDIUM"]/*' />
            CIRCLEMEDIUM = 1333,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CIRCLESMALL"]/*' />
            CIRCLESMALL = 1334,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SQUARELARGE"]/*' />
            SQUARELARGE = 1335,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SQUAREMEDIUM"]/*' />
            SQUAREMEDIUM = 1336,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SQUARESMALL"]/*' />
            SQUARESMALL = 1337,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFTDIAGLARGE"]/*' />
            LEFTDIAGLARGE = 1338,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFTDIAGMEDIUM"]/*' />
            LEFTDIAGMEDIUM = 1339,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFTDIAGSMALL"]/*' />
            LEFTDIAGSMALL = 1340,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RIGHTDIAGLARGE"]/*' />
            RIGHTDIAGLARGE = 1341,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RIGHTDIAGMEDIUM"]/*' />
            RIGHTDIAGMEDIUM = 1342,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RIGHTDIAGSMALL"]/*' />
            RIGHTDIAGSMALL = 1343,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPLASHSMALL"]/*' />
            SPLASHSMALL = 1344,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPLASHMEDIUM"]/*' />
            SPLASHMEDIUM = 1345,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPLASHLARGE"]/*' />
            SPLASHLARGE = 1346,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINESMALLER"]/*' />
            LINESMALLER = 1347,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINESMALL"]/*' />
            LINESMALL = 1348,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINEMEDIUM"]/*' />
            LINEMEDIUM = 1349,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINELARGE"]/*' />
            LINELARGE = 1350,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINELARGER"]/*' />
            LINELARGER = 1351,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LARGERBRUSH"]/*' />
            LARGERBRUSH = 1352,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LARGEBRUSH"]/*' />
            LARGEBRUSH = 1353,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STDBRUSH"]/*' />
            STDBRUSH = 1354,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SMALLBRUSH"]/*' />
            SMALLBRUSH = 1355,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SMALLERBRUSH"]/*' />
            SMALLERBRUSH = 1356,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOMIN"]/*' />
            ZOOMIN = 1357,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOMOUT"]/*' />
            ZOOMOUT = 1358,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PREVCOLOR"]/*' />
            PREVCOLOR = 1359,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PREVECOLOR"]/*' />
            PREVECOLOR = 1360,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEXTCOLOR"]/*' />
            NEXTCOLOR = 1361,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEXTECOLOR"]/*' />
            NEXTECOLOR = 1362,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMG_OPTIONS"]/*' />
            IMG_OPTIONS = 1363,

            //
            // Sharable Commands from Visual Web Developer (website projects)
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STARTWEBADMINTOOL"]/*' />
            STARTWEBADMINTOOL = 1400,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NESTRELATEDFILES"]/*' />
            NESTRELATEDFILES = 1401,

            //---------------------------------------------------

            //
            // Shareable commands from WINFORMS
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CANCELDRAG"]/*' />
            CANCELDRAG = 1500,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DEFAULTACTION"]/*' />
            DEFAULTACTION = 1501,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVEUPGRID"]/*' />
            CTLMOVEUPGRID = 1502,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVEDOWNGRID"]/*' />
            CTLMOVEDOWNGRID = 1503,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVELEFTGRID"]/*' />
            CTLMOVELEFTGRID = 1504,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVERIGHTGRID"]/*' />
            CTLMOVERIGHTGRID = 1505,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZERIGHTGRID"]/*' />
            CTLSIZERIGHTGRID = 1506,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZEUPGRID"]/*' />
            CTLSIZEUPGRID = 1507,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZELEFTGRID"]/*' />
            CTLSIZELEFTGRID = 1508,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZEDOWNGRID"]/*' />
            CTLSIZEDOWNGRID = 1509,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEXTCTL"]/*' />
            NEXTCTL = 1510,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PREVCTL"]/*' />
            PREVCTL = 1511,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RENAME"]/*' />
            RENAME = 1550,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXTRACTMETHOD"]/*' />
            EXTRACTMETHOD = 1551,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ENCAPSULATEFIELD"]/*' />
            ENCAPSULATEFIELD = 1552,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXTRACTINTERFACE"]/*' />
            EXTRACTINTERFACE = 1553,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROMOTELOCAL"]/*' />
            PROMOTELOCAL = 1554,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REMOVEPARAMETERS"]/*' />
            REMOVEPARAMETERS = 1555,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REORDERPARAMETERS"]/*' />
            REORDERPARAMETERS = 1556,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GENERATEMETHODSTUB"]/*' />
            GENERATEMETHODSTUB = 1557,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPLEMENTINTERFACEIMPLICIT"]/*' />
            IMPLEMENTINTERFACEIMPLICIT = 1558,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPLEMENTINTERFACEEXPLICIT"]/*' />
            IMPLEMENTINTERFACEEXPLICIT = 1559,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPLEMENTABSTRACTCLASS"]/*' />
            IMPLEMENTABSTRACTCLASS = 1560,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SURROUNDWITH"]/*' />
            SURROUNDWITH = 1561,

            // this is coming in with the VS2K guid?
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.QUICKOBJECTSEARCH"]/*' />
            QUICKOBJECTSEARCH = 1119,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ToggleWordWrapOW"]/*' />
            ToggleWordWrapOW = 1600,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoNextLocationOW"]/*' />
            GotoNextLocationOW = 1601,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoPrevLocationOW"]/*' />
            GotoPrevLocationOW = 1602,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BuildOnlyProject"]/*' />
            BuildOnlyProject = 1603,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RebuildOnlyProject"]/*' />
            RebuildOnlyProject = 1604,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CleanOnlyProject"]/*' />
            CleanOnlyProject = 1605,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SetBuildStartupsOnlyOnRun"]/*' />
            SetBuildStartupsOnlyOnRun = 1606,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UnhideAll"]/*' />
            UnhideAll = 1607,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HideFolder"]/*' />
            HideFolder = 1608,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UnhideFolders"]/*' />
            UnhideFolders = 1609,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CopyFullPathName"]/*' />
            CopyFullPathName = 1610,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SaveFolderAsSolution"]/*' />
            SaveFolderAsSolution = 1611,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ManageUserSettings"]/*' />
            ManageUserSettings = 1612,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewSolutionFolder"]/*' />
            NewSolutionFolder = 1613,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ClearPaneOW"]/*' />
            ClearPaneOW = 1615,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoErrorTagOW"]/*' />
            GotoErrorTagOW = 1616,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoNextErrorTagOW"]/*' />
            GotoNextErrorTagOW = 1617,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoPrevErrorTagOW"]/*' />
            GotoPrevErrorTagOW = 1618,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ClearPaneFR1"]/*' />
            ClearPaneFR1 = 1619,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoErrorTagFR1"]/*' />
            GotoErrorTagFR1 = 1620,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoNextErrorTagFR1"]/*' />
            GotoNextErrorTagFR1 = 1621,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoPrevErrorTagFR1"]/*' />
            GotoPrevErrorTagFR1 = 1622,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ClearPaneFR2"]/*' />
            ClearPaneFR2 = 1623,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoErrorTagFR2"]/*' />
            GotoErrorTagFR2 = 1624,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoNextErrorTagFR2"]/*' />
            GotoNextErrorTagFR2 = 1625,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoPrevErrorTagFR2"]/*' />
            GotoPrevErrorTagFR2 = 1626,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OutputPaneCombo"]/*' />
            OutputPaneCombo = 1627,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OutputPaneComboList"]/*' />
            OutputPaneComboList = 1628,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DisableDockingChanges"]/*' />
            DisableDockingChanges = 1629,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ToggleFloat"]/*' />
            ToggleFloat = 1630,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ResetLayout"]/*' />
            ResetLayout = 1631,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewSolutionFolderBar"]/*' />
            NewSolutionFolderBar = 1638,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DataShortcut"]/*' />
            DataShortcut = 1639,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NextToolWindow"]/*' />
            NextToolWindow = 1640,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PrevToolWindow"]/*' />
            PrevToolWindow = 1641,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BrowseToFileInExplorer"]/*' />
            BrowseToFileInExplorer = 1642,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ShowEzMDIFileMenu"]/*' />
            ShowEzMDIFileMenu = 1643,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PrevToolWindowNav"]/*' />
            PrevToolWindowNav = 1645,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.StaticAnalysisOnlyProject"]/*' />
            StaticAnalysisOnlyProject = 1646,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_RUNFXCOPSEL"]/*' />
            ECMD_RUNFXCOPSEL = 1647,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CloseAllButThis"]/*' />
            CloseAllButThis = 1650,
            //
            // Class View commands
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVShowInheritedMembers"]/*' />
            CVShowInheritedMembers = 1651,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVShowBaseTypes"]/*' />
            CVShowBaseTypes = 1652,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVShowDerivedTypes"]/*' />
            CVShowDerivedTypes = 1653,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVShowHidden"]/*' />
            CVShowHidden = 1654,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVBack"]/*' />
            CVBack = 1655,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVForward"]/*' />
            CVForward = 1656,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVSearchCombo"]/*' />
            CVSearchCombo = 1657,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVSearch"]/*' />
            CVSearch = 1658,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVSortObjectsAlpha"]/*' />
            CVSortObjectsAlpha = 1659,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVSortObjectsType"]/*' />
            CVSortObjectsType = 1660,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVSortObjectsAccess"]/*' />
            CVSortObjectsAccess = 1661,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVGroupObjectsType"]/*' />
            CVGroupObjectsType = 1662,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVSortMembersAlpha"]/*' />
            CVSortMembersAlpha = 1663,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVSortMembersType"]/*' />
            CVSortMembersType = 1664,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVSortMembersAccess"]/*' />
            CVSortMembersAccess = 1665,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVTypeBrowserSettings"]/*' />
            CVTypeBrowserSettings = 1666,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVViewMembersAsImplementor"]/*' />
            CVViewMembersAsImplementor = 1667,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVViewMembersAsSubclass"]/*' />
            CVViewMembersAsSubclass = 1668,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVViewMembersAsUser"]/*' />
            CVViewMembersAsUser = 1669,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVReserved1"]/*' />
            CVReserved1 = 1670,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVReserved2"]/*' />
            CVReserved2 = 1671,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVShowProjectReferences"]/*' />
            CVShowProjectReferences = 1672,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVGroupMembersType"]/*' />
            CVGroupMembersType = 1673,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVClearSearch"]/*' />
            CVClearSearch = 1674,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVFilterToType"]/*' />
            CVFilterToType = 1675,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVSortByBestMatch"]/*' />
            CVSortByBestMatch = 1676,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVSearchMRUList"]/*' />
            CVSearchMRUList = 1677,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVViewOtherMembers"]/*' />
            CVViewOtherMembers = 1678,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVSearchCmd"]/*' />
            CVSearchCmd = 1679,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CVGoToSearchCmd"]/*' />
            CVGoToSearchCmd = 1680,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ControlGallery"]/*' />
            ControlGallery = 1700,
            //
            // Object Browser commands
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBShowInheritedMembers"]/*' />
            OBShowInheritedMembers = 1711,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBShowBaseTypes"]/*' />
            OBShowBaseTypes = 1712,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBShowDerivedTypes"]/*' />
            OBShowDerivedTypes = 1713,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBShowHidden"]/*' />
            OBShowHidden = 1714,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBBack"]/*' />
            OBBack = 1715,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBForward"]/*' />
            OBForward = 1716,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBSearchCombo"]/*' />
            OBSearchCombo = 1717,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBSearch"]/*' />
            OBSearch = 1718,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBSortObjectsAlpha"]/*' />
            OBSortObjectsAlpha = 1719,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBSortObjectsType"]/*' />
            OBSortObjectsType = 1720,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBSortObjectsAccess"]/*' />
            OBSortObjectsAccess = 1721,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBGroupObjectsType"]/*' />
            OBGroupObjectsType = 1722,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBSortMembersAlpha"]/*' />
            OBSortMembersAlpha = 1723,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBSortMembersType"]/*' />
            OBSortMembersType = 1724,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBSortMembersAccess"]/*' />
            OBSortMembersAccess = 1725,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBTypeBrowserSettings"]/*' />
            OBTypeBrowserSettings = 1726,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBViewMembersAsImplementor"]/*' />
            OBViewMembersAsImplementor = 1727,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBViewMembersAsSubclass"]/*' />
            OBViewMembersAsSubclass = 1728,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBViewMembersAsUser"]/*' />
            OBViewMembersAsUser = 1729,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBNamespacesView"]/*' />
            OBNamespacesView = 1730,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBContainersView"]/*' />
            OBContainersView = 1731,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBReserved1"]/*' />
            OBReserved1 = 1732,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBGroupMembersType"]/*' />
            OBGroupMembersType = 1733,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBClearSearch"]/*' />
            OBClearSearch = 1734,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBFilterToType"]/*' />
            OBFilterToType = 1735,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBSortByBestMatch"]/*' />
            OBSortByBestMatch = 1736,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBSearchMRUList"]/*' />
            OBSearchMRUList = 1737,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBViewOtherMembers"]/*' />
            OBViewOtherMembers = 1738,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBSearchCmd"]/*' />
            OBSearchCmd = 1739,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBGoToSearchCmd"]/*' />
            OBGoToSearchCmd = 1740,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBShowExtensionMembers"]/*' />
            OBShowExtensionMembers = 1741,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FullScreen2"]/*' />
            FullScreen2 = 1775,
            //
            // find symbol results sorting command
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FSRSortObjectsAlpha"]/*' />
            FSRSortObjectsAlpha = 1776,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FSRSortByBestMatch"]/*' />
            FSRSortByBestMatch = 1777,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NavigateBack"]/*' />
            NavigateBack = 1800,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NavigateForward"]/*' />
            NavigateForward = 1801,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_1"]/*' />
            ECMD_CORRECTION_1 = 1900,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_2"]/*' />
            ECMD_CORRECTION_2 = 1901,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_3"]/*' />
            ECMD_CORRECTION_3 = 1902,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_4"]/*' />
            ECMD_CORRECTION_4 = 1903,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_5"]/*' />
            ECMD_CORRECTION_5 = 1904,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_6"]/*' />
            ECMD_CORRECTION_6 = 1905,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_7"]/*' />
            ECMD_CORRECTION_7 = 1906,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_8"]/*' />
            ECMD_CORRECTION_8 = 1907,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_9"]/*' />
            ECMD_CORRECTION_9 = 1908,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_10"]/*' />
            ECMD_CORRECTION_10 = 1909,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBAddReference"]/*' />
            OBAddReference = 1914,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FindReferences"]/*' />
            [Obsolete("VSStd2KCmdID.FindReferences has been deprecated; please use VSStd97CmdID.FindReferences instead.", false)]
            FindReferences = 1915,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CodeDefView"]/*' />
            CodeDefView = 1926,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CodeDefViewGoToPrev"]/*' />
            CodeDefViewGoToPrev = 1927,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CodeDefViewGoToNext"]/*' />
            CodeDefViewGoToNext = 1928,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CodeDefViewEditDefinition"]/*' />
            CodeDefViewEditDefinition = 1929,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CodeDefViewChooseEncoding"]/*' />
            CodeDefViewChooseEncoding = 1930,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ViewInClassDiagram"]/*' />
            ViewInClassDiagram = 1931,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDDBTABLE"]/*' />
            ECMD_ADDDBTABLE = 1950,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDDATATABLE"]/*' />
            ECMD_ADDDATATABLE = 1951,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDFUNCTION"]/*' />
            ECMD_ADDFUNCTION = 1952,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDRELATION"]/*' />
            ECMD_ADDRELATION = 1953,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDKEY"]/*' />
            ECMD_ADDKEY = 1954,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDCOLUMN"]/*' />
            ECMD_ADDCOLUMN = 1955,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONVERT_DBTABLE"]/*' />
            ECMD_CONVERT_DBTABLE = 1956,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONVERT_DATATABLE"]/*' />
            ECMD_CONVERT_DATATABLE = 1957,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_GENERATE_DATABASE"]/*' />
            ECMD_GENERATE_DATABASE = 1958,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONFIGURE_CONNECTIONS"]/*' />
            ECMD_CONFIGURE_CONNECTIONS = 1959,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_IMPORT_XMLSCHEMA"]/*' />
            ECMD_IMPORT_XMLSCHEMA = 1960,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_SYNC_WITH_DATABASE"]/*' />
            ECMD_SYNC_WITH_DATABASE = 1961,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONFIGURE"]/*' />
            ECMD_CONFIGURE = 1962,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CREATE_DATAFORM"]/*' />
            ECMD_CREATE_DATAFORM = 1963,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CREATE_ENUM"]/*' />
            ECMD_CREATE_ENUM = 1964,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_INSERT_FUNCTION"]/*' />
            ECMD_INSERT_FUNCTION = 1965,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_EDIT_FUNCTION"]/*' />
            ECMD_EDIT_FUNCTION = 1966,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_SET_PRIMARY_KEY"]/*' />
            ECMD_SET_PRIMARY_KEY = 1967,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_INSERT_COLUMN"]/*' />
            ECMD_INSERT_COLUMN = 1968,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_AUTO_SIZE"]/*' />
            ECMD_AUTO_SIZE = 1969,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_SHOW_RELATION_LABELS"]/*' />
            ECMD_SHOW_RELATION_LABELS = 1970,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDGenerateDataSet"]/*' />
            VSDGenerateDataSet = 1971,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDPreview"]/*' />
            VSDPreview = 1972,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDConfigureAdapter"]/*' />
            VSDConfigureAdapter = 1973,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDViewDatasetSchema"]/*' />
            VSDViewDatasetSchema = 1974,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDDatasetProperties"]/*' />
            VSDDatasetProperties = 1975,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDParameterizeForm"]/*' />
            VSDParameterizeForm = 1976,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDAddChildForm"]/*' />
            VSDAddChildForm = 1977,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_EDITCONSTRAINT"]/*' />
            ECMD_EDITCONSTRAINT = 1978,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_DELETECONSTRAINT"]/*' />
            ECMD_DELETECONSTRAINT = 1979,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_EDITDATARELATION"]/*' />
            ECMD_EDITDATARELATION = 1980,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CloseProject"]/*' />
            CloseProject = 1982,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ReloadCommandBars"]/*' />
            ReloadCommandBars = 1983,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SolutionPlatform"]/*' />
            SolutionPlatform = 1990,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SolutionPlatformGetList"]/*' />
            SolutionPlatformGetList = 1991,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_DATAACCESSOR"]/*' />
            ECMD_DATAACCESSOR = 2000,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADD_DATAACCESSOR"]/*' />
            ECMD_ADD_DATAACCESSOR = 2001,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_QUERY"]/*' />
            ECMD_QUERY = 2002,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADD_QUERY"]/*' />
            ECMD_ADD_QUERY = 2003,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_PUBLISHSELECTION"]/*' />
            ECMD_PUBLISHSELECTION = 2005,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_PUBLISHSLNCTX"]/*' />
            ECMD_PUBLISHSLNCTX = 2006,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowCallsTo"]/*' />
            CallBrowserShowCallsTo = 2010,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowCallsFrom"]/*' />
            CallBrowserShowCallsFrom = 2011,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowNewCallsTo"]/*' />
            CallBrowserShowNewCallsTo = 2012,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowNewCallsFrom"]/*' />
            CallBrowserShowNewCallsFrom = 2013,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1ShowCallsTo"]/*' />
            CallBrowser1ShowCallsTo = 2014,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2ShowCallsTo"]/*' />
            CallBrowser2ShowCallsTo = 2015,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3ShowCallsTo"]/*' />
            CallBrowser3ShowCallsTo = 2016,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4ShowCallsTo"]/*' />
            CallBrowser4ShowCallsTo = 2017,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5ShowCallsTo"]/*' />
            CallBrowser5ShowCallsTo = 2018,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6ShowCallsTo"]/*' />
            CallBrowser6ShowCallsTo = 2019,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7ShowCallsTo"]/*' />
            CallBrowser7ShowCallsTo = 2020,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8ShowCallsTo"]/*' />
            CallBrowser8ShowCallsTo = 2021,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9ShowCallsTo"]/*' />
            CallBrowser9ShowCallsTo = 2022,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10ShowCallsTo"]/*' />
            CallBrowser10ShowCallsTo = 2023,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11ShowCallsTo"]/*' />
            CallBrowser11ShowCallsTo = 2024,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12ShowCallsTo"]/*' />
            CallBrowser12ShowCallsTo = 2025,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13ShowCallsTo"]/*' />
            CallBrowser13ShowCallsTo = 2026,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14ShowCallsTo"]/*' />
            CallBrowser14ShowCallsTo = 2027,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15ShowCallsTo"]/*' />
            CallBrowser15ShowCallsTo = 2028,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16ShowCallsTo"]/*' />
            CallBrowser16ShowCallsTo = 2029,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1ShowCallsFrom"]/*' />
            CallBrowser1ShowCallsFrom = 2030,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2ShowCallsFrom"]/*' />
            CallBrowser2ShowCallsFrom = 2031,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3ShowCallsFrom"]/*' />
            CallBrowser3ShowCallsFrom = 2032,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4ShowCallsFrom"]/*' />
            CallBrowser4ShowCallsFrom = 2033,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5ShowCallsFrom"]/*' />
            CallBrowser5ShowCallsFrom = 2034,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6ShowCallsFrom"]/*' />
            CallBrowser6ShowCallsFrom = 2035,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7ShowCallsFrom"]/*' />
            CallBrowser7ShowCallsFrom = 2036,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8ShowCallsFrom"]/*' />
            CallBrowser8ShowCallsFrom = 2037,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9ShowCallsFrom"]/*' />
            CallBrowser9ShowCallsFrom = 2038,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10ShowCallsFrom"]/*' />
            CallBrowser10ShowCallsFrom = 2039,
            /// <include file='doc\VSConstants.uex' p