ions.
HRESULT
RequestAudioNotifications(
    HANDLE hMsgQueue,                               // Handle to a message queue created with CreateMsgQueue for read access.
    DWORD dwFlags,                                  // Logical-OR of the desired event types to receive notifications.
    __out HAUDIONOTIFICATION *phAudioNotification   // Returned audio notification handle.
    );

// Stops audio notifications.
HRESULT
StopAudioNotifications(
    HAUDIONOTIFICATION hAudioNotification           // Notification handle returned from RequestAudioNotifications.
    );

// Audio notification event types.
#define AUDIOEVT_WAVEOUT_DEVICEID_CHANGE        0x00000001  // Device ID change notification for Wave output devices.
#define AUDIOEVT_WAVEIN_DEVICEID_CHANGE         0x00000100  // Device ID change notificaiton for Wave input devices.

// Maximum audio event message size.
#define AUDIOEVTMSG_SIZE_MAX                    256

// Audio event message header.  This structure is located at the beginning
// of all audio event messages.
typedef struct _AUDIOEVTMSGHDR
{
    DWORD dwEventType;              // An event type that was specified in the dwFlags parameter to RequestAudioNotifications.
    DWORD cbMsg;                    // Size in bytes of the entire message.
} AUDIOEVTMSGHDR, *PAUDIOEVTMSGHDR;

// Maximum number of device change entries in AUDIOEVTMSG_DEVICEID_CHANGE.
#define DEVICEID_CHANGE_ENTRIES_MAX             16

// Device ID change audio event message.
typedef struct _AUDIOEVTMSG_DEVICEID_CHANGE
{
    AUDIOEVTMSGHDR hdr;             // Message header.
    DWORD cEntries;                 // Number of entries in rgDeviceIdMap.
    struct
    {
        DWORD dwStreamClassId;      // Stream class affected by the device change.
        UINT uDeviceId;             // New mapped device ID for the stream class.
    } rgDeviceIdMap[DEVICEID_CHANGE_ENTRIES_MAX];
} AUDIOEVTMSG_DEVICEID_CHANGE, *PAUDIOEVTMSG_DEVICEID_CHANGE;

// CASSERT(sizeof(AUDIOEVTMSG_DEVICEID_CHANGE) <= AUDIOEVTMSG_SIZE_MAX);

#ifdef __cplusplus
}
#endif

#endif // _AUDIORTGAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\austream.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for austream.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __austream_h__
#define __austream_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAudioMediaStream_FWD_DEFINED__
#define __IAudioMediaStream_FWD_DEFINED__
typedef interface IAudioMediaStream IAudioMediaStream;
#endif 	/* __IAudioMediaStream_FWD_DEFINED__ */


#ifndef __IAudioStreamSample_FWD_DEFINED__
#define __IAudioStreamSample_FWD_DEFINED__
typedef interface IAudioStreamSample IAudioStreamSample;
#endif 	/* __IAudioStreamSample_FWD_DEFINED__ */


#ifndef __IMemoryData_FWD_DEFINED__
#define __IMemoryData_FWD_DEFINED__
typedef interface IMemoryData IMemoryData;
#endif 	/* __IMemoryData_FWD_DEFINED__ */


#ifndef __IAudioData_FWD_DEFINED__
#define __IAudioData_FWD_DEFINED__
typedef interface IAudioData IAudioData;
#endif 	/* __IAudioData_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "mmstream.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_austream_0000_0000 */
/* [local] */ 

//
//	The following declarations within the 'if 0' block are dummy typedefs used to make
//	the ddstream.idl file build.  The actual definitions are contained in DDRAW.H
//
#if 0
typedef struct tWAVEFORMATEX WAVEFORMATEX;

#endif






extern RPC_IF_HANDLE __MIDL_itf_austream_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_austream_0000_0000_v0_0_s_ifspec;

#ifndef __IAudioMediaStream_INTERFACE_DEFINED__
#define __IAudioMediaStream_INTERFACE_DEFINED__

/* interface IAudioMediaStream */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioMediaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f7537560-a3be-11d0-8212-00c04fc32c45")
    IAudioMediaStream : public IMediaStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFormat( 
            /* [optional][out] */ WAVEFORMATEX *pWaveFormatCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFormat( 
            /* [in] */ const WAVEFORMATEX *lpWaveFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSample( 
            /* [in] */ IAudioData *pAudioData,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IAudioStreamSample **ppSample) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioMediaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioMediaStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioMediaStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioMediaStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultiMediaStream )( 
            IAudioMediaStream * This,
            /* [out] */ IMultiMediaStream **ppMultiMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetInformation )( 
            IAudioMediaStream * This,
            /* [optional][out] */ MSPID *pPurposeId,
            /* [optional][out] */ STREAM_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *SetSameFormat )( 
            IAudioMediaStream * This,
            /* [in] */ IMediaStream *pStreamThatHasDesiredFormat,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSample )( 
            IAudioMediaStream * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSharedSample )( 
            IAudioMediaStream * This,
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample);
        
        HRESULT ( STDMETHODCALLTYPE *SendEndOfStream )( 
            IAudioMediaStream * This,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            IAudioMediaStream * This,
            /* [optional][out] */ WAVEFORMATEX *pWaveFormatCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            IAudioMediaStream * This,
            /* [in] */ const WAVEFORMATEX *lpWaveFormat);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSample )( 
            IAudioMediaStream * This,
            /* [in] */ IAudioData *pAudioData,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IAudioStreamSample **ppSample);
        
        END_INTERFACE
    } IAudioMediaStreamVtbl;

    interface IAudioMediaStream
    {
        CONST_VTBL struct IAudioMediaStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioMediaStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioMediaStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioMediaStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioMediaStream_GetMultiMediaStream(This,ppMultiMediaStream)	\
    ( (This)->lpVtbl -> GetMultiMediaStream(This,ppMultiMediaStream) ) 

#define IAudioMediaStream_GetInformation(This,pPurposeId,pType)	\
    ( (This)->lpVtbl -> GetInformation(This,pPurposeId,pType) ) 

#define IAudioMediaStream_SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags)	\
    ( (This)->lpVtbl -> SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags) ) 

#define IAudioMediaStream_AllocateSample(This,dwFlags,ppSample)	\
    ( (This)->lpVtbl -> AllocateSample(This,dwFlags,ppSample) ) 

#define IAudioMediaStream_CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample)	\
    ( (This)->lpVtbl -> CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample) ) 

#define IAudioMediaStream_SendEndOfStream(This,dwFlags)	\
    ( (This)->lpVtbl -> SendEndOfStream(This,dwFlags) ) 


#define IAudioMediaStream_GetFormat(This,pWaveFormatCurrent)	\
    ( (This)->lpVtbl -> GetFormat(This,pWaveFormatCurrent) ) 

#define IAudioMediaStream_SetFormat(This,lpWaveFormat)	\
    ( (This)->lpVtbl -> SetFormat(This,lpWaveFormat) ) 

#define IAudioMediaStream_CreateSample(This,pAudioData,dwFlags,ppSample)	\
    ( (This)->lpVtbl -> CreateSample(This,pAudioData,dwFlags,ppSample) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioMediaStream_INTERFACE_DEFINED__ */


#ifndef __IAudioStreamSample_INTERFACE_DEFINED__
#define __IAudioStreamSample_INTERFACE_DEFINED__

/* interface IAudioStreamSample */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioStreamSample;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("345fee00-aba5-11d0-8212-00c04fc32c45")
    IAudioStreamSample : public IStreamSample
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAudioData( 
            /* [out] */ IAudioData **ppAudio) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioStreamSampleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioStreamSample * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioStreamSample * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioStreamSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaStream )( 
            IAudioStreamSample * This,
            /* [in] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetSampleTimes )( 
            IAudioStreamSample * This,
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetSampleTimes )( 
            IAudioStreamSample * This,
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime);
        
        HRESULT ( STDMETHODCALLTYPE *Update )( 
            IAudioStreamSample * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ HANDLE hEvent,
            /* [optional][in] */ PAPCFUNC pfnAPC,
            /* [optional][in] */ DWORD dwAPCData);
        
        HRESULT ( STDMETHODCALLTYPE *CompletionStatus )( 
            IAudioStreamSample * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioData )( 
            IAudioStreamSample * This,
            /* [out] */ IAudioData **ppAudio);
        
        END_INTERFACE
    } IAudioStreamSampleVtbl;

    interface IAudioStreamSample
    {
        CONST_VTBL struct IAudioStreamSampleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioStreamSample_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioStreamSample_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioStreamSample_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioStreamSample_GetMediaStream(This,ppMediaStream)	\
    ( (This)->lpVtbl -> GetMediaStream(This,ppMediaStream) ) 

#define IAudioStreamSample_GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime)	\
    ( (This)->lpVtbl -> GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime) ) 

#define IAudioStreamSample_SetSampleTimes(This,pStartTime,pEndTime)	\
    ( (This)->lpVtbl -> SetSampleTimes(This,pStartTime,pEndTime) ) 

#define IAudioStreamSample_Update(This,dwFlags,hEvent,pfnAPC,dwAPCData)	\
    ( (This)->lpVtbl -> Update(This,dwFlags,hEvent,pfnAPC,dwAPCData) ) 

#define IAudioStreamSample_CompletionStatus(This,dwFlags,dwMilliseconds)	\
    ( (This)->lpVtbl -> CompletionStatus(This,dwFlags,dwMilliseconds) ) 


#define IAudioStreamSample_GetAudioData(This,ppAudio)	\
    ( (This)->lpVtbl -> GetAudioData(This,ppAudio) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioStreamSample_INTERFACE_DEFINED__ */


#ifndef __IMemoryData_INTERFACE_DEFINED__
#define __IMemoryData_INTERFACE_DEFINED__

/* interface IMemoryData */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IMemoryData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("327fc560-af60-11d0-8212-00c04fc32c45")
    IMemoryData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBuffer( 
            /* [in] */ DWORD cbSize,
            /* [in] */ BYTE *pbData,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ DWORD *pdwLength,
            /* [out] */ BYTE **ppbData,
            /* [out] */ DWORD *pcbActualData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActual( 
            /* [in] */ DWORD cbDataValid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMemoryDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMemoryData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMemoryData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMemoryData * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBuffer )( 
            IMemoryData * This,
            /* [in] */ DWORD cbSize,
            /* [in] */ BYTE *pbData,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IMemoryData * This,
            /* [out] */ DWORD *pdwLength,
            /* [out] */ BYTE **ppbData,
            /* [out] */ DWORD *pcbActualData);
        
        HRESULT ( STDMETHODCALLTYPE *SetActual )( 
            IMemoryData * This,
            /* [in] */ DWORD cbDataValid);
        
        END_INTERFACE
    } IMemoryDataVtbl;

    interface IMemoryData
    {
        CONST_VTBL struct IMemoryDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMemoryData_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMemoryData_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMemoryData_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMemoryData_SetBuffer(This,cbSize,pbData,dwFlags)	\
    ( (This)->lpVtbl -> SetBuffer(This,cbSize,pbData,dwFlags) ) 

#define IMemoryData_GetInfo(This,pdwLength,ppbData,pcbActualData)	\
    ( (This)->lpVtbl -> GetInfo(This,pdwLength,ppbData,pcbActualData) ) 

#define IMemoryData_SetActual(This,cbDataValid)	\
    ( (This)->lpVtbl -> SetActual(This,cbDataValid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMemoryData_INTERFACE_DEFINED__ */


#ifndef __IAudioData_INTERFACE_DEFINED__
#define __IAudioData_INTERFACE_DEFINED__

/* interface IAudioData */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54c719c0-af60-11d0-8212-00c04fc32c45")
    IAudioData : public IMemoryData
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFormat( 
            /* [optional][out] */ WAVEFORMATEX *pWaveFormatCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFormat( 
            /* [in] */ const WAVEFORMATEX *lpWaveFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioData * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBuffer )( 
            IAudioData * This,
            /* [in] */ DWORD cbSize,
            /* [in] */ BYTE *pbData,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IAudioData * This,
            /* [out] */ DWORD *pdwLength,
            /* [out] */ BYTE **ppbData,
            /* [out] */ DWORD *pcbActualData);
        
        HRESULT ( STDMETHODCALLTYPE *SetActual )( 
            IAudioData * This,
            /* [in] */ DWORD cbDataValid);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            IAudioData * This,
            /* [optional][out] */ WAVEFORMATEX *pWaveFormatCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            IAudioData * This,
            /* [in] */ const WAVEFORMATEX *lpWaveFormat);
        
        END_INTERFACE
    } IAudioDataVtbl;

    interface IAudioData
    {
        CONST_VTBL struct IAudioDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioData_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioData_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioData_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioData_SetBuffer(This,cbSize,pbData,dwFlags)	\
    ( (This)->lpVtbl -> SetBuffer(This,cbSize,pbData,dwFlags) ) 

#define IAudioData_GetInfo(This,pdwLength,ppbData,pcbActualData)	\
    ( (This)->lpVtbl -> GetInfo(This,pdwLength,ppbData,pcbActualData) ) 

#define IAudioData_SetActual(This,cbDataValid)	\
    ( (This)->lpVtbl -> SetActual(This,cbDataValid) ) 


#define IAudioData_GetFormat(This,pWaveFormatCurrent)	\
    ( (This)->lpVtbl -> GetFormat(This,pWaveFormatCurrent) ) 

#define IAudioData_SetFormat(This,lpWaveFormat)	\
    ( (This)->lpVtbl -> SetFormat(This,lpWaveFormat) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioData_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\aviriff.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;
#pragma warning(disable: 4097 4511 4512 4514 4705)

/*+
 *
 * Structures and defines for the RIFF AVI file format extended to
 * handle very large/long files
 *
 *-=====================================================================*/

#if !defined AVIRIFF_H
#define AVIRIFF_H

#if !defined NUMELMS
  #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

// all structures in this file are packed on word boundaries
//
#include <pshpack2.h>

/*
 * heres the general layout of an AVI riff file (new format)
 *
 * RIFF (3F??????) AVI       <- not more than 1 GB in size
 *     LIST (size) hdrl
 *         avih (0038)
 *         LIST (size) strl
 *             strh (0038)
 *             strf (????)
 *             indx (3ff8)   <- size may vary, should be sector sized
 *         LIST (size) strl
 *             strh (0038)
 *             strf (????)
 *             indx (3ff8)   <- size may vary, should be sector sized
 *         LIST (size) odml
 *             dmlh (????)
 *         JUNK (size)       <- fill to align to sector - 12
 *     LIST (7f??????) movi  <- aligned on sector - 12
 *         00dc (size)       <- sector aligned
 *         01wb (size)       <- sector aligned
 *         ix00 (size)       <- sector aligned
 *     idx1 (00??????)       <- sector aligned
 * RIFF (7F??????) AVIX
 *     JUNK (size)           <- fill to align to sector -12
 *     LIST (size) movi
 *         00dc (size)       <- sector aligned
 * RIFF (7F??????) AVIX      <- not more than 2GB in size
 *     JUNK (size)           <- fill to align to sector - 12
 *     LIST (size) movi
 *         00dc (size)       <- sector aligned
 *
 *-===================================================================*/

//
// structures for manipulating RIFF headers
//
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))

typedef struct _riffchunk {
   FOURCC fcc;
   DWORD  cb;
   } RIFFCHUNK, * LPRIFFCHUNK;
typedef struct _rifflist {
   FOURCC fcc;
   DWORD  cb;
   FOURCC fccListType;
   } RIFFLIST, * LPRIFFLIST;


//
// ==================== avi header structures ===========================
//

// main header for the avi file (compatibility header)
//
#define ckidMAINAVIHEADER FCC('avih')
typedef struct _avimainheader {
    FOURCC fcc;                    // 'avih'
    DWORD  cb;                     // size of this structure -8
    DWORD  dwMicroSecPerFrame;     // frame display rate (or 0L)
    DWORD  dwMaxBytesPerSec;       // max. transfer rate
    DWORD  dwPaddingGranularity;   // pad to multiples of this size; normally 2K.
    DWORD  dwFlags;                // the ever-present flags
    #define AVIF_HASINDEX        0x00000010 // Index at end of file?
    #define AVIF_MUSTUSEINDEX    0x00000020
    #define AVIF_ISINTERLEAVED   0x00000100
    #define AVIF_TRUSTCKTYPE     0x00000800 // Use CKType to find key frames
    #define AVIF_WASCAPTUREFILE  0x00010000
    #define AVIF_COPYRIGHTED     0x00020000
    DWORD  dwTotalFrames;          // # frames in first movi list
    DWORD  dwInitialFrames;
    DWORD  dwStreams;
    DWORD  dwSuggestedBufferSize;
    DWORD  dwWidth;
    DWORD  dwHeight;
    DWORD  dwReserved[4];
    } AVIMAINHEADER;

#define ckidODML          FCC('odml')
#define ckidAVIEXTHEADER  FCC('dmlh')
typedef struct _aviextheader {
   FOURCC  fcc;                    // 'dmlh'
   DWORD   cb;                     // size of this structure -8
   DWORD   dwGrandFrames;          // total number of frames in the file
   DWORD   dwFuture[61];           // to be defined later
   } AVIEXTHEADER;

//
// structure of an AVI stream header riff chunk
//
#define ckidSTREAMLIST   FCC('strl')

#ifndef ckidSTREAMHEADER
#define ckidSTREAMHEADER FCC('strh')
#endif
typedef struct _avistreamheader {
   FOURCC fcc;          // 'strh'
   DWORD  cb;           // size of this structure - 8

   FOURCC fccType;      // stream type codes

   #ifndef streamtypeVIDEO
   #define streamtypeVIDEO FCC('vids')
   #define streamtypeAUDIO FCC('auds')
   #define streamtypeMIDI  FCC('mids')
   #define streamtypeTEXT  FCC('txts')
   #endif

   FOURCC fccHandler;
   DWORD  dwFlags;
   #define AVISF_DISABLED          0x00000001
   #define AVISF_VIDEO_PALCHANGES  0x00010000

   WORD   wPriority;
   WORD   wLanguage;
   DWORD  dwInitialFrames;
   DWORD  dwScale;
   DWORD  dwRate;       // dwRate/dwScale is stream tick rate in ticks/sec
   DWORD  dwStart;
   DWORD  dwLength;
   DWORD  dwSuggestedBufferSize;
   DWORD  dwQuality;
   DWORD  dwSampleSize;
   struct {
      short int left;
      short int top;
      short int right;
      short int bottom;
      }   rcFrame;
   } AVISTREAMHEADER;


//
// structure of an AVI stream format chunk
//
#ifndef ckidSTREAMFORMAT
#define ckidSTREAMFORMAT FCC('strf')
#endif
//
// avi stream formats are different for each stream type
//
// BITMAPINFOHEADER for video streams
// WAVEFORMATEX or PCMWAVEFORMAT for audio streams
// nothing for text streams
// nothing for midi streams


#pragma warning(disable:4200)
//
// structure of old style AVI index
//
#define ckidAVIOLDINDEX FCC('idx1')
typedef struct _avioldindex {
   FOURCC  fcc;        // 'idx1'
   DWORD   cb;         // size of this structure -8
   struct _avioldindex_entry {
      DWORD   dwChunkId;
      DWORD   dwFlags;

      #ifndef AVIIF_LIST
      #define AVIIF_LIST       0x00000001
      #define AVIIF_KEYFRAME   0x00000010
      #endif
     
      #define AVIIF_NO_TIME    0x00000100
      #define AVIIF_COMPRESSOR 0x0FFF0000  // unused?
      DWORD   dwOffset;    // offset of riff chunk header for the data
      DWORD   dwSize;      // size of the data (excluding riff header size)
      } aIndex[];          // size of this array
   } AVIOLDINDEX;


//
// ============ structures for timecode in an AVI file =================
//

#ifndef TIMECODE_DEFINED
#define TIMECODE_DEFINED

// defined
// timecode time structure
//
typedef union _timecode {
   struct {
      WORD   wFrameRate;
      WORD   wFrameFract;
      LONG   cFrames;
      };
   DWORDLONG  qw;
   } TIMECODE;

#endif // TIMECODE_DEFINED

#define TIMECODE_RATE_30DROP 0   // this MUST be zero

// struct for all the SMPTE timecode info
//
typedef struct _timecodedata {
   TIMECODE time;
   DWORD    dwSMPTEflags;
   DWORD    dwUser;
   } TIMECODEDATA;

// dwSMPTEflags masks/values
//
#define TIMECODE_SMPTE_BINARY_GROUP 0x07
#define TIMECODE_SMPTE_COLOR_FRAME  0x08

//
// ============ structures for new style AVI indexes =================
//

// index type codes
//
#define AVI_INDEX_OF_INDEXES       0x00
#define AVI_INDEX_OF_CHUNKS        0x01
#define AVI_INDEX_OF_TIMED_CHUNKS  0x02
#define AVI_INDEX_OF_SUB_2FIELD    0x03
#define AVI_INDEX_IS_DATA          0x80

// index subtype codes
//
#define AVI_INDEX_SUB_DEFAULT     0x00

// INDEX_OF_CHUNKS subtype codes
//
#define AVI_INDEX_SUB_2FIELD      0x01

// meta structure of all avi indexes
//
typedef struct _avimetaindex {
   FOURCC fcc;
   UINT   cb;
   WORD   wLongsPerEntry;
   BYTE   bIndexSubType;
   BYTE   bIndexType;
   DWORD  nEntriesInUse;
   DWORD  dwChunkId;
   DWORD  dwReserved[3];
   DWORD  adwIndex[];
   } AVIMETAINDEX;

#define STDINDEXSIZE 0x4000
#define NUMINDEX(wLongsPerEntry) ((STDINDEXSIZE-32)/4/(wLongsPerEntry))
#define NUMINDEXFILL(wLongsPerEntry) ((STDINDEXSIZE/4) - NUMINDEX(wLongsPerEntry))

// structure of a super index (INDEX_OF_INDEXES)
//
#define ckidAVISUPERINDEX FCC('indx')
typedef struct _avisuperindex {
   FOURCC   fcc;               // 'indx'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==4
   BYTE     bIndexSubType;     // ==0 (frame index) or AVI_INDEX_SUB_2FIELD 
   BYTE     bIndexType;        // ==AVI_INDEX_OF_INDEXES
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // chunk ID of chunks being indexed, (i.e. RGB8)
   DWORD    dwReserved[3];     // must be 0
   struct _avisuperindex_entry {
      DWORDLONG qwOffset;    // 64 bit offset to sub index chunk
      DWORD    dwSize;       // 32 bit size of sub index chunk
      DWORD    dwDuration;   // time span of subindex chunk (in stream ticks)
      } aIndex[NUMINDEX(4)];
   } AVISUPERINDEX;
#define Valid_SUPERINDEX(pi) (*(DWORD *)(&((pi)->wLongsPerEntry)) == (4 | (AVI_INDEX_OF_INDEXES << 24)))

// struct of a standard index (AVI_INDEX_OF_CHUNKS)
//
typedef struct _avistdindex_entry {
   DWORD dwOffset;       // 32 bit offset to data (points to data, not riff header)
   DWORD dwSize;         // 31 bit size of data (does not include size of riff header), bit 31 is deltaframe bit
   } AVISTDINDEX_ENTRY;
#define AVISTDINDEX_DELTAFRAME ( 0x80000000) // Delta frames have the high bit set
#define AVISTDINDEX_SIZEMASK   (~0x80000000)

typedef struct _avistdindex {
   FOURCC   fcc;               // 'indx' or '##ix'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==2
   BYTE     bIndexSubType;     // ==0
   BYTE     bIndexType;        // ==AVI_INDEX_OF_CHUNKS
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // chunk ID of chunks being indexed, (i.e. RGB8)
   DWORDLONG qwBaseOffset;     // base offset that all index intries are relative to
   DWORD    dwReserved_3;      // must be 0
   AVISTDINDEX_ENTRY aIndex[NUMINDEX(2)];
   } AVISTDINDEX;

// struct of a time variant standard index (AVI_INDEX_OF_TIMED_CHUNKS)
//
typedef struct _avitimedindex_entry {
   DWORD dwOffset;       // 32 bit offset to data (points to data, not riff header)
   DWORD dwSize;         // 31 bit size of data (does not include size of riff header) (high bit is deltaframe bit)
   DWORD dwDuration;     // how much time the chunk should be played (in stream ticks)
   } AVITIMEDINDEX_ENTRY;

typedef struct _avitimedindex {
   FOURCC   fcc;               // 'indx' or '##ix'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==3
   BYTE     bIndexSubType;     // ==0
   BYTE     bIndexType;        // ==AVI_INDEX_OF_TIMED_CHUNKS
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // chunk ID of chunks being indexed, (i.e. RGB8)
   DWORDLONG qwBaseOffset;     // base offset that all index intries are relative to
   DWORD    dwReserved_3;      // must be 0
   AVITIMEDINDEX_ENTRY aIndex[NUMINDEX(3)];
   DWORD adwTrailingFill[NUMINDEXFILL(3)]; // to align struct to correct size
   } AVITIMEDINDEX;

// structure of a timecode stream
//
typedef struct _avitimecodeindex {
   FOURCC   fcc;               // 'indx' or '##ix'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==4
   BYTE     bIndexSubType;     // ==0
   BYTE     bIndexType;        // ==AVI_INDEX_IS_DATA
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // 'time'
   DWORD    dwReserved[3];     // must be 0
   TIMECODEDATA aIndex[NUMINDEX(sizeof(TIMECODEDATA)/sizeof(LONG))];
   } AVITIMECODEINDEX;

// structure of a timecode discontinuity list (when wLongsPerEntry == 7)
//
typedef struct _avitcdlindex_entry {
    DWORD    dwTick;           // stream tick time that maps to this timecode value
    TIMECODE time;
    DWORD    dwSMPTEflags;
    DWORD    dwUser;
    TCHAR    szReelId[12];
    } AVITCDLINDEX_ENTRY;

typedef struct _avitcdlindex {
   FOURCC   fcc;               // 'indx' or '##ix'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==7 (must be 4 or more all 'tcdl' indexes
   BYTE     bIndexSubType;     // ==0
   BYTE     bIndexType;        // ==AVI_INDEX_IS_DATA
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // 'tcdl'
   DWORD    dwReserved[3];     // must be 0
   AVITCDLINDEX_ENTRY aIndex[NUMINDEX(7)];
   DWORD adwTrailingFill[NUMINDEXFILL(7)]; // to align struct to correct size
   } AVITCDLINDEX;

typedef struct _avifieldindex_chunk {
   FOURCC   fcc;               // 'ix##'
   DWORD    cb;                // size of this structure
   WORD     wLongsPerEntry;    // must be 3 (size of each entry in
                               // aIndex array)
   BYTE     bIndexSubType;     // AVI_INDEX_2FIELD
   BYTE     bIndexType;        // AVI_INDEX_OF_CHUNKS
   DWORD    nEntriesInUse;     //
   DWORD    dwChunkId;         // '##dc' or '##db'
   DWORDLONG qwBaseOffset;     // offsets in aIndex array are relative to this
   DWORD    dwReserved3;       // must be 0
   struct _avifieldindex_entry {
      DWORD    dwOffset;
      DWORD    dwSize;         // size of all fields
                               // (bit 31 set for NON-keyframes)
      DWORD    dwOffsetField2; // offset to second field
   } aIndex[  ];
} AVIFIELDINDEX, * PAVIFIELDINDEX;


#include <poppack.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\autoras.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    autoras.h

Abstract:

    Data structures, defines and function prototypes for autoras.dll

Environment:

    

Revision History:

    September 2001  :: Original version.

--*/

#ifndef __AUTORAS__H_
#define __AUTORAS__H_

//
//  Createfile(AUTORAS_DEVICE_NAME...)
//

#define AUTORAS_DEVICE_NAME     TEXT("ARS1:")


//
//  Autoras.dll finds default ras phone book entry in:
//  HKLM\Comm\Autoras\RasEntry
//

#define REG_AUTORAS_ROOT        TEXT("Comm\\Autoras")
#define REG_DEFAULT_RAS_ENTRY   TEXT("RasEntry")


//
//  Autoras expects the dialer information to be provided
//  in the following registry entries:
//
//  Example:
//
//  [HKEY_LOCAL_MACHINE\Comm\Autoras]
//      "Dialer"="rnaapp.exe"
//      "NoPromptOpt"="-p"
//      "RasEntryOpt"="-e"

#define REG_AUTORAS_DIALER           TEXT("Dialer")
#define REG_AUTORAS_OPT_NO_PROMPT    TEXT("NoPromptOpt")
#define REG_AUTORAS_OPT_RASENTRY     TEXT("RasEntryOpt")


//
//  Valid IOCTL for ARS1
//

#define FSCTL_AUTORAS_BASE      FILE_DEVICE_NETWORK

#define _AUTORAS_CTL_CODE(_Function, _Method, _Access)  \
            CTL_CODE(FSCTL_AUTORAS_BASE, _Function, _Method, _Access)


#define IOCTL_ARS_DIAL		\
            _AUTORAS_CTL_CODE(0x200, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_ARS_DIAL_SYNC	\
            _AUTORAS_CTL_CODE(0x201, METHOD_BUFFERED, FILE_ANY_ACCESS)            



//
//  Message queue used by AutoRas to communicate with the dialer.
//  Dialer should call CreateMsgQueue(AUTORAS_MSGQUEUE_NAME...) 
//  and set to write access.
//	** NOTE ** 
//	The queue has to be created with MSGQUEUE_ALLOW_BROKEN
//	flag.   See public\common\oak\drivers\netsamp\rnaapp for example.
//	
//

#define AUTORAS_MSGQUEUE_NAME   TEXT("AutorasMsgqueue")

typedef struct 
{
    DWORD   dwNotificationId;
    DWORD   dwNotificationParam;

}   DIALER_NOTIFICATION, *PDIALER_NOTIFICATION;


//
//  Constants for dwNotificationId, and its necessary dwNotificationParam..
//

#define DIALER_START            0x00000001
#define DIALER_TERMINATE        0x00000002
#define DIALER_CANCELLED        0x00000003
#define DIALER_CONNECTED        0x00000004



//
//  APIs exposed by Autoras.dll driver..
//  


#define AUTORAS_DLL         TEXT("Autoras.dll")
#define AUTORAS_DIAL        TEXT("Autoras_Dial")
#define AUTORAS_DIAL_SYNC   TEXT("Autoras_Dial_Sync")


typedef BOOL (* PFN_AUTORAS_DIAL)(void);
typedef BOOL (* PFN_AUTORAS_DIAL_SYNC)(void);

#endif  //  __AUTORAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\avifmt.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/****************************************************************************/
/*                                                                          */
/*        AVIFMT.H - Include file for working with AVI files                */
/*                                                                          */
/*        Note: You must include WINDOWS.H and MMSYSTEM.H before            */
/*        including this file.                                              */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_AVIFMT
#define _INC_AVIFMT	100	/* version number * 100 + revision */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifdef _MSC_VER
#pragma warning(disable:4200)
#endif
    
/* The following is a short description of the AVI file format.  Please
 * see the accompanying documentation for a full explanation.
 *
 * An AVI file is the following RIFF form:
 *
 *	RIFF('AVI' 
 *	      LIST('hdrl'
 *		    avih(<MainAVIHeader>)
 *                  LIST ('strl'
 *                      strh(<Stream header>)
 *                      strf(<Stream format>)
 *                      ... additional header data
 *            LIST('movi'	 
 *      	  { LIST('rec' 
 *      		      SubChunk...
 *      		   )
 *      	      | SubChunk } ....	    
 *            )
 *            [ <AVIIndex> ]
 *      )
 *
 *	The main file header specifies how many streams are present.  For
 *	each one, there must be a stream header chunk and a stream format
 *	chunk, enlosed in a 'strl' LIST chunk.  The 'strf' chunk contains
 *	type-specific format information; for a video stream, this should
 *	be a BITMAPINFO structure, including palette.  For an audio stream,
 *	this should be a WAVEFORMAT (or PCMWAVEFORMAT) structure.
 *
 *	The actual data is contained in subchunks within the 'movi' LIST 
 *	chunk.  The first two characters of each data chunk are the
 *	stream number with which that data is associated.
 *
 *	Some defined chunk types:
 *           Video Streams:
 *                  ##db:	RGB DIB bits
 *                  ##dc:	RLE8 compressed DIB bits
 *                  ##pc:	Palette Change
 *
 *           Audio Streams:
 *                  ##wb:	waveform audio bytes
 *
 * The grouping into LIST 'rec' chunks implies only that the contents of
 *   the chunk should be read into memory at the same time.  This
 *   grouping is used for files specifically intended to be played from 
 *   CD-ROM.
 *
 * The index chunk at the end of the file should contain one entry for 
 *   each data chunk in the file.
 *       
 * Limitations for the current software:
 *	Only one video stream and one audio stream are allowed.
 *	The streams must start at the beginning of the file.
 *
 * 
 * To register codec types please obtain a copy of the Multimedia
 * Developer Registration Kit from:
 *
 *  Microsoft Corporation
 *  Multimedia Systems Group
 *  Product Marketing
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 */


#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

/* Macro to make a TWOCC out of two characters */
#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

typedef WORD TWOCC;

/* form types, list types, and chunk types */
#define formtypeAVI             mmioFOURCC('A', 'V', 'I', ' ')
#define listtypeAVIHEADER       mmioFOURCC('h', 'd', 'r', 'l')
#define ckidAVIMAINHDR          mmioFOURCC('a', 'v', 'i', 'h')
#define listtypeSTREAMHEADER    mmioFOURCC('s', 't', 'r', 'l')
#define ckidSTREAMHEADER        mmioFOURCC('s', 't', 'r', 'h')
#define ckidSTREAMFORMAT        mmioFOURCC('s', 't', 'r', 'f')
#define ckidSTREAMHANDLERDATA   mmioFOURCC('s', 't', 'r', 'd')
#define ckidSTREAMNAME		mmioFOURCC('s', 't', 'r', 'n')

#define listtypeAVIMOVIE        mmioFOURCC('m', 'o', 'v', 'i')
#define listtypeAVIRECORD       mmioFOURCC('r', 'e', 'c', ' ')

#define ckidAVINEWINDEX         mmioFOURCC('i', 'd', 'x', '1')

/*
** Stream types for the <fccType> field of the stream header.
*/
#define streamtypeVIDEO         mmioFOURCC('v', 'i', 'd', 's')
#define streamtypeAUDIO         mmioFOURCC('a', 'u', 'd', 's')
#define streamtypeMIDI		mmioFOURCC('m', 'i', 'd', 's')
#define streamtypeTEXT          mmioFOURCC('t', 'x', 't', 's')

/* Basic chunk types */
#define cktypeDIBbits           aviTWOCC('d', 'b')
#define cktypeDIBcompressed     aviTWOCC('d', 'c')
#define cktypePALchange         aviTWOCC('p', 'c')
#define cktypeWAVEbytes         aviTWOCC('w', 'b')

/* Chunk id to use for extra chunks for padding. */
#define ckidAVIPADDING          mmioFOURCC('J', 'U', 'N', 'K')


/*
** Useful macros
**
** Warning: These are nasty macro, and MS C 6.0 compiles some of them
** incorrectly if optimizations are on.  Ack.
*/

/* Macro to get stream number out of a FOURCC ckid */
#define FromHex(n)	(((n) >= 'A') ? ((n) + 10 - 'A') : ((n) - '0'))
#define StreamFromFOURCC(fcc) ((WORD) ((FromHex(LOBYTE(LOWORD(fcc))) << 4) + \
                                             (FromHex(HIBYTE(LOWORD(fcc))))))

/* Macro to get TWOCC chunk type out of a FOURCC ckid */
#define TWOCCFromFOURCC(fcc)    HIWORD(fcc)

/* Macro to make a ckid for a chunk out of a TWOCC and a stream number
** from 0-255.
*/
#define ToHex(n)	((BYTE) (((n) > 9) ? ((n) - 10 + 'A') : ((n) + '0')))
#define MAKEAVICKID(tcc, stream) \
        MAKELONG((ToHex((stream) & 0x0f) << 8) | \
			    (ToHex(((stream) & 0xf0) >> 4)), tcc)


/*
** Main AVI File Header 
*/	     
		     
/* flags for use in <dwFlags> in AVIFileHdr */
#define AVIF_HASINDEX		0x00000010	// Index at end of file?
#define AVIF_MUSTUSEINDEX	0x00000020
#define AVIF_ISINTERLEAVED	0x00000100
#define AVIF_TRUSTCKTYPE	0x00000800	// Use CKType to find key frames?
#define AVIF_WASCAPTUREFILE	0x00010000
#define AVIF_COPYRIGHTED	0x00020000

/* The AVI File Header LIST chunk should be padded to this size */
#define AVI_HEADERSIZE  2048                    // size of AVI header list

typedef struct
{
    DWORD		dwMicroSecPerFrame;	// frame display rate (or 0L)
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwPaddingGranularity;	// pad to multiples of this
                                                // size; normally 2K.
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwTotalFrames;		// # frames in file
    DWORD		dwInitialFrames;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;
    
    DWORD		dwWidth;
    DWORD		dwHeight;
    
    DWORD		dwReserved[4];
} MainAVIHeader;


/*
** Stream header
*/

#define AVISF_DISABLED			0x00000001

#define AVISF_VIDEO_PALCHANGES		0x00010000

typedef struct {
    FOURCC		fccType;
    FOURCC		fccHandler;
    DWORD		dwFlags;	/* Contains AVITF_* flags */
    WORD		wPriority;
    WORD		wLanguage;
    DWORD		dwInitialFrames;
    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwStart;
    DWORD		dwLength; /* In units above... */
    DWORD		dwSuggestedBufferSize;
    DWORD		dwQuality;
    DWORD		dwSampleSize;
    RECT		rcFrame;
} AVIStreamHeader;

/* Flags for index */
#define AVIIF_LIST          0x00000001L // chunk is a 'LIST'
#define AVIIF_KEYFRAME      0x00000010L // this frame is a key frame.

#define AVIIF_NOTIME	    0x00000100L // this frame doesn't take any time
#define AVIIF_COMPUSE       0x0FFF0000L // these bits are for compressor use

typedef struct
{
    DWORD		ckid;
    DWORD		dwFlags;
    DWORD		dwChunkOffset;		// Position of chunk
    DWORD		dwChunkLength;		// Length of chunk
} AVIINDEXENTRY;


/*
** Palette change chunk
**
** Used in video streams.
*/
typedef struct
{
    BYTE		bFirstEntry;	/* first entry to change */
    BYTE		bNumEntries;	/* # entries to change (0 if 256) */
    WORD		wFlags;		/* Mostly to preserve alignment... */
    PALETTEENTRY	peNew[];	/* New color specifications */
} AVIPALCHANGE;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif /* _INC_AVIFMT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\axcore.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for axcore.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __axcore_h__
#define __axcore_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPin_FWD_DEFINED__
#define __IPin_FWD_DEFINED__
typedef interface IPin IPin;
#endif 	/* __IPin_FWD_DEFINED__ */


#ifndef __IEnumPins_FWD_DEFINED__
#define __IEnumPins_FWD_DEFINED__
typedef interface IEnumPins IEnumPins;
#endif 	/* __IEnumPins_FWD_DEFINED__ */


#ifndef __IEnumMediaTypes_FWD_DEFINED__
#define __IEnumMediaTypes_FWD_DEFINED__
typedef interface IEnumMediaTypes IEnumMediaTypes;
#endif 	/* __IEnumMediaTypes_FWD_DEFINED__ */


#ifndef __IFilterGraph_FWD_DEFINED__
#define __IFilterGraph_FWD_DEFINED__
typedef interface IFilterGraph IFilterGraph;
#endif 	/* __IFilterGraph_FWD_DEFINED__ */


#ifndef __IEnumFilters_FWD_DEFINED__
#define __IEnumFilters_FWD_DEFINED__
typedef interface IEnumFilters IEnumFilters;
#endif 	/* __IEnumFilters_FWD_DEFINED__ */


#ifndef __IEnumFilterInterfaces_FWD_DEFINED__
#define __IEnumFilterInterfaces_FWD_DEFINED__
typedef interface IEnumFilterInterfaces IEnumFilterInterfaces;
#endif 	/* __IEnumFilterInterfaces_FWD_DEFINED__ */


#ifndef __IMediaFilter_FWD_DEFINED__
#define __IMediaFilter_FWD_DEFINED__
typedef interface IMediaFilter IMediaFilter;
#endif 	/* __IMediaFilter_FWD_DEFINED__ */


#ifndef __IBaseFilter_FWD_DEFINED__
#define __IBaseFilter_FWD_DEFINED__
typedef interface IBaseFilter IBaseFilter;
#endif 	/* __IBaseFilter_FWD_DEFINED__ */


#ifndef __IReferenceClock_FWD_DEFINED__
#define __IReferenceClock_FWD_DEFINED__
typedef interface IReferenceClock IReferenceClock;
#endif 	/* __IReferenceClock_FWD_DEFINED__ */


#ifndef __IReferenceClock2_FWD_DEFINED__
#define __IReferenceClock2_FWD_DEFINED__
typedef interface IReferenceClock2 IReferenceClock2;
#endif 	/* __IReferenceClock2_FWD_DEFINED__ */


#ifndef __IMediaSample_FWD_DEFINED__
#define __IMediaSample_FWD_DEFINED__
typedef interface IMediaSample IMediaSample;
#endif 	/* __IMediaSample_FWD_DEFINED__ */


#ifndef __IMediaSample2_FWD_DEFINED__
#define __IMediaSample2_FWD_DEFINED__
typedef interface IMediaSample2 IMediaSample2;
#endif 	/* __IMediaSample2_FWD_DEFINED__ */


#ifndef __IMemAllocator_FWD_DEFINED__
#define __IMemAllocator_FWD_DEFINED__
typedef interface IMemAllocator IMemAllocator;
#endif 	/* __IMemAllocator_FWD_DEFINED__ */


#ifndef __IMemAllocator2_FWD_DEFINED__
#define __IMemAllocator2_FWD_DEFINED__
typedef interface IMemAllocator2 IMemAllocator2;
#endif 	/* __IMemAllocator2_FWD_DEFINED__ */


#ifndef __IMemInputPin_FWD_DEFINED__
#define __IMemInputPin_FWD_DEFINED__
typedef interface IMemInputPin IMemInputPin;
#endif 	/* __IMemInputPin_FWD_DEFINED__ */


#ifndef __IAMovieSetup_FWD_DEFINED__
#define __IAMovieSetup_FWD_DEFINED__
typedef interface IAMovieSetup IAMovieSetup;
#endif 	/* __IAMovieSetup_FWD_DEFINED__ */


#ifndef __IMediaSeeking_FWD_DEFINED__
#define __IMediaSeeking_FWD_DEFINED__
typedef interface IMediaSeeking IMediaSeeking;
#endif 	/* __IMediaSeeking_FWD_DEFINED__ */


#ifndef __IAudioRenderer_FWD_DEFINED__
#define __IAudioRenderer_FWD_DEFINED__
typedef interface IAudioRenderer IAudioRenderer;
#endif 	/* __IAudioRenderer_FWD_DEFINED__ */


#ifndef __IAudioRendererWaveOut_FWD_DEFINED__
#define __IAudioRendererWaveOut_FWD_DEFINED__
typedef interface IAudioRendererWaveOut IAudioRendererWaveOut;
#endif 	/* __IAudioRendererWaveOut_FWD_DEFINED__ */


#ifndef __IFilterGraphCache_FWD_DEFINED__
#define __IFilterGraphCache_FWD_DEFINED__
typedef interface IFilterGraphCache IFilterGraphCache;
#endif 	/* __IFilterGraphCache_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_axcore_0000_0000 */
/* [local] */ 

#define CHARS_IN_GUID     39
typedef struct _AMMediaType
    {
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown *pUnk;
    ULONG cbFormat;
    BYTE *pbFormat;
    } 	AM_MEDIA_TYPE;

typedef 
enum _PinDirection
    {	PINDIR_INPUT	= 0,
	PINDIR_OUTPUT	= ( PINDIR_INPUT + 1 ) 
    } 	PIN_DIRECTION;

#define MAX_PIN_NAME     128
#define MAX_FILTER_NAME  128
typedef LONGLONG REFERENCE_TIME;

typedef double REFTIME;

typedef DWORD_PTR HSEMAPHORE;

typedef DWORD_PTR HEVENT;

typedef struct _AllocatorProperties
    {
    long cBuffers;
    long cbBuffer;
    long cbAlign;
    long cbPrefix;
    } 	ALLOCATOR_PROPERTIES;















extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0000_v0_0_s_ifspec;

#ifndef __IPin_INTERFACE_DEFINED__
#define __IPin_INTERFACE_DEFINED__

/* interface IPin */
/* [unique][uuid][object] */ 

typedef struct _PinInfo
    {
    IBaseFilter *pFilter;
    PIN_DIRECTION dir;
    WCHAR achName[ 128 ];
    } 	PIN_INFO;


EXTERN_C const IID IID_IPin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86891-0ad4-11ce-b03a-0020af0ba770")
    IPin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ IPin *pReceivePin,
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReceiveConnection( 
            /* [in] */ IPin *pConnector,
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectedTo( 
            /* [out] */ IPin **pPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionMediaType( 
            /* [out] */ AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryPinInfo( 
            /* [out] */ PIN_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDirection( 
            /* [out] */ PIN_DIRECTION *pPinDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryId( 
            /* [out] */ LPWSTR *Id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAccept( 
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMediaTypes( 
            /* [out] */ IEnumMediaTypes **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInternalConnections( 
            /* [out] */ IPin **apPin,
            /* [out][in] */ ULONG *nPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndOfStream( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginFlush( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndFlush( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewSegment( 
            /* [in] */ REFERENCE_TIME tStart,
            /* [in] */ REFERENCE_TIME tStop,
            /* [in] */ double dRate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPinVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IPin * This,
            /* [in] */ IPin *pReceivePin,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveConnection )( 
            IPin * This,
            /* [in] */ IPin *pConnector,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectedTo )( 
            IPin * This,
            /* [out] */ IPin **pPin);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionMediaType )( 
            IPin * This,
            /* [out] */ AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *QueryPinInfo )( 
            IPin * This,
            /* [out] */ PIN_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDirection )( 
            IPin * This,
            /* [out] */ PIN_DIRECTION *pPinDir);
        
        HRESULT ( STDMETHODCALLTYPE *QueryId )( 
            IPin * This,
            /* [out] */ LPWSTR *Id);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAccept )( 
            IPin * This,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMediaTypes )( 
            IPin * This,
            /* [out] */ IEnumMediaTypes **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInternalConnections )( 
            IPin * This,
            /* [out] */ IPin **apPin,
            /* [out][in] */ ULONG *nPin);
        
        HRESULT ( STDMETHODCALLTYPE *EndOfStream )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginFlush )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndFlush )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *NewSegment )( 
            IPin * This,
            /* [in] */ REFERENCE_TIME tStart,
            /* [in] */ REFERENCE_TIME tStop,
            /* [in] */ double dRate);
        
        END_INTERFACE
    } IPinVtbl;

    interface IPin
    {
        CONST_VTBL struct IPinVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPin_Connect(This,pReceivePin,pmt)	\
    ( (This)->lpVtbl -> Connect(This,pReceivePin,pmt) ) 

#define IPin_ReceiveConnection(This,pConnector,pmt)	\
    ( (This)->lpVtbl -> ReceiveConnection(This,pConnector,pmt) ) 

#define IPin_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IPin_ConnectedTo(This,pPin)	\
    ( (This)->lpVtbl -> ConnectedTo(This,pPin) ) 

#define IPin_ConnectionMediaType(This,pmt)	\
    ( (This)->lpVtbl -> ConnectionMediaType(This,pmt) ) 

#define IPin_QueryPinInfo(This,pInfo)	\
    ( (This)->lpVtbl -> QueryPinInfo(This,pInfo) ) 

#define IPin_QueryDirection(This,pPinDir)	\
    ( (This)->lpVtbl -> QueryDirection(This,pPinDir) ) 

#define IPin_QueryId(This,Id)	\
    ( (This)->lpVtbl -> QueryId(This,Id) ) 

#define IPin_QueryAccept(This,pmt)	\
    ( (This)->lpVtbl -> QueryAccept(This,pmt) ) 

#define IPin_EnumMediaTypes(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumMediaTypes(This,ppEnum) ) 

#define IPin_QueryInternalConnections(This,apPin,nPin)	\
    ( (This)->lpVtbl -> QueryInternalConnections(This,apPin,nPin) ) 

#define IPin_EndOfStream(This)	\
    ( (This)->lpVtbl -> EndOfStream(This) ) 

#define IPin_BeginFlush(This)	\
    ( (This)->lpVtbl -> BeginFlush(This) ) 

#define IPin_EndFlush(This)	\
    ( (This)->lpVtbl -> EndFlush(This) ) 

#define IPin_NewSegment(This,tStart,tStop,dRate)	\
    ( (This)->lpVtbl -> NewSegment(This,tStart,tStop,dRate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPin_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0001 */
/* [local] */ 

typedef IPin *PPIN;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0001_v0_0_s_ifspec;

#ifndef __IEnumPins_INTERFACE_DEFINED__
#define __IEnumPins_INTERFACE_DEFINED__

/* interface IEnumPins */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumPins;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86892-0ad4-11ce-b03a-0020af0ba770")
    IEnumPins : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cPins,
            /* [size_is][out] */ IPin **ppPins,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cPins) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumPins **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPinsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumPins * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumPins * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumPins * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumPins * This,
            /* [in] */ ULONG cPins,
            /* [size_is][out] */ IPin **ppPins,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumPins * This,
            /* [in] */ ULONG cPins);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumPins * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumPins * This,
            /* [out] */ IEnumPins **ppEnum);
        
        END_INTERFACE
    } IEnumPinsVtbl;

    interface IEnumPins
    {
        CONST_VTBL struct IEnumPinsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPins_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumPins_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumPins_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumPins_Next(This,cPins,ppPins,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cPins,ppPins,pcFetched) ) 

#define IEnumPins_Skip(This,cPins)	\
    ( (This)->lpVtbl -> Skip(This,cPins) ) 

#define IEnumPins_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumPins_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumPins_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0002 */
/* [local] */ 

typedef IEnumPins *PENUMPINS;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0002_v0_0_s_ifspec;

#ifndef __IEnumMediaTypes_INTERFACE_DEFINED__
#define __IEnumMediaTypes_INTERFACE_DEFINED__

/* interface IEnumMediaTypes */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumMediaTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("89c31040-846b-11ce-97d3-00aa0055595a")
    IEnumMediaTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cMediaTypes,
            /* [size_is][out] */ AM_MEDIA_TYPE **ppMediaTypes,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cMediaTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumMediaTypes **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMediaTypesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumMediaTypes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumMediaTypes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumMediaTypes * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumMediaTypes * This,
            /* [in] */ ULONG cMediaTypes,
            /* [size_is][out] */ AM_MEDIA_TYPE **ppMediaTypes,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumMediaTypes * This,
            /* [in] */ ULONG cMediaTypes);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumMediaTypes * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumMediaTypes * This,
            /* [out] */ IEnumMediaTypes **ppEnum);
        
        END_INTERFACE
    } IEnumMediaTypesVtbl;

    interface IEnumMediaTypes
    {
        CONST_VTBL struct IEnumMediaTypesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMediaTypes_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumMediaTypes_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumMediaTypes_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumMediaTypes_Next(This,cMediaTypes,ppMediaTypes,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cMediaTypes,ppMediaTypes,pcFetched) ) 

#define IEnumMediaTypes_Skip(This,cMediaTypes)	\
    ( (This)->lpVtbl -> Skip(This,cMediaTypes) ) 

#define IEnumMediaTypes_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumMediaTypes_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumMediaTypes_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0003 */
/* [local] */ 

typedef IEnumMediaTypes *PENUMMEDIATYPES;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0003_v0_0_s_ifspec;

#ifndef __IFilterGraph_INTERFACE_DEFINED__
#define __IFilterGraph_INTERFACE_DEFINED__

/* interface IFilterGraph */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFilterGraph;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a8689f-0ad4-11ce-b03a-0020af0ba770")
    IFilterGraph : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddFilter( 
            /* [in] */ IBaseFilter *pFilter,
            /* [string][in] */ LPCWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFilter( 
            /* [in] */ IBaseFilter *pFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFilters( 
            /* [out] */ IEnumFilters **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFilterByName( 
            /* [string][in] */ LPCWSTR pName,
            /* [out] */ IBaseFilter **ppFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectDirect( 
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn,
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reconnect( 
            /* [in] */ IPin *ppin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [in] */ IPin *ppin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultSyncSource( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterGraphVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterGraph * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterGraph * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterGraph * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilter )( 
            IFilterGraph * This,
            /* [in] */ IBaseFilter *pFilter,
            /* [string][in] */ LPCWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilter )( 
            IFilterGraph * This,
            /* [in] */ IBaseFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFilters )( 
            IFilterGraph * This,
            /* [out] */ IEnumFilters **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindFilterByName )( 
            IFilterGraph * This,
            /* [string][in] */ LPCWSTR pName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDirect )( 
            IFilterGraph * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *Reconnect )( 
            IFilterGraph * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IFilterGraph * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSyncSource )( 
            IFilterGraph * This);
        
        END_INTERFACE
    } IFilterGraphVtbl;

    interface IFilterGraph
    {
        CONST_VTBL struct IFilterGraphVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterGraph_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFilterGraph_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFilterGraph_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFilterGraph_AddFilter(This,pFilter,pName)	\
    ( (This)->lpVtbl -> AddFilter(This,pFilter,pName) ) 

#define IFilterGraph_RemoveFilter(This,pFilter)	\
    ( (This)->lpVtbl -> RemoveFilter(This,pFilter) ) 

#define IFilterGraph_EnumFilters(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumFilters(This,ppEnum) ) 

#define IFilterGraph_FindFilterByName(This,pName,ppFilter)	\
    ( (This)->lpVtbl -> FindFilterByName(This,pName,ppFilter) ) 

#define IFilterGraph_ConnectDirect(This,ppinOut,ppinIn,pmt)	\
    ( (This)->lpVtbl -> ConnectDirect(This,ppinOut,ppinIn,pmt) ) 

#define IFilterGraph_Reconnect(This,ppin)	\
    ( (This)->lpVtbl -> Reconnect(This,ppin) ) 

#define IFilterGraph_Disconnect(This,ppin)	\
    ( (This)->lpVtbl -> Disconnect(This,ppin) ) 

#define IFilterGraph_SetDefaultSyncSource(This)	\
    ( (This)->lpVtbl -> SetDefaultSyncSource(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFilterGraph_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0004 */
/* [local] */ 

typedef IFilterGraph *PFILTERGRAPH;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0004_v0_0_s_ifspec;

#ifndef __IEnumFilters_INTERFACE_DEFINED__
#define __IEnumFilters_INTERFACE_DEFINED__

/* interface IEnumFilters */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumFilters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86893-0ad4-11ce-b03a-0020af0ba770")
    IEnumFilters : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cFilters,
            /* [out] */ IBaseFilter **ppFilter,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cFilters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumFilters **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumFiltersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumFilters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumFilters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumFilters * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumFilters * This,
            /* [in] */ ULONG cFilters,
            /* [out] */ IBaseFilter **ppFilter,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumFilters * This,
            /* [in] */ ULONG cFilters);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumFilters * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumFilters * This,
            /* [out] */ IEnumFilters **ppEnum);
        
        END_INTERFACE
    } IEnumFiltersVtbl;

    interface IEnumFilters
    {
        CONST_VTBL struct IEnumFiltersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumFilters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumFilters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumFilters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumFilters_Next(This,cFilters,ppFilter,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cFilters,ppFilter,pcFetched) ) 

#define IEnumFilters_Skip(This,cFilters)	\
    ( (This)->lpVtbl -> Skip(This,cFilters) ) 

#define IEnumFilters_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumFilters_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumFilters_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0005 */
/* [local] */ 

typedef IEnumFilters *PENUMFILTERS;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0005_v0_0_s_ifspec;

#ifndef __IEnumFilterInterfaces_INTERFACE_DEFINED__
#define __IEnumFilterInterfaces_INTERFACE_DEFINED__

/* interface IEnumFilterInterfaces */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IEnumFilterInterfaces;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F845653C-2777-4d84-A50D-26D3397D5C75")
    IEnumFilterInterfaces : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [out] */ IUnknown **ppUnknown,
            /* [in] */ UINT32 cchFilterName,
            /* [size_is][string][out][in] */ wchar_t *pwszFilterName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumFilterInterfacesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumFilterInterfaces * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumFilterInterfaces * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumFilterInterfaces * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumFilterInterfaces * This,
            /* [out] */ IUnknown **ppUnknown,
            /* [in] */ UINT32 cchFilterName,
            /* [size_is][string][out][in] */ wchar_t *pwszFilterName);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumFilterInterfaces * This);
        
        END_INTERFACE
    } IEnumFilterInterfacesVtbl;

    interface IEnumFilterInterfaces
    {
        CONST_VTBL struct IEnumFilterInterfacesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumFilterInterfaces_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumFilterInterfaces_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumFilterInterfaces_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumFilterInterfaces_Next(This,ppUnknown,cchFilterName,pwszFilterName)	\
    ( (This)->lpVtbl -> Next(This,ppUnknown,cchFilterName,pwszFilterName) ) 

#define IEnumFilterInterfaces_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumFilterInterfaces_INTERFACE_DEFINED__ */


#ifndef __IMediaFilter_INTERFACE_DEFINED__
#define __IMediaFilter_INTERFACE_DEFINED__

/* interface IMediaFilter */
/* [unique][uuid][object] */ 

typedef 
enum _FilterState
    {	State_Stopped	= 0,
	State_Paused	= ( State_Stopped + 1 ) ,
	State_Running	= ( State_Paused + 1 ) 
    } 	FILTER_STATE;


EXTERN_C const IID IID_IMediaFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86899-0ad4-11ce-b03a-0020af0ba770")
    IMediaFilter : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            REFERENCE_TIME tStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ DWORD dwMilliSecsTimeout,
            /* [out] */ FILTER_STATE *State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncSource( 
            /* [in] */ IReferenceClock *pClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncSource( 
            /* [out] */ IReferenceClock **pClock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IMediaFilter * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMediaFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMediaFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMediaFilter * This,
            REFERENCE_TIME tStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMediaFilter * This,
            /* [in] */ DWORD dwMilliSecsTimeout,
            /* [out] */ FILTER_STATE *State);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncSource )( 
            IMediaFilter * This,
            /* [in] */ IReferenceClock *pClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncSource )( 
            IMediaFilter * This,
            /* [out] */ IReferenceClock **pClock);
        
        END_INTERFACE
    } IMediaFilterVtbl;

    interface IMediaFilter
    {
        CONST_VTBL struct IMediaFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaFilter_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IMediaFilter_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMediaFilter_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IMediaFilter_Run(This,tStart)	\
    ( (This)->lpVtbl -> Run(This,tStart) ) 

#define IMediaFilter_GetState(This,dwMilliSecsTimeout,State)	\
    ( (This)->lpVtbl -> GetState(This,dwMilliSecsTimeout,State) ) 

#define IMediaFilter_SetSyncSource(This,pClock)	\
    ( (This)->lpVtbl -> SetSyncSource(This,pClock) ) 

#define IMediaFilter_GetSyncSource(This,pClock)	\
    ( (This)->lpVtbl -> GetSyncSource(This,pClock) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0007 */
/* [local] */ 

typedef IMediaFilter *PMEDIAFILTER;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0007_v0_0_s_ifspec;

#ifndef __IBaseFilter_INTERFACE_DEFINED__
#define __IBaseFilter_INTERFACE_DEFINED__

/* interface IBaseFilter */
/* [unique][uuid][object] */ 

typedef struct _FilterInfo
    {
    WCHAR achName[ 128 ];
    IFilterGraph *pGraph;
    } 	FILTER_INFO;


EXTERN_C const IID IID_IBaseFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86895-0ad4-11ce-b03a-0020af0ba770")
    IBaseFilter : public IMediaFilter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumPins( 
            /* [out] */ IEnumPins **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindPin( 
            /* [string][in] */ LPCWSTR Id,
            /* [out] */ IPin **ppPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryFilterInfo( 
            /* [out] */ FILTER_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JoinFilterGraph( 
            /* [in] */ IFilterGraph *pGraph,
            /* [string][in] */ LPCWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryVendorInfo( 
            /* [string][out] */ LPWSTR *pVendorInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBaseFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBaseFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBaseFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBaseFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IBaseFilter * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IBaseFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IBaseFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IBaseFilter * This,
            REFERENCE_TIME tStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IBaseFilter * This,
            /* [in] */ DWORD dwMilliSecsTimeout,
            /* [out] */ FILTER_STATE *State);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncSource )( 
            IBaseFilter * This,
            /* [in] */ IReferenceClock *pClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncSource )( 
            IBaseFilter * This,
            /* [out] */ IReferenceClock **pClock);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPins )( 
            IBaseFilter * This,
            /* [out] */ IEnumPins **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindPin )( 
            IBaseFilter * This,
            /* [string][in] */ LPCWSTR Id,
            /* [out] */ IPin **ppPin);
        
        HRESULT ( STDMETHODCALLTYPE *QueryFilterInfo )( 
            IBaseFilter * This,
            /* [out] */ FILTER_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *JoinFilterGraph )( 
            IBaseFilter * This,
            /* [in] */ IFilterGraph *pGraph,
            /* [string][in] */ LPCWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryVendorInfo )( 
            IBaseFilter * This,
            /* [string][out] */ LPWSTR *pVendorInfo);
        
        END_INTERFACE
    } IBaseFilterVtbl;

    interface IBaseFilter
    {
        CONST_VTBL struct IBaseFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBaseFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBaseFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBaseFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBaseFilter_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IBaseFilter_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IBaseFilter_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IBaseFilter_Run(This,tStart)	\
    ( (This)->lpVtbl -> Run(This,tStart) ) 

#define IBaseFilter_GetState(This,dwMilliSecsTimeout,State)	\
    ( (This)->lpVtbl -> GetState(This,dwMilliSecsTimeout,State) ) 

#define IBaseFilter_SetSyncSource(This,pClock)	\
    ( (This)->lpVtbl -> SetSyncSource(This,pClock) ) 

#define IBaseFilter_GetSyncSource(This,pClock)	\
    ( (This)->lpVtbl -> GetSyncSource(This,pClock) ) 


#define IBaseFilter_EnumPins(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumPins(This,ppEnum) ) 

#define IBaseFilter_FindPin(This,Id,ppPin)	\
    ( (This)->lpVtbl -> FindPin(This,Id,ppPin) ) 

#define IBaseFilter_QueryFilterInfo(This,pInfo)	\
    ( (This)->lpVtbl -> QueryFilterInfo(This,pInfo) ) 

#define IBaseFilter_JoinFilterGraph(This,pGraph,pName)	\
    ( (This)->lpVtbl -> JoinFilterGraph(This,pGraph,pName) ) 

#define IBaseFilter_QueryVendorInfo(This,pVendorInfo)	\
    ( (This)->lpVtbl -> QueryVendorInfo(This,pVendorInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBaseFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0008 */
/* [local] */ 

typedef IBaseFilter *PFILTER;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0008_v0_0_s_ifspec;

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

/* interface IReferenceClock */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IReferenceClock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86897-0ad4-11ce-b03a-0020af0ba770")
    IReferenceClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ REFERENCE_TIME *pTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseTime( 
            /* [in] */ REFERENCE_TIME baseTime,
            /* [in] */ REFERENCE_TIME streamTime,
            /* [in] */ HEVENT hEvent,
            /* [out] */ DWORD_PTR *pdwAdviseCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
            /* [in] */ REFERENCE_TIME startTime,
            /* [in] */ REFERENCE_TIME periodTime,
            /* [in] */ HSEMAPHORE hSemaphore,
            /* [out] */ DWORD_PTR *pdwAdviseCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD_PTR dwAdviseCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReferenceClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IReferenceClock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IReferenceClock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IReferenceClock * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IReferenceClock * This,
            /* [out] */ REFERENCE_TIME *pTime);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseTime )( 
            IReferenceClock * This,
            /* [in] */ REFERENCE_TIME baseTime,
            /* [in] */ REFERENCE_TIME streamTime,
            /* [in] */ HEVENT hEvent,
            /* [out] */ DWORD_PTR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AdvisePeriodic )( 
            IReferenceClock * This,
            /* [in] */ REFERENCE_TIME startTime,
            /* [in] */ REFERENCE_TIME periodTime,
            /* [in] */ HSEMAPHORE hSemaphore,
            /* [out] */ DWORD_PTR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IReferenceClock * This,
            /* [in] */ DWORD_PTR dwAdviseCookie);
        
        END_INTERFACE
    } IReferenceClockVtbl;

    interface IReferenceClock
    {
        CONST_VTBL struct IReferenceClockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReferenceClock_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IReferenceClock_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IReferenceClock_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IReferenceClock_GetTime(This,pTime)	\
    ( (This)->lpVtbl -> GetTime(This,pTime) ) 

#define IReferenceClock_AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie)	\
    ( (This)->lpVtbl -> AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie) ) 

#define IReferenceClock_AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie)	\
    ( (This)->lpVtbl -> AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie) ) 

#define IReferenceClock_Unadvise(This,dwAdviseCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwAdviseCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IReferenceClock_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0009 */
/* [local] */ 

typedef IReferenceClock *PREFERENCECLOCK;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0009_v0_0_s_ifspec;

#ifndef __IReferenceClock2_INTERFACE_DEFINED__
#define __IReferenceClock2_INTERFACE_DEFINED__

/* interface IReferenceClock2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IReferenceClock2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73885-c2c8-11cf-8b46-00805f6cef60")
    IReferenceClock2 : public IReferenceClock
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IReferenceClock2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IReferenceClock2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IReferenceClock2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IReferenceClock2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IReferenceClock2 * This,
            /* [out] */ REFERENCE_TIME *pTime);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseTime )( 
            IReferenceClock2 * This,
            /* [in] */ REFERENCE_TIME baseTime,
            /* [in] */ REFERENCE_TIME streamTime,
            /* [in] */ HEVENT hEvent,
            /* [out] */ DWORD_PTR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AdvisePeriodic )( 
            IReferenceClock2 * This,
            /* [in] */ REFERENCE_TIME startTime,
            /* [in] */ REFERENCE_TIME periodTime,
            /* [in] */ HSEMAPHORE hSemaphore,
            /* [out] */ DWORD_PTR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IReferenceClock2 * This,
            /* [in] */ DWORD_PTR dwAdviseCookie);
        
        END_INTERFACE
    } IReferenceClock2Vtbl;

    interface IReferenceClock2
    {
        CONST_VTBL struct IReferenceClock2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReferenceClock2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IReferenceClock2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IReferenceClock2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IReferenceClock2_GetTime(This,pTime)	\
    ( (This)->lpVtbl -> GetTime(This,pTime) ) 

#define IReferenceClock2_AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie)	\
    ( (This)->lpVtbl -> AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie) ) 

#define IReferenceClock2_AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie)	\
    ( (This)->lpVtbl -> AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie) ) 

#define IReferenceClock2_Unadvise(This,dwAdviseCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwAdviseCookie) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IReferenceClock2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0010 */
/* [local] */ 

typedef IReferenceClock2 *PREFERENCECLOCK2;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0010_v0_0_s_ifspec;

#ifndef __IMediaSample_INTERFACE_DEFINED__
#define __IMediaSample_INTERFACE_DEFINED__

/* interface IMediaSample */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IMediaSample;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a8689a-0ad4-11ce-b03a-0020af0ba770")
    IMediaSample : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPointer( 
            /* [out] */ BYTE **ppBuffer) = 0;
        
        virtual long STDMETHODCALLTYPE GetSize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ REFERENCE_TIME *pTimeStart,
            /* [out] */ REFERENCE_TIME *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTime( 
            /* [in] */ REFERENCE_TIME *pTimeStart,
            /* [in] */ REFERENCE_TIME *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSyncPoint( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncPoint( 
            BOOL bIsSyncPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPreroll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPreroll( 
            BOOL bIsPreroll) = 0;
        
        virtual long STDMETHODCALLTYPE GetActualDataLength( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActualDataLength( 
            long __MIDL__IMediaSample0000) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            AM_MEDIA_TYPE **ppMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            AM_MEDIA_TYPE *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDiscontinuity( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDiscontinuity( 
            BOOL bDiscontinuity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaTime( 
            /* [out] */ LONGLONG *pTimeStart,
            /* [out] */ LONGLONG *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaTime( 
            /* [in] */ LONGLONG *pTimeStart,
            /* [in] */ LONGLONG *pTimeEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaSampleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaSample * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaSample * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointer )( 
            IMediaSample * This,
            /* [out] */ BYTE **ppBuffer);
        
        long ( STDMETHODCALLTYPE *GetSize )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IMediaSample * This,
            /* [out] */ REFERENCE_TIME *pTimeStart,
            /* [out] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetTime )( 
            IMediaSample * This,
            /* [in] */ REFERENCE_TIME *pTimeStart,
            /* [in] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *IsSyncPoint )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncPoint )( 
            IMediaSample * This,
            BOOL bIsSyncPoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsPreroll )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreroll )( 
            IMediaSample * This,
            BOOL bIsPreroll);
        
        long ( STDMETHODCALLTYPE *GetActualDataLength )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetActualDataLength )( 
            IMediaSample * This,
            long __MIDL__IMediaSample0000);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IMediaSample * This,
            AM_MEDIA_TYPE **ppMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IMediaSample * This,
            AM_MEDIA_TYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *IsDiscontinuity )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDiscontinuity )( 
            IMediaSample * This,
            BOOL bDiscontinuity);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaTime )( 
            IMediaSample * This,
            /* [out] */ LONGLONG *pTimeStart,
            /* [out] */ LONGLONG *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaTime )( 
            IMediaSample * This,
            /* [in] */ LONGLONG *pTimeStart,
            /* [in] */ LONGLONG *pTimeEnd);
        
        END_INTERFACE
    } IMediaSampleVtbl;

    interface IMediaSample
    {
        CONST_VTBL struct IMediaSampleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaSample_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaSample_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaSample_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaSample_GetPointer(This,ppBuffer)	\
    ( (This)->lpVtbl -> GetPointer(This,ppBuffer) ) 

#define IMediaSample_GetSize(This)	\
    ( (This)->lpVtbl -> GetSize(This) ) 

#define IMediaSample_GetTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> GetTime(This,pTimeStart,pTimeEnd) ) 

#define IMediaSample_SetTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> SetTime(This,pTimeStart,pTimeEnd) ) 

#define IMediaSample_IsSyncPoint(This)	\
    ( (This)->lpVtbl -> IsSyncPoint(This) ) 

#define IMediaSample_SetSyncPoint(This,bIsSyncPoint)	\
    ( (This)->lpVtbl -> SetSyncPoint(This,bIsSyncPoint) ) 

#define IMediaSample_IsPreroll(This)	\
    ( (This)->lpVtbl -> IsPreroll(This) ) 

#define IMediaSample_SetPreroll(This,bIsPreroll)	\
    ( (This)->lpVtbl -> SetPreroll(This,bIsPreroll) ) 

#define IMediaSample_GetActualDataLength(This)	\
    ( (This)->lpVtbl -> GetActualDataLength(This) ) 

#define IMediaSample_SetActualDataLength(This,__MIDL__IMediaSample0000)	\
    ( (This)->lpVtbl -> SetActualDataLength(This,__MIDL__IMediaSample0000) ) 

#define IMediaSample_GetMediaType(This,ppMediaType)	\
    ( (This)->lpVtbl -> GetMediaType(This,ppMediaType) ) 

#define IMediaSample_SetMediaType(This,pMediaType)	\
    ( (This)->lpVtbl -> SetMediaType(This,pMediaType) ) 

#define IMediaSample_IsDiscontinuity(This)	\
    ( (This)->lpVtbl -> IsDiscontinuity(This) ) 

#define IMediaSample_SetDiscontinuity(This,bDiscontinuity)	\
    ( (This)->lpVtbl -> SetDiscontinuity(This,bDiscontinuity) ) 

#define IMediaSample_GetMediaTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> GetMediaTime(This,pTimeStart,pTimeEnd) ) 

#define IMediaSample_SetMediaTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> SetMediaTime(This,pTimeStart,pTimeEnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaSample_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0011 */
/* [local] */ 

typedef IMediaSample *PMEDIASAMPLE;


enum tagAM_SAMPLE_PROPERTY_FLAGS
    {	AM_SAMPLE_SPLICEPOINT	= 0x1,
	AM_SAMPLE_PREROLL	= 0x2,
	AM_SAMPLE_DATADISCONTINUITY	= 0x4,
	AM_SAMPLE_TYPECHANGED	= 0x8,
	AM_SAMPLE_TIMEVALID	= 0x10,
	AM_SAMPLE_TIMEDISCONTINUITY	= 0x40,
	AM_SAMPLE_FLUSH_ON_PAUSE	= 0x80,
	AM_SAMPLE_STOPVALID	= 0x100,
	AM_SAMPLE_ENDOFSTREAM	= 0x200,
	AM_STREAM_MEDIA	= 0,
	AM_STREAM_CONTROL	= 1
    } ;
typedef struct tagAM_SAMPLE2_PROPERTIES
    {
    DWORD cbData;
    DWORD dwTypeSpecificFlags;
    DWORD dwSampleFlags;
    LONG lActual;
    REFERENCE_TIME tStart;
    REFERENCE_TIME tStop;
    DWORD dwStreamId;
    AM_MEDIA_TYPE *pMediaType;
    BYTE *pbBuffer;
    LONG cbBuffer;
    } 	AM_SAMPLE2_PROPERTIES;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0011_v0_0_s_ifspec;

#ifndef __IMediaSample2_INTERFACE_DEFINED__
#define __IMediaSample2_INTERFACE_DEFINED__

/* interface IMediaSample2 */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IMediaSample2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73884-c2c8-11cf-8b46-00805f6cef60")
    IMediaSample2 : public IMediaSample
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [in] */ DWORD cbProperties,
            /* [size_is][out] */ BYTE *pbProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ DWORD cbProperties,
            /* [size_is][in] */ const BYTE *pbProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaSample2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaSample2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaSample2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointer )( 
            IMediaSample2 * This,
            /* [out] */ BYTE **ppBuffer);
        
        long ( STDMETHODCALLTYPE *GetSize )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IMediaSample2 * This,
            /* [out] */ REFERENCE_TIME *pTimeStart,
            /* [out] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetTime )( 
            IMediaSample2 * This,
            /* [in] */ REFERENCE_TIME *pTimeStart,
            /* [in] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *IsSyncPoint )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncPoint )( 
            IMediaSample2 * This,
            BOOL bIsSyncPoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsPreroll )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreroll )( 
            IMediaSample2 * This,
            BOOL bIsPreroll);
        
        long ( STDMETHODCALLTYPE *GetActualDataLength )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetActualDataLength )( 
            IMediaSample2 * This,
            long __MIDL__IMediaSample0000);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IMediaSample2 * This,
            AM_MEDIA_TYPE **ppMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IMediaSample2 * This,
            AM_MEDIA_TYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *IsDiscontinuity )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDiscontinuity )( 
            IMediaSample2 * This,
            BOOL bDiscontinuity);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaTime )( 
            IMediaSample2 * This,
            /* [out] */ LONGLONG *pTimeStart,
            /* [out] */ LONGLONG *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaTime )( 
            IMediaSample2 * This,
            /* [in] */ LONGLONG *pTimeStart,
            /* [in] */ LONGLONG *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IMediaSample2 * This,
            /* [in] */ DWORD cbProperties,
            /* [size_is][out] */ BYTE *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            IMediaSample2 * This,
            /* [in] */ DWORD cbProperties,
            /* [size_is][in] */ const BYTE *pbProperties);
        
        END_INTERFACE
    } IMediaSample2Vtbl;

    interface IMediaSample2
    {
        CONST_VTBL struct IMediaSample2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaSample2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaSample2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaSample2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaSample2_GetPointer(This,ppBuffer)	\
    ( (This)->lpVtbl -> GetPointer(This,ppBuffer) ) 

#define IMediaSample2_GetSize(This)	\
    ( (This)->lpVtbl -> GetSize(This) ) 

#define IMediaSample2_GetTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> GetTime(This,pTimeStart,pTimeEnd) ) 

#define IMediaSample2_SetTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> SetTime(This,pTimeStart,pTimeEnd) ) 

#define IMediaSample2_IsSyncPoint(This)	\
    ( (This)->lpVtbl -> IsSyncPoint(This) ) 

#define IMediaSample2_SetSyncPoint(This,bIsSyncPoint)	\
    ( (This)->lpVtbl -> SetSyncPoint(This,bIsSyncPoint) ) 

#define IMediaSample2_IsPreroll(This)	\
    ( (This)->lpVtbl -> IsPreroll(This) ) 

#define IMediaSample2_SetPreroll(This,bIsPreroll)	\
    ( (This)->lpVtbl -> SetPreroll(This,bIsPreroll) ) 

#define IMediaSample2_GetActualDataLength(This)	\
    ( (This)->lpVtbl -> GetActualDataLength(This) ) 

#define IMediaSample2_SetActualDataLength(This,__MIDL__IMediaSample0000)	\
    ( (This)->lpVtbl -> SetActualDataLength(This,__MIDL__IMediaSample0000) ) 

#define IMediaSample2_GetMediaType(This,ppMediaType)	\
    ( (This)->lpVtbl -> GetMediaType(This,ppMediaType) ) 

#define IMediaSample2_SetMediaType(This,pMediaType)	\
    ( (This)->lpVtbl -> SetMediaType(This,pMediaType) ) 

#define IMediaSample2_IsDiscontinuity(This)	\
    ( (This)->lpVtbl -> IsDiscontinuity(This) ) 

#define IMediaSample2_SetDiscontinuity(This,bDiscontinuity)	\
    ( (This)->lpVtbl -> SetDiscontinuity(This,bDiscontinuity) ) 

#define IMediaSample2_GetMediaTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> GetMediaTime(This,pTimeStart,pTimeEnd) ) 

#define IMediaSample2_SetMediaTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> SetMediaTime(This,pTimeStart,pTimeEnd) ) 


#define IMediaSample2_GetProperties(This,cbProperties,pbProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,cbProperties,pbProperties) ) 

#define IMediaSample2_SetProperties(This,cbProperties,pbProperties)	\
    ( (This)->lpVtbl -> SetProperties(This,cbProperties,pbProperties) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaSample2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0012 */
/* [local] */ 

typedef IMediaSample2 *PMEDIASAMPLE2;

#define AM_GBF_PREVFRAMESKIPPED 1
#define AM_GBF_NOTASYNCPOINT 2
#define AM_GBF_NOWAIT 4
#define AM_GBF_NODDSURFACELOCK 8


extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0012_v0_0_s_ifspec;

#ifndef __IMemAllocator_INTERFACE_DEFINED__
#define __IMemAllocator_INTERFACE_DEFINED__

/* interface IMemAllocator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMemAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a8689c-0ad4-11ce-b03a-0020af0ba770")
    IMemAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ ALLOCATOR_PROPERTIES *pRequest,
            /* [out] */ ALLOCATOR_PROPERTIES *pActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ ALLOCATOR_PROPERTIES *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Decommit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [out] */ IMediaSample **ppBuffer,
            /* [in] */ REFERENCE_TIME *pStartTime,
            /* [in] */ REFERENCE_TIME *pEndTime,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseBuffer( 
            /* [in] */ IMediaSample *pBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMemAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMemAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMemAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMemAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            IMemAllocator * This,
            /* [in] */ ALLOCATOR_PROPERTIES *pRequest,
            /* [out] */ ALLOCATOR_PROPERTIES *pActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IMemAllocator * This,
            /* [out] */ ALLOCATOR_PROPERTIES *pProps);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IMemAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Decommit )( 
            IMemAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IMemAllocator * This,
            /* [out] */ IMediaSample **ppBuffer,
            /* [in] */ REFERENCE_TIME *pStartTime,
            /* [in] */ REFERENCE_TIME *pEndTime,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
            IMemAllocator * This,
            /* [in] */ IMediaSample *pBuffer);
        
        END_INTERFACE
    } IMemAllocatorVtbl;

    interface IMemAllocator
    {
        CONST_VTBL struct IMemAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMemAllocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMemAllocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMemAllocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMemAllocator_SetProperties(This,pRequest,pActual)	\
    ( (This)->lpVtbl -> SetProperties(This,pRequest,pActual) ) 

#define IMemAllocator_GetProperties(This,pProps)	\
    ( (This)->lpVtbl -> GetProperties(This,pProps) ) 

#define IMemAllocator_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#define IMemAllocator_Decommit(This)	\
    ( (This)->lpVtbl -> Decommit(This) ) 

#define IMemAllocator_GetBuffer(This,ppBuffer,pStartTime,pEndTime,dwFlags)	\
    ( (This)->lpVtbl -> GetBuffer(This,ppBuffer,pStartTime,pEndTime,dwFlags) ) 

#define IMemAllocator_ReleaseBuffer(This,pBuffer)	\
    ( (This)->lpVtbl -> ReleaseBuffer(This,pBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMemAllocator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0013 */
/* [local] */ 

typedef IMemAllocator *PMEMALLOCATOR;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0013_v0_0_s_ifspec;

#ifndef __IMemAllocator2_INTERFACE_DEFINED__
#define __IMemAllocator2_INTERFACE_DEFINED__

/* interface IMemAllocator2 */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IMemAllocator2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fa04cdc8-cb49-11d1-a4ef-00c04fb6fa12")
    IMemAllocator2 : public IMemAllocator
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBusyCount( 
            DWORD *pdwBusyCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFreeCount( 
            DWORD *pdwFreeCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMemAllocator2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMemAllocator2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMemAllocator2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMemAllocator2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            IMemAllocator2 * This,
            /* [in] */ ALLOCATOR_PROPERTIES *pRequest,
            /* [out] */ ALLOCATOR_PROPERTIES *pActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IMemAllocator2 * This,
            /* [out] */ ALLOCATOR_PROPERTIES *pProps);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IMemAllocator2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Decommit )( 
            IMemAllocator2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IMemAllocator2 * This,
            /* [out] */ IMediaSample **ppBuffer,
            /* [in] */ REFERENCE_TIME *pStartTime,
            /* [in] */ REFERENCE_TIME *pEndTime,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
            IMemAllocator2 * This,
            /* [in] */ IMediaSample *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetBusyCount )( 
            IMemAllocator2 * This,
            DWORD *pdwBusyCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetFreeCount )( 
            IMemAllocator2 * This,
            DWORD *pdwFreeCount);
        
        END_INTERFACE
    } IMemAllocator2Vtbl;

    interface IMemAllocator2
    {
        CONST_VTBL struct IMemAllocator2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMemAllocator2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMemAllocator2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMemAllocator2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMemAllocator2_SetProperties(This,pRequest,pActual)	\
    ( (This)->lpVtbl -> SetProperties(This,pRequest,pActual) ) 

#define IMemAllocator2_GetProperties(This,pProps)	\
    ( (This)->lpVtbl -> GetProperties(This,pProps) ) 

#define IMemAllocator2_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#define IMemAllocator2_Decommit(This)	\
    ( (This)->lpVtbl -> Decommit(This) ) 

#define IMemAllocator2_GetBuffer(This,ppBuffer,pStartTime,pEndTime,dwFlags)	\
    ( (This)->lpVtbl -> GetBuffer(This,ppBuffer,pStartTime,pEndTime,dwFlags) ) 

#define IMemAllocator2_ReleaseBuffer(This,pBuffer)	\
    ( (This)->lpVtbl -> ReleaseBuffer(This,pBuffer) ) 


#define IMemAllocator2_GetBusyCount(This,pdwBusyCount)	\
    ( (This)->lpVtbl -> GetBusyCount(This,pdwBusyCount) ) 

#define IMemAllocator2_GetFreeCount(This,pdwFreeCount)	\
    ( (This)->lpVtbl -> GetFreeCount(This,pdwFreeCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMemAllocator2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0014 */
/* [local] */ 

typedef IMemAllocator2 *PMEMALLOCATOR2;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0014_v0_0_s_ifspec;

#ifndef __IMemInputPin_INTERFACE_DEFINED__
#define __IMemInputPin_INTERFACE_DEFINED__

/* interface IMemInputPin */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMemInputPin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a8689d-0ad4-11ce-b03a-0020af0ba770")
    IMemInputPin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAllocator( 
            /* [out] */ IMemAllocator **ppAllocator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyAllocator( 
            /* [in] */ IMemAllocator *pAllocator,
            /* [in] */ BOOL bReadOnly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocatorRequirements( 
            /* [out] */ ALLOCATOR_PROPERTIES *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Receive( 
            /* [in] */ IMediaSample *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReceiveMultiple( 
            /* [size_is][in] */ IMediaSample **pSamples,
            /* [in] */ long nSamples,
            /* [out] */ long *nSamplesProcessed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReceiveCanBlock( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMemInputPinVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMemInputPin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMemInputPin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMemInputPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocator )( 
            IMemInputPin * This,
            /* [out] */ IMemAllocator **ppAllocator);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyAllocator )( 
            IMemInputPin * This,
            /* [in] */ IMemAllocator *pAllocator,
            /* [in] */ BOOL bReadOnly);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatorRequirements )( 
            IMemInputPin * This,
            /* [out] */ ALLOCATOR_PROPERTIES *pProps);
        
        HRESULT ( STDMETHODCALLTYPE *Receive )( 
            IMemInputPin * This,
            /* [in] */ IMediaSample *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveMultiple )( 
            IMemInputPin * This,
            /* [size_is][in] */ IMediaSample **pSamples,
            /* [in] */ long nSamples,
            /* [out] */ long *nSamplesProcessed);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveCanBlock )( 
            IMemInputPin * This);
        
        END_INTERFACE
    } IMemInputPinVtbl;

    interface IMemInputPin
    {
        CONST_VTBL struct IMemInputPinVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMemInputPin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMemInputPin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMemInputPin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMemInputPin_GetAllocator(This,ppAllocator)	\
    ( (This)->lpVtbl -> GetAllocator(This,ppAllocator) ) 

#define IMemInputPin_NotifyAllocator(This,pAllocator,bReadOnly)	\
    ( (This)->lpVtbl -> NotifyAllocator(This,pAllocator,bReadOnly) ) 

#define IMemInputPin_GetAllocatorRequirements(This,pProps)	\
    ( (This)->lpVtbl -> GetAllocatorRequirements(This,pProps) ) 

#define IMemInputPin_Receive(This,pSample)	\
    ( (This)->lpVtbl -> Receive(This,pSample) ) 

#define IMemInputPin_ReceiveMultiple(This,pSamples,nSamples,nSamplesProcessed)	\
    ( (This)->lpVtbl -> ReceiveMultiple(This,pSamples,nSamples,nSamplesProcessed) ) 

#define IMemInputPin_ReceiveCanBlock(This)	\
    ( (This)->lpVtbl -> ReceiveCanBlock(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMemInputPin_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0015 */
/* [local] */ 

typedef IMemInputPin *PMEMINPUTPIN;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0015_v0_0_s_ifspec;

#ifndef __IAMovieSetup_INTERFACE_DEFINED__
#define __IAMovieSetup_INTERFACE_DEFINED__

/* interface IAMovieSetup */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMovieSetup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a3d8cec0-7e5a-11cf-bbc5-00805f6cef20")
    IAMovieSetup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Register( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unregister( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMovieSetupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMovieSetup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMovieSetup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMovieSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Register )( 
            IAMovieSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unregister )( 
            IAMovieSetup * This);
        
        END_INTERFACE
    } IAMovieSetupVtbl;

    interface IAMovieSetup
    {
        CONST_VTBL struct IAMovieSetupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMovieSetup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMovieSetup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMovieSetup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMovieSetup_Register(This)	\
    ( (This)->lpVtbl -> Register(This) ) 

#define IAMovieSetup_Unregister(This)	\
    ( (This)->lpVtbl -> Unregister(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMovieSetup_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0016 */
/* [local] */ 

typedef IAMovieSetup *PAMOVIESETUP;

typedef 
enum AM_SEEKING_SeekingFlags
    {	AM_SEEKING_NoPositioning	= 0,
	AM_SEEKING_AbsolutePositioning	= 0x1,
	AM_SEEKING_RelativePositioning	= 0x2,
	AM_SEEKING_IncrementalPositioning	= 0x3,
	AM_SEEKING_PositioningBitsMask	= 0x3,
	AM_SEEKING_SeekToKeyFrame	= 0x4,
	AM_SEEKING_ReturnTime	= 0x8,
	AM_SEEKING_Segment	= 0x10,
	AM_SEEKING_NoFlush	= 0x20
    } 	AM_SEEKING_SEEKING_FLAGS;

typedef 
enum AM_SEEKING_SeekingCapabilities
    {	AM_SEEKING_CanSeekAbsolute	= 0x1,
	AM_SEEKING_CanSeekForwards	= 0x2,
	AM_SEEKING_CanSeekBackwards	= 0x4,
	AM_SEEKING_CanGetCurrentPos	= 0x8,
	AM_SEEKING_CanGetStopPos	= 0x10,
	AM_SEEKING_CanGetDuration	= 0x20,
	AM_SEEKING_CanPlayBackwards	= 0x40,
	AM_SEEKING_CanDoSegments	= 0x80,
	AM_SEEKING_Source	= 0x100
    } 	AM_SEEKING_SEEKING_CAPABILITIES;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0016_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0016_v0_0_s_ifspec;

#ifndef __IMediaSeeking_INTERFACE_DEFINED__
#define __IMediaSeeking_INTERFACE_DEFINED__

/* interface IMediaSeeking */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMediaSeeking;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73880-c2c8-11cf-8b46-00805f6cef60")
    IMediaSeeking : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD *pCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckCapabilities( 
            /* [out][in] */ DWORD *pCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsFormatSupported( 
            /* [in] */ const GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryPreferredFormat( 
            /* [out] */ GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimeFormat( 
            /* [out] */ GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingTimeFormat( 
            /* [in] */ const GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimeFormat( 
            /* [in] */ const GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDuration( 
            /* [out] */ LONGLONG *pDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStopPosition( 
            /* [out] */ LONGLONG *pStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentPosition( 
            /* [out] */ LONGLONG *pCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertTimeFormat( 
            /* [out] */ LONGLONG *pTarget,
            /* [in] */ const GUID *pTargetFormat,
            /* [in] */ LONGLONG Source,
            /* [in] */ const GUID *pSourceFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPositions( 
            /* [out][in] */ LONGLONG *pCurrent,
            /* [in] */ DWORD dwCurrentFlags,
            /* [out][in] */ LONGLONG *pStop,
            /* [in] */ DWORD dwStopFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPositions( 
            /* [out] */ LONGLONG *pCurrent,
            /* [out] */ LONGLONG *pStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAvailable( 
            /* [out] */ LONGLONG *pEarliest,
            /* [out] */ LONGLONG *pLatest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRate( 
            /* [in] */ double dRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRate( 
            /* [out] */ double *pdRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreroll( 
            /* [out] */ LONGLONG *pllPreroll) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaSeekingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaSeeking * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaSeeking * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaSeeking * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            IMediaSeeking * This,
            /* [out] */ DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *CheckCapabilities )( 
            IMediaSeeking * This,
            /* [out][in] */ DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
            IMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *QueryPreferredFormat )( 
            IMediaSeeking * This,
            /* [out] */ GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimeFormat )( 
            IMediaSeeking * This,
            /* [out] */ GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingTimeFormat )( 
            IMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimeFormat )( 
            IMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pDuration);
        
        HRESULT ( STDMETHODCALLTYPE *GetStopPosition )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPosition )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertTimeFormat )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pTarget,
            /* [in] */ const GUID *pTargetFormat,
            /* [in] */ LONGLONG Source,
            /* [in] */ const GUID *pSourceFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetPositions )( 
            IMediaSeeking * This,
            /* [out][in] */ LONGLONG *pCurrent,
            /* [in] */ DWORD dwCurrentFlags,
            /* [out][in] */ LONGLONG *pStop,
            /* [in] */ DWORD dwStopFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPositions )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pCurrent,
            /* [out] */ LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailable )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pEarliest,
            /* [out] */ LONGLONG *pLatest);
        
        HRESULT ( STDMETHODCALLTYPE *SetRate )( 
            IMediaSeeking * This,
            /* [in] */ double dRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetRate )( 
            IMediaSeeking * This,
            /* [out] */ double *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreroll )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pllPreroll);
        
        END_INTERFACE
    } IMediaSeekingVtbl;

    interface IMediaSeeking
    {
        CONST_VTBL struct IMediaSeekingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaSeeking_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaSeeking_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaSeeking_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaSeeking_GetCapabilities(This,pCapabilities)	\
    ( (This)->lpVtbl -> GetCapabilities(This,pCapabilities) ) 

#define IMediaSeeking_CheckCapabilities(This,pCapabilities)	\
    ( (This)->lpVtbl -> CheckCapabilities(This,pCapabilities) ) 

#define IMediaSeeking_IsFormatSupported(This,pFormat)	\
    ( (This)->lpVtbl -> IsFormatSupported(This,pFormat) ) 

#define IMediaSeeking_QueryPreferredFormat(This,pFormat)	\
    ( (This)->lpVtbl -> QueryPreferredFormat(This,pFormat) ) 

#define IMediaSeeking_GetTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> GetTimeFormat(This,pFormat) ) 

#define IMediaSeeking_IsUsingTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> IsUsingTimeFormat(This,pFormat) ) 

#define IMediaSeeking_SetTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> SetTimeFormat(This,pFormat) ) 

#define IMediaSeeking_GetDuration(This,pDuration)	\
    ( (This)->lpVtbl -> GetDuration(This,pDuration) ) 

#define IMediaSeeking_GetStopPosition(This,pStop)	\
    ( (This)->lpVtbl -> GetStopPosition(This,pStop) ) 

#define IMediaSeeking_GetCurrentPosition(This,pCurrent)	\
    ( (This)->lpVtbl -> GetCurrentPosition(This,pCurrent) ) 

#define IMediaSeeking_ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat)	\
    ( (This)->lpVtbl -> ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat) ) 

#define IMediaSeeking_SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags)	\
    ( (This)->lpVtbl -> SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags) ) 

#define IMediaSeeking_GetPositions(This,pCurrent,pStop)	\
    ( (This)->lpVtbl -> GetPositions(This,pCurrent,pStop) ) 

#define IMediaSeeking_GetAvailable(This,pEarliest,pLatest)	\
    ( (This)->lpVtbl -> GetAvailable(This,pEarliest,pLatest) ) 

#define IMediaSeeking_SetRate(This,dRate)	\
    ( (This)->lpVtbl -> SetRate(This,dRate) ) 

#define IMediaSeeking_GetRate(This,pdRate)	\
    ( (This)->lpVtbl -> GetRate(This,pdRate) ) 

#define IMediaSeeking_GetPreroll(This,pllPreroll)	\
    ( (This)->lpVtbl -> GetPreroll(This,pllPreroll) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaSeeking_INTERFACE_DEFINED__ */


#ifndef __IAudioRenderer_INTERFACE_DEFINED__
#define __IAudioRenderer_INTERFACE_DEFINED__

/* interface IAudioRenderer */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAudioRenderer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86612576-6b0a-4033-8374-edbdc59ac25c")
    IAudioRenderer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDriftRate( 
            /* [in] */ DOUBLE dwRate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioRendererVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioRenderer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioRenderer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioRenderer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDriftRate )( 
            IAudioRenderer * This,
            /* [in] */ DOUBLE dwRate);
        
        END_INTERFACE
    } IAudioRendererVtbl;

    interface IAudioRenderer
    {
        CONST_VTBL struct IAudioRendererVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioRenderer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioRenderer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioRenderer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioRenderer_SetDriftRate(This,dwRate)	\
    ( (This)->lpVtbl -> SetDriftRate(This,dwRate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioRenderer_INTERFACE_DEFINED__ */


#ifndef __IAudioRendererWaveOut_INTERFACE_DEFINED__
#define __IAudioRendererWaveOut_INTERFACE_DEFINED__

/* interface IAudioRendererWaveOut */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAudioRendererWaveOut;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8244a79e-9986-4187-abcb-3a69542f7cc7")
    IAudioRendererWaveOut : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SendMessage( 
            /* [in] */ UINT uMsg,
            /* [in] */ DWORD dw1,
            /* [in] */ DWORD dw2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioRendererWaveOutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioRendererWaveOut * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioRendererWaveOut * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioRendererWaveOut * This);
        
        HRESULT ( STDMETHODCALLTYPE *SendMessage )( 
            IAudioRendererWaveOut * This,
            /* [in] */ UINT uMsg,
            /* [in] */ DWORD dw1,
            /* [in] */ DWORD dw2);
        
        END_INTERFACE
    } IAudioRendererWaveOutVtbl;

    interface IAudioRendererWaveOut
    {
        CONST_VTBL struct IAudioRendererWaveOutVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioRendererWaveOut_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioRendererWaveOut_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioRendererWaveOut_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioRendererWaveOut_SendMessage(This,uMsg,dw1,dw2)	\
    ( (This)->lpVtbl -> SendMessage(This,uMsg,dw1,dw2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioRendererWaveOut_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_axcore_0000_0019 */
/* [local] */ 

typedef IMediaSeeking *PMEDIASEEKING;

enum tagAM_MEDIAEVENT_FLAGS
{
    AM_MEDIAEVENT_NONOTIFY = 0x01
};
typedef /* [public][public] */ struct __MIDL___MIDL_itf_axcore_0000_0019_0001
    {
    CLSID clsid;
    WCHAR achName[ 128 ];
    BOOL bDMO;
    } 	FilterCreationInfo;



extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0019_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_axcore_0000_0019_v0_0_s_ifspec;

#ifndef __IFilterGraphCache_INTERFACE_DEFINED__
#define __IFilterGraphCache_INTERFACE_DEFINED__

/* interface IFilterGraphCache */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFilterGraphCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D8C7CBF-F1D4-461b-B737-7384EA690710")
    IFilterGraphCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ClearGraphCache( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFiltersToGraphCache( 
            /* [in] */ IBaseFilter *pSourceFilter,
            /* [in] */ WCHAR *pExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFiltersFromGraphCache( 
            /* [in] */ GUID *pType,
            /* [in] */ GUID *pSubtype,
            /* [in] */ WCHAR *pExtension,
            /* [out] */ FilterCreationInfo *pFilterInfo,
            /* [out][in] */ DWORD *pcFilterInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterGraphCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterGraphCache * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterGraphCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterGraphCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *ClearGraphCache )( 
            IFilterGraphCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFiltersToGraphCache )( 
            IFilterGraphCache * This,
            /* [in] */ IBaseFilter *pSourceFilter,
            /* [in] */ WCHAR *pExtension);
        
        HRESULT ( STDMETHODCALLTYPE *GetFiltersFromGraphCache )( 
            IFilterGraphCache * This,
            /* [in] */ GUID *pType,
            /* [in] */ GUID *pSubtype,
            /* [in] */ WCHAR *pExtension,
            /* [out] */ FilterCreationInfo *pFilterInfo,
            /* [out][in] */ DWORD *pcFilterInfo);
        
        END_INTERFACE
    } IFilterGraphCacheVtbl;

    interface IFilterGraphCache
    {
        CONST_VTBL struct IFilterGraphCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterGraphCache_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFilterGraphCache_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFilterGraphCache_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFilterGraphCache_ClearGraphCache(This)	\
    ( (This)->lpVtbl -> ClearGraphCache(This) ) 

#define IFilterGraphCache_AddFiltersToGraphCache(This,pSourceFilter,pExtension)	\
    ( (This)->lpVtbl -> AddFiltersToGraphCache(This,pSourceFilter,pExtension) ) 

#define IFilterGraphCache_GetFiltersFromGraphCache(This,pType,pSubtype,pExtension,pFilterInfo,pcFilterInfo)	\
    ( (This)->lpVtbl -> GetFiltersFromGraphCache(This,pType,pSubtype,pExtension,pFilterInfo,pcFilterInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFilterGraphCache_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\basetsd.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    basetsd.h

Abstract:

    Type definitions for the basic sized types.

Revision History:

--*/

#pragma once

#ifndef _BASETSD_H_
#define _BASETSD_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// The following types are guaranteed to be signed and 32 bits wide.
//

typedef int LONG32, *PLONG32;
typedef int INT32, *PINT32;

//
// The following types are guaranteed to be unsigned and 32 bits wide.
//

typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;
typedef unsigned int UINT32, *PUINT32;

//
// The INT_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. UINT_PTR is
// the unsigned variation.
//
// HALF_PTR is half the size of a pointer it intended for use with
// within strcuture which contain a pointer and two small fields.
// UHALF_PTR is the unsigned variation.
//

#ifdef _WIN64

typedef __int64 SHANDLE_PTR;
typedef unsigned __int64 HANDLE_PTR;

typedef __int64 INT_PTR, *PINT_PTR;
typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

typedef __int64 LONG_PTR, *PLONG_PTR;
typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

typedef unsigned int UHALF_PTR, *PUHALF_PTR;
typedef int HALF_PTR, *PHALF_PTR;

#pragma warning(disable:4311)   // type cast truncation

#if !defined(__midl)
__inline
unsigned long
HandleToUlong(
    void *h
    )
{
    return((unsigned long) h );
}

__inline
long
HandleToLong(
    void *h
    )
{
    return((long) h );
}

__inline
void *
UlongToHandle(
    const unsigned long h
    )
{
    return((void *) (UINT_PTR) h );
}


__inline
void *
LongToHandle(
    const long h
    )
{
    return((void *) (INT_PTR) h );
}

__inline
unsigned long
PtrToUlong(
    void  *p
    )
{
    return((unsigned long) p );
}

__inline
unsigned int
PtrToUint(
    const void  *p
    )
{
    return((unsigned int) (UINT_PTR) p );
}

__inline
unsigned short
PtrToUshort(
    void  *p
    )
{
    return((unsigned short) p );
}

__inline
long
PtrToLong(
    void  *p
    )
{
    return((long) p );
}


__inline
int
PtrToInt(
    const void  *p
    )
{
    return((int) (INT_PTR) p );
}


__inline
short
PtrToShort(
    void  *p
    )
{
    return((short) p );
}

__inline
void *
IntToPtr(
    const int i
    )
// Caution: IntToPtr() sign-extends the int value.
{
    return( (void *)(INT_PTR)i );
}

__inline
void *
UintToPtr(
    const unsigned int ui
    )
// Caution: UIntToPtr() zero-extends the unsigned int value.
{
    return( (void *)(UINT_PTR)ui );
}


__inline
void *
LongToPtr(
    const long l
    )
// Caution: LongToPtr() sign-extends the long value.
{
    return( (void *)(LONG_PTR)l );
}

__inline
void *
UlongToPtr(
    const unsigned long ul
    )
// Caution: ULongToPtr() zero-extends the unsigned long value.
{
    return( (void *)(ULONG_PTR)ul );
}


#endif
#pragma warning(3:4311)   // type cast truncation

#else  // !_WIN64 

typedef int INT_PTR, *PINT_PTR;
typedef unsigned int UINT_PTR, *PUINT_PTR;

typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;

typedef unsigned short UHALF_PTR, *PUHALF_PTR;
typedef short HALF_PTR, *PHALF_PTR;

typedef long SHANDLE_PTR;
typedef unsigned long HANDLE_PTR;

#define HandleToUlong( h ) ((ULONG)(ULONG_PTR)(h) )
#define HandleToLong( h )  ((LONG)(LONG_PTR) (h) )
#define UlongToHandle( ul ) ((HANDLE)(ULONG_PTR) (ul) )
#define LongToHandle( h )   ((HANDLE)(LONG_PTR) (h) )
#define PtrToUlong( p ) ((ULONG)(ULONG_PTR) (p) )
#define PtrToLong( p )  ((LONG)(LONG_PTR) (p) )
#define PtrToUint( p ) ((UINT)(UINT_PTR) (p) )
#define PtrToInt( p )  ((INT)(INT_PTR) (p) )
#define PtrToUshort( p ) ((unsigned short)(ULONG_PTR)(p) )
#define PtrToShort( p )  ((short)(LONG_PTR)(p) )
#define IntToPtr( i )    ((VOID *)(INT_PTR)((int)i))
#define UintToPtr( ui )  ((VOID *)(UINT_PTR)((unsigned int)ui))
#define LongToPtr( l )   ((VOID *)(LONG_PTR)((long)l))
#define UlongToPtr( ul ) ((VOID *)(ULONG_PTR)((unsigned long)ul))

#endif // !_WIN64

#if defined(UNDER_CE)
// Some capitalization inconsistencies between older 
// and newer versions of the conversions. 
#define HandleToULong HandleToUlong
#define ULongToHandle UlongToHandle
#define PtrToULong PtrToUlong
#define PtrToUInt PtrToUint
#define PtrToUShort PtrToUshort
#define UIntToPtr UintToPtr
#define ULongToPtr UlongToPtr
#endif

#define MAXUINT_PTR  ((UINT_PTR)~0)
#define MAXINT_PTR   ((INT_PTR)(MAXUINT_PTR >> 1))
#define MININT_PTR   (~MAXINT_PTR)

#define MAXULONG_PTR ((ULONG_PTR)~0)
#define MAXLONG_PTR  ((LONG_PTR)(MAXULONG_PTR >> 1))
#define MINLONG_PTR  (~MAXLONG_PTR)

#define MAXUHALF_PTR ((UHALF_PTR)~0)
#define MAXHALF_PTR  ((HALF_PTR)(UHALF_PTR >> 1))
#define MINHALF_PTR  (~MAXHALF_PTR)

//
// SIZE_T used for counts or ranges which need to span the range of
// of a pointer.  SSIZE_T is the signed variation.
//

typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;

//
// DWORD_PTR types
//

typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

//
// The following types are guaranteed to be signed and 64 bits wide.
//

typedef __int64 LONG64, *PLONG64;
typedef __int64 INT64,  *PINT64;


//
// The following types are guaranteed to be unsigned and 64 bits wide.
//

typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;
typedef unsigned __int64 UINT64,  *PUINT64;

#ifdef __cplusplus
}
#endif

#endif // _BASETSD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\aygshell.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    aygshell.h
 
Abstract:

    Shell defines.

--*/


#ifndef __AYGSHELL_H__
#define __AYGSHELL_H__


#include <windows.h>
#include <sipapi.h>
#include <shlobj.h>
#include <prsht.h>
#include <winuserm.h>
#include <commctrl.h>
#include <commdlg.h>
#include <changeinfo.h>
#include <storagecard.h>

#ifdef TPC
#include "vibrate.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

// To enable autodoc tags
//@doc

// This event is set when the shell APIs are ready to be called.
#define SHELL_API_READY_EVENT  TEXT("SYSTEM/ShellAPIReady")

// This event is set when the shell window is ready to process messages.
#define SHELL_INIT_EVENT TEXT("SYSTEM/ShellInit")


//#define SHN_FIRST               (0U-1000U)       // Shell reserved
    
#define SHNN_FIRST              (0U-1000U)        // Shell Notifications
#define SHNN_LAST               (0U-1020U)        // Shell Notifications

//#define SHN_LAST                (0U-11000U)

//
// flags in the fdwFlags field of SIPINFO.
// some of these are defined in sipapi.h in the OS.
//
#define SIPF_DISABLECOMPLETION      0x08


//
// Supported system parameters.
//
#ifndef SPI_SETSIPINFO
#define SPI_SETSIPINFO          224
#endif
#define SPI_GETSIPINFO          225
#define SPI_SETCURRENTIM        226
#define SPI_GETCURRENTIM        227
#define SPI_SETCOMPLETIONINFO   223
#define SPI_APPBUTTONCHANGE     228
#define SPI_RESERVED            229
#define SPI_SYNCSETTINGSCHANGE  230


//Pocket PC  special controls
#define WC_SIPPREF    L"SIPPREF"

// BOOL SHGetDocumentsFolder(LPCTSTR pszPath, LPTSTR pszDocs)
// this retrieves the path to the documents directory for
// the volume specified in pszPath.
// return FALSE if there is no such directory (e.g. storage card
// path but no storage card exists
//
// pszDocs is the out parameter and must be at least MAX_PATH long
BOOL SHGetDocumentsFolder(LPCTSTR pszVolume, LPTSTR pszDocs);

//
// SHSipInfo function.
//
WINSHELLAPI
BOOL
SHSipInfo(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni );

BYTE SHGetAppKeyAssoc( LPCTSTR ptszApp );
BOOL SHSetAppKeyWndAssoc( BYTE bVk, HWND hwnd );

BOOL SHInitExtraControls(void);
BOOL SHCloseApps( DWORD dwMemSought );


//++++++
//
// SHInitDialog 
//

typedef struct tagSHINITDLGINFO
{
    DWORD dwMask;
    HWND  hDlg;
    DWORD dwFlags;
} SHINITDLGINFO, *PSHINITDLGINFO;


//
// The functions
//

BOOL SHInitDialog(PSHINITDLGINFO pshidi);

//
// Valid mask values
//

#define SHIDIM_FLAGS                0x0001

//
// Valid flags
//

#define SHIDIF_DONEBUTTON           0x0001
#define SHIDIF_SIZEDLG              0x0002
#define SHIDIF_SIZEDLGFULLSCREEN    0x0004
#define SHIDIF_SIPDOWN              0x0008
#define SHIDIF_FULLSCREENNOMENUBAR  0x0010
#define SHIDIF_EMPTYMENU            0x0020
#define SHIDIF_WANTSCROLLBAR        0x0040
#define SHIDIF_CANCELBUTTON         0x0080

//
// End SHInitDialog
//
//------

HBITMAP SHLoadImageResource(HINSTANCE hinst, UINT uIdGif);
HBITMAP SHLoadImageFile(LPCTSTR pszFileName);

//++++++
//
// Shell Menubar support
//

// Allows menus on softkeys (which have no ID) to be accessed through TB_GETBUTTONINFO/TB_SETBUTTONINFO
// by using an index (0 or 1) and setting TBIF_BYINDEX. 
#ifndef TBIF_BYINDEX
#define TBIF_BYINDEX 0x80000000
#endif

#define NOMENU 0xFFFF
#define IDC_COMMANDBANDS    100

// These defines MUST be < 100.  This is so apps can use these defines
// to get strings from the shell.
#define IDS_SHNEW           1
#define IDS_SHEDIT          2
#define IDS_SHTOOLS         3
#define IDS_SHVIEW          4
#define IDS_SHFILE          5
#define IDS_SHGO            6
#define IDS_SHFAVORITES     7
#define IDS_SHOPEN          8
#define IDS_SHMENU          9

//
// Shared New menu support
//
#define  IDM_SHAREDNEW        10
#define  IDM_SHAREDNEWDEFAULT 11
#define  IDM_SHAREDMENU       12

//
// Valid dwFlags
//
#define SHCMBF_EMPTYBAR      0x0001
#define SHCMBF_HIDDEN        0x0002 // create it hidden
#define SHCMBF_HIDESIPBUTTON 0x0004
#define SHCMBF_COLORBK       0x0008
#define SHCMBF_HMENU         0x0010 // specify an hmenu for resource rather than toolbar info
#define SHCMBF_NOACTION      0x0020 // Do not include the shell "Action" menu item in the menu


typedef struct tagSHMENUBARINFO
{
    DWORD     cbSize;               // IN  - Indicates which members of struct are valid
    HWND      hwndParent;           // IN
    DWORD     dwFlags;              // IN  - Some features we want
    UINT      nToolBarId;           // IN  - Which toolbar are we using
    HINSTANCE hInstRes;             // IN  - Instance that owns the resources
    int       nBmpId;
    int       cBmpImages;           // IN  - Count of bitmap images
    HWND      hwndMB;               // OUT
    COLORREF  clrBk;                // IN  - background color of the menu bar (excluding sip)
} SHMENUBARINFO, *PSHMENUBARINFO;

BOOL  SHCreateMenuBar(SHMENUBARINFO *pmbi);

/****************************************************************************

        SHCMBM_OVERRIDEKEY
            Both Pocket PCs and Smart Phones support this message.
            This is used to modify the default handling of key messages sent
            to the soft key control of the foreground app.  
            
            wParam = nVirtkey,
            dwMask = (DWORD)LOWORD(lParam),
            dwBits = (DWORD)HIWORD(lParam)
                SHMBOF_NODEFAULT    0x00000001 // do not do default handling of this key
                SHMBOF_NOTIFY       0x00000002 // send the owner the WM_* messages for this key
                
 ****************************************************************************/

#define SHCMBM_SETSUBMENU   (WM_USER + 400) // wparam == id of button, lParam == hmenu, return is old hmenu
#define SHCMBM_GETSUBMENU   (WM_USER + 401) // lParam == ID
#define SHCMBM_GETMENU      (WM_USER + 402) // get the owning hmenu (as specified in the load resource)
#define SHCMBM_OVERRIDEKEY  (WM_USER + 403)
#define SHCMBM_SETBKCOLOR   (WM_USER + 406) // lParam == COLORREF
#define SHCMBM_UPDATEACTIONTEXT (WM_USER + 408) // Update the label for the action softkey

// Returns menubar owned by a window
HWND WINAPI SHFindMenuBar(HWND hwnd);


#define SHMBOF_NODEFAULT    0x00000001 // do not do default handling of this key
#define SHMBOF_NOTIFY       0x00000002 // send us the WM_* messages for this key



// Does the default handling of pressing the back button.
void WINAPI SHNavigateBack();


// Enable/disable softkeys by command or index.
// Parameters:
//        hwndMenuBar Handle to the softkey bar as returned from SHCreateMenuBar or SHFindMenuBar
//        uid         The Command ID or index (if bByIndex is set) of the softkey to enable/disable
//        bByIndex    If TRUE, uid is interpreted as an index (0 or 1), otherwise uid is a command ID.
//        bEnable     Set TRUE to enable, FALSE to disable the softkey.
WINSHELLAPI HRESULT  SHEnableSoftkey(HWND hwndMenuBar, UINT uid,  BOOL bByIndex, BOOL bEnable);


//
// End Shell Menubar support
//
//------

//++++++
//
// Shell home screen support
//
HRESULT SHOnPluginDataChange(const CLSID* pclsidPlugin);
//
// End Shell Home screen support
//
//------

//++++++
//
// SHHandleWMActivate and SHHandleWMSettingChange fun
//

typedef struct
{
    DWORD cbSize;
    HWND hwndLastFocus;
    UINT fSipUp :1;
    UINT fSipOnDeactivation :1;
    UINT fActive :1;
    UINT fReserved :29;
} SHACTIVATEINFO, *PSHACTIVATEINFO;

#define SHA_INPUTDIALOG 0x00000001

WINSHELLAPI BOOL SHHandleWMActivate(HWND hwnd, WPARAM wParam, LPARAM lParam, SHACTIVATEINFO* psai, DWORD dwFlags);
WINSHELLAPI BOOL SHHandleWMSettingChange(HWND hwnd, WPARAM wParam, LPARAM lParam, SHACTIVATEINFO* psai);

//
// End SHHandleWMActivate and SHHandleWMSettingChange fun
//
//------


//++++++
//
// SHSipPreference
//

BOOL SHSipPreference(HWND hwnd, SIPSTATE st);

//
// End SHSipPreference
//
//------

//+++++++
//
// SIP_AUTODEPLOY_STATE
//

typedef enum tagSIP_AUTODEPLOY_STATE
{
    SIP_AUTODEPLOY_INHERIT = 0, //inherit the behavior of parent window
    SIP_AUTODEPLOY_DISABLE,     //disable auto-deploy
    SIP_AUTODEPLOY_ENABLE,      //enable auto-deploy
}SIP_AUTODEPLOY_STATE;


//////////////////////////////////////////////////////////////////////////////
//
// SHSipSetAutoDeploy
//
//   Set the status of sip auto-deploy for a certain window.
//
// Parameters:
//    hWnd
//        [in] Handle to the window whose SIP auto-deploy enalbe/disable status 
//        is to be changed.
//    st
//        [in] Specifies window SIP_AUTODEPLOY_STATE value. This parameter must 
//        be one of the following values:
//
//        SIP_AUTODEPLOY_ENABLE 
//            Indicates that SIP auto-deploy is enabled for the window.
//        SIP_AUTODEPLOY_DISABLE 
//            Indicates that SIP auto-deploy is disabled for the window. 
//        SIP_AUTODEPLOY_INHERIT
//            Indicates that SIP auto-deploy status is determined by the parent's
//            or ancestor's SIP auto-deploy status.
//
// Return value:
//    If the function succeeds, the return value is S_OK.
//    If the function fails, the return value is one of the following values:
// 
//    Value                       Description
//    ------------------------------------------------------------------------
//    E_INVALIDARG                The input parameter is incorrect. hWnd is 
//                                invalid or state is beyond the 3 values defined.
//    E_FAIL                      Error occurs when setting window property.
//    E_OUTOFMEMORY               Fail to allocate memory for window property.
// 
// Remarks
//    The SIP status will not be changed when user call this API. 
//    To change current SIP status, please call SipSetInfo() or SipShowIM().
// 
//
HRESULT SHSipSetAutoDeploy(HWND hWnd, SIP_AUTODEPLOY_STATE st);


//++++++
//
// SHRecognizeGesture structs
//

typedef struct tagSHRGI {
    DWORD cbSize;
    HWND hwndClient;
    POINT ptDown;
    DWORD dwFlags;
} SHRGINFO, *PSHRGINFO;


//
// Gesture notifications
//
#define  GN_CONTEXTMENU       1000


//
// Gesture flags
//
#define  SHRG_RETURNCMD       0x00000001
#define  SHRG_NOTIFYPARENT    0x00000002
// use the longer (mixed ink) delay timer
// useful for cases where you might click down first, verify you're
// got the right spot, then start dragging... and it's not clear
// you wanted a context menu
#define  SHRG_LONGDELAY       0x00000008 
#define  SHRG_NOANIMATION     0x00000010

//
// Struct sent through WM_NOTIFY when SHRG_NOTIFYPARENT is used
//
typedef struct tagNMRGINFO 
{
    NMHDR hdr;
    POINT ptAction;
    DWORD dwItemSpec;
} NMRGINFO, *PNMRGINFO;

WINSHELLAPI DWORD SHRecognizeGesture(SHRGINFO *shrg);

//
// End SHRecognizeGesture
//
//------


//++++++
//
// SHFullScreen
//

BOOL SHFullScreen(HWND hwndRequester, DWORD dwState);


//
// Valid states
//

#define SHFS_DEFAULT                0x0000
#define SHFS_SHOWTASKBAR            0x0001
#define SHFS_HIDETASKBAR            0x0002
#define SHFS_SHOWSIPBUTTON          0x0004
#define SHFS_HIDESIPBUTTON          0x0008
#define SHFS_SHOWSTARTICON          0x0010
#define SHFS_HIDESTARTICON          0x0020
#define SHFS_SHOWMENUBAR            0x0040
#define SHFS_HIDEMENUBAR            0x0080
#define SHFS_AUTOMENUBAR            0x0100


//++++++
//
// SHSetWindowTitleDisplayOptions
//

#define SHSWTDO_DEFAULT             0
#define SHSWTDO_IGNOREWINDOWTITLE   1

/// <summary>
/// Sets the window title display options for a particular window
/// </summary>
/// <param name="hwnd">
///     Handle to the window setting the new display options
/// </param>
/// <param name="dwFlags">
///     The window title display options to use 
/// </param>
/// <returns>
///     E_INVALIDARG if dwFlags or hwnd is an invalid value.
/// </returns>
/// <remarks>
///
///     SHSWTDO_DEFAULT will cause the window title to be displayed normally
///
///     SHSWTDO_IGNOREWINDOWTITLE will cause the window's title to be ignored.
///     If appropriate, the system will display the window title of the next
///     window in the Z-order.
/// </remarks>
HRESULT SHSetWindowTitleDisplayOptions(HWND hwnd, DWORD dwFlags);


//
// Menu bar notifications
//
#define MBN_SHOWMENUBAR 1106
#define MBN_HIDEMENUBAR 1107

//
// End SHFullScreen
//
//------


//++++++
//
// SHDoneButton
//

BOOL SHDoneButton(HWND hwndRequester, DWORD dwState);


//
// Valid states
//

#define SHDB_SHOW                   0x0001
#define SHDB_HIDE                   0x0002
#define SHDB_SHOWCANCEL             0x0004


//
// Disable the navigation button bestowed by the Shell
// (NOTE: this only works if WS_CAPTION is not set)

#define WS_NONAVDONEBUTTON WS_MINIMIZEBOX

//
// End SHDoneButton
//
//------


//++++++
//
// SHGetAutoRunPath
//  pAutoRunPath must be at least MAX_PATH long

BOOL SHGetAutoRunPath( LPTSTR pAutoRunPath );

//
// End SHGetAutoRunPath
//
//------

//++++++
//
// SHSetNavBarText
//

BOOL SHSetNavBarText(HWND hwndRequester, LPCTSTR pszText);

//
// End SHSetNavBarText
//
//------

//++++++
//
// SHInputDialog
//

void SHInputDialog(HWND hwnd, UINT uMsg, WPARAM wParam);

//
// End SHInputDialog
//
//------

//++++++
//
// SHEnumPropSheetHandlers
//

// this is the maximum number of extension pages that can be added
// to a property sheet

#define MAX_EXTENSION_PAGES 6

// For property sheet extension - enumerates the subkeys under the
// class key hkey.  For each handler, the class is instantiated,
// queried for IShellPropSheetExt and AddPages is called.  The
// handle to the page is inserted in the array prghPropPages, and
// the pointer to the IShellPropSheetExt is added to prgpispse
// with one reference from the caller (these should be released
// by the caller after PropertySheet() is called).  These two arrays
// should be allocated before calling SHEnumPropSheetHandlers.
//
// Typical usage of this function would be:
//
//  - allocate an array of HPROPSHEETPAGEs for the standard pages plus
//    MAX_EXTENSION_PAGES extension pages
//  - fill a PROPSHEETPAGE struct and call CreatePropertySheetPage() on each
//    standard page
//  - store the HPROPSHEETPAGE for the standard pages at the beginning of
//    the array
//  - open a registry key where the app has defined ISV extension
//  - allocate an array of MAX_EXTENSION_PAGES IShellPropSheetExt interface
//    pointers
//  - call SHEnumPropSheetHandlers(), passing in the hkey, a pointer to the
//    first free HPROPSHEETPAGE array element, and a pointer to the array of
//    IShellPropSheetExt interface pointers
//  - call PropertySheet() to display the property sheet
//  - Release each interface pointer in the array of interface pointers
//  - free both arrays

// SHEnumPropSheetHandlers assumes that prghPropPages and prgpispse have been
// allocated with enough space for up to MAX_EXTENSION_PAGES elements.  The
// number of pages added is returned in *pcPages.

BOOL SHEnumPropSheetHandlers(HKEY hkey, int *pcPages, HPROPSHEETPAGE
        *prghPropPages, IShellPropSheetExt **prgpispse);

//
// End SHEnumPropSheetHandlers
//
//------


//++++++
//
// SHLoadContextMenuExtensions
//
//    Loads context menu extensions from handlers listed in the registry for
//    the context/class pair specified.  Menu items are added to hmenu in the
//    range [idCmdFirst, idCmdLast].  A handle to the context menu extensions
//    abstraction object is returned in *phCMExtensions.  It must be freed by
//    a call to SHFreeContextMenuExtensions.

BOOL SHLoadContextMenuExtensions(IUnknown *punkOwner, LPCTSTR pszContext,
    LPCTSTR pszClass, HMENU hmenu, UINT idCmdFirst, UINT idCmdLast,
    HANDLE *phCMExtensions);

//
// End SHLoadContextMenuExtensions
//
//------


//++++++
//
// SHInvokeContextMenuCommand
//
//    Invokes a command from a context menu.  Issues the command in the
//    extension that added it to the menu.

BOOL SHInvokeContextMenuCommand(HWND hwndOwner, UINT idCmd,
        HANDLE hCMExtensions);

//
// End SHInvokeContextMenuCommand
//
//------


//++++++
//
// SHFreeContextMenuExtensions
//

//    Releases memory allocated for context menu processing.

BOOL SHFreeContextMenuExtensions(HANDLE hCMExtensions);

//
// End SHFreeContextMenuExtensions
//
//------


//++++++
//
//  SHGetEmergencyCallList
//
//       Gets a list of emergency calls

HRESULT SHGetEmergencyCallList(TCHAR *pwszBuffer, UINT uLenBuf);

//
// End SHGetEmergencyCallList
//
//------


//////////////////////////////////////////////////////////////////////////////
//
// Input Context API
//
// These are definitions and APIs for the interacting with the input context
// properties of individual windows
//
// {

// Word correct Options
enum SHIC_FEATURE
{
    SHIC_FEATURE_RESTOREDEFAULT = 0,
    SHIC_FEATURE_AUTOCORRECT    = 0x00000001L,
    SHIC_FEATURE_AUTOSUGGEST    = 0x00000002L,
    SHIC_FEATURE_HAVETRAILER    = 0x00000003L,
    SHIC_FEATURE_CLASS          = 0x00000004L
};

typedef enum SHIC_FEATURE SHIC_FEATURE;

// Predefined input context classes
#define SHIC_CLASS_DEFAULT              TEXT("")
#define SHIC_CLASS_EMAIL                TEXT("email")
#define SHIC_CLASS_URL                  TEXT("url")
#define SHIC_CLASS_PHONE                TEXT("phone")
#define SHIC_CLASS_NAME                 TEXT("name")
#define SHIC_CLASS_PHONE_AND_EMAIL      TEXT("phoneAndEmail")
#define SHIC_CLASS_MAXLEN               (MAX_PATH - 11)

//@topic Input Context Features |
// The input context API supports the following features and their corresponding values:
//
//@flag   SHIC_FEATURE_RESTOREDEFAULT   | Restore original input context state. (no corresponding value)
//@flag   SHIC_FEATURE_AUTOCORRECT      | Turn auto-corrections on and off. (TRUE, FALSE)
//@flag   SHIC_FEATURE_AUTOCOMPLETE     | Turn dictionary suggestions on and off. (TRUE, FALSE)
//@flag   SHIC_FEATURE_HAVETRAILER      | Specify whether to append trailer characters after replacing words.
//                                      (TRUE, FALSE)
//@flag   SHIC_FEATURE_CLASS            | Make this control behave like a specific semantic type.
//                                      (SHIC_CLASS_DEFAULT, SHIC_CLASS_EMAIL, SHIC_CLASS_URL,
//                                      SHIC_CLASS_PHONE, SHIC_CLASS_NAME, SHIC_CLASS_PHONE_AND_EMAIL)
//
//@comm All SHIC_FEATUREs are inherited from parent if undefined. That is, if they are not defined in
//      a window or the window's SHIC class, the API looks at the parent chain to find the setting
//      that applies to the window.
//
//@xref <f SHSetInputContext> <f SHGetInputContext>
//


//++++++
//
//@func HRESULT | SHSetInputContext | Changes the state of an input context feature
//
//@parm HWND            | hwnd      | IN - Window whose context will be set
//@parm DWORD           | dwFeature | IN - Input context feature to change
//@parm const LPVOID    | lpValue   | IN - New value assigned to feature
//
//@rdesc Returns one of the following values:
//@flag S_OK                    | If everything went well
//@flag ERROR_INVALID_PARAMETER | if hwnd was NULL or lpValue was NULL for a feature
//                                that does not support it, such as SHIC_FEATURE_AUTOCORRECT,
//                                SHIC_FEATURE_AUTOCOMPLETE and SHIC_FEATURE_HAVETRAILER.
//@flag ERROR_NOT_SUPPORTED     | If the feature specified was invalid
//@flag ERROR_INVALID_DATA      | If the specified value is not a legal option
//
//@xref <l Input_Context_Features> <f SHGetInputContext>
//

HRESULT SHSetInputContext( HWND hwnd, DWORD dwFeature, const LPVOID lpValue );

//
// End SHSetInputContext
//
//------


//++++++
//
//@func HRESULT | SHGetInputContext | Retrieves current state of an input context feature
//
//@parm HWND    | hwnd      | IN - Window whose context will be retrieved
//@parm DWORD   | dwFeature | IN - Input context feature to retrieve
//@parm LPVOID  | lpValue   | OUT - Buffer to hold current value of feature
//@parm LPDWORD | pdwSize   | IN/OUT - size of the buffer passed in to retrieve the value
//
//@rdesc Returns one of the following values:
//@flag S_OK                        | If everything went well
//@flag ERROR_INVALID_PARAMETER     | If hwnd or lpdwSize passed were NULL
//@flag ERROR_NOT_SUPPORTED         | If the feature specified was invalid
//@flag ERROR_INSUFFICIENT_BUFFER   | If buffer passed is too small
//
//@comm Retrieves the current state/value of the specified
//      input context feature. If the value is not explicitly set, it
//      looks at the features set by the context class. If no class was
//      set explicitly, or the class didn't set that value, it returns
//      the default value for that feature, which would be the
//      currently active one.
//      If lpValue is NULL and lpdwSize is not NULL, it returns the
//      size of the buffer needed in lpdwSize.
//
//@xref <l Input_Context_Features> <f SHSetInputContext>
//

HRESULT SHGetInputContext( HWND hwnd, DWORD dwFeature, LPVOID lpValue, LPDWORD lpdwSize );


//
// End SHGetInputContext
//
//------


// }
//
// end Input Context API
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//
// SHUIMETRICS - UI Metrics that applications might be interested in
//
// These are definitions and APIs for Shell UI Metrics
//
// {

// Call RegisterWindowMessage on this string if you are interested in knowing when UI Metrics have changed
// wParam will be 0, lParam will be one of the SHUIMETRICTYPE values to indicate what value has changed.  
// Call SHGetUIMetrics to find out the new value if interested
#define SH_UIMETRIC_CHANGE    TEXT("SH_UIMETRIC_CHANGE")

// Enumeration of metrics you can ask for
typedef enum tagSHUIMETRIC
{
    SHUIM_INVALID = 0,    // Illegal

    // Note that you will receive a notification for SHUIM_FONTSIZE_POINT when one of these three values changes
    SHUIM_FONTSIZE_POINT,       // Application font size (hundredhts of a point) -- buffer is pointer to DWORD
    SHUIM_FONTSIZE_PIXEL,       // Application font size (in pixels) -- buffer is pointer to DWORD
    SHUIM_FONTSIZE_PERCENTAGE,  // Application font size as percentage of normal -- buffer is pointer to DWORD
} SHUIMETRIC;
 
HRESULT SHGetUIMetrics(SHUIMETRIC shuim, PVOID pvBuffer, DWORD cbBufferSize, DWORD *pcbRequired);

// }
//
// end Shell UI Metrics
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// SHNAPI - Shell Notification API
//
// These are definitions and APIs for the Shell Notifications system
//
// {

// formerly in the Windows Mobile shlobj.h
// FILECHANGEINFO defined in changeinfo.h

#define WM_FILECHANGEINFO   (WM_APP + 0x101)

typedef struct tagFILECHANGENOTIFY {
    DWORD dwRefCount;
    FILECHANGEINFO fci;
} FILECHANGENOTIFY;

typedef struct tagSHCHANGENOTIFYENTRY {
    DWORD   dwEventMask;    // Events to watch
    LPTSTR  pszWatchDir;    // Directory or root for the events we want. NULL means all.
    BOOL    fRecursive;     // Indicates whether look just for pszWatchDir or recursively.
} SHCHANGENOTIFYENTRY;


// These were explicitly removed from shlobj.h
BOOL WINAPI SHChangeNotifyRegister( HWND hwnd, SHCHANGENOTIFYENTRY *pshcne);
BOOL WINAPI SHChangeNotifyDeregister( HWND hwnd );
void WINAPI SHChangeNotifyFree( FILECHANGENOTIFY *pfcn );


// notification priority

typedef enum _SHNP
{
    SHNP_INFORM = 0x1B1,    // deprecated
    SHNP_ICONIC,
} SHNP;


// notification update mask
#define SHNUM_PRIORITY      0x0001
#define SHNUM_DURATION      0x0002
#define SHNUM_ICON          0x0004
#define SHNUM_HTML          0x0008
#define SHNUM_TITLE         0x0010
#define SHNUM_SOFTKEYS      0x0020
#define SHNUM_TODAYKEY      0x0040
#define SHNUM_TODAYEXEC     0x0080
#define SHNUM_SOFTKEYCMDS   0x0100
#define SHNUM_FLAGS         0x0200
#define SHNUM_NOTIFTEXT     0x0400
#define SHNUM_NOTIFICON     0x0800
#define SHNUM_SKTITLE       0x1000
#define SHNUM_OCCUR         0x2000
#define SHNUM_LAST_VALUE__  SHNUM_OCCUR  // mask guard, internal

// notification data

// TODO: remove ///////////////
    #define NOTIF_NUM_SOFTKEYS 2
    typedef struct _SOFTKEYCMD
    {
        WPARAM wpCmd;
        DWORD grfFlags;
    } SOFTKEYCMD;
    typedef struct _SOFTKEYNOTIFY
    {
        LPCTSTR pszTitle;
        SOFTKEYCMD skc;
    } SOFTKEYNOTIFY;

    typedef struct _SOFTKEYMENU
    {
        HMENU   hMenu;
        SOFTKEYCMD *prgskc;
        UINT    cskc;
    } SOFTKEYMENU;
///////////////////////////////

typedef struct _SHNOTIFICATIONDATA
{
    DWORD        cbStruct;      // for verification and versioning
    DWORD        dwID;          // identifier for this particular notification
    SHNP         npPriority;    // priority
    DWORD        csDuration;    // duration of the notification (usage depends on prio)
    HICON        hicon;         // the icon for the notification
    DWORD        grfFlags;      // flags - see SHNF_ flags below
    CLSID        clsid;         // unique identifier for the notification class
    HWND         hwndSink;      // window to receive command choices, dismiss, etc.
    LPCWSTR      pszHTML;       // HTML content for the bubble
    LPCWSTR      pszTitle;      // Optional title for bubble
    LPARAM       lParam;        // User-defined parameter
    LPCWSTR *    rgszText;      // Multi-line notification text (array of LPCWSTR strings).
    DWORD        cTextSize;     // Number of lines in the multi-line notification text (size of rgszText array)
    HICON        hNotifIcon;    // Icon that gives a visual context to the notification.
                                // This icon is displayed in the notification UI.
    LPCWSTR      pszSkTitle;    // SK1 title.  Represents an action that can be performed with the notification.
    DWORD        cOccurrences;  // Number of times the event that this notification represents has occurred.
} SHNOTIFICATIONDATA;

typedef struct _SHNOTIFICATIONID
{
    CLSID   clsid;
    DWORD   dwID;
} SHNOTIFICATIONID;

// Flags

// For SHNP_INFORM priority and above, don't display the notification bubble
// when it's initially added; the icon will display for the duration then it
// will go straight into the tray.  The user can view the icon / see the
// bubble by opening the tray.
#define SHNF_STRAIGHTTOTRAY  0x00000001

// Critical information - highlights the border and title of the bubble.
#define SHNF_CRITICAL        0x00000002

// Force the message (bubble) to display even if settings says not to.
#define SHNF_FORCEMESSAGE    0x00000008

// Force the display to turn on for notification.
#define SHNF_DISPLAYON       0x00000010

// Force the notification to be silent and not vibrate, regardless of Settings
#define SHNF_SILENT          0x00000020

// Softkey bar is created from an HMENU passed in skm structure 
#define SHNF_HASMENU         0x00000040

// Draw the current time with the title
#define SHNF_TITLETIME       0x00000080

// A notification with "stack" support
#define SHNF_SPINNERS        0x00000100

// RE-play physical alerts on an update
#define SHNF_ALERTONUPDATE   0x00000200

// Capture the VK_TTALK button and forward it to the notification's sink window
#define SHNF_WANTVKTTALK     0x00000400

// Last value for the SHNF.  Internal.  Used for validation.
#define SHNF_LASTVALUE__    SHNF_WANTVKTTALK

// notification message and codes for window-based notification
// the notification's dwID is in hdr.idFrom

typedef struct _NMSHN
{
    NMHDR   hdr;
    LPARAM lParam;
    DWORD dwReturn;
    union
    {
        LPCTSTR pszLink;
        BOOL    fTimeout;
        POINT   pt;
    };
} NMSHN;

#define SHNN_LINKSEL            (SHNN_FIRST-0)
// nmshn.pszLink contains the link text of the choice that was selected

#define SHNN_DISMISS            (SHNN_FIRST-1)
// nmshn.fTimeout is TRUE if duration expired, FALSE if user tapped away

#define SHNN_SHOW               (SHNN_FIRST-2)
// nmshn.pt contains the point to which the bubble points

#define SHNN_NAVPREV            (SHNN_FIRST-3)
// Toast stack left spinner clicked / DPAD LEFT

#define SHNN_NAVNEXT           (SHNN_FIRST-4)
// Toast stack right spinner clicked / DPAD RIGHT

#define SHNN_ACTIVATE           (SHNN_FIRST-5)
// Toast DPAD Action

#define SHNN_ICONCLICKED        (SHNN_FIRST-6)
// nmshn.pt contains the point where the user clicked

#define SHNN_HOTKEY             (SHNN_FIRST-7)
// A hotkey has been pressed - modifiers are in the loword of the nmshn.lParam, 
// the virtual key code is in the hiword.
// If the sink window returns 0 in response to this notification, then
// the notification toast will be hidden and VK_TTALK key default behavior
// will be performed.

//===========================================================================
//
// Interface: IShellNotificationCallback
//
//  The IShellNotificationCallback interface is used by the Shell to advise
// the notification owner of actions taken on the notification.
//
// [Member functions]
//
// IShellNotificationCallback::OnShow
//
//  Reserved.  Return E_NOTIMPL.
//
// IShellNotificationCallback::OnCommandSelected
//
//  This member function is called when the user selects a link of the form
// <A HREF="cmd:#">link</A>.
//
//  Parameters:
//   dwID       -- the identifier of the notification
//   wCmdID     -- this is the # in the link
//
// IShellNotificationCallback::OnLinkSelected
//
//  This member function is called when the user selects one of the action
// choice links in the notification bubble window.
//
//  Parameters:
//   dwID       -- the identifier of the notification
//   pszLink    -- the link content that was selected
//   lParam     -- the lParam of the notification
//
// IShellNotificationCallback::OnDismiss
//
//  This member function is called when the user taps away from the bubble
// window or if a SHNP_INFORM priority notification's duration expires.
//
//  Parameters:
//   dwID       -- the identifier of the notification
//   fTimeout   -- the notification timed out (SHNP_INFORM only)
//   lParam     -- the lParam of the notification
//   
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellNotificationCallback

DECLARE_INTERFACE_(IShellNotificationCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellNotificationCallback methods ***
    STDMETHOD(OnShow)(THIS_ DWORD dwID, POINT pt, LPARAM lParam) PURE;
    STDMETHOD(OnCommandSelected)(THIS_ DWORD dwID, WORD wCmdID)
        PURE;
    STDMETHOD(OnLinkSelected)(THIS_ DWORD dwID, LPCTSTR pszLink, LPARAM lParam)
        PURE;
    STDMETHOD(OnDismiss)(THIS_ DWORD dwID, BOOL fTimeout, LPARAM lParam) PURE;
};


// SHNotificationAdd
//
//   Add a notification.

LRESULT SHNotificationAdd(SHNOTIFICATIONDATA const * pndAdd);

// SHNotificationUpdate
//
//   Update aspects of a pending notification.

LRESULT SHNotificationUpdate(DWORD grnumUpdateMask, SHNOTIFICATIONDATA const * pndNew);

// SHNotificationRemove
//
//   Remove a notification.  This is usually in reponse to some
//   action taken on the data outside of the notification system - for example
//   if a message is read or deleted.

LRESULT SHNotificationRemove(const CLSID *pclsid, DWORD dwID);

// SHNotificationGetData
//
//   Get the data for a notification.  Used by a handler to get information
//   stored in the notification by the poster.

LRESULT SHNotificationGetData(CLSID const * pclsid, DWORD dwID, SHNOTIFICATIONDATA * pndBuffer);

// SHNotificationGetAll
//
//  Get all notifications.

LRESULT SHNotificationGetAll(SHNOTIFICATIONID ** prgNotif, DWORD * pdwCount);

// SHNotificationFreeData
//
//  Free the resources that SHNOTIFICATIONDATA structure contains

LRESULT SHNotificationFreeData(SHNOTIFICATIONDATA * pnd);

// SHNotificationUserAction
//
//  Notifies the sink window of the notification of the user action.

LRESULT SHNotificationUserAction(REFCLSID clsid, DWORD dwID);

//++++++
//
// GetOpenFileNameEx
//
//  This function extends the GetOpenFileName provided by WinCE to support our Thumbnail view and provide support
//  for other extensoins (i.e. hide DRM content) not supported by defauly in WinCE

//
// Sort order
//
typedef enum tagOFN_SORTORDER
{
   OFN_SORTORDER_AUTO,
   OFN_SORTORDER_DATE,
   OFN_SORTORDER_NAME,
   OFN_SORTORDER_SIZE,
   OFN_SORTORDER_ASCENDING = 0x00008000

} OFN_SORTORDER;

//
// Extended Flags  
//
typedef enum tagOFN_EXFLAG
{
    OFN_EXFLAG_EXPLORERVIEW                      = 0x00000000,
    OFN_EXFLAG_DETAILSVIEW                       = 0x00000001,
    OFN_EXFLAG_THUMBNAILVIEW                     = 0x00000002,
    OFN_EXFLAG_MESSAGING_FILE_CREATE             = 0x00000004,
    OFN_EXFLAG_CAMERACAPTURE_MODE_VIDEOONLY      = 0x00000008,
    OFN_EXFLAG_CAMERACAPTURE_MODE_VIDEOWITHAUDIO = 0x00000010,
    OFN_EXFLAG_CAMERACAPTURE_MODE_VIDEODEFAULT   = 0x00000020,
    OFN_EXFLAG_LOCKDIRECTORY                     = 0x00000100,
    OFN_EXFLAG_NOFILECREATE                      = 0x00000200,
    OFN_EXFLAG_HIDEDRMPROTECTED                  = 0x00010000,     //If this flag is set and the DRM engine is installed - the PicturePicker will not show ANY DRM content
    OFN_EXFLAG_HIDEDRMFORWARDLOCKED              = 0x00020000     //If this flag is set and the DRM engine is installed - the PicturePicker will not show ANY DRM FORWARD LOCK content
} OFN_EXFLAG;


typedef struct tagOPENFILENAMEEX
{
    // Fields which map to OPENFILENAME
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCTSTR      lpstrFilter;
   LPTSTR       lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPTSTR       lpstrFile;
   DWORD        nMaxFile;
   LPTSTR       lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCTSTR      lpstrInitialDir;
   LPCTSTR      lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCTSTR      lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCTSTR      lpTemplateName;

   // Extended fields
   DWORD       dwSortOrder;
   DWORD       ExFlags;
}OPENFILENAMEEX, *LPOPENFILENAMEEX ;


//
// The functions
//

BOOL GetOpenFileNameEx(LPOPENFILENAMEEX lpofnex);

//
// End GetOpenFileNameEX
//
//------

// }
//
// end SHNAPI
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//
// SHIme - Shell IME API
//
// These are APIs are used by IMEs (Input Method Editors) to communicate
// with the Smartphone shell.
//
// 

typedef enum tagSHIME_MODE
{
    SHIME_MODE_NONE                = 0,
    SHIME_MODE_SPELL               = 1,
    SHIME_MODE_SPELL_CAPS          = 2,
    SHIME_MODE_SPELL_CAPS_LOCK     = 3,
    SHIME_MODE_AMBIGUOUS           = 4,
    SHIME_MODE_AMBIGUOUS_CAPS      = 5,
    SHIME_MODE_AMBIGUOUS_CAPS_LOCK = 6,
    SHIME_MODE_NUMBERS             = 7,
    SHIME_MODE_CUSTOM              = 8,
} SHIME_MODE;


// Notify the shell that the user pressed a key.  (The shell can use this notification
// to reset idle timers.)
HRESULT SHImeOnKeyPress(void);

// Get the message that should go in the IME translation buffer in
// order to clear the field the user is typing in.  Usually this is triggered
// by press-and-hold of the Back button.
HRESULT SHImeGetClearMessage(HIMC himc, UINT *pMsg, WPARAM *pWParam, LPARAM *pLParam);

// Give the shell a bitmap containing icons which the shell will use to draw
// the status icon when in a custom input mode.
// The bitmap is a monochrome mask, H pixels high by H*N pixels wide, where N
// is the number of icons, and H is 16 at 96DPI and 22 at 131DPI.
HRESULT SHImeSetCustomInputIcons(HBITMAP hbm);

// Set the status icon to the specified mode.
// If mode==SHIME_MODE_CUSTOM, then iCustomMode specifies the
// custom mode, which is also the index into the bitmap supplied 
// by SHImeSetCustomInputIcons().
HRESULT SHImeSetModeIcon(SHIME_MODE mode, DWORD iCustomMode);


//
// end SHIme
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//
// DrawFocusRectColor
//
// Draw a rectangle in the style and color used to indicate that the rectangle has
// the focus, respecting the current theme.
//

#define DFRC_FOCUSCOLOR             0  // Draw using focus color for current theme
#define DFRC_SELECTEDBRUSH          1  // Draw using selected brush (can be used for erasing)


BOOL DrawFocusRectColor(HDC hdc, const RECT* lprc, UINT uFlags);

//
// end DrawFocusRectColor
//
//////////////////////////////////////////////////////////////////////////////


// For use with SHIdleTimerResetEx
#define LOCK_SESSION    0x00000001  // reset device lock session timer
#define HOME_SESSION    0x00000002  // reset home session timer
#define FLUSH_SESSION   0x00000004  // reset flush session timer
#define IDLE_SESSION    0x00000008  // reset system idle timer (call SystemIdleTimerReset)

// Reset shell's idle timer
void WINAPI SHIdleTimerReset();

// SHIdleTimerResetEx
// 
// Parameters
// dwFlags
//   [in] Specifies which shell session timer should be reset. On Smartphone, this parameter can be any
//    combination of the following values. PocketPC currently only supports LOCK_SESSION and IDLE_SESSION. 
//   LOCK_SESSION - reset device lock session timer
//   HOME_SESSION - reset home session timer
//   FLUSH_SESSION - reset flush session timer
//   IDLE_SESSION - reset the system idle timer
// Return Values
//      S_OK on success
HRESULT WINAPI SHIdleTimerResetEx(DWORD dwFlags);

// ExitWindowsEx : Shuts down the system.
//
BOOL ExitWindowsEx(
  UINT uFlags,       // shutdown operation
  DWORD dwReserved   // reserved
);
// Parameters
// uFlags 
//  [in] Specifies the type of shutdown. This parameter must be one of the following values. 
//      EWX_POWEROFF - Shuts down the system and turns off the power. (not supported on PocketPC)
//      EWX_REBOOT - Shuts down the system and reboots
//
//      The following modifiers can be OR'd in with EWX_REBOOT to modify its behavior
//      EWX_DEFER  - Reboot will be deferred until it is safe
//      EWX_PROMPT - User will be prompted before a reboot
// dwReserved 
//  [in] Reserved; this parameter is ignored.
// Return Values
//  If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. 
//
// Remarks
//  The ExitWindowsEx function returns as soon as it has initiated the shutdown. The shutdown then proceeds asynchronously. 

//////////////////////////////////////////////////////////////////////////////
//
// Flags for camera capture UI

/// <summary>
/// This is the enumerator for photo quality
/// </summary>
/// <remarks>
///
/// </remarks>
typedef enum
{
    CAMERACAPTUREEX_PHOTO_QUALITY_DEFAULT = 0,
    CAMERACAPTUREEX_PHOTO_QUALITY_BASIC,
    CAMERACAPTUREEX_PHOTO_QUALITY_NORMAL,
    CAMERACAPTUREEX_PHOTO_QUALITY_FINE,
    CAMERACAPTUREEX_PHOTO_QUALITY_SUPERFINE,
} CAMERACAPTUREEX_PHOTO_QUALITY;

/// <summary>
/// This is the enumerator for file type
/// </summary>
/// <remarks>
///
/// </remarks>
typedef enum
{
    CAMERACAPTUREEX_FILE_TYPE_ALL       = 0x00,
    CAMERACAPTUREEX_FILE_TYPE_STANDARD  = 0x01,
    CAMERACAPTUREEX_FILE_TYPE_MESSAGING = 0x02,
} CAMERACAPTUREEX_FILE_TYPE;


/// <summary>
/// This is the enumerator for capture modes
/// </summary>
/// <remarks>
///
/// </remarks>
typedef enum
{
    CAMERACAPTUREEX_CAPTURE_MODE_PHOTO = 0x01,
    CAMERACAPTUREEX_CAPTURE_MODE_VIDEO = 0x02,
} CAMERACAPTUREEX_CAPTURE_MODE;

/// <summary>
/// This is the enumerator for audio option
/// </summary>
/// <remarks>
///
/// </remarks>
typedef enum
{
    CAMERACAPTUREEX_AUDIO_OPTION_FREE = 0,
    CAMERACAPTUREEX_AUDIO_OPTION_ON,
    CAMERACAPTUREEX_AUDIO_OPTION_OFF,
} CAMERACAPTUREEX_AUDIO_OPTION;

/// <summary>
/// This is the extended version of SHCAMERACAPTURE structure that
/// used to configure the behavior of camera
/// </summary>
/// <param name="DWORD cbSize">
/// The size of SHCAMERACAPTUREEX structure in bytes
/// </param>
/// <param name="HWND hwndOwner">
/// A handle to the owner window. Can be NULL
/// </param>
/// <param name="TCHAR szFile[MAX_PATH]">
/// The fully-qualified path-name of the captured photo file or video file if
/// the photo or video has been successfully captured.
/// </param>
/// <param name="LPCTSTR pszDir">
/// Specifies the directory for storing the captured photo or video file. If
/// this parameter is NULL, the captured file will be saved to a camera app preferred
/// directory.
/// </param>
/// <param name="LPCTSTR pszFileName">
/// Specifies the file name, not include the suffix, for the captured photo
/// or video clip. If the file already exists and it is not read-only file,
/// it will be overwritten; if the file name is not specified by the caller,
/// a camera app perferred file name will be used. 
/// Note: The combination of pszDir and pszFileName must not exceed 256 characters.
/// <param name="LPCTSTR pszTitle">
/// The title will be used as the title when create the main window. 
/// Note: since camera is full screen app, the title won't be displayed. the caller
/// can use this title to distinguish different camera API windows.
/// </param>
/// <param name="CAMERACAPTUREEX_PHOTO_QUALITY PhotoQuality">
/// One of the CAMERACAPTUREEX_PHOTO_QUALITY enumeration values, which specifies
/// the quality of the captured photo.
/// </param>
/// <param name="DWORD dwFileTypes">
/// This is the bit mask of CAMERACAPTUREEX_FILE_TYPE enumeration values, which
/// specifies a file type.
/// For example, whether the file is suitable to be used by an MMS application.
/// </param>
/// <param name="dwResolutionWidth">
/// The image width, in pixels. When dwResolutionWidth equals 0, means any width
/// is acceptable.
/// </param>
/// <param name="DWORD dwResolutionHeight">
/// The image height, in pixels. When dwResolutionHeight equals 0, means any
/// height is acceptable
/// </param>
/// <param name="DWORD dwVideoTimeLimit">
/// The maximum length of time in seconds, allowed for a video clip. 0 indicates
/// that there is no limitation.
/// </param>
/// <param name="DWORD dwModes">
/// This is the bit mask of the capture CAMERACAPTUREEX_CAPTURE_MODE. if both video and photo
/// bit are set, camera API will have both photo and video mode available.
/// </param>
/// <param name="DWORD dwInitialMode">
/// If both CAMERACAPTUREEX_MODE_PHOTO and CAMERACAPTUREEX_MODE_VIDEO are set
/// in Modes, the InitialMode must be either CAMERACAPTUREEX_MODE_PHOTO or
/// CAMERACAPTUREEX_MODE_VIDEO;
/// if only one of CAMERACAPTUREEX_MODE_PHOTO or CAMERACAPTUREEX_MODE_VIDEO
/// is set in Modes, the InitialMode will be ignored.
/// </param>
/// <param name="CAMERACAPTUREEX_AUDIO_OPTION AudioOption">
/// One of the CAMERACAPTUREEX_AUDIO_OPTION enumeration values, which specifies
/// whether audio will be included in video clip. 
/// </param>
/// <param name="DWORD fPostCaptureScreen">
/// Specify if the post capture screen is needed; 0 mean no post capture screen;
/// other value means have post capture screen.
/// </param>
/// <remarks>
///
/// </remarks>
typedef struct tagSHCAMERACAPTUREEX
{
    DWORD cbSize;
    HWND hwndOwner;
    TCHAR szFile[MAX_PATH];
    LPCTSTR pszDir;
    LPCTSTR pszFileName;
    LPCTSTR pszTitle;
    CAMERACAPTUREEX_PHOTO_QUALITY PhotoQuality;
    DWORD dwFileTypes;
    DWORD dwResolutionWidth;
    DWORD dwResolutionHeight;
    DWORD dwVideoTimeLimit;
    DWORD dwModes;
    DWORD dwInitialMode;
    CAMERACAPTUREEX_AUDIO_OPTION AudioOption;
    BOOL fPostCaptureScreen;
}SHCAMERACAPTUREEX, *PSHCAMERACAPTUREEX;

/// <summary>
/// The second version of API to invoke the camera capture dialog
/// </summary>
/// <param name="pshcc">structure used to configure the behavior of camera </param>
/// <returns>
/// S_OK: The method completed successfully.
/// S_FALSE: The user canceled the Camera Capture dialog box.
/// E_OUTOFMEMORY: There is not enough memory to save the image or video.
///
/// The following error codes define at \public\mediaapps\sdk\inc\CAMErrorCodes.h
/// E_CAMERA_DISABLED: This error indicates that the camera is disabled due to
/// a specific condition value.
/// E_CAPTURE_FAILURE: This error indicates that there is error when capture
/// image or video.
/// E_INVALID_VERSION: the cbSize is not valid.
/// E_INVALID_OWNER_WINDOW: the hwndOwner is not valid window handle.
/// E_INVALID_DIR: This error indicates that pszDir is either not exists.
/// E_INVALID_FILE_NAME: This error indicates that pszFileName is either invalid
/// file name or the string length of combination of pszDir and pszFileName
/// exceed MAX_PATH
/// E_INVALID_PHOTO_QUALITY: This error indicates that the PictureQuality
/// parameter is invalid.
/// E_INVALID_FILE_TYPE: This error indicates that the FileTypes parameter
/// is invalid.
/// E_INVALID_RESOLUTION: this error indicates that the resolution indicated by
/// dwResolutionWidth and dwResolutionHeight is not supported by camera app.
/// E_INVALID_CAPTURE_MODES: This error indicates that the Modes parameter is invalid.
/// E_INVALID_INITIAL_MODE: This error indicates that the InitialMode parameter is invalid.
/// E_INVALID_AUDIO_OPTION: This error means audio option cant be turned on
/// or off due to either hardware restrain or device wide audio capture policy.
/// </returns>
/// <remarks>
///
/// </remarks>

HRESULT SHCameraCaptureEx (PSHCAMERACAPTUREEX pshcc);

//
// end of flags for camera capture UI
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
// SHDeviceLockAndPrompt
//
// Puts the device into a lock state and immediately attempts to unlock it.
// Available to trusted callers only.
//
// Return Value:
//  (HRESULT) S_OK if the lock succeeded (return value does not check unlock). 
//  Failure otherwise.
//  
HRESULT SHDeviceLockAndPrompt(); 
//
// End SHDeviceLockAndPrompt
//
//////////////////////////////////////////////////////////////////////////////

/// <summary>
/// Adjust the power timeout when the device is locked/unlocked.
/// </summary>
/// <param name="fLock">
/// The lock state for which the power timeout should be applied.  
/// fLock=FALSE will apply the user-selected 
/// timeouts that are normally used when the device is unlocked.
/// fLock=TRUE will apply the shorter timeouts that are 
/// normally used when the device is locked.
/// </param>
/// <remarks>
/// This API is used to adjust the power timeout when the device is
/// locked. Primarily it is called by the Shell when locking and
/// unlocking the device but can also be called by applications
/// to temporarily override the shorter power timeout when the
/// device is locked.
/// NOTE: this API must be called in matched pairs - once with
/// fLock=FALSE to override the reduced timeout, and once with
/// fLock=TRUE to restore it.
/// </remarks>
HRESULT SHSetPowerTimeoutForLock(BOOL fLock);

//////////////////////////////////////////////////////////////////////////////
//
// IsMatchFromKeyMap
//
// Given a filter string, text string, and matching options, IsMatchFromKeyMap
// determines if there is a way to match the two strings using one or more of the
// mappings configured on the device.  In case of a possible match, IsMatchFromKeyMap
// can optionally output data about what was matched.
//
// Parameters:
//  pszFilter
//   [in] String containing search filter to use.
//  pszText
//   [in] String containing text to apply pszFilter to.
//  dwFlags
//   [in] Bit flags specifying how to perform the matching.
//  cMatchBufferLengths
//   [in] Minimum count of elements in prgbMatchCounts and pszMatchedText if they're non-NULL
//  prgbMatchCounts
//   [out] Optional pointer to an array of at least cMatchBufferLengths BYTEs.
//         If pszFilter and pszText match then prgbMatchCounts[i] is the number of contiguous
//         characters matched starting from pszText[i].
//  pszMatchedText
//   [out] Optional pointer to an array of at least cMatchBufferLengths TCHARs.
//         If pszFilter and pszText match then pszMatchedText will be a string representing what matched.
//
// Return Value:
//  TRUE if the strings match.
//  FALSE otherwise.
//
// Remarks:
//
//   IsMatchFromKeyMap uses one or more of the following mappings to match the strings:
//     Hardware keyboard mappings
//     Phone keypad mappings (e.g. 2:abc, 3:def, etc.)
//     Equivalence mappings (e.g. case, width, kana-type, and accent insensitive matching)
//
//   IsMatchFromKeyMap may also use one or more of the following advanced matching features:
//     Wildcard (note that the default wildcard character is '1' but can be changed/disabled by the OEM)
//     Delimited matching (e.g. match "Barry Johnson" with a filter string of "b john")
//     Skippable characters matching (e.g. match "Vlatka Juric-Sedic" with a filter string of "juricsed")
//     Wraparound matching (e.g. match "Johnson, Barry" with a filter string of "barryj"
//
//   The very first time IsMatchFromKeyMap is called for a process may take longer to return
//   than subsequent calls because internal data initialization is required the first time
//   this function is called.  If this delay on first match session is noticeable with your
//   application, try calling IsMatchFromKeyMap(_T(""), _T(""), 0, 0, NULL, NULL)
//   at an appropriate time before the user starts inputting a filter string.
//
//   pszFilter only supports up to KEYMAP_CCH_MAXFILTER TCHARs
//   pszText only supports up to KEYMAP_CCH_MAXTEXT TCHARs
//   dwFlags can be any KEYMAP_IMF_* value
//   cMatchBufferLengths should at least be as large as the length of pszText + 1 for a terminating NULL
//
//   Here are some example matching scenarios of what prgbMatchCounts and pszMatchedText will contain
//   when using dwFlags of KEYMAP_IMF_NAME | KEYMAP_IMF_NOKEYBOARDMAPPINGS:
//
//     A filter of "jo" against a name of "Barry Johnson" would produce:
//       prgbMatchCounts[6] = 2 (and all other values of prgbMatchCounts up to index 12 will be 0)
//       pszMatchedText = "Jo"
//     A filter of "bar" against a name of "Barry Johnson" would produce:
//       prgbMatchCounts[0] = 3
//       pszMatchedText = "Bar"
//     A filter of "j bar" against a name of "Barry Johnson" would produce:
//       prgbMatchCounts[0] = 3; prgbMatchCounts[6] = 1
//       pszMatchedText = "J Bar"
//     A filter of "barryjohnson" against "Barry Johnson" would produce:
//       prgbMatchCounts[0] = 13
//       pszMatchedText = "Barry Johnson"
//     A filter of "johnsonbarry" against "Barry Johnson" would produce:
//       prgbMatchCounts[0] = 5; prgbMatchCounts[6] = 7
//       pszMatchedText = "Johnson Barry" 
//     A filter of "vlatkajuric" against "Juric-Sedic, Vlatka" would produce:
//       prgbMatchCounts[0] = 5; prgbMatchCounts[13] = 6
//       pszMatchedText = "Vlatka Juric"
//
BOOL IsMatchFromKeyMap(__in LPCTSTR pszFilter, __in LPCTSTR pszText, DWORD dwFlags, UINT cMatchBufferLengths, __out_bcount_opt(cMatchBufferLengths) BYTE *prgbMatchCounts, __out_ecount_opt(cMatchBufferLengths) TCHAR *pszMatchedText);

// IsMatchFromKeyMap maximum string parameter lengths
#define KEYMAP_CCH_MAXFILTER    250
#define KEYMAP_CCH_MAXTEXT      1027

// IsMatchFromKeyMap supported flags
// Note that equivalence mappings cannot be turned off.
// Note that advanced matching features cannot be turned off from this API.
//   - Although space is always a delimiter, a custom delimiter character can also
//     be configured by the OEM or by ISVs via the LoadKeyMap API.
enum KEYMAP_ISMATCHFLAGS
{
    // Let IsMatchFromKeyMap determine whether pszText should be matching using
    // name, number, or text matching logic.  This flag is useful when iterating
    // across a list of mixed content where some items should match via name,
    // some via number, or some via plain text.
    KEYMAP_IMF_AUTORECOGNIZE                = 0x1,

    // pszText is the name of a person or business.  This affects how matching is
    // performed, especially with regards to names in the "last, first" format.
    KEYMAP_IMF_NAME                         = 0x2,

    // pszText is a telephone number.  This affects how matching is performed,
    // especially with regards to ignoring formatting characters in the number.
    KEYMAP_IMF_NUMBER                       = 0x4,

    // pszText is plain text.  This affects how matching is performed, especially
    // by not applying name or number specific logic.
    KEYMAP_IMF_TEXT                         = 0x8,

    // Do not use hardware keyboard mappings.  Default is on.
    // This flag is useful for reducing overmatching when the user isn't using
    // the hardware keyboard.
    KEYMAP_IMF_NOKEYBOARDMAPPINGS           = 0x100,

    // Use phone keypad mappings.  Default is off.
    // Note that the default phone keypad mappings are the ITU E 1.161 mappings
    // of 2:ABC, 3:DEF, etc. though OEMs can configure these mappings differently.
    // This flag is useful when the user is using the phone keypad.
    KEYMAP_IMF_USEPHONEKEYPADMAPPINGS    = 0x200,
};

//////////////////////////////////////////////////////////////////////////////
//
// KeyMapCharacter
//
// Apply one or more of the mappings configured on the device to the character input.
//
// Parameters:
//  chInput
//   [in] Character to map.
//  cKeyMaps
//   [in] Flags specifying what type(s) of mappings to apply.
//
// Return Value:
//  Mapped character value if successful.
//  0 otherwise.
TCHAR KeyMapCharacter(TCHAR chInput, DWORD dwFlags);

// KeyMapCharacter supported flags
enum KEYMAP_MAPCHARACTERFLAGS
{
    // Letters to digits via ITU E 1.161.  Digits are output unchanged.
    // Ex: chInput of A, B, or C outputs 2; D, E, or F outputs 3; etc.
    // Iterating across a string like "1800ABCDEFG" would output "18002223334"    
    KEYMAP_MCF_ALPHATOPHONE                 = 0x1,

    // Character to first matching character using the hardware keyboard mappings.
    // The phone application uses this mapping to determine what to display in the
    // No Matches text when the filter string matches nothing.
    // Ex: If the hardware keyboard has "T5", "I8", and "M?" keys and the hardware
    // keyboard mappings list 't', 'i', and 'm' as the first matching characters for
    // '5', '8', and '?' respectively then if the user types "58?" and it doesn't happen
    // to match any entries then the No Matches text will display "tim" instead of "58?"
    KEYMAP_MCF_KEYMAPTOFIRSTMATCH,

    // Character to filter character that would match it using the hardware keyboard mappings.
    // Ex: If the hardware keyboard has a "K:" key then chInput of 'k' will output ':'
    KEYMAP_MCF_KEYMAPTOFILTERCHAR,

    // Characters to phone characters using the on-screen keypad mappings.
    // Ex: By default, the on-screen keypad mappings are based on ITU E 1.161
    // so chInput of 'T', 'i', 'm' would output '8', '4', '6'.  The OEM can
    // customize these mappings differently though so it's better to use
    // KEYMAP_MCF_KEYMAPTOPHONEKEYPAD instead of KEYMAP_MCF_ALPHATOPHONE if the
    // user is inputting characters via a phone keypad.
    KEYMAP_MCF_KEYMAPTOPHONEKEYPAD
};

//////////////////////////////////////////////////////////////////////////////
//
// KEYMAPPING struct
//
// Use to specify keyboard mapping data for use with LoadKeyMap function.
//
// Fields:
//   chHardware
//     WM_CHAR value sent when the affected key is pressed
//     without using <shift> or other modifiers.
//   rgchMatches
//     WM_CHAR values that should match chHardware.
//
// Remarks:
//   rgchMatches must be '\0' terminated.
//   chHardware values must be unique.
//   rgchMatches individual values must be unique.
//   chHardware and rgchMatches values must be lowercase or caseless.
//
typedef struct _KEYMAPPING
{
    WCHAR chHardware;
    WCHAR *rgchMatches;
} KEYMAPPING, *PKEYMAPPING;

//////////////////////////////////////////////////////////////////////////////
//
// LoadKeyMap
//
// Load keyboard mapping data and override current keyboard mapping.
// Usable by trusted callers only.
//
// Parameters:
//  prgKeyMaps
//   [in opt] Pointer to array of KEYMAPPINGs to load.
//  cKeyMaps
//   [in] Count of KEYMAPPINGs to load.
//
// Return Value:
//  (HANDLE) Handle to KeyMap identifier for use with UnloadKeyMap.
//  INVALID_HANDLE_VALUE in case of failure.
//
// Remarks:
//  Default keyboard mapping data is always restored on reboot.
//  It can also be restored by calling UnloadKeyMap.
//  Be sure to call UnloadKeyMap if the device for this mapping data is disconnected.
//  Set prgKeyMaps to NULL to set keyboard mappings for an unambiguous keyboard.
//
HANDLE LoadKeyMap(__in_ecount_opt(cKeyMaps) const PKEYMAPPING prgKeyMaps, DWORD cKeyMaps);

//////////////////////////////////////////////////////////////////////////////
//
// UnloadKeyMap
//
// Unload keyboard mapping data and restore default keyboard mapping data.
// Usable by trusted callers only.
//
// Parameters:
//  hKeyMap
//   [in] HANDLE to KeyMap identifier returned by LoadKeyMap.
//
// Return Value:
//  Standard HRESULT.
//
HRESULT UnloadKeyMap(HANDLE hKeyMap);

//////////////////////////////////////////////////////////////////////////////
//
// Authentication Reset APIs
//
// These APIs are used by LAPs (Local Authentication Plugins) to setup and 
// perform Authentication Reset.
//
// Implemented in Aygshell.dll
// 
// 
// Defined value types for AuthResetGetValue()
#define AUTHRESET_VALUE_FAILURE_THRESHOLD       1
#define AUTHRESET_VALUE_FAILURE_COUNT           2
#define AUTHRESET_VALUE_SETUP_MESSAGE           3
#define AUTHRESET_VALUE_SETUPRESULT_MESSAGE     4
#define AUTHRESET_VALUE_REQUEST_MESSAGE         5
#define AUTHRESET_VALUE_REQUESTRESULT_MESSAGE   6

//////////////////////////////////////////////////////////////////////////////
//
// AuthResetSetup
//
// This function wraps the Authentication Reset Component setup functionality.
// 
// Parameters
//    hWndParent 
//        [in] Handle to the parent window. May be NULL.
//    pbResetData
//        [in, optional] Pointer to Reset Data. The meaning, size, and contents
//        of the Reset Data are defined by the caller. The same data will be 
//        returned by a successful call to AuthResetRequest. May be NULL.
//    cbResetData
//        [in] Size, in bytes, of the buffer pointed to by pbResetData. If 
//        pbResetData is not NULL, cannot be 0. If pbResetData is NULL, this 
//        parameter is ignored.
//    ppbRequestData
//        [out] Pointer to a BYTE-array that receives the data to use during 
//        a call to AuthResetRequest. The meaning, size, and contents of the 
//        Request Data are defined by the Authentication Reset Component. The
//        caller is responsible for storing this data securely and providing it
//        in subsequents calls to AuthResetReqeust. The buffer for the BYTE array 
//        is allocated by this function. The caller is required to free this 
//        buffer using LocalFree. 
//    pcbRequestData
//        [out] Pointer to a variable that receives the size of the buffer 
//        pointed to by the ppbRequestData parameter, in bytes.
// 
// Return Values
//    Returns S_OK if setup steps were completed successfully or an error code 
//    otherwise:
// 
//    Error                Description
//    ------------------------------------------------------------------------
//    HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED)
//                         Device configuration does not permit Authentication 
//                         Reset.
//    HRESULT_FROM_WIN32(ERROR_TOO_MANY_SESS)
//                         Another thread is already calling AuthResetSetup or 
//                         AuthResetRequest.
//    HRESULT_FROM_WIN32(WAIT_TIMEOUT)
//                         The wait timeout has been exceeded.
//    E_ACCESSDENIED       The caller is not trusted.
//    E_POINTER            Invalid pointer. Either ppbRequestData is NULL or 
//                         pcbRequestData is NULL. Valid pointers for these 
//                         arguments are required.
//    E_INVALIDARG         Invalid argument. pbResetData is not NULL and 
//                         cbResetData is 0. This condition is not allowed.
//    E_ABORT              The user cancelled the process.
//    E_OUTOFMEMORY        The device is out of memory.
//    E_FAIL               Unspecified error.
// 
//    Other error codes may be defined by Authentication Reset Components.
//
// Remarks
//    A LAP should call this API during enrollment if it wants to make 
//    Authentication Reset available to the user at a later time. The LAP 
//    may supply Reset Data (e.g., an admin key) and must receive Request 
//    Data (e.g., a certificate). The method used to process the Request Data 
//    and the methods of storing and retrieving Reset Data are at the  
//    discretion of the Authentication Reset Component. Request Data must be 
//    securely stored and used when calling AuthResetRequest. If a call to 
//    AuthResetRequest is successful and Reset Data were supplied previously, 
//    the Reset Data are returned and the LAP should verify that these data 
//    match the originally-supplied data.  
//
//    The Authentication Reset component may display user interface and may 
//    take any amount of time to complete this function.
//
//    This function ignores the AuthenticationReset policy.
//
//    The default functionality encrypts the Reset Data with a key that is
//    stored on an Exchange Server and returns the encrypted data to the 
//    caller as the Request Data.
//
//    This API can only be called by trusted processes.
// 
HRESULT AuthResetSetup(__in_opt HWND hWndParent, __in_bcount_opt(cbResetData) const BYTE* pbResetData, DWORD cbResetData, 
                       __deref_out_bcount(*pcbRequestData) LPBYTE* ppbRequestData, __out LPDWORD pcbRequestData);

//////////////////////////////////////////////////////////////////////////////
//
// AuthResetRequest
//
// This function wraps the Authentication Reset Component request functionality.
// 
// Parameters
//    hWndParent 
//        [in] Handle to the parent window. May be NULL.
//    pbRequestData
//        [in] Pointer to the Request Data. To successfully complete 
//        Authentication Reset, this must be the same data returned by a 
//        successful call to AuthResetSetup. The meaning, size, and contents
//        of the Request Data are defined by the Authentication Reset 
//        Component.
//    cbRequestData
//        [in] Size, in bytes, of the buffer pointed to by pbRequestData.
//    ppbResetData
//        [out] Pointer to a BYTE-array that contains the Reset Data 
//        set during a call to AuthResetSetup, if available. The caller
//        should verify that the contents of this buffer match the 
//        originally-supplied Reset Data before continuing Authentication
//        Reset steps. The buffer for the BYTE array will be allocated by 
//        this function. The caller is required to free this buffer using 
//        LocalFree. If no Reset Data are available, this argument will
//        point to NULL.
//    pcbResetData
//        [out] Pointer to size of the buffer supplied in the ppbResetData 
//        parameter, in bytes. If no Reset Data are available, this argument 
//        will point to 0.
// 
// Return Values
//    Returns S_OK if Authentication Reset is allowed to proceed. In this case,
//    pbRequestData has been verified and ppbResetData contains the originally-
//    supplied Reset Data. The LAP should perform any additional authentication
//    necessary before continuing Authentication Reset steps. If Authentication
//    Reset cannot proceed, an error code is returned:
// 
//    Error                             Description
//    ------------------------------------------------------------------------
//    HRESULT_FROM_WIN32(ERROR_PRIVILEGE_NOT_HELD) 
//                                      The Authentication Reset request is 
//                                      denied.
//    HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED)      
//                                      Device policy and/or configuration does 
//                                      not permit Authentication Reset.
//    HRESULT_FROM_WIN32(ERROR_TOO_MANY_CMDS)      
//                                      The number of Authentication Reset
//                                      attempts has been exceeded.
//    HRESULT_FROM_WIN32(ERROR_TOO_MANY_SESS)      
//                                      Another thread is already calling 
//                                      AuthResetSetup or AuthResetRequest.
//    HRESULT_FROM_WIN32(WAIT_TIMEOUT)  The wait timeout has been exceeded.
//    E_PENDING                         The Authentication Reset could not be 
//                                      completed at this time. The user may 
//                                      be requested to wait or perform some 
//                                      action, then try again.
//    E_ACCESSDENIED                    The caller is not trusted.
//    E_POINTER                         Invalid pointer. Either ppbResetData is NULL or 
//                                      pcbResetData is NULL. Valid pointers for these 
//                                      arguments are required.
//    E_INVALIDARG                      Invalid argument. pbRequestData is NULL 
//                                      or cbResetData is 0. Non-zero values
//                                      for these arguments are required.
//    E_ABORT                           The user cancelled the process.
//    E_OUTOFMEMORY                     The device is out of memory.
//    E_FAIL                            Unspecified error.
// 
// Remarks
//    A LAP should call this API if a user requests to reset an authentication 
//    token (e.g., they have lost or forgotten a password, card, etc). This  
//    function will determine if the user is allowed to perform an  
//    Authentication Reset. It will also retrieve associated Reset Data if any 
//    were stored using AuthResetSetup. If a call to AuthResetRequest is 
//    successful and Reset Data were supplied previously, the Reset Data are 
//    returned and the LAP should verify that these data match the originally-
//    supplied data. The LAP should also perform any additional authentication
//    necessary before continuing Authentication Reset steps. The method used 
//    to determine if the user is allowed to perform Authentication Reset and 
//    the methods of storing and retrieving Reset Data are at the discretion 
//    of the Authentication Reset Component. 
//
//    This function will fail if the AuthenticationReset policy is set to 0 
//    (Authentication Reset is not allowed).
//
//    The default functionality prompts the user for a recovery password that can
//    be obtained from a system administrator. 

//    This API can only be called by trusted processes.
//
//    If a DeviceWipeThreshold has been set on the device, this API will 
//    limit the number of failed Authentication Reset attempts. When the 
//    threshold has been reached, this function will always return 
//    HRESULT_FROM_WIN32(ERROR_TOO_MANY_CMDS).
// 
HRESULT AuthResetRequest(__in_opt HWND hWndParent, __in_bcount(cbRequestData) const BYTE* pbRequestData, DWORD cbRequestData, 
                         __deref_out_bcount_opt(*pcbResetData) LPBYTE* ppbResetData, __out LPDWORD pcbResetData);

//////////////////////////////////////////////////////////////////////////////
//
// AuthResetGetValue
//
// This function provides a method to query the Authentication Reset Component 
// for values.
// 
// Parameters
//    dwValueId 
//        [in] The value to query. The list of values that can be queried may 
//        be extended by Authentication Reset Components.The known values that 
//        can be queried are:
//
//        dwValueId                              pInData            pOutBuffer
//        --------------------------------------------------------------------
//        AUTHRESET_VALUE_FAILURE_THRESHOLD      Ignored            Pointer to a DWORD.
//            Returns the AuthReset failure threshold. This is the number of 
//            times that AuthReset may be attempted without succeeding. When 
//            this threshold has been reached, AuthResetRequest will always 
//            fail. Returns 0 if no threshold is set.    
//        AUTHRESET_VALUE_FAILURE_COUNT          Ignored            Pointer to a DWORD.
//            Returns the number of AuthReset failures. Returns 0 if there 
//            have been no failures.    
//        AUTHRESET_VALUE_SETUP_MESSAGE          Ignored            String pointer. May be an empty string.
//            Returns the setup message from the registered Authentication 
//            Reset Component. In some cases, this message may be overridden 
//            or augmented by the IT administrator. If the component does not 
//            provide a setup message, pOutBuffer will be an empty string.
//            This message introduces the Authentication Reset setup process 
//            and alerts the user to any requirements (e.g., existing 
//            ActiveSync partnership, network connectivity, etc.).    
//        AUTHRESET_VALUE_SETUPRESULT_MESSAGE    HRESULT from       String pointer. May be an empty string.
//                                               AuthResetSetup    
//            Returns the result message from the registered Authentication 
//            Reset Component. In some cases, this message may be overridden 
//            or augmented by the IT administrator. If the component does not 
//            provide a result message, pOutBuffer will be an empty string.    
//        AUTHRESET_VALUE_REQUEST_MESSAGE        Ignored            String pointer. May be an empty string.
//            Returns the reset message from the registered Authentication 
//            Reset Component. In some cases, this message may be overridden 
//            or augmented by the IT administrator. If the component does not 
//            provide a reset message, pOutBuffer will be an empty string.
//            This message introduces the Authentication Reset process and 
//            alerts the user to any requirements (e.g., existing ActiveSync 
//            partnership, network connectivity, etc.).    
//        AUTHRESET_VALUE_REQUESTRESULT_MESSAGE  HRESULT from       String pointer. May be an empty string.
//                                               AuthResetRequest    
//            Returns the result message from the registered Authentication 
//            Reset Component. In some cases, this message may be overridden 
//            or augmented by the IT administrator. If the component does not 
//            provide a result message, pOutBuffer will be an empty string.    
//        
//    pInData 
//        [in, optional] Pointer to input data. The type and meaning of this 
//        data depends on dwValueId. May be NULL.
//    cbInData 
//        [in] Size of the input data in bytes. Ignored if pInData is NULL.
//    pOutBuffer 
//        [out] Pointer to a buffer that receives the value associated with 
//        dwValueId. The type and meaning of this buffer depend on dwValueId. 
//        If pOutBuffer is NULL, this function returns ERROR_SUCCESS and 
//        stores the size of the value, in bytes, in the variable pointed to 
//        by pcbOutBuffer. This enables an application to determine the best 
//        way to allocate a buffer for the value's data.
//    pcbOutBuffer 
//        [in, out] Pointer to a variable that specifies the size of the buffer 
//        pointed to by the pOutBuffer parameter, in bytes. When the function 
//        returns, this variable contains the size of the data copied to 
//        pOutBuffer, including any terminating null characters. 
//        If the value is a string, this size includes any terminating null 
//        character or characters. 
//        If the buffer specified in pOutBuffer is not large enough to hold the 
//        data, the function returns ERROR_MORE_DATA and stores the required 
//        buffer size in the variable pointed to by pcbOutBuffer. In this case, 
//        the contents of pOutBuffer are undefined.
// 
// Return Values
//    If the function succeeds, the return value is ERROR_SUCCESS.
//    If the function fails, the return value is a nonzero error code defined 
//    in Winerror.h. You can use the FormatMessage function with the 
//    FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the 
//    error. The following table shows the most common error codes:
// 
//    Error                    Description
//    ------------------------------------------------------------------------
//    ERROR_INVALID_PARAMETER  One of the parameters contains an invalid 
//                             value. pInData may be the wrong size for the 
//                             data input required by dwValueId.
//    ERROR_MORE_DATA          The buffer specified by the pOutbuffer 
//                             parameter is not large enough to hold the 
//                             returned data.
//    ERROR_UNKNOWN_PROPERTY   The dwValueId parameter is not a valid option.
// 
// Remarks
//    Authentication Reset components may expose additional values for use 
//    by specific LAPs (especially in the case that the LAP and Authentication 
//    Reset Components are developed by the same party). If the system does not 
//    recognize the value in dwValueId, it passes it into the Authentication 
//    Reset Component. 
//    The default Windows Mobile Authentication Reset Component attempts to 
//    load strings from the registry. This allows IT administrators to override 
//    the default messages provided. Other Authentication Reset Components 
//    may provide similar functionality.
// 
LONG AuthResetGetValue(DWORD dwValueId, __in_bcount_opt(cbInData) PVOID pInData, DWORD cbInData, 
                       __out_bcount_part_opt(*pcbOutBuffer, *pcbOutBuffer) PVOID pOutBuffer, __inout DWORD* pcbOutBuffer);

//////////////////////////////////////////////////////////////////////////////
//
// Implemented by the Authentication Reset Components:
//
//////////////////////////////////////////////////////////////////////////////
//
// ARCSetup
//
// This function is implemented by the Authentication Reset Component. It 
// may perform any desired functionality to allow future Authentication 
// Reset requests.
// 
// Parameters
//    hWndParent 
//        [in] Handle to the parent window. May be NULL.
//    pbResetData
//        [in, optional] Pointer to Reset Data. The meaning, size, and contents
//        of the Reset Data are defined by the caller. The same data will be 
//        returned by a successful call to ARCRequest. May be NULL.
//    cbResetData
//        [in] Size, in bytes, of the buffer pointed to by pbResetData. If 
//        pbResetData is not NULL, cannot be 0. If pbResetData is NULL, this 
//        parameter is ignored.
//    ppbRequestData
//        [out] Pointer to a BYTE-array that receives the data to use during 
//        a call to ARCRequest. The meaning, size, and contents of the 
//        Request Data are defined by the Authentication Reset Component. The
//        caller is responsible for storing this data securely and providing it
//        in subsequents calls to ARCRequest. The buffer for the BYTE array 
//        must be allocated by this function using LocalAlloc. The caller is 
//        required to free this buffer using LocalFree. 
//    pcbRequestData
//        [out] Pointer to a variable that receives the size of the buffer 
//        pointed to by the ppbRequestData parameter, in bytes.
// 
// Return Values
//    Returns S_OK if setup steps were completed successfully or an error code 
//    otherwise. Examples:
// 
//    Error              Description
//    ------------------------------------------------------------------------
//    HRESULT_FROM_WIN32(WAIT_TIMEOUT)
//                         The wait timeout has been exceeded.
//    E_ACCESSDENIED       The caller is not trusted.
//    E_POINTER            Invalid pointer. Either ppbRequestData is NULL or 
//                         pcbRequestData is NULL. Valid pointers for these 
//                         arguments are required.
//    E_INVALIDARG         Invalid argument. pbResetData is not NULL and 
//                         cbResetData is 0. This condition is not allowed.
//    E_ABORT              The user cancelled the process.
//    E_OUTOFMEMORY        The device is out of memory.
//    E_FAIL               Unspecified error.
// 
//    Other error codes may be defined by Authentication Reset Components.
//
// Remarks
//    This function is called by the Shell in response to a request from a 
//    LAP to setup Authentication Reset. LAPs must not call this function 
//    directly, they should use AuthResetRequest. 
//    
//    Buffers returned from this function must be allocated using LocalAlloc.
//
//    The Authentication Reset component may display user interface and may 
//    take any amount of time to complete this function. If user interface is 
//    displayed, the implementation must provide a way for the user to cancel 
//    or provide a mechanism to place emergency phone calls (on phone devices). 
//    All windows must have the WS_EX_ABOVESTARTUP exstyle set.
//    If the user cancels, this function should return E_ABORT.
// 
HRESULT ARCSetup(__in_opt HWND hWndParent, __in_bcount_opt(cbResetData) const BYTE* pbResetData, DWORD cbResetData, 
                 __deref_out_bcount(*pcbRequestData) LPBYTE* ppbRequestData, __out LPDWORD pcbRequestData);

//////////////////////////////////////////////////////////////////////////////
//
// ARCRequest
//
// This function is implemented by the Authentication Reset Component. It 
// may perform any desired functionality to determine if Authentication 
// Reset is allowed.
// 
// Parameters
//    hWndParent 
//        [in] Handle to the parent window. May be NULL.
//    pbRequestData
//        [in] Pointer to the Request Data. To successfully complete 
//        Authentication Reset, this must be the same data returned by a 
//        successful call to ARCSetup. The meaning, size, and contents
//        of the Request Data are defined by the Authentication Reset 
//        Component.
//    cbRequestData
//        [in] Size, in bytes, of the buffer pointed to by pbRequestData.
//    ppbResetData
//        [out] Pointer to a BYTE-array that contains the Reset Data 
//        set during a call to ARCSetup, if available. The caller
//        should verify that the contents of this buffer match the 
//        originally-supplied Reset Data before continuing Authentication
//        Reset steps. The buffer for the BYTE array must be allocated by 
//        this function using LocalAlloc. The caller is required to free 
//        this buffer using LocalFree. If no Reset Data are available, 
//        this argument will point to NULL.
//    pcbResetData
//        [out] Pointer to size of the buffer supplied in the ppbResetData 
//        parameter, in bytes. If no Reset Data are available, this argument 
//        will point to 0.
// 
// Return Values
//    Returns S_OK if Authentication Reset is allowed to proceed. In this case,
//    pbRequestData must have been verified and ppbResetData must contain the 
//    originally-supplied Reset Data. If Authentication Reset cannot proceed, 
//    an error code is returned. The error code must be 
//    HRESULT(ERROR_PRIVILEGE_NOT_HELD) if the request is denied, but 
//    may contain more specific error information. Examples:
// 
//    Error                             Description
//    ------------------------------------------------------------------------
//    HRESULT(ERROR_PRIVILEGE_NOT_HELD) The Authentication Reset request is 
//                                      denied.
//    HRESULT_FROM_WIN32(WAIT_TIMEOUT)  The wait timeout has been exceeded.
//    E_PENDING                         The Authentication Reset could not be 
//                                      completed at this time. The user may 
//                                      be requested to wait or perform some 
//                                      action, then try again.
//    E_ACCESSDENIED                    The caller is not trusted.
//    E_POINTER                         Invalid pointer. Either ppbResetData is NULL or 
//                                      pcbResetData is NULL. Valid pointers for these 
//                                      arguments are required.
//    E_INVALIDARG                      Invalid argument. pbRequestData is NULL 
//                                      or cbResetData is 0. Non-zero values
//                                      for these arguments are required.
//    E_ABORT                           The user cancelled the process.
//    E_OUTOFMEMORY                     The device is out of memory.
//    E_FAIL                            Unspecified error.
// 
// Remarks
//    This function is called by the Shell in response to a request from a LAP 
//    to reset the user's authentication. LAPs must not call this function 
//    directly, they should use AuthResetRequest. 
//
//    Buffers returned from this function must be allocated using LocalAlloc.
//
//    The Authentication Reset component may display user interface and may 
//    take any amount of time to complete this function. If user interface is 
//    displayed, the implementation must provide a way for the user to cancel 
//    or provide a mechanism to place emergency phone calls (on phone devices). 
//    All windows must have the WS_EX_ABOVESTARTUP exstyle set.
//    If the user cancels, this function should return E_ABORT.
// 
HRESULT ARCRequest(__in_opt HWND hWndParent, __in_bcount(cbRequestData) const BYTE* pbRequestData, DWORD cbRequestData, 
                   __deref_out_bcount_opt(*pcbResetData) LPBYTE* ppbResetData, __out LPDWORD pcbResetData);

//////////////////////////////////////////////////////////////////////////////
//
// ARCGetValue
//
// This function queries the Authentication Reset Component for values.
// 
// Parameters
//    dwValueId 
//        [in] The value to query. Authentication Reset Components may extend 
//        this list as necessary. The known values that can be queried are:
//
//        dwValueId                              pInData            pOutBuffer
//        --------------------------------------------------------------------
//        AUTHRESET_VALUE_SETUP_MESSAGE          Ignored            String pointer. May be an empty string.
//            Returns the setup message from the registered Authentication 
//            Reset Component. In some cases, this message may be overridden 
//            or augmented by the IT administrator. If the component does not 
//            provide a setup message, pOutBuffer will be an empty string.
//            This message introduces the Authentication Reset setup process 
//            and alerts the user to any requirements (e.g., existing 
//            ActiveSync partnership, network connectivity, etc.).    
//        AUTHRESET_VALUE_SETUPRESULT_MESSAGE    HRESULT from       String pointer. May be an empty string.
//                                               ARCSetup    
//            Returns the result message from the registered Authentication 
//            Reset Component. In some cases, this message may be overridden 
//            or augmented by the IT administrator. If the component does not 
//            provide a result message, pOutBuffer will be an empty string.    
//        AUTHRESET_VALUE_REQUEST_MESSAGE        Ignored            String pointer. May be an empty string.
//            Returns the reset message from the registered Authentication 
//            Reset Component. In some cases, this message may be overridden 
//            or augmented by the IT administrator. If the component does not 
//            provide a reset message, pOutBuffer will be an empty string.
//            This message introduces the Authentication Reset process and 
//            alerts the user to any requirements (e.g., existing ActiveSync 
//            partnership, network connectivity, etc.).    
//        AUTHRESET_VALUE_REQUESTRESULT_MESSAGE  HRESULT from       String pointer. May be an empty string.
//                                               ARCRequest    
//            Returns the result message from the registered Authentication 
//            Reset Component. In some cases, this message may be overridden 
//            or augmented by the IT administrator. If the component does not 
//            provide a result message, pOutBuffer will be an empty string.    
// 
//    pInData 
//        [in, optional] Pointer to input data. The type and meaning of this 
//        data depends on dwValueId. May be NULL.
//    cbInData 
//        [in] Size of the input data in bytes. Ignored if pInData is NULL.
//    pOutBuffer 
//        [out] Pointer to a buffer that receives the value associated with 
//        dwValueId. The type and meaning of this buffer depend on dwValueId. 
//        If pOutBuffer is NULL, this function returns ERROR_SUCCESS and stores 
//        the size of the value, in bytes, in the variable pointed to by 
//        pcbOutBuffer. This enables an application to determine the best way 
//        to allocate a buffer for the value's data.
//    pcbOutBuffer 
//        [in, out] Pointer to a variable that specifies the size of the buffer 
//        pointed to by the pOutBuffer parameter, in bytes. When the function 
//        returns, this variable contains the size of the data copied to 
//        pOutBuffer, including any terminating null characters. 
//        If the value is a string, this size includes any terminating null 
//        character or characters. 
//        If the buffer specified pOutBuffer is not large enough to hold the 
//        data, the function returns ERROR_MORE_DATA and stores the required 
//        buffer size in the variable pointed to by pcbOutBuffer. In this case, 
//        the contents of pOutBuffer are undefined.
//
// Return Values
//    If the function succeeds, the return value must be ERROR_SUCCESS.
//    If the function fails, the return value must be a nonzero error code 
//    defined in Winerror.h. The following table shows common error codes:
// 
//    Value                       Description
//    ------------------------------------------------------------------------
//    ERROR_INVALID_PARAMETER     One of the parameters contains an invalid 
//                                value. pInData may be the wrong size for the 
//                                data input required by dwValueId.
//    ERROR_MORE_DATA             The buffer specified by the pOutbuffer 
//                                parameter is not large enough to hold the 
//                                returned data.
//    ERROR_UNKNOWN_PROPERTY      The dwValueId parameter is not a valid option.
// 
// Remarks
//    Authentication Reset Components can expose additional values for use by 
//    specific LAPs (especially in the case that the LAP and Authentication 
//    Reset Components are developed by the same party). If the LAP does not 
//    The default Windows Mobile Authentication Reset Component attempts to 
//    load strings from the registry. This allows IT administrators to override 
//    the default messages provided. Other Authentication Reset Components may 
//    provide similar functionality.
// 
LONG ARCGetValue(DWORD dwValueId, __in_bcount_opt(cbInData) PVOID pInData, DWORD cbInData, 
                 __out_bcount_part_opt(*pcbOutBuffer, *pcbOutBuffer) PVOID pOutBuffer, __inout DWORD* pcbOutBuffer);
//
// End Authentication Reset APIs
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// SHSetImeMode
//
//   This function will pass the SHIME_MODE value to IME if it is present.
//   Or it will pass this SHIME_MODE info to keyboard driver if the IME is disabled. 
//
// Parameters:
//  hWnd
//   [in] Handle to the window whose IME  mode is to be changed.
//        If the window handle is NULL then only keyboard driver will be notified.
//  nMode
//   [in] It is one of SHIME_MODE values.
//
// Return value:
//  S_OK means succeeded, otherwise means failure.
//
HRESULT SHSetImeMode(HWND hWnd, SHIME_MODE nMode);


//////////////////////////////////////////////////////////////////////////////
//
// SHGetImeMode
//
//   This function will get the SHIME_MODE value from IME if it is present.
//   Otherwise, it will try to get SHIME_MODE from keyboard driver.
//
// Parameters:
//  hWnd
//   [in] Handle to the window whose IME  mode is to be queried.
//        If the window handle is NULL then only keyboard driver's IME mode
//        will be queried.
// pnMode
//   [out] A pointer to a DWORD to receive the SHIME_MODE value.
//
// Return value:
//  S_OK means succeeded, otherwise means failure.
//
HRESULT SHGetImeMode(HWND hWnd, SHIME_MODE* pnMode);

// Structure used to set/get information when associating a menu item with a 
// softkey button. See SHSetAssignedMenuItem and SHGetAssignedMenuItem.
typedef struct tagSHAMI
{
    UINT    cbSize;         // Size of the SHAMI structure, in bytes.
    DWORD   dwFlags;        // Optional SHAMIF_* flags.
    LPTSTR  pszAltLabel;    // Softkey button label (if label is different from associated menu item).
    UINT    cchAltLabel;    // Softkey button label buffer size (including NULL).
}   SHAMI, *LPSHAMI;    

// The menu item to be assigned to the softkey button does not currently exist in the menu. 
// The softkey parent window can add the menu item to the menu upon receiving WM_INITMENUPOPUP otherwise 
// the menu item will be added to the menu automatically at a position that corresponds to the assigned softkey index.
// Note: uFlags must be set to MF_BYCOMMAND when this flag is used in conjunction with SHSetAssignedMenuItem.
#define SHAMIF_ADDMENUITEMONPOPUP 0x0001 

// Action menu item ID.
#define MIID_ACTION 0xFFFE 

//////////////////////////////////////////////////////////////////////////////
//
// SHSetAssignedMenuItem
//
//   Set a menu item to be assigned to the menu bar.
//
//   If softkeys exist they will display the associated menu item.
//
// Parameters:
//    hwndMB
//        [in] Window handle to the menu bar.
//    hMenu
//        [in] Handle to the menu that contains the menu item. If NULL no menu 
//        item is assigned to the specified softkey.
//    uItem
//        [in] Specifies the menu item to be assigned, as determined by the 
//        uFlags parameter. Ignored if hMenu is NULL.
//  
//        Note: The menu item cannot be a separator, have an associated popup 
//        menu or be owner drawn.
//    uFlags
//        [in] Specifies how the uItem parameter is interpreted. Ignored if 
//        hMenu is NULL. This parameter must be one of the following values:
//
//        MF_BYCOMMAND 
//            Indicates that uItem gives the identifier of the
//            menu item. The MF_BYCOMMAND flag is the default flag if neither 
//            the MF_BYCOMMAND nor MF_BYPOSITION flag is specified. 
//        MF_BYPOSITION 
//            Indicates that uItem gives the zero-based 
//            relative position of the menu item. 
//
//    uAssignedIndex 
//        [in] Index of the softkey that will display the menu item.
//
//         Note: This value should be less than the maximum number of softkey
//         buttons. See the SN_MAXMENUBARBUTTONS_VALUE state. Otherwise 
//         S_FALSE is returned.
//
//    lpshami
//        [out] Optional. Pointer to a SHAMI structure that contains information
//        about the menu item assignment.
//
//    Return value:
//        S_OK indicates success; otherwise, returns a failure code.
//
HRESULT SHSetAssignedMenuItem(HWND hwndMB, HMENU hMenu, UINT uItem, UINT uFlags, UINT uAssignedIndex, LPSHAMI lpshami);

//////////////////////////////////////////////////////////////////////////////
//
// SHGetAssignedMenuItem
//
//   Get the menu item assigned to the menu bar.
//
// Parameters:
//    hwndMB
//        [in] Window handle to the menu bar.
//    phMenu
//        [out] Handle to the menu that contains the menu item assigned to the
//        menu bar is returned or NULL if no menu item has been assigned.
//    puItem
//        [out] The menu item assigned to the menu bar as determined by the 
//        uFlags parameter or -1 if no menu has been assigned to the softkey.
//    uFlags
//        [in] Specifies how the uItem parameter is interpreted.  
//        This parameter must be one of the following values:
//
//        MF_BYCOMMAND 
//            Indicates that puItem will point to the identifier of the
//            menu item. The MF_BYCOMMAND flag is the default flag if neither 
//            the MF_BYCOMMAND nor MF_BYPOSITION flag is specified. 
//        MF_BYPOSITION 
//            Indicates that puItem will point to the zero-based 
//            relative position of the menu item. 
//
//    uAssignedIndex 
//        [in] Index of the softkey to retrieve info from.
//
//         Note: This value should be less than the maximum number of softkey
//         buttons. See the SN_MAXMENUBARBUTTONS_VALUE state. Otherwise 
//         S_FALSE is returned.
//
//    lpshami
//        [out] Optional. Pointer to a SHAMI structure that receives information
//        about the menu item assignment.
//
//    Return value:
//        S_OK indicates success; otherwise, returns a failure code.
//
HRESULT SHGetAssignedMenuItem(HWND hwndMB, HMENU* phMenu, UINT* puItem, UINT uFlags, UINT uAssignedIndex, LPSHAMI lpshami);

//////////////////////////////////////////////////////////////////////////////
//
// SHActionChanged
//
//   Notify the shell that the specified window's action text has changed.
//
// Parameters:
//    hwnd
//        [in] Handle of the window whose action text has changed.
//
//    Return value:
//        S_OK indicates success; otherwise, returns a failure code.
//
HRESULT SHActionChanged(HWND hwnd);


///~~~~~~~~~~~~
///
///  GetDeviceFeatureLevel
///

/// The infrared support level of device. Below is the list of return value of pdwFeatureLevel.
/// 
/// DFL_NOINFRARED - The device doesn't include infrared capability.
/// DFL_INFRARED - The device includes infrared capability.
/// 
#define DFLI_INFRARED           0xc0020002
#define DFL_NOINFRARED          0
#define DFL_INFRARED            1

/// The vibration support level of device. Below is the list of return value of pdwFeatureLevel.
/// 
/// DFL_NOVIBRATION - The device doesn't include vibration capability.
/// DFL_VIBRATION - The device includes vibration capability.
///
#define DFLI_VIBRATION          0xc0020003
#define DFL_NOVIBRATION         0
#define DFL_VIBRATION           1

/// Telephone capbilities support level.
/// 
/// DFL_NOPHONE - The device does not include telephone capabilities.
/// DFL_PHONE - The device includes telephone capabilities.
/// DFL_PHONE_LOCKFACILITY - The device supports locking one or more of the installed telephone services.
/// DFL_PHONE_INTLPLUS - Indicates that the phone UI will generate a '+' when the user presses and holds '0'.
/// DFL_PHONE_SUPPORTSPEAKPHONE - The device supports a speakerphone mode while in a call.
/// 
#define DFLI_PHONE                          0xc0020005
#define DFL_NOPHONE                         0x00000000
#define DFL_PHONE                           0x00000001
#define DFL_PHONE_LOCKFACILITY              0x00000008
#define DFL_PHONE_INTLPLUS                  0x00000100
#define DFL_PHONE_SUPPORTSPEAKERPHONE       0x00020000

/// The Bluetooth support level. Below is the list of return value of pdwFeatureLevel.
/// 
/// DFL_NOBTH - The device doesn't include Bluetooth capability.
/// DFL_BTH - The device includes Bluetooth capability.
/// DFL_BTH_CONNECTABLE - The Bluetooth state is set to connectable.
/// DFL_BTH_DISCOVERABLE - The Bluetooth state is set to discoverable.
/// 
#define CONNECT_MODE_SHIFT      1

#define DFLI_BTH                0xc0020006
#define DFL_NOBTH               0x00
#define DFL_BTH                 0x01
#define DFL_BTH_CONNECTABLE     BTH_CONNECTABLE << CONNECT_MODE_SHIFT
#define DFL_BTH_DISCOVERABLE    BTH_DISCOVERABLE << CONNECT_MODE_SHIFT

/// The Bluetooth hands free support level. Below is the list of return value of pdwFeatureLevel.
/// 
/// DFL_NOHANDSFREE - The device doesn't include hands free capability.
/// DFL_HANDSFREE - The device include hands free capability.
/// 
#define DFLI_BTH_HANDSFREE      0xc002000B
#define DFL_NOHANDSFREE         0
#define DFL_HANDSFREE           1

/// The sound recording support level. Below is the list of return value of pdwFeatureLevel.
/// 
/// DFL_NOSOUND_RECORDING - The device doesn't include sound recording capability.
/// DFL_SOUND_RECORDING - The device includes sound recording capability.
/// 
#define DFLI_SOUND_RECORDING    0xc0020016
#define DFL_NOSOUND_RECORDING   0
#define DFL_SOUND_RECORDING     1

/// CONTACT FIELDS SUPPORTED BY THE CURRENT SIM.
/// Bits 0-7 are a value indicating the number of email addresses 
/// supported per contact. 
/// Bits 8-15 are a value indicating the number of additional phone 
/// numbers supported per contact.
/// Bits 16-19 are a value indicating the number of USIM groups 
/// supported.
/// Bits 20-27 are a value indicating the number of additional number 
/// tags supported.
/// Bit 28 is unused.
/// Bit 29 indicates if the hidden flag is supported.
/// Bit 30 indicates that the additional name is supported.
/// Bit 31, the most significant bit, indicates that the default name and 
/// number are supported. This will only be FALSE if there is no SIM 
/// support, or the device has never been booted with a SIM, or the SIM 
/// really has no phonebook support at all.
/// 
/// If you boot with no SIM you'll get the capabilities from the 
/// previous boot that did have a SIM.
/// 
#define DFLI_SIMCTS_CONTACTSFIELDS          0xc0020017
#define DFL_SIMCTS_EMAILCOUNT               0x000000FF
#define DFL_SIMCTS_ADDNLNUMBERCOUNT         0x0000FF00
#define DFL_SIMCTS_GROUPCOUNT               0x000F0000
#define DFL_SIMCTS_PHONENUMBERTAGS          0x0FF00000
#define DFL_SIMCTS_HIDDENFLAG               0x20000000
#define DFL_SIMCTS_SECONDNAME               0x40000000
#define DFL_SIMCTS_BASE                     0x80000000



/// The hardware keyboard support level. Below is the list of return value of pdwFeatureLevel. 
/// 
/// DFL_NOKEYBOARD - The device doesn't include hardware keyboard.
/// DFL_QWERTYKBD - The device includes QWERTY keyboard.
/// DFL_12KEYPAD - The device includes 12 keys keypad.
/// 
#define DFLI_KEYBOARD           0xc002001A
#define DFL_NOKEYBOARD          0
#define DFL_QWERTYKBD           1
#define DFL_12KEYPAD            2

/// The soft key support level.
/// 
/// The return value of pdwFeatureLevel is the number of hardware buttons
/// corresponding to software buttons in menu bar.
/// 
#define DFLI_SOFTKEYS           0xc002001B


HRESULT GetDeviceFeatureLevel(DWORD dwIndex, DWORD *pdwFeatureLevel);


//
//  end GetDeviceFeatureLevel
//
//~~~~~~~~~~~~

/// Possible status display modes
#define STATUS_DISPLAY_MODE_STANDARD              0
#define STATUS_DISPLAY_MODE_STANDARD_BLUETOOTH    1
#define STATUS_DISPLAY_MODE_EXTENDED              2

/// <summary>
/// Sets the display mode for the system's title bar
/// </summary>
/// <param name="hwndRequester">
///     Handle to the top-level window requesting the status display mode
/// </param>
/// <param name="dwMode">
///     The mode the status display should be in
/// </param>
/// <returns>
///     E_INVALIDARG if dwMode is an invalid value.
///     Otherwise, the result of changing the status mode.
/// </returns>
/// <remarks>
///
///     STATUS_DISPLAY_MODE_STANDARD will cause the title bar to display a
///     minimal set of icons.
///
///     STATUS_DISPLAY_MODE_STANDARD_BLUETOOTH will cause the title bar to
///     display a minimal set of icons, but will include the bluetooth icon
///
///     STATUS_DISPLAY_MODE_EXTENDED will cause the title bar to display
///     many status icons. This will cut down on the available room to display
///     text in the titlebar.
/// </remarks>
HRESULT WINAPI SetStatusDisplayMode(HWND hwndRequester, DWORD dwMode);


/// <summary>
///   Opens the specified control panel settings.
/// </summary>
/// <param name="pszCpl">
///   [in] Control panel to open. This must be one of the following:
///   <list type="table">
///     <listheader>
///       <term>Value</term>
///       <description>Description</description>
///     </listheader>
///     <item>
///       <term>NULL or empty string</term>
///       <description>
///         Opens the control panel task list.
///       </description>
///     </item>
///     <item>
///       <term>GUID String</term>
///       <description>
///         Unique identifier of a control panel to open.
///         Example: {7EC037F2-1D6A-4f4b-9415-6494CF1D480A}
///       </description>
///     </item>
///     <item>
///       <term>Canonical Name</term>
///       <description>
///         Canonical name of a control panel to open. Case is ignored.
///         Example: Microsoft.DateTime
///       </description>
///     </item>
///   </list>
/// </param>
/// <returns>
///   HRESULT. S_OK if the control panel application was launched.
/// </returns>
/// <remarks>
///   <para>
///     The control panel is opened in a separate process. This function
///     returns immediately and does not provide any useful information
///     about the state of the control panel.
///   </para>
/// </remarks>
HRESULT LaunchCpl(__in_opt LPCTSTR pszCpl);


//////////////////////////////////////////////////////////////////////////////
//
// StartMenuOpen
//
//   Displays the Start Menu, optionally opening a subfolder within the Start Menu.
//
// Parameters:
//   lpszFolder
//     [in] A pointer to a null-terminated string that specifies the relative 
//     path of a subfolder from the Start Menu folder. Absolute path is not 
//     supported. For the exact path of the Start Menu folder, see 
//     SHGetSpecialFolderPath for CSIDL_STARTMENU. The length of this string 
//     concatenated with the length of the Start Menu path is limited to 
//     MAX_PATH characters.
//     Passing NULL opens the Start Menu at the root of the 
//     Start Menu folder.  This is the same behavior as if a user 
//     manually presses "Start".
// 
// Returns: 
//   HRESULT. Returns S_OK if successful; otherwise returns an error code.
//   The following table shows the return values for this function.
//   Value                       Description
//   ------------------------------------------------------------------------
//   S_OK                        The parameter is valid and the system is 
//                               attempting to open the Start Menu.
//   E_INVALIDARG                The supplied path is invalid.
//   HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) The path was not found.
//
// Remarks:
//   When the user presses "Back", the Start Menu functions the same as when 
//   the user uses the Start Menu normally. For example, if the Start Menu
//   is displaying the "Games" folder and the user presses "Back", the 
//   contents of the parent folder are shown.
//   Example usage: 
//     StartMenuOpen(TEXT("Games"));
//   This will show contents of the Games folder in the Start Menu, 
//   if it exists.
//
HRESULT StartMenuOpen(__in_opt LPCTSTR lpszFolder);



/// <summary>
///    Used to update the text of a popup window and, if this is the foreground
///    window, to have the change be reflected in the titlebar
/// </summary>
/// <param name="hwnd">
///    Handle to the window whose text is to be changed
/// </param>
/// <param name="pszString">
///     Pointer to a null-terminated string to be used as the new  
/// </param>
/// <returns>
///     HRESULT.
/// </returns>
HRESULT SHSetPopupWindowText(HWND hwnd, __in_opt LPCTSTR pszString);

#ifdef __cplusplus
}
#endif

#endif // __AYGSHELL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\bldver.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name: bldver.h

--*/

#ifndef _BLDVER_H_
#define _BLDVER_H_

#define CE_MAJOR_VER      0x0007
#define CE_MINOR_VER      0x0000    // Minor version is in hundredths

#define CE_BUILD_VER      2398
#define CE_BUILD_SYSVER   2398

#endif // _BLDVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\basesearchobj.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#include <searchobj.h>

///<topic name="basesearchobj" displayname="Search Object Base Implementations">
///  <summary>
///    We provide base implementations for the interfaces that we expect data
///    providers to implement, so that data providers that only want to provide the
///    bare minimum of functionality can inherit from them and override only a
///    small set of methods.
///  </summary>
///  <doc_scope tref="datamodel" visibility="sdk"/>
///</topic>

///<doc_scope tref="basesearchobj" visibility="sdk">

#ifndef SAFERELEASE
#define SAFERELEASE(p) {if (p) {(p)->Release(); p = NULL;}}
#endif

#ifndef SAFECAST
#define SAFECAST(p, c)  (static_cast<c> (p))
#endif

#ifndef OBJCALL
#define OBJCALL(Object,Function) \
                ((NULL != (Object)) ? \
                  (Object)->Function : \
                  E_FAIL)
#endif



__inline HRESULT ReturnFalseHelper(BOOL *pfRet, BOOL fOtherParamCheckPassed)
{
    HRESULT hr = S_OK;

    if ((NULL == pfRet) || !fOtherParamCheckPassed)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pfRet = FALSE;
    }
    
    return hr;
}

// Many parameters are not referenced in these base objects because
// several interface methods are left unimplemented.
#pragma warning(disable : 4100)     // 4100 = Unreferenced Parameter

class CEventWrapper
{
private:
    IEvent *m_pEvent;

public:
    ///////////////////////////////////////
    // Constructors
    CEventWrapper()
    {
        m_pEvent = NULL;
    }

    ~CEventWrapper()
    {
        SAFERELEASE(m_pEvent);
    }

    ///////////////////////////////////////
    // To support change notification events
    HRESULT GetEvent(__deref_out IEvent **ppEvent)
    {
        HRESULT hr = S_OK;

        if (NULL == ppEvent)
        {
            hr = E_INVALIDARG;
            goto Error;
        }

        if (NULL == m_pEvent)
        {
            hr = MulticastEvent_CreateInstance(&m_pEvent);
            if (FAILED(hr))
            {
                goto Error;
            }
        }

        *ppEvent = m_pEvent;
        // One reference for this object to keep and another one to give to caller
        (*ppEvent)->AddRef();

    Error:
        return hr;
    }
    
    HRESULT SendItemAdded(UINT iItem, IUnknown *punkSender)
    {
        VLISTEVENTPARAMS vlevtParams = {iItem, 0};
        BLOB blobParams = {sizeof(vlevtParams), (BYTE*)&vlevtParams};
        HRESULT hr = S_OK;

        // No failure reported if there is nobody registered to receive event
        if (m_pEvent)
        {
            hr = m_pEvent->Invoke(VLISTEVENT_ITEMADDED, punkSender, &blobParams);
        }
        
        return hr;
    }

    HRESULT SendItemChanged(UINT iItem, IUnknown *punkSender)
    {
        VLISTEVENTPARAMS vlevtParams = {iItem, 0};
        BLOB blobParams = {sizeof(vlevtParams), (BYTE*)&vlevtParams};
        HRESULT hr = S_OK;

        // No failure reported if there is nobody registered to receive event
        if (m_pEvent)
        {
            hr = m_pEvent->Invoke(VLISTEVENT_ITEMCHANGED, punkSender, &blobParams);
        }
        
        return hr;
    }

    HRESULT SendItemDeleted(UINT iItem, IUnknown *punkSender)
    {
        VLISTEVENTPARAMS vlevtParams = {iItem, 0};
        BLOB blobParams = {sizeof(vlevtParams), (BYTE*)&vlevtParams};
        HRESULT hr = S_OK;

        // No failure reported if there is nobody registered to receive event
        if (m_pEvent)
        {
            hr = m_pEvent->Invoke(VLISTEVENT_ITEMDELETED, punkSender, &blobParams);
        }
        
        return hr;
    }

    HRESULT SendItemMoved(UINT iItemNew, UINT iItemOld, IUnknown *punkSender)
    {
        VLISTEVENTPARAMS vlevtParams = {iItemNew, iItemOld};
        BLOB blobParams = {sizeof(vlevtParams), (BYTE*)&vlevtParams};
        HRESULT hr = S_OK;

        // No failure reported if there is nobody registered to receive event
        if (m_pEvent)
        {
            hr = m_pEvent->Invoke(VLISTEVENT_ITEMMOVED, punkSender, &blobParams);
        }
        
        return hr;
    }

    HRESULT SendReset(UINT cItemsNew, UINT cItemsOld, UINT iFirstAffected, UINT cItemsAffected, IUnknown *punkSender)
    {
        RESETEVENTPARAMS resetParams = {cItemsNew, cItemsOld, iFirstAffected, cItemsAffected};
        BLOB blobParams = {sizeof(resetParams), (BYTE*)&resetParams};
        HRESULT hr = S_OK;

        // No failure reported if there is nobody registered to receive event
        if (m_pEvent)
        {
            hr = m_pEvent->Invoke(VLISTEVENT_RESET, punkSender, &blobParams);
        }
        
        return hr;
    }

    HRESULT SendResetAllItems(IUnknown *punkSender)
    {
        HRESULT hr = S_OK;

        // No failure reported if there is nobody registered to receive event
        if (m_pEvent)
        {
            hr = m_pEvent->Invoke(VLISTEVENT_RESET, punkSender, NULL);
        }
        
        return hr;
    }

    HRESULT Invoke(LONG nEventCode, __in const BLOB *pParams, IUnknown *punkSender)
    {
        HRESULT hr = S_OK;

        // No failure reported if there is nobody registered to receive event
        if (m_pEvent)
        {
            hr = m_pEvent->Invoke(nEventCode, punkSender, pParams);
        }
        
        return hr;
    }
};

class SchedulerWrapper
{
private:
    ISupplierThreadWorkerScheduler *m_pScheduler;

public:
    ///////////////////////////////////////
    // Constructors
    SchedulerWrapper()
    {
        m_pScheduler = NULL;
    }

    ~SchedulerWrapper()
    {
        SAFERELEASE(m_pScheduler);
    }

    HRESULT SetThreadWorkerScheduler(__in ISupplierThreadWorkerScheduler *pScheduler)
    {
        HRESULT hr = S_OK;

        SAFERELEASE(m_pScheduler);

        if (NULL != pScheduler)
        {
            pScheduler->AddRef();
        }
        m_pScheduler = pScheduler;
        
        return hr;
    }

    HRESULT ScheduleThreadWorker(__in ISupplierThreadWorker *pWorker, __in REFGUID guidRequest)
    {
        HRESULT hr = S_OK;

        // No failure reported if there is nobody registered to receive event
        if (m_pScheduler)
        {
            hr = m_pScheduler->ScheduleThreadWorker(pWorker, guidRequest);
        }
        else
        {
            hr = E_FAIL;
        }
        
        return hr;
    }
};

// Base implementation of IItemSupplier to be used by suppliers
// that don't care to support the features that are not strictly necessary
class CBaseCoreSupplier : public IItemSupplier
{
protected:
    LONG m_cRef;
    CEventWrapper m_eventwrapper;
    SchedulerWrapper m_schedulerwrapper;

    virtual ~CBaseCoreSupplier()
    {
    }


private:
    __inline void Initialize(BOOL fAddRef)
    {
        m_cRef = 0;

        if (fAddRef)
        {
            AddRef();
        }
    }
    
public:
    ////////////////////////
    // Constructors
    
    CBaseCoreSupplier()
    {
        Initialize(TRUE);
    }

    CBaseCoreSupplier(BOOL fAddRef)
    {
        // Allow code pattern where ref count starts as zero and factory immediately calls
        // QueryInterface on us.
        Initialize(fAddRef);
    }

    /////////////////////////
    // IUnknown members
    
    virtual STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual STDMETHODIMP_(ULONG) Release()
    {
        ULONG cRef = InterlockedDecrement(&m_cRef);
        if (0 == cRef)
        {
            delete this;
        }

        return cRef;
    }

    virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject)
    {
        if (NULL == ppvObject)
            return E_INVALIDARG;

        *ppvObject = NULL;

        if (IID_IUnknown == riid)
        {
            *ppvObject = SAFECAST(this, IUnknown *);
        }
        else if (IID_IItemSupplier == riid)
        {
            *ppvObject = SAFECAST(this, IItemSupplier *);
        }

        if (NULL != *ppvObject)
        {
            (SAFECAST(*ppvObject, IUnknown *))->AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    ///////////////////////////////////
    // IItemSupplier members
    
    virtual STDMETHODIMP GetCount(__out UINT *pcItems) = 0;

    virtual STDMETHODIMP GetItem(UINT iItem, __deref_out ICategorizedVirtualItem **ppviItem) = 0;

    virtual STDMETHODIMP CacheItemsHint(UINT iFirstItem,
                                        UINT cItems,
                                        __in_ecount(cPropertyIDs) const DWORD *rgdwPropertyIDs,
                                        UINT cPropertyIDs)
    {
        return E_NOTIMPL;
    }

    virtual void STDMETHODCALLTYPE Lock() = 0;

    virtual void STDMETHODCALLTYPE Unlock() = 0;

    virtual STDMETHODIMP GetProperty(DWORD dwListPropertyID,
                                     __out PROPVARIANT *pListPropertyValue)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP GetSupportedSortCount(__out UINT *pcSort)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP GetSupportedSortPropertyID(UINT iSortProperty,
                                                    __out DWORD *pdwSortPropertyID)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP GetSupportedSortDirection(UINT iSortProperty,
                                                   __out LISTSORTDIRECTION *plsdir)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP SetThreadWorkerScheduler(__in ISupplierThreadWorkerScheduler *pScheduler)
    {
        return m_schedulerwrapper.SetThreadWorkerScheduler(pScheduler);
    }

    virtual STDMETHODIMP ApplySort(DWORD dwPropertyID,
                                   LISTSORTDIRECTION lsdir)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP RemoveSort()
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP SetFilterString(__in LPCOLESTR pszFilter)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP GetVerbSource(__deref_out IVerbSource **ppVerbSource)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP GetChangeNotificationEvent(__deref_out IEvent **ppEvent)
    {
        return m_eventwrapper.GetEvent(ppEvent);
    }

    ///////////////////////////////////
    // Helpers for triggering notifications
    
    virtual HRESULT SendItemAdded(UINT iItem)
    {
        return m_eventwrapper.SendItemAdded(iItem, this);
    }

    virtual HRESULT SendItemChanged(UINT iItem)
    {
        return m_eventwrapper.SendItemChanged(iItem, this);
    }

    virtual HRESULT SendItemDeleted(UINT iItem)
    {
        return m_eventwrapper.SendItemDeleted(iItem, this);
    }

    virtual HRESULT SendItemMoved(UINT iItemNew, UINT iItemOld)
    {
        return m_eventwrapper.SendItemMoved(iItemNew, iItemOld, this);
    }

    virtual HRESULT SendReset(UINT cItemsNew, UINT cItemsOld, UINT iFirstAffected, UINT cItemsAffected)
    {
        return m_eventwrapper.SendReset(cItemsNew, cItemsOld, iFirstAffected, cItemsAffected, this);
    }

    virtual HRESULT SendResetAllItems()
    {
        return m_eventwrapper.SendResetAllItems(this);
    }

    virtual HRESULT SendEvent(LONG nEventCode, __in const BLOB *pParams)
    {
        return m_eventwrapper.Invoke(nEventCode, pParams, this);
    }

    ///<summary>
    ///  Requests the thread worker scheduler to schedule a new worker thread.
    ///</summary>
    ///<param name="pWorker">
    ///  [in] Thread worker that should be scheduled
    ///</param>
    ///<param name="guidRequest">
    ///  [in] Unique identifier that represents the scheduling request. A request
    ///  with the same GUID as a request currently being serviced will replace
    ///  that request, and a request with a GUID that is not associated with a
    ///  currently active request will be serviced in parallel with it.
    ///</param>
    ///<returns>
    ///  <para>
    ///    S_OK if successful
    ///  </para>
    ///  <para>
    ///    Unspecified failure condition otherwise
    ///  </para>
    ///</returns>
    ///<remarks>
    ///  <para>
    ///    Work done by <see cref="ISupplierThreadWorker"/> objects identified
    ///    by different GUIDs should be orthogonal, so that different thread
    ///    workers don't step on each other's toes
    ///  </para>
    ///  <para>
    ///    Suppliers that know that they want all thread work requests coming from
    ///    them to replace any previous requests sent will can just use
    ///    GUID_THREADWORKREQUEST_DEFAULT to identify all of their requests,
    ///    instead of declaring new GUIDs.
    ///  </para>
    ///</remarks>
    virtual HRESULT RequestThreadWorkerScheduling(__in ISupplierThreadWorker *pWorker, __in REFGUID guidRequest)
    {
        return m_schedulerwrapper.ScheduleThreadWorker(pWorker, guidRequest);
    }
};


// Base implementation of ISearchSupplier to be used by suppliers
// that don't care to support the features that are not strictly necessary
class CBaseRestrictableSupplier :
    public IRestrictableItemSupplier
{   
protected:
    LONG m_cRef;
    CEventWrapper m_eventwrapper;
    SchedulerWrapper m_schedulerwrapper;

    virtual ~CBaseRestrictableSupplier()
    {
    }

private:
    __inline void Initialize(BOOL fAddRef)
    {
        m_cRef = 0;

        if (fAddRef)
        {
            AddRef();
        }

    }
    
public:
    ////////////////////////
    // Constructors
    CBaseRestrictableSupplier()
    {
        Initialize(TRUE);
    }

    CBaseRestrictableSupplier(BOOL fAddRef)
    {
        // Allow code pattern where ref count starts as zero and factory immediately calls
        // QueryInterface on us.
        Initialize(fAddRef);
    }

    /////////////////////////
    // IUnknown members

    virtual STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual STDMETHODIMP_(ULONG) Release()
    {
        ULONG cRef = InterlockedDecrement(&m_cRef);
        if (0 == cRef)
        {
            delete this;
        }

        return cRef;
    }

    virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject)
    {
        if (NULL == ppvObject)
            return E_INVALIDARG;

        *ppvObject = NULL;

        if (IID_IUnknown == riid)
        {
            *ppvObject = SAFECAST(this, IUnknown*);
        }
        else if (IID_IItemSupplier == riid)
        {
            *ppvObject = SAFECAST(this, IItemSupplier *);
        }
        else if (IID_IRestrictableItemSupplier == riid)
        {
            *ppvObject = SAFECAST(this, IRestrictableItemSupplier *);
        }

        if (NULL != *ppvObject)
        {
            (SAFECAST(*ppvObject, IUnknown *))->AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    ///////////////////////////////////
    // IItemSupplier members
    
    virtual STDMETHODIMP GetCount(__out UINT *pcItems) = 0;

    virtual STDMETHODIMP GetItem(UINT iItem, __deref_out ICategorizedVirtualItem **ppviItem) = 0;

    virtual STDMETHODIMP CacheItemsHint(UINT iFirstItem,
                                        UINT cItems,
                                        __in_ecount(cPropertyIDs) const DWORD *rgdwPropertyIDs,
                                        UINT cPropertyIDs)
    {
        return E_NOTIMPL;
    }

    virtual void STDMETHODCALLTYPE Lock() = 0;

    virtual void STDMETHODCALLTYPE Unlock() = 0;

    virtual STDMETHODIMP GetProperty(DWORD dwListPropertyID,
                                     __out PROPVARIANT *pListPropertyValue)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP GetSupportedSortCount(__out UINT *pcSort)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP GetSupportedSortPropertyID(UINT iSortProperty,
                                                    __out DWORD *pdwSortPropertyID)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP GetSupportedSortDirection(UINT iSortProperty,
                                                   __out LISTSORTDIRECTION *plsdir)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP ApplySort(DWORD dwPropertyID,
                                   LISTSORTDIRECTION lsdir)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP SetThreadWorkerScheduler(__in ISupplierThreadWorkerScheduler *pScheduler)
    {
        return m_schedulerwrapper.SetThreadWorkerScheduler(pScheduler);
    }

    virtual STDMETHODIMP RemoveSort()
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP SetFilterString(__in LPCOLESTR pszFilter)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP GetVerbSource(__deref_out IVerbSource **ppVerbSource)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP GetChangeNotificationEvent(__deref_out IEvent **ppEvent)
    {
        return m_eventwrapper.GetEvent(ppEvent);
    }

    ///////////////////////////////////
    // IRestrictableItemSupplier members
    virtual STDMETHODIMP SetResultTemplates(__in_ecount(cTemplates) IItemTemplate **rgpTemplates,
                                            UINT cTemplates)
    {
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP SetRelatedItem(__in ICategorizedVirtualItem *pRelatedItem)
    {
        return E_NOTIMPL;
    }

    ///////////////////////////////////
    // Helpers for triggering notifications
    
    virtual HRESULT SendItemAdded(UINT iItem)
    {
        return m_eventwrapper.SendItemAdded(iItem, this);
    }

    virtual HRESULT SendItemChanged(UINT iItem)
    {
        return m_eventwrapper.SendItemChanged(iItem, this);
    }

    virtual HRESULT SendItemDeleted(UINT iItem)
    {
        return m_eventwrapper.SendItemDeleted(iItem, this);
    }

    virtual HRESULT SendItemMoved(UINT iItemNew, UINT iItemOld)
    {
        return m_eventwrapper.SendItemMoved(iItemNew, iItemOld, this);
    }

    virtual HRESULT SendReset(UINT cItemsNew, UINT cItemsOld, UINT iFirstAffected, UINT cItemsAffected)
    {
        return m_eventwrapper.SendReset(cItemsNew, cItemsOld, iFirstAffected, cItemsAffected, this);
    }

    virtual HRESULT SendResetAllItems()
    {
        return m_eventwrapper.SendResetAllItems(this);
    }

    virtual HRESULT SendEvent(LONG nEventCode, __in const BLOB *pParams)
    {
        return m_eventwrapper.Invoke(nEventCode, pParams, this);
    }

    ///<summary>
    ///  Requests the thread worker scheduler to schedule a new worker thread.
    ///</summary>
    ///<param name="pWorker">
    ///  [in] Thread worker that should be scheduled
    ///</param>
    ///<param name="guidRequest">
    ///  [in] Unique identifier that represents the scheduling request. A request
    ///  with the same GUID as a request currently being serviced will replace
    ///  that request, and a request with a GUID that is not associated with a
    ///  currently active request will be serviced in parallel with it.
    ///</param>
    ///<returns>
    ///  <para>
    ///    S_OK if successful
    ///  </para>
    ///  <para>
    ///    Unspecified failure condition otherwise
    ///  </para>
    ///</returns>
    ///<remarks>
    ///  <para>
    ///    Work done by <see cref="ISupplierThreadWorker"/> objects identified
    ///    by different GUIDs should be orthogonal, so that different thread
    ///    workers don't step on each other's toes
    ///  </para>
    ///  <para>
    ///    Suppliers that know that they want all thread work requests coming from
    ///    them to replace any previous requests sent will can just use
    ///    GUID_THREADWORKREQUEST_DEFAULT to identify all of their requests,
    ///    instead of declaring new GUIDs.
    ///  </para>
    ///</remarks>
    virtual HRESULT RequestThreadWorkerScheduling(__in ISupplierThreadWorker *pWorker, __in REFGUID guidRequest)
    {
        return m_schedulerwrapper.ScheduleThreadWorker(pWorker, guidRequest);
    }
};

// Simple base class for inspector implementations that implements IUnknown plus IsItemValid.
class CBaseInspector : public IItemInspector
{
protected:
    LONG m_cRef;

    // If fAddRef is TRUE, ref count is initialized as 1.
    // Otherwise, ref count is initialized as 0. Useful for some initialization
    // patterns that do an explicit AddRef during IClassFactory::CreateInstance.
    HRESULT Initialize(BOOL fAddRef)
    {
        HRESULT hr = S_OK;
        
        m_cRef = 0;

        if (fAddRef)
        {
            AddRef();
        }
        
        return hr;
    }
    
    // Necessary to ensure that subclass destructor gets called when ref count becomes zero
    virtual ~CBaseInspector()
    {
    }

public:
    CBaseInspector()
    {
        Initialize(TRUE);
    }

    CBaseInspector(BOOL fAddRef)
    {
        // Allow code pattern where ref count starts as zero and factory immediately calls
        // QueryInterface on us.
        Initialize(fAddRef);
    }
    
    /////////////////////////
    // IUnknown members
    
    virtual STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual STDMETHODIMP_(ULONG) Release()
    {
        ULONG cRef = InterlockedDecrement(&m_cRef);
        if (0 == cRef)
        {
            delete this;
        }

        return cRef;
    }

    virtual STDMETHODIMP QueryInterface(REFIID riid, __deref_out void ** ppvObject)
    {
        if (NULL == ppvObject)
            return E_INVALIDARG;

        *ppvObject = NULL;

        if (IID_IUnknown == riid)
        {
            *ppvObject = SAFECAST(this, IUnknown*);
        }
        else if (IID_IItemInspector == riid)
        {
            *ppvObject = SAFECAST(this, IItemInspector*);
        }

        if (NULL != *ppvObject)
        {
            ((IUnknown *)(*ppvObject))->AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    /////////////////////////
    // IItemInspector members

    virtual STDMETHODIMP IsItemValid(__in ICategorizedVirtualItem *pcviItem,
                                     __out BOOL *pfValid)
    {
        HRESULT hr = S_OK;

        if ((NULL != pcviItem) && (NULL != pfValid))
        {
            // By default mark all items as valid
            *pfValid = TRUE;
        }
        else
        {
            hr = E_INVALIDARG;
        }

        return hr;
    }

    virtual STDMETHODIMP CachePropertiesInItem(__in ICategorizedDataItem *pcdiItem,
                                               __in_ecount(cPropertyIDs) const DWORD *rgdwPropertyIDs,
                                               UINT cPropertyIDs)
    {        
        return E_NOTIMPL;
    }

    virtual STDMETHODIMP GetVerbExtension(__deref_out IVerbExtension **ppVerbExtension)
    {        
        return E_NOTIMPL;
    }
};


// Simple base class for verb source implementations that implements IUnknown methods.
class CBaseVerbSource : public IVerbSource
{
protected:
    LONG m_cRef;

    // If fAddRef is TRUE, ref count is initialized as 1.
    // Otherwise, ref count is initialized as 0. Useful for some initialization
    // patterns that do an explicit AddRef during IClassFactory::CreateInstance.
    HRESULT Initialize(BOOL fAddRef)
    {
        HRESULT hr = S_OK;
        
        m_cRef = 0;

        if (fAddRef)
        {
            AddRef();
        }
        
        return hr;
    }
    
    // Necessary to ensure that subclass destructor gets called when ref count becomes zero
    virtual ~CBaseVerbSource()
    {
    }

public:
    /////////////////////////
    // constructors
    CBaseVerbSource()
    {
        Initialize(TRUE);
    }

    CBaseVerbSource(BOOL fAddRef)
    {
        Initialize(fAddRef);
    }
    
    /////////////////////////
    // IUnknown members
    
    virtual STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual STDMETHODIMP_(ULONG) Release()
    {
        ULONG cRef = InterlockedDecrement(&m_cRef);
        if (0 == cRef)
        {
            delete this;
        }

        return cRef;
    }

    virtual STDMETHODIMP QueryInterface(REFIID riid, __deref_out void ** ppvObject)
    {
        if (NULL == ppvObject)
            return E_INVALIDARG;

        *ppvObject = NULL;

        if (IID_IUnknown == riid)
        {
            *ppvObject = SAFECAST(this, IUnknown*);
        }
        else if (IID_IVerbSource == riid)
        {
            *ppvObject = SAFECAST(this, IVerbSource*);
        }

        if (NULL != *ppvObject)
        {
            ((IUnknown *)(*ppvObject))->AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    /////////////////////////
    // IVerbSource members

    virtual STDMETHODIMP GetGroupVerbs(LPCOLESTR pszGroupName,
                                       __deref_out IVerbSnapshot **ppSnapshot) = 0;

    virtual STDMETHODIMP GetVerbsFromIDs(__in_ecount(cVerbIDs) const DWORD *rgdwVerbIDs,
                                         UINT cVerbIDs,
                                         __deref_out IVerbSnapshot **ppSnapshot) = 0;

    virtual STDMETHODIMP InvokeVerb(DWORD dwVerbID,
                                    __in_opt HWND hwndOwner,
                                    __in_opt PROPVARIANT *pVerbParam) = 0;
};

// Simple base class for verb extension implementations that implements IUnknown methods.
class CBaseVerbExtension : public IVerbExtension
{
protected:
    LONG m_cRef;

    // If fAddRef is TRUE, ref count is initialized as 1.
    // Otherwise, ref count is initialized as 0. Useful for some initialization
    // patterns that do an explicit AddRef during IClassFactory::CreateInstance.
    HRESULT Initialize(BOOL fAddRef)
    {
        HRESULT hr = S_OK;
        
        m_cRef = 0;

        if (fAddRef)
        {
            AddRef();
        }
        
        return hr;
    }
    
    // Necessary to ensure that subclass destructor gets called when ref count becomes zero
    virtual ~CBaseVerbExtension()
    {
    }

public:
    /////////////////////////
    // Constructors
    CBaseVerbExtension()
    {
        Initialize(TRUE);
    }

    CBaseVerbExtension(BOOL fAddRef)
    {
        Initialize(fAddRef);
    }
    
    /////////////////////////
    // IUnknown members
    
    virtual STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual STDMETHODIMP_(ULONG) Release()
    {
        ULONG cRef = InterlockedDecrement(&m_cRef);
        if (0 == cRef)
        {
            delete this;
        }

        return cRef;
    }

    virtual STDMETHODIMP QueryInterface(REFIID riid, __deref_out void ** ppvObject)
    {
        if (NULL == ppvObject)
            return E_INVALIDARG;

        *ppvObject = NULL;

        if (IID_IUnknown == riid)
        {
            *ppvObject = SAFECAST(this, IUnknown*);
        }
        else if (IID_IVerbSource == riid)
        {
            *ppvObject = SAFECAST(this, IVerbSource*);
        }
        else if (IID_IVerbExtension == riid)
        {
            *ppvObject = SAFECAST(this, IVerbExtension*);
        }

        if (NULL != *ppvObject)
        {
            ((IUnknown *)(*ppvObject))->AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    /////////////////////////
    // IVerbSource members

    virtual STDMETHODIMP GetGroupVerbs(LPCOLESTR pszGroupName,
                                       __deref_out IVerbSnapshot **ppSnapshot) = 0;

    virtual STDMETHODIMP GetVerbsFromIDs(__in_ecount(cVerbIDs) const DWORD *rgdwVerbIDs,
                                         UINT cVerbIDs,
                                         __deref_out IVerbSnapshot **ppSnapshot) = 0;

    virtual STDMETHODIMP InvokeVerb(DWORD dwVerbID,
                                    __in_opt HWND hwndOwner,
                                    __in_opt PROPVARIANT *pVerbParam) = 0;

    /////////////////////////
    // IVerbExtension members
    virtual STDMETHODIMP SetVerbTarget(__in_opt IUnknown *pTarget) = 0;

    virtual STDMETHODIMP GetValidVerbIDRange(__out DWORD *pdwFirstValidID,
                                             __out DWORD *pdwLastValidID) = 0;
};

///<summary>
///  This is an abstract implementation of IEventDelegate meant to be a base class
///  for concrete implementations.
///</summary>
///<remarks>
///  <para>
///    The most salient feature of this base class is that it addresses the problem
///    of circular dependencies that is common for IEventDelegate implementations.
///    E.g.: Client A has a reference to object B, who exposes an event E. A wants
///    to receive change notifications from B, so it registers its delegate, D, with
///    E. The delegate has a pointer back to A, in order to be able to do real work.
///    So, A -> B -> E -> D -> A forms a reference cycle
///  </para>
///  <para>
///    The circular reference problem is solved by having the delegate keep only a
///    weak (i.e., non-ref-counted) reference to its owner (the client object A) that
///    wants to be notified of event changes.
///  </para>
///  <para>
///    Whenever the delegate is invoked (i.e., an event calls
///    IEventDelegate::DelegateProc), CBaseEventDelegate will obtain a strong
///    reference to its owner, via a call to AddRef, call the concrete implementation
///    of _DelegateProcImpl, and then release the strong reference to the owner.
///  </para>
///  <para>
///    The owner object needs to call CBaseEventDelegate::DetachOwner whenever it gets
///    destructed so that its delegate(s) can know to avoid trying to acquire a
///    strong reference to the owner in the future.
///  </para>
///</remarks>
template <class Owner> 
class CBaseEventDelegate : public IEventDelegate
{
private:
    LONG m_cRef;
    CRITICAL_SECTION m_csOwner;
    // Owner class should have AddRef and Release functions, whether it derives
    // from IUnknown or not.
    Owner *m_pOwner;
    
protected:
    // This function must be overridden by subclasses
    virtual HRESULT _DelegateProcImpl(Owner *pOwner,
                                      LONG nEventCode,
                                      __in IUnknown *pSender,
                                      __in const BLOB *pParams) = 0;

    virtual ~CBaseEventDelegate()
    {
        DeleteCriticalSection(&m_csOwner);
    }

public:
    CBaseEventDelegate(Owner *pOwner)
    {
        m_cRef = 1;
        
        // Don't call AddRef on owner to avoid reference cycles.
        // Owner should call "CBaseEventDelegate.DetachOwner" when it is being destroyed.
        ASSERT(NULL != pOwner);
        m_pOwner = pOwner;
        InitializeCriticalSection(&m_csOwner);
    }
    
    ////////////////////////////////////////////
    // IUnknown members
    STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release()
    {
        ULONG cRef = InterlockedDecrement(&m_cRef);
        if (0 == cRef)
        {
            delete this;
        }

        return cRef;
    }

    virtual STDMETHODIMP QueryInterface(REFIID riid, __deref_out void ** ppvObject)
    {
        if (NULL == ppvObject)
            return E_INVALIDARG;

        *ppvObject = NULL;

        if (IID_IUnknown == riid)
        {
            *ppvObject = SAFECAST(this, IUnknown*);
        }
        else if (IID_IEventDelegate == riid)
        {
            *ppvObject = SAFECAST(this, IEventDelegate*);
        }

        if (NULL != *ppvObject)
        {
            ((IUnknown *)(*ppvObject))->AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }


    ///////////////////////////////////
    // IEventDelegate members
    STDMETHODIMP DelegateProc(LONG nEventCode,
                              __in IUnknown *pSender,
                              __in const BLOB *pParams)
    {
        Owner *pOwner = NULL;
        HRESULT hr = S_OK;

        EnterCriticalSection(&m_csOwner);
        // Attempt to get a strong reference to the owner object
        if (NULL != m_pOwner)
        {
            pOwner = m_pOwner;

            // If the owner's ref count was zero before we called AddRef, owner
            // object is probably in the process of being deallocated and
            // unpredictable behavior may result. Therefore, treat this case
            // as a failure to acquire strong reference.
            if (1 >= pOwner->AddRef())
            {
                // This should only happen in deallocation race conditions
                // and not in normal circumstances.
                // Investigate if this ASSERT fires with predictable repro
                // steps.
                ASSERT(0);
                pOwner = NULL;
            }
        }
        LeaveCriticalSection(&m_csOwner);

        if (NULL != pOwner)
        {
            // If we successfully obtained a strong reference to owner object,
            // proceed with event handling.
            hr = _DelegateProcImpl(pOwner, nEventCode, pSender, pParams);

            pOwner->Release();
        }

        return hr;
    }

    HRESULT DetachOwner()
    {
        EnterCriticalSection(&m_csOwner);
        // Invalidate weak reference to owner object to prevent trying to acquire
        // a strong reference in the future.
        m_pOwner = NULL;
        LeaveCriticalSection(&m_csOwner);

        return S_OK;
    }
};

///</doc_scope> basesearchobj

#pragma warning(default : 4100)     // 4100 = Unreferenced Parameter
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\basetyps.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       basetyps.h
//
//----------------------------------------------------------------------------
#if !defined( _BASETYPS_H_ )
#define _BASETYPS_H_

// Common macros gleamed from COMPOBJ.H

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef _WIN32

// Win32 doesn't support __export

#define STDMETHODCALLTYPE       __stdcall
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE




/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#if defined(__cplusplus) && !defined(CINTERFACE)
//#define interface               struct FAR
#define interface struct
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface



#else

#define interface               struct

#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)




#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif

// macros to define byte pattern for a GUID.
//      Example: DEFINE_GUID(GUID_XXX, a, b, c, ...);
//
#include <initguid.h>

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

#ifndef _ERROR_STATUS_T_DEFINED
typedef unsigned long error_status_t;
#define _ERROR_STATUS_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;
#endif /* GUID_DEFINED */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\bmedia.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for bmedia.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __bmedia_h__
#define __bmedia_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IServiceProvider_FWD_DEFINED__
#define __IServiceProvider_FWD_DEFINED__
typedef interface IServiceProvider IServiceProvider;
#endif 	/* __IServiceProvider_FWD_DEFINED__ */


#ifndef __IAsyncPProt_FWD_DEFINED__
#define __IAsyncPProt_FWD_DEFINED__
typedef interface IAsyncPProt IAsyncPProt;
#endif 	/* __IAsyncPProt_FWD_DEFINED__ */


#ifndef __IAsyncMHandler_FWD_DEFINED__
#define __IAsyncMHandler_FWD_DEFINED__
typedef interface IAsyncMHandler IAsyncMHandler;
#endif 	/* __IAsyncMHandler_FWD_DEFINED__ */


#ifndef __IDirectControl_FWD_DEFINED__
#define __IDirectControl_FWD_DEFINED__
typedef interface IDirectControl IDirectControl;
#endif 	/* __IDirectControl_FWD_DEFINED__ */


#ifndef __IDirectControlView_FWD_DEFINED__
#define __IDirectControlView_FWD_DEFINED__
typedef interface IDirectControlView IDirectControlView;
#endif 	/* __IDirectControlView_FWD_DEFINED__ */


#ifndef __IDirectContainer_FWD_DEFINED__
#define __IDirectContainer_FWD_DEFINED__
typedef interface IDirectContainer IDirectContainer;
#endif 	/* __IDirectContainer_FWD_DEFINED__ */


#ifndef __IRadioView_FWD_DEFINED__
#define __IRadioView_FWD_DEFINED__
typedef interface IRadioView IRadioView;
#endif 	/* __IRadioView_FWD_DEFINED__ */


#ifndef __IRadioPlayer_FWD_DEFINED__
#define __IRadioPlayer_FWD_DEFINED__
typedef interface IRadioPlayer IRadioPlayer;
#endif 	/* __IRadioPlayer_FWD_DEFINED__ */


#ifndef __IRadioServer_FWD_DEFINED__
#define __IRadioServer_FWD_DEFINED__
typedef interface IRadioServer IRadioServer;
#endif 	/* __IRadioServer_FWD_DEFINED__ */


#ifndef __IRadioServerControl_FWD_DEFINED__
#define __IRadioServerControl_FWD_DEFINED__
typedef interface IRadioServerControl IRadioServerControl;
#endif 	/* __IRadioServerControl_FWD_DEFINED__ */


#ifndef __IRadioBand_FWD_DEFINED__
#define __IRadioBand_FWD_DEFINED__
typedef interface IRadioBand IRadioBand;
#endif 	/* __IRadioBand_FWD_DEFINED__ */


#ifndef __IMediaBindStream_FWD_DEFINED__
#define __IMediaBindStream_FWD_DEFINED__
typedef interface IMediaBindStream IMediaBindStream;
#endif 	/* __IMediaBindStream_FWD_DEFINED__ */


#ifndef __IMediaPlayerListener_FWD_DEFINED__
#define __IMediaPlayerListener_FWD_DEFINED__
typedef interface IMediaPlayerListener IMediaPlayerListener;
#endif 	/* __IMediaPlayerListener_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_bmedia_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// ServProv.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IServiceProvider Interfaces.




extern RPC_IF_HANDLE __MIDL_itf_bmedia_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bmedia_0000_0000_v0_0_s_ifspec;

#ifndef __IServiceProvider_INTERFACE_DEFINED__
#define __IServiceProvider_INTERFACE_DEFINED__

/* interface IServiceProvider */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IServiceProvider *LPSERVICEPROVIDER;

#if (_MSC_VER >= 1100) && defined(__cplusplus) && !defined(CINTERFACE)
    EXTERN_C const IID IID_IServiceProvider;
    extern "C++"
    {
        MIDL_INTERFACE("6d5140c1-7436-11ce-8034-00aa006009fa")
        IServiceProvider : public IUnknown
        {
        public:
            virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryService( 
                /* [in] */ REFGUID guidService,
                /* [in] */ REFIID riid,
                /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
            
            template <class Q>
            HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, Q** pp)
            {
                return QueryService(guidService, __uuidof(Q), (void **)pp);
            }
        };
    }

    /* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_RemoteQueryService_Proxy( 
        IServiceProvider __RPC_FAR * This,
        /* [in] */ REFGUID guidService,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);

    void __RPC_STUB IServiceProvider_RemoteQueryService_Stub(
        IRpcStubBuffer *This,
        IRpcChannelBuffer *_pRpcChannelBuffer,
        PRPC_MESSAGE _pRpcMessage,
        DWORD *_pdwStubPhase);

#else // VC6 Hack

EXTERN_C const IID IID_IServiceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d5140c1-7436-11ce-8034-00aa006009fa")
    IServiceProvider : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceProvider * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryService )( 
            IServiceProvider * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        END_INTERFACE
    } IServiceProviderVtbl;

    interface IServiceProvider
    {
        CONST_VTBL struct IServiceProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServiceProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServiceProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServiceProvider_QueryService(This,guidService,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryService(This,guidService,riid,ppvObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_RemoteQueryService_Proxy( 
    IServiceProvider * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObject);


void __RPC_STUB IServiceProvider_RemoteQueryService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServiceProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_bmedia_0000_0001 */
/* [local] */ 

#endif // VC6 Hack


extern RPC_IF_HANDLE __MIDL_itf_bmedia_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bmedia_0000_0001_v0_0_s_ifspec;

#ifndef __IAsyncPProt_INTERFACE_DEFINED__
#define __IAsyncPProt_INTERFACE_DEFINED__

/* interface IAsyncPProt */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IAsyncPProt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3DA2AA3A-3D96-11D2-9BD2-204C4F4F5020")
    IAsyncPProt : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAsyncPProtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAsyncPProt * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAsyncPProt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAsyncPProt * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAsyncPProt * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAsyncPProt * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAsyncPProt * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAsyncPProt * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IAsyncPProtVtbl;

    interface IAsyncPProt
    {
        CONST_VTBL struct IAsyncPProtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAsyncPProt_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAsyncPProt_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAsyncPProt_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAsyncPProt_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAsyncPProt_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAsyncPProt_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAsyncPProt_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAsyncPProt_INTERFACE_DEFINED__ */


#ifndef __IAsyncMHandler_INTERFACE_DEFINED__
#define __IAsyncMHandler_INTERFACE_DEFINED__

/* interface IAsyncMHandler */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IAsyncMHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3DA2AA3D-3D96-11D2-9BD2-204C4F4F5020")
    IAsyncMHandler : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAsyncMHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAsyncMHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAsyncMHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAsyncMHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAsyncMHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAsyncMHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAsyncMHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAsyncMHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IAsyncMHandlerVtbl;

    interface IAsyncMHandler
    {
        CONST_VTBL struct IAsyncMHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAsyncMHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAsyncMHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAsyncMHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAsyncMHandler_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAsyncMHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAsyncMHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAsyncMHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAsyncMHandler_INTERFACE_DEFINED__ */


#ifndef __IDirectControl_INTERFACE_DEFINED__
#define __IDirectControl_INTERFACE_DEFINED__

/* interface IDirectControl */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IDirectControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("39A2C2A5-4778-11D2-9BDB-204C4F4F5020")
    IDirectControl : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateView( 
            BSTR bszClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyAllViews( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDirectControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDirectControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDirectControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDirectControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *CreateView )( 
            IDirectControl * This,
            BSTR bszClsid);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyAllViews )( 
            IDirectControl * This);
        
        END_INTERFACE
    } IDirectControlVtbl;

    interface IDirectControl
    {
        CONST_VTBL struct IDirectControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectControl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDirectControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDirectControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDirectControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDirectControl_CreateView(This,bszClsid)	\
    ( (This)->lpVtbl -> CreateView(This,bszClsid) ) 

#define IDirectControl_DestroyAllViews(This)	\
    ( (This)->lpVtbl -> DestroyAllViews(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectControl_INTERFACE_DEFINED__ */


#ifndef __IDirectControlView_INTERFACE_DEFINED__
#define __IDirectControlView_INTERFACE_DEFINED__

/* interface IDirectControlView */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IDirectControlView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("39A2C2FF-4778-11D2-9BDB-204C4F4F5020")
    IDirectControlView : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsTimerNeeded( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTimer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Visible( 
            VARIANT_BOOL bVisible) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFocusChange( 
            VARIANT_BOOL bFocus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectControlViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectControlView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectControlView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectControlView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDirectControlView * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDirectControlView * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDirectControlView * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDirectControlView * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *IsTimerNeeded )( 
            IDirectControlView * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnTimer )( 
            IDirectControlView * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            IDirectControlView * This,
            VARIANT_BOOL bVisible);
        
        HRESULT ( STDMETHODCALLTYPE *OnFocusChange )( 
            IDirectControlView * This,
            VARIANT_BOOL bFocus);
        
        END_INTERFACE
    } IDirectControlViewVtbl;

    interface IDirectControlView
    {
        CONST_VTBL struct IDirectControlViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectControlView_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectControlView_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectControlView_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectControlView_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDirectControlView_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDirectControlView_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDirectControlView_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDirectControlView_IsTimerNeeded(This)	\
    ( (This)->lpVtbl -> IsTimerNeeded(This) ) 

#define IDirectControlView_OnTimer(This)	\
    ( (This)->lpVtbl -> OnTimer(This) ) 

#define IDirectControlView_put_Visible(This,bVisible)	\
    ( (This)->lpVtbl -> put_Visible(This,bVisible) ) 

#define IDirectControlView_OnFocusChange(This,bFocus)	\
    ( (This)->lpVtbl -> OnFocusChange(This,bFocus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectControlView_INTERFACE_DEFINED__ */


#ifndef __IDirectContainer_INTERFACE_DEFINED__
#define __IDirectContainer_INTERFACE_DEFINED__

/* interface IDirectContainer */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDirectContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("39A2C2A8-4778-11D2-9BDB-204C4F4F5020")
    IDirectContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateControl( 
            BSTR bszClsid,
            DWORD dwClsContext,
            IUnknown **ppunk,
            DWORD dwWindowStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetServiceProvider( 
            IServiceProvider *pspSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIInputObjectSite( 
            IUnknown *pios) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowControl( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HideControl( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsControlCreated( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyControl( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectContainer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateControl )( 
            IDirectContainer * This,
            BSTR bszClsid,
            DWORD dwClsContext,
            IUnknown **ppunk,
            DWORD dwWindowStyle);
        
        HRESULT ( STDMETHODCALLTYPE *SetServiceProvider )( 
            IDirectContainer * This,
            IServiceProvider *pspSet);
        
        HRESULT ( STDMETHODCALLTYPE *SetIInputObjectSite )( 
            IDirectContainer * This,
            IUnknown *pios);
        
        HRESULT ( STDMETHODCALLTYPE *ShowControl )( 
            IDirectContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *HideControl )( 
            IDirectContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsControlCreated )( 
            IDirectContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyControl )( 
            IDirectContainer * This);
        
        END_INTERFACE
    } IDirectContainerVtbl;

    interface IDirectContainer
    {
        CONST_VTBL struct IDirectContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectContainer_CreateControl(This,bszClsid,dwClsContext,ppunk,dwWindowStyle)	\
    ( (This)->lpVtbl -> CreateControl(This,bszClsid,dwClsContext,ppunk,dwWindowStyle) ) 

#define IDirectContainer_SetServiceProvider(This,pspSet)	\
    ( (This)->lpVtbl -> SetServiceProvider(This,pspSet) ) 

#define IDirectContainer_SetIInputObjectSite(This,pios)	\
    ( (This)->lpVtbl -> SetIInputObjectSite(This,pios) ) 

#define IDirectContainer_ShowControl(This)	\
    ( (This)->lpVtbl -> ShowControl(This) ) 

#define IDirectContainer_HideControl(This)	\
    ( (This)->lpVtbl -> HideControl(This) ) 

#define IDirectContainer_IsControlCreated(This)	\
    ( (This)->lpVtbl -> IsControlCreated(This) ) 

#define IDirectContainer_DestroyControl(This)	\
    ( (This)->lpVtbl -> DestroyControl(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectContainer_INTERFACE_DEFINED__ */


#ifndef __IRadioView_INTERFACE_DEFINED__
#define __IRadioView_INTERFACE_DEFINED__

/* interface IRadioView */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRadioView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("847B4DF4-4B61-11D2-9BDB-204C4F4F5020")
    IRadioView : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IRadioViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRadioView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRadioView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRadioView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRadioView * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRadioView * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRadioView * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRadioView * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IRadioViewVtbl;

    interface IRadioView
    {
        CONST_VTBL struct IRadioViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRadioView_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRadioView_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRadioView_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRadioView_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRadioView_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRadioView_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRadioView_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRadioView_INTERFACE_DEFINED__ */


#ifndef __IRadioPlayer_INTERFACE_DEFINED__
#define __IRadioPlayer_INTERFACE_DEFINED__

/* interface IRadioPlayer */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRadioPlayer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C2263AF-3E3C-11D2-9BD3-204C4F4F5020")
    IRadioPlayer : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BindRadioMemory( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ReleaseRadio( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RegisterEvent( 
            /* [in] */ BSTR bszEvent,
            /* [retval][out] */ LONG *plRegister) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RegisterWindow( 
            /* [in] */ LONG lHWND,
            /* [in] */ DWORD dwMessage,
            /* [in] */ DWORD dwCodeSet,
            /* [retval][out] */ LONG *plRegister) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetSection( 
            /* [retval][out] */ BSTR *bszSection) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Unregister( 
            /* [in] */ LONG lRegister) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetInstanceCount( 
            /* [retval][out] */ LONG *plInstances) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Play( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Url( 
            /* [in] */ BSTR wszUrl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ LONG lVolumeSet) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Mute( 
            /* [in] */ VARIANT_BOOL fMuteSet) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ LONG *plVolume,
            /* [out] */ LONG *pfMute,
            /* [out] */ LONG *pfPlay,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0000,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0001,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0002,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0003,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0004,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0005,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0006) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ LONG *plOpenState,
            /* [out] */ LONG *pfBuffering,
            /* [out] */ LONG *plBufferingPercent,
            /* [out] */ LONG *plQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRadioPlayerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRadioPlayer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRadioPlayer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRadioPlayer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRadioPlayer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRadioPlayer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRadioPlayer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRadioPlayer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *BindRadioMemory )( 
            IRadioPlayer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ReleaseRadio )( 
            IRadioPlayer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RegisterEvent )( 
            IRadioPlayer * This,
            /* [in] */ BSTR bszEvent,
            /* [retval][out] */ LONG *plRegister);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RegisterWindow )( 
            IRadioPlayer * This,
            /* [in] */ LONG lHWND,
            /* [in] */ DWORD dwMessage,
            /* [in] */ DWORD dwCodeSet,
            /* [retval][out] */ LONG *plRegister);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetSection )( 
            IRadioPlayer * This,
            /* [retval][out] */ BSTR *bszSection);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Unregister )( 
            IRadioPlayer * This,
            /* [in] */ LONG lRegister);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInstanceCount )( 
            IRadioPlayer * This,
            /* [retval][out] */ LONG *plInstances);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Play )( 
            IRadioPlayer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IRadioPlayer * This);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Url )( 
            IRadioPlayer * This,
            /* [in] */ BSTR wszUrl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            IRadioPlayer * This,
            /* [in] */ LONG lVolumeSet);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Mute )( 
            IRadioPlayer * This,
            /* [in] */ VARIANT_BOOL fMuteSet);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IRadioPlayer * This,
            /* [out] */ LONG *plVolume,
            /* [out] */ LONG *pfMute,
            /* [out] */ LONG *pfPlay,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0000,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0001,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0002,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0003,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0004,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0005,
            /* [out] */ BSTR *__MIDL__IRadioPlayer0006);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IRadioPlayer * This,
            /* [out] */ LONG *plOpenState,
            /* [out] */ LONG *pfBuffering,
            /* [out] */ LONG *plBufferingPercent,
            /* [out] */ LONG *plQuality);
        
        END_INTERFACE
    } IRadioPlayerVtbl;

    interface IRadioPlayer
    {
        CONST_VTBL struct IRadioPlayerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRadioPlayer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRadioPlayer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRadioPlayer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRadioPlayer_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRadioPlayer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRadioPlayer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRadioPlayer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRadioPlayer_BindRadioMemory(This)	\
    ( (This)->lpVtbl -> BindRadioMemory(This) ) 

#define IRadioPlayer_ReleaseRadio(This)	\
    ( (This)->lpVtbl -> ReleaseRadio(This) ) 

#define IRadioPlayer_RegisterEvent(This,bszEvent,plRegister)	\
    ( (This)->lpVtbl -> RegisterEvent(This,bszEvent,plRegister) ) 

#define IRadioPlayer_RegisterWindow(This,lHWND,dwMessage,dwCodeSet,plRegister)	\
    ( (This)->lpVtbl -> RegisterWindow(This,lHWND,dwMessage,dwCodeSet,plRegister) ) 

#define IRadioPlayer_GetSection(This,bszSection)	\
    ( (This)->lpVtbl -> GetSection(This,bszSection) ) 

#define IRadioPlayer_Unregister(This,lRegister)	\
    ( (This)->lpVtbl -> Unregister(This,lRegister) ) 

#define IRadioPlayer_GetInstanceCount(This,plInstances)	\
    ( (This)->lpVtbl -> GetInstanceCount(This,plInstances) ) 

#define IRadioPlayer_Play(This)	\
    ( (This)->lpVtbl -> Play(This) ) 

#define IRadioPlayer_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IRadioPlayer_put_Url(This,wszUrl)	\
    ( (This)->lpVtbl -> put_Url(This,wszUrl) ) 

#define IRadioPlayer_put_Volume(This,lVolumeSet)	\
    ( (This)->lpVtbl -> put_Volume(This,lVolumeSet) ) 

#define IRadioPlayer_put_Mute(This,fMuteSet)	\
    ( (This)->lpVtbl -> put_Mute(This,fMuteSet) ) 

#define IRadioPlayer_GetStatus(This,plVolume,pfMute,pfPlay,__MIDL__IRadioPlayer0000,__MIDL__IRadioPlayer0001,__MIDL__IRadioPlayer0002,__MIDL__IRadioPlayer0003,__MIDL__IRadioPlayer0004,__MIDL__IRadioPlayer0005,__MIDL__IRadioPlayer0006)	\
    ( (This)->lpVtbl -> GetStatus(This,plVolume,pfMute,pfPlay,__MIDL__IRadioPlayer0000,__MIDL__IRadioPlayer0001,__MIDL__IRadioPlayer0002,__MIDL__IRadioPlayer0003,__MIDL__IRadioPlayer0004,__MIDL__IRadioPlayer0005,__MIDL__IRadioPlayer0006) ) 

#define IRadioPlayer_GetState(This,plOpenState,pfBuffering,plBufferingPercent,plQuality)	\
    ( (This)->lpVtbl -> GetState(This,plOpenState,pfBuffering,plBufferingPercent,plQuality) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRadioPlayer_INTERFACE_DEFINED__ */


#ifndef __IRadioServer_INTERFACE_DEFINED__
#define __IRadioServer_INTERFACE_DEFINED__

/* interface IRadioServer */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRadioServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C2263A0-3E3C-11D2-9BD3-204C4F4F5020")
    IRadioServer : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BindToRadio( 
            /* [in] */ BSTR wszRadio,
            /* [retval][out] */ IRadioPlayer **ppServer) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsRadioExists( 
            /* [in] */ BSTR wszRadio) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE LaunchStandardUrl( 
            /* [in] */ BSTR bszUrl,
            /* [in] */ IUnknown *pBrowser) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRadioServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRadioServer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRadioServer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRadioServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRadioServer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRadioServer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRadioServer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRadioServer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *BindToRadio )( 
            IRadioServer * This,
            /* [in] */ BSTR wszRadio,
            /* [retval][out] */ IRadioPlayer **ppServer);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsRadioExists )( 
            IRadioServer * This,
            /* [in] */ BSTR wszRadio);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *LaunchStandardUrl )( 
            IRadioServer * This,
            /* [in] */ BSTR bszUrl,
            /* [in] */ IUnknown *pBrowser);
        
        END_INTERFACE
    } IRadioServerVtbl;

    interface IRadioServer
    {
        CONST_VTBL struct IRadioServerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRadioServer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRadioServer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRadioServer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRadioServer_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRadioServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRadioServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRadioServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRadioServer_BindToRadio(This,wszRadio,ppServer)	\
    ( (This)->lpVtbl -> BindToRadio(This,wszRadio,ppServer) ) 

#define IRadioServer_IsRadioExists(This,wszRadio)	\
    ( (This)->lpVtbl -> IsRadioExists(This,wszRadio) ) 

#define IRadioServer_LaunchStandardUrl(This,bszUrl,pBrowser)	\
    ( (This)->lpVtbl -> LaunchStandardUrl(This,bszUrl,pBrowser) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRadioServer_INTERFACE_DEFINED__ */


#ifndef __IRadioServerControl_INTERFACE_DEFINED__
#define __IRadioServerControl_INTERFACE_DEFINED__

/* interface IRadioServerControl */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRadioServerControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E718889-423F-11D2-876E-00A0C9082467")
    IRadioServerControl : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IRadioServerControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRadioServerControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRadioServerControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRadioServerControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRadioServerControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRadioServerControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRadioServerControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRadioServerControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IRadioServerControlVtbl;

    interface IRadioServerControl
    {
        CONST_VTBL struct IRadioServerControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRadioServerControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRadioServerControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRadioServerControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRadioServerControl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRadioServerControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRadioServerControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRadioServerControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRadioServerControl_INTERFACE_DEFINED__ */


#ifndef __IRadioBand_INTERFACE_DEFINED__
#define __IRadioBand_INTERFACE_DEFINED__

/* interface IRadioBand */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRadioBand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E718881-423F-11D2-876E-00A0C9082467")
    IRadioBand : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            LONG *phwnd,
            LONG hwndParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRadioBandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRadioBand * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRadioBand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRadioBand * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRadioBand * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRadioBand * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRadioBand * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRadioBand * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IRadioBand * This,
            LONG *phwnd,
            LONG hwndParent);
        
        END_INTERFACE
    } IRadioBandVtbl;

    interface IRadioBand
    {
        CONST_VTBL struct IRadioBandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRadioBand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRadioBand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRadioBand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRadioBand_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRadioBand_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRadioBand_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRadioBand_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRadioBand_Create(This,phwnd,hwndParent)	\
    ( (This)->lpVtbl -> Create(This,phwnd,hwndParent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRadioBand_INTERFACE_DEFINED__ */


#ifndef __IMediaBindStream_INTERFACE_DEFINED__
#define __IMediaBindStream_INTERFACE_DEFINED__

/* interface IMediaBindStream */
/* [object][unique][dual][uuid] */ 


EXTERN_C const IID IID_IMediaBindStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("920F0DE3-91C5-11d2-828F-00C04FC99D4E")
    IMediaBindStream : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE LoadMoniker( 
            /* [in] */ BSTR bszTransferContext,
            /* [in] */ BSTR bszUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaBindStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaBindStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaBindStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaBindStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaBindStream * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaBindStream * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaBindStream * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaBindStream * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *LoadMoniker )( 
            IMediaBindStream * This,
            /* [in] */ BSTR bszTransferContext,
            /* [in] */ BSTR bszUrl);
        
        END_INTERFACE
    } IMediaBindStreamVtbl;

    interface IMediaBindStream
    {
        CONST_VTBL struct IMediaBindStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaBindStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaBindStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaBindStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaBindStream_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaBindStream_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaBindStream_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaBindStream_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaBindStream_LoadMoniker(This,bszTransferContext,bszUrl)	\
    ( (This)->lpVtbl -> LoadMoniker(This,bszTransferContext,bszUrl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaBindStream_INTERFACE_DEFINED__ */


#ifndef __IMediaPlayerListener_INTERFACE_DEFINED__
#define __IMediaPlayerListener_INTERFACE_DEFINED__

/* interface IMediaPlayerListener */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMediaPlayerListener;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("33222211-5E5E-11d2-9E8E-0000F8085981")
    IMediaPlayerListener : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PlayStateChanged( 
            /* [in] */ long lNewState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Buffering( 
            /* [in] */ VARIANT_BOOL fStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BufferPercent( 
            /* [in] */ long lBufferPercent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenStateChanged( 
            /* [in] */ long lOpenState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MediaInfoChanged( 
            /* [in] */ BSTR bstrShowTitle,
            /* [in] */ BSTR bstrClipTitle,
            /* [in] */ BSTR bstrClipAuthor,
            /* [in] */ BSTR bstrClipCopyright,
            /* [in] */ BSTR bstrStationURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QualityChanged( 
            /* [in] */ long lQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ BSTR bstrError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaPlayerListenerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaPlayerListener * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaPlayerListener * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaPlayerListener * This);
        
        HRESULT ( STDMETHODCALLTYPE *PlayStateChanged )( 
            IMediaPlayerListener * This,
            /* [in] */ long lNewState);
        
        HRESULT ( STDMETHODCALLTYPE *Buffering )( 
            IMediaPlayerListener * This,
            /* [in] */ VARIANT_BOOL fStart);
        
        HRESULT ( STDMETHODCALLTYPE *BufferPercent )( 
            IMediaPlayerListener * This,
            /* [in] */ long lBufferPercent);
        
        HRESULT ( STDMETHODCALLTYPE *OpenStateChanged )( 
            IMediaPlayerListener * This,
            /* [in] */ long lOpenState);
        
        HRESULT ( STDMETHODCALLTYPE *MediaInfoChanged )( 
            IMediaPlayerListener * This,
            /* [in] */ BSTR bstrShowTitle,
            /* [in] */ BSTR bstrClipTitle,
            /* [in] */ BSTR bstrClipAuthor,
            /* [in] */ BSTR bstrClipCopyright,
            /* [in] */ BSTR bstrStationURL);
        
        HRESULT ( STDMETHODCALLTYPE *QualityChanged )( 
            IMediaPlayerListener * This,
            /* [in] */ long lQuality);
        
        HRESULT ( STDMETHODCALLTYPE *Error )( 
            IMediaPlayerListener * This,
            /* [in] */ BSTR bstrError);
        
        END_INTERFACE
    } IMediaPlayerListenerVtbl;

    interface IMediaPlayerListener
    {
        CONST_VTBL struct IMediaPlayerListenerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaPlayerListener_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaPlayerListener_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaPlayerListener_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaPlayerListener_PlayStateChanged(This,lNewState)	\
    ( (This)->lpVtbl -> PlayStateChanged(This,lNewState) ) 

#define IMediaPlayerListener_Buffering(This,fStart)	\
    ( (This)->lpVtbl -> Buffering(This,fStart) ) 

#define IMediaPlayerListener_BufferPercent(This,lBufferPercent)	\
    ( (This)->lpVtbl -> BufferPercent(This,lBufferPercent) ) 

#define IMediaPlayerListener_OpenStateChanged(This,lOpenState)	\
    ( (This)->lpVtbl -> OpenStateChanged(This,lOpenState) ) 

#define IMediaPlayerListener_MediaInfoChanged(This,bstrShowTitle,bstrClipTitle,bstrClipAuthor,bstrClipCopyright,bstrStationURL)	\
    ( (This)->lpVtbl -> MediaInfoChanged(This,bstrShowTitle,bstrClipTitle,bstrClipAuthor,bstrClipCopyright,bstrStationURL) ) 

#define IMediaPlayerListener_QualityChanged(This,lQuality)	\
    ( (This)->lpVtbl -> QualityChanged(This,lQuality) ) 

#define IMediaPlayerListener_Error(This,bstrError)	\
    ( (This)->lpVtbl -> Error(This,bstrError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaPlayerListener_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Proxy( 
    IServiceProvider * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Stub( 
    IServiceProvider * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObject);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\bcrypt.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//  File:       bcrypt.h
//
//  Contents:   Cryptographic Primitive API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#pragma once

#ifndef __BCRYPT_H__
#define __BCRYPT_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WINAPI
#define WINAPI __stdcall
#endif

#ifndef _NTSTATUS_
typedef __success(return >= 0) LONG NTSTATUS, *PNTSTATUS;
#endif

#ifndef CONST
#define CONST const
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#if !defined(__midl)
#define BCRYPT_STRUCT_ALIGNMENT __declspec(align(BCRYPT_OBJECT_ALIGNMENT))
#else
#define BCRYPT_STRUCT_ALIGNMENT
#endif /*!defined(__midl)*/

//
//  Alignment macros
//

// BCRYPT_OBJECT_ALIGNMENT must be a power of 2
#if defined(_IA64_) || defined(_AMD64_)
 #define BCRYPT_OBJECT_ALIGNMENT    8
#else
 #define BCRYPT_OBJECT_ALIGNMENT    4
#endif

#if !defined(__midl)
#define BCRYPT_STRUCT_ALIGNMENT __declspec(align(BCRYPT_OBJECT_ALIGNMENT))
#else
#define BCRYPT_STRUCT_ALIGNMENT
#endif /*!defined(__midl)*/

//
// DeriveKey KDF Types
//
#define BCRYPT_KDF_HASH     L"HASH"
#define BCRYPT_KDF_HMAC     L"HMAC"
#define BCRYPT_KDF_TLS_PRF  L"TLS_PRF"

//
// DeriveKey KDF BufferTypes
//
// For BCRYPT_KDF_HASH and BCRYPT_KDF_HMAC operations, there may be an arbitrary
// number of KDF_SECRET_PREPEND and KDF_SECRET_APPEND buffertypes in the
// parameter list.  The BufferTypes are processed in order of appearence 
// within the parameter list.
//
#define KDF_HASH_ALGORITHM  0x0
#define KDF_SECRET_PREPEND  0x1
#define KDF_SECRET_APPEND   0x2
#define KDF_HMAC_KEY        0x3
#define KDF_TLS_PRF_LABEL   0x4
#define KDF_TLS_PRF_SEED    0x5
#define KDF_SECRET_HANDLE   0x6

//
// DeriveKey Flags:
//
// KDF_USE_SECRET_AS_HMAC_KEY_FLAG causes the secret agreement to serve also
// as the HMAC key.  If this flag is used, the KDF_HMAC_KEY parameter should 
// NOT be specified.
//
#define KDF_USE_SECRET_AS_HMAC_KEY_FLAG 0x1

//
// BCrypt structs
//

typedef struct __BCRYPT_KEY_LENGTHS_STRUCT
{
    ULONG   dwMinLength;
    ULONG   dwMaxLength;
    ULONG   dwIncrement;
} BCRYPT_KEY_LENGTHS_STRUCT;

typedef BCRYPT_KEY_LENGTHS_STRUCT BCRYPT_AUTH_TAG_LENGTHS_STRUCT;

#pragma pack(push, BCRYPT_OBJECT_ALIGNMENT)
typedef BCRYPT_STRUCT_ALIGNMENT struct _BCRYPT_OID
{
    ULONG   cbOID;
    PUCHAR  pbOID;
} BCRYPT_OID;

typedef BCRYPT_STRUCT_ALIGNMENT struct _BCRYPT_OID_LIST
{
    ULONG       dwOIDCount;
    BCRYPT_OID  *pOIDs;
} BCRYPT_OID_LIST;
#pragma pack(pop)

typedef struct _BCRYPT_PKCS1_PADDING_INFO
{
    LPCWSTR pszAlgId;
} BCRYPT_PKCS1_PADDING_INFO;

typedef struct _BCRYPT_PSS_PADDING_INFO
{
    LPCWSTR pszAlgId;
    ULONG   cbSalt;
} BCRYPT_PSS_PADDING_INFO;

typedef struct _BCRYPT_OAEP_PADDING_INFO
{
    LPCWSTR pszAlgId;
    PUCHAR   pbLabel;
    ULONG   cbLabel;
} BCRYPT_OAEP_PADDING_INFO;

#define BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO_VERSION  1

#define BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG   0x00000001
#define BCRYPT_AUTH_MODE_IN_PROGRESS_FLAG   0x00000002

typedef struct _BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO
{
    ULONG       cbSize;
    ULONG       dwInfoVersion;
    PUCHAR      pbNonce;
    ULONG       cbNonce;
    PUCHAR      pbAuthData;
    ULONG       cbAuthData;
    PUCHAR      pbTag;
    ULONG       cbTag;
    PUCHAR      pbMacContext;
    ULONG       cbMacContext;
    ULONG       cbAAD;
    ULONGLONG   cbData;
    ULONG       dwFlags;
} BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO, *PBCRYPT_AUTHENTICATED_CIPHER_MODE_INFO;

#define BCRYPT_INIT_AUTH_MODE_INFO(_AUTH_INFO_STRUCT_)    \
            RtlZeroMemory((&_AUTH_INFO_STRUCT_), sizeof(BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO));  \
            (_AUTH_INFO_STRUCT_).cbSize = sizeof(BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO);          \
            (_AUTH_INFO_STRUCT_).dwInfoVersion = BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO_VERSION;

//
// BCrypt String Properties
//

// BCrypt(Import/Export)Key BLOB types
#define BCRYPT_OPAQUE_KEY_BLOB      L"OpaqueKeyBlob"
#define BCRYPT_KEY_DATA_BLOB        L"KeyDataBlob"

// BCryptGetProperty strings
#define BCRYPT_OBJECT_LENGTH        L"ObjectLength"
#define BCRYPT_ALGORITHM_NAME       L"AlgorithmName"
#define BCRYPT_PROVIDER_HANDLE      L"ProviderHandle"
#define BCRYPT_CHAINING_MODE        L"ChainingMode"
#define BCRYPT_BLOCK_LENGTH         L"BlockLength"
#define BCRYPT_KEY_LENGTH           L"KeyLength"
#define BCRYPT_KEY_OBJECT_LENGTH    L"KeyObjectLength"
#define BCRYPT_KEY_STRENGTH         L"KeyStrength"
#define BCRYPT_KEY_LENGTHS          L"KeyLengths"
#define BCRYPT_BLOCK_SIZE_LIST      L"BlockSizeList"
#define BCRYPT_EFFECTIVE_KEY_LENGTH L"EffectiveKeyLength"
#define BCRYPT_HASH_LENGTH          L"HashDigestLength"
#define BCRYPT_HASH_OID_LIST        L"HashOIDList"
#define BCRYPT_PADDING_SCHEMES      L"PaddingSchemes"
#define BCRYPT_SIGNATURE_LENGTH     L"SignatureLength"
#define BCRYPT_HASH_BLOCK_LENGTH    L"HashBlockLength"
#define BCRYPT_AUTH_TAG_LENGTH      L"AuthTagLength"

// BCryptSetProperty strings
#define BCRYPT_INITIALIZATION_VECTOR    L"IV"


// Property Strings
#define BCRYPT_CHAIN_MODE_NA        L"ChainingModeN/A"
#define BCRYPT_CHAIN_MODE_CBC       L"ChainingModeCBC"
#define BCRYPT_CHAIN_MODE_ECB       L"ChainingModeECB"
#define BCRYPT_CHAIN_MODE_CFB       L"ChainingModeCFB"
#define BCRYPT_CHAIN_MODE_CCM       L"ChainingModeCCM"
#define BCRYPT_CHAIN_MODE_GCM       L"ChainingModeGCM"

// Supported RSA Padding Types
#define BCRYPT_SUPPORTED_PAD_ROUTER     0x00000001
#define BCRYPT_SUPPORTED_PAD_PKCS1_ENC  0x00000002
#define BCRYPT_SUPPORTED_PAD_PKCS1_SIG  0x00000004
#define BCRYPT_SUPPORTED_PAD_OAEP       0x00000008
#define BCRYPT_SUPPORTED_PAD_PSS        0x00000010

//
//      BCrypt Flags
//

#define BCRYPT_PROV_DISPATCH        0x00000001  // BCryptOpenAlgorithmProvider

#define BCRYPT_BLOCK_PADDING        0x00000001  // BCryptEncrypt/Decrypt

// RSA padding schemes
#define BCRYPT_PAD_NONE             0x00000001
#define BCRYPT_PAD_PKCS1            0x00000002  // BCryptEncrypt/Decrypt BCryptSignHash/VerifySignature
#define BCRYPT_PAD_OAEP             0x00000004  // BCryptEncrypt/Decrypt
#define BCRYPT_PAD_PSS              0x00000008  // BCryptSignHash/VerifySignature


#define BCRYPTBUFFER_VERSION        0

typedef struct _BCryptBuffer {
    ULONG   cbBuffer;             // Length of buffer, in bytes
    ULONG   BufferType;           // Buffer type
    PVOID   pvBuffer;             // Pointer to buffer
} BCryptBuffer, * PBCryptBuffer;

typedef struct _BCryptBufferDesc {
    ULONG   ulVersion;            // Version number
    ULONG   cBuffers;             // Number of buffers
    PBCryptBuffer pBuffers;       // Pointer to array of buffers
} BCryptBufferDesc, * PBCryptBufferDesc;


//
// Primitive handles
//

typedef PVOID BCRYPT_HANDLE;
typedef PVOID BCRYPT_ALG_HANDLE;
typedef PVOID BCRYPT_KEY_HANDLE;
typedef PVOID BCRYPT_HASH_HANDLE;
typedef PVOID BCRYPT_SECRET_HANDLE;


//
// Structures used to represent key blobs.
//

#define BCRYPT_PUBLIC_KEY_BLOB       L"PUBLICBLOB"
#define BCRYPT_PRIVATE_KEY_BLOB      L"PRIVATEBLOB"

typedef struct _BCRYPT_KEY_BLOB
{
    ULONG   Magic;
} BCRYPT_KEY_BLOB;

// The BCRYPT_RSAPUBLIC_BLOB and BCRYPT_RSAPRIVATE_BLOB blob types are used
// to transport plaintext RSA keys. These blob types will be supported by
// all RSA primitive providers.
// The BCRYPT_RSAPRIVATE_BLOB includes the following values:
// Public Exponent
// Modulus
// Prime1
// Prime2

#define BCRYPT_RSAPUBLIC_BLOB       L"RSAPUBLICBLOB"
#define BCRYPT_RSAPRIVATE_BLOB      L"RSAPRIVATEBLOB"
#define LEGACY_RSAPUBLIC_BLOB       L"CAPIPUBLICBLOB"
#define LEGACY_RSAPRIVATE_BLOB      L"CAPIPRIVATEBLOB"

#define BCRYPT_RSAPUBLIC_MAGIC      0x31415352  // RSA1
#define BCRYPT_RSAPRIVATE_MAGIC     0x32415352  // RSA2

typedef struct _BCRYPT_RSAKEY_BLOB
{
    ULONG   Magic;
    ULONG   BitLength;
    ULONG   cbPublicExp;
    ULONG   cbModulus;
    ULONG   cbPrime1;
    ULONG   cbPrime2;
} BCRYPT_RSAKEY_BLOB;

// The BCRYPT_RSAFULLPRIVATE_BLOB blob type is used to transport
// plaintext private RSA keys.  It includes the following values:
// Public Exponent
// Modulus
// Prime1
// Prime2
// Private Exponent mod (Prime1 - 1)
// Private Exponent mod (Prime2 - 1)
// Inverse of Prime2 mod Prime1
// PrivateExponent
#define BCRYPT_RSAFULLPRIVATE_BLOB      L"RSAFULLPRIVATEBLOB"

#define BCRYPT_RSAFULLPRIVATE_MAGIC     0x33415352  // RSA3

// The BCRYPT_ECCPUBLIC_BLOB and BCRYPT_ECCPRIVATE_BLOB blob types are used
// to transport plaintext ECC keys. These blob types will be supported by
// all ECC primitive providers.
#define BCRYPT_ECCPUBLIC_BLOB           L"ECCPUBLICBLOB"
#define BCRYPT_ECCPRIVATE_BLOB          L"ECCPRIVATEBLOB"

#define BCRYPT_ECDH_PUBLIC_P256_MAGIC   0x314B4345  // ECK1
#define BCRYPT_ECDH_PRIVATE_P256_MAGIC  0x324B4345  // ECK2
#define BCRYPT_ECDH_PUBLIC_P384_MAGIC   0x334B4345  // ECK3
#define BCRYPT_ECDH_PRIVATE_P384_MAGIC  0x344B4345  // ECK4
#define BCRYPT_ECDH_PUBLIC_P521_MAGIC   0x354B4345  // ECK5
#define BCRYPT_ECDH_PRIVATE_P521_MAGIC  0x364B4345  // ECK6

#define BCRYPT_ECDSA_PUBLIC_P256_MAGIC  0x31534345  // ECS1
#define BCRYPT_ECDSA_PRIVATE_P256_MAGIC 0x32534345  // ECS2
#define BCRYPT_ECDSA_PUBLIC_P384_MAGIC  0x33534345  // ECS3
#define BCRYPT_ECDSA_PRIVATE_P384_MAGIC 0x34534345  // ECS4
#define BCRYPT_ECDSA_PUBLIC_P521_MAGIC  0x35534345  // ECS5
#define BCRYPT_ECDSA_PRIVATE_P521_MAGIC 0x36534345  // ECS6

typedef struct _BCRYPT_ECCKEY_BLOB
{
    ULONG   dwMagic;
    ULONG   cbKey;
} BCRYPT_ECCKEY_BLOB, *PBCRYPT_ECCKEY_BLOB;

// The BCRYPT_DH_PUBLIC_BLOB and BCRYPT_DH_PRIVATE_BLOB blob types are used
// to transport plaintext DH keys. These blob types will be supported by
// all DH primitive providers.
#define BCRYPT_DH_PUBLIC_BLOB           L"DHPUBLICBLOB"
#define BCRYPT_DH_PRIVATE_BLOB          L"DHPRIVATEBLOB"
#define LEGACY_DH_PUBLIC_BLOB           L"CAPIDHPUBLICBLOB"
#define LEGACY_DH_PRIVATE_BLOB          L"CAPIDHPRIVATEBLOB"

#define BCRYPT_DH_PUBLIC_MAGIC          0x42504844  // DHPB
#define BCRYPT_DH_PRIVATE_MAGIC         0x56504844  // DHPV

typedef struct _BCRYPT_DH_KEY_BLOB
{
    ULONG   dwMagic;
    ULONG   cbKey;
} BCRYPT_DH_KEY_BLOB, *PBCRYPT_DH_KEY_BLOB;

// Property Strings for DH
#define BCRYPT_DH_PARAMETERS            L"DHParameters"

#define BCRYPT_DH_PARAMETERS_MAGIC      0x4d504844  // DHPM

typedef __struct_bcount(cbLength) struct _BCRYPT_DH_PARAMETER_HEADER
{
    ULONG           cbLength;
    ULONG           dwMagic;
    ULONG           cbKeyLength;
} BCRYPT_DH_PARAMETER_HEADER;


// The BCRYPT_DSA_PUBLIC_BLOB and BCRYPT_DSA_PRIVATE_BLOB blob types are used
// to transport plaintext DSA keys. These blob types will be supported by
// all DSA primitive providers.
#define BCRYPT_DSA_PUBLIC_BLOB          L"DSAPUBLICBLOB"
#define BCRYPT_DSA_PRIVATE_BLOB         L"DSAPRIVATEBLOB"
#define LEGACY_DSA_PUBLIC_BLOB          L"CAPIDSAPUBLICBLOB"
#define LEGACY_DSA_PRIVATE_BLOB         L"CAPIDSAPRIVATEBLOB"
#define LEGACY_DSA_V2_PRIVATE_BLOB      L"V2CAPIDSAPRIVATEBLOB"

#define BCRYPT_DSA_PUBLIC_MAGIC         0x42505344  // DSPB
#define BCRYPT_DSA_PRIVATE_MAGIC        0x56505344  // DSPV

typedef struct _BCRYPT_DSA_KEY_BLOB
{
    ULONG   dwMagic;
    ULONG   cbKey;
    UCHAR   Count[4];
    UCHAR   Seed[20];
    UCHAR   q[20];
} BCRYPT_DSA_KEY_BLOB, *PBCRYPT_DSA_KEY_BLOB;

typedef struct _BCRYPT_KEY_DATA_BLOB_HEADER
{
    ULONG   dwMagic;
    ULONG   dwVersion;
    ULONG   cbKeyData;
} BCRYPT_KEY_DATA_BLOB_HEADER, *PBCRYPT_KEY_DATA_BLOB_HEADER;

#define BCRYPT_KEY_DATA_BLOB_MAGIC       0x4d42444b //Key Data Blob Magic (KDBM)

#define BCRYPT_KEY_DATA_BLOB_VERSION1    0x1

// Property Strings for DSA
#define BCRYPT_DSA_PARAMETERS       L"DSAParameters"

#define BCRYPT_DSA_PARAMETERS_MAGIC 0x4d505344  // DSPM

typedef struct _BCRYPT_DSA_PARAMETER_HEADER
{
    ULONG           cbLength;
    ULONG           dwMagic;
    ULONG           cbKeyLength;
    UCHAR           Count[4];
    UCHAR           Seed[20];
    UCHAR           q[20];
} BCRYPT_DSA_PARAMETER_HEADER;

//
// Microsoft built-in providers.
//

#define MS_PRIMITIVE_PROVIDER                   L"Microsoft Primitive Provider"

//
// Common algorithm identifiers.
//

#define BCRYPT_RSA_ALGORITHM                    L"RSA"
#define BCRYPT_RSA_SIGN_ALGORITHM               L"RSA_SIGN"
#define BCRYPT_DH_ALGORITHM                     L"DH"
#define BCRYPT_DSA_ALGORITHM                    L"DSA"
#define BCRYPT_RC2_ALGORITHM                    L"RC2"
#define BCRYPT_RC4_ALGORITHM                    L"RC4"
#define BCRYPT_AES_ALGORITHM                    L"AES"
#define BCRYPT_DES_ALGORITHM                    L"DES"
#define BCRYPT_DESX_ALGORITHM                   L"DESX"
#define BCRYPT_3DES_ALGORITHM                   L"3DES"
#define BCRYPT_3DES_112_ALGORITHM               L"3DES_112"
#define BCRYPT_MD2_ALGORITHM                    L"MD2"
#define BCRYPT_MD4_ALGORITHM                    L"MD4"
#define BCRYPT_MD5_ALGORITHM                    L"MD5"
#define BCRYPT_SHA1_ALGORITHM                   L"SHA1"
#define BCRYPT_SHA256_ALGORITHM                 L"SHA256"
#define BCRYPT_SHA384_ALGORITHM                 L"SHA384"
#define BCRYPT_SHA512_ALGORITHM                 L"SHA512"
#define BCRYPT_AES_GMAC_ALGORITHM               L"AES-GMAC"
#define BCRYPT_ECDSA_P256_ALGORITHM             L"ECDSA_P256"
#define BCRYPT_ECDSA_P384_ALGORITHM             L"ECDSA_P384"
#define BCRYPT_ECDSA_P521_ALGORITHM             L"ECDSA_P521"
#define BCRYPT_ECDH_P256_ALGORITHM              L"ECDH_P256"
#define BCRYPT_ECDH_P384_ALGORITHM              L"ECDH_P384"
#define BCRYPT_ECDH_P521_ALGORITHM              L"ECDH_P521"
#define BCRYPT_RNG_ALGORITHM                    L"RNG"
#define BCRYPT_RNG_FIPS186_DSA_ALGORITHM        L"FIPS186DSARNG"
#define BCRYPT_RNG_DUAL_EC_ALGORITHM            L"DUALECRNG"

//
// Interfaces
//

#define BCRYPT_CIPHER_INTERFACE                 0x00000001
#define BCRYPT_HASH_INTERFACE                   0x00000002
#define BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE  0x00000003
#define BCRYPT_SECRET_AGREEMENT_INTERFACE       0x00000004
#define BCRYPT_SIGNATURE_INTERFACE              0x00000005
#define BCRYPT_RNG_INTERFACE                    0x00000006

//
// Primitive algorithm provider functions.
//

#define BCRYPT_ALG_HANDLE_HMAC_FLAG     0x00000008

NTSTATUS
WINAPI
BCryptOpenAlgorithmProvider(
    __out       BCRYPT_ALG_HANDLE   *phAlgorithm,
    __in        LPCWSTR pszAlgId,
    __in_opt    LPCWSTR pszImplementation,
    __in        ULONG   dwFlags);

typedef NTSTATUS
(WINAPI * BCryptOpenAlgorithmProviderFn)(
    __out   BCRYPT_ALG_HANDLE   *phAlgorithm,
    __in    LPCWSTR pszAlgId,
    __in    ULONG   dwFlags);


// AlgOperations flags for use with BCryptEnumAlgorithms()
#define BCRYPT_CIPHER_OPERATION                 0x00000001
#define BCRYPT_HASH_OPERATION                   0x00000002
#define BCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION  0x00000004
#define BCRYPT_SECRET_AGREEMENT_OPERATION       0x00000008
#define BCRYPT_SIGNATURE_OPERATION              0x00000010
#define BCRYPT_RNG_OPERATION                    0x00000020

// USE EXTREME CAUTION: editing comments that contain "certenrolls_*" tokens
// could break building CertEnroll idl files:
// certenrolls_begin -- BCRYPT_ALGORITHM_IDENTIFIER
typedef struct _BCRYPT_ALGORITHM_IDENTIFIER
{
    LPWSTR  pszName;
    ULONG   dwClass;
    ULONG   dwFlags;

} BCRYPT_ALGORITHM_IDENTIFIER;
// certenrolls_end

NTSTATUS
WINAPI
BCryptEnumAlgorithms(
    __in    ULONG   dwAlgOperations,
    __out   ULONG   *pAlgCount,
    __out   BCRYPT_ALGORITHM_IDENTIFIER **ppAlgList,
    __in    ULONG   dwFlags);


typedef struct _BCRYPT_PROVIDER_NAME
{
    LPWSTR  pszProviderName;
} BCRYPT_PROVIDER_NAME;

NTSTATUS
WINAPI
BCryptEnumProviders(
    __in    LPCWSTR pszAlgId,
    __out   ULONG   *pImplCount,
    __out   BCRYPT_PROVIDER_NAME    **ppImplList,
    __in    ULONG   dwFlags);


// Flags for use with BCryptGetProperty and BCryptSetProperty
#define BCRYPT_PUBLIC_KEY_FLAG                  0x00000001
#define BCRYPT_PRIVATE_KEY_FLAG                 0x00000002


NTSTATUS
WINAPI
BCryptGetProperty(
    __in                                        BCRYPT_HANDLE   hObject,
    __in                                        LPCWSTR pszProperty,
    __out_bcount_part_opt(cbOutput, *pcbResult) PUCHAR   pbOutput,
    __in                                        ULONG   cbOutput,
    __out                                       ULONG   *pcbResult,
    __in                                        ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptGetPropertyFn)(
    __in                                        BCRYPT_HANDLE   hObject,
    __in                                        LPCWSTR pszProperty,
    __out_bcount_part_opt(cbOutput, *pcbResult) PUCHAR   pbOutput,
    __in                                        ULONG   cbOutput,
    __out                                       ULONG   *pcbResult,
    __in                                        ULONG   dwFlags);


// @@END_DDKSPLIT


NTSTATUS
WINAPI
BCryptSetProperty(
    __inout                 BCRYPT_HANDLE   hObject,
    __in                    LPCWSTR pszProperty,
    __in_bcount(cbInput)    PUCHAR   pbInput,
    __in                    ULONG   cbInput,
    __in                    ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptSetPropertyFn)(
    __inout                 BCRYPT_HANDLE   hObject,
    __in                    LPCWSTR pszProperty,
    __in_bcount(cbInput)    PUCHAR   pbInput,
    __in                    ULONG   cbInput,
    __in                    ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptCloseAlgorithmProvider(
    __inout BCRYPT_ALG_HANDLE   hAlgorithm,
    __in    ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptCloseAlgorithmProviderFn)(
    __inout BCRYPT_ALG_HANDLE   hAlgorithm,
    __in    ULONG   dwFlags);

// @@END_DDKSPLIT



VOID
WINAPI
BCryptFreeBuffer(
    __deref PVOID   pvBuffer);

// @@BEGIN_DDKSPLIT
typedef VOID
(WINAPI * BCryptFreeBufferFn)(
    __deref PVOID   pvBuffer);

// @@END_DDKSPLIT



//
// Primitive encryption functions.
//

NTSTATUS
WINAPI
BCryptGenerateSymmetricKey(
    __inout                         BCRYPT_ALG_HANDLE   hAlgorithm,
    __out                           BCRYPT_KEY_HANDLE   *phKey,
    __out_bcount_full(cbKeyObject)  PUCHAR   pbKeyObject,
    __in                            ULONG   cbKeyObject,
    __in_bcount(cbSecret)           PUCHAR   pbSecret,
    __in                            ULONG   cbSecret,
    __in                            ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptGenerateSymmetricKeyFn)(
    __inout                         BCRYPT_ALG_HANDLE   hAlgorithm,
    __out                           BCRYPT_KEY_HANDLE   *phKey,
    __out_bcount_full(cbKeyObject)  PUCHAR   pbKeyObject,
    __in                            ULONG   cbKeyObject,
    __in_bcount(cbSecret)           PUCHAR   pbSecret,
    __in                            ULONG   cbSecret,
    __in                            ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptGenerateKeyPair(
    __inout BCRYPT_ALG_HANDLE   hAlgorithm,
    __out   BCRYPT_KEY_HANDLE   *phKey,
    __in    ULONG   dwLength,
    __in    ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptGenerateKeyPairFn)(
    __inout BCRYPT_ALG_HANDLE   hAlgorithm,
    __out   BCRYPT_KEY_HANDLE   *phKey,
    __in    ULONG   dwLength,
    __in    ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptEncrypt(
    __inout                                     BCRYPT_KEY_HANDLE hKey,
    __in_bcount(cbInput)                        PUCHAR   pbInput,
    __in                                        ULONG   cbInput,
    __in_opt                                    VOID    *pPaddingInfo,
    __inout_bcount_opt(cbIV)                    PUCHAR   pbIV,
    __in                                        ULONG   cbIV,
    __out_bcount_part_opt(cbOutput, *pcbResult) PUCHAR   pbOutput,
    __in                                        ULONG   cbOutput,
    __out                                       ULONG   *pcbResult,
    __in                                        ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptEncryptFn)(
    __inout                                     BCRYPT_KEY_HANDLE   hKey,
    __in_bcount(cbInput)                        PUCHAR   pbInput,
    __in                                        ULONG   cbInput,
    __in_opt                                    VOID    *pPaddingInfo,
    __inout_bcount_opt(cbIV)                    PUCHAR   pbIV,
    __in                                        ULONG   cbIV,
    __out_bcount_part_opt(cbOutput, *pcbResult) PUCHAR   pbOutput,
    __in                                        ULONG   cbOutput,
    __out                                       ULONG   *pcbResult,
    __in                                        ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptDecrypt(
    __inout                                     BCRYPT_KEY_HANDLE   hKey,
    __in_bcount(cbInput)                        PUCHAR   pbInput,
    __in                                        ULONG   cbInput,
    __in_opt                                    VOID    *pPaddingInfo,
    __inout_bcount_opt(cbIV)                    PUCHAR   pbIV,
    __in                                        ULONG   cbIV,
    __out_bcount_part_opt(cbOutput, *pcbResult) PUCHAR   pbOutput,
    __in                                        ULONG   cbOutput,
    __out                                       ULONG   *pcbResult,
    __in                                        ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptDecryptFn)(
    __inout                                     BCRYPT_KEY_HANDLE   hKey,
    __in_bcount(cbInput)                        PUCHAR   pbInput,
    __in                                        ULONG   cbInput,
    __in_opt                                    VOID    *pPaddingInfo,
    __inout_bcount_opt(cbIV)                    PUCHAR   pbIV,
    __in                                        ULONG   cbIV,
    __out_bcount_part_opt(cbOutput, *pcbResult) PUCHAR   pbOutput,
    __in                                        ULONG   cbOutput,
    __out                                       ULONG   *pcbResult,
    __in                                        ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptExportKey(
    __in                                        BCRYPT_KEY_HANDLE   hKey,
    __in_opt                                    BCRYPT_KEY_HANDLE   hExportKey,
    __in                                        LPCWSTR pszBlobType,
    __out_bcount_part_opt(cbOutput, *pcbResult) PUCHAR   pbOutput,
    __in                                        ULONG   cbOutput,
    __out                                       ULONG   *pcbResult,
    __in                                        ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptExportKeyFn)(
    __in                                        BCRYPT_KEY_HANDLE   hKey,
    __in_opt                                    BCRYPT_KEY_HANDLE   hExportKey,
    __in                                        LPCWSTR pszBlobType,
    __out_bcount_part_opt(cbOutput, *pcbResult) PUCHAR   pbOutput,
    __in                                        ULONG   cbOutput,
    __out                                       ULONG   *pcbResult,
    __in                                        ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptImportKey(
    __in                            BCRYPT_ALG_HANDLE hAlgorithm,
    __in_opt                        BCRYPT_KEY_HANDLE hImportKey,
    __in                            LPCWSTR pszBlobType,
    __out                           BCRYPT_KEY_HANDLE *phKey,
    __out_bcount_full(cbKeyObject)  PUCHAR   pbKeyObject,
    __in                            ULONG   cbKeyObject,
    __in_bcount(cbInput)            PUCHAR   pbInput,
    __in                            ULONG   cbInput,
    __in                            ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptImportKeyFn)(
    __in                            BCRYPT_ALG_HANDLE hAlgorithm,
    __in_opt                        BCRYPT_KEY_HANDLE hImportKey,
    __in                            LPCWSTR pszBlobType,
    __out                           BCRYPT_KEY_HANDLE *phKey,
    __out_bcount_full(cbKeyObject)  PUCHAR   pbKeyObject,
    __in                            ULONG   cbKeyObject,
    __in_bcount(cbInput)            PUCHAR   pbInput,
    __in                            ULONG   cbInput,
    __in                            ULONG   dwFlags);

// @@END_DDKSPLIT



#define BCRYPT_NO_KEY_VALIDATION    0x00000008

NTSTATUS
WINAPI
BCryptImportKeyPair(
    __in                            BCRYPT_ALG_HANDLE hAlgorithm,
    __in_opt                        BCRYPT_KEY_HANDLE hImportKey,
    __in                            LPCWSTR pszBlobType,
    __out                           BCRYPT_KEY_HANDLE *phKey,
    __in_bcount(cbInput)            PUCHAR   pbInput,
    __in                            ULONG   cbInput,
    __in                            ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptImportKeyPairFn)(
    __in                            BCRYPT_ALG_HANDLE hAlgorithm,
    __in_opt                        BCRYPT_KEY_HANDLE hImportKey,
    __in                            LPCWSTR pszBlobType,
    __out                           BCRYPT_KEY_HANDLE *phKey,
    __in_bcount(cbInput)            PUCHAR   pbInput,
    __in                            ULONG   cbInput,
    __in                            ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptDuplicateKey(
    __in                            BCRYPT_KEY_HANDLE   hKey,
    __out                           BCRYPT_KEY_HANDLE   *phNewKey,
    __out_bcount_full(cbKeyObject)  PUCHAR   pbKeyObject,
    __in                            ULONG   cbKeyObject,
    __in                            ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptDuplicateKeyFn)(
    __in                            BCRYPT_KEY_HANDLE   hKey,
    __out                           BCRYPT_KEY_HANDLE   *phNewKey,
    __out_bcount_full(cbKeyObject)  PUCHAR   pbKeyObject,
    __in                            ULONG   cbKeyObject,
    __in                            ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptFinalizeKeyPair(
    __inout BCRYPT_KEY_HANDLE   hKey,
    __in    ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptFinalizeKeyPairFn)(
    __inout BCRYPT_KEY_HANDLE   hKey,
    __in    ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptDestroyKey(
    __inout BCRYPT_KEY_HANDLE   hKey);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptDestroyKeyFn)(
    __inout BCRYPT_KEY_HANDLE hKey);

// @@END_DDKSPLIT


NTSTATUS
WINAPI
BCryptDestroySecret(
    __inout BCRYPT_SECRET_HANDLE   hSecret);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptDestroySecretFn)(
    __inout BCRYPT_SECRET_HANDLE hSecret);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptSignHash(
    __in                                        BCRYPT_KEY_HANDLE   hKey,
    __in_opt                                    VOID    *pPaddingInfo,
    __in_bcount(cbInput)                        PUCHAR   pbInput,
    __in                                        ULONG   cbInput,
    __out_bcount_part_opt(cbOutput, *pcbResult) PUCHAR   pbOutput,
    __in                                        ULONG   cbOutput,
    __out                                       ULONG   *pcbResult,
    __in                                        ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptSignHashFn)(
    __in                                        BCRYPT_KEY_HANDLE   hKey,
    __in_opt                                    VOID    *pPaddingInfo,
    __in_bcount(cbInput)                        PUCHAR   pbInput,
    __in                                        ULONG   cbInput,
    __out_bcount_part_opt(cbOutput, *pcbResult) PUCHAR   pbOutput,
    __in                                        ULONG   cbOutput,
    __out                                       ULONG   *pcbResult,
    __in                                        ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptVerifySignature(
    __in                        BCRYPT_KEY_HANDLE   hKey,
    __in_opt                    VOID    *pPaddingInfo,
    __in_bcount(cbHash)         PUCHAR   pbHash,
    __in                        ULONG   cbHash,
    __in_bcount(cbSignature)    PUCHAR   pbSignature,
    __in                        ULONG   cbSignature,
    __in                        ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptVerifySignatureFn)(
    __in                        BCRYPT_KEY_HANDLE   hKey,
    __in_opt                    VOID    *pPaddingInfo,
    __in_bcount(cbHash)         PUCHAR   pbHash,
    __in                        ULONG   cbHash,
    __in_bcount(cbSignature)    PUCHAR   pbSignature,
    __in                        ULONG   cbSignature,
    __in                        ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptSecretAgreement(
    __in    BCRYPT_KEY_HANDLE       hPrivKey,
    __in    BCRYPT_KEY_HANDLE       hPubKey,
    __out   BCRYPT_SECRET_HANDLE    *phAgreedSecret,
    __in    ULONG                   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptSecretAgreementFn)(
    __in    BCRYPT_KEY_HANDLE       hPrivKey,
    __in    BCRYPT_KEY_HANDLE       hPubKey,
    __out   BCRYPT_SECRET_HANDLE    *phAgreedSecret,
    __in    ULONG                   dwFlags);

// @@END_DDKSPLIT


NTSTATUS
WINAPI
BCryptDeriveKey(
    __in        BCRYPT_SECRET_HANDLE hSharedSecret,
    __in        LPCWSTR              pwszKDF,
    __in_opt    BCryptBufferDesc     *pParameterList,
    __out_bcount_part_opt(cbDerivedKey, *pcbResult) PUCHAR pbDerivedKey,
    __in        ULONG                cbDerivedKey,
    __out       ULONG                *pcbResult,
    __in        ULONG                dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptDeriveKeyFn)(
    __in        BCRYPT_SECRET_HANDLE hSharedSecret,
    __in        LPCWSTR              pwszKDF,
    __in_opt    BCryptBufferDesc     *pParameterList,
    __out_bcount_part_opt(cbDerivedKey, *pcbResult) PUCHAR pbDerivedKey,
    __in        ULONG                cbDerivedKey,
    __out       ULONG                *pcbResult,
    __in        ULONG                dwFlags);

// @@END_DDKSPLIT


//
// Primitive hashing functions.
//

NTSTATUS
WINAPI
BCryptCreateHash(
    __inout                         BCRYPT_ALG_HANDLE   hAlgorithm,
    __out                           BCRYPT_HASH_HANDLE  *phHash,
    __out_bcount_full(cbHashObject) PUCHAR   pbHashObject,
    __in                            ULONG   cbHashObject,
    __in_bcount_opt(cbSecret)       PUCHAR   pbSecret,   // optional
    __in                            ULONG   cbSecret,   // optional
    __in                            ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptCreateHashFn)(
    __inout                          BCRYPT_ALG_HANDLE   hAlgorithm,
    __out                           BCRYPT_HASH_HANDLE  *phHash,
    __out_bcount_full(cbHashObject) PUCHAR   pbHashObject,
    __in                            ULONG   cbHashObject,
    __in_bcount_opt(cbSecret)       PUCHAR   pbSecret,   // optional
    __in                            ULONG   cbSecret,   // optional
    __in                            ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptHashData(
    __inout                 BCRYPT_HASH_HANDLE  hHash,
    __in_bcount(cbInput)    PUCHAR   pbInput,
    __in                    ULONG   cbInput,
    __in                    ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptHashDataFn)(
    __inout                 BCRYPT_HASH_HANDLE hHash,
    __in_bcount(cbInput)    PUCHAR   pbInput,
    __in                    ULONG   cbInput,
    __in                    ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptFinishHash(
    __inout                     BCRYPT_HASH_HANDLE hHash,
    __out_bcount_full(cbOutput) PUCHAR   pbOutput,
    __in                        ULONG   cbOutput,
    __in                        ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptFinishHashFn)(
    __inout                     BCRYPT_HASH_HANDLE  hHash,
    __out_bcount_full(cbOutput) PUCHAR   pbOutput,
    __in                        ULONG   cbOutput,
    __in                        ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptDuplicateHash(
    __in                            BCRYPT_HASH_HANDLE  hHash,
    __out                           BCRYPT_HASH_HANDLE  *phNewHash,
    __out_bcount_full(cbHashObject) PUCHAR   pbHashObject,
    __in                            ULONG   cbHashObject,
    __in                            ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptDuplicateHashFn)(
    __in                            BCRYPT_HASH_HANDLE hHash,
    __out                           BCRYPT_HASH_HANDLE * phNewHash,
    __out_bcount_full(cbHashObject) PUCHAR pbHashObject,
    __in                            ULONG   cbHashObject,
    __in                            ULONG   dwFlags);

// @@END_DDKSPLIT



NTSTATUS
WINAPI
BCryptDestroyHash(
    __inout BCRYPT_HASH_HANDLE  hHash);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptDestroyHashFn)(
    __inout BCRYPT_HASH_HANDLE  hHash);

// @@END_DDKSPLIT



//
// Primitive random number generation.
//

// Flags to BCryptGenRandom
#define BCRYPT_RNG_USE_ENTROPY_IN_BUFFER    0x00000001
#define BCRYPT_USE_SYSTEM_PREFERRED_RNG     0x00000002

NTSTATUS
WINAPI
BCryptGenRandom(
    __inout                         BCRYPT_ALG_HANDLE   hAlgorithm,
    __inout_bcount_full(cbBuffer)   PUCHAR  pbBuffer,
    __in                            ULONG   cbBuffer,
    __in                            ULONG   dwFlags);

// @@BEGIN_DDKSPLIT
typedef NTSTATUS
(WINAPI * BCryptGenRandomFn)(
    __inout                         BCRYPT_ALG_HANDLE   hAlgorithm,
    __inout_bcount_full(cbBuffer)   PUCHAR   pbBuffer,
    __in                            ULONG   cbBuffer,
    __in                            ULONG   dwFlags);

// @@END_DDKSPLIT



//
// Interface version control...
//
typedef struct _BCRYPT_INTERFACE_VERSION
{
    USHORT MajorVersion;
    USHORT MinorVersion;

} BCRYPT_INTERFACE_VERSION, *PBCRYPT_INTERFACE_VERSION;

#define BCRYPT_MAKE_INTERFACE_VERSION(major,minor) {(USHORT)major, (USHORT)minor}

#define BCRYPT_IS_INTERFACE_VERSION_COMPATIBLE(loader, provider)    \
    ((loader).MajorVersion <= (provider).MajorVersion)

//
// Primitive provider interfaces.
//

#define BCRYPT_CIPHER_INTERFACE_VERSION_1    BCRYPT_MAKE_INTERFACE_VERSION(1,0)

// @@BEGIN_DDKSPLIT
typedef struct _BCRYPT_CIPHER_FUNCTION_TABLE
{
    BCRYPT_INTERFACE_VERSION        Version;
    BCryptOpenAlgorithmProviderFn   OpenAlgorithmProvider;
    BCryptGetPropertyFn             GetProperty;
    BCryptSetPropertyFn             SetProperty;
    BCryptCloseAlgorithmProviderFn  CloseAlgorithmProvider;
    BCryptGenerateSymmetricKeyFn    GenerateKey;
    BCryptEncryptFn                 Encrypt;
    BCryptDecryptFn                 Decrypt;
    BCryptImportKeyFn               ImportKey;
    BCryptExportKeyFn               ExportKey;
    BCryptDuplicateKeyFn            DuplicateKey;
    BCryptDestroyKeyFn              DestroyKey;
} BCRYPT_CIPHER_FUNCTION_TABLE;

NTSTATUS
WINAPI
GetCipherInterface(
    __in    LPCWSTR pszProviderName,
    __in    LPCWSTR pszAlgId,
    __out   BCRYPT_CIPHER_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG dwFlags);

typedef NTSTATUS
(WINAPI * GetCipherInterfaceFn)(
    __in    LPCWSTR pszProviderName,
    __in    LPCWSTR pszAlgId,
    __out   BCRYPT_CIPHER_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG dwFlags);

// @@END_DDKSPLIT

#define BCRYPT_HASH_INTERFACE_VERSION_1    BCRYPT_MAKE_INTERFACE_VERSION(1,0)

// @@BEGIN_DDKSPLIT
typedef struct _BCRYPT_HASH_FUNCTION_TABLE
{
    BCRYPT_INTERFACE_VERSION        Version;
    BCryptOpenAlgorithmProviderFn   OpenAlgorithmProvider;
    BCryptGetPropertyFn             GetProperty;
    BCryptSetPropertyFn             SetProperty;
    BCryptCloseAlgorithmProviderFn  CloseAlgorithmProvider;
    BCryptCreateHashFn              CreateHash;
    BCryptHashDataFn                HashData;
    BCryptFinishHashFn              FinishHash;
    BCryptDuplicateHashFn           DuplicateHash;
    BCryptDestroyHashFn             DestroyHash;
} BCRYPT_HASH_FUNCTION_TABLE;

NTSTATUS
WINAPI
GetHashInterface(
    __in    LPCWSTR pszProviderName,
    __in    LPCWSTR pszAlgId,
    __out   BCRYPT_HASH_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG   dwFlags);

typedef NTSTATUS
(WINAPI * GetHashInterfaceFn)(
    __in    LPCWSTR pszProviderName,
    __in    LPCWSTR pszAlgId,
    __out   BCRYPT_HASH_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG dwFlags);
// @@END_DDKSPLIT

#define BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE_VERSION_1    BCRYPT_MAKE_INTERFACE_VERSION(1,0)

// @@BEGIN_DDKSPLIT
typedef struct _BCRYPT_ASYMMETRIC_ENCRYPTION_FUNCTION_TABLE
{
    BCRYPT_INTERFACE_VERSION        Version;
    BCryptOpenAlgorithmProviderFn   OpenAlgorithmProvider;
    BCryptGetPropertyFn             GetProperty;
    BCryptSetPropertyFn             SetProperty;
    BCryptCloseAlgorithmProviderFn  CloseAlgorithmProvider;
    BCryptGenerateKeyPairFn         GenerateKeyPair;
    BCryptFinalizeKeyPairFn         FinalizeKeyPair;
    BCryptEncryptFn                 Encrypt;
    BCryptDecryptFn                 Decrypt;
    BCryptImportKeyPairFn           ImportKeyPair;
    BCryptExportKeyFn               ExportKey;
    BCryptDestroyKeyFn              DestroyKey;
    BCryptSignHashFn                SignHash;
    BCryptVerifySignatureFn         VerifySignature;
} BCRYPT_ASYMMETRIC_ENCRYPTION_FUNCTION_TABLE;

NTSTATUS
WINAPI
GetAsymmetricEncryptionInterface(
    __in    LPCWSTR pszProviderName,
    __in    LPCWSTR pszAlgId,
    __out   BCRYPT_ASYMMETRIC_ENCRYPTION_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG   dwFlags);

typedef NTSTATUS
(WINAPI * GetAsymmetricEncryptionInterfaceFn)(
    __in    LPCWSTR pszProviderName,
    __in    LPCWSTR pszAlgId,
    __out   BCRYPT_ASYMMETRIC_ENCRYPTION_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG dwFlags);

// @@END_DDKSPLIT

#define BCRYPT_SECRET_AGREEMENT_INTERFACE_VERSION_1    BCRYPT_MAKE_INTERFACE_VERSION(1,0)

// @@BEGIN_DDKSPLIT
typedef struct _BCRYPT_SECRET_AGREEMENT_FUNCTION_TABLE
{
    BCRYPT_INTERFACE_VERSION        Version;
    BCryptOpenAlgorithmProviderFn   OpenAlgorithmProvider;
    BCryptGetPropertyFn             GetProperty;
    BCryptSetPropertyFn             SetProperty;
    BCryptCloseAlgorithmProviderFn  CloseAlgorithmProvider;
    BCryptSecretAgreementFn         SecretAgreement;
    BCryptDeriveKeyFn               DeriveKey;
    BCryptDestroySecretFn           DestroySecret;
    BCryptGenerateKeyPairFn         GenerateKeyPair;
    BCryptFinalizeKeyPairFn         FinalizeKeyPair;
    BCryptImportKeyPairFn           ImportKeyPair;
    BCryptExportKeyFn               ExportKey;
    BCryptDestroyKeyFn              DestroyKey;
} BCRYPT_SECRET_AGREEMENT_FUNCTION_TABLE;

NTSTATUS
WINAPI
GetSecretAgreementInterface(
    __in    LPCWSTR pszProviderName,
    __in    LPCWSTR pszAlgId,
    __out   BCRYPT_SECRET_AGREEMENT_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG   dwFlags);

typedef NTSTATUS
(WINAPI * GetSecretAgreementInterfaceFn)(
    __in    LPCWSTR pszProviderName,
    __in    LPCWSTR pszAlgId,
    __out   BCRYPT_SECRET_AGREEMENT_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG dwFlags);

// @@END_DDKSPLIT

#define BCRYPT_SIGNATURE_INTERFACE_VERSION_1    BCRYPT_MAKE_INTERFACE_VERSION(1,0)

// @@BEGIN_DDKSPLIT
typedef struct _BCRYPT_SIGNATURE_FUNCTION_TABLE
{
    BCRYPT_INTERFACE_VERSION        Version;
    BCryptOpenAlgorithmProviderFn   OpenAlgorithmProvider;
    BCryptGetPropertyFn             GetProperty;
    BCryptSetPropertyFn             SetProperty;
    BCryptCloseAlgorithmProviderFn  CloseAlgorithmProvider;
    BCryptGenerateKeyPairFn         GenerateKeyPair;
    BCryptFinalizeKeyPairFn         FinalizeKeyPair;
    BCryptSignHashFn                SignHash;
    BCryptVerifySignatureFn         VerifySignature;
    BCryptImportKeyPairFn           ImportKeyPair;
    BCryptExportKeyFn               ExportKey;
    BCryptDestroyKeyFn              DestroyKey;
} BCRYPT_SIGNATURE_FUNCTION_TABLE;

NTSTATUS
WINAPI
GetSignatureInterface(
    __in    LPCWSTR pszProviderName,
    __in    LPCWSTR pszAlgId,
    __out   BCRYPT_SIGNATURE_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG   dwFlags);

typedef NTSTATUS
(WINAPI * GetSignatureInterfaceFn)(
    __in    LPCWSTR pszProviderName,
    __in    LPCWSTR pszAlgId,
    __out   BCRYPT_SIGNATURE_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG dwFlags);
// @@END_DDKSPLIT

#define BCRYPT_RNG_INTERFACE_VERSION_1    BCRYPT_MAKE_INTERFACE_VERSION(1,0)

// @@BEGIN_DDKSPLIT
typedef struct _BCRYPT_RNG_FUNCTION_TABLE
{
    BCRYPT_INTERFACE_VERSION        Version;
    BCryptOpenAlgorithmProviderFn   OpenAlgorithmProvider;
    BCryptGetPropertyFn             GetProperty;
    BCryptSetPropertyFn             SetProperty;
    BCryptCloseAlgorithmProviderFn  CloseAlgorithmProvider;
    BCryptGenRandomFn               GenRandom;
} BCRYPT_RNG_FUNCTION_TABLE;

NTSTATUS
WINAPI
GetRngInterface(
    __in    LPCWSTR pszProviderName,
    __out   BCRYPT_RNG_FUNCTION_TABLE   **ppFunctionTable,
    __in    ULONG   dwFlags);

typedef NTSTATUS
(WINAPI * GetRngInterfaceFn)(
    __in    LPCWSTR pszProviderName,
    __out   BCRYPT_RNG_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG dwFlags);

// @@END_DDKSPLIT

//////////////////////////////////////////////////////////////////////////////
// CryptoConfig Definitions //////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// Interface registration flags
#define CRYPT_MIN_DEPENDENCIES      (0x00000001)
#define CRYPT_PROCESS_ISOLATE       (0x00010000) // User-mode only

// Processor modes supported by a provider
//
// (Valid for BCryptQueryProviderRegistration and BCryptResolveProviders):
//
#define CRYPT_UM                    (0x00000001)    // User mode only
#define CRYPT_KM                    (0x00000002)    // Kernel mode only
#define CRYPT_MM                    (0x00000003)    // Multi-mode: Must support BOTH UM and KM
//
// (Valid only for BCryptQueryProviderRegistration):
//
#define CRYPT_ANY                   (0x00000004)    // Wildcard: Either UM, or KM, or both


// Write behavior flags
#define CRYPT_OVERWRITE             (0x00000001)

// Configuration tables
#define CRYPT_LOCAL                 (0x00000001)
#define CRYPT_DOMAIN                (0x00000002)

// Context configuration flags
#define CRYPT_EXCLUSIVE             (0x00000001)
#define CRYPT_OVERRIDE              (0x00010000) // Enterprise table only

// Resolution and enumeration flags
#define CRYPT_ALL_FUNCTIONS         (0x00000001)
#define CRYPT_ALL_PROVIDERS         (0x00000002)

// Priority list positions
#define CRYPT_PRIORITY_TOP          (0x00000000)
#define CRYPT_PRIORITY_BOTTOM       (0xFFFFFFFF)

// Default system-wide context
#define CRYPT_DEFAULT_CONTEXT       L"Default"

//////////////////////////////////////////////////////////////////////////////
// CryptoConfig Structures ///////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//
// Provider Registration Structures
//

typedef struct _CRYPT_INTERFACE_REG
{
    ULONG dwInterface;
    ULONG dwFlags;

    ULONG cFunctions;
    PWSTR *rgpszFunctions;
}
CRYPT_INTERFACE_REG, *PCRYPT_INTERFACE_REG;

typedef struct _CRYPT_IMAGE_REG
{
    PWSTR pszImage;

    ULONG cInterfaces;
    PCRYPT_INTERFACE_REG *rgpInterfaces;
}
CRYPT_IMAGE_REG, *PCRYPT_IMAGE_REG;

typedef struct _CRYPT_PROVIDER_REG
{
    ULONG cAliases;
    PWSTR *rgpszAliases;
    
    PCRYPT_IMAGE_REG pUM;
    PCRYPT_IMAGE_REG pKM;
}
CRYPT_PROVIDER_REG, *PCRYPT_PROVIDER_REG;

typedef struct _CRYPT_PROVIDERS
{
    ULONG cProviders;
    PWSTR *rgpszProviders;
}
CRYPT_PROVIDERS, *PCRYPT_PROVIDERS;

//
// Context Configuration Structures
//

typedef struct _CRYPT_CONTEXT_CONFIG
{
    ULONG dwFlags;
    ULONG dwReserved;
}
CRYPT_CONTEXT_CONFIG, *PCRYPT_CONTEXT_CONFIG;

typedef struct _CRYPT_CONTEXT_FUNCTION_CONFIG
{
    ULONG dwFlags;
    ULONG dwReserved;
}
CRYPT_CONTEXT_FUNCTION_CONFIG, *PCRYPT_CONTEXT_FUNCTION_CONFIG;

typedef struct _CRYPT_CONTEXTS
{
    ULONG cContexts;
    PWSTR *rgpszContexts;
}
CRYPT_CONTEXTS, *PCRYPT_CONTEXTS;

typedef struct _CRYPT_CONTEXT_FUNCTIONS
{
    ULONG cFunctions;
    PWSTR *rgpszFunctions;
}
CRYPT_CONTEXT_FUNCTIONS, *PCRYPT_CONTEXT_FUNCTIONS;

typedef struct _CRYPT_CONTEXT_FUNCTION_PROVIDERS
{
    ULONG cProviders;
    PWSTR *rgpszProviders;
}
CRYPT_CONTEXT_FUNCTION_PROVIDERS, *PCRYPT_CONTEXT_FUNCTION_PROVIDERS;

//
// Provider Resolution Structures
//

typedef struct _CRYPT_PROPERTY_REF
{
    PWSTR pszProperty;

    ULONG cbValue;
    PUCHAR pbValue;
}
CRYPT_PROPERTY_REF, *PCRYPT_PROPERTY_REF;

typedef struct _CRYPT_IMAGE_REF
{
    PWSTR pszImage;
    ULONG dwFlags;
}
CRYPT_IMAGE_REF, *PCRYPT_IMAGE_REF;

typedef struct _CRYPT_PROVIDER_REF
{
    ULONG dwInterface;
    PWSTR pszFunction;
    PWSTR pszProvider;

    ULONG cProperties;
    PCRYPT_PROPERTY_REF *rgpProperties;

    PCRYPT_IMAGE_REF pUM;
    PCRYPT_IMAGE_REF pKM;
}
CRYPT_PROVIDER_REF, *PCRYPT_PROVIDER_REF;

typedef struct _CRYPT_PROVIDER_REFS
{
    ULONG cProviders;
    PCRYPT_PROVIDER_REF *rgpProviders;
}
CRYPT_PROVIDER_REFS, *PCRYPT_PROVIDER_REFS;

//////////////////////////////////////////////////////////////////////////////
// CryptoConfig Functions ////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#ifndef KERNEL_MODE_CNG

// @@BEGIN_DDKSPLIT
//
// Provider Registration Functions
//

NTSTATUS
WINAPI
BCryptRegisterProvider(
    __in LPCWSTR pszProvider,
    __in ULONG dwFlags,
    __in PCRYPT_PROVIDER_REG pReg);

NTSTATUS
WINAPI
BCryptUnregisterProvider(
    __in LPCWSTR pszProvider);

// @@END_DDKSPLIT

NTSTATUS
WINAPI
BCryptQueryProviderRegistration(
    __in LPCWSTR pszProvider,
    __in ULONG dwMode,
    __in ULONG dwInterface,
    __inout ULONG* pcbBuffer,
    __deref_opt_inout_bcount_part_opt(*pcbBuffer, *pcbBuffer) PCRYPT_PROVIDER_REG *ppBuffer);

NTSTATUS
WINAPI
BCryptEnumRegisteredProviders(
    __inout ULONG* pcbBuffer,
    __deref_opt_inout_bcount_part_opt(*pcbBuffer, *pcbBuffer) PCRYPT_PROVIDERS *ppBuffer);

//
// Context Configuration Functions
//

NTSTATUS
WINAPI
BCryptCreateContext(
    __in ULONG dwTable,
    __in LPCWSTR pszContext,
    __in_opt PCRYPT_CONTEXT_CONFIG pConfig); // Optional

NTSTATUS
WINAPI
BCryptDeleteContext(
    __in ULONG dwTable,
    __in LPCWSTR pszContext);

NTSTATUS
WINAPI
BCryptEnumContexts(
    __in ULONG dwTable,
    __inout ULONG* pcbBuffer,
    __deref_opt_inout_bcount_part_opt(*pcbBuffer, *pcbBuffer) PCRYPT_CONTEXTS *ppBuffer);

NTSTATUS
WINAPI
BCryptConfigureContext(
    __in ULONG dwTable,
    __in LPCWSTR pszContext,
    __in PCRYPT_CONTEXT_CONFIG pConfig);

NTSTATUS
WINAPI
BCryptQueryContextConfiguration(
    __in ULONG dwTable,
    __in LPCWSTR pszContext,
    __inout ULONG* pcbBuffer,
    __deref_opt_inout_bcount_part_opt(*pcbBuffer, *pcbBuffer) PCRYPT_CONTEXT_CONFIG *ppBuffer);

NTSTATUS
WINAPI
BCryptAddContextFunction(
    __in ULONG dwTable,
    __in LPCWSTR pszContext,
    __in ULONG dwInterface,
    __in LPCWSTR pszFunction,
    __in ULONG dwPosition);

NTSTATUS
WINAPI
BCryptRemoveContextFunction(
    __in ULONG dwTable,
    __in LPCWSTR pszContext,
    __in ULONG dwInterface,
    __in LPCWSTR pszFunction);

NTSTATUS
WINAPI
BCryptEnumContextFunctions(
    __in ULONG dwTable,
    __in LPCWSTR pszContext,
    __in ULONG dwInterface,
    __inout ULONG* pcbBuffer,
    __deref_opt_inout_bcount_part_opt(*pcbBuffer, *pcbBuffer) PCRYPT_CONTEXT_FUNCTIONS *ppBuffer);

NTSTATUS
WINAPI
BCryptConfigureContextFunction(
    __in ULONG dwTable,
    __in LPCWSTR pszContext,
    __in ULONG dwInterface,
    __in LPCWSTR pszFunction,
    __in PCRYPT_CONTEXT_FUNCTION_CONFIG pConfig);

NTSTATUS
WINAPI
BCryptQueryContextFunctionConfiguration(
    __in ULONG dwTable,
    __in LPCWSTR pszContext,
    __in ULONG dwInterface,
    __in LPCWSTR pszFunction,
    __inout ULONG* pcbBuffer,
    __deref_opt_inout_bcount_part_opt(*pcbBuffer, *pcbBuffer) PCRYPT_CONTEXT_FUNCTION_CONFIG *ppBuffer);

// @@BEGIN_DDKSPLIT

NTSTATUS
WINAPI
BCryptAddContextFunctionProvider(
    __in ULONG dwTable,
    __in LPCWSTR pszContext,
    __in ULONG dwInterface,
    __in LPCWSTR pszFunction,
    __in LPCWSTR pszProvider,
    __in ULONG dwPosition);

NTSTATUS
WINAPI
BCryptRemoveContextFunctionProvider(
    __in ULONG dwTable,
    __in LPCWSTR pszContext,
    __in ULONG dwInterface,
    __in LPCWSTR pszFunction,
    __in LPCWSTR pszProvider);

// @@END_DDKSPLIT

NTSTATUS
WINAPI
BCryptEnumContextFunctionProviders(
    __in ULONG dwTable,
    __in LPCWSTR pszContext,
    __in ULONG dwInterface,
    __in LPCWSTR pszFunction,
    __inout ULONG* pcbBuffer,
    __deref_opt_inout_bcount_part_opt(*pcbBuffer, *pcbBuffer) PCRYPT_CONTEXT_FUNCTION_PROVIDERS *ppBuffer);

NTSTATUS
WINAPI
BCryptSetContextFunctionProperty(
    __in ULONG dwTable,
    __in LPCWSTR pszContext,
    __in ULONG dwInterface,
    __in LPCWSTR pszFunction,
    __in LPCWSTR pszProperty,
    __in ULONG cbValue,
    __in_bcount_opt(cbValue) PUCHAR pbValue);

NTSTATUS
WINAPI
BCryptQueryContextFunctionProperty(
    __in ULONG dwTable,
    __in LPCWSTR pszContext,
    __in ULONG dwInterface,
    __in LPCWSTR pszFunction,
    __in LPCWSTR pszProperty,
    __inout ULONG* pcbValue,
    __deref_opt_inout_bcount_part_opt(*pcbValue, *pcbValue) PUCHAR *ppbValue);

#endif //#ifndef KERNEL_MODE_CNG

//
// Configuration Change Notification Functions
//

#ifdef KERNEL_MODE_CNG
NTSTATUS
WINAPI
BCryptRegisterConfigChangeNotify(
    __in PRKEVENT pEvent);
#else
NTSTATUS
WINAPI
BCryptRegisterConfigChangeNotify(
    __out HANDLE *phEvent);
#endif

#ifdef KERNEL_MODE_CNG
NTSTATUS
WINAPI
BCryptUnregisterConfigChangeNotify(
    __in PRKEVENT pEvent);
#else
NTSTATUS
WINAPI
BCryptUnregisterConfigChangeNotify(
    __in HANDLE hEvent);
#endif

//
// Provider Resolution Functions
//

NTSTATUS WINAPI
BCryptResolveProviders(
    __in_opt LPCWSTR pszContext,
    __in_opt ULONG dwInterface,
    __in_opt LPCWSTR pszFunction,
    __in_opt LPCWSTR pszProvider,
    __in ULONG dwMode,
    __in ULONG dwFlags,
    __inout ULONG* pcbBuffer,
    __deref_opt_inout_bcount_part_opt(*pcbBuffer, *pcbBuffer) PCRYPT_PROVIDER_REFS *ppBuffer);


//
// Miscellaneous queries about the crypto environment
//

NTSTATUS
WINAPI
BCryptGetFipsAlgorithmMode(
    __out BOOLEAN *pfEnabled
    );


#ifdef __cplusplus
}
#endif

#endif // __BCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\bthapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* Compiler settings for BthAPI.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __BthAPI_h__
#define __BthAPI_h__

/* Forward Declarations */ 

#ifndef __ISdpWalk_FWD_DEFINED__
#define __ISdpWalk_FWD_DEFINED__
typedef interface ISdpWalk ISdpWalk;
#endif 	/* __ISdpWalk_FWD_DEFINED__ */


#ifndef __ISdpNodeContainer_FWD_DEFINED__
#define __ISdpNodeContainer_FWD_DEFINED__
typedef interface ISdpNodeContainer ISdpNodeContainer;
#endif 	/* __ISdpNodeContainer_FWD_DEFINED__ */


#ifndef __ISdpSearch_FWD_DEFINED__
#define __ISdpSearch_FWD_DEFINED__
typedef interface ISdpSearch ISdpSearch;
#endif 	/* __ISdpSearch_FWD_DEFINED__ */


#ifndef __ISdpStream_FWD_DEFINED__
#define __ISdpStream_FWD_DEFINED__
typedef interface ISdpStream ISdpStream;
#endif 	/* __ISdpStream_FWD_DEFINED__ */


#ifndef __ISdpRecord_FWD_DEFINED__
#define __ISdpRecord_FWD_DEFINED__
typedef interface ISdpRecord ISdpRecord;
#endif 	/* __ISdpRecord_FWD_DEFINED__ */


#ifndef __IBluetoothDevice_FWD_DEFINED__
#define __IBluetoothDevice_FWD_DEFINED__
typedef interface IBluetoothDevice IBluetoothDevice;
#endif 	/* __IBluetoothDevice_FWD_DEFINED__ */


#ifndef __IBluetoothAuthenticate_FWD_DEFINED__
#define __IBluetoothAuthenticate_FWD_DEFINED__
typedef interface IBluetoothAuthenticate IBluetoothAuthenticate;
#endif 	/* __IBluetoothAuthenticate_FWD_DEFINED__ */


#ifndef __SdpNodeContainer_FWD_DEFINED__
#define __SdpNodeContainer_FWD_DEFINED__

#ifdef __cplusplus
typedef class SdpNodeContainer SdpNodeContainer;
#else
typedef struct SdpNodeContainer SdpNodeContainer;
#endif /* __cplusplus */

#endif 	/* __SdpNodeContainer_FWD_DEFINED__ */


#ifndef __SdpSearch_FWD_DEFINED__
#define __SdpSearch_FWD_DEFINED__

#ifdef __cplusplus
typedef class SdpSearch SdpSearch;
#else
typedef struct SdpSearch SdpSearch;
#endif /* __cplusplus */

#endif 	/* __SdpSearch_FWD_DEFINED__ */


#ifndef __SdpWalk_FWD_DEFINED__
#define __SdpWalk_FWD_DEFINED__

#ifdef __cplusplus
typedef class SdpWalk SdpWalk;
#else
typedef struct SdpWalk SdpWalk;
#endif /* __cplusplus */

#endif 	/* __SdpWalk_FWD_DEFINED__ */


#ifndef __SdpStream_FWD_DEFINED__
#define __SdpStream_FWD_DEFINED__

#ifdef __cplusplus
typedef class SdpStream SdpStream;
#else
typedef struct SdpStream SdpStream;
#endif /* __cplusplus */

#endif 	/* __SdpStream_FWD_DEFINED__ */


#ifndef __SdpRecord_FWD_DEFINED__
#define __SdpRecord_FWD_DEFINED__

#ifdef __cplusplus
typedef class SdpRecord SdpRecord;
#else
typedef struct SdpRecord SdpRecord;
#endif /* __cplusplus */

#endif 	/* __SdpRecord_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_BthAPI_0000 */
/* [local] */ 

//
// Copyright (C) Microsoft Corporation, All rights reserved.
//
#ifndef __BTHSDPDEF_H__
struct SDP_LARGE_INTEGER_16
    {
    ULONGLONG LowPart;
    LONGLONG HighPart;
    };
struct SDP_ULARGE_INTEGER_16
    {
    ULONGLONG LowPart;
    ULONGLONG HighPart;
    };
typedef struct SDP_ULARGE_INTEGER_16 SDP_ULARGE_INTEGER_16;

typedef struct SDP_ULARGE_INTEGER_16 __RPC_FAR *PSDP_ULARGE_INTEGER_16;

typedef struct SDP_ULARGE_INTEGER_16 __RPC_FAR *LPSDP_ULARGE_INTEGER_16;

typedef struct SDP_LARGE_INTEGER_16 SDP_LARGE_INTEGER_16;

typedef struct SDP_LARGE_INTEGER_16 __RPC_FAR *PSDP_LARGE_INTEGER_16;

typedef struct SDP_LARGE_INTEGER_16 __RPC_FAR *LPSDP_LARGE_INTEGER_16;


enum NodeContainerType
    {	NodeContainerTypeSequence	= 0,
	NodeContainerTypeAlternative	= NodeContainerTypeSequence + 1
    };
typedef enum NodeContainerType NodeContainerType;

typedef USHORT SDP_ERROR;

typedef USHORT __RPC_FAR *PSDP_ERROR;


enum SDP_TYPE
    {	SDP_TYPE_NIL	= 0,
	SDP_TYPE_UINT	= 0x1,
	SDP_TYPE_INT	= 0x2,
	SDP_TYPE_UUID	= 0x3,
	SDP_TYPE_STRING	= 0x4,
	SDP_TYPE_BOOLEAN	= 0x5,
	SDP_TYPE_SEQUENCE	= 0x6,
	SDP_TYPE_ALTERNATIVE	= 0x7,
	SDP_TYPE_URL	= 0x8,
	SDP_TYPE_CONTAINER	= 0x20
    };
typedef enum SDP_TYPE SDP_TYPE;


enum SDP_SPECIFICTYPE
    {	SDP_ST_NONE	= 0,
	SDP_ST_UINT8	= 0x10,
	SDP_ST_UINT16	= 0x110,
	SDP_ST_UINT32	= 0x210,
	SDP_ST_UINT64	= 0x310,
	SDP_ST_UINT128	= 0x410,
	SDP_ST_INT8	= 0x20,
	SDP_ST_INT16	= 0x120,
	SDP_ST_INT32	= 0x220,
	SDP_ST_INT64	= 0x320,
	SDP_ST_INT128	= 0x420,
	SDP_ST_UUID16	= 0x130,
	SDP_ST_UUID32	= 0x230,
	SDP_ST_UUID128	= 0x430
    };
typedef enum SDP_SPECIFICTYPE SDP_SPECIFICTYPE;

typedef struct _SdpAttributeRange
    {
    USHORT minAttribute;
    USHORT maxAttribute;
    }	SdpAttributeRange;

typedef /* [switch_type] */ union SdpQueryUuidUnion
    {
    /* [case()] */ GUID uuid128;
    /* [case()] */ ULONG uuid32;
    /* [case()] */ USHORT uuid16;
    }	SdpQueryUuidUnion;

typedef struct _SdpQueryUuid
    {
    /* [switch_is] */ SdpQueryUuidUnion u;
    USHORT uuidType;
    }	SdpQueryUuid;

#define BTH_SDP_VERSION 1
typedef struct _BTHNS_SETBLOB
    {
    ULONG __RPC_FAR *pSdpVersion;
    ULONG __RPC_FAR *pRecordHandle;
    ULONG Reserved[ 4 ];
    ULONG fSecurity;
    ULONG fOptions;
    ULONG ulRecordLength;
    UCHAR pRecord[ 1 ];
    }	BTHNS_SETBLOB;

typedef struct _BTHNS_SETBLOB __RPC_FAR *PBTHNS_SETBLOB;

#define MAX_UUIDS_IN_QUERY 12
#define SDP_SERVICE_SEARCH_REQUEST           1
#define SDP_SERVICE_ATTRIBUTE_REQUEST        2
#define SDP_SERVICE_SEARCH_ATTRIBUTE_REQUEST 3
 
//
// The following may be passed as parameters to BthNsLookupServiceNext as extended 
// dwFlags options for device inquiry.
//
 
// Causes traversal through list to be reset to first element.
#define BTHNS_LUP_RESET_ITERATOR 0x00010000
// Does not increment list, causes next query to be performed on current item as well.
#define BTHNS_LUP_NO_ADVANCE     0x00020000
// Causes LookupServiceEnd to abort current inquiry.
#define BTHNS_ABORT_CURRENT_INQUIRY 0xfffffffd
 
typedef struct _BTHNS_INQUIRYBLOB
    {
    ULONG LAP;
    unsigned char length;
    unsigned char num_responses;
    }	BTHNS_INQUIRYBLOB;

typedef struct _BTHNS_INQUIRYBLOB __RPC_FAR *PBTHNS_INQUIRYBLOB;

typedef struct _BTHNS_RESTRICTIONBLOB
    {
    ULONG type;
    ULONG serviceHandle;
    SdpQueryUuid uuids[ 12 ];
    ULONG numRange;
    SdpAttributeRange pRange[ 1 ];
    }	BTHNS_RESTRICTIONBLOB;

typedef struct _BTHNS_RESTRICTIONBLOB __RPC_FAR *PBTHNS_RESTRICTIONBLOB;

#define __BTHSDPDEF_H__
#endif


struct SdpString
    {
    /* [size_is] */ CHAR __RPC_FAR *val;
    ULONG length;
    };
typedef struct SdpString SdpString;

typedef /* [switch_type] */ union NodeDataUnion
    {
    /* [case()] */ SDP_LARGE_INTEGER_16 int128;
    /* [case()] */ SDP_ULARGE_INTEGER_16 uint128;
    /* [case()] */ GUID uuid128;
    /* [case()] */ ULONG uuid32;
    /* [case()] */ USHORT uuid16;
    /* [case()] */ LONGLONG int64;
    /* [case()] */ ULONGLONG uint64;
    /* [case()] */ LONG int32;
    /* [case()] */ ULONG uint32;
    /* [case()] */ SHORT int16;
    /* [case()] */ USHORT uint16;
    /* [case()] */ CHAR int8;
    /* [case()] */ UCHAR uint8;
    /* [case()] */ UCHAR booleanVal;
    /* [case()] */ SdpString str;
    /* [case()] */ SdpString url;
    /* [case()] */ ISdpNodeContainer __RPC_FAR *container;
    /* [case()] */  /* Empty union arm */ 
    }	NodeDataUnion;

typedef struct NodeData
    {
    USHORT type;
    USHORT specificType;
    /* [switch_is] */ NodeDataUnion u;
    }	NodeData;


enum BthDeviceStringType
    {	BthDeviceStringTypeFriendlyName	= 0,
	BthDeviceStringTypeDeviceName	= BthDeviceStringTypeFriendlyName + 1,
	BthDeviceStringTypeDisplay	= BthDeviceStringTypeDeviceName + 1,
	BthDeviceStringTypeClass	= BthDeviceStringTypeDisplay + 1,
	BthDeviceStringTypeAddress	= BthDeviceStringTypeClass + 1
    };
#ifndef __BTHDEVICEINFO_DEFINED__
#define __BTHDEVICEINFO_DEFINED__
#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(1)
typedef struct _BthDeviceInfo
    {
    ULONGLONG btAddress;
    ULONG cod;
    ULONGLONG lmpSupportedFeatures;
    CHAR name[ 248 ];
    }	BthDeviceInfo;

#pragma warning(disable:4103)

#pragma pack(pop)
#endif // __BTHDEVICEINFO_DEFINED__


extern RPC_IF_HANDLE __MIDL_itf_BthAPI_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_BthAPI_0000_v0_0_s_ifspec;

#ifndef __ISdpWalk_INTERFACE_DEFINED__
#define __ISdpWalk_INTERFACE_DEFINED__

/* interface ISdpWalk */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISdpWalk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("57134AE6-5D3C-462D-BF2F-810361FBD7E7")
    ISdpWalk : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WalkNode( 
            /* [in] */ NodeData __RPC_FAR *pData,
            /* [in] */ ULONG state) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WalkStream( 
            /* [in] */ UCHAR elementType,
            /* [in] */ ULONG elementSize,
            /* [size_is][in] */ UCHAR __RPC_FAR *pStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISdpWalkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISdpWalk __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISdpWalk __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISdpWalk __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WalkNode )( 
            ISdpWalk __RPC_FAR * This,
            /* [in] */ NodeData __RPC_FAR *pData,
            /* [in] */ ULONG state);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WalkStream )( 
            ISdpWalk __RPC_FAR * This,
            /* [in] */ UCHAR elementType,
            /* [in] */ ULONG elementSize,
            /* [size_is][in] */ UCHAR __RPC_FAR *pStream);
        
        END_INTERFACE
    } ISdpWalkVtbl;

    interface ISdpWalk
    {
        CONST_VTBL struct ISdpWalkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISdpWalk_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISdpWalk_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISdpWalk_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISdpWalk_WalkNode(This,pData,state)	\
    (This)->lpVtbl -> WalkNode(This,pData,state)

#define ISdpWalk_WalkStream(This,elementType,elementSize,pStream)	\
    (This)->lpVtbl -> WalkStream(This,elementType,elementSize,pStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpWalk_WalkNode_Proxy( 
    ISdpWalk __RPC_FAR * This,
    /* [in] */ NodeData __RPC_FAR *pData,
    /* [in] */ ULONG state);


void __RPC_STUB ISdpWalk_WalkNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpWalk_WalkStream_Proxy( 
    ISdpWalk __RPC_FAR * This,
    /* [in] */ UCHAR elementType,
    /* [in] */ ULONG elementSize,
    /* [size_is][in] */ UCHAR __RPC_FAR *pStream);


void __RPC_STUB ISdpWalk_WalkStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISdpWalk_INTERFACE_DEFINED__ */


#ifndef __ISdpNodeContainer_INTERFACE_DEFINED__
#define __ISdpNodeContainer_INTERFACE_DEFINED__

/* interface ISdpNodeContainer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISdpNodeContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43F6ED49-6E22-4F81-A8EB-DCED40811A77")
    ISdpNodeContainer : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [out] */ UCHAR __RPC_FAR *__RPC_FAR *ppStream,
            /* [out] */ ULONG __RPC_FAR *pSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WriteStream( 
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ ULONG __RPC_FAR *pNumBytesWritten) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendNode( 
            /* [in] */ NodeData __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ NodeContainerType __RPC_FAR *pType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ NodeContainerType type) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Walk( 
            /* [in] */ ISdpWalk __RPC_FAR *pWalk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetNode( 
            /* [in] */ ULONG nodeIndex,
            /* [in] */ NodeData __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNode( 
            /* [in] */ ULONG nodeIndex,
            /* [out] */ NodeData __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LockContainer( 
            /* [in] */ UCHAR lock) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNodeCount( 
            /* [out] */ ULONG __RPC_FAR *pNodeCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateFromStream( 
            /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNodeStringData( 
            /* [in] */ ULONG nodeIndex,
            /* [out][in] */ NodeData __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStreamSize( 
            /* [out] */ ULONG __RPC_FAR *pSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISdpNodeContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISdpNodeContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISdpNodeContainer __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStream )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [out] */ UCHAR __RPC_FAR *__RPC_FAR *ppStream,
            /* [out] */ ULONG __RPC_FAR *pSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteStream )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ ULONG __RPC_FAR *pNumBytesWritten);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendNode )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [in] */ NodeData __RPC_FAR *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [out] */ NodeContainerType __RPC_FAR *pType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetType )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [in] */ NodeContainerType type);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Walk )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [in] */ ISdpWalk __RPC_FAR *pWalk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNode )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [in] */ ULONG nodeIndex,
            /* [in] */ NodeData __RPC_FAR *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNode )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [in] */ ULONG nodeIndex,
            /* [out] */ NodeData __RPC_FAR *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockContainer )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [in] */ UCHAR lock);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNodeCount )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pNodeCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateFromStream )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNodeStringData )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [in] */ ULONG nodeIndex,
            /* [out][in] */ NodeData __RPC_FAR *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSize )( 
            ISdpNodeContainer __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pSize);
        
        END_INTERFACE
    } ISdpNodeContainerVtbl;

    interface ISdpNodeContainer
    {
        CONST_VTBL struct ISdpNodeContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISdpNodeContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISdpNodeContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISdpNodeContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISdpNodeContainer_CreateStream(This,ppStream,pSize)	\
    (This)->lpVtbl -> CreateStream(This,ppStream,pSize)

#define ISdpNodeContainer_WriteStream(This,pStream,pNumBytesWritten)	\
    (This)->lpVtbl -> WriteStream(This,pStream,pNumBytesWritten)

#define ISdpNodeContainer_AppendNode(This,pData)	\
    (This)->lpVtbl -> AppendNode(This,pData)

#define ISdpNodeContainer_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ISdpNodeContainer_SetType(This,type)	\
    (This)->lpVtbl -> SetType(This,type)

#define ISdpNodeContainer_Walk(This,pWalk)	\
    (This)->lpVtbl -> Walk(This,pWalk)

#define ISdpNodeContainer_SetNode(This,nodeIndex,pData)	\
    (This)->lpVtbl -> SetNode(This,nodeIndex,pData)

#define ISdpNodeContainer_GetNode(This,nodeIndex,pData)	\
    (This)->lpVtbl -> GetNode(This,nodeIndex,pData)

#define ISdpNodeContainer_LockContainer(This,lock)	\
    (This)->lpVtbl -> LockContainer(This,lock)

#define ISdpNodeContainer_GetNodeCount(This,pNodeCount)	\
    (This)->lpVtbl -> GetNodeCount(This,pNodeCount)

#define ISdpNodeContainer_CreateFromStream(This,pStream,size)	\
    (This)->lpVtbl -> CreateFromStream(This,pStream,size)

#define ISdpNodeContainer_GetNodeStringData(This,nodeIndex,pData)	\
    (This)->lpVtbl -> GetNodeStringData(This,nodeIndex,pData)

#define ISdpNodeContainer_GetStreamSize(This,pSize)	\
    (This)->lpVtbl -> GetStreamSize(This,pSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_CreateStream_Proxy( 
    ISdpNodeContainer __RPC_FAR * This,
    /* [out] */ UCHAR __RPC_FAR *__RPC_FAR *ppStream,
    /* [out] */ ULONG __RPC_FAR *pSize);


void __RPC_STUB ISdpNodeContainer_CreateStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_WriteStream_Proxy( 
    ISdpNodeContainer __RPC_FAR * This,
    /* [in] */ UCHAR __RPC_FAR *pStream,
    /* [out] */ ULONG __RPC_FAR *pNumBytesWritten);


void __RPC_STUB ISdpNodeContainer_WriteStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_AppendNode_Proxy( 
    ISdpNodeContainer __RPC_FAR * This,
    /* [in] */ NodeData __RPC_FAR *pData);


void __RPC_STUB ISdpNodeContainer_AppendNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_GetType_Proxy( 
    ISdpNodeContainer __RPC_FAR * This,
    /* [out] */ NodeContainerType __RPC_FAR *pType);


void __RPC_STUB ISdpNodeContainer_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_SetType_Proxy( 
    ISdpNodeContainer __RPC_FAR * This,
    /* [in] */ NodeContainerType type);


void __RPC_STUB ISdpNodeContainer_SetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_Walk_Proxy( 
    ISdpNodeContainer __RPC_FAR * This,
    /* [in] */ ISdpWalk __RPC_FAR *pWalk);


void __RPC_STUB ISdpNodeContainer_Walk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_SetNode_Proxy( 
    ISdpNodeContainer __RPC_FAR * This,
    /* [in] */ ULONG nodeIndex,
    /* [in] */ NodeData __RPC_FAR *pData);


void __RPC_STUB ISdpNodeContainer_SetNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_GetNode_Proxy( 
    ISdpNodeContainer __RPC_FAR * This,
    /* [in] */ ULONG nodeIndex,
    /* [out] */ NodeData __RPC_FAR *pData);


void __RPC_STUB ISdpNodeContainer_GetNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_LockContainer_Proxy( 
    ISdpNodeContainer __RPC_FAR * This,
    /* [in] */ UCHAR lock);


void __RPC_STUB ISdpNodeContainer_LockContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_GetNodeCount_Proxy( 
    ISdpNodeContainer __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pNodeCount);


void __RPC_STUB ISdpNodeContainer_GetNodeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_CreateFromStream_Proxy( 
    ISdpNodeContainer __RPC_FAR * This,
    /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
    /* [in] */ ULONG size);


void __RPC_STUB ISdpNodeContainer_CreateFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_GetNodeStringData_Proxy( 
    ISdpNodeContainer __RPC_FAR * This,
    /* [in] */ ULONG nodeIndex,
    /* [out][in] */ NodeData __RPC_FAR *pData);


void __RPC_STUB ISdpNodeContainer_GetNodeStringData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_GetStreamSize_Proxy( 
    ISdpNodeContainer __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pSize);


void __RPC_STUB ISdpNodeContainer_GetStreamSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISdpNodeContainer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_BthAPI_0146 */
/* [local] */ 

//
// flags for fConnect in SdpSearch::Connect
//
#define SDP_SEARCH_LOCAL    (0x00000001)
#define SDP_SEARCH_CACHED   (0x00000002)


extern RPC_IF_HANDLE __MIDL_itf_BthAPI_0146_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_BthAPI_0146_v0_0_s_ifspec;

#ifndef __ISdpSearch_INTERFACE_DEFINED__
#define __ISdpSearch_INTERFACE_DEFINED__

/* interface ISdpSearch */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISdpSearch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D93B6B2A-5EEF-4E1E-BECF-F5A4340C65F5")
    ISdpSearch : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Begin( 
            ULONGLONG __RPC_FAR *pAddrss,
            ULONG fConnect) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ServiceSearch( 
            /* [size_is][in] */ SdpQueryUuid __RPC_FAR *pUuidList,
            /* [in] */ ULONG listSize,
            /* [out] */ ULONG __RPC_FAR *pHandles,
            /* [out][in] */ USHORT __RPC_FAR *pNumHandles) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AttributeSearch( 
            /* [in] */ ULONG handle,
            /* [size_is][in] */ SdpAttributeRange __RPC_FAR *pRangeList,
            /* [in] */ ULONG numRanges,
            /* [out] */ ISdpRecord __RPC_FAR *__RPC_FAR *ppSdpRecord) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ServiceAndAttributeSearch( 
            /* [size_is][in] */ SdpQueryUuid __RPC_FAR *pUuidList,
            /* [in] */ ULONG listSize,
            /* [size_is][in] */ SdpAttributeRange __RPC_FAR *pRangeList,
            /* [in] */ ULONG numRanges,
            /* [out] */ ISdpRecord __RPC_FAR *__RPC_FAR *__RPC_FAR *pppSdpRecord,
            /* [out] */ ULONG __RPC_FAR *pNumRecords) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISdpSearchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISdpSearch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISdpSearch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISdpSearch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Begin )( 
            ISdpSearch __RPC_FAR * This,
            ULONGLONG __RPC_FAR *pAddrss,
            ULONG fConnect);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            ISdpSearch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ServiceSearch )( 
            ISdpSearch __RPC_FAR * This,
            /* [size_is][in] */ SdpQueryUuid __RPC_FAR *pUuidList,
            /* [in] */ ULONG listSize,
            /* [out] */ ULONG __RPC_FAR *pHandles,
            /* [out][in] */ USHORT __RPC_FAR *pNumHandles);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttributeSearch )( 
            ISdpSearch __RPC_FAR * This,
            /* [in] */ ULONG handle,
            /* [size_is][in] */ SdpAttributeRange __RPC_FAR *pRangeList,
            /* [in] */ ULONG numRanges,
            /* [out] */ ISdpRecord __RPC_FAR *__RPC_FAR *ppSdpRecord);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ServiceAndAttributeSearch )( 
            ISdpSearch __RPC_FAR * This,
            /* [size_is][in] */ SdpQueryUuid __RPC_FAR *pUuidList,
            /* [in] */ ULONG listSize,
            /* [size_is][in] */ SdpAttributeRange __RPC_FAR *pRangeList,
            /* [in] */ ULONG numRanges,
            /* [out] */ ISdpRecord __RPC_FAR *__RPC_FAR *__RPC_FAR *pppSdpRecord,
            /* [out] */ ULONG __RPC_FAR *pNumRecords);
        
        END_INTERFACE
    } ISdpSearchVtbl;

    interface ISdpSearch
    {
        CONST_VTBL struct ISdpSearchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISdpSearch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISdpSearch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISdpSearch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISdpSearch_Begin(This,pAddrss,fConnect)	\
    (This)->lpVtbl -> Begin(This,pAddrss,fConnect)

#define ISdpSearch_End(This)	\
    (This)->lpVtbl -> End(This)

#define ISdpSearch_ServiceSearch(This,pUuidList,listSize,pHandles,pNumHandles)	\
    (This)->lpVtbl -> ServiceSearch(This,pUuidList,listSize,pHandles,pNumHandles)

#define ISdpSearch_AttributeSearch(This,handle,pRangeList,numRanges,ppSdpRecord)	\
    (This)->lpVtbl -> AttributeSearch(This,handle,pRangeList,numRanges,ppSdpRecord)

#define ISdpSearch_ServiceAndAttributeSearch(This,pUuidList,listSize,pRangeList,numRanges,pppSdpRecord,pNumRecords)	\
    (This)->lpVtbl -> ServiceAndAttributeSearch(This,pUuidList,listSize,pRangeList,numRanges,pppSdpRecord,pNumRecords)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpSearch_Begin_Proxy( 
    ISdpSearch __RPC_FAR * This,
    ULONGLONG __RPC_FAR *pAddrss,
    ULONG fConnect);


void __RPC_STUB ISdpSearch_Begin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpSearch_End_Proxy( 
    ISdpSearch __RPC_FAR * This);


void __RPC_STUB ISdpSearch_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpSearch_ServiceSearch_Proxy( 
    ISdpSearch __RPC_FAR * This,
    /* [size_is][in] */ SdpQueryUuid __RPC_FAR *pUuidList,
    /* [in] */ ULONG listSize,
    /* [out] */ ULONG __RPC_FAR *pHandles,
    /* [out][in] */ USHORT __RPC_FAR *pNumHandles);


void __RPC_STUB ISdpSearch_ServiceSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpSearch_AttributeSearch_Proxy( 
    ISdpSearch __RPC_FAR * This,
    /* [in] */ ULONG handle,
    /* [size_is][in] */ SdpAttributeRange __RPC_FAR *pRangeList,
    /* [in] */ ULONG numRanges,
    /* [out] */ ISdpRecord __RPC_FAR *__RPC_FAR *ppSdpRecord);


void __RPC_STUB ISdpSearch_AttributeSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpSearch_ServiceAndAttributeSearch_Proxy( 
    ISdpSearch __RPC_FAR * This,
    /* [size_is][in] */ SdpQueryUuid __RPC_FAR *pUuidList,
    /* [in] */ ULONG listSize,
    /* [size_is][in] */ SdpAttributeRange __RPC_FAR *pRangeList,
    /* [in] */ ULONG numRanges,
    /* [out] */ ISdpRecord __RPC_FAR *__RPC_FAR *__RPC_FAR *pppSdpRecord,
    /* [out] */ ULONG __RPC_FAR *pNumRecords);


void __RPC_STUB ISdpSearch_ServiceAndAttributeSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISdpSearch_INTERFACE_DEFINED__ */


#ifndef __ISdpStream_INTERFACE_DEFINED__
#define __ISdpStream_INTERFACE_DEFINED__

/* interface ISdpStream */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISdpStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6ECD9FB-0C7A-41A3-9FF0-0B617E989357")
    ISdpStream : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Validate( 
            /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size,
            /* [out] */ ULONG __RPC_FAR *pErrorByte) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Walk( 
            /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size,
            /* [in] */ ISdpWalk __RPC_FAR *pWalk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveRecords( 
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size,
            /* [out][in] */ ISdpRecord __RPC_FAR *__RPC_FAR *ppSdpRecords,
            /* [out][in] */ ULONG __RPC_FAR *pNumRecords) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveUuid128( 
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ GUID __RPC_FAR *pUuid128) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveUint16( 
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ USHORT __RPC_FAR *pUint16) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveUint32( 
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ ULONG __RPC_FAR *pUint32) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveUint64( 
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ ULONGLONG __RPC_FAR *pUint64) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveUint128( 
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ PSDP_ULARGE_INTEGER_16 pUint128) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveInt16( 
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ SHORT __RPC_FAR *pInt16) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveInt32( 
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ LONG __RPC_FAR *pInt32) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveInt64( 
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ LONGLONG __RPC_FAR *pInt64) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveInt128( 
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ PSDP_LARGE_INTEGER_16 pInt128) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapUuid128( 
            /* [in] */ GUID __RPC_FAR *pInUuid128,
            /* [out] */ GUID __RPC_FAR *pOutUuid128) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapUint128( 
            /* [in] */ PSDP_ULARGE_INTEGER_16 pInUint128,
            /* [out] */ PSDP_ULARGE_INTEGER_16 pOutUint128) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapUint64( 
            /* [in] */ ULONGLONG inUint64,
            /* [out] */ ULONGLONG __RPC_FAR *pOutUint64) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapUint32( 
            /* [in] */ ULONG uint32,
            /* [out] */ ULONG __RPC_FAR *pUint32) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapUint16( 
            /* [in] */ USHORT uint16,
            /* [out] */ USHORT __RPC_FAR *pUint16) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapInt128( 
            /* [in] */ PSDP_LARGE_INTEGER_16 pInInt128,
            /* [out] */ PSDP_LARGE_INTEGER_16 pOutInt128) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapInt64( 
            /* [in] */ LONGLONG inInt64,
            /* [out] */ LONGLONG __RPC_FAR *pOutInt64) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapInt32( 
            /* [in] */ LONG int32,
            /* [out] */ LONG __RPC_FAR *pInt32) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapInt16( 
            /* [in] */ SHORT int16,
            /* [out] */ SHORT __RPC_FAR *pInt16) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NormalizeUuid( 
            /* [in] */ NodeData __RPC_FAR *pDataUuid,
            /* [out] */ GUID __RPC_FAR *pNormalizeUuid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveElementInfo( 
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ SDP_TYPE __RPC_FAR *pElementType,
            /* [out] */ SDP_SPECIFICTYPE __RPC_FAR *pElementSpecificType,
            /* [out] */ ULONG __RPC_FAR *pElementSize,
            /* [out] */ ULONG __RPC_FAR *pStorageSize,
            /* [out] */ UCHAR __RPC_FAR *__RPC_FAR *ppData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VerifySequenceOf( 
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size,
            /* [in] */ SDP_TYPE ofType,
            /* [in] */ UCHAR __RPC_FAR *pSpecificSizes,
            /* [out] */ ULONG __RPC_FAR *pNumFound) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISdpStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISdpStream __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISdpStream __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Validate )( 
            ISdpStream __RPC_FAR * This,
            /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size,
            /* [out] */ ULONG __RPC_FAR *pErrorByte);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Walk )( 
            ISdpStream __RPC_FAR * This,
            /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size,
            /* [in] */ ISdpWalk __RPC_FAR *pWalk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetrieveRecords )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size,
            /* [out][in] */ ISdpRecord __RPC_FAR *__RPC_FAR *ppSdpRecords,
            /* [out][in] */ ULONG __RPC_FAR *pNumRecords);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetrieveUuid128 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ GUID __RPC_FAR *pUuid128);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetrieveUint16 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ USHORT __RPC_FAR *pUint16);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetrieveUint32 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ ULONG __RPC_FAR *pUint32);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetrieveUint64 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ ULONGLONG __RPC_FAR *pUint64);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetrieveUint128 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ PSDP_ULARGE_INTEGER_16 pUint128);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetrieveInt16 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ SHORT __RPC_FAR *pInt16);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetrieveInt32 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ LONG __RPC_FAR *pInt32);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetrieveInt64 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ LONGLONG __RPC_FAR *pInt64);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetrieveInt128 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ PSDP_LARGE_INTEGER_16 pInt128);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ByteSwapUuid128 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ GUID __RPC_FAR *pInUuid128,
            /* [out] */ GUID __RPC_FAR *pOutUuid128);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ByteSwapUint128 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ PSDP_ULARGE_INTEGER_16 pInUint128,
            /* [out] */ PSDP_ULARGE_INTEGER_16 pOutUint128);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ByteSwapUint64 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ ULONGLONG inUint64,
            /* [out] */ ULONGLONG __RPC_FAR *pOutUint64);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ByteSwapUint32 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ ULONG uint32,
            /* [out] */ ULONG __RPC_FAR *pUint32);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ByteSwapUint16 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ USHORT uint16,
            /* [out] */ USHORT __RPC_FAR *pUint16);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ByteSwapInt128 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ PSDP_LARGE_INTEGER_16 pInInt128,
            /* [out] */ PSDP_LARGE_INTEGER_16 pOutInt128);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ByteSwapInt64 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ LONGLONG inInt64,
            /* [out] */ LONGLONG __RPC_FAR *pOutInt64);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ByteSwapInt32 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ LONG int32,
            /* [out] */ LONG __RPC_FAR *pInt32);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ByteSwapInt16 )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ SHORT int16,
            /* [out] */ SHORT __RPC_FAR *pInt16);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NormalizeUuid )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ NodeData __RPC_FAR *pDataUuid,
            /* [out] */ GUID __RPC_FAR *pNormalizeUuid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetrieveElementInfo )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [out] */ SDP_TYPE __RPC_FAR *pElementType,
            /* [out] */ SDP_SPECIFICTYPE __RPC_FAR *pElementSpecificType,
            /* [out] */ ULONG __RPC_FAR *pElementSize,
            /* [out] */ ULONG __RPC_FAR *pStorageSize,
            /* [out] */ UCHAR __RPC_FAR *__RPC_FAR *ppData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *VerifySequenceOf )( 
            ISdpStream __RPC_FAR * This,
            /* [in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size,
            /* [in] */ SDP_TYPE ofType,
            /* [in] */ UCHAR __RPC_FAR *pSpecificSizes,
            /* [out] */ ULONG __RPC_FAR *pNumFound);
        
        END_INTERFACE
    } ISdpStreamVtbl;

    interface ISdpStream
    {
        CONST_VTBL struct ISdpStreamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISdpStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISdpStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISdpStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISdpStream_Validate(This,pStream,size,pErrorByte)	\
    (This)->lpVtbl -> Validate(This,pStream,size,pErrorByte)

#define ISdpStream_Walk(This,pStream,size,pWalk)	\
    (This)->lpVtbl -> Walk(This,pStream,size,pWalk)

#define ISdpStream_RetrieveRecords(This,pStream,size,ppSdpRecords,pNumRecords)	\
    (This)->lpVtbl -> RetrieveRecords(This,pStream,size,ppSdpRecords,pNumRecords)

#define ISdpStream_RetrieveUuid128(This,pStream,pUuid128)	\
    (This)->lpVtbl -> RetrieveUuid128(This,pStream,pUuid128)

#define ISdpStream_RetrieveUint16(This,pStream,pUint16)	\
    (This)->lpVtbl -> RetrieveUint16(This,pStream,pUint16)

#define ISdpStream_RetrieveUint32(This,pStream,pUint32)	\
    (This)->lpVtbl -> RetrieveUint32(This,pStream,pUint32)

#define ISdpStream_RetrieveUint64(This,pStream,pUint64)	\
    (This)->lpVtbl -> RetrieveUint64(This,pStream,pUint64)

#define ISdpStream_RetrieveUint128(This,pStream,pUint128)	\
    (This)->lpVtbl -> RetrieveUint128(This,pStream,pUint128)

#define ISdpStream_RetrieveInt16(This,pStream,pInt16)	\
    (This)->lpVtbl -> RetrieveInt16(This,pStream,pInt16)

#define ISdpStream_RetrieveInt32(This,pStream,pInt32)	\
    (This)->lpVtbl -> RetrieveInt32(This,pStream,pInt32)

#define ISdpStream_RetrieveInt64(This,pStream,pInt64)	\
    (This)->lpVtbl -> RetrieveInt64(This,pStream,pInt64)

#define ISdpStream_RetrieveInt128(This,pStream,pInt128)	\
    (This)->lpVtbl -> RetrieveInt128(This,pStream,pInt128)

#define ISdpStream_ByteSwapUuid128(This,pInUuid128,pOutUuid128)	\
    (This)->lpVtbl -> ByteSwapUuid128(This,pInUuid128,pOutUuid128)

#define ISdpStream_ByteSwapUint128(This,pInUint128,pOutUint128)	\
    (This)->lpVtbl -> ByteSwapUint128(This,pInUint128,pOutUint128)

#define ISdpStream_ByteSwapUint64(This,inUint64,pOutUint64)	\
    (This)->lpVtbl -> ByteSwapUint64(This,inUint64,pOutUint64)

#define ISdpStream_ByteSwapUint32(This,uint32,pUint32)	\
    (This)->lpVtbl -> ByteSwapUint32(This,uint32,pUint32)

#define ISdpStream_ByteSwapUint16(This,uint16,pUint16)	\
    (This)->lpVtbl -> ByteSwapUint16(This,uint16,pUint16)

#define ISdpStream_ByteSwapInt128(This,pInInt128,pOutInt128)	\
    (This)->lpVtbl -> ByteSwapInt128(This,pInInt128,pOutInt128)

#define ISdpStream_ByteSwapInt64(This,inInt64,pOutInt64)	\
    (This)->lpVtbl -> ByteSwapInt64(This,inInt64,pOutInt64)

#define ISdpStream_ByteSwapInt32(This,int32,pInt32)	\
    (This)->lpVtbl -> ByteSwapInt32(This,int32,pInt32)

#define ISdpStream_ByteSwapInt16(This,int16,pInt16)	\
    (This)->lpVtbl -> ByteSwapInt16(This,int16,pInt16)

#define ISdpStream_NormalizeUuid(This,pDataUuid,pNormalizeUuid)	\
    (This)->lpVtbl -> NormalizeUuid(This,pDataUuid,pNormalizeUuid)

#define ISdpStream_RetrieveElementInfo(This,pStream,pElementType,pElementSpecificType,pElementSize,pStorageSize,ppData)	\
    (This)->lpVtbl -> RetrieveElementInfo(This,pStream,pElementType,pElementSpecificType,pElementSize,pStorageSize,ppData)

#define ISdpStream_VerifySequenceOf(This,pStream,size,ofType,pSpecificSizes,pNumFound)	\
    (This)->lpVtbl -> VerifySequenceOf(This,pStream,size,ofType,pSpecificSizes,pNumFound)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_Validate_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
    /* [in] */ ULONG size,
    /* [out] */ ULONG __RPC_FAR *pErrorByte);


void __RPC_STUB ISdpStream_Validate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_Walk_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
    /* [in] */ ULONG size,
    /* [in] */ ISdpWalk __RPC_FAR *pWalk);


void __RPC_STUB ISdpStream_Walk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveRecords_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ UCHAR __RPC_FAR *pStream,
    /* [in] */ ULONG size,
    /* [out][in] */ ISdpRecord __RPC_FAR *__RPC_FAR *ppSdpRecords,
    /* [out][in] */ ULONG __RPC_FAR *pNumRecords);


void __RPC_STUB ISdpStream_RetrieveRecords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveUuid128_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ UCHAR __RPC_FAR *pStream,
    /* [out] */ GUID __RPC_FAR *pUuid128);


void __RPC_STUB ISdpStream_RetrieveUuid128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveUint16_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ UCHAR __RPC_FAR *pStream,
    /* [out] */ USHORT __RPC_FAR *pUint16);


void __RPC_STUB ISdpStream_RetrieveUint16_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveUint32_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ UCHAR __RPC_FAR *pStream,
    /* [out] */ ULONG __RPC_FAR *pUint32);


void __RPC_STUB ISdpStream_RetrieveUint32_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveUint64_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ UCHAR __RPC_FAR *pStream,
    /* [out] */ ULONGLONG __RPC_FAR *pUint64);


void __RPC_STUB ISdpStream_RetrieveUint64_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveUint128_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ UCHAR __RPC_FAR *pStream,
    /* [out] */ PSDP_ULARGE_INTEGER_16 pUint128);


void __RPC_STUB ISdpStream_RetrieveUint128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveInt16_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ UCHAR __RPC_FAR *pStream,
    /* [out] */ SHORT __RPC_FAR *pInt16);


void __RPC_STUB ISdpStream_RetrieveInt16_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveInt32_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ UCHAR __RPC_FAR *pStream,
    /* [out] */ LONG __RPC_FAR *pInt32);


void __RPC_STUB ISdpStream_RetrieveInt32_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveInt64_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ UCHAR __RPC_FAR *pStream,
    /* [out] */ LONGLONG __RPC_FAR *pInt64);


void __RPC_STUB ISdpStream_RetrieveInt64_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveInt128_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ UCHAR __RPC_FAR *pStream,
    /* [out] */ PSDP_LARGE_INTEGER_16 pInt128);


void __RPC_STUB ISdpStream_RetrieveInt128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapUuid128_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ GUID __RPC_FAR *pInUuid128,
    /* [out] */ GUID __RPC_FAR *pOutUuid128);


void __RPC_STUB ISdpStream_ByteSwapUuid128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapUint128_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ PSDP_ULARGE_INTEGER_16 pInUint128,
    /* [out] */ PSDP_ULARGE_INTEGER_16 pOutUint128);


void __RPC_STUB ISdpStream_ByteSwapUint128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapUint64_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ ULONGLONG inUint64,
    /* [out] */ ULONGLONG __RPC_FAR *pOutUint64);


void __RPC_STUB ISdpStream_ByteSwapUint64_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapUint32_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ ULONG uint32,
    /* [out] */ ULONG __RPC_FAR *pUint32);


void __RPC_STUB ISdpStream_ByteSwapUint32_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapUint16_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ USHORT uint16,
    /* [out] */ USHORT __RPC_FAR *pUint16);


void __RPC_STUB ISdpStream_ByteSwapUint16_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapInt128_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ PSDP_LARGE_INTEGER_16 pInInt128,
    /* [out] */ PSDP_LARGE_INTEGER_16 pOutInt128);


void __RPC_STUB ISdpStream_ByteSwapInt128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapInt64_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ LONGLONG inInt64,
    /* [out] */ LONGLONG __RPC_FAR *pOutInt64);


void __RPC_STUB ISdpStream_ByteSwapInt64_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapInt32_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ LONG int32,
    /* [out] */ LONG __RPC_FAR *pInt32);


void __RPC_STUB ISdpStream_ByteSwapInt32_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapInt16_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ SHORT int16,
    /* [out] */ SHORT __RPC_FAR *pInt16);


void __RPC_STUB ISdpStream_ByteSwapInt16_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_NormalizeUuid_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ NodeData __RPC_FAR *pDataUuid,
    /* [out] */ GUID __RPC_FAR *pNormalizeUuid);


void __RPC_STUB ISdpStream_NormalizeUuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveElementInfo_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ UCHAR __RPC_FAR *pStream,
    /* [out] */ SDP_TYPE __RPC_FAR *pElementType,
    /* [out] */ SDP_SPECIFICTYPE __RPC_FAR *pElementSpecificType,
    /* [out] */ ULONG __RPC_FAR *pElementSize,
    /* [out] */ ULONG __RPC_FAR *pStorageSize,
    /* [out] */ UCHAR __RPC_FAR *__RPC_FAR *ppData);


void __RPC_STUB ISdpStream_RetrieveElementInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_VerifySequenceOf_Proxy( 
    ISdpStream __RPC_FAR * This,
    /* [in] */ UCHAR __RPC_FAR *pStream,
    /* [in] */ ULONG size,
    /* [in] */ SDP_TYPE ofType,
    /* [in] */ UCHAR __RPC_FAR *pSpecificSizes,
    /* [out] */ ULONG __RPC_FAR *pNumFound);


void __RPC_STUB ISdpStream_VerifySequenceOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISdpStream_INTERFACE_DEFINED__ */


#ifndef __ISdpRecord_INTERFACE_DEFINED__
#define __ISdpRecord_INTERFACE_DEFINED__

/* interface ISdpRecord */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISdpRecord;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10276714-1456-46D7-B526-8B1E83D5116E")
    ISdpRecord : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateFromStream( 
            /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WriteToStream( 
            /* [out] */ UCHAR __RPC_FAR *__RPC_FAR *ppStream,
            /* [out] */ ULONG __RPC_FAR *pStreamSize,
            ULONG preSize,
            ULONG postSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ USHORT attribute,
            /* [in] */ NodeData __RPC_FAR *pNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAttributeFromStream( 
            /* [in] */ USHORT attribute,
            /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [in] */ USHORT attribute,
            /* [out][in] */ NodeData __RPC_FAR *pNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAttributeAsStream( 
            /* [in] */ USHORT attribute,
            /* [out] */ UCHAR __RPC_FAR *__RPC_FAR *ppStream,
            /* [out] */ ULONG __RPC_FAR *pSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Walk( 
            /* [in] */ ISdpWalk __RPC_FAR *pWalk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAttributeList( 
            /* [out] */ USHORT __RPC_FAR *__RPC_FAR *ppList,
            /* [out] */ ULONG __RPC_FAR *pListSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetString( 
            USHORT offset,
            USHORT __RPC_FAR *pLangId,
            WCHAR __RPC_FAR *__RPC_FAR *ppString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIcon( 
            int cxRes,
            int cyRes,
            HICON __RPC_FAR *phIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetServiceClass( 
            /* [out] */ LPGUID pServiceClass) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISdpRecordVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISdpRecord __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISdpRecord __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISdpRecord __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateFromStream )( 
            ISdpRecord __RPC_FAR * This,
            /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteToStream )( 
            ISdpRecord __RPC_FAR * This,
            /* [out] */ UCHAR __RPC_FAR *__RPC_FAR *ppStream,
            /* [out] */ ULONG __RPC_FAR *pStreamSize,
            ULONG preSize,
            ULONG postSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttribute )( 
            ISdpRecord __RPC_FAR * This,
            /* [in] */ USHORT attribute,
            /* [in] */ NodeData __RPC_FAR *pNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributeFromStream )( 
            ISdpRecord __RPC_FAR * This,
            /* [in] */ USHORT attribute,
            /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
            /* [in] */ ULONG size);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttribute )( 
            ISdpRecord __RPC_FAR * This,
            /* [in] */ USHORT attribute,
            /* [out][in] */ NodeData __RPC_FAR *pNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeAsStream )( 
            ISdpRecord __RPC_FAR * This,
            /* [in] */ USHORT attribute,
            /* [out] */ UCHAR __RPC_FAR *__RPC_FAR *ppStream,
            /* [out] */ ULONG __RPC_FAR *pSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Walk )( 
            ISdpRecord __RPC_FAR * This,
            /* [in] */ ISdpWalk __RPC_FAR *pWalk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeList )( 
            ISdpRecord __RPC_FAR * This,
            /* [out] */ USHORT __RPC_FAR *__RPC_FAR *ppList,
            /* [out] */ ULONG __RPC_FAR *pListSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetString )( 
            ISdpRecord __RPC_FAR * This,
            USHORT offset,
            USHORT __RPC_FAR *pLangId,
            WCHAR __RPC_FAR *__RPC_FAR *ppString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIcon )( 
            ISdpRecord __RPC_FAR * This,
            int cxRes,
            int cyRes,
            HICON __RPC_FAR *phIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServiceClass )( 
            ISdpRecord __RPC_FAR * This,
            /* [out] */ LPGUID pServiceClass);
        
        END_INTERFACE
    } ISdpRecordVtbl;

    interface ISdpRecord
    {
        CONST_VTBL struct ISdpRecordVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISdpRecord_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISdpRecord_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISdpRecord_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISdpRecord_CreateFromStream(This,pStream,size)	\
    (This)->lpVtbl -> CreateFromStream(This,pStream,size)

#define ISdpRecord_WriteToStream(This,ppStream,pStreamSize,preSize,postSize)	\
    (This)->lpVtbl -> WriteToStream(This,ppStream,pStreamSize,preSize,postSize)

#define ISdpRecord_SetAttribute(This,attribute,pNode)	\
    (This)->lpVtbl -> SetAttribute(This,attribute,pNode)

#define ISdpRecord_SetAttributeFromStream(This,attribute,pStream,size)	\
    (This)->lpVtbl -> SetAttributeFromStream(This,attribute,pStream,size)

#define ISdpRecord_GetAttribute(This,attribute,pNode)	\
    (This)->lpVtbl -> GetAttribute(This,attribute,pNode)

#define ISdpRecord_GetAttributeAsStream(This,attribute,ppStream,pSize)	\
    (This)->lpVtbl -> GetAttributeAsStream(This,attribute,ppStream,pSize)

#define ISdpRecord_Walk(This,pWalk)	\
    (This)->lpVtbl -> Walk(This,pWalk)

#define ISdpRecord_GetAttributeList(This,ppList,pListSize)	\
    (This)->lpVtbl -> GetAttributeList(This,ppList,pListSize)

#define ISdpRecord_GetString(This,offset,pLangId,ppString)	\
    (This)->lpVtbl -> GetString(This,offset,pLangId,ppString)

#define ISdpRecord_GetIcon(This,cxRes,cyRes,phIcon)	\
    (This)->lpVtbl -> GetIcon(This,cxRes,cyRes,phIcon)

#define ISdpRecord_GetServiceClass(This,pServiceClass)	\
    (This)->lpVtbl -> GetServiceClass(This,pServiceClass)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_CreateFromStream_Proxy( 
    ISdpRecord __RPC_FAR * This,
    /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
    /* [in] */ ULONG size);


void __RPC_STUB ISdpRecord_CreateFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_WriteToStream_Proxy( 
    ISdpRecord __RPC_FAR * This,
    /* [out] */ UCHAR __RPC_FAR *__RPC_FAR *ppStream,
    /* [out] */ ULONG __RPC_FAR *pStreamSize,
    ULONG preSize,
    ULONG postSize);


void __RPC_STUB ISdpRecord_WriteToStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_SetAttribute_Proxy( 
    ISdpRecord __RPC_FAR * This,
    /* [in] */ USHORT attribute,
    /* [in] */ NodeData __RPC_FAR *pNode);


void __RPC_STUB ISdpRecord_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_SetAttributeFromStream_Proxy( 
    ISdpRecord __RPC_FAR * This,
    /* [in] */ USHORT attribute,
    /* [size_is][in] */ UCHAR __RPC_FAR *pStream,
    /* [in] */ ULONG size);


void __RPC_STUB ISdpRecord_SetAttributeFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_GetAttribute_Proxy( 
    ISdpRecord __RPC_FAR * This,
    /* [in] */ USHORT attribute,
    /* [out][in] */ NodeData __RPC_FAR *pNode);


void __RPC_STUB ISdpRecord_GetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_GetAttributeAsStream_Proxy( 
    ISdpRecord __RPC_FAR * This,
    /* [in] */ USHORT attribute,
    /* [out] */ UCHAR __RPC_FAR *__RPC_FAR *ppStream,
    /* [out] */ ULONG __RPC_FAR *pSize);


void __RPC_STUB ISdpRecord_GetAttributeAsStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_Walk_Proxy( 
    ISdpRecord __RPC_FAR * This,
    /* [in] */ ISdpWalk __RPC_FAR *pWalk);


void __RPC_STUB ISdpRecord_Walk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_GetAttributeList_Proxy( 
    ISdpRecord __RPC_FAR * This,
    /* [out] */ USHORT __RPC_FAR *__RPC_FAR *ppList,
    /* [out] */ ULONG __RPC_FAR *pListSize);


void __RPC_STUB ISdpRecord_GetAttributeList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_GetString_Proxy( 
    ISdpRecord __RPC_FAR * This,
    USHORT offset,
    USHORT __RPC_FAR *pLangId,
    WCHAR __RPC_FAR *__RPC_FAR *ppString);


void __RPC_STUB ISdpRecord_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_GetIcon_Proxy( 
    ISdpRecord __RPC_FAR * This,
    int cxRes,
    int cyRes,
    HICON __RPC_FAR *phIcon);


void __RPC_STUB ISdpRecord_GetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_GetServiceClass_Proxy( 
    ISdpRecord __RPC_FAR * This,
    /* [out] */ LPGUID pServiceClass);


void __RPC_STUB ISdpRecord_GetServiceClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISdpRecord_INTERFACE_DEFINED__ */


#ifndef __IBluetoothDevice_INTERFACE_DEFINED__
#define __IBluetoothDevice_INTERFACE_DEFINED__

/* interface IBluetoothDevice */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IBluetoothDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5BD0418B-D705-4766-B215-183E4EADE341")
    IBluetoothDevice : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            const BthDeviceInfo __RPC_FAR *pInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInfo( 
            BthDeviceInfo __RPC_FAR *pInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetString( 
            enum BthDeviceStringType type,
            WCHAR __RPC_FAR *__RPC_FAR *ppString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetString( 
            enum BthDeviceStringType type,
            WCHAR __RPC_FAR *ppString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIcon( 
            int cxRes,
            int cyRes,
            HICON __RPC_FAR *phIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetApprovedServices( 
            GUID __RPC_FAR *pServices,
            ULONG __RPC_FAR *pServiceCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPassKey( 
            HWND hwndParent,
            UCHAR __RPC_FAR *pPassKey,
            UCHAR __RPC_FAR *pPassKeyLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBluetoothDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBluetoothDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBluetoothDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBluetoothDevice __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IBluetoothDevice __RPC_FAR * This,
            const BthDeviceInfo __RPC_FAR *pInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )( 
            IBluetoothDevice __RPC_FAR * This,
            BthDeviceInfo __RPC_FAR *pInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetString )( 
            IBluetoothDevice __RPC_FAR * This,
            enum BthDeviceStringType type,
            WCHAR __RPC_FAR *__RPC_FAR *ppString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetString )( 
            IBluetoothDevice __RPC_FAR * This,
            enum BthDeviceStringType type,
            WCHAR __RPC_FAR *ppString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIcon )( 
            IBluetoothDevice __RPC_FAR * This,
            int cxRes,
            int cyRes,
            HICON __RPC_FAR *phIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetApprovedServices )( 
            IBluetoothDevice __RPC_FAR * This,
            GUID __RPC_FAR *pServices,
            ULONG __RPC_FAR *pServiceCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPassKey )( 
            IBluetoothDevice __RPC_FAR * This,
            HWND hwndParent,
            UCHAR __RPC_FAR *pPassKey,
            UCHAR __RPC_FAR *pPassKeyLength);
        
        END_INTERFACE
    } IBluetoothDeviceVtbl;

    interface IBluetoothDevice
    {
        CONST_VTBL struct IBluetoothDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBluetoothDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBluetoothDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBluetoothDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBluetoothDevice_Initialize(This,pInfo)	\
    (This)->lpVtbl -> Initialize(This,pInfo)

#define IBluetoothDevice_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#define IBluetoothDevice_GetString(This,type,ppString)	\
    (This)->lpVtbl -> GetString(This,type,ppString)

#define IBluetoothDevice_SetString(This,type,ppString)	\
    (This)->lpVtbl -> SetString(This,type,ppString)

#define IBluetoothDevice_GetIcon(This,cxRes,cyRes,phIcon)	\
    (This)->lpVtbl -> GetIcon(This,cxRes,cyRes,phIcon)

#define IBluetoothDevice_GetApprovedServices(This,pServices,pServiceCount)	\
    (This)->lpVtbl -> GetApprovedServices(This,pServices,pServiceCount)

#define IBluetoothDevice_GetPassKey(This,hwndParent,pPassKey,pPassKeyLength)	\
    (This)->lpVtbl -> GetPassKey(This,hwndParent,pPassKey,pPassKeyLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_Initialize_Proxy( 
    IBluetoothDevice __RPC_FAR * This,
    const BthDeviceInfo __RPC_FAR *pInfo);


void __RPC_STUB IBluetoothDevice_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_GetInfo_Proxy( 
    IBluetoothDevice __RPC_FAR * This,
    BthDeviceInfo __RPC_FAR *pInfo);


void __RPC_STUB IBluetoothDevice_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_GetString_Proxy( 
    IBluetoothDevice __RPC_FAR * This,
    enum BthDeviceStringType type,
    WCHAR __RPC_FAR *__RPC_FAR *ppString);


void __RPC_STUB IBluetoothDevice_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_SetString_Proxy( 
    IBluetoothDevice __RPC_FAR * This,
    enum BthDeviceStringType type,
    WCHAR __RPC_FAR *ppString);


void __RPC_STUB IBluetoothDevice_SetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_GetIcon_Proxy( 
    IBluetoothDevice __RPC_FAR * This,
    int cxRes,
    int cyRes,
    HICON __RPC_FAR *phIcon);


void __RPC_STUB IBluetoothDevice_GetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_GetApprovedServices_Proxy( 
    IBluetoothDevice __RPC_FAR * This,
    GUID __RPC_FAR *pServices,
    ULONG __RPC_FAR *pServiceCount);


void __RPC_STUB IBluetoothDevice_GetApprovedServices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_GetPassKey_Proxy( 
    IBluetoothDevice __RPC_FAR * This,
    HWND hwndParent,
    UCHAR __RPC_FAR *pPassKey,
    UCHAR __RPC_FAR *pPassKeyLength);


void __RPC_STUB IBluetoothDevice_GetPassKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBluetoothDevice_INTERFACE_DEFINED__ */


#ifndef __IBluetoothAuthenticate_INTERFACE_DEFINED__
#define __IBluetoothAuthenticate_INTERFACE_DEFINED__

/* interface IBluetoothAuthenticate */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IBluetoothAuthenticate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5F0FBA2B-8300-429D-99AD-96A2835D4901")
    IBluetoothAuthenticate : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IBluetoothAuthenticateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBluetoothAuthenticate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBluetoothAuthenticate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBluetoothAuthenticate __RPC_FAR * This);
        
        END_INTERFACE
    } IBluetoothAuthenticateVtbl;

    interface IBluetoothAuthenticate
    {
        CONST_VTBL struct IBluetoothAuthenticateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBluetoothAuthenticate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBluetoothAuthenticate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBluetoothAuthenticate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBluetoothAuthenticate_INTERFACE_DEFINED__ */



#ifndef __BTHAPILib_LIBRARY_DEFINED__
#define __BTHAPILib_LIBRARY_DEFINED__

/* library BTHAPILib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_BTHAPILib;

EXTERN_C const CLSID CLSID_SdpNodeContainer;

#ifdef __cplusplus

class DECLSPEC_UUID("D5CA76C5-0DEE-4453-96A1-E603C2401766")
SdpNodeContainer;
#endif

EXTERN_C const CLSID CLSID_SdpSearch;

#ifdef __cplusplus

class DECLSPEC_UUID("3B898402-857E-4e41-9145-BC35431B7B4D")
SdpSearch;
#endif

EXTERN_C const CLSID CLSID_SdpWalk;

#ifdef __cplusplus

class DECLSPEC_UUID("ED384010-59AE-44c7-8FCA-F3DF22CDCD28")
SdpWalk;
#endif

EXTERN_C const CLSID CLSID_SdpStream;

#ifdef __cplusplus

class DECLSPEC_UUID("249797FA-19DB-4dda-94D4-E0BCD30EA65E")
SdpStream;
#endif

EXTERN_C const CLSID CLSID_SdpRecord;

#ifdef __cplusplus

class DECLSPEC_UUID("ACD02BA7-9667-4085-A100-CC6ACA9621D6")
SdpRecord;
#endif
#endif /* __BTHAPILib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HICON __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HICON __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HICON __RPC_FAR * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long __RPC_FAR *, HICON __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\bthservicehelper.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma once

#include <windows.h>
#include <bt_api.h>

typedef void (*PFN_BthServiceRequestCallback) (BT_ADDR* pbtAddr, GUID* pServiceUuid, BOOL fConnect);

int 
BthServiceNotifyConnected(
    BT_ADDR* pbtAddr,
    const GUID* pServiceUuid);

int 
BthServiceNotifyDisconnected(
    BT_ADDR* pbtAddr,
    const GUID* pServiceUuid);

int
BthSetServiceCallback(
    const GUID* pServiceUuid,
    PFN_BthServiceRequestCallback pfnCallback);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\bthutil.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#pragma once

////////////////////////////////////////////////////////////////////////////////
//
// @enum    BTH_RADIO_MODE |
//          Enumerate all the possible modes of operation of the bluetooth radio
//
////////////////////////////////////////////////////////////////////////////////

enum BTH_RADIO_MODE
{
    BTH_POWER_OFF,
    BTH_CONNECTABLE,
    BTH_DISCOVERABLE
};

#ifdef __cplusplus
extern "C"{
#endif 

////////////////////////////////////////////////////////////////////////////////
//
// @func    int | BthSetMode |
//          This function set the bluetooth Mode of operation and reflects it in 
//          the control panel.  It also persist that state across hardware insertion
//          and reboot
//
// @syntax  BthSetMode( DWORD dwMode )
//
// @parm    DWORD | dwMode |
//          BTH_POWER_OFF to turn the bluetooth radio OFF
//          BTH_CONNECTABLE to turn the bluetooth radio ON and CONNECTABLE
//          BTH_DISCOVERABLE to turn the bluetooth radio ON and CONNECTABLE and DISCOVERABLE
//
// @rdesc   int: ERROR_SUCCESS on success.  Error code describing error on failure.
//
////////////////////////////////////////////////////////////////////////////////

int BthSetMode( DWORD dwMode );

////////////////////////////////////////////////////////////////////////////////
//
// @func    int | BthGetMode |
//          This function retrieves the current mode of operation of the bluetooth radio
//
// @syntax  BthGetMode( DWORD* pdwMode )
//
// @parm    DWORD* | pdwMode |
//          BTH_POWER_OFF to indicate the bluetooth radio is OFF
//          BTH_CONNECTABLE to indicate the bluetooth radio ON and CONNECTABLE
//          BTH_DISCOVERABLE to indicate the bluetooth radio ON and CONNECTABLE and DISCOVERABLE
//
// @rdesc   int: ERROR_SUCCESS on success.  Error code describing error on failure.
//
////////////////////////////////////////////////////////////////////////////////

int BthGetMode( DWORD* pdwMode );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\camera.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef __CAMERA_H__
#define __CAMERA_H__


#include <windows.h>
#include <Cs.h>
#include <Csmedia.h>

#define DRIVER_VERSION       1
#define DRIVER_VERSION_2     2

#define DEVCLASS_CAMERA_GUID { 0xCB998A05, 0x122C, 0x4166, 0x84, 0x6A, 0x93, 0x3E, 0x4D, 0x7E, 0x3C, 0x86 }
#define DEVCLASS_3PT_CAMERA_GUID { 0xcb0f3e02, 0x534f, 0x4826, {0xa0, 0x44, 0xf0, 0x8f, 0x10, 0xe6, 0x44, 0x8d }}
#define DEVCLASS_PIN_GUID    { 0xC9D092D6, 0x827A, 0x45E2, 0x81, 0x44, 0xDE, 0x19, 0x82, 0xBF, 0xC3, 0xA8 }

#define IOCTL_STREAM_INSTANTIATE          CTL_CODE(FILE_DEVICE_KS, 0x007, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_CS_ALLOCATE_BUFFERS         CTL_CODE(FILE_DEVICE_KS, 0x008, METHOD_NEITHER, FILE_ANY_ACCESS)

// {443A0706-9554-41f4-BB70-ECB5D210FB3B}
#define STATIC_CSPROPSETID_StreamEx\
    0x443a0706L, 0x9554, 0x41f4, 0xbb, 0x70, 0xec, 0xb5, 0xd2, 0x10, 0xfb, 0x3b
DEFINE_GUIDSTRUCT("443A0706-9554-41f4-BB70-ECB5D210FB3B", CSPROPSETID_StreamEx);	
#define CSPROPSETID_StreamEx DEFINE_GUIDNAMED(CSPROPSETID_StreamEx)

#define STATIC_CSPROPSETID_ADAPTER \
    0x1633ec1b, 0x67b1, 0x42a4, 0xa9, 0x62, 0x44, 0x15, 0xf9, 0x6, 0x2, 0xe1
DEFINE_GUIDSTRUCT("1633EC1B-67B1-42a4-A962-4415F90602E1", CSPROPSETID_Adapter);
#define CSPROPSETID_Adapter DEFINE_GUIDNAMED(CSPROPSETID_Adapter)



typedef enum {
    CSPROPERTY_BUFFER_DRIVER = 1,
    CSPROPERTY_BUFFER_CLIENT_LIMITED = 2,
    CSPROPERTY_BUFFER_CLIENT_UNLIMITED = 4
} CSPROPERTY_BUFFER_MODE;

typedef enum
{
    CSPROPERTY_STREAMEX_INIT = 0,
} CSPROPERTY_STREAMEX;

typedef enum {
    CSPROPERTY_ADAPTER_NOTIFICATION = 0,
} CSPROPERTY_ADAPTER;

typedef struct _tagCSPROPERTY_StreamEx
{
    CSP_PIN CsPin;
    HANDLE  hMsgQueue;
} CSPROPERTY_STREAMEX_S, * PCSPROPERTY_STREAMEX_S;

typedef struct _tagCSPROPERTY_ADAPTER_NOTIFICATION{
    CSPROPERTY CsProperty;
    HANDLE  hMsgQueue;
} CSPROPERTY_ADAPTER_NOTIFICATION_S, * PCSPROPERTY_ADAPTER_NOTIFICATION_S;

typedef struct _tagMessageQueueHeader
{
    ULONG  Size;
    ULONG  Flags;
    LPVOID Context;
} CS_MSGQUEUE_HEADER, * PCS_MSGQUEUE_HEADER;

#define FLAG_MSGQ_FRAME_BUFFER          0x00000001
#define FLAG_MSGQ_SAMPLE_SCANNED        0x00000002
#define FLAG_MSGQ_ASYNCHRONOUS_FOCUS    0x00000004

typedef struct _tagStreamDescriptor
{
    CSSTREAM_HEADER CsStreamHeader;
    CS_FRAME_INFO   CsFrameInfo;

} CS_STREAM_DESCRIPTOR, * PCS_STREAM_DESCRIPTOR;


typedef struct _tagMessageQueueData
{
    CS_MSGQUEUE_HEADER    CsMsgQueueHeader;
    PCS_STREAM_DESCRIPTOR pStreamDescriptor;
} CS_MSGQUEUE_BUFFER, * PCS_MSGQUEUE_BUFFER;

typedef struct _tagCSBUFFER_Info
{
    DWORD dwCommand;
    PCS_STREAM_DESCRIPTOR pStreamDescriptor;
} CSBUFFER_INFO, * PCSBUFFER_INFO;

// CAM_NOTIFICATION_CONTEXT is used to pass various notifications (such as shutter sound, Async Auto-focus) from PDD to the application
typedef struct _tagCamNotificationContext{
    DWORD  Size;		// Size of the structure
    DWORD  Data;		// Specific to Notification
    DWORD  Result;	    // ERROR_SUCCESS or any failure
} CAM_NOTIFICATION_CONTEXT, * PCAM_NOTIFICATION_CONTEXT;


// CSSTREAM_ALLOCATOR is used by the client to specify, in case of driver being the allocator, the number of buffers the driver should create.
// When the client itself is the alloctor, this structure is used to pass down the number of buffers allocated by the client and the pointer to
// these buffers is stored in ppBuffers structure.
typedef struct
{
    ULONG    DesiredCount;
    ULONG    ActualCount;
    LPVOID   pBuffers;
} CSSTREAM_ALLOCATOR, * PCSSTREAM_ALLOCATOR;

typedef struct _Stream_Buffer STREAM_BUFFERNODE, *PSTREAM_BUFFERNODE;
struct _Stream_Buffer
{
    PCS_STREAM_DESCRIPTOR pCsStreamDesc;
    PSTREAM_BUFFERNODE    pNext;
    PVOID                 pMappedData;
    PVOID                 pUnmappedData;
};

//TODO : POOL_TYPE is also defined in public\common\ddk\inc\ndis.h. Later we need to unify the two.
typedef enum _POOL_TYPE 
{
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType
} POOL_TYPE;

typedef enum {
    NORMAL_COMPLETION =0,	// Normal Start/Stop notification
    CANCELLED	            // Notification sent when operation is cancelled
} CAMERA_ACTION; 


//
// Define alignment requirement values
//

#define FILE_BYTE_ALIGNMENT             0x00000000
#define FILE_WORD_ALIGNMENT             0x00000001
#define FILE_LONG_ALIGNMENT             0x00000003
#define FILE_QUAD_ALIGNMENT             0x00000007
#define FILE_OCTA_ALIGNMENT             0x0000000f
#define FILE_32_BYTE_ALIGNMENT          0x0000001f
#define FILE_64_BYTE_ALIGNMENT          0x0000003f
#define FILE_128_BYTE_ALIGNMENT         0x0000007f
#define FILE_256_BYTE_ALIGNMENT         0x000000ff
#define FILE_512_BYTE_ALIGNMENT         0x000001ff


#endif //__CAMERA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\bt_sdp.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//------------------------------------------------------------------------------
// 
//      Bluetooth SDP header
// 
// 
// Module Name:
// 
//      bt_sdp.h
// 
// Abstract:
// 
//      This file contains constants and structures for Service Discovery Protocol.
// 
// 
//------------------------------------------------------------------------------

#if ! defined (__bt_sdp_H__)
#define __bt_sdp_H__		1

#include <windows.h>

#define SDP_ERROR_INVALID_SDP_VERSION           0x0001
#define SDP_ERROR_INVALID_RECORD_HANDLE         0x0002
#define SDP_ERROR_INVALID_REQUEST_SYNTAX        0x0003
#define SDP_ERROR_INVALID_PDU_SIZE              0x0004
#define SDP_ERROR_INVALID_CONTINUATION_STATE    0x0005
#define SDP_ERROR_INSUFFICIENT_RESOURCES        0x0006

#define SDP_ATTRIB_RECORD_HANDLE            0x0000
#define SDP_ATTRIB_CLASS_ID_LIST            0x0001
#define SDP_ATTRIB_RECORD_STATE             0x0002
#define SDP_ATTRIB_SERVICE_ID               0x0003
#define SDP_ATTRIB_PROTOCOL_DESCRIPTOR_LIST 0x0004
#define SDP_ATTRIB_BROWSE_GROUP_LIST        0x0005
#define SDP_ATTRIB_LANG_BASE_ATTRIB_ID_LIST 0x0006
#define SDP_ATTRIB_INFO_TIME_TO_LIVE        0x0007
#define SDP_ATTRIB_AVAILABILITY             0x0008
#define SDP_ATTRIB_PROFILE_DESCRIPTOR_LIST  0x0009
#define SDP_ATTRIB_DOCUMENTATION_URL        0x000A
#define SDP_ATTRIB_CLIENT_EXECUTABLE_URL    0x000B
#define SDP_ATTRIB_ICON_URL                 0x000C

//
// Attribute IDs in the range of 0x000D - 0x01FF are reserved for future use
//
#define SDP_ATTRIB_PROFILE_SPECIFIC                     0x0200

#define STRING_NAME_OFFSET                              0x0000
#define STRING_DESCRIPTION_OFFSET                       0x0001
#define STRING_PROVIDER_NAME_OFFSET                     0x0002

#define SDP_ATTRIB_SDP_VERSION_NUMBER_LIST              0x0200 
#define SDP_ATTRIB_SDP_DATABASE_STATE                   0x0201

#define SDP_ATTRIB_BROWSE_GROUP_ID                      0x0200 

#define SDP_ATTRIB_CORDLESS_EXTERNAL_NETWORK            0x0301

#define SDP_ATTRIB_FAX_CLASS_1_SUPPORT                  0x0302
#define SDP_ATTRIB_FAX_CLASS_2_0_SUPPORT                0x0303
#define SDP_ATTRIB_FAX_CLASS_2_SUPPORT                  0x0304
#define SDP_ATTRIB_FAX_AUDIO_FEEDBACK_SUPPORT           0x0305

#define SDP_ATTRIB_HEADSET_REMOTE_AUDIO_VOLUME_CONTROL  0x0302

#define SDP_ATTRIB_LAN_LPSUBNET                         0x0200

#define SDP_ATTRIB_OBJECT_PUSH_SUPPORTED_FORMATS_LIST   0x0303

#define SDP_ATTRIB_SYNCH_SUPPORTED_DATA_STORES_LIST     0x0301

//  this is in the assigned numbers doc, but it does not show up in any profile
#define SDP_ATTRIB_SERVICE_VERSION                      0x0300

#define SDP_ATTRIB_PAN_SECURITY_DESCRIPTION             0x030A
#define SDP_ATTRIB_PAN_NET_ACCESS_TYPE                  0x030B
#define SDP_ATTRIB_PAN_MAX_NET_ACCESS_RATE              0x030C
#define SDP_ATTRIB_PAN_IPV4_SUBNET                      0x030D
#define SDP_ATTRIB_PAN_IPV6_SUBNET                      0x030E


// Bluetooth base UUID for service discovery
//
//DEFINE_GUID(Bluetooth_Base_UUID,   0x00000000, 0x0000, 0x1000, 0x70, 0x07, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(Bluetooth_Base_UUID,   0x00000000, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);

DEFINE_GUID(SDP_PROTOCOL_UUID,    0x00000001, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(UDP_PROTOCOL_UUID,    0x00000002, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(RFCOMM_PROTOCOL_UUID, 0x00000003, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(TCP_PROTOCOL_UUID,    0x00000004, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(TCSBIN_PROTOCOL_UUID, 0x00000005, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(TCSAT_PROTOCOL_UUID,  0x00000006, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(OBEX_PROTOCOL_UUID,   0x00000008, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(IP_PROTOCOL_UUID,     0x00000009, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(FTP_PROTOCOL_UUID,    0x0000000A, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(HTTP_PROTOCOL_UUID,   0x0000000C, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(WSP_PROTOCOL_UUID,    0x0000000E, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(BNEP_PROTOCOL_UUID,   0x0000000F, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(L2CAP_PROTOCOL_UUID,  0x00000100, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);

DEFINE_GUID(ServiceDiscoveryServerServiceClassID_UUID, 0x00001000, 0x0000, 0x1000, 0x80, 0x08, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(BrowseGroupDescriptorServiceClassID_UUID,  0x00001001, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(PublicBrowseGroupServiceClass_UUID,        0x00001002, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(SerialPortServiceClass_UUID,               0x00001101, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(LANAccessUsingPPPServiceClass_UUID,        0x00001102, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(DialupNetworkingServiceClass_UUID,         0x00001103, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(IrMCSyncServiceClass_UUID,                 0x00001104, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(OBEXObjectPushServiceClass_UUID,           0x00001105, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(OBEXFileTransferServiceClass_UUID,         0x00001106, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(IrMCSyncCommandServiceClass_UUID,          0x00001107, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(HeadsetServiceClass_UUID,                  0x00001108, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(CordlessTelephonyServiceClass_UUID,        0x00001109, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(AudioSourceServiceClass_UUID,              0x0000110A, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(AudioSinkServiceClass_UUID,                0x0000110B, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(AV_RemoteControlTargetServiceClass_UUID,   0x0000110C, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(AdvancedAudioDistributionServiceClass_UUID,0x0000110D, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(AV_RemoteControlServiceClass_UUID,         0x0000110E, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(VideoConferencingServiceClass_UUID,        0x0000110F, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(IntercomServiceClass_UUID,                 0x00001110, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(FaxServiceClass_UUID,                      0x00001111, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(HeadsetAudioGatewayServiceClass_UUID,      0x00001112, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(PANUServiceClass_UUID,                     0x00001115, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(NAPServiceClass_UUID,                      0x00001116, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(GNServiceClass_UUID,                       0x00001117, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(HandsfreeServiceClass_UUID,                0x0000111E, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(HandsfreeAudioGatewayServiceClass_UUID,    0x0000111F, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(HumanInterfaceDeviceServiceClass_UUID,     0x00001124, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(PhoneBookAccessProfile_UUID,               0x0000112F, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(PnPInformationServiceClass_UUID,           0x00001200, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(GenericNetworkingServiceClass_UUID,        0x00001201, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(GenericFileTransferServiceClass_UUID,      0x00001202, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(GenericAudioServiceClass_UUID,             0x00001203, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);
DEFINE_GUID(GenericTelephonyServiceClass_UUID,         0x00001204, 0x0000, 0x1000, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB);

#define SDP_PROTOCOL_UUID16     0x0001
#define UDP_PROTOCOL_UUID16     0x0002
#define RFCOMM_PROTOCOL_UUID16  0x0003
#define TCP_PROTOCOL_UUID16     0x0004
#define TCSBIN_PROTOCOL_UUID16  0x0005
#define TCSAT_PROTOCOL_UUID16   0x0006
#define OBEX_PROTOCOL_UUID16    0x0008
#define IP_PROTOCOL_UUID16      0x0009
#define FTP_PROTOCOL_UUID16     0x000A
#define HTTP_PROTOCOL_UUID16    0x000C
#define WSP_PROTOCOL_UUID16     0x000E
#define BNEP_PROTOCOL_UUID16    0x000F
#define HID_PROTOCOL_UUID16     0x0011
#define AVCTP_PROTOCOL_UUID16   0x0017
#define AVDTP_PROTOCOL_UUID16   0x0019
#define L2CAP_PROTOCOL_UUID16   0x0100

#define ServiceDiscoveryServerServiceClassID_UUID16     (0x1000)
#define BrowseGroupDescriptorServiceClassID_UUID16      (0x1001)
#define PublicBrowseGroupServiceClassID_UUID16          (0x1002)
#define SerialPortServiceClassID_UUID16                 (0x1101)
#define LANAccessUsingPPPServiceClassID_UUID16          (0x1102)
#define DialupNetworkingServiceClassID_UUID16           (0x1103)
#define IrMCSyncServiceClassID_UUID16                   (0x1104)
#define OBEXObjectPushServiceClassID_UUID16             (0x1105)
#define OBEXFileTransferServiceClassID_UUID16           (0x1106)
#define IrMcSyncCommandServiceClassID_UUID16            (0x1107)
#define HeadsetServiceClassID_UUID16                    (0x1108)
#define CordlessServiceClassID_UUID16                   (0x1109)
#define AudioSourceServiceClassID_UUID16                (0x110A)
#define AudioSinkServiceClassID_UUID16                  (0x110B)
#define AV_RemoteControlTargetServiceClassID_UUID16     (0x110C)
#define AdvancedAudioDistributionServiceClassID_UUID16  (0x110D)
#define AV_RemoteControlServiceClassID_UUID16           (0x110E)
#define VideoConferencingServiceClassID_UUID16          (0x110F)
#define IntercomServiceClassID_UUID16                   (0x1110)
#define FaxServiceClassID_UUID16                        (0x1111)
#define HeadsetAudioGatewayServiceClassID_UUID16        (0x1112)
#define PANUServiceClassID_UUID16                       (0x1115)
#define NAPServiceClassID_UUID16                        (0x1116)
#define GNServiceClassID_UUID16                         (0x1117)
#define HandsfreeServiceClassID_UUID16                  (0x111E)
#define HandsfreeAudioGatewayServiceClassID_UUID16      (0x111F)
#define PhoneBookAccessProfile_UUID16                   (0x112F)
#define PnPInformationServiceClassID_UUID16             (0x1200)
#define GenericNetworkingServiceClassID_UUID16          (0x1201)
#define GenericFileTransferServiceClassID_UUID16        (0x1202)
#define GenericAudioServiceClassID_UUID16               (0x1203)
#define GenericTelephonyServiceClassID_UUID16           (0x1204)

#define PSM_SDP                 0x0001
#define PSM_RFCOMM              0x0003
#define PSM_TCS_BIN             0x0005
#define PSM_TCS_BIN_CORDLESS    0x0007


// HID specific SDP attrib ids.
#define SDP_ATTRIB_HID_DEVICE_RELEASE_NUMBER    0x0200
#define SDP_ATTRIB_HID_PARSER_VERSION           0x0201
#define SDP_ATTRIB_HID_DEVICE_SUBCLASS          0x0202
#define SDP_ATTRIB_HID_COUNTRY_CODE             0x0203
#define SDP_ATTRIB_HID_VIRTUAL_CABLE            0x0204
#define SDP_ATTRIB_HID_RECONNECT_INITIATE       0x0205
#define SDP_ATTRIB_HID_DESCRIPTOR_LIST          0x0206
#define SDP_ATTRIB_HID_LANGID_BASE_LIST         0x0207
#define SDP_ATTRIB_HID_SDP_DISABLE              0x0208
#define SDP_ATTRIB_HID_BATTERY_POWER            0x0209
#define SDP_ATTRIB_HID_REMOTE_WAKE              0x020A
#define SDP_ATTRIB_HID_PROFILE_VERSION          0x020B
#define SDP_ATTRIB_HID_SUPERVISION_TIMEOUT      0x020C
#define SDP_ATTRIB_HID_NORMALLY_CONNECTABLE     0x020D
#define SDP_ATTRIB_HID_BOOT_DEVICE              0x020E

#endif		/* __bt_sdp_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\bt_api.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//------------------------------------------------------------------------------
// 
//      Bluetooth client API declarations
// 
// 
// Module Name:
// 
//      bt_api.h
// 
// Abstract:
// 
//      This file defines client-level APIs to Bluetooth stack
// 
// 
//------------------------------------------------------------------------------
//
//Blietooth client API
//

#pragma once

#if ! defined (__bt_api_H__)
#define __bt_api_H__        1

#include <windows.h>
#include <ws2bth.h>
#include <winioctl.h>

#if defined (__cplusplus)
extern "C" {
#endif

//
//      COD classes
//

#define GET_MAJOR_SERVICE_COD(dwCOD)                            (dwCOD & 0x00FFE000) //bits 13-23
#define BTH_COD_MAJOR_SERVICE_CLASS_INFORMATION                 0x00800000
#define BTH_COD_MAJOR_SERVICE_CLASS_TELEPHONY                   0x00400000
#define BTH_COD_MAJOR_SERVICE_CLASS_AUDIO                       0x00200000
#define BTH_COD_MAJOR_SERVICE_CLASS_OBEX                        0x00100000
#define BTH_COD_MAJOR_SERVICE_CLASS_CAPTURE                     0x00080000
#define BTH_COD_MAJOR_SERVICE_CLASS_RENDERING                   0x00040000
#define BTH_COD_MAJOR_SERVICE_CLASS_NETWORK                     0x00020000
#define BTH_COD_MAJOR_SERVICE_CLASS_POSITIONING                 0x00010000
#define BTH_COD_MAJOR_SERVICE_CLASS_LIMITED_DISC                0x00002000

#define GET_MAJOR_DEVICE_COD(dwCOD)                             (dwCOD & 0x00001F00) //bits 8-12
#define BTH_COD_MAJOR_DEVICE_CLASS_MISC                         0x00000000
#define BTH_COD_MAJOR_DEVICE_CLASS_COMPUTER                     0x00000100
#define BTH_COD_MAJOR_DEVICE_CLASS_PHONE                        0x00000200
#define BTH_COD_MAJOR_DEVICE_CLASS_LAP                          0x00000300
#define BTH_COD_MAJOR_DEVICE_CLASS_AV                           0x00000400
#define BTH_COD_MAJOR_DEVICE_CLASS_PERIPHERAL                   0x00000500
#define BTH_COD_MAJOR_DEVICE_CLASS_IMAGING                      0x00000600
#define BTH_COD_MAJOR_DEVICE_CLASS_UNCLASSIFIED                 0x00001F00

#define GET_MINOR_COMPUTER_COD(dwCOD)                           (dwCOD & 0x000000FC) //bits 2-7
#define BTH_COD_MINOR_COMPUTER_UNCLASSIFIED         0x00000000
#define BTH_COD_MINOR_COMPUTER_DESKTOP              0x00000004
#define BTH_COD_MINOR_COMPUTER_SERVER               0x00000008
#define BTH_COD_MINOR_COMPUTER_LAPTOP               0x0000000C
#define BTH_COD_MINOR_COMPUTER_HANDHELD                         0x00000010
#define BTH_COD_MINOR_COMPUTER_PDA                              0x00000014
#define BTH_COD_MINOR_COMPUTER_WEARABLE                         0x00000018

#define GET_MINOR_PHONE_COD(dwCOD)                              (dwCOD & 0x000000FC) //bits 2-7
#define BTH_COD_MINOR_PHONE_UNCLASSIFIED                        0x00000000
#define BTH_COD_MINOR_PHONE_CELL                                0x00000004
#define BTH_COD_MINOR_PHONE_CORDLESS                            0x00000008
#define BTH_COD_MINOR_PHONE_SMART                               0x0000000C
#define BTH_COD_MINOR_PHONE_WIRED                               0x00000010
#define BTH_COD_MINOR_PHONE_ISDN                                0x00000014

#define GET_MINOR_LAP_COD(dwCOD)                                (dwCOD & 0x000000E0) //bits 5-7
#define BTH_COD_MINOR_LAP_AVAILABLE                             0x00000000
#define BTH_COD_MINOR_LAP_1_17                                  0x00000020
#define BTH_COD_MINOR_LAP_17_33                                 0x00000040
#define BTH_COD_MINOR_LAP_33_50                                 0x00000060
#define BTH_COD_MINOR_LAP_50_67                                 0x00000080
#define BTH_COD_MINOR_LAP_67_83                                 0x000000A0
#define BTH_COD_MINOR_LAP_83_99                                 0x000000C0
#define BTH_COD_MINOR_LAP_NO_SERVICE                            0x000000E0

#define GET_MINOR_AV_COD(dwCOD)                                 (dwCOD & 0x000000FC) //bits 2-7
#define BTH_COD_MINOR_AV_UNCLASSIFIED                           0x00000000
#define BTH_COD_MINOR_AV_HEADSET                                0x00000004
#define BTH_COD_MINOR_AV_HANDSFREE                              0x00000008
// reserved                                                     0x0000000C
#define BTH_COD_MINOR_AV_MICROPHONE                             0x00000010
#define BTH_COD_MINOR_AV_LOUDSPEAKER                            0x00000014
#define BTH_COD_MINOR_AV_HEADPHONE                              0x00000018
#define BTH_COD_MINOR_AV_PORTABLE                               0x0000001C
#define BTH_COD_MINOR_AV_CAR                                    0x00000020
#define BTH_COD_MINOR_AV_SETTOP                                 0x00000024
#define BTH_COD_MINOR_AV_HIFI                                   0x00000028
#define BTH_COD_MINOR_AV_VCR                                    0x0000002C
#define BTH_COD_MINOR_AV_CAMERA                                 0x00000030
#define BTH_COD_MINOR_AV_CAMCORDER                              0x00000034
#define BTH_COD_MINOR_AV_DISPLAY                                0x00000038
#define BTH_COD_MINOR_AV_DISPLAYSPEAKER                         0x0000003C
#define BTH_COD_MINOR_AV_CONFERENCING                           0x00000040
// reserved                                                     0x00000044
#define BTH_COD_MINOR_AV_GAMING                                 0x00000048

#define GET_MINOR_FN_PERIPHERAL_COD(dwCOD)                      (dwCOD & 0x0000003C) //bits 2-5
#define BTH_COD_MINOR_FN_PERIPHERAL_UNCLASSIFIED                0x00000000
#define BTH_COD_MINOR_FN_PERIPHERAL_JOYSTICK                    0x00000004
#define BTH_COD_MINOR_FN_PERIPHERAL_GAMEPAD                     0x00000008
#define BTH_COD_MINOR_FN_PERIPHERAL_REMOTE                      0x0000000C
#define BTH_COD_MINOR_FN_PERIPHERAL_SENSING                     0x00000010
#define BTH_COD_MINOR_FN_PERIPHERAL_TABLET                      0x00000014
#define BTH_COD_MINOR_FN_PERIPHERAL_CARDREADER                  0x0000001C

#define GET_MINOR_PERIPHERAL_COD(dwCOD)                         (dwCOD & 0x000000C0) //bits 6-7
#define BTH_COD_MINOR_PERIPHERAL_KEYBOARD                       0x00000040
#define BTH_COD_MINOR_PERIPHERAL_POINTING                       0x00000080
#define BTH_COD_MINOR_PERIPHERAL_COMBO                          0x000000C0

#define GET_MINOR_FN_IMAGING_COD(dwCOD)                         (dwCOD & 0x000000F0) //bits 4-7
#define BTH_COD_MINOR_FN_IMAGING_DISPLAY                        0x00000010
#define BTH_COD_MINOR_FN_IMAGING_CAMERA                         0x00000020
#define BTH_COD_MINOR_FN_IMAGING_SCANNER                        0x00000040
#define BTH_COD_MINOR_FN_IMAGING_PRINTER                        0x00000080

// Defined for backwards compatibility
#define BTH_COD_MAJOR_DEVICE_CLASS_AUDIO                        BTH_COD_MAJOR_DEVICE_CLASS_AV
#define BTH_COD_MINOR_AUDIO_UNCLASSIFIED                        BTH_COD_MINOR_AV_UNCLASSIFIED
#define BTH_COD_MINOR_AUDIO_HEADSET                             BTH_COD_MINOR_AV_HEADSET

#define BTH_NAMEDEVENT_PAIRING_CHANGED              L"system/events/bluetooth/PairingChange"
#define BTH_NAMEDEVENT_HARDWARE_CHANGED             L"system/events/bluetooth/HardwareChange"
#define BTH_NAMEDEVENT_DEVICEID_CHANGED             L"system/events/bluetooth/DeviceIdChange"
#define BTH_NAMEDEVENT_CONNECTIVITY_CHANGED         L"system/events/bluetooth/ConnectivityChange"
#define BTH_NAMEDEVENT_SECURITY_CHANGED             L"system/events/bluetooth/SecurityChange"
#define BTH_NAMEDEVENT_CONNECTIONS_CHANGED          L"system/events/bluetooth/ConnectionsChange"
#define BTH_NAMEDEVENT_BASEBAND_CHANGED             L"system/events/bluetooth/BasebandChange"
#define BTH_NAMEDEVENT_STACK_INITED                 L"system/events/bluetooth/StackInitialized"
#define BTH_NAMEDEVENT_PAN_REFRESH                  L"system/events/bluetooth/pan/refresh"

#define BTH_MAX_PIN_LENGTH  16

// Helpful macro for StringCchPrintf
#define STRING_AND_COUNTOF(s) (s), _countof(s)

#if ! defined (__bt_ddi_H__)
//
//  Attention: also defined in bt_ddi.h! Keep in sync!
//
//  Hardware Status
//
#define HCI_HARDWARE_UNKNOWN                            0
#define HCI_HARDWARE_NOT_PRESENT                        1
#define HCI_HARDWARE_INITIALIZING                       2
#define HCI_HARDWARE_RUNNING                            3
#define HCI_HARDWARE_SHUTDOWN                           4
#define HCI_HARDWARE_ERROR                              5

#define BTH_MIN_PIN_SIZE     1
#define BTH_MAX_PIN_SIZE    16
#define BTH_LINK_KEY_SIZE   16

#endif

#define BTH_GET_BASEBAND_CONNECTIONS_EX_API_VERSION      1

typedef struct _BASEBAND_CONNECTION
{
    USHORT      hConnection;
    BT_ADDR     baAddress;
    int         cDataPacketsPending;
    UINT        fLinkType       : 1;
    UINT        fEncrypted      : 1;
    UINT        fAuthenticated  : 1;
    UINT        fMode           : 3;
} BASEBAND_CONNECTION, *PBASEBAND_CONNECTION;

typedef struct _BASEBAND_CONNECTION_EX
{
    USHORT      hConnection;    
    BT_ADDR     baAddress;
    int         cDataPacketsPending;
    UCHAR       link_type;
    UCHAR       mode;
    UINT        fEncrypted      : 1;
    BOOL        fAuthenticated  : 1;
} BASEBAND_CONNECTION_EX, *PBASEBAND_CONNECTION_EX;


#define HCI_PAGE_SCAN_TYPE_STANDARD         0x00
#define HCI_PAGE_SCAN_TYPE_INTERLACED       0x01

#define HCI_INQUIRY_SCAN_TYPE_STANDARD      0x00
#define HCI_INQUIRY_SCAN_TYPE_INTERLACED    0x01


// Scan Enable bitmask
#define SCAN_ENABLE_INQUIRY 0x01
#define SCAN_ENABLE_PAGE    0x02

//
// Warning: To use the following Bth* APIs you must link to btdrt.lib.  
//          This library may or may not be available in your SDK.
//
// To preserve Win32 compatibility, consider using the Winsock equivalent 
// of these functions.
//

//
//  Management APIs
//
int BthWriteScanEnableMask
(
unsigned char   mask
);

int BthReadScanEnableMask
(
unsigned char   *pmask
);

int BthWritePageTimeout
(
unsigned short timeout
);

int BthReadPageTimeout
(
unsigned short *ptimeout
);

int BthWriteCOD
(
unsigned int    cod
);

int BthReadCOD
(
unsigned int    *pcod
);

int BthGetRemoteCOD
(
BT_ADDR         *pbt,
unsigned int    *pcod
);

int BthWriteAuthenticationEnable
(
unsigned char   ae
);

int BthReadAuthenticationEnable
(
unsigned char   *pae
);

int BthWriteLinkPolicySettings
(
BT_ADDR         *pba,
unsigned short  lps
);

int BthReadLinkPolicySettings
(
BT_ADDR         *pba,
unsigned short  *plps
);

int BthEnterHoldMode
(
BT_ADDR         *pba,
unsigned short  hold_mode_max,
unsigned short  hold_mode_min,
unsigned short  *pinterval
);

int BthEnterSniffMode
(
BT_ADDR         *pba,
unsigned short  sniff_mode_max,
unsigned short  sniff_mode_min,
unsigned short  sniff_attempt,
unsigned short  sniff_timeout,
unsigned short  *pinterval
);

int BthExitSniffMode
(
BT_ADDR         *pba
);

int BthSetSSRParameters
(
BT_ADDR         *pba,
unsigned short  ssr_max_latency,
unsigned short  ssr_min_remote_timeout,
unsigned short  ssr_min_local_timeout
);


int BthWriteLSTO
(
BT_ADDR            *pbt,
unsigned short    timeout
);

int BthReadLSTO
(
BT_ADDR            *pbt,
unsigned short    *ptimeout
);

int BthEnterParkMode
(
BT_ADDR         *pba,
unsigned short  beacon_max,
unsigned short  beacon_min,
unsigned short  *pinterval
);

int BthExitParkMode
(
BT_ADDR         *pba
);

int BthGetCurrentMode
(
BT_ADDR         *pba,
unsigned char   *pmode
);

int BthGetBasebandHandles
(
int             cHandles,
__out_ecount(cHandles) unsigned short   *pHandles,
int             *pcHandlesReturned
);

int BthGetBasebandConnections
(
int                 cConnections,
__out_ecount(cConnections) BASEBAND_CONNECTION  *pConnections,
int                 *pcConnectionsReturned
);

int BthGetBasebandConnectionsEx
(
DWORD dwApiVersion,
int cConnections,
__out_ecount(cConnections) BASEBAND_CONNECTION_EX *pConnections,
int *pcConnectionsReturned
);

int BthGetAddress
(
unsigned short  handle,
BT_ADDR         *pba
);

int BthReadLocalAddr
(
BT_ADDR         *pba
);

int BthGetHardwareStatus
(
int             *pistatus
);

int BthReadLocalVersion
(
unsigned char   *phci_version,
unsigned short  *phci_revision,
unsigned char   *plmp_version,
unsigned short  *plmp_subversion,
unsigned short  *pmanufacturer,
unsigned char   *plmp_features
);

int BthReadRemoteVersion
(
BT_ADDR         *pba,
unsigned char   *plmp_version,
unsigned short  *plmp_subversion,
unsigned short  *pmanufacturer,
unsigned char   *plmp_features
);

DWORD BthReadRemoteExtendedFeatures(
    __in  const BT_ADDR  *pba,
    __in  BYTE            PageNumber,
    __out BYTE            LMPFeatures[8]);

int BthPerformInquiry
(
unsigned int     LAP,
unsigned char    length,
unsigned char    num_responses,
unsigned int     cElems,
unsigned int     *pcDiscoveredDevices,
__out_ecount(cElems) BthInquiryResult *InquiryList
);

int 
BthStartInquiryAsync(
    UINT LAP,
    UCHAR length,
    UCHAR cNumResponses);

int BthCancelInquiry
(
void
);

int BthRemoteNameQuery
(
BT_ADDR         *pba,
unsigned int    cBuffer,
unsigned int    *pcRequired,
__out_ecount(cBuffer) WCHAR         *szString
);

int BthCancelRemoteNameQuery
(
BT_ADDR         *pba
);

int BthTerminateIdleConnections
(
void
);

int BthSetInquiryFilter
(
BT_ADDR         *pba
);

int BthSetCODInquiryFilter
(
 unsigned int cod,
 unsigned int codMask
);

int BthClearInquiryFilter
(
void
);

int BthSwitchRole
(
BT_ADDR* pbt,     
USHORT usRole     
);

int BthGetRole
(
BT_ADDR* pbt,     
USHORT* pusRole
);

int BthReadRSSI
(
BT_ADDR* pbt, 
BYTE* pbRSSI
);


//
//  Security manager APIs
//
int BthSetPIN
(
BT_ADDR         *pba,
int             cPinLength,
unsigned char   *ppin
);

int BthRevokePIN
(
BT_ADDR         *pba
);

int BthSetLinkKey
(
BT_ADDR         *pba,
unsigned char   key[16]
);

int BthGetLinkKey
(
BT_ADDR         *pba,
unsigned char   key[16]
);

int BthRevokeLinkKey
(
BT_ADDR         *pba
);

int BthAuthenticate
(
BT_ADDR         *pba
);

typedef enum BTSecurityLevel
{                       // Link key requirement (SSP / Pre-2.1):
    BTSecurityLevel_0,  // None             / None
    BTSecurityLevel_1,  // Unauthenticated  / None
    BTSecurityLevel_2,  // Unauthenticated  / Combination
    BTSecurityLevel_3   // Authenticated    / Combination 
} BTSecurityLevel;

typedef enum BTSSPBondingType
{
    BTSSPBonding_None = 0,
    BTSSPBonding_Dedicated = 1,
    BTSSPBonding_General = 2
} BTSSPBondingType;

//
//  BthAuthenticateEx is called to authenticate the connection to
//  the specified remote device to ensure that the link key meets
//  the required SecurityLevel.
//
//  If the current link key for the connection is sufficient to meet
//  the required SecurityLevel, then no new authentication will take place.
//
//  If a new link key is generated, then it will be saved for reuse
//  on subsequent connections to the remote device if PersistKey = TRUE.
//
DWORD 
BthAuthenticateEx(
    __in  const BT_ADDR             *pRemoteDevice,
    __in  const BTSecurityLevel      RequiredSecurityLevel,
    __in  const BTSSPBondingType     BondingType,
    __in  const BOOL                 PersistKey);


int BthSetEncryption
(
BT_ADDR         *pba,
int             fOn
);

int BthSetSecurityUI
(
HANDLE      hEvent,
DWORD       dwStoreTimeout,
DWORD       dwProcTimeout
);

int BthGetPINRequest
(
BT_ADDR *pbt
);

int BthRefusePINRequest
(
BT_ADDR *pbt
);

int BthAnswerPairRequest 
(
BT_ADDR *pba,
int cPinLength,
__in_bcount(cPinLength) unsigned char *ppin
);

int BthPairRequest 
(
BT_ADDR *pba,
int cPinLength,
__in_bcount(cPinLength) unsigned char *ppin
);

//
//  Connection APIs
//

int BthCreateACLConnection
(
BT_ADDR         *pbt,
unsigned short  *phandle
);

int BthCreateSCOConnection
(
BT_ADDR         *pbt,
unsigned short  *phandle
);

int BthCloseConnection
(
unsigned short  handle
);

int BthAcceptSCOConnections
(
BOOL fAccept
);

int BthWritePageScanActivity
(
unsigned short pageScanInterval,
unsigned short pageScanWindow
);

int BthWriteInquiryScanActivity
(
unsigned short inquiryScanInterval,
unsigned short inquiryScanWindow
);

int BthReadPageScanActivity
(
unsigned short* pPageScanInterval,
unsigned short* pPageScanWindow
);

int BthReadInquiryScanActivity
(
unsigned short* pInquiryScanInterval,
unsigned short* pInquiryScanWindow
);

int BthWritePageScanType
(
unsigned char pageScanType
);

int BthWriteInquiryScanType
(
unsigned char inquiryScanType
);

int BthReadPageScanType
(
unsigned char* pPageScanType
);

int BthReadInquiryScanType
(
unsigned char* pInquiryScanType
);

int BthCreateSynchronousConnection
(
BT_ADDR         *pbt,
unsigned short  *pHandle,
unsigned int    txBandwidth,
unsigned int    rxBandwidth,
unsigned short  maxLatency,
unsigned short  voiceSetting,
unsigned char   retransmit
);

int BthAcceptSynchronousConnections
(
BOOL fAccept
);

BOOL BthIsProfileAllowed
(
GUID uuidService
);

int
BthSetLocalEirRecord(
    BYTE cbLength,
    BYTE bDataType,
    PBYTE pData);

int
BthRemoveLocalEirRecord(    
    BYTE bDataType);

int
BthFindFirstEirRecord(
    __in BT_ADDR* pbta,
    __out PBYTE pcbLength,
    __out PBYTE pbDataType,
    __out PBYTE pData,
    __in DWORD cbDataBuffer,
    HANDLE* phFind);

int
BthFindNextEirRecord(
    __in HANDLE hFind,    
    __out PBYTE pcbLength,
    __out PBYTE pbDataType,
    __out PBYTE pData,
    __in DWORD cbDataBuffer);

int
BthFindEirRecordClose(
    __in HANDLE hFind);

int
BthGetEirRecord(
    __in BT_ADDR* pbta,
    __in BYTE bDataType,
    __out PBYTE pcbLength,
    __out PBYTE pData,
    __in DWORD cbDataBuffer);

//
//  SDP Name Service APIs
//
typedef struct _SdpAttributeRange SdpAttributeRange;
typedef struct _SdpQueryUuid      SdpQueryUuid;
typedef struct _WSAQuerySetW *LPWSAQUERYSET;
typedef enum _WSAESETSERVICEOP WSAESETSERVICEOP;


int BthNsSetService(LPWSAQUERYSET pSet, WSAESETSERVICEOP op, DWORD dwFlags);
int BthNsLookupServiceBegin(LPWSAQUERYSET pQuerySet, DWORD dwFlags, LPHANDLE lphLookup);
int BthNsLookupServiceNext(HANDLE hLookup, DWORD dwFlags, LPDWORD lpdwBufferLength, __out_bcount_opt(*lpdwBufferLength) LPWSAQUERYSET pResults);
int BthNsLookupServiceEnd(HANDLE hLookup);

//
//  RFCOMM Apis
//
#define RFCOMM_PORT_FLAGS_REMOTE_DCB    0x00000001
#define RFCOMM_PORT_FLAGS_KEEP_DCD      0x00000002
#define RFCOMM_PORT_FLAGS_AUTHENTICATE  0x00000004
#define RFCOMM_PORT_FLAGS_ENCRYPT       0x00000008

#if ! defined (__bt_ddi_H__)
//
//  Attention: also defined in bt_ddi.h! Keep in sync!
//
//  channel:
//      RFCOMM_CHANNEL_ALL          accept connection on all channels (default upper layer)
//      RFCOMM_CHANNEL_CLIENT_ONLY  do not accept connections at all (client only)
//      ...or channel to restrict connections on
//
#define RFCOMM_CHANNEL_ALL          0x00
#define RFCOMM_CHANNEL_MULTIPLE     0xfe
#define RFCOMM_CHANNEL_CLIENT_ONLY  0xff
#endif

typedef struct _portemu_port_params {
    int             channel;
    int             flocal;
    BT_ADDR         device;
    int             imtu;
    int             iminmtu;
    int             imaxmtu;
    int             isendquota;
    int             irecvquota;
    GUID            uuidService;
    unsigned int    uiportflags;
} PORTEMUPortParams;

//  Bluetooth serial IOCTLs are cross-defined in pegdser.h to reserve spot there.
#define IOCTL_BLUETOOTH_GET_RFCOMM_CHANNEL  CTL_CODE(FILE_DEVICE_SERIAL_PORT,24,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_BLUETOOTH_GET_PEER_DEVICE     CTL_CODE(FILE_DEVICE_SERIAL_PORT,25,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// Bluetooth COM port registration
//

HANDLE RegisterBluetoothCOMPort
(
LPCWSTR lpszType,           // "BSP" or "COM"
DWORD dwIndex,              // device index
PORTEMUPortParams* pParams  // BT specific params
);

BOOL DeregisterBluetoothCOMPort
(
HANDLE hDevice
);


//
// Bluetooth notification system
//

HANDLE RequestBluetoothNotifications
(
DWORD dwClass,  // class of notifications to register for
HANDLE hMsgQ    // message queue created by caller
);

BOOL StopBluetoothNotifications
(
HANDLE h        // Handle returned from RequestBluetoothNotifications
);

typedef struct _BTEVENT {
    DWORD dwEventId;        // Event ID    
    DWORD dwReserved;       // Reserved
    BYTE baEventData[64];   // Event Data
} BTEVENT, *PBTEVENT;

int BthNotifyEvent(PBTEVENT pbtEvent, DWORD dwEventClass);

//
// Bluetooth notification event classes
//
#define BTE_CLASS_CONNECTIONS   0x00000001
#define BTE_CLASS_PAIRING       0x00000002
#define BTE_CLASS_DEVICE        0x00000004
#define BTE_CLASS_STACK         0x00000008
#define BTE_CLASS_AVDTP         0x00000010
#define BTE_CLASS_PAN           0x00000020
#define BTE_CLASS_INQUIRY       0x00000040
#define BTE_CLASS_SSP           0x00000080
#define BTE_CLASS_SERVICE       0x00000100

//
// Bluetooth notification event identifiers
//

// Connection class
#define BTE_CONNECTION                      100
#define BTE_DISCONNECTION                   101
#define BTE_ROLE_SWITCH                     102
#define BTE_MODE_CHANGE                     103
#define BTE_PAGE_TIMEOUT                    104
#define BTE_CONNECTION_AUTH_FAILURE         105
#define BTE_SSR_EVENT                       106
// Pairing class
#define BTE_KEY_NOTIFY                      200
#define BTE_KEY_REVOKED                     201
// Device class
#define BTE_LOCAL_NAME                      300
#define BTE_COD                             301
#define BTE_SCAN_MODE                       302
// Stack class
#define BTE_STACK_UP                        400
#define BTE_STACK_DOWN                      401
#define BTE_WINSOCK_UP                      402
// AVDTP class
#define BTE_AVDTP_STATE                     500
// PAN class
#define BTE_PAN_CONNECTIONS                 600
// Inquiry class
#define BTE_INQUIRY_RESULT                  700
#define BTE_INQUIRY_COMPLETE                701
#define BTE_INQUIRY_CANCEL                  702
// Service class
#define BTE_SERVICE_CONNECTION_REQUEST      900
#define BTE_SERVICE_DISCONNECTION_REQUEST   901
#define BTE_SERVICE_CONNECTION_EVENT        902
#define BTE_SERVICE_DISCONNECTION_EVENT     903

//
// Bluetooth notification data structures
// 

// Connection class data structures
typedef struct {
    DWORD dwSize;         // To keep track of version
    USHORT hConnection;   // Baseband connection handle
    BT_ADDR bta;          // Address of remote device
    UCHAR ucLinkType;     // Link Type (ACL/SCO)
    UCHAR ucEncryptMode;  // Encryption mode
} BT_CONNECT_EVENT, *PBT_CONNECT_EVENT;

typedef struct {
    DWORD dwSize;         // To keep track of version
    USHORT hConnection;   // Baseband connection handle
    UCHAR ucReason;       // Reason for disconnection
} BT_DISCONNECT_EVENT, *PBT_DISCONNECT_EVENT;

typedef struct {
    DWORD dwSize;         // To keep track of version
    BT_ADDR bta;          // Address of remote device
    UINT fRole : 1;       // New Role (master/slave)
} BT_ROLE_SWITCH_EVENT, *PBT_ROLE_SWITCH_EVENT;

typedef struct {
    DWORD dwSize;         // To keep track of version
    USHORT hConnection;   // Baseband connection handle
    BT_ADDR bta;          // Address of remote device
    BYTE bMode;           // Power mode (sniff, etc)
    USHORT usInterval;    // Power mode interval 
} BT_MODE_CHANGE_EVENT, *PBT_MODE_CHANGE_EVENT;

typedef struct {
    DWORD dwSize;         // To keep track of version
    USHORT hConnection;   // Baseband connection handle
    BT_ADDR bta;          // Address of remote device
    USHORT status;
    USHORT maximum_transmit_latency;
    USHORT maximum_receive_latency;
    USHORT minimum_remote_timeout;
    USHORT minimum_local_timeout;
} BT_SSR_EVENT, *PBT_SSRPARAM_CHANGE_EVENT;


// Pairing class data structures

typedef struct {
    DWORD dwSize;        // To keep track of version
    BT_ADDR bta;         // Address of remote device
    UCHAR link_key[16];  // Link key data
    UCHAR key_type;      // Link key type
} BT_LINK_KEY_EVENT, *PBT_LINK_KEY_EVENT;

// Device class data structures

typedef struct {
    DWORD dwSize;       // To keep track of version
    UCHAR scan_mode;    // Scan enable mask
} BT_SCAN_MODE_EVENT, *PBT_SCAN_MODE_EVENT;


// AVDTP class data structures

#define BT_AVDTP_STATE_DISCONNECTED     0
#define BT_AVDTP_STATE_SUSPENDED        1
#define BT_AVDTP_STATE_STREAMING        2

typedef struct {
    DWORD dwSize;       // To keep track of version
    BT_ADDR bta;        // Address of remote device
    DWORD dwState;      // New state of the AVDTP stream
} BT_AVDTP_STATE_CHANGE, *PBT_AVDTP_STATE_CHANGE;


// PAN class data structures

typedef struct {
    DWORD dwSize;       // To keep track of version
    DWORD NumConnections; // Number of peers connected
} BT_PAN_NUM_CONNECTIONS, *PBT_PAN_NUM_CONNECTIONS;


// Inquiry class data structures

typedef struct {
    DWORD dwSize;
    BT_ADDR bta;
    UINT uiCod;
    UCHAR ucRssi;
    BOOL fNamePresent : 1;
} BT_INQUIRY_RESULT_EVENT, *PBT_INQUIRY_RESULT_EVENT;


// Service class data structures

typedef struct {
    DWORD dwSize;
    BT_ADDR btAddr;
    GUID uuidService;
} BT_SERVICE_REQUEST, *PBT_SERVICE_REQUEST;


//
// Secure Simple Pairing (SSP) Data Types and APIs
//

typedef enum BTSSPIOCapability
{
    BTSSPIO_DisplayOnly  = 0x00,
    BTSSPIO_DisplayYesNo = 0x01,
    BTSSPIO_KeyboardOnly = 0x02,
    BTSSPIO_NoIO         = 0x03,
    BTSSPIO_Unspecified  = 0xFF
} BTSSPIOCapability;

typedef struct BTSSPAuthRequirement   
{
    BOOL                 MITMProtectionRequired;
    BTSSPBondingType     BondingType;
} BTSSPAuthRequirement;

typedef struct BTSSPConfigurationInfo
{
    BTSSPIOCapability    IOCapability;
    DWORD                Flags;
#define BT_SSP_FLAG_INDICATE_IO_CAPABILITY_REQUEST_EVENTS (1<<0)
#define BT_SSP_FLAG_INDICATE_OOB_DATA_REQUEST_EVENTS      (1<<1)
#define BT_SSP_FLAG_BASEBAND_SSP_DISABLE                  (1<<2)
// Flag bits 3-31 are reserved and should be set to zero

} BTSSPConfigurationInfo;

typedef enum  BTSSP_Keypress_Notification_Type
{
    BTSSP_Keypress_Notification_Started = 0,
    BTSSP_Keypress_Notification_Digit_Entered = 1,
    BTSSP_Keypress_Notification_Digit_Erased = 2,
    BTSSP_Keypress_Notification_Cleared = 3,
    BTSSP_Keypress_Notification_Completed = 4
} BTSSP_Keypress_Notification_Type;

#define BTSSP_HASH_SIZE       16
#define BTSSP_RANDOMIZER_SIZE 16

typedef struct BTSSPOOBData
{
    BYTE C[BTSSP_HASH_SIZE];         // 16 byte Hash
    BYTE R[BTSSP_RANDOMIZER_SIZE];   // 16 byte Randomizer
} BTSSPOOBData;

// BthSSPLocalSupported will determine whether the local BT device supports SSP.
// If supported, then *SSPSupported will be set to true, otherwise false.
DWORD BthSSPLocalSupported(__out BOOL *SSPSupported);

// BthSSPRemoteSupported will determine whether the remote BT device supports SSP.
// If supported, then *SSPSupported will be set to true, otherwise false.
DWORD BthSSPRemoteSupported(__in BT_ADDR RemoteDevice, __out BOOL *SSPSupported);

// Register a message queue to receive BTE_CLASS_SSP events
HANDLE BthSSPRequestNotifications(__in HANDLE hMsgQ);

// Stop receiving BTE_CLASS_SSP events
// The parameter "h" is the return value from BthSSPRequestNotifications
BOOL BthSSPStopNotifications(__in HANDLE h);

// BthSSPSetConfigurationInfo is called to enable the use of SSP.
// It must be called prior to calling any other BthSSPXxx APIs other than BthSSPIsSupported. 
DWORD BthSSPSetConfigurationInfo(__in const BTSSPConfigurationInfo *pInfo);

// Retrieve the setting from the most recent call to BthSSPSetConfigurationInfo.
DWORD BthSSPGetConfigurationInfo(__out BTSSPConfigurationInfo *pInfo);

// BthSSPPairRequest is called to initiate pairing using the SSP procedure to the specified remote device.
DWORD BthSSPPairRequest(__in const BT_ADDR *RemoteDevice);

// BthSSPAbortPairing aborts any pairing attempt in progress with the specified device
DWORD BthSSPAbortPairing(__in const BT_ADDR *RemoteDevice);

// BthSSPUserConfirmationRequestReply is called after the user accepts or rejects a numeric value
// displayed as a result of a User Confirmation Request Event.
//
// "UserAccepted" should be "true" if the user accepted the displayed value as being correct
// (e.g. by pressing the "OK" button of a confirmation dialog),
//  or "false" if the user rejected the value (e.g. by pressing the "Cancel" button of a confirmation dialog).
//
DWORD BthSSPUserConfirmationRequestReply(__in const BT_ADDR *RemoteDevice, BOOL UserAccepted);

// BthSSPUserPasskeyRequestReply is called after the user enters (or refuses to enter)
// a 6 decimal digit passkey as a result of a User Passkey Request Event.
// If the user entered a passkey then "HavePasskey" should be "true" and
// "Passkey" should be set to the entered value.
// If no passkey is available then HavePasskey should be false and Passkey is ignored.
DWORD BthSSPUserPasskeyRequestReply(const BT_ADDR *RemoteDevice, BOOL HavePasskey, UINT Passkey);

// BthSSPSendKeypressNotification is called to indicate progress being made as the user
// types the passkey into the keyboard in response to a User Passkey Request Event.
DWORD BthSSPSendKeypressNotification(__in const BT_ADDR *RemoteDevice, BTSSP_Keypress_Notification_Type Type);

// BthSSPSetRemoteOOBData is called by an application to set the OOB data 
// that has been received from the peer through the OOB mechanism.
// Default is no OOB data present.
DWORD BthSSPSetRemoteOOBData(__in const BT_ADDR *RemoteDevice, __in const BTSSPOOBData *pData);

// Retrieve the OOB data set for the specified RemoteDevice in an earlier call to BthSSPSetRemoteOOBData
DWORD BthSSPGetRemoteOOBData(__in const BT_ADDR * RemoteDevice, __out BTSSPOOBData *pData);

// BthSSPReadLocalOOBData to retrieve the local values of C and R for transmission to a peer through an OOB mechanism.
DWORD BthSSPReadLocalOOBData(__out BTSSPOOBData *pData);

// BthSSPIOCapabilityRequestReply is used to respond to an SSP IO Capability Request from the peer
DWORD  BthSSPIOCapabilityRequestReply(
    __in const BT_ADDR              *RemoteDevice,
    __in const BTSSPIOCapability     IOCapability,
    __in const BOOL                  OOBDataPresent,
    __in const BTSSPAuthRequirement *pAuthRequirements);

// BthSSPIOCapabilityRequestReply is used to respond to an SSP IO Capability Request from the peer
DWORD BthSSPIOCapabilityRequestNegativeReply(
    __in const BT_ADDR             *RemoteDevice,
    __in const BYTE                 Reason);

// BthSSPPINCodeRequestReply is called to specify the PIN entered by the user in response to a PIN Code Request Event. 
// If pPin is NULL, a PIN Code Request Negative Reply will be sent.
DWORD BthSSPPINCodeRequestReply(
    __in      const BT_ADDR *RemoteDevice,
    __in_opt  const BYTE    *pPin, 
    __in UINT                cbPin);


//
// Events for Secure Simple Pairing (SSP)
//

#define BTE_SSP_USER_CONFIRMATION_REQUEST   801
typedef struct BT_SSP_USER_CONFIRMATION_REQUEST_EVENT
{
    UINT         NumericValue;     // Value 000000-999999 to be displayed/confirmed by user
} BT_SSP_USER_CONFIRMATION_REQUEST_EVENT;

#define BTE_SSP_USER_PASSKEY_REQUEST        802
typedef struct BT_SSP_PASSKEY_REQUEST_EVENT
{
    UINT Reserved;
} BT_SSP_PASSKEY_REQUEST_EVENT;

#define BTE_SSP_PAIRING_COMPLETE            803
typedef struct BT_SSP_PAIRING_COMPLETE_EVENT
{
    BYTE         Status;           // 0=Success, 1-0xFF = error code
} BT_SSP_PAIRING_COMPLETE_EVENT;

#define BTE_SSP_USER_PASSKEY_NOTIFICATION   804
typedef struct BT_SSP_USER_PASSKEY_NOTIFICATION_EVENT
{
    UINT         Passkey;          // Passkey in range 000000-999999 to be displayed to user
                                   // so he can enter it on remote device keyboard
} BT_SSP_USER_PASSKEY_NOTIFICATION_EVENT;

#define BTE_SSP_KEYPRESS_NOTIFICATION       805
typedef struct BT_SSP_KEYPRESS_NOTIFICATION_EVENT
{
    BTSSP_Keypress_Notification_Type Type;
} BT_SSP_KEYPRESS_NOTIFICATION_EVENT;

#define BTE_SSP_IO_CAPABILITY_REQUEST       806
typedef struct BT_SSP_IO_CAPABILITY_REQUEST_EVENT
{
    UINT Reserved;
} BT_SSP_IO_CAPABILITY_REQUEST_EVENT;

#define BTE_SSP_IO_CAPABILITY_RESPONSE      807
typedef struct BT_SSP_IO_CAPABILITY_RESPONSE_EVENT
{
    BTSSPIOCapability    IOCapability;
    BOOL                 OOBDataPresent;
    BTSSPAuthRequirement AuthRequirement;
} BT_SSP_IO_CAPABILITY_RESPONSE_EVENT;

#define BTE_SSP_REMOTE_OOB_DATA_REQUEST      808
typedef struct BT_SSP_REMOTE_OOB_DATA_REQUEST_EVENT
{
    UINT Reserved;
} BT_SSP_REMOTE_OOB_DATA_REQUEST_EVENT;

#define BTE_SSP_PIN_CODE_REQUEST             809
typedef struct BT_SSP_PIN_CODE_REQUEST_EVENT
{
    UINT Reserved;
} BT_SSP_PIN_CODE_REQUEST_EVENT;

// BTE_SSP_IO_CAPABILITY_NOTIFICATION is an informative event
// specifying the values the stack is sending to the peer
// in response to an IO Capability Request from the peer.
// No action is required from the application upon reception
// of this event.
#define BTE_SSP_IO_CAPABILITY_NOTIFICATION   810
typedef struct BT_SSP_IO_CAPABILITY_NOTIFICATION_EVENT
{
    BTSSPIOCapability    IOCapability;
    BOOL                 OOBDataPresent;
    BTSSPAuthRequirement AuthRequirement;
} BT_SSP_IO_CAPABILITY_NOTIFICATION_EVENT;

// BTE_SSP_AUTHENTICATION_COMPLETED is an informative event that is
// indicated when authentication has finished successfully (after
// a link key is generated) or unsuccessfully (e.g. peer
// disconnected prior to link key being issued, or we timed out
// after sending a PIN.)
#define BTE_SSP_AUTHENTICATION_COMPLETED     811
typedef struct BT_SSP_AUTHENTICATION_COMPLETED_EVENT
{
    DWORD  Result; // ERROR_SUCCESS if authentication was successful
} BT_SSP_AUTHENTICATION_COMPLETED_EVENT;

typedef struct BTSSPEvent
{
    DWORD                dwSize;
    BT_ADDR              RemoteDevice;     // Remote device being paired with
    ULONG                BTECode;          // BTE_SSP_Xxx identifier
    union
    {
        BT_SSP_USER_CONFIRMATION_REQUEST_EVENT  UserConfirmationRequest;
        BT_SSP_PASSKEY_REQUEST_EVENT            PasskeyRequest;
        BT_SSP_PAIRING_COMPLETE_EVENT           PairingComplete;
        BT_SSP_USER_PASSKEY_NOTIFICATION_EVENT  UserPasskeyNotification;
        BT_SSP_KEYPRESS_NOTIFICATION_EVENT      KeypressNotification;
        BT_SSP_IO_CAPABILITY_REQUEST_EVENT      IoCapabilityRequest;
        BT_SSP_IO_CAPABILITY_RESPONSE_EVENT     IoCapabilityResponse;
        BT_SSP_REMOTE_OOB_DATA_REQUEST_EVENT    RemoteOOBDataRequest;
        BT_SSP_PIN_CODE_REQUEST_EVENT           PINCodeRequest;
        BT_SSP_IO_CAPABILITY_NOTIFICATION_EVENT IoCapabilityNotification;
        BT_SSP_AUTHENTICATION_COMPLETED_EVENT   AuthenticationCompleted;
    };
} BTSSPEvent;

typedef BYTE HCIBDAddr[6];  // 6 octet bluetooth device address 
BT_ADDR ConvertHCIBDAddrToBTAddr(__in const BYTE *pBDAddr);
void    ConvertBTAddrToBDAddr(__in  const BT_ADDR BTAddr, __out BYTE   *pBDAddr);

//
// PAN APIs
//

int BthActivatePAN (BOOL fActivate);

// Define these for back-compat
#define rfRegisterDevice RegisterDevice
#define rfDeregisterDevice DeregisterDevice
#define rfCreateFile CreateFile
#define rfReadFile ReadFile
#define rfWriteFile WriteFile
#define rfCloseHandle CloseHandle

#if defined (__cplusplus)
};          // __cplusplus
#endif

#endif      /* __bt_api_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\callback.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:12:50 2007
 */
/* Compiler settings for ..\callback.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __callback_h__
#define __callback_h__

/* Forward Declarations */ 

#ifndef __ISynchronizedCallBack_FWD_DEFINED__
#define __ISynchronizedCallBack_FWD_DEFINED__
typedef interface ISynchronizedCallBack ISynchronizedCallBack;
#endif 	/* __ISynchronizedCallBack_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_callback_0000 */
/* [local] */ 

#ifndef _SYNCHRONIZED_CALLBACK_H_
#define _SYNCHRONIZED_CALLBACK_H_


extern RPC_IF_HANDLE __MIDL_itf_callback_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_callback_0000_v0_0_s_ifspec;

#ifndef __ISynchronizedCallBack_INTERFACE_DEFINED__
#define __ISynchronizedCallBack_INTERFACE_DEFINED__

/* interface ISynchronizedCallBack */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISynchronizedCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("74C26041-70D1-11d1-B75A-00A0C90564FE")
    ISynchronizedCallBack : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallBack( 
            /* [size_is][in] */ BYTE __RPC_FAR *pParams,
            /* [in] */ ULONG uSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISynchronizedCallBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISynchronizedCallBack __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISynchronizedCallBack __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISynchronizedCallBack __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CallBack )( 
            ISynchronizedCallBack __RPC_FAR * This,
            /* [size_is][in] */ BYTE __RPC_FAR *pParams,
            /* [in] */ ULONG uSize);
        
        END_INTERFACE
    } ISynchronizedCallBackVtbl;

    interface ISynchronizedCallBack
    {
        CONST_VTBL struct ISynchronizedCallBackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISynchronizedCallBack_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISynchronizedCallBack_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISynchronizedCallBack_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISynchronizedCallBack_CallBack(This,pParams,uSize)	\
    (This)->lpVtbl -> CallBack(This,pParams,uSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISynchronizedCallBack_CallBack_Proxy( 
    ISynchronizedCallBack __RPC_FAR * This,
    /* [size_is][in] */ BYTE __RPC_FAR *pParams,
    /* [in] */ ULONG uSize);


void __RPC_STUB ISynchronizedCallBack_CallBack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISynchronizedCallBack_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_callback_0008 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_callback_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_callback_0008_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cache.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Non MFC based generic cache class, January 1995

/* This class implements a simple cache. A cache object is instantiated
   with the number of items it is to hold. An item is a pointer to an
   object derived from CBaseObject (helps reduce memory leaks). The cache
   can then have objects added to it and removed from it. The cache size
   is fixed at construction time and may therefore run out or be flooded.
   If it runs out it returns a NULL pointer, if it fills up it also returns
   a NULL pointer instead of a pointer to the object just inserted */

/* Making these classes inherit from CBaseObject does nothing for their
   functionality but it allows us to check there are no memory leaks */

/* WARNING Be very careful when using this class, what it lets you do is
   store and retrieve objects so that you can minimise object creation
   which in turns improves efficiency. However the object you store is
   exactly the same as the object you get back which means that it short
   circuits the constructor initialisation phase. This means any class
   variables the object has (eg pointers) are highly likely to be invalid.
   Therefore ensure you reinitialise the object before using it again */


#ifndef __CACHE__
#define __CACHE__


class CCache : CBaseObject {

    /* Make copy constructor and assignment operator inaccessible */

    CCache(const CCache &refCache);
    CCache &operator=(const CCache &refCache);

private:

    /* These are initialised in the constructor. The first variable points to
       an array of pointers, each of which points to a CBaseObject derived
       object. The m_iCacheSize is the static fixed size for the cache and the
       m_iUsed defines the number of places filled with objects at any time.
       We fill the array of pointers from the start (ie m_ppObjects[0] first)
       and then only add and remove objects from the end position, so in this
       respect the array of object pointers should be treated as a stack */

    CBaseObject **m_ppObjects;
    const INT m_iCacheSize;
    INT m_iUsed;

public:

    CCache(TCHAR *pName,INT iItems);
    virtual ~CCache();

    /* Add an item to the cache */
    CBaseObject *AddToCache(CBaseObject *pObject);

    /* Remove an item from the cache */
    CBaseObject *RemoveFromCache();

    /* Delete all the objects held in the cache */
    void RemoveAll(void);

    /* Return the cache size which is set during construction */
    INT GetCacheSize(void) const {return m_iCacheSize;};
};

#endif /* __CACHE__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cameradriver.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef __NULL_DD
#define __NULL_DD

#ifdef __cplusplus
extern "C" {
#endif

#define CAM_MSGQ_IMEOUT 250

// CAPTURE and STILL are required pin types. PREVIEW is optional, so list it last.
enum
{
    ADAPTER = -1,
    CAPTURE = 0,
    STILL   = 1,
    PREVIEW = 2
};

// DEFINES for PROPSETID_VIDCAP_VIDEOPROCAMP
typedef enum {
    // VideoProcAmp
    ENUM_BRIGHTNESS = 0,
    ENUM_CONTRAST,
    ENUM_HUE,
    ENUM_SATURATION,
    ENUM_SHARPNESS,
    ENUM_GAMMA,
    ENUM_COLORENABLE,
    ENUM_WHITEBALANCE,
    ENUM_BACKLIGHT_COMPENSATION,
    ENUM_GAIN,

    ENUM_VIDPROCAMP_MAX = ENUM_GAIN,
    
    // CameraControl
    ENUM_PAN,
    ENUM_TILT,
    ENUM_ROLL,
    ENUM_ZOOM,
    ENUM_EXPOSURE,
    ENUM_IRIS,
    ENUM_FOCUS,
    ENUM_FLASH,

    ENUM_CAMCONTROL_MAX = ENUM_FLASH,

    ENUM_DEV_PROP_MAX = ENUM_CAMCONTROL_MAX
} ENUM_DEV_PROP;


const size_t StandardSizeOfBasicValues   = sizeof(CSPROPERTY_DESCRIPTION) + sizeof(CSPROPERTY_MEMBERSHEADER) + sizeof(CSPROPERTY_STEPPING_LONG) ;
const size_t StandardSizeOfDefaultValues = sizeof(CSPROPERTY_DESCRIPTION) + sizeof(CSPROPERTY_MEMBERSHEADER) + sizeof(ULONG) ;


DWORD MDD_HandleIO( LPVOID ModeContext, ULONG ulModeType );
DWORD MDD_HandleNotification( LPVOID MDDContext, LONG lModeType, ULONG NotificationId, LPVOID Context );

class CPinDevice;

typedef class CCameraDevice 
{
public:
    CCameraDevice( );

    ~CCameraDevice( );
    
    bool
    Initialize(
        PVOID context
        );

    bool
    BindApplicationProc(
        HANDLE
        );

    bool
    UnBindApplicationProc( );
    
    DWORD
    AdapterHandlePinRequests(
        __in_bcount(InBufLen) PUCHAR pInBuf,
        DWORD  InBufLen,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD  OutBufLen,
        PDWORD pdwBytesTransferred
        );

    DWORD
    AdapterHandleVersion(
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD  OutBufLen,
        PDWORD pdwBytesTransferred
        );        

    DWORD
    AdapterHandlePropSetAdapter(
        __in_bcount(InBufLen) PUCHAR pInBuf,
        DWORD  InBufLen,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD  OutBufLen,
        PDWORD pdwBytesTransferred
        );

    DWORD
    AdapterHandleVidProcAmpRequests(
        __in_bcount(InBufLen) PUCHAR pInBuf,
        DWORD  InBufLen,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD  OutBufLen,
        PDWORD pdwBytesTransferred 
        );

    DWORD
    AdapterHandleCamControlRequests(
        __in_bcount(InBufLen) PUCHAR pInBuf,
        DWORD  InBufLen,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD  OutBufLen,
        PDWORD pdwBytesTransferred
        );

    DWORD
    AdapterHandleVideoControlRequests(
        __in_bcount(InBufLen) PUCHAR pInBuf,
        DWORD  InBufLen,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD  OutBufLen,
        PDWORD pdwBytesTransferred
        );
    
    DWORD
    AdapterHandleDroppedFramesRequests(
        __in_bcount(InBufLen) PUCHAR pInBuf,
        DWORD  InBufLen,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD  OutBufLen,
        PDWORD pdwBytesTransferred
        );

    DWORD
    CCameraDevice::AdapterHandleMetadataRequests(
        PUCHAR pInBuf,
        DWORD  InBufLen,
        PUCHAR pOutBuf,
        DWORD  OutBufLen,
        PDWORD pdwBytesTransferred
        );

    DWORD
    AdapterHandlePowerRequests(
        DWORD  dwCode,
        __in_bcount(InBufLen) PUCHAR pInBuf,
        DWORD  InBufLen,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD  OutBufLen,
        PDWORD pdwBytesTransferred
        );

    DWORD
    AdapterHandleCustomRequests(
        __in_bcount(InBufLen) PUCHAR pInBuf,
        DWORD  InBufLen,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD  OutBufLen,
        PDWORD pdwBytesTransferred
        );

    DWORD HandleNotification( 
        LONG lModeType, 
        ULONG NotificationId, 
        LPVOID Context
        );

  
    LPVOID
    ValidateBuffer(
        __in_bcount(ulActualBufLen) LPVOID  lpBuff,
        ULONG   ulActualBufLen,
        ULONG   ulExpectedBuffLen,
        DWORD * dwError
        );
    
    bool
    AdapterCompareFormat(
        const ULONG                 ulPinId,
        const PCS_DATARANGE_VIDEO   pCsDataRangeVideoToCompare,
        PCS_DATARANGE_VIDEO       * ppCsDataRangeVideoMatched,
        bool                        fDetailedComparison
        );

    bool
    AdapterCompareFormat(
        const ULONG                            ulPinId,
        const PCS_DATAFORMAT_VIDEOINFOHEADER   pCsDataRangeVideoToCompare,
        PCS_DATARANGE_VIDEO                  * ppCsDataRangeVideoMatched,
        bool                                   fDetailedComparison
        );

    bool
    IsValidPin(
        ULONG ulPinId
        );

    bool
    GetPinFormat(
        ULONG                 ulPinId,
        ULONG                 ulIndex,
        PCS_DATARANGE_VIDEO * ppCsDataRangeVid
        );

    bool
    IncrCInstances(
        ULONG        ulPinId,
        CPinDevice * pPinDev
        );

    bool
    DecrCInstances(
        ULONG ulPinId
        );

    bool
    PauseCaptureAndPreview( );

    bool
    RevertCaptureAndPreviewState( );

    DWORD
    PDDClosePin( 
        ULONG ulPinId 
        );

    DWORD 
    PDDGetPinInfo( 
        ULONG ulPinId, 
        PSENSORMODEINFO pSensorModeInfo 
        );

    DWORD PDDSetPinState( 
        ULONG ulPinId, 
        CSSTATE State 
        );

    DWORD PDDFillPinBuffer( 
        ULONG ulPinId, 
        PUCHAR pImage 
        );

    DWORD PDDInitPin( 
        ULONG ulPinId, 
        CPinDevice *pPin 
        );

    DWORD PDDSetPinFormat(
        ULONG ulPinId,
        PCS_DATARANGE_VIDEO pCsDataRangeVideo
        );

    PVOID PDDAllocatePinBuffer( 
        ULONG ulPinId 
        );

    DWORD PDDDeAllocatePinBuffer( 
        ULONG ulPinId, 
        PVOID pBuffer
        );

    DWORD PDDRegisterClientBuffer(
        ULONG ulPinId,
        PVOID pBuffer 
        );

    DWORD PDDUnRegisterClientBuffer(
        ULONG ulPinId,
        PVOID pBuffer 
        );

    DWORD PDDHandlePinCustomProperties(
        ULONG ulPinId,
        __in_bcount(InBufLen) PUCHAR pInBuf,
        DWORD  InBufLen,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD  OutBufLen,
        PDWORD pdwBytesTransferred
        );

private:

    bool
    GetPDDPinInfo();

    void
    GetBasicSupportInfo(
        __out_bcount(OutBufLen) PUCHAR        pOutBuf,
        DWORD         OutBufLen,
        PDWORD        pdwBytesTransferred,
        PSENSOR_PROPERTY pSensorProp,
        PDWORD        pdwError
        );

    void
    GetDefaultValues(
        __out_bcount(OutBufLen) PUCHAR        pOutBuf,
        DWORD         OutBufLen,
        PDWORD        pdwBytesTransferred,
        PSENSOR_PROPERTY pDevProp,
        PDWORD        pdwError
        );

    bool
    AdapterCompareGUIDsAndFormatSize(
        const PCSDATARANGE DataRange1,
        const PCSDATARANGE DataRange2
        );

    DWORD 
    WriteMessage( 
        ULONG flag, 
        LPVOID Context 
        );

    DWORD 
    PowerDown();

    DWORD
    PowerUp();

private:

    CRITICAL_SECTION m_csDevice;        

    HANDLE          m_hStream;                         // Handle to the corresponding stream sub-device
    HANDLE          m_hCallerProcess;                  // Handle of the process this driver is currently bound to.
    HANDLE          m_hAdapterMessageQueue;
    DWORD           m_dwVersion;
    CEDEVICE_POWER_STATE m_PowerState;
    STREAM_INSTANCES *m_pStrmInstances;
    ADAPTERINFO     m_AdapterInfo;
    PVOID           m_PDDContext;
    PPDDFUNCTBL     m_pPDDFuncTbl;
    PDDFUNCTBL2     m_PDDFuncTbl2;
    DWORD           m_dwRefCount;

} CAMERADEVICE, * PCAMERADEVICE;

typedef struct CCameraOpenHandle
{
    PCAMERADEVICE pCamDevice;
} CAMERAOPENHANDLE, * PCAMERAOPENHANDLE;

#ifdef __cplusplus
}
#endif


#endif // __NULL_DD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cameradebug.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _DBGSETTINGS_H
#define _DBGSETTINGS_H

#ifndef DEBUG
#define DEBUG                // always turn on debug output
#endif // DEBUG

#ifdef DEBUG

#define DEBUGMASK(bit)       (1 << (bit))

#define MASK_ERROR           DEBUGMASK(0)
#define MASK_WARN            DEBUGMASK(1)
#define MASK_INIT            DEBUGMASK(2)
#define MASK_FUNCTION        DEBUGMASK(3)
#define MASK_IOCTL           DEBUGMASK(4)
#define MASK_DEVICE          DEBUGMASK(5)

#define PIN_REG_PATH         TEXT("Software\\Microsoft\\DirectX\\DirectShow\\Capture")

#ifdef CAMINTERFACE
extern "C" 
DBGPARAM dpCurSettings = {
    _T("CAMMDD"), 
    {
        _T("Errors"), _T("Warnings"), _T("Init"), _T("Function"), 
        _T("Ioctl"), _T("Device"), _T(""), _T(""),
        _T(""),_T(""),_T("PDDCAM"),_T("IRQ"),
        _T("DMA"),_T(""),_T(""),_T("Verbose") 
    },
    MASK_ERROR | MASK_WARN | MASK_INIT 
}; 
#else
extern "C" DBGPARAM dpCurSettings;
#endif

#define ZONE_ERROR           DEBUGZONE(0)
#define ZONE_WARN            DEBUGZONE(1)
#define ZONE_INIT            DEBUGZONE(2)
#define ZONE_FUNCTION        DEBUGZONE(3)
#define ZONE_IOCTL           DEBUGZONE(4)
#define ZONE_DEVICE          DEBUGZONE(5)

#define ZONE_PDDCAM          DEBUGZONE(10)
#define ZONE_IRQ             DEBUGZONE(11)
#define ZONE_DMA             DEBUGZONE(12)
#define ZONE_VERBOSE         DEBUGZONE(15)


#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\camerapdd.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _CAMERAPDD_H
#define _CAMERAPDD_H

#ifdef __cplusplus
extern "C" {
#endif

    /////////////////////////////////////////////////////////////////////////////////////
    // The following methods are corresponding to the adapter

    // PDD_Init is called when the driver is first loaded. MDDContext is what MDD receive in its XXX_Init call.
    // PDD needs to return a context which the MDD will later send back in the rest of the PDD functions.
    // PDD will also populate pPDDFuncTbl which is a list of entry points the PDD implements.
    PVOID PDD_Init( PVOID MDDContext, PPDDFUNCTBL pPDDFuncTbl );

    // PDD_DeInit is called when the driver is being Unloaded. At this point PDD should free up any 
    // unfreed resources.
    DWORD PDD_DeInit( LPVOID PDDContext );

    // PDD_Open is called in response of XXX_Open() call
    DWORD PDD_Open( PVOID PDDContext, PVOID MDDOpenContext );

    // PDD_Close is called in response to XXX_Close() call
    DWORD PDD_Close( PVOID PDDContext, LPVOID MDDOpenContext );

    // PDD_GetAdapterInfo is called at the initialization time to get information about the Adapter
    DWORD PDD_GetAdapterInfo( LPVOID PDDContext, PADAPTERINFO pAdapterInfo );

    // Handle VideoProcAmp specific property changes.
    DWORD PDD_HandleVidProcAmpChanges( LPVOID PDDContext, DWORD dwPropId, LONG lFlags, LONG lValue);

    // Handle CameraControl specific property changes.
    DWORD PDD_HandleCamControlChanges( LPVOID PDDContext, DWORD dwPropId, LONG lFlags, LONG lValue );

    // Returns static metadata from the PDD. On return, pOutBuf will be filled in with the contents
    // of a CSMETADATA_S structure. Note that setting lpOutBuffer = NULL will return the required
    // buffer size in pdwBytesTransferred.
    DWORD PDD_GetMetadata( LPVOID PDDContext, DWORD dwPropId, PUCHAR pOutBuf, DWORD OutBufLen, PDWORD pdwBytesTransferred );

    // Handle CSPROPERTY_VIDEOCONTROL_CAPS property.
    DWORD PDD_HandleVideoControlCapsChanges( LPVOID PDDContext, LONG lModeType ,ULONG ulCaps );

    // Set driver power state.
    DWORD PDD_SetPowerState( LPVOID PDDContext, CEDEVICE_POWER_STATE PowerState );

    // Handle Adapter level custom/proprietary properties
    DWORD PDD_HandleAdapterCustomProperties( LPVOID PDDContext, PUCHAR pInBuf, DWORD  InBufLen, PUCHAR pOutBuf, DWORD  OutBufLen, PDWORD pdwBytesTransferred );
   
    
    // End of adapter specific methods
    /////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////////////
    // The following methods are corresponding to sensor modes. This is why the 2nd parameter
    // of all these methods is the Mode Type.

    // PDD_InitSensorMode() is called when the MDD wants PDD to allocate all the resources related 
    // to a given mode ulModeType. Any Buffer allocation or DMA setup should be done in this
    // function.
    DWORD PDD_InitSensorMode( LPVOID PDDContext, ULONG ulModeType, LPVOID ModeContext );

    // PDD_DeInitSensorMode() is called when the MDD wants PDD to deallocate all the resources 
    // related to a given mode ulModeType.
    DWORD PDD_DeInitSensorMode( LPVOID PDDContext, ULONG ulModeType );

    // There are three valid states, i.e., CSSTATE_STOP, CSSTATE_PAUSE, CSSTATE_RUN. 
    // PDD_SetSensorState() is only called for Preview or Capture sensor modes. For Still sensor mode, 
    // PDD_TakeStillPicture (discussed further below) is called.
    // PDD should only capture data when put in CSSTATE_RUN.
    DWORD PDD_SetSensorState( LPVOID PDDContext, ULONG ulModeType, CSSTATE CsState );

    // PDD_TakeStillPicture is called to take still picture. The 2nd parameter pBurstModeInfo is not
    // used in this version. MDD will always set it to NULL.
    // When the PDD receives this function call, it should setup the sensor for still mode. It may have to 
    // disable sending data for Capture or preview sensor mode.
    DWORD PDD_TakeStillPicture( LPVOID PDDContext, LPVOID pBurstModeInfo );

    // PDD_GetSensorModeInfo is currently called during the instantiation time but this can be called from any place.
    DWORD PDD_GetSensorModeInfo( LPVOID PDDContext, ULONG ulModeType, PSENSORMODEINFO pSensorModeInfo );

    // PDD_SetSensorModeFormat() is called to set the format of a particular sensor mode i.e., ulModeType. PDD must not
    // allocate resources at this time. Instead it should wait for PDD_InitSensorMode to do the actual allocation.
    DWORD PDD_SetSensorModeFormat( LPVOID PDDContext, ULONG ulModeType, PCS_DATARANGE_VIDEO pCsDataRangeVideo );
    
    // PDD_AllocateBuffer is called when the MDD wants PDD to allocate its Mode specific buffer. This method is called
    // n times where n is the total number of buffers that the application agreed with driver at the time of initialization
    // Each mode (Capture, Still etc.)will have its own set of buffers. This method is only called if the Memory Model 
    // is CSPROPERTY_BUFFER_DRIVER
    PVOID PDD_AllocateBuffer( LPVOID PDDContext, ULONG ulModeType );

    // PDD_DeAllocateBuffer is called when the MDD wants PDD to deallocate its Mode specific buffer. MDD will call
    // this function n times where n is the total number of buffers agreed by the driver and Application(DShow)
    // This method is only called if the Memory Model is CSPROPERTY_BUFFER_DRIVER
    DWORD PDD_DeAllocateBuffer( LPVOID PDDContext, ULONG ulModeType, PVOID pBuffer );

    // PDD_RegisterClientBuffer is called by MDD to give PDD the pointers to buffers allocated by the 
    // application(DShow). MDD will call this function n times where n is the total number of buffers 
    // agreed by the driver and Application(DShow)At this point, PDD can setup DMA using these pointers.
    // This method is only called if the Memory Model IS NOT CSPROPERTY_BUFFER_DRIVER
    DWORD PDD_RegisterClientBuffer( LPVOID PDDContext, ULONG ulModeType, PVOID pBuffer );

    // PDD_UnRegisterClientBuffer is called by MDD to tell PDD that the particular pointer is no more 
    // available. PDD must not used this pointer after this function call.
    // This method is only called if the Memory Model IS NOT CSPROPERTY_BUFFER_DRIVER
    DWORD PDD_UnRegisterClientBuffer( LPVOID PDDContext, ULONG ulModeType, PVOID pBuffer );

    // When the PDD receives an interrupt for sensor data availabilitly, it will call MDD_HandleIO() 
    // implemented by the MDD. MDD_HandleIO() will internally call PDD_FillBuffer() to to let PDD
    // transfer/DMA data to the buffer. MDD_HandleIO 
    DWORD PDD_FillBuffer( LPVOID PDDContext, ULONG ulModeType, PUCHAR pImage );

    // PDD_HandleModeCustomProperties handles Sensor Mode specific Custom/Proprietary properties
    DWORD PDD_HandleModeCustomProperties( LPVOID PDDContext, ULONG ulModeType, PUCHAR pInBuf, DWORD  InBufLen, PUCHAR pOutBuf, DWORD  OutBufLen, PDWORD pdwBytesTransferred );

    // End of Mode specific methods
    /////////////////////////////////////////////////////////////////////////////////////
  

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\camerapddprops.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _CAMERAPDDPROPS_H
#define _CAMERAPDDPROPS_H

#define MAX_SUPPORTED_PINS        3
#define MAX_PINNAME_LENGTH       10
#define MAX_VIDEO_FORMAT         10

#define NUM_VIDEOPROCAMP_ITEMS   10
#define NUM_CAMERACONTROL_ITEMS   8
#define NUM_PROPERTY_ITEMS       NUM_VIDEOPROCAMP_ITEMS + NUM_CAMERACONTROL_ITEMS


#define PDD_NOTIFICATION_SAMPLE_SCANNED     0x00000001
#define PDD_NOTIFICATION_ASYNCHRONOUS_FOCUS 0x00000002

static const WCHAR g_wszPinNames[MAX_SUPPORTED_PINS][MAX_PINNAME_LENGTH] = {L"Capture",
                                                                            L"Still",
                                                                            L"Preview"};

static WCHAR g_wszPinDeviceNames[MAX_SUPPORTED_PINS][MAX_PINNAME_LENGTH] = {L"PIN1:",
                                                                            L"PIN1:",
                                                                            L"PIN1:"};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\camerrorcodes.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma once
#include <windows.h>
#include <aygshell.h>

// Camera Error code
const HRESULT E_CAMCAP_CAMERA_DISABLED       = 0x800710D5;
const HRESULT E_CAMCAP_CAPTURE_FAILURE       = MAKE_HRESULT(0x1, FACILITY_WINDOWS_CE, MA_CAMCAP_BASE);
const HRESULT E_CAMCAP_INVALID_VERSION       = MAKE_HRESULT(0x1, FACILITY_WINDOWS_CE, MA_CAMCAP_BASE + 0x01);
const HRESULT E_CAMCAP_INVALID_OWNER_WINDOW  = MAKE_HRESULT(0x1, FACILITY_WINDOWS_CE, MA_CAMCAP_BASE + 0x02);
const HRESULT E_CAMCAP_INVALID_DIR           = MAKE_HRESULT(0x1, FACILITY_WINDOWS_CE, MA_CAMCAP_BASE + 0x03);
const HRESULT E_CAMCAP_INVALID_FILE_NAME     = MAKE_HRESULT(0x1, FACILITY_WINDOWS_CE, MA_CAMCAP_BASE + 0x04);
const HRESULT E_CAMCAP_INVALID_PHOTO_QUALITY = MAKE_HRESULT(0x1, FACILITY_WINDOWS_CE, MA_CAMCAP_BASE + 0x05);
const HRESULT E_CAMCAP_INVALID_FILE_TYPE     = MAKE_HRESULT(0x1, FACILITY_WINDOWS_CE, MA_CAMCAP_BASE + 0x06);
const HRESULT E_CAMCAP_INVALID_RESOLUTION    = MAKE_HRESULT(0x1, FACILITY_WINDOWS_CE, MA_CAMCAP_BASE + 0x07);
const HRESULT E_CAMCAP_INVALID_MODES         = MAKE_HRESULT(0x1, FACILITY_WINDOWS_CE, MA_CAMCAP_BASE + 0x08);
const HRESULT E_CAMCAP_INVALID_INITIAL_MODE  = MAKE_HRESULT(0x1, FACILITY_WINDOWS_CE, MA_CAMCAP_BASE + 0x09);
const HRESULT E_CAMCAP_INVALID_AUDIO_OPTION  = MAKE_HRESULT(0x1, FACILITY_WINDOWS_CE, MA_CAMCAP_BASE + 0x0A);
const HRESULT E_CAMCAP_LAST_ERROR_CODE       = MAKE_HRESULT(0x1, FACILITY_WINDOWS_CE, MA_CAMCAP_BASE + 0x0A);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\candidateapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for CandidateAPI.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __CandidateAPI_h__
#define __CandidateAPI_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICandidateEntry_FWD_DEFINED__
#define __ICandidateEntry_FWD_DEFINED__
typedef interface ICandidateEntry ICandidateEntry;
#endif 	/* __ICandidateEntry_FWD_DEFINED__ */


#ifndef __ICandidateList_FWD_DEFINED__
#define __ICandidateList_FWD_DEFINED__
typedef interface ICandidateList ICandidateList;
#endif 	/* __ICandidateList_FWD_DEFINED__ */


#ifndef __IIMECallback_FWD_DEFINED__
#define __IIMECallback_FWD_DEFINED__
typedef interface IIMECallback IIMECallback;
#endif 	/* __IIMECallback_FWD_DEFINED__ */


#ifndef __ICandidateWindow_FWD_DEFINED__
#define __ICandidateWindow_FWD_DEFINED__
typedef interface ICandidateWindow ICandidateWindow;
#endif 	/* __ICandidateWindow_FWD_DEFINED__ */


#ifndef __IIME_COMMON_CTRL_FWD_DEFINED__
#define __IIME_COMMON_CTRL_FWD_DEFINED__

#ifdef __cplusplus
typedef class IIME_COMMON_CTRL IIME_COMMON_CTRL;
#else
typedef struct IIME_COMMON_CTRL IIME_COMMON_CTRL;
#endif /* __cplusplus */

#endif 	/* __IIME_COMMON_CTRL_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_CandidateAPI_0000_0000 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_CandidateAPI_0000_0000_0001
    {	IMECW_STYLE_DOCKED_HORIZONTAL	= 0x1,
	IMECW_STYLE_FLOATING_HORIZONTAL	= 0x2,
	IMECW_STYLE_FLOATING_VERTICAL	= 0x4,
	IMECW_STYLE_NOAUTOSELECTION	= 0x10,
	IMECW_STYLE_SHOWSEPARATOR	= 0x20
    } 	IMECW_STYLE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_CandidateAPI_0000_0000_0002
    {	IMECW_NOTIFICATION_FINALIZATION	= 0x1,
	IMECW_NOTIFICATION_PAGE_CHANGED	= 0x2,
	IMECW_NOTIFICATION_SELECTION	= 0x4,
	IMECW_NOTIFICATION_PAGESIZE_CHANGED	= 0x8
    } 	IMECW_NOTIFICATION;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_CandidateAPI_0000_0000_0003
    {	IMECW_COMPONENT_COMPOSITION	= 0x1,
	IMECW_COMPONENT_ACCELERATOR	= 0x2,
	IMECW_COMPONENT_PAGE_INDICATOR	= 0x4,
	IMECW_COMPONENT_SELECTOR	= 0x8
    } 	IMECW_COMPONENT;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_CandidateAPI_0000_0000_0004
    {	IMECW_CREATEMASK_NONE	= 0,
	IMECW_CREATEMASK_COLOR	= 0x1,
	IMECW_CREATEMASK_FONT	= 0x2
    } 	IMECW_CREATEMASK;

typedef struct tagCandidateCreationInfo
    {
    DWORD style;
    DWORD dwComponentsLayout;
    COLORREF colorForegroundNormal;
    COLORREF colorBackgroundNormal;
    COLORREF colorForegroundSelected;
    COLORREF colorBackgroundSelected;
    HFONT hFontNormal;
    HFONT hFontIndicator;
    DWORD dwCreateInfoMask;
    } 	CANDIDATE_CREATE_INFO;



extern RPC_IF_HANDLE __MIDL_itf_CandidateAPI_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_CandidateAPI_0000_0000_v0_0_s_ifspec;

#ifndef __ICandidateEntry_INTERFACE_DEFINED__
#define __ICandidateEntry_INTERFACE_DEFINED__

/* interface ICandidateEntry */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICandidateEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5b18914d-fb02-4a14-939c-5ebcb901bf15")
    ICandidateEntry : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [retval][out] */ BSTR *pbstr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICandidateEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICandidateEntry * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICandidateEntry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICandidateEntry * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            ICandidateEntry * This,
            /* [retval][out] */ BSTR *pbstr);
        
        END_INTERFACE
    } ICandidateEntryVtbl;

    interface ICandidateEntry
    {
        CONST_VTBL struct ICandidateEntryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICandidateEntry_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICandidateEntry_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICandidateEntry_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICandidateEntry_GetString(This,pbstr)	\
    ( (This)->lpVtbl -> GetString(This,pbstr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICandidateEntry_INTERFACE_DEFINED__ */


#ifndef __ICandidateList_INTERFACE_DEFINED__
#define __ICandidateList_INTERFACE_DEFINED__

/* interface ICandidateList */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICandidateList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4f1d9c49-75ff-4b4a-9ce5-844a938f06c9")
    ICandidateList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCandidateCount( 
            /* [retval][out] */ INT *piCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNthCandidate( 
            /* [in] */ INT iIndex,
            /* [retval][out] */ ICandidateEntry **ppICandidateEntry) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICandidateListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICandidateList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICandidateList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICandidateList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateCount )( 
            ICandidateList * This,
            /* [retval][out] */ INT *piCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetNthCandidate )( 
            ICandidateList * This,
            /* [in] */ INT iIndex,
            /* [retval][out] */ ICandidateEntry **ppICandidateEntry);
        
        END_INTERFACE
    } ICandidateListVtbl;

    interface ICandidateList
    {
        CONST_VTBL struct ICandidateListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICandidateList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICandidateList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICandidateList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICandidateList_GetCandidateCount(This,piCount)	\
    ( (This)->lpVtbl -> GetCandidateCount(This,piCount) ) 

#define ICandidateList_GetNthCandidate(This,iIndex,ppICandidateEntry)	\
    ( (This)->lpVtbl -> GetNthCandidate(This,iIndex,ppICandidateEntry) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICandidateList_INTERFACE_DEFINED__ */


#ifndef __IIMECallback_INTERFACE_DEFINED__
#define __IIMECallback_INTERFACE_DEFINED__

/* interface IIMECallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IIMECallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6f4c9694-274e-4782-9636-c12530484d18")
    IIMECallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCandidateWindowChanged( 
            /* [in] */ DWORD dwChangeNotifyFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCursorPosition( 
            /* [out] */ POINT *pcursorPosition,
            /* [out] */ INT *pdwInputAreaHeight) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIMECallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIMECallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIMECallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIMECallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnCandidateWindowChanged )( 
            IIMECallback * This,
            /* [in] */ DWORD dwChangeNotifyFlag);
        
        HRESULT ( STDMETHODCALLTYPE *GetCursorPosition )( 
            IIMECallback * This,
            /* [out] */ POINT *pcursorPosition,
            /* [out] */ INT *pdwInputAreaHeight);
        
        END_INTERFACE
    } IIMECallbackVtbl;

    interface IIMECallback
    {
        CONST_VTBL struct IIMECallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIMECallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIMECallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIMECallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIMECallback_OnCandidateWindowChanged(This,dwChangeNotifyFlag)	\
    ( (This)->lpVtbl -> OnCandidateWindowChanged(This,dwChangeNotifyFlag) ) 

#define IIMECallback_GetCursorPosition(This,pcursorPosition,pdwInputAreaHeight)	\
    ( (This)->lpVtbl -> GetCursorPosition(This,pcursorPosition,pdwInputAreaHeight) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIMECallback_INTERFACE_DEFINED__ */


#ifndef __ICandidateWindow_INTERFACE_DEFINED__
#define __ICandidateWindow_INTERFACE_DEFINED__

/* interface ICandidateWindow */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICandidateWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e34515a-111a-4118-a1ec-6ca04592f852")
    ICandidateWindow : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ CANDIDATE_CREATE_INFO *pCreateInfo,
            /* [in] */ IIMECallback *pIIMECallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateList( 
            /* [in] */ ICandidateList *pICandidateList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CandidateListUpdated( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxPageSize( 
            /* [in] */ INT iPageSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCursorFollowPosition( 
            /* [in] */ POINT ptCursor,
            /* [in] */ INT iCursorHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Hide( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSelection( 
            /* [in] */ INT iSelectedItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearSelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PageUp( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PageDown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShowStatus( 
            /* [retval][out] */ BOOL *pbShown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWindowRect( 
            /* [retval][out] */ RECT *prcWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [retval][out] */ INT *piSelectedItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayRange( 
            /* [out] */ INT *piPageStart,
            /* [out] */ INT *piPageEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICandidateWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICandidateWindow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICandidateWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICandidateWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICandidateWindow * This,
            /* [in] */ CANDIDATE_CREATE_INFO *pCreateInfo,
            /* [in] */ IIMECallback *pIIMECallback);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateList )( 
            ICandidateWindow * This,
            /* [in] */ ICandidateList *pICandidateList);
        
        HRESULT ( STDMETHODCALLTYPE *CandidateListUpdated )( 
            ICandidateWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxPageSize )( 
            ICandidateWindow * This,
            /* [in] */ INT iPageSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetCursorFollowPosition )( 
            ICandidateWindow * This,
            /* [in] */ POINT ptCursor,
            /* [in] */ INT iCursorHeight);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ICandidateWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *Hide )( 
            ICandidateWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            ICandidateWindow * This,
            /* [in] */ INT iSelectedItem);
        
        HRESULT ( STDMETHODCALLTYPE *ClearSelection )( 
            ICandidateWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *PageUp )( 
            ICandidateWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *PageDown )( 
            ICandidateWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetShowStatus )( 
            ICandidateWindow * This,
            /* [retval][out] */ BOOL *pbShown);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowRect )( 
            ICandidateWindow * This,
            /* [retval][out] */ RECT *prcWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            ICandidateWindow * This,
            /* [retval][out] */ INT *piSelectedItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayRange )( 
            ICandidateWindow * This,
            /* [out] */ INT *piPageStart,
            /* [out] */ INT *piPageEnd);
        
        END_INTERFACE
    } ICandidateWindowVtbl;

    interface ICandidateWindow
    {
        CONST_VTBL struct ICandidateWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICandidateWindow_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICandidateWindow_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICandidateWindow_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICandidateWindow_Initialize(This,pCreateInfo,pIIMECallback)	\
    ( (This)->lpVtbl -> Initialize(This,pCreateInfo,pIIMECallback) ) 

#define ICandidateWindow_SetCandidateList(This,pICandidateList)	\
    ( (This)->lpVtbl -> SetCandidateList(This,pICandidateList) ) 

#define ICandidateWindow_CandidateListUpdated(This)	\
    ( (This)->lpVtbl -> CandidateListUpdated(This) ) 

#define ICandidateWindow_SetMaxPageSize(This,iPageSize)	\
    ( (This)->lpVtbl -> SetMaxPageSize(This,iPageSize) ) 

#define ICandidateWindow_SetCursorFollowPosition(This,ptCursor,iCursorHeight)	\
    ( (This)->lpVtbl -> SetCursorFollowPosition(This,ptCursor,iCursorHeight) ) 

#define ICandidateWindow_Show(This)	\
    ( (This)->lpVtbl -> Show(This) ) 

#define ICandidateWindow_Hide(This)	\
    ( (This)->lpVtbl -> Hide(This) ) 

#define ICandidateWindow_SetSelection(This,iSelectedItem)	\
    ( (This)->lpVtbl -> SetSelection(This,iSelectedItem) ) 

#define ICandidateWindow_ClearSelection(This)	\
    ( (This)->lpVtbl -> ClearSelection(This) ) 

#define ICandidateWindow_PageUp(This)	\
    ( (This)->lpVtbl -> PageUp(This) ) 

#define ICandidateWindow_PageDown(This)	\
    ( (This)->lpVtbl -> PageDown(This) ) 

#define ICandidateWindow_GetShowStatus(This,pbShown)	\
    ( (This)->lpVtbl -> GetShowStatus(This,pbShown) ) 

#define ICandidateWindow_GetWindowRect(This,prcWindow)	\
    ( (This)->lpVtbl -> GetWindowRect(This,prcWindow) ) 

#define ICandidateWindow_GetSelection(This,piSelectedItem)	\
    ( (This)->lpVtbl -> GetSelection(This,piSelectedItem) ) 

#define ICandidateWindow_GetDisplayRange(This,piPageStart,piPageEnd)	\
    ( (This)->lpVtbl -> GetDisplayRange(This,piPageStart,piPageEnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICandidateWindow_INTERFACE_DEFINED__ */



#ifndef __ImeCandidateWindow_LIBRARY_DEFINED__
#define __ImeCandidateWindow_LIBRARY_DEFINED__

/* library ImeCandidateWindow */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ImeCandidateWindow;

EXTERN_C const CLSID CLSID_IIME_COMMON_CTRL;

#ifdef __cplusplus

class DECLSPEC_UUID("67664C9A-893E-4e63-A2BC-0C0706F9255A")
IIME_COMMON_CTRL;
#endif
#endif /* __ImeCandidateWindow_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HFONT_UserSize(     unsigned long *, unsigned long            , HFONT * ); 
unsigned char * __RPC_USER  HFONT_UserMarshal(  unsigned long *, unsigned char *, HFONT * ); 
unsigned char * __RPC_USER  HFONT_UserUnmarshal(unsigned long *, unsigned char *, HFONT * ); 
void                      __RPC_USER  HFONT_UserFree(     unsigned long *, HFONT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cardapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/************************************************************************/
/**                         Microsoft Windows                          **/
/************************************************************************/

//
// Module: CARDAPI.H - WINCE PCMCIA Card Services function typedefs
//

//
// Card Services Function Typedefs (exported by pcmcia.dll)
//
typedef CARD_CLIENT_HANDLE (*REGISTERCLIENT)(CLIENT_CALLBACK, PCARD_REGISTER_PARMS);
typedef STATUS (*GETFIRSTTUPLE)(PCARD_TUPLE_PARMS);
typedef STATUS (*GETNEXTTUPLE)(PCARD_TUPLE_PARMS);
typedef STATUS (*GETTUPLEDATA)(PCARD_DATA_PARMS);
typedef STATUS (*GETPARSEDTUPLE)(CARD_SOCKET_HANDLE, UINT8, PVOID, PUINT32);
typedef STATUS (*GETSTATUS)(PCARD_STATUS);
typedef DWORD (*SYSTEMPOWER)(DWORD);
typedef STATUS (*DEREGISTERCLIENT)(CARD_CLIENT_HANDLE);
typedef STATUS (*REQUESTEXCLUSIVE)(CARD_CLIENT_HANDLE, CARD_SOCKET_HANDLE);
typedef STATUS (*RELEASEEXCLUSIVE)(CARD_CLIENT_HANDLE, CARD_SOCKET_HANDLE);
typedef STATUS (*REQUESTSOCKETMASK)(CARD_CLIENT_HANDLE, CARD_SOCKET_HANDLE, UINT16);
typedef STATUS (*RELEASESOCKETMASK)(CARD_CLIENT_HANDLE, CARD_SOCKET_HANDLE);
typedef STATUS (*GETEVENTMASK)(CARD_CLIENT_HANDLE, PCARD_EVENT_MASK_PARMS);
typedef STATUS (*SETEVENTMASK)(CARD_CLIENT_HANDLE, PCARD_EVENT_MASK_PARMS);
typedef STATUS (*RESETFUNCTION)(CARD_CLIENT_HANDLE, CARD_SOCKET_HANDLE);
typedef CARD_WINDOW_HANDLE (*REQUESTWINDOW)(CARD_CLIENT_HANDLE, PCARD_WINDOW_PARMS);
typedef STATUS (*RELEASEWINDOW)(CARD_WINDOW_HANDLE);   
typedef STATUS (*MODIFYWINDOW)(CARD_WINDOW_HANDLE, UINT16, UINT8);
typedef PVOID (*MAPWINDOW)(CARD_WINDOW_HANDLE, UINT32, UINT32, PUINT32);
typedef STATUS (*REQUESTIRQ)(CARD_CLIENT_HANDLE, CARD_SOCKET_HANDLE,
                      CARD_ISR, UINT32);
typedef STATUS (*RELEASEIRQ)(CARD_CLIENT_HANDLE, CARD_SOCKET_HANDLE);
typedef STATUS (*REQUESTCONFIG)(CARD_CLIENT_HANDLE, PCARD_CONFIG_INFO);
typedef STATUS (*MODIFYCONFIG)(CARD_CLIENT_HANDLE, CARD_SOCKET_HANDLE, PUINT16);
typedef STATUS (*RELEASECONFIG)(CARD_CLIENT_HANDLE, CARD_SOCKET_HANDLE);
typedef STATUS (*ACCESSCONFIGREG)(CARD_CLIENT_HANDLE, CARD_SOCKET_HANDLE,
                      UINT8, UINT8, UINT8 *);
typedef STATUS (*POWERON)(CARD_CLIENT_HANDLE, CARD_SOCKET_HANDLE);
typedef STATUS (*POWEROFF)(CARD_CLIENT_HANDLE, CARD_SOCKET_HANDLE);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\camerapindriver.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef __PIN_DD
#define __PIN_DD

#include "marshal.hpp" //helper classes to marshal/alloc embedded/async buffer

#ifdef __cplusplus
extern "C" {
#endif

#define PIN_TIMEOUT    250

typedef struct _tagStreamDescriptorShadow
{
    PCS_STREAM_DESCRIPTOR pCsStreamDescriptorExternal;
    CS_STREAM_DESCRIPTOR  csStreamDescriptorShadow;
    BOOL                  m_fBusy;
    MarshalledBuffer_t   *m_pMarshalledDataBuffer;      // Marshalled/Async allocated data buffer when the memory model is not CSPROPERTY_BUFFER_DRIVER
    MarshalledBuffer_t   *m_pMarshalledStreamDesc;      // Marshalled/Async allocated stream descriptor
    PCS_STREAM_DESCRIPTOR m_pUnmarshalledStreamDesc;    // Driver maintains the unmarshalled descriptor pointer used for returning filled buffers
    PVOID                 m_pvUnmarshalledDataBuffer;   // Pointer to unmarshalled data buffer.
} CS_STREAM_DESCRIPTOR_SHADOW, * PCS_STREAM_DESCRIPTOR_SHADOW;


typedef class CPinDevice 
{
public:
    CPinDevice( );

    ~CPinDevice( );

    bool
    InitializeSubDevice(
        PCAMERADEVICE pCamDevice
        );

    DWORD
    StreamInstantiate(
        PCSPROPERTY_STREAMEX_S pCsPropStreamEx,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD                  OutBufLen,
        PDWORD                 pdwBytesTransferred
        );

    DWORD
    PinHandleConnectionRequests(
        PCSPROPERTY pCsProp,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD       OutBufLen,
        PDWORD      pdwBytesTransferred
        );

    DWORD
    PinHandleBufferRequest(
        CSBUFFER_INFO  csBufferInfo,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD  OutBufLen,
        DWORD *pdwBytesTransferred
        );

    DWORD
    PinHandleCustomRequests(
        __in_bcount(InBufLen) PUCHAR pInBuf,
        DWORD  InBufLen,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD  OutBufLen,
        PDWORD pdwBytesTransferred
        );

    DWORD
    HandlePinIO( );

    void 
    FlushBufferQueue();

    void
    ReleaseBuffers();

    CSSTATE
    GetState( ) { return m_CsState; };
    
    void
    SetState(
        CSSTATE   CsState,
        CSSTATE * CsPrevState
        );


    DWORD
    PauseStream( );

    DWORD
    CloseSubDevice( );

    ULONG
    PictureNumber( ) const;

    ULONG
    FramesDropped( ) const;

    ULONG
    FrameSize( ) const;

    LONG
    IncrementStillCount()
    {   return InterlockedIncrement(&m_lStillCount);   }

    LONG
    GetStillCount()
    {   return m_lStillCount;   }

    DWORD WriteMessage( 
        ULONG flag, 
        LPVOID Context 
        );

private:

    DWORD
    AllocateBuffer( 
        PCS_STREAM_DESCRIPTOR pCsDescriptor,
        PCS_STREAM_DESCRIPTOR pCsDescriptorOut,
        DWORD *pdwBytesTransferred
        );

    DWORD
    DeallocateBuffer(
        PCS_STREAM_DESCRIPTOR pCsDescriptor
        );

    DWORD
    DeallocateBuffer_I(
        DWORD dwIndex,
        BOOL fForce
        );

    DWORD
    EnqueueDescriptor(
        PCS_STREAM_DESCRIPTOR pCsDescriptor
        );

    bool
    RemoveBufferFromList(
        PCS_STREAM_DESCRIPTOR * ppCsStreamDesc,
        PVOID                 * ppMappedData,
        PVOID                 * ppUnmappedData,
        PDWORD                  pdwIndex
        );

    bool
    ResetBufferList( );
    
    DWORD
    PinHandleConnStateSubReqs(
        ULONG  ulReqFlags,
        __out_bcount(OutBufLen) PUCHAR pOutBuf,
        DWORD  OutBufLen,
        PDWORD pdwBytesTransferred
        );

    DWORD
    PinHandleConnDataFormatSubReqs(
        ULONG                          ulReqFlags,
        PCS_DATAFORMAT_VIDEOINFOHEADER pCsDataFormatVidInfoHdr,
        PDWORD                         pdwBytesTransferred
        );

    BOOL InitMsgQueueDescriptor(
        PCS_MSGQUEUE_BUFFER pCsMsgQBuff, 
        PCS_STREAM_DESCRIPTOR pCsStreamDesc, 
        PVOID pMappedData, 
        PVOID pUnmappedData, 
        DWORD dwIndex,
        BOOL bFillBuffer);

    LONG
    GetIndexFromHandle( 
        DWORD  dwHandle,
        LPVOID pBuffer
        );

    DWORD 
    MakeHandle( 
        DWORD  dwIndex, 
        LPVOID pBuffer 
        );

    DWORD
    SwSetupStreamDescriptor(
        DWORD dwIndex,
        PVOID pvUnmarshalledClientBuffer,
        PCS_STREAM_DESCRIPTOR pCsStreamDescOut
        );

    DWORD
    HwSetupStreamDescriptor(
        DWORD dwIndex
        );

    DWORD
    MarshalClientBuffer(
        DWORD dwIndex,
        PVOID pvUnmarshalledClientBuffer
        );

    DWORD
    UnmarshalClientBuffer(
        DWORD dwIndex
        );

    DWORD
    FlushClientBuffer(
        DWORD dwIndex
        );

    DWORD
    MarshalClientDescriptor(
        DWORD dwIndex,
        PCS_STREAM_DESCRIPTOR pUnmarshalledCsDescriptor
        );

    DWORD
    UnmarshalClientDescriptor(
        DWORD dwIndex
        );

    bool ReadMemoryModelFromRegistry();

    LONG DecrementStillCount()
    {   return InterlockedDecrement(&m_lStillCount);   };

    ULONG              m_ulPinId;
    // Get MAX buffer information from pdd ULONG              m_ulMaxNumOfBuffers;
    ULONG              m_ulFrameSize;
    ULONG              m_ulFramesDropped;
    ULONG              m_ulPictureNumber;
    LONG               m_lStillCount; //Count of still capture requests.

    DWORD              m_dwMemoryModel;
    DWORD              m_dwBufferCount;
    DWORD              m_ulMaxNumOfBuffers;
    DWORD              m_msStart;
    DWORD              m_msLastPT;
    
    REFERENCE_TIME     m_RtAveTimePerFrame;

    HANDLE             m_hMsgQ;

    CRITICAL_SECTION   m_csStreamBuffer;
    CRITICAL_SECTION   m_csStreamIO;

    PCAMERADEVICE      m_pCamAdapter;
    PCS_STREAM_DESCRIPTOR_SHADOW m_pStreamDescriptorList;
    CS_DATARANGE_VIDEO m_CsDataRangeVideo;

    CSSTATE            m_CsState;

    bool               m_fClientInitialized;
    bool               m_fDiscontinuity;


} PINDEVICE, * PPINDEVICE;

typedef struct CPinInitHandle
{
    PCAMERADEVICE pCamDevice;
} PININITHANDLE, * PPININITHANDLE;

#ifdef __cplusplus
}
#endif

#endif //__PIN_DD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cardserv.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  

    cardserv.h

Abstract:  

    This file implements the Windows CE PCMCIA Card Services structures and
    definitions.  This is provided as a sample to platform writers and is
    expected to be able to be used without modification on most (if not
    all) hardware platforms.

Functions:


Notes:


--*/

// @doc DRIVERS

#ifndef __CARDSERV_H__
#define __CARDSERV_H__ 1

#ifdef	__cplusplus
extern "C" {
#endif

//**********************************************************************
// WinCE Device Interface GUID for PCMCIA Card Services.
// Use the _GUID form to initialize a local const GUID to pass to
// RequestDeviceNotifications. NEVER CHANGE THESE VALUES! They indicate
// to whomever receives notfications that Card Services is present.
//**********************************************************************

#define DEVCLASS_CARDSERV_STRING TEXT("{6BEAB08A-8914-42fd-B33F-61968B9AAB32}")
#define DEVCLASS_CARDSERV_GUID { 0x6beab08a, 0x8914, 0x42fd, { 0xb3, 0x3f, 0x61, 0x96, 0x8b, 0x9a, 0xab, 0x32 } }


//**********************************************************************
// Card Services Event Codes.
//**********************************************************************

//
// @type CARD_EVENT | Event code passed to the client driver's callback function
//                    to indicate the type of PCMCIA event.
//
typedef UINT32 CARD_EVENT;

#define CE_BATTERY_DEAD          0x01
#define CE_BATTERY_LOW           0x02
#define CE_CARD_LOCK             0x03
#define CE_CARD_READY            0x04
#define CE_CARD_REMOVAL          0x05
#define CE_CARD_UNLOCK           0x06
#define CE_EJECTION_COMPLETE     0x07
#define CE_EJECTION_REQUEST      0x08
#define CE_INSERTION_COMPLETE    0x09
#define CE_INSERTION_REQUEST     0x0A
#define CE_PM_RESUME             0x0B    // Power management
#define CE_PM_SUSPEND            0x0C    // Power management
#define CE_EXCLUSIVE_COMPLETE    0x0D
#define CE_EXCLUSIVE_REQUEST     0x0E
#define CE_RESET_PHYSICAL        0x0F
#define CE_RESET_REQUEST         0x10
#define CE_CARD_RESET            0x11
#define CE_MTD_REQUEST           0x12
#define CE_CLIENT_INFO           0x14
#define CE_TIMER_EXPIRED         0x15
#define CE_SS_UPDATED            0x16
#define CE_WRITE_PROTECT         0x17
#define CE_CARD_INSERTION        0x40
#define CE_RESET_COMPLETE        0x80
#define CE_ERASE_COMPLETE        0x81
#define CE_REGISTRATION_COMPLETE 0x82
#define CE_STATUS_CHANGE_INTERRUPT 0xFE   // The card generated a status change interrupt

//**********************************************************************
// Card Services Return Codes.
//**********************************************************************

//
// @type STATUS | Set of return codes used by Card Services
//
typedef UINT32 STATUS;

#define CERR_SUCCESS              0x00
#define CERR_BAD_ADAPTER          0x01
#define CERR_BAD_ATTRIBUTE        0x02
#define CERR_BAD_BASE             0x03
#define CERR_BAD_EDC              0x04
#define CERR_BAD_IRQ              0x06
#define CERR_BAD_OFFSET           0x07
#define CERR_BAD_PAGE             0x08
#define CERR_READ_FAILURE         0x09
#define CERR_BAD_SIZE             0x0A
#define CERR_BAD_SOCKET           0x0B
#define CERR_BAD_TYPE             0x0D
#define CERR_BAD_VCC              0x0E
#define CERR_BAD_VPP              0x0F
#define CERR_BAD_WINDOW           0x11
#define CERR_WRITE_FAILURE        0x12
#define CERR_NO_CARD              0x14
#define CERR_UNSUPPORTED_SERVICE  0x15
#define CERR_UNSUPPORTED_MODE     0x16
#define CERR_BAD_SPEED            0x17
#define CERR_BUSY                 0x18
#define CERR_GENERAL_FAILURE      0x19
#define CERR_WRITE_PROTECTED      0x1A
#define CERR_BAD_ARG_LENGTH       0x1B
#define CERR_BAD_ARGS             0x1C
#define CERR_CONFIGURATION_LOCKED 0x1D
#define CERR_IN_USE               0x1E
#define CERR_NO_MORE_ITEMS        0x1F
#define CERR_OUT_OF_RESOURCE      0x20
#define CERR_BAD_HANDLE           0x21
#define CERR_BAD_VERSION          0x22

//*********************************************************************
// Card Services Interface Structures.
// (Must be packed to one byte to guarantee conformance to the
//  card services specification).
//*********************************************************************/

#pragma pack(1)

typedef PVOID CARD_CLIENT_HANDLE;
typedef PVOID CARD_WINDOW_HANDLE;

//*****************************************************************
// Socket handle (formed by concatenating the 0 based socket number
// and the 0 based function number)
//*****************************************************************/

//
// @struct CARD_SOCKET_HANDLE | Structure used to specify a logical socket
//                              and is composed of a socket number and a function number
//

typedef struct _CARD_SOCKET_HANDLE {
    UINT8 uSocket;          // @field Specifies the socket number (first socket is 0)
    UINT8 uFunction;        // @field Specifies the function number (first function is 0)
} CARD_SOCKET_HANDLE, *PCARD_SOCKET_HANDLE;


//*****************************************************************
// Event Mask Structures.
//*****************************************************************/

#define EVENT_ATTR_SOCKET_ONLY        0x0001    // 0 for global event mask

//
// Event masks used in calls to CardRequestSocketMask, CardGetEventMask,
// CardSetEventMask and CardRegisterClient
//
// CARD_REGISTER_PARMS.fEventMask
// CARD_EVENT_MASK_PARMS.fEventMask
// CardRequestSocketMask(fEventMask)
// CARD_STATUS.fCardState
// CARD_STATUS.fSocketState
// (PCARD_SOCKET_INFO.fInterruptEvents)
// (PCARD_SOCKET_INFO.fNotifyEvents)
//
#define EVENT_MASK_WRITE_PROTECT    0x0001 // write protect change
#define EVENT_MASK_CARD_LOCK        0x0002 // card lock change
#define EVENT_MASK_EJECT_REQ        0x0004 // ejection request
#define EVENT_MASK_INSERT_REQ       0x0008 // insertion request
#define EVENT_MASK_BATTERY_DEAD     0x0010 // battery dead
#define EVENT_MASK_BATTERY_LOW      0x0020 // battery low
#define EVENT_MASK_CARD_READY       0x0040 // ready change
#define EVENT_MASK_CARD_DETECT      0x0080 // card detect change
#define EVENT_MASK_POWER_MGMT       0x0100 // power management change
#define EVENT_MASK_RESET            0x0200 // card resets
#define EVENT_MASK_STATUS_CHANGE    0x0400 // card generated status change interrupts

//
// @struct CARD_EVENT_MASK_PARMS | Structure passed to <f CardGetEventMask> and <f CardSetEventMask>
// 
typedef struct _CARD_EVENT_MASK_PARMS {
    CARD_SOCKET_HANDLE    hSocket;      // @field Logical socket (socket/function)
    UINT16  fAttributes;                // @field First bit clear indicates the global event mask
                                        //        First bit set indicates the socket specific event mask
    UINT16  fEventMask;                 // @field Input for CardSetEventMask, Output for CardGetEventMask
} CARD_EVENT_MASK_PARMS, *PCARD_EVENT_MASK_PARMS;


//******************************************************************
// Callback function parameter block
//******************************************************************

//
// @struct CARD_EVENT_PARMS | Structure passed to the client driver's callback function
//
typedef struct _CARD_EVENT_PARMS {
    UINT32 uClientData;             // @field Context data specified in CardRegisterClient
    UINT32 Parm1;                   // @field Event code specific parameter one
    UINT32 Parm2;                   // @field Event code specific parameter two
} CARD_EVENT_PARMS, *PCARD_EVENT_PARMS;

typedef STATUS (*CLIENT_CALLBACK)(CARD_EVENT, CARD_SOCKET_HANDLE, PCARD_EVENT_PARMS);
typedef CLIENT_CALLBACK *PCLIENT_CALLBACK;

//
// Client driver interrupt service routine prototype
//
typedef VOID (*CARD_ISR)(UINT32);
typedef CARD_ISR *PCARD_ISR;

//******************************************************************
// Register Client Flags
//******************************************************************

//
// CARD_REGISTER_PARMS.fAttributes
//
#define CLIENT_ATTR_MEM_DRIVER       0x0001   // memory client driver
#define CLIENT_ATTR_MTD_DRIVER       0x0002   // memory technology driver
#define CLIENT_ATTR_IO_DRIVER        0x0004   // i/o client driver
#define CLIENT_ATTR_NOTIFY_SHARED    0x0008   // sharable PC cards
#define CLIENT_ATTR_NOTIFY_EXCLUSIVE 0x0010   // exclusively used PC cards

//
// @struct CARD_REGISTER_PARMS | Structure used to indicate client driver characteristics to
//                               the <f CardRegisterClient> API
//
typedef struct _CARD_REGISTER_PARMS {
    UINT16 fAttributes;         // @field Type of driver
    UINT16 fEventMask;          // @field Global event mask
    UINT32 uClientData;         // @field Context data for the callback function
} CARD_REGISTER_PARMS,*PCARD_REGISTER_PARMS;

//*****************************************************************
// Window packet structures.
//****************************************************************

//
// Window attribute masks used in calls to
// CardRequestWindow and CardModifyWindow
//
// Usage:
// CARD_WINDOW_PARMS.fAttributes
// CardModifyWindow(fAttributes)
//
#define WIN_ATTR_IO_SPACE      0x0001        // 1 = I/O window
                                             // 0 = memory window
#define WIN_ATTR_ATTRIBUTE     0x0002        // 1 = attribute, 0 = common
#define WIN_ATTR_ENABLED       0x0004        // 1 = window is enabled
                                             // 0 = window is disabled
#define WIN_ATTR_16BIT         0x0008        // 1 = 16 bit, 0 = 8 bit
#define WIN_ATTR_PAGED         0x0010        // 1 = size is 16K multiple
#define WIN_ATTR_SHARED        0x0020        // 1 = shared memory request
#define WIN_ATTR_FIRST_SHARED  0x0040        // 1 = first shared request
#define WIN_ATTR_OFFSETS_SIZED 0x0100        // card offsets window sized
#define WIN_ATTR_ACCESS_SPEED_VALID 0x0200   // Used to cause CardModifyWindow 
                                             // to change the window's access speed

//
// Memory window speed encodings
//
// Usage:
// CARD_WINDOW_PARMS.fAccessSpeed
// CardModifyWindow(fAccessSpeed)
// (PDCARD_WINDOW_INFO.fSlowest)
// (PDCARD_WINDOW_INFO.fFastest)
// (PDCARD_WINDOW_STATE.fSpeed)
//
#define WIN_SPEED_EXP_MASK  0x07    // Exponent mask
#define WIN_SPEED_EXP_1NS   0x00    // 1 nanosecond
#define WIN_SPEED_EXP_10NS  0x01
#define WIN_SPEED_EXP_100NS 0x02
#define WIN_SPEED_EXP_1US   0x03    // 1 microsecond
#define WIN_SPEED_EXP_10US  0x04
#define WIN_SPEED_EXP_100US 0x05
#define WIN_SPEED_EXP_1MS   0x06    // 1 millisecond
#define WIN_SPEED_EXP_10MS  0x07

#define WIN_SPEED_MANT_MASK 0x78    // Mantissa mask
#define WIN_SPEED_MANT_10   0x08    // 1.0
#define WIN_SPEED_MANT_12   0x10    // 1.2
#define WIN_SPEED_MANT_13   0x18    // 1.3
#define WIN_SPEED_MANT_15   0x20    // 1.5
#define WIN_SPEED_MANT_20   0x28    // 2.0
#define WIN_SPEED_MANT_25   0x30    // 2.5
#define WIN_SPEED_MANT_30   0x38    // 3.0
#define WIN_SPEED_MANT_35   0x40    // 3.5
#define WIN_SPEED_MANT_40   0x48    // 4.0
#define WIN_SPEED_MANT_45   0x50    // 4.5
#define WIN_SPEED_MANT_50   0x58    // 5.0
#define WIN_SPEED_MANT_55   0x60    // 5.5
#define WIN_SPEED_MANT_60   0x68    // 6.0
#define WIN_SPEED_MANT_70   0x70    // 7.0
#define WIN_SPEED_MANT_80   0x78    // 8.0

#define WIN_SPEED_USE_WAIT  0x80    // Use wait if available

//
// @struct CARD_WINDOW_PARMS | Structure to specify the desired memory or I/O window characteristics
//                             to <f CardRequestWindow>
//
typedef struct _CARD_WINDOW_PARMS {
    CARD_SOCKET_HANDLE hSocket;     // @field Socket to be associated with the window
    UINT16 fAttributes;             // @field Bit encoded window attributes
    UINT32 uWindowSize;             // @field Desired window size in bytes
    UINT8  fAccessSpeed;            // @field Bit encoded memory access speed
} CARD_WINDOW_PARMS, *PCARD_WINDOW_PARMS;


//*****************************************************************
// Configuration packet structures.
//****************************************************************

//
// CARD_CONFIG_INFO.fAttributes
//
#define CFG_ATTR_EXCLUSIVE    0x0001
#define CFG_ATTR_IRQ_STEERING 0x0002    // Enable interrupts from PC card to host
#define CFG_ATTR_IRQ_WAKEUP   0x0004    // Allow PCMCIA ints to wake system from
                                        // suspend mode. 
#define CFG_ATTR_KEEP_POWERED 0x0008    // Keep the PCMCIA bus powered while the
                                        // system is in the suspended state.
#define CFG_ATTR_NO_SUSPEND_UNLOAD 0x0010    // Do not unload the driver when returning from suspend
                                             // If possible
#define CFG_ATTR_ENABLE_DMA   0x0040
#define CFG_ATTR_VALID_CLIENT 0x0100    
#define CFG_ATTR_VS_OVERRIDE  0x0200
#define CFG_ATTR_NO_IO_IS_8   0x0400

//
// CARD_CONFIG_INFO.fInterfaceType
// (PDCARD_SOCKET_STATE.fInterfaceType)
//
#define CFG_IFACE_MEMORY    0x0001  // Put socket controller in memory only interface mode
#define CFG_IFACE_MEMORY_IO 0x0002  // Put socket controller in memory and I/O interface mode

//
// CARD_CONFIG_INFO.fRegisters
//
// Each of these bits indicates the presence one of the standard function and
// configuration registers in the attribute space of the PC card.  Using the API
// CardRequestConfiguration, a driver can set these registers to desired initial
// values.  The fRegisters field indicates which registers to write.
//
#define CFG_REGISTER_CONFIG   0x01  // Configuration Option Register (uConfigReg)
#define CFG_REGISTER_STATUS   0x02  // Function Configuration and Status Register (uStatusReg)
#define CFG_REGISTER_PIN      0x04  // Pin Replacement Register (uPinReg)
#define CFG_REGISTER_COPY     0x08  // Socket and Copy Register (uCopyReg)
#define CFG_REGISTER_EXSTATUS 0x10  // Extended Status register (uExtendedStatus)
#define CFG_REGISTER_EXREG    0x20  // Extended registers present

// Extended register presence bits

#define CFG_EXREGISTER_IOBASE0      0x0001
#define CFG_EXREGISTER_IOBASE1      0x0002
#define CFG_EXREGISTER_IOBASE2      0x0004
#define CFG_EXREGISTER_IOBASE3      0x0008
#define CFG_EXREGISTER_IOLIMIT      0x0010

//
// @struct CARD_CONFIG_INFO | Structure used to indicate desired PC card configuration parameters
//                            to the <f CardRequestConfiguration> API
//  
typedef struct _CARD_CONFIG_INFO {
    CARD_SOCKET_HANDLE  hSocket;// @field Logical socket (socket/function)
    UINT16 fAttributes;         // @field Bit encoded socket attributes
    UINT8  fInterfaceType;      // @field Bit encoded PC card interface type (memory or I/O)
    UINT8  uVcc;                // @field Vcc voltage to use
    UINT8  uVpp1;               // @field Vpp1 voltage to use
    UINT8  uVpp2;               // @field Vpp2 voltage to use
    UINT8  fRegisters;          // @field Register presence mask
    UINT8  uConfigReg;          // @field Initial value to write to the configuration option register
    UINT8  uStatusReg;          // @field Initial value to write to the function status register
    UINT8  uPinReg;             // @field Initial value to write to the pin replacement register
    UINT8  uCopyReg;            // @field Initial value to write to the socket and copy register
    UINT8  uExtendedStatus;     // @field Initial value to write to the extended status register
    UINT16 fExtRegisters;       // @field Extended register presence mask
    UINT8  IOBase[4];           // @field Initial value to write to the I/O Base registers
    UINT8  IOLimit;             // @field Initial value to write to the I/O Limit register
} CARD_CONFIG_INFO, *PCARD_CONFIG_INFO;

//
// Function Configuration Register offsets
//
#define FCR_OFFSET_COR   0   // Configuration Option Register
#define FCR_OFFSET_FCSR  1   // Function and Configuration Status Register
#define FCR_OFFSET_PRR   2   // Pin Replacement Register
#define FCR_OFFSET_SCR   3   // Socket and Copy Register
#define FCR_OFFSET_ESR   4   // Extended Status Register
#define FCR_OFFSET_IOB0  5   // I/O Base Register 0
#define FCR_OFFSET_IOB1  6   // I/O Base Register 1
#define FCR_OFFSET_IOB2  7   // I/O Base Register 2
#define FCR_OFFSET_IOB3  8   // I/O Base Register 3
#define FCR_OFFSET_IOSZ  9   // I/O Size Register

//
// Configuration Option Register Bit Masks
// CARD_CONFIG_INFO.uConfigReg
//
// Note: The lower 6 bits of the configuration option register are used to
//       specify which configuration number to use for single function cards.
//
#define FCR_COR_LEVEL_IREQ  0x40    // 1 = level mode interrupts, 0 = pulse mode
#define FCR_COR_SRESET      0x80    // 1 = soft reset

//
// Function and Configuration Status Register Bit Masks
// CARD_CONFIG_INFO.uStatusReg
//
#define FCR_FCSR_INTR_ACK   0x01    // interrupt acknowledge
#define FCR_FCSR_INTR       0x02    // interrupt pending
#define FCR_FCSR_PWR_DOWN   0x04    // place PC card in power down mode
#define FCR_FCSR_AUDIO      0x08    // enable audio signal on BVD2 (pin 62)
#define FCR_FCSR_IO_IS_8    0x20    // used by host to indicate 8 bit only I/O
#define FCR_FCSR_STSCHG     0x40    // Enable status change (STSCHG, pin 63) from PC card
#define FCR_FCSR_CHANGED    0x80    // Set if one of the status changed bits is set in
                                    // the pin replacement register.

#define FCR_FCSR_REQUIRED_BITS (FCR_FCSR_INTR_ACK|FCR_FCSR_IO_IS_8)

//
// CARD_CONFIG_INFO.uPinReg
//
#define FCR_PRR_RWP         0x01    // Current state of write protect
#define FCR_PRR_RREADY      0x02    // Current state of Ready
#define FCR_PRR_RBVD2       0x04    // Current state of BV2
#define FCR_PRR_RBVD1       0x08    // Current state of BV1
#define FCR_PRR_CWP         0x10    // Write protect changed
#define FCR_PRR_CRDY        0x20    // Ready changed
#define FCR_PRR_CBVD2       0x40    // BVD2 changed
#define FCR_PRR_CBVD1       0x80    // BVD1 changed


//
//  Used for CardAccessConfigurationRegister function
//
#define CARD_FCR_READ  0
#define CARD_FCR_WRITE 1

//*****************************************************************
// CardGetStatus structure
//*****************************************************************

//
// @struct CARD_STATUS | Structure used by <f CardGetStatus>
//
typedef struct _CARD_STATUS {
    CARD_SOCKET_HANDLE  hSocket;    // @field Logical socket (socket/function)
    UINT16  fCardState;             // @field current card state
    UINT16  fSocketState;           // @field changed socket state
} CARD_STATUS, *PCARD_STATUS;


//*****************************************************************
// Tuple request structures.
// NOTE:
//         - The tuple flags structure is only used internally by card
//           services and is defined as required by an implementation.
//         - A variable length tuple data area immediately follows
//           the tuple data packet structure.
//****************************************************************

//
// CARD_TUPLE_PARMS.fAttributes
// CARD_DATA_PARMS.fAttributes
//
#define TUPLE_RETURN_LINKS  0x0001   // return link tuples

//
// @struct CARD_TUPLE_PARMS | Structure passed to <f CardGetFirstTuple> and used in
//                            subsequent calls to <f CardGetNextTuple>.
//                            
typedef struct _CARD_TUPLE_PARMS {
    CARD_SOCKET_HANDLE  hSocket;// @field Logical socket (socket/function)
    UINT16 fAttributes;         // @field First bit set means to return link tuples
    UINT8  uDesiredTuple;       // @field Tuple code of desired tuple or 0xFF for any tuple
    UINT8  uReserved;           // @field Reserved (used to maintain alignment with CARD_DATA_PARMS)
    UINT16 fFlags;              // @field Used by Card Services, value must be preserved
    UINT32 uLinkOffset;         // @field Used by Card Services, value must be preserved
    UINT32 uCISOffset;          // @field Used by Card Services, value must be preserved
    UINT8  uTupleCode;          // @field Output: Tuple code found
    UINT8  uTupleLink;          // @field Output: Link field (length) of tuple found
} CARD_TUPLE_PARMS, *PCARD_TUPLE_PARMS;

//
// @struct CARD_DATA_PARMS | Structure passed to <f CardGetTupleData>.  With care,
//               one region of memory can be used as both a <t CARD_TUPLE_PARMS> and
//               a CARD_DATA_PARMS structure.
//
typedef struct _CARD_DATA_PARMS {
    CARD_SOCKET_HANDLE  hSocket;// @field Logical socket (socket/function)
    UINT16 fAttributes;         // @field First bit set means to return link tuples
    UINT8  uDesiredTuple;       // @field Tuple code of desired tuple or 0xFF for any tuple
    UINT8  uTupleOffset;        // @field Offset in the current tuple to retrieve data
    UINT16 fFlags;              // @field Used by Card Services, value must be preserved
    UINT32 uLinkOffset;         // @field Used by Card Services, value must be preserved
    UINT32 uCISOffset;          // @field Used by Card Services, value must be preserved
    UINT16 uBufLen;             // @field Input: number of bytes following this CARD_DATA_PARMS structure
    UINT16 uDataLen;            // @field Output: number of bytes of data returned
} CARD_DATA_PARMS, *PCARD_DATA_PARMS;


#pragma pack()   // return packing to normal


//
// Prototype for the detection function.
//
// Return is NULL for undetected or pointer to the device key under HLM\Drivers\PCMCIA
// of the device driver to load for a detected card.
//
typedef LPTSTR (*PFN_DETECT_ENTRY)(
                    CARD_SOCKET_HANDLE, // Socket containing the card to detect
                    UCHAR,              // Device type from CISTPL_FUNCID or 0xff for unknown
                    LPTSTR,             // Buffer to put name of device key
                    DWORD);             // Number of characters in buffer parameter


//
// Card Services Function Prototypes
//
CARD_CLIENT_HANDLE CardRegisterClient(CLIENT_CALLBACK CallBackFn, PCARD_REGISTER_PARMS pParms);
STATUS CardDeregisterClient(CARD_CLIENT_HANDLE hCardClient);
STATUS CardGetFirstTuple(PCARD_TUPLE_PARMS pGetTupleParms);
STATUS CardGetNextTuple(PCARD_TUPLE_PARMS pGetTupleParms);
STATUS CardGetTupleData(PCARD_DATA_PARMS pGetTupleData);
STATUS CardGetParsedTuple(CARD_SOCKET_HANDLE hSocket, UINT8 uDesiredTuple, PVOID pBuf, PUINT32 pnItems);
STATUS CardRequestExclusive(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSocket);
STATUS CardReleaseExclusive(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSocket);
STATUS CardRequestSocketMask(CARD_CLIENT_HANDLE hCardClient,
                             CARD_SOCKET_HANDLE hSock, UINT16 fEventMask);
STATUS CardReleaseSocketMask(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSock);
STATUS CardGetEventMask(CARD_CLIENT_HANDLE hCardClient, PCARD_EVENT_MASK_PARMS pMaskParms);
STATUS CardSetEventMask(CARD_CLIENT_HANDLE hCardClient, PCARD_EVENT_MASK_PARMS pMaskParms);
STATUS CardResetFunction(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSock);
CARD_WINDOW_HANDLE CardRequestWindow(CARD_CLIENT_HANDLE hCardClient, PCARD_WINDOW_PARMS pCardWinParms);
STATUS CardReleaseWindow(CARD_WINDOW_HANDLE hCardWin);   
STATUS CardModifyWindow(CARD_WINDOW_HANDLE hCardWindow, UINT16 fAttributes, UINT8 fAccessSpeed);
PVOID CardMapWindow(CARD_WINDOW_HANDLE hCardWindow, UINT32 uCardAddress, UINT32 uSize, PUINT32 pGranularity);
STATUS CardGetStatus(PCARD_STATUS pStatus);
STATUS CardRequestIRQ(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSocket,
                      CARD_ISR ISRFunction, UINT32 uISRContextData);
STATUS CardReleaseIRQ(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSocket);
STATUS CardRequestConfiguration(CARD_CLIENT_HANDLE hCardClient, PCARD_CONFIG_INFO pParms);
STATUS CardModifyConfiguration(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSock,
                      PUINT16 fAttributes);
STATUS CardReleaseConfiguration(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSock);
STATUS CardAccessConfigurationRegister(CARD_CLIENT_HANDLE hCardClient,
                                       CARD_SOCKET_HANDLE hSock,UINT8 rw_flag,
                                       UINT8 offset,UINT8 *pValue);
STATUS CardPowerOn(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSock);
STATUS CardPowerOff(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSock);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cardsv2.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  

cardsv2.h

Abstract:  

This file implements the Windows CE PCMCIA Card Services structures and
definitions.  This is provided as a sample to platform writers and is
expected to be able to be used without modification on most (if not
all) hardware platforms.

Functions:


Notes:


--*/

// @doc DRIVERS

#ifndef __CARDSV2_H__
#define __CARDSV2_H__ 

// Disable First Version of CardService.
#ifndef __CARDSERV_H__
#define __CARDSERV_H__
#endif

#include <SockSv2.h>
#ifdef  __cplusplus
extern "C"
{
#endif

    //**********************************************************************
    // WinCE Device Interface GUID for PCMCIA Card Services.
    // Use the _GUID form to initialize a local const GUID to pass to
    // RequestDeviceNotifications. NEVER CHANGE THESE VALUES! They indicate
    // to whomever receives notfications that Card Services is present.
    //**********************************************************************

#define DEVCLASS_CARDSERV_STRING TEXT("{6BEAB08A-8914-42fd-B33F-61968B9AAB32}")
#define DEVCLASS_CARDSERV_GUID { 0x6beab08a, 0x8914, 0x42fd, { 0xb3, 0x3f, 0x61, 0x96, 0x8b, 0x9a, 0xab, 0x32 } }


    //**********************************************************************
    // Card Services Event Codes.
    //**********************************************************************

    //
    // @type CARD_EVENT | Event code passed to the client driver's callback function
    //                    to indicate the type of PCMCIA event.
    //
    typedef UINT32 CARD_EVENT;

#define CE_BATTERY_DEAD          0x01
#define CE_BATTERY_LOW           0x02
#define CE_CARD_LOCK             0x03
#define CE_CARD_READY            0x04
#define CE_CARD_REMOVAL          0x05
#define CE_CARD_UNLOCK           0x06
#define CE_EJECTION_COMPLETE     0x07
#define CE_EJECTION_REQUEST      0x08
#define CE_INSERTION_COMPLETE    0x09
#define CE_INSERTION_REQUEST     0x0A
#define CE_PM_RESUME             0x0B    // Power management
#define CE_PM_SUSPEND            0x0C    // Power management
#define CE_EXCLUSIVE_COMPLETE    0x0D
#define CE_EXCLUSIVE_REQUEST     0x0E
#define CE_RESET_PHYSICAL        0x0F
#define CE_RESET_REQUEST         0x10
#define CE_CARD_RESET            0x11
#define CE_MTD_REQUEST           0x12
#define CE_CLIENT_INFO           0x14
#define CE_TIMER_EXPIRED         0x15
#define CE_SS_UPDATED            0x16
#define CE_WRITE_PROTECT         0x17
#define CE_POWER_CYCLE_ON        0x20
#define CE_POWER_CYCLE_OFF       0x21
#define CE_CARD_INSERTION        0x40
#define CE_RESET_COMPLETE        0x80
#define CE_ERASE_COMPLETE        0x81
#define CE_REGISTRATION_COMPLETE 0x82
#define CE_CARD_BUS_INFO         0x83
#define CE_CARD_UNLOAD_DRIVER    0x84
#define CE_CARD_LOAD_DRIVER      0x85
#define CE_STATUS_CHANGE_INTERRUPT 0xFE   // The card generated a status change interrupt

    //**********************************************************************
    // Card Services Return Codes.
    // It define at SockSv2.h
    //**********************************************************************

    //*********************************************************************
    // Card Services Interface Structures.
    // (Must be packed to one byte to guarantee conformance to the
    //  card services specification).
    //*********************************************************************/

#pragma pack(1)

    typedef PVOID CARD_CLIENT_HANDLE;

    typedef PVOID CARD_WINDOW_HANDLE;

    //*****************************************************************
    // Socket handle (formed by concatenating the 0 based socket number
    // and the 0 based function number)
    //*****************************************************************/

    //
    // @struct CARD_SOCKET_HANDLE | Structure used to specify a logical socket
    //                              and is composed of a socket number and a function number
    //

    typedef struct _CARD_SOCKET_HANDLE
    {
        UINT8   uSocket;          // @field Specifies the socket number (first socket is 0)
        UINT8   uFunction;        // @field Specifies the function number (first function is 0)
    } CARD_SOCKET_HANDLE, * PCARD_SOCKET_HANDLE;

    typedef struct _WINDOW_HANDLE_CONTENT
    {
        UINT16              uWindowIndex;
        CARD_SOCKET_HANDLE  hCardHandle;
    } WINDOW_HANDLE_CONTENT;

    //*****************************************************************
    // Event Mask Structures.
    //*****************************************************************/

#define EVENT_ATTR_SOCKET_ONLY        0x0001    // 0 for global event mask

    //
    // Event masks used in calls to CardRequestSocketMask, CardGetEventMask,
    // CardSetEventMask and CardRegisterClient
    //
    // CARD_REGISTER_PARMS.fEventMask
    // CARD_EVENT_MASK_PARMS.fEventMask
    // CardRequestSocketMask(fEventMask)
    // CARD_STATUS.fCardState
    // CARD_STATUS.fSocketState
    // (PCARD_SOCKET_INFO.fInterruptEvents)
    // (PCARD_SOCKET_INFO.fNotifyEvents)
    //
#define EVENT_MASK_WRITE_PROTECT    0x0001 // write protect change
#define EVENT_MASK_CARD_LOCK        0x0002 // card lock change
#define EVENT_MASK_EJECT_REQ        0x0004 // ejection request
#define EVENT_MASK_INSERT_REQ       0x0008 // insertion request
#define EVENT_MASK_BATTERY_DEAD     0x0010 // battery dead
#define EVENT_MASK_BATTERY_LOW      0x0020 // battery low
#define EVENT_MASK_CARD_READY       0x0040 // ready change
#define EVENT_MASK_CARD_DETECT      0x0080 // card detect change
#define EVENT_MASK_POWER_MGMT       0x0100 // power management change
#define EVENT_MASK_RESET            0x0200 // card resets
#define EVENT_MASK_STATUS_CHANGE    0x0400 // card generated status change interrupts
#define EVENT_MASK_POWER_CYCLE      0x0800 // Report Power Cycle happens.
#define EVENT_MASK_CARDBUS_CARD     0x1000 // Report If it is cardbus card or not.
    //
    // @struct CARD_EVENT_MASK_PARMS | Structure passed to <f CardGetEventMask> and <f CardSetEventMask>
    // 
    typedef struct _CARD_EVENT_MASK_PARMS
    {
        CARD_SOCKET_HANDLE  hSocket;      // @field Logical socket (socket/function)
        UINT16              fAttributes;                // @field First bit clear indicates the global event mask
        //        First bit set indicates the socket specific event mask
        UINT16              fEventMask;                 // @field Input for CardSetEventMask, Output for CardGetEventMask
    } CARD_EVENT_MASK_PARMS, * PCARD_EVENT_MASK_PARMS;


    //******************************************************************
    // Callback function parameter block
    //******************************************************************

    //
    // @struct CARD_EVENT_PARMS | Structure passed to the client driver's callback function
    //
    typedef struct _CARD_EVENT_PARMS
    {
        UINT32  uClientData;             // @field Context data specified in CardRegisterClient
        UINT32  Parm1;                   // @field Event code specific parameter one
        UINT32  Parm2;                   // @field Event code specific parameter two
    } CARD_EVENT_PARMS, * PCARD_EVENT_PARMS;

    typedef STATUS ( *CLIENT_CALLBACK )( CARD_EVENT,
                                         CARD_SOCKET_HANDLE,
                                         PCARD_EVENT_PARMS );
    typedef CLIENT_CALLBACK* PCLIENT_CALLBACK;

    //
    // Client driver interrupt service routine prototype
    //
    typedef VOID ( *CARD_ISR )( UINT32 );
    typedef CARD_ISR* PCARD_ISR;

    //******************************************************************
    // Register Client Flags
    //******************************************************************

    //
    // CARD_REGISTER_PARMS.fAttributes
    //
#define CLIENT_ATTR_MEM_DRIVER       0x0001   // memory client driver
#define CLIENT_ATTR_MTD_DRIVER       0x0002   // memory technology driver
#define CLIENT_ATTR_IO_DRIVER        0x0004   // i/o client driver
#define CLIENT_ATTR_NOTIFY_SHARED    0x0008   // sharable PC cards
#define CLIENT_ATTR_NOTIFY_EXCLUSIVE 0x0010   // exclusively used PC cards
#define CLIENT_ATTR_CARDBUS_DRIVER   0x8000   // 32-Bit CardBus Driver.
    //
    // @struct CARD_REGISTER_PARMS | Structure used to indicate client driver characteristics to
    //                               the <f CardRegisterClient> API
    //
    typedef struct _CARD_REGISTER_PARMS
    {
        UINT16  fAttributes;         // @field Type of driver
        UINT16  fEventMask;          // @field Global event mask
        UINT32  uClientData;         // @field Context data for the callback function
    } CARD_REGISTER_PARMS, * PCARD_REGISTER_PARMS;

    //*****************************************************************
    // Window packet structures.
    //****************************************************************

    //
    // Window attribute masks used in calls to
    // CardRequestWindow and CardModifyWindow
    //
    // Usage:
    // CARD_WINDOW_PARMS.fAttributes
    // CardModifyWindow(fAttributes)
    //
#define WIN_ATTR_IO_SPACE      0x0001        // 1 = I/O window
    // 0 = memory window
#define WIN_ATTR_ATTRIBUTE     0x0002        // 1 = attribute, 0 = common
#define WIN_ATTR_ENABLED       0x0004        // 1 = window is enabled
    // 0 = window is disabled
#define WIN_ATTR_16BIT         0x0008        // 1 = 16 bit, 0 = 8 bit
    //#define WIN_ATTR_PAGED         0x0010        // 1 = size is 16K multiple
    //#define WIN_ATTR_SHARED        0x0020        // 1 = shared memory request
#define WIN_ATTR_SHARED_IO     0x0040        // 1 = first shared request
#define WIN_ATTR_OFFSETS_SIZED 0x0100        // card offsets window sized
#define WIN_ATTR_ACCESS_SPEED_VALID 0x0200   // Used to cause CardModifyWindow 
    // to change the window's access speed

    //
    // Memory window speed encodings
    //
    // Usage:
    // CARD_WINDOW_PARMS.fAccessSpeed
    // CardModifyWindow(fAccessSpeed)
    // (PDCARD_WINDOW_INFO.fSlowest)
    // (PDCARD_WINDOW_INFO.fFastest)
    // (PDCARD_WINDOW_STATE.fSpeed)
    //
#define WIN_SPEED_EXP_MASK  0x07    // Exponent mask
#define WIN_SPEED_EXP_1NS   0x00    // 1 nanosecond
#define WIN_SPEED_EXP_10NS  0x01
#define WIN_SPEED_EXP_100NS 0x02
#define WIN_SPEED_EXP_1US   0x03    // 1 microsecond
#define WIN_SPEED_EXP_10US  0x04
#define WIN_SPEED_EXP_100US 0x05
#define WIN_SPEED_EXP_1MS   0x06    // 1 millisecond
#define WIN_SPEED_EXP_10MS  0x07

#define WIN_SPEED_MANT_MASK 0x78    // Mantissa mask
#define WIN_SPEED_MANT_10   0x08    // 1.0
#define WIN_SPEED_MANT_12   0x10    // 1.2
#define WIN_SPEED_MANT_13   0x18    // 1.3
#define WIN_SPEED_MANT_15   0x20    // 1.5
#define WIN_SPEED_MANT_20   0x28    // 2.0
#define WIN_SPEED_MANT_25   0x30    // 2.5
#define WIN_SPEED_MANT_30   0x38    // 3.0
#define WIN_SPEED_MANT_35   0x40    // 3.5
#define WIN_SPEED_MANT_40   0x48    // 4.0
#define WIN_SPEED_MANT_45   0x50    // 4.5
#define WIN_SPEED_MANT_50   0x58    // 5.0
#define WIN_SPEED_MANT_55   0x60    // 5.5
#define WIN_SPEED_MANT_60   0x68    // 6.0
#define WIN_SPEED_MANT_70   0x70    // 7.0
#define WIN_SPEED_MANT_80   0x78    // 8.0

#define WIN_SPEED_USE_WAIT  0x80    // Use wait if available

    //
    // @struct CARD_WINDOW_PARMS | Structure to specify the desired memory or I/O window characteristics
    //                             to <f CardRequestWindow>
    //
    typedef struct _CARD_WINDOW_PARMS
    {
        CARD_SOCKET_HANDLE  hSocket;     // @field Socket to be associated with the window
        UINT16              fAttributes;             // @field Bit encoded window attributes
        UINT32              uWindowSize;             // @field Desired window size in bytes
        UINT8               fAccessSpeed;            // @field Bit encoded memory access speed
    } CARD_WINDOW_PARMS, * PCARD_WINDOW_PARMS;

    typedef struct _CARD_WINDOW_ADDRESS
    {
        CARD_SOCKET_HANDLE  hSocket;     // @field Socket to be associated with the window
        UINT32              uCardAddress;            // Input & Output: Input:Address in this window, Output: Offset from uWindowPhAddress.
        UINT32              uSize;                   // Input & Output: Input:requested size for this window. Output: adjusted size to cover the requested window
        UINT32              uWindowPhAddr;           // Output: Physical Address this window Mapped to.
        UINT32              uGranularity;            // Output: This address granularity.
        UINT16              fAttributes;             // @field Bit encoded window attributes
        UINT8               fAccessSpeed;            // @field Bit encoded memory access speed
        UINT8               Reserved;                // Packed to 32-bit aligment
    } CARD_WINDOW_ADDRESS, * PCARD_WINDOW_ADDRESS ;
    //*****************************************************************
    // Configuration packet structures.
    //****************************************************************

    //
    // CARD_CONFIG_INFO.fAttributes
    //
#define CFG_ATTR_EXCLUSIVE    0x0001
#define CFG_ATTR_IRQ_STEERING 0x0002    // Enable interrupts from PC card to host
#define CFG_ATTR_IRQ_WAKEUP   0x0004    // Allow PCMCIA ints to wake system from
    // suspend mode. 
#define CFG_ATTR_KEEP_POWERED 0x0008    // Keep the PCMCIA bus powered while the
    // system is in the suspended state.
#define CFG_ATTR_NO_SUSPEND_UNLOAD 0x0010    // Do not unload the driver when returning from suspend
    // If possible
#define CFG_ATTR_ENABLE_DMA   0x0040
#define CFG_ATTR_VALID_CLIENT 0x0100    
#define CFG_ATTR_VS_OVERRIDE  0x0200
#define CFG_ATTR_NO_IO_IS_8   0x0400

    //
    // CARD_CONFIG_INFO.fInterfaceType
    // (PDCARD_SOCKET_STATE.fInterfaceType)
    //
#define CFG_IFACE_MEMORY    0x0001  // Put socket controller in memory only interface mode
#define CFG_IFACE_MEMORY_IO 0x0002  // Put socket controller in memory and I/O interface mode

    //
    // CARD_CONFIG_INFO.fRegisters
    //
    // Each of these bits indicates the presence one of the standard function and
    // configuration registers in the attribute space of the PC card.  Using the API
    // CardRequestConfiguration, a driver can set these registers to desired initial
    // values.  The fRegisters field indicates which registers to write.
    //
#define CFG_REGISTER_CONFIG   0x01  // Configuration Option Register (uConfigReg)
#define CFG_REGISTER_STATUS   0x02  // Function Configuration and Status Register (uStatusReg)
#define CFG_REGISTER_PIN      0x04  // Pin Replacement Register (uPinReg)
#define CFG_REGISTER_COPY     0x08  // Socket and Copy Register (uCopyReg)
#define CFG_REGISTER_EXSTATUS 0x10  // Extended Status register (uExtendedStatus)
#define CFG_REGISTER_EXREG    0x20  // Extended registers present

    // Extended register presence bits

#define CFG_EXREGISTER_IOBASE0      0x0001
#define CFG_EXREGISTER_IOBASE1      0x0002
#define CFG_EXREGISTER_IOBASE2      0x0004
#define CFG_EXREGISTER_IOBASE3      0x0008
#define CFG_EXREGISTER_IOLIMIT      0x0010

    //
    // @struct CARD_CONFIG_INFO | Structure used to indicate desired PC card configuration parameters
    //                            to the <f CardRequestConfiguration> API
    //  
    typedef struct _CARD_CONFIG_INFO
    {
        CARD_SOCKET_HANDLE  hSocket;// @field Logical socket (socket/function)
        UINT16              fAttributes;         // @field Bit encoded socket attributes
        UINT8               fInterfaceType;      // @field Bit encoded PC card interface type (memory or I/O)
        UINT8               uVcc;                // @field Vcc voltage to use
        UINT8               uVpp1;               // @field Vpp1 voltage to use
        UINT8               uVpp2;               // @field Vpp2 voltage to use
        UINT8               fRegisters;          // @field Register presence mask
        UINT8               uConfigReg;          // @field Initial value to write to the configuration option register
        UINT8               uStatusReg;          // @field Initial value to write to the function status register
        UINT8               uPinReg;             // @field Initial value to write to the pin replacement register
        UINT8               uCopyReg;            // @field Initial value to write to the socket and copy register
        UINT8               uExtendedStatus;     // @field Initial value to write to the extended status register
        UINT16              fExtRegisters;       // @field Extended register presence mask
        UINT8               IOBase[4];           // @field Initial value to write to the I/O Base registers
        UINT8               IOLimit;             // @field Initial value to write to the I/O Limit register
    } CARD_CONFIG_INFO, * PCARD_CONFIG_INFO;

    //
    // Function Configuration Register offsets
    //
#define FCR_OFFSET_COR   0   // Configuration Option Register
#define FCR_OFFSET_FCSR  1   // Function and Configuration Status Register
#define FCR_OFFSET_PRR   2   // Pin Replacement Register
#define FCR_OFFSET_SCR   3   // Socket and Copy Register
#define FCR_OFFSET_ESR   4   // Extended Status Register
#define FCR_OFFSET_IOB0  5   // I/O Base Register 0
#define FCR_OFFSET_IOB1  6   // I/O Base Register 1
#define FCR_OFFSET_IOB2  7   // I/O Base Register 2
#define FCR_OFFSET_IOB3  8   // I/O Base Register 3
#define FCR_OFFSET_IOSZ  9   // I/O Size Register

    //
    // Configuration Option Register Bit Masks
    // CARD_CONFIG_INFO.uConfigReg
    //
    // Note: The lower 6 bits of the configuration option register are used to
    //       specify which configuration number to use for single function cards.
    //
#define FCR_COR_LEVEL_IREQ  0x40    // 1 = level mode interrupts, 0 = pulse mode
#define FCR_COR_SRESET      0x80    // 1 = soft reset

    //
    // Function and Configuration Status Register Bit Masks
    // CARD_CONFIG_INFO.uStatusReg
    //
#define FCR_FCSR_INTR_ACK   0x01    // interrupt acknowledge
#define FCR_FCSR_INTR       0x02    // interrupt pending
#define FCR_FCSR_PWR_DOWN   0x04    // place PC card in power down mode
#define FCR_FCSR_AUDIO      0x08    // enable audio signal on BVD2 (pin 62)
#define FCR_FCSR_IO_IS_8    0x20    // used by host to indicate 8 bit only I/O
#define FCR_FCSR_STSCHG     0x40    // Enable status change (STSCHG, pin 63) from PC card
#define FCR_FCSR_CHANGED    0x80    // Set if one of the status changed bits is set in
    // the pin replacement register.

#define FCR_FCSR_REQUIRED_BITS (FCR_FCSR_INTR_ACK|FCR_FCSR_IO_IS_8)

    //
    // CARD_CONFIG_INFO.uPinReg
    //
#define FCR_PRR_RWP         0x01    // Current state of write protect
#define FCR_PRR_RREADY      0x02    // Current state of Ready
#define FCR_PRR_RBVD2       0x04    // Current state of BV2
#define FCR_PRR_RBVD1       0x08    // Current state of BV1
#define FCR_PRR_CWP         0x10    // Write protect changed
#define FCR_PRR_CRDY        0x20    // Ready changed
#define FCR_PRR_CBVD2       0x40    // BVD2 changed
#define FCR_PRR_CBVD1       0x80    // BVD1 changed


    //
    //  Used for CardAccessConfigurationRegister function
    //
#define CARD_FCR_READ  0
#define CARD_FCR_WRITE 1

    //*****************************************************************
    // CardGetStatus structure
    //*****************************************************************

    //
    // @struct CARD_STATUS | Structure used by <f CardGetStatus>
    //
    typedef struct _CARD_STATUS
    {
        CARD_SOCKET_HANDLE  hSocket;    // @field Logical socket (socket/function)
        UINT16              fCardState;             // @field current card state
        UINT16              fSocketState;           // @field changed socket state
    } CARD_STATUS, * PCARD_STATUS;


    //*****************************************************************
    // Tuple request structures.
    // NOTE:
    //         - The tuple flags structure is only used internally by card
    //           services and is defined as required by an implementation.
    //         - A variable length tuple data area immediately follows
    //           the tuple data packet structure.
    //****************************************************************

    //
    // CARD_TUPLE_PARMS.fAttributes
    // CARD_DATA_PARMS.fAttributes
    //
#define TUPLE_RETURN_LINKS  0x0001   // return link tuples

    //
    // @struct CARD_TUPLE_PARMS | Structure passed to <f CardGetFirstTuple> and used in
    //                            subsequent calls to <f CardGetNextTuple>.
    //                            
    typedef struct _CARD_TUPLE_PARMS
    {
        CARD_SOCKET_HANDLE  hSocket;// @field Logical socket (socket/function)
        UINT16              fAttributes;         // @field First bit set means to return link tuples
        UINT8               uDesiredTuple;       // @field Tuple code of desired tuple or 0xFF for any tuple
        UINT8               uReserved;           // @field Reserved (used to maintain alignment with CARD_DATA_PARMS)
        UINT16              fFlags;              // @field Used by Card Services, value must be preserved
        UINT32              uLinkOffset;         // @field Used by Card Services, value must be preserved
        UINT32              uCISOffset;          // @field Used by Card Services, value must be preserved
        UINT8               uTupleCode;          // @field Output: Tuple code found
        UINT8               uTupleLink;          // @field Output: Link field (length) of tuple found
    } CARD_TUPLE_PARMS, * PCARD_TUPLE_PARMS;

    //
    // @struct CARD_DATA_PARMS | Structure passed to <f CardGetTupleData>.  With care,
    //               one region of memory can be used as both a <t CARD_TUPLE_PARMS> and
    //               a CARD_DATA_PARMS structure.
    //
    typedef struct _CARD_DATA_PARMS
    {
        CARD_SOCKET_HANDLE  hSocket;// @field Logical socket (socket/function)
        UINT16              fAttributes;         // @field First bit set means to return link tuples
        UINT8               uDesiredTuple;       // @field Tuple code of desired tuple or 0xFF for any tuple
        UINT8               uTupleOffset;        // @field Offset in the current tuple to retrieve data
        UINT16              fFlags;              // @field Used by Card Services, value must be preserved
        UINT32              uLinkOffset;         // @field Used by Card Services, value must be preserved
        UINT32              uCISOffset;          // @field Used by Card Services, value must be preserved
        UINT16              uBufLen;             // @field Input: number of bytes following this CARD_DATA_PARMS structure
        UINT16              uDataLen;            // @field Output: number of bytes of data returned
    } CARD_DATA_PARMS, * PCARD_DATA_PARMS;

#define MAX_SOCKET_DESCRIPTOR_NAME 0x20
    typedef struct _SOCKET_DESCRIPTOR
    {
        DWORD   dwSocketIndex;
        WCHAR   sSocketName[MAX_SOCKET_DESCRIPTOR_NAME];
    } SOCKET_DESCRIPTOR, * PSOCKET_DESCRIPTOR;
    typedef struct _CARD_DESCRIPTOR
    {
        DWORD               dwSocketIndex;
        CARD_SOCKET_HANDLE  hCardHandle;
    } CARD_DESCRIPTOR, * PCARD_DESCRIPTOR;

#pragma pack()   // return packing to normal



    //
    // Card Services Function Prototypes
    //
    CARD_CLIENT_HANDLE CardRegisterClient( CLIENT_CALLBACK CallBackFn,
                                           PCARD_REGISTER_PARMS pParms );
    STATUS CardDeregisterClient( CARD_CLIENT_HANDLE hCardClient );


    STATUS CardGetFirstTuple( PCARD_TUPLE_PARMS pGetTupleParms );
    STATUS CardGetNextTuple( PCARD_TUPLE_PARMS pGetTupleParms );
    STATUS CardGetTupleData( PCARD_DATA_PARMS pGetTupleData );
    STATUS CardGetParsedTuple( CARD_SOCKET_HANDLE hSocket,
                               UINT8 uDesiredTuple,
                               PVOID pBuf,
                               PUINT32 pnItems );

    STATUS CardRequestExclusive( CARD_CLIENT_HANDLE hCardClient,
                                 CARD_SOCKET_HANDLE hSocket );
    STATUS CardReleaseExclusive( CARD_CLIENT_HANDLE hCardClient,
                                 CARD_SOCKET_HANDLE hSocket );
    STATUS CardRequestDisable( CARD_CLIENT_HANDLE hCardClient,
                               CARD_SOCKET_HANDLE hSocket );

    STATUS CardGetEventMask( CARD_CLIENT_HANDLE hCardClient,
                             PCARD_EVENT_MASK_PARMS pMaskParms );
    STATUS CardSetEventMask( CARD_CLIENT_HANDLE hCardClient,
                             PCARD_EVENT_MASK_PARMS pMaskParms );
    STATUS CardResetFunction( CARD_CLIENT_HANDLE hCardClient,
                              CARD_SOCKET_HANDLE hSock );

    CARD_WINDOW_HANDLE CardRequestWindow( CARD_CLIENT_HANDLE hCardClient,
                                          PCARD_WINDOW_PARMS pCardWinParms );
    STATUS CardReleaseWindow( CARD_WINDOW_HANDLE hCardWin );   
    STATUS CardModifyWindow( CARD_WINDOW_HANDLE hCardWindow,
                             UINT16 fAttributes,
                             UINT8 fAccessSpeed );
    PVOID CardMapWindow( CARD_WINDOW_HANDLE hCardWindow,
                         UINT32 uCardAddress,
                         UINT32 uSize,
                         PUINT32 pGranularity );
    STATUS CardMapWindowPhysical( CARD_WINDOW_HANDLE hCardWindow,
                                  PCARD_WINDOW_ADDRESS pCardWindowAddr ) ;

    STATUS CardGetStatus( PCARD_STATUS pStatus );

    STATUS CardRequestConfiguration( CARD_CLIENT_HANDLE hCardClient,
                                     PCARD_CONFIG_INFO pParms );
    STATUS CardModifyConfiguration( CARD_CLIENT_HANDLE hCardClient,
                                    CARD_SOCKET_HANDLE hSock,
                                    PUINT16 fAttributes );
    STATUS CardReleaseConfiguration( CARD_CLIENT_HANDLE hCardClient,
                                     CARD_SOCKET_HANDLE hSock );

    STATUS CardRequestConfigRegisterPhAddr( CARD_CLIENT_HANDLE hCardClient,
                                            CARD_SOCKET_HANDLE hSock,
                                            PCARD_WINDOW_ADDRESS pCardWindowAddr,
                                            PDWORD pOffset );
    STATUS CardAccessConfigurationRegister( CARD_CLIENT_HANDLE hCardClient,
                                            CARD_SOCKET_HANDLE hSock,
                                            UINT8 rw_flag,
                                            UINT8 offset,
                                            UINT8* pValue );
    // Only Support By Lagacy Driver
    STATUS CardRequestIRQ( CARD_CLIENT_HANDLE hCardClient,
                           CARD_SOCKET_HANDLE hSocket,
                           CARD_ISR ISRFunction,
                           UINT32 uISRContextData );
    STATUS CardReleaseIRQ( CARD_CLIENT_HANDLE hCardClient,
                           CARD_SOCKET_HANDLE hSocket );
    // Useless Function.
    //STATUS CardPowerOn(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSock);
    //STATUS CardPowerOff(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSock);

    STATUS CardRequestIRQLine( CARD_CLIENT_HANDLE hCardClient,
                               CARD_SOCKET_HANDLE hSocket,
                               UINT16 uSupportedIrqBit,
                               PDWORD pdwIrqOrSysIntrNumber,
                               PDWORD pdwIsSysIntr );


    STATUS CardPowerOff( CARD_CLIENT_HANDLE hCardClient,
                         CARD_SOCKET_HANDLE hSock );
    STATUS CardPowerOn( CARD_CLIENT_HANDLE hCardClient,
                        CARD_SOCKET_HANDLE hSock );
    STATUS CardRequestSocketMask( CARD_CLIENT_HANDLE hCardClient,
                                  CARD_SOCKET_HANDLE hSock,
                                  UINT16 fEventMask ); 
    STATUS CardReleaseSocketMask( CARD_CLIENT_HANDLE hCardClient,
                                  CARD_SOCKET_HANDLE hSock );

    //Extension Function for Control Panel
    STATUS EnumSocket( PDWORD pdwNumOfStructure,
                       PSOCKET_DESCRIPTOR pSocketDescriptorArray,
                       PDWORD pdwNumOfStructureCopied );
    STATUS EnumCard( PDWORD pdwNumOfStructure,
                     PCARD_DESCRIPTOR pCardDescriptorArray,
                     PDWORD pdwNumOfStructureCopied );
    STATUS GetSocketStatus( DWORD dwSocketIndex, PDWORD pdwStatus );
    STATUS GetSocketIndex( CARD_SOCKET_HANDLE hSocket, PDWORD pdwSocketIndex );

    // Exposed Function Type
    typedef CARD_CLIENT_HANDLE ( WINAPI * PFN_CardRegisterClient )( CLIENT_CALLBACK CallBackFn,
                                                                    PCARD_REGISTER_PARMS pParms );
    typedef STATUS ( WINAPI * PFN_CardDeregisterClient )( CARD_CLIENT_HANDLE hCardClient );


    typedef STATUS ( WINAPI *PFN_CardGetFirstTuple )( PCARD_TUPLE_PARMS pGetTupleParms );
    typedef STATUS ( WINAPI *PFN_CardGetNextTuple )( PCARD_TUPLE_PARMS pGetTupleParms );
    typedef STATUS ( WINAPI *PFN_CardGetTupleData )( PCARD_DATA_PARMS pGetTupleData );
    typedef STATUS ( WINAPI *PFN_CardGetParsedTuple )( CARD_SOCKET_HANDLE hSocket,
                                                       UINT8 uDesiredTuple,
                                                       PVOID pBuf,
                                                       PUINT32 pnItems );

    typedef STATUS ( WINAPI *PFN_CardRequestExclusive )( CARD_CLIENT_HANDLE hCardClient,
                                                         CARD_SOCKET_HANDLE hSocket );
    typedef STATUS ( WINAPI *PFN_CardReleaseExclusive )( CARD_CLIENT_HANDLE hCardClient,
                                                         CARD_SOCKET_HANDLE hSocket );
    typedef STATUS ( WINAPI *PFN_CardRequestDisable )( CARD_CLIENT_HANDLE hCardClient,
                                                       CARD_SOCKET_HANDLE hSocket );

    typedef STATUS ( WINAPI *PFN_CardGetEventMask )( CARD_CLIENT_HANDLE hCardClient,
                                                     PCARD_EVENT_MASK_PARMS pMaskParms );
    typedef STATUS ( WINAPI *PFN_CardSetEventMask )( CARD_CLIENT_HANDLE hCardClient,
                                                     PCARD_EVENT_MASK_PARMS pMaskParms );
    typedef STATUS ( WINAPI *PFN_CardResetFunction )( CARD_CLIENT_HANDLE hCardClient,
                                                      CARD_SOCKET_HANDLE hSock );

    typedef CARD_WINDOW_HANDLE ( WINAPI *PFN_CardRequestWindow )( CARD_CLIENT_HANDLE hCardClient,
                                                                  PCARD_WINDOW_PARMS pCardWinParms );
    typedef STATUS ( WINAPI *PFN_CardReleaseWindow )( CARD_WINDOW_HANDLE hCardWin );   
    typedef STATUS ( WINAPI *PFN_CardModifyWindow )( CARD_WINDOW_HANDLE hCardWindow,
                                                     UINT16 fAttributes,
                                                     UINT8 fAccessSpeed );
    typedef PVOID ( WINAPI *PFN_CardMapWindow )( CARD_WINDOW_HANDLE hCardWindow,
                                                 UINT32 uCardAddress,
                                                 UINT32 uSize,
                                                 PUINT32 pGranularity );
    typedef STATUS ( WINAPI *PFN_CardMapWindowPhysical )( CARD_WINDOW_HANDLE hCardWindow,
                                                          PCARD_WINDOW_ADDRESS pCardWindowAddr ) ;

    typedef STATUS ( WINAPI *PFN_CardGetStatus )( PCARD_STATUS pStatus );

    typedef STATUS ( WINAPI *PFN_CardRequestConfiguration )( CARD_CLIENT_HANDLE hCardClient,
                                                             PCARD_CONFIG_INFO pParms );
    typedef STATUS ( WINAPI *PFN_CardModifyConfiguration )( CARD_CLIENT_HANDLE hCardClient,
                                                            CARD_SOCKET_HANDLE hSock,
                                                            PUINT16 fAttributes );
    typedef STATUS ( WINAPI *PFN_CardReleaseConfiguration )( CARD_CLIENT_HANDLE hCardClient,
                                                             CARD_SOCKET_HANDLE hSock );
    typedef STATUS ( WINAPI *PFN_CardRequestConfigRegisterPhAddr )( CARD_CLIENT_HANDLE hCardClient,
                                                                    CARD_SOCKET_HANDLE hSock,
                                                                    PCARD_WINDOW_ADDRESS pCardWindowAddr,
                                                                    PDWORD pOffset );
    typedef STATUS ( WINAPI *PFN_CardAccessConfigurationRegister )( CARD_CLIENT_HANDLE hCardClient,
                                                                    CARD_SOCKET_HANDLE hSock,
                                                                    UINT8 rw_flag,
                                                                    UINT8 offset,
                                                                    UINT8* pValue );
    // Only Support By Lagacy Driver
    typedef STATUS ( WINAPI *PFN_CardRequestIRQ )( CARD_CLIENT_HANDLE hCardClient,
                                                   CARD_SOCKET_HANDLE hSocket,
                                                   CARD_ISR ISRFunction,
                                                   UINT32 uISRContextData );
    typedef STATUS ( WINAPI *PFN_CardReleaseIRQ )( CARD_CLIENT_HANDLE hCardClient,
                                                   CARD_SOCKET_HANDLE hSocket );
    // Useless Function.
    //STATUS CardPowerOn(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSock);
    //STATUS CardPowerOff(CARD_CLIENT_HANDLE hCardClient, CARD_SOCKET_HANDLE hSock);

    typedef STATUS ( WINAPI *PFN_CardRequestIRQLine )( CARD_CLIENT_HANDLE hCardClient,
                                                       CARD_SOCKET_HANDLE hSocket,
                                                       UINT16 uSupportedIrqBit,
                                                       PDWORD pdwIrqOrSysIntrNumber,
                                                       PDWORD pdwIsSysIntr );

    typedef STATUS ( WINAPI *PFN_CardPowerOff )( CARD_CLIENT_HANDLE hCardClient,
                                                 CARD_SOCKET_HANDLE hSock );
    typedef STATUS ( WINAPI *PFN_CardPowerOn )( CARD_CLIENT_HANDLE hCardClient,
                                                CARD_SOCKET_HANDLE hSock );
    typedef STATUS ( WINAPI *PFN_CardRequestSocketMask )( CARD_CLIENT_HANDLE hCardClient,
                                                          CARD_SOCKET_HANDLE hSock,
                                                          UINT16 fEventMask ); 
    typedef STATUS ( WINAPI *PFN_CardReleaseSocketMask )( CARD_CLIENT_HANDLE hCardClient,
                                                          CARD_SOCKET_HANDLE hSock );

    //Extension Function for Control Panel
    typedef STATUS ( WINAPI *PFN_EnumSocket )( PDWORD pdwNumOfStructure,
                                               PSOCKET_DESCRIPTOR pSocketDescriptorArray,
                                               PDWORD pdwNumOfStructureCopied );
    typedef STATUS ( WINAPI *PFN_EnumCard )( PDWORD pdwNumOfStructure,
                                             PCARD_DESCRIPTOR pCardDescriptorArray,
                                             PDWORD pdwNumOfStructureCopied );
    typedef STATUS ( WINAPI *PFN_GetSocketStatus )( DWORD dwSocketIndex,
                                                    PDWORD pdwStatus );
    typedef STATUS ( WINAPI *PFN_GetSocketIndex )( CARD_SOCKET_HANDLE hSocket,
                                                   PDWORD pdwSocketIndex );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ccpselect.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma once

// actions sent with the WM_SELECTION message indicating what action the Selection Facilitator would like the control 
// to perform.
enum SELECTION_ACTION
{
    SELECTION_ACTION_DISABLE = 0,
    SELECTION_ACTION_ENABLE,
    SELECTION_ACTION_SETANCHOR,
    SELECTION_ACTION_SELECTALL,
    SELECTION_ACTION_UNSELECT
};

// notification/state of selection.  sent by the control when selection mode is updated or ended
enum SELECTION_STATE
{
    SELECTION_STATE_CANCELLED,
    SELECTION_STATE_ANCHORNOTSET,
    SELECTION_STATE_ANCHORSET,
    SELECTION_STATE_COPIED,
    SELECTION_STATE_CUT, 
    SELECTION_STATE_DELETED
};



// handle to the selection facilitator
DECLARE_HANDLE(HCCP);


extern "C"
{
/// <summary>
/// Entry point to Selection Mode.  Used by an application to allow the user to select content from a control.
/// </summary>
/// <param name="hwndMenuOwner">handle to the application's main window that is currently in view and owns the softkey bar</param>
/// <param name="hwndSelection">handle to the control that is to be put into a selection context</param>
/// <param name="pssResult">result of selection mode.  Can be NULL</param>
/// <returns>
/// </returns>
/// <remarks>
/// </remarks>
HRESULT WINAPI EnterSelectMode(HWND hwndMenuOwner, HWND hwndSelection, __out SELECTION_STATE* pss);

/// <summary>
/// API used to report back to the Selection facilitator an updated selection status
/// </summary>
/// <param name="hccp">handle to the selection facilitator</param>
/// <param name="hwndSender">control that is sending the update</param>
/// <param name="ss">notification to give the faciliator</param>
/// <returns>
/// </returns>
/// <remarks>
/// </remarks>
HRESULT WINAPI UpdateSelectionState(HCCP hccp, HWND hwndControl, SELECTION_STATE ss);

/// <summary>
/// API used to exit selection mode and report the reason why
/// </summary>
/// <param name="hccp">handle to the selection facilitator</param>
/// <param name="hwndSender">control that is sending the update</param>
/// <param name="ss">reason for exiting</param>
/// <returns>
/// </returns>
/// <remarks>
/// </remarks>
HRESULT WINAPI EndSelection(HCCP hccp, HWND hwndControl, SELECTION_STATE ss);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cebus.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// Module Name:  
//     CEBUS.h
// 
// Abstract: Provides Liberary for Bus Access.
// 
// Notes: 
//
#ifndef __CEBUS_H_
#define __CEBUS_H_
#include <ceddk.h>
#include <pm.h>

#define _BUSACCESS_CTL_CODE(_Function)  \
            CTL_CODE(FILE_DEVICE_BUS_EXTENDER, _Function, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_BUS_TRANSLATE_BUS_ADDRESS _BUSACCESS_CTL_CODE(1)
#define IOCTL_BUS_TRANSLATE_SYSTEM_ADDRESS _BUSACCESS_CTL_CODE(2)

#define IOCTL_BUS_GET_POWER_STATE   _BUSACCESS_CTL_CODE(3)
#define IOCTL_BUS_SET_POWER_STATE   _BUSACCESS_CTL_CODE(4)


#define IOCTL_BUS_GET_CONFIGURE_DATA    _BUSACCESS_CTL_CODE(5)
#define IOCTL_BUS_SET_CONFIGURE_DATA    _BUSACCESS_CTL_CODE(6)

#define IOCTL_BUS_ACTIVATE_CHILD    _BUSACCESS_CTL_CODE(16)
#define IOCTL_BUS_DEACTIVATE_CHILD  _BUSACCESS_CTL_CODE(17)
#define IOCTL_BUS_POSTINIT          _BUSACCESS_CTL_CODE(18)
#define IOCTL_BUS_ENABLE_CHILD      _BUSACCESS_CTL_CODE(19)
#define IOCTL_BUS_DISABLE_CHILD     _BUSACCESS_CTL_CODE(20)
#define IOCTL_BUS_IS_CHILD_ENABLE   _BUSACCESS_CTL_CODE(21)

#define IOCTL_BUS_IS_CHILD_REMOVED   _BUSACCESS_CTL_CODE(32)
#define IOCTL_BUS_NAME_PREFIX _BUSACCESS_CTL_CODE(33)

#define IOCTL_BUS_OEM_EXTENDER  0x800

typedef struct _CEDDK_BUS_POWER_STATE {
    CEDEVICE_POWER_STATE DevicePowerState;
    PVOID  lpReserved; // THis is reserved for future.
} CEDDK_BUS_POWER_STATE, *PCEDDK_BUS_POWER_STATE;

// Structure for Translate Bus Address.
typedef struct _CEDDK_BUS_TRANSLATE_BUS_ADDR {
    INTERFACE_TYPE  InterfaceType;
    ULONG BusNumber;
    PHYSICAL_ADDRESS BusAddress;
    ULONG AddressSpace;
    PHYSICAL_ADDRESS TranslatedAddress;
} CEDDK_BUS_TRANSLATE_BUS_ADDR,*PCEDDK_BUS_TRANSLATE_BUS_ADDR;

typedef struct _CEDDK_BUS_TRANSLATE_SYSTEM_ADDR {
    INTERFACE_TYPE  InterfaceType;
    ULONG BusNumber;
    PHYSICAL_ADDRESS SystemAddress;
    PHYSICAL_ADDRESS TranslatedAddress;
} CEDDK_BUS_TRANSLATE_SYSTEM_ADDR,*PCEDDK_BUS_TRANSLATE_SYSTEM_ADDR;

typedef struct _CEDDK_BUS_DEVICE_CONFIGURATION_DATA {
    DWORD dwSpace;
    DWORD dwOffset;
    DWORD dwLength;
    BYTE pBuffer[1];
} CEDDK_BUS_DEVICE_CONFIGURATION_DATA,*PCEDDK_BUS_DEVICE_CONFIGURATION_DATA ;

// Bus Extention for USB OTG
#define BUS_USBOTG_EXTENTION_FUNCTIONCODE 0x100
#define BUS_USBOTG_EXTENTION_FUNCTIONCODE_SIZE 0x40
#define IOCTL_BUS_USBOTG_BEGIN _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE)
#define IOCTL_BUS_USBOTG_END   _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE+BUS_USBOTG_EXTENTION_FUNCTIONCODE_SIZE-1)
// Bus Extention for SD
#define BUS_SD_EXTENTION_FUNCTIONCODE 0x140
#define BUS_SD_EXTENTION_FUNCTIONCODE_SIZE 0x40
#define IOCTL_BUS_SD_BEGIN _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE)
#define IOCTL_BUS_SD_END   _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+BUS_SD_EXTENTION_FUNCTIONCODE_SIZE-1)
// USBD Extension code
#define BUS_USBD_EXTENTION_FUNCTIONCODE 0x180
#define BUS_USBD_EXTENTION_FUNCTIONCODE_SIZE 0x40
#define IOCTL_BUS_USBD_BEGIN _BUSACCESS_CTL_CODE(BUS_USBD_EXTENTION_FUNCTIONCODE)
#define IOCTL_BUS_USBD_END   _BUSACCESS_CTL_CODE(BUS_USBD_EXTENTION_FUNCTIONCODE+BUS_USBD_EXTENTION_FUNCTIONCODE_SIZE-1)

// USBD Extension code
#define BUS_SERVICES_EXTENTION_FUNCTIONCODE 0x1C0
#define BUS_SERVICES_EXTENTION_FUNCTIONCODE_SIZE 0x40
#define IOCTL_BUS_SERVICES_BEGIN _BUSACCESS_CTL_CODE(BUS_SERVICES_EXTENTION_FUNCTIONCODE)
#define IOCTL_BUS_SERVICES_END   _BUSACCESS_CTL_CODE(BUS_SERVICES_EXTENTION_FUNCTIONCODE+BUS_SERVICES_EXTENTION_FUNCTIONCODE_SIZE-1)
/* define in PKFuncs.h
#define _REFLECTORACCESS_CTL_CODE(_Function)  \
            CTL_CODE(FILE_DEVICE_REFLECTOR, _Function, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_REF_INTERRUPT_INITIALIZE _REFLECTORACCESS_CTL_CODE(1)
typedef struct _REF_INTERRUPT_INTIALIZE_PARAM {
    DWORD   idInt;
    HANDLE  hEvent;
    LPVOID  pvData;
    DWORD   cbData;
} REF_INTERRUPTINITIALIZE_PARAM, *PREF_INTERRUPTINITIALIZE_PARAM ;

#define IOCTL_REF_INTERRUPT_DONE _REFLECTORACCESS_CTL_CODE(2)
// dwSysIntr only.

#define IOCTL_REF_INTERRUPT_DISABLE _REFLECTORACCESS_CTL_CODE(3)
// dwSysIntr only

#define IOCTL_REF_INTERRUPT_MASK _REFLECTORACCESS_CTL_CODE(4)
typedef struct _REF_INTERRUPT_MASK_PARAM {
    DWORD idInt;
    BOOL fDisable;
} REF_INTERRUPT_MASK_PARAM, *PREF_INTERRUPT_MASK_PARAM ;

#define IOCTL_REF_VIRTUAL_COPY _REFLECTORACCESS_CTL_CODE(5)
typedef struct _REF_VIRTUALCOPY_PARAM {
    LPVOID  lpvDest;
    LPVOID  lpvSrc;
    DWORD   cbSize;
    DWORD   fdwProtect;
} REF_VIRTUALCOPY_PARAM,*PREF_VIRTUALCOPY_PARAM;

#define IOCTL_REF_LOAD_INT_CHAIN_HANDLER _REFLECTORACCESS_CTL_CODE(6)
#define REF_DEVDLL_LEN 0x40
#define REF_DEVENTRY_LEN 0x40
typedef struct _REF_LOAD_INT_CHAIN_HANDLER {
    TCHAR   szIISRDll[REF_DEVDLL_LEN];
    TCHAR   szIISREntry[REF_DEVENTRY_LEN];
    BYTE    bIRQ;
} REF_LOAD_INT_CHAIN_HANDLER, *PREF_LOAD_INT_CHAIN_HANDLER;
// Output is Handle.

#define IOCTL_REF_FREE_INT_CHAIN_HANDLER _REFLECTORACCESS_CTL_CODE(7)
// Input is Handle

#define IOCTL_REF_CREATE_STATIC_MAPPING _REFLECTORACCESS_CTL_CODE(8)
typedef struct _REF_CREATE_STATIC_MAPPING {
    DWORD   dwPhysBase;
    DWORD   dwSize;
} REF_CREATE_STATIC_MAPPING, *PREF_CREATE_STATIC_MAPPING;
// Output PVOID static addresss.
#define IOCTL_REF_INT_CHAIN_HANDLER_IOCONTROL _REFLECTORACCESS_CTL_CODE(9)
typedef struct _REF_INT_CHAIN_HANDLER_IOCONTROL {
    HANDLE  hLib;
    DWORD   dwIoControlCode;
    LPVOID  lpInBuf; // yes we use embedded pointer here.
    DWORD   nInBufSize;
} REF_INT_CHAIN_HANDLER_IOCONTROL, *PREF_INT_CHAIN_HANDLER_IOCONTROL;
// OUTPUT is IOCONTROL output buffer.
#define IOCTL_REF_CREATE_ASYNC_IO_HANDLE _REFLECTORACCESS_CTL_CODE(0xa)
// INPUT is NUNLL.
// OUTPUT is IOCONTROL output buffer.
typedef struct _REF_CREATE_ASYNC_IO_HANDLE {
    HANDLE  hIoRef;
    LPVOID  lpInBuf; // output value for async buffer.
    LPVOID  lpOutBuf; // outout value for async buffer.
} REF_CREATE_ASYNC_IO_HANDLE, *PREF_CREATE_ASYNC_IO_HANDLE;
*/
//  Beside Interupt function the MnMapFunction.
#define IOCTL_REF_MNMAPIOSPACE _REFLECTORACCESS_CTL_CODE(0x10)
typedef struct _REF_MNMAPIOSPACE_PARAM {
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG NumberOfBytes;
    BOOLEAN CacheEnable;
} REF_MNMAPIOSPACE_PARAM , *PREF_MNMAPIOSPACE_PARAM  ;

#define IOCTL_REF_MNUNMAPIOSPACE _REFLECTORACCESS_CTL_CODE(0x11)
typedef struct _REF_MNUNMAPIOSPACE_PARAM {
    PVOID BaseAddress;
    ULONG NumberOfBytes;
} REF_MNUNMAPIOSPACE_PARAM ,*PREF_MNUNMAPIOSPACE_PARAM ;

// CeDriverDuplicateCallerHandle
#define IOCTL_REF_DUPLCATE_HANDLE _REFLECTORACCESS_CTL_CODE(0x12)
typedef struct _REF_DUPLICATE_HANDLE_PARAM { // IN Put.
  HANDLE DirectCallerHandle;
  DWORD dwDesiredAccess;
  BOOL bInheritHandle; 
  DWORD dwOptions;
} REF_DUPLICATE_HANDLE_PARAM,*PREF_DUPLICATE_HANDLE_PARAM;
// OUTPUT Buffer is Handle.


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cebuscfg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// Module Name:  
//     cebuscfg.h
// 
// Abstract: Provides Liberary for Bus Access.
// 
// Notes: 
//
#ifndef __CEBUSCFG_H_
#define __CEBUSCFG_H_
// SpaceType.
// PCI
#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350
// PC Card.
#define    PCCARD_PCI_CONFIGURATION_SPACE    0  // for cardbus cards
#define    PCCARD_ATTRIBUTE_MEMORY           1
#define    PCCARD_COMMON_MEMORY              2
#define    PCCARD_ATTRIBUTE_MEMORY_INDIRECT  3
#define    PCCARD_COMMON_MEMORY_INDIRECT     4


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ceddk.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Module Name:

    ceddk.h

Abstract:

    This module defines the NT types, constants, and functions that are
    exposed to device drivers.

Revision History:

--*/
#pragma once

#ifndef _CEDDK_
#define _CEDDK_

#define NTKERNELAPI
#define NTHALAPI

#ifdef __cplusplus
extern "C" {
#endif

#include <ntstatus.h>
#ifdef _MAC
#include <macwin32.h>
#endif

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS; 

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
} INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;

//
// A PCI driver can read the complete 256 bytes of configuration
// information for any PCI device by calling:
//
//      ULONG
//      HalGetBusData (
//          __in BUS_DATA_TYPE        PCIConfiguration,
//          __in ULONG                PciBusNumber,
//          __in PCI_SLOT_NUMBER      VirtualSlotNumber,
//          __in PPCI_COMMON_CONFIG   &PCIDeviceConfig,
//          __in ULONG                sizeof (PCIDeviceConfig)
//      );
//
//      A return value of 0 means that the specified PCI bus does not exist.
//
//      A return value of 2, with a VendorID of PCI_INVALID_VENDORID means
//      that the PCI bus does exist, but there is no device at the specified
//      VirtualSlotNumber (PCI Device/Function number).
//
//

// begin_ntminiport begin_ntndis

//
// Disable level 4 warning "C4214: nonstandard extension used : bit field types other than int"
// for PCI_SLOT_NUMBER structure. 
//
#pragma warning( push )
#pragma warning( disable : 4214 )

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;

#pragma warning( pop )

#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             1

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            ULONG   Reserved2[2];

            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;

        struct _PCI_HEADER_TYPE_1 {
            ULONG   BaseAddresses[PCI_TYPE1_ADDRESSES];
            UCHAR   PrimaryBusNumber;
            UCHAR   SecondaryBusNumber;
            UCHAR   SubordinateBusNumber;
            UCHAR   SecondaryLatencyTimer;
            UCHAR   IOBase;
            UCHAR   IOLimit;
            USHORT  SecondaryStatus;
            USHORT  MemoryBase;
            USHORT  MemoryLimit;
            USHORT  PrefetchableMemoryBase;
            USHORT  PrefetchableMemoryLimit;
            ULONG   PrefetchableMemoryBaseUpper32;
            ULONG   PrefetchableMemoryLimitUpper32;
            USHORT  IOBaseUpper;
            USHORT  IOLimitUpper;
            ULONG   Reserved2;
            ULONG   ExpansionROMBase;
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type1;

        struct _PCI_HEADER_TYPE_2 {
            ULONG   BaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved2;
            USHORT  SecondaryStatus;
            UCHAR   PrimaryBusNumber;
            UCHAR   CardbusBusNumber;
            UCHAR   SubordinateBusNumber;
            UCHAR   CardbusLatencyTimer;
            ULONG   MemoryBase0;
            ULONG   MemoryLimit0;
            ULONG   MemoryBase1;
            ULONG   MemoryLimit1;
            USHORT  IOBase0_LO;
            USHORT  IOBase0_HI;
            USHORT  IOLimit0_LO;
            USHORT  IOLimit0_HI;
            USHORT  IOBase1_LO;
            USHORT  IOBase1_HI;
            USHORT  IOLimit1_LO;
            USHORT  IOLimit1_HI;
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   LegacyBaseAddress;
            UCHAR   Reserved3[56];
            ULONG   SystemControl;
            UCHAR   MultiMediaControl;
            UCHAR   GeneralStatus;
            UCHAR   Reserved4[2];
            UCHAR   GPIO0Control;
            UCHAR   GPIO1Control;
            UCHAR   GPIO2Control;
            UCHAR   GPIO3Control;
            ULONG   IRQMuxRouting;
            UCHAR   RetryStatus;
            UCHAR   CardControl;
            UCHAR   DeviceControl;
            UCHAR   Diagnostic;
        } type2;

    } u;

    UCHAR   DeviceSpecific[108];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_BUS                         255
#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8

#define PCI_INVALID_VENDORID                0xFFFF
#define PCI_INVALID_DEVICEID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_TYPE                    0x02

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04




//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_SPACE            0x00000000
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001

//
// ISA PnP Structures
//

typedef struct  _ISA_PNP_LOGICAL_DEVICE_INFO
{
    DWORD   LogicalDeviceID;
    DWORD   CompatibleIDs[8];
}   ISA_PNP_LOGICAL_DEVICE_INFO, *PISA_PNP_LOGICAL_DEVICE_INFO;

typedef struct  _ISA_PNP_CONFIG
{
    DWORD                           VendorID;
    DWORD                           SerialNumber;
    DWORD                           NumberLogicalDevices;
    ISA_PNP_LOGICAL_DEVICE_INFO     LogicalDeviceInfo[8];
}   ISA_PNP_CONFIG, *PISA_PNP_CONFIG;

typedef struct  _ISA_PNP_RESOURCES
{
    USHORT                          Flags;
    struct
    {
        USHORT      MemoryBase;
        USHORT      MemoryUpperLimit;
        UCHAR       MemoryControl;
    }                               Memory24Descriptors[4];
    struct
    {
        DWORD       MemoryBase;
        DWORD       MemoryUpperLimit;
        UCHAR       MemoryControl;
    }                               Memory32Descriptors[4];
    USHORT                          IoPortDescriptors[8];
    struct
    {
        UCHAR       IRQLevel;
        UCHAR       IRQType;
    }                               IRQDescriptors[2];
    UCHAR                           DMADescriptors[2];
}   ISA_PNP_RESOURCES, *PISA_PNP_RESOURCES;

#define ISA_PNP_RESOURCE_FLAG_ACTIVE    0x00000001

//++
//
// ULONG
// ROUND_TO_PAGES (
//     __in ULONG Size
//     )
//
// Routine Description:
//
//     The ROUND_TO_PAGES macro takes a size in bytes and rounds it up to a
//     multiple of the page size.
//
//     NOTE: This macro fails for values 0xFFFFFFFF - (PAGE_SIZE - 1).
//
// Arguments:
//
//     Size - Size in bytes to round up to a page multiple.
//
// Return Value:
//
//     Returns the size rounded up to a multiple of the page size.
//
//--

#define ROUND_TO_PAGES(Size)  (((ULONG)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

//++
//
// ULONG
// BYTES_TO_PAGES (
//     __in ULONG Size
//     )
//
// Routine Description:
//
//     The BYTES_TO_PAGES macro takes the size in bytes and calculates the
//     number of pages required to contain the bytes.
//
// Arguments:
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages required to contain the specified size.
//
//--

#define BYTES_TO_PAGES(Size)  (((ULONG)(Size) >> PAGE_SHIFT) + \
                               (((ULONG)(Size) & (PAGE_SIZE - 1)) != 0))

//++
//
// ULONG
// BYTE_OFFSET (
//     __in PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET(Va) ((ULONG)(Va) & (PAGE_SIZE - 1))


//++
//
// PVOID
// PAGE_ALIGN (
//     __in PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN(Va) ((PVOID)((ULONG)(Va) & ~(PAGE_SIZE - 1)))


//++
//
// ULONG
// ADDRESS_AND_SIZE_TO_SPAN_PAGES (
//     __in PVOID Va,
//     __in ULONG Size
//     )
//
// Routine Description:
//
//     The ADDRESS_AND_SIZE_TO_SPAN_PAGES macro takes a virtual address and
//     size and returns the number of pages spanned by the size.
//
// Arguments:
//
//     Va - Virtual address.
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages spanned by the size.
//
// Notes:
//
//     Do not call with a Size of zero, since it sometimes will return 1
//     instead of 0 for the number of pages.
//
//--

#define COMPUTE_PAGES_SPANNED(Va, Size) \
    ((((ULONG)(Va) & (PAGE_SIZE - 1)) + (Size) + (PAGE_SIZE - 1)) >> PAGE_SHIFT)

#define ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va, Size) \
   COMPUTE_PAGES_SPANNED((Va), (Size))



// OEM IOCTL codes for IOCTL_HAL_DDK_CALL calls.
//
#define IOCTL_HAL_SETBUSDATA    0x01
#define IOCTL_HAL_GETBUSDATA    0x02

// Used by HalSetBusDataByOffset & HalGetBusDataByOffset when calling OAL.
//
typedef struct  __BUSDATA_PARMS
{
    __in  DWORD Function;    // Which function (IOCTL_HAL_GETBUSDATA/SETBUSDATA)
    __out ULONG ReturnCode;  // Return code from the function
    __in  BUS_DATA_TYPE BusDataType;
    __in  ULONG BusNumber;
    __in  ULONG SlotNumber;
    __in  PVOID Buffer;
    __in  ULONG Offset;
    __in  ULONG Length;
} BUSDATA_PARMS, *PBUSDATA_PARMS;


NTKERNELAPI
PVOID
MmMapIoSpace (
    __in PHYSICAL_ADDRESS PhysicalAddress,
    __in ULONG NumberOfBytes,
    __in BOOLEAN CacheEnable
    );

NTKERNELAPI
VOID
MmUnmapIoSpace (
    __in PVOID BaseAddress,
    __in ULONG NumberOfBytes
    );

NTKERNELAPI
BOOL
TransBusAddrToVirtual(
    __in INTERFACE_TYPE InterfaceType,
    __in ULONG BusNumber,
    __in PHYSICAL_ADDRESS BusAddress,
    __in ULONG Length,
    __inout PULONG AddressSpace,
    __out PPVOID MappedAddress
    );

NTKERNELAPI
BOOL
TransBusAddrToStatic(
    __in INTERFACE_TYPE InterfaceType,
    __in ULONG BusNumber,
    __in PHYSICAL_ADDRESS BusAddress,
    __in ULONG Length,
    __inout PULONG AddressSpace,
    __out PPVOID MappedAddress
    );
    
//
// I/O driver configuration functions.
//

NTHALAPI
ULONG
HalGetBusDataByOffset(
    __in BUS_DATA_TYPE BusDataType,
    __in ULONG BusNumber,
    __in ULONG SlotNumber,
    __in PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
    );

ULONG __inline
HalGetBusData(
    __in BUS_DATA_TYPE BusDataType,
    __in ULONG BusNumber,
    __in ULONG SlotNumber,
    __in PVOID Buffer,
    __in ULONG Length
    )
{
    return HalGetBusDataByOffset(
        BusDataType, BusNumber, SlotNumber, Buffer, 0, Length);
}

NTHALAPI
ULONG
HalSetBusDataByOffset(
    __in BUS_DATA_TYPE BusDataType,
    __in ULONG BusNumber,
    __in ULONG SlotNumber,
    __in PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
    );

ULONG __inline
HalSetBusData(
    __in BUS_DATA_TYPE BusDataType,
    __in ULONG BusNumber,
    __in ULONG SlotNumber,
    __in PVOID Buffer,
    __in ULONG Length
    )
{
    return HalSetBusDataByOffset(
        BusDataType, BusNumber, SlotNumber, Buffer, 0, Length);
}

NTHALAPI
BOOLEAN
HalTranslateBusAddress(
    __in INTERFACE_TYPE  InterfaceType,
    __in ULONG BusNumber,
    __in PHYSICAL_ADDRESS BusAddress,
    __inout PULONG AddressSpace,
    __out PPHYSICAL_ADDRESS TranslatedAddress
    );

NTHALAPI
BOOLEAN
HalTranslateSystemAddress(
    __in  INTERFACE_TYPE    InterfaceType,
    __in  ULONG             BusNumber,
    __in  PHYSICAL_ADDRESS  SystemAddress,
    __out PPHYSICAL_ADDRESS TranslatedAddress
    );


//
// DMA Adapter Description
//
typedef struct _DMA_ADAPTER_OBJECT_
{
    USHORT ObjectSize;                  // Size of structure (versioning).
    INTERFACE_TYPE InterfaceType;       // Adapter bus interface.
    ULONG BusNumber;                    // Adapter bus number.
} DMA_ADAPTER_OBJECT, *PDMA_ADAPTER_OBJECT;

//
// DMA functions.
//
NTHALAPI
PVOID
HalAllocateCommonBuffer(
    __in  PDMA_ADAPTER_OBJECT       Adapter,
    __in  ULONG              Length,
    __out PPHYSICAL_ADDRESS  LogicalAddress,
    __in  BOOLEAN            CacheEnabled
    );

NTHALAPI
VOID
HalFreeCommonBuffer(
    __in PDMA_ADAPTER_OBJECT      Adapter,
    __in ULONG             Length,
    __in PHYSICAL_ADDRESS  LogicalAddress,
    __in PVOID             VirtualAddress,
    __in BOOLEAN           CacheEnabled
    );

//
// I/O space read and write macros.
//
//  These are implemented as functions in ceddk.dll, since only the platform
//  architect knows for sure how the peripherals are mapped to the chip.  An
//  appropriate DLL must then be written for each platform.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

// 
// Use inline/macro versions of these APIs only when (a) performance is critical and
// (b) the underlying platform supports their use.
//

#ifdef CEDDK_USEDDKMACRO

#include <ddkmacro.h>

#else       // CEDDK_USEDDKMACRO

NTKERNELAPI
UCHAR
READ_REGISTER_UCHAR(
    __in volatile const UCHAR * const Register
    );

NTKERNELAPI
USHORT
READ_REGISTER_USHORT(
    __in volatile const USHORT * const Register
    );

NTKERNELAPI
ULONG
READ_REGISTER_ULONG(
    __in volatile const ULONG * const  Register
    );

NTKERNELAPI
VOID
READ_REGISTER_BUFFER_UCHAR(
    __in volatile const UCHAR * const  Register,
    __out_ecount(Count) UCHAR *  Buffer,
    __in ULONG   Count
    );

NTKERNELAPI
VOID
READ_REGISTER_BUFFER_USHORT(
    __in volatile const USHORT * const Register,
    __out_ecount(Count) USHORT * Buffer,
    __in ULONG   Count
    );

NTKERNELAPI
VOID
READ_REGISTER_BUFFER_ULONG(
    __in volatile const ULONG * const  Register,
    __out_ecount(Count) ULONG *  Buffer,
    __in ULONG   Count
    );


NTKERNELAPI
VOID
WRITE_REGISTER_UCHAR(
    __in volatile UCHAR * const  Register,
    __in UCHAR const Value
    );

NTKERNELAPI
VOID
WRITE_REGISTER_USHORT(
    __in volatile USHORT * const Register,
    __in USHORT  const Value
    );

NTKERNELAPI
VOID
WRITE_REGISTER_ULONG(
    __in volatile ULONG * const  Register,
    __in ULONG   const Value
    );

NTKERNELAPI
VOID
WRITE_REGISTER_BUFFER_UCHAR(
    __in volatile UCHAR * const  Register,
    __in_ecount(Count) const UCHAR *  Buffer,
    __in ULONG   Count
    );

NTKERNELAPI
VOID
WRITE_REGISTER_BUFFER_USHORT(
    __in volatile USHORT * const Register,
    __in_ecount(Count) const USHORT * Buffer,
    __in ULONG   Count
    );

NTKERNELAPI
VOID
WRITE_REGISTER_BUFFER_ULONG(
    __in volatile ULONG * const  Register,
    __in_ecount(Count) const ULONG *  Buffer,
    __in ULONG   Count
    );

NTKERNELAPI
UCHAR
READ_PORT_UCHAR(
    __in volatile const UCHAR * const  Port
    );

NTKERNELAPI
USHORT
READ_PORT_USHORT(
    __in volatile const USHORT * const Port
    );

NTKERNELAPI
ULONG
READ_PORT_ULONG(
    __in volatile const ULONG * const  Port
    );

NTKERNELAPI
VOID
READ_PORT_BUFFER_UCHAR(
    __in volatile const UCHAR * const  Port,
    __out_ecount(Count) UCHAR *  Buffer,
    __in ULONG   Count
    );

NTKERNELAPI
VOID
READ_PORT_BUFFER_USHORT(
    __in volatile const USHORT * const Port,
    __out_ecount(Count) USHORT * Buffer,
    __in ULONG   Count
    );

NTKERNELAPI
VOID
READ_PORT_BUFFER_ULONG(
    __in volatile const ULONG * const  Port,
    __out_ecount(Count) ULONG *  Buffer,
    __in ULONG   Count
    );

NTKERNELAPI
VOID
WRITE_PORT_UCHAR(
    __in volatile UCHAR * const  Port,
    __in UCHAR   const Value
    );

NTKERNELAPI
VOID
WRITE_PORT_USHORT(
    __in volatile USHORT * const Port,
    __in USHORT  const Value
    );

NTKERNELAPI
VOID
WRITE_PORT_ULONG(
    __in volatile ULONG * const  Port,
    __in ULONG   const Value
    );

NTKERNELAPI
VOID
WRITE_PORT_BUFFER_UCHAR(
    __in volatile UCHAR * const  Port,
    __in_ecount(Count) const UCHAR *  Buffer,
    __in ULONG   Count
    );

NTKERNELAPI
VOID
WRITE_PORT_BUFFER_USHORT(
    __in volatile USHORT * const Port,
    __in_ecount(Count) const USHORT * Buffer,
    __in ULONG   Count
    );

NTKERNELAPI
VOID
WRITE_PORT_BUFFER_ULONG(
    __in volatile ULONG * const  Port,
    __in_ecount(Count) const ULONG *  Buffer,
    __in ULONG   Count
    );

#endif      // CEDDK_USEDDKMACRO

//
// Definitions for Stall Execution
//
extern HANDLE g_hCalibrateThread;

typedef  LONG  (*pRegCloseKey) (     HKEY     );
#ifdef UNICODE

typedef 
LONG
(*pRegCreateKeyEx) (
    __in HKEY hKey,
    __in LPCWSTR lpSubKey,
    __in DWORD Reserved,
    __in LPWSTR lpClass,
    __in DWORD dwOptions,
    __in REGSAM samDesired,
    __in LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __out PHKEY phkResult,
    __out LPDWORD lpdwDisposition
    );
#else
typedef 
LONG
(*pRegCreateKeyEx) (
    __in HKEY hKey,
    __in LPCSTR lpSubKey,
    __in DWORD Reserved,
    __in LPSTR lpClass,
    __in DWORD dwOptions,
    __in REGSAM samDesired,
    __in LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __out PHKEY phkResult,
    __out LPDWORD lpdwDisposition
    );
#endif // !UNICODE

#ifdef UNICODE
typedef 
LONG
 (*pRegQueryValueEx) (
    __in HKEY hKey,
    __in LPCWSTR lpValueName,
    __in LPDWORD lpReserved,
    __out LPDWORD lpType,
    __inout LPBYTE lpData,
    __inout LPDWORD lpcbData
    );
#else
typedef 
LONG
(*pRegQueryValueEx) (
    __in HKEY hKey,
    __in LPCSTR lpValueName,
    __in LPDWORD lpReserved,
    __out LPDWORD lpType,
    __inout LPBYTE lpData,
    __inout LPDWORD lpcbData
    );
#endif

#ifdef UNICODE
typedef 
LONG
(*pRegQueryValueEx) (
    __in HKEY hKey,
    __in LPCWSTR lpValueName,
    __in LPDWORD lpReserved,
    __out LPDWORD lpType,
    __inout LPBYTE lpData,
    __inout LPDWORD lpcbData
    );
#else
typedef 
LONG
(*pRegQueryValueEx) (
    __in HKEY hKey,
    __in LPCSTR lpValueName,
    __in LPDWORD lpReserved,
    __out LPDWORD lpType,
    __inout LPBYTE lpData,
    __inout LPDWORD lpcbData
    );
#endif

#ifdef UNICODE
typedef 
LONG
(*pRegSetValueEx) (
    __in HKEY hKey,
    __in LPCWSTR lpValueName,
    __in DWORD Reserved,
    __in DWORD dwType,
    __in CONST BYTE* lpData,
    __in DWORD cbData
    );
#else
typedef 
LONG
(*pRegSetValueEx) (
    __in HKEY hKey,
    __in LPCSTR lpValueName,
    __in DWORD Reserved,
    __in DWORD dwType,
    __in CONST BYTE* lpData,
    __in DWORD cbData
    );
#endif 

void
StallOneMicrosecond(void);

BOOL  
BeginCalibration (HKEY hKey);

void
CalibrateStallCounter(void);

void 
StallExecution (DWORD dwMicroSec);

#ifdef WINCEOEM
//------------------------------------------------------------------------------
// milli-second wait, use Sleep if possible
//
#include <pkfuncs.h>
#define MAX_STALL   (0x3fffffff/1000)
__inline void DDKDriverSleep (DWORD dwMilliSecond)
{
    if (IsInPwrHdlr ()) {
        DWORD dwMs;
        while (dwMilliSecond) {
            dwMs = (dwMilliSecond > MAX_STALL)? MAX_STALL : dwMilliSecond;
            StallExecution (dwMs * 1000);   // stall execution is in micro-second
            dwMilliSecond -= dwMs;
        }
    } else {
        Sleep (dwMilliSecond);
    }
}
#endif

#include <pm.h>
#include <CeBus.h>

#define PAGE_SIZE   VM_PAGE_SIZE
#define PAGE_SHIFT  VM_PAGE_SHIFT

HANDLE  CreateBusAccessHandle(__in LPCTSTR lpActiveRegPath);
VOID    CloseBusAccessHandle(__in_opt HANDLE hBusAccess);
BOOL    SetDevicePowerState(__in_opt HANDLE hBusAccess, __in CEDEVICE_POWER_STATE PowerState,__reserved PVOID pReserved);
BOOL    GetDevicePowerState(__in_opt HANDLE hBusAccess, __out PCEDEVICE_POWER_STATE pPowerState,__reserved PVOID pReserved);
BOOL    TranslateBusAddr(__in_opt HANDLE hBusAccess,
            __in INTERFACE_TYPE  InterfaceType,__in ULONG BusNumber,__in PHYSICAL_ADDRESS BusAddress,__inout PULONG AddressSpace,__out PPHYSICAL_ADDRESS TranslatedAddress );
BOOL    TranslateSystemAddr(__in_opt HANDLE hBusAccess,
            __in INTERFACE_TYPE  InterfaceType,__in ULONG BusNumber,__in PHYSICAL_ADDRESS SystemAddress,__out PPHYSICAL_ADDRESS TranslatedAddress );

ULONG   SetDeviceConfigurationData(__in_opt HANDLE hBusAccess,
            __in DWORD dwSpace,__in DWORD BusNumber,__in  DWORD SlotNumber,__in DWORD dwOffset, __in DWORD dwLength, __in_bcount(dwLength) PVOID pBuffer);
ULONG   GetDeviceConfigurationData(__in_opt HANDLE hBusAccess,
            __in DWORD dwSpace,__in DWORD BusNumber,__in DWORD SlotNumber,__in DWORD dwOffset,__in DWORD dwLength, __out_bcount(dwLength) PVOID pBuffer);
BOOL    GetParentDeviceInfo(__in_opt HANDLE hBusAccess,__out PDEVMGR_DEVICE_INFORMATION pDeviceInfo);
BOOL    GetChildDeviceRemoveState(__in_opt HANDLE hBusAccess, __out PDWORD lpdChildDeviceState);
BOOL    GetBusNamePrefix(__in_opt HANDLE hBusAccess, __out_ecount(dwSizeInCharacters) LPTSTR lpReturnStr,DWORD dwSizeInCharacters);
BOOL    BusTransBusAddrToVirtual( __in_opt HANDLE hBusAccess,__in INTERFACE_TYPE InterfaceType,__in ULONG BusNumber, __in PHYSICAL_ADDRESS BusAddress, __in ULONG Length,__inout PULONG AddressSpace, __out PPVOID MappedAddress);
BOOL    BusTransBusAddrToStatic(__in_opt HANDLE hBusAccess,__in INTERFACE_TYPE InterfaceType, __in ULONG BusNumber,__in PHYSICAL_ADDRESS BusAddress, __in ULONG Length, __inout PULONG AddressSpace, __out PPVOID MappedAddress);
BOOL    BusIoControl(__in_opt HANDLE hBusAccess,__in  DWORD dwIoControlCode, __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer, __in DWORD nInBufferSize, __out_bcount(nOutBufferSize) LPVOID lpOutBuffer,__in DWORD nOutBufferSize, __out LPDWORD lpBytesReturned,__in_opt LPOVERLAPPED lpOverlapped);
BOOL    BusChildIoControl(__in_opt HANDLE hBusAccess,__in DWORD dwIoControlCode, __out_bcount_opt (nBufferSize)LPVOID lpBuffer, __in DWORD  nBufferSize) ;

// Notification Function.
DWORD   CeDriverGetDirectCaller();
HANDLE  CeDriverDuplicateCallerHandle( 
  IN HANDLE DirectCallerHandle, 
  IN DWORD dwDesiredAccess, 
  IN BOOL bInheritHandle, 
  IN DWORD dwOptions
); 


typedef BOOL (WINAPI *LPNOTIFY_CALLBACK_ROUTINE)(
    DWORD dwIoControlCode, __inout_bcount_opt(nInBufSize)LPVOID lpInBuf, DWORD nInBufSize, __inout_bcount_opt(nOutBufSize) LPVOID lpOutBuf, DWORD nOutBufSize, __out_opt LPDWORD lpBytesReturned, __reserved LPOVERLAPPED lpOverlapped
);

HANDLE CeDriverMapCallbackFunction(
 IN LPNOTIFY_CALLBACK_ROUTINE lpCallback
) ;
BOOL CeDriverPerformCallback(
  IN HANDLE hCallback, DWORD dwIoControlCode, __inout_bcount_opt(nInBufSize)LPVOID lpInBuf, DWORD nInBufSize, __inout_bcount_opt(nOutBufSize) LPVOID lpOutBuf, DWORD nOutBufSize, __out_opt LPDWORD lpBytesReturned, __reserved LPOVERLAPPED lpOverlapped
);

///////////////////////////////////////////////////////////////////////////////
// DRIVERHELPER_POWER library
///////////////////////////////////////////////////////////////////////////////

typedef CEDEVICE_POWER_STATE (*PFN_SETPOWERLEVEL)( DWORD, CEDEVICE_POWER_STATE );
typedef void (*PFN_SETPOWERLEVELCALLBACK)( DWORD, CEDEVICE_POWER_STATE );

// lock mechanism initialization/cleanup
HANDLE DDKPwr_Initialize(__in PFN_SETPOWERLEVEL pSetPowerLevelFn,__in DWORD dwContext,__in BOOL fAbortOnPMRequests,__in DWORD dwTimeout );
void   DDKPwr_Deinitialize(__in HANDLE hPowerLock );

// power level lock acquire/release
HANDLE DDKPwr_RequestLevel(__in HANDLE hPowerLock,__in CEDEVICE_POWER_STATE dx );
void   DDKPwr_ReleaseLevel(__in HANDLE hPowerLock,__in HANDLE hLevelLock );

// power level get/set
CEDEVICE_POWER_STATE DDKPwr_GetDeviceLevel(__in HANDLE hPowerLock );
BOOL DDKPwr_SetDeviceLevel(__in HANDLE hPowerLock,__in CEDEVICE_POWER_STATE dx, __in PFN_SETPOWERLEVELCALLBACK pCallbackFn );

#ifdef __cplusplus
}
#endif // __cplusplus
#include <oaldma.h>

#endif // _CEDDK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cedma.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// Module Name:  
//     CEDMA.h
// 
// Abstract: Provides Liberary for DMA Access.
// 
// Notes: 
//



#ifndef __CEDMA_H_
#define __CEDMA_H_
#include <ceddk.h>
#include <pm.h>

#ifdef __cplusplus
extern "C" {
#endif

#define _CE_DMA_CTL_CODE(_Function)  \
            CTL_CODE(FILE_DEVICE_CE_DMA, _Function, METHOD_BUFFERED, FILE_ANY_ACCESS)

// DMAGetAdapter
#define IOCTL_CE_DMA_OALGETDMAADAPTER _CE_DMA_CTL_CODE(1)
//    IN PDEVICE_DMA_REQUIREMENT_INFO pDeviceDmaRequirementInfo, //  Device Description. It descript what is capable Adapt supported.
//    OUT PCE_DMA_ADAPTER pDmaAdapter


// DMAAllocateChannel
#define IOCTL_CE_DMA_ALLOCATECHANNEL _CE_DMA_CTL_CODE(2)
// IN
typedef struct _CE_DMA_OALALLOCADAPTERCHANNEL {
    IN CE_DMA_ADAPTER       DmaAdapter;
    IN ULONG                ulRequestedChannel;
    IN ULONG                ulAddressSpace;
    IN PHYSICAL_ADDRESS     phDeviceIoAddress;
} CE_DMA_OALALLOCADAPTERCHANNEL,*PCE_DMA_OALALLOCADAPTERCHANNEL;
// OUT  DMA CHANNEL HANDLE

//DMAFreeChannel
#define IOCTL_CE_DMA_FREEDMACHANNEL _CE_DMA_CTL_CODE(3)
// IN DMA CHANNEL HANDLE

//DMAIssueTransfer
#define IOCTL_CE_DMA_ISSUEDMATRANSFER _CE_DMA_CTL_CODE(4)
//IN 
typedef struct _CE_DMA_ISSUEDMATRANSFER {
  IN HANDLE hDmaChannel;
  IN DWORD  dwFlags;
  IN PHYSICAL_ADDRESS  SystemMemoryPhysicalAddress;
  IN PVOID CurrentVa;
  IN ULONG Length;
  IN HANDLE hNotifyHandle;
  IN PVOID NotifyContext1; IN PVOID NotifyContext2;
  IN PHYSICAL_ADDRESS  phOpDeviceIoAddress;
} CE_DMA_ISSUEDMATRANSFER, *PCE_DMA_ISSUEDMATRANSFER;
// OUT
// DMA_TRANSFER_HANDLE hDmaHandle,

//DMACancelTransfer
#define IOCTL_CE_DMA_OALCANCELDMATRANSFER _CE_DMA_CTL_CODE(5)
// IN DMA_TRANSFER_HANDLE

//DMACloseTransfer
#define IOCTL_CE_DMA_OALCLOSEDMATRANSFER _CE_DMA_CTL_CODE(6)
// IN DMA_TRANSFER_HANDLE

//DMAGetStatus
#define IOCTL_CE_DMA_GETDMASTATUS _CE_DMA_CTL_CODE(7)
// IN DMA_TRANSFER_HANDLE
// OUT
typedef struct _CE_DMA_GETDMASTATUS {
  OUT DWORD CompletedLength;
  OUT DWORD CompletionCode;
} CE_DMA_GETDMASTATUS ,*PCE_DMA_GETDMASTATUS ;

//DMAIssueRawTransfer
#define IOCTL_CE_DMA_ISSUERAWDMATRANSFER _CE_DMA_CTL_CODE(8)
typedef struct _CE_DMA_ISSUERAWDMATRANSFER {
  IN HANDLE hDmaChannel;
  IN PVOID lpInPtr;
  IN DWORD nInLen;
  IN HANDLE hNotifyHandle;
  IN PVOID NotifyContext1;PVOID NotifyContext2;
} CE_DMA_ISSUERAWDMATRANSFER, *PCE_DMA_ISSUERAWDMATRANSFER;
// OUT DMA_TRANSFER_HANDLE

//DMARawTransferControl
#define IOCTL_CE_DMA_RAWDMATRANSFERCTRL _CE_DMA_CTL_CODE(9)
typedef struct _CE_DMA_RAWDMATRANSFERCTRL {
  IN DMA_TRANSFER_HANDLE hDmaHandle;
  IN DWORD dwIoControl;
  IN PVOID lpInPtr;
  IN DWORD nInLen;
} CE_DMA_RAWDMATRANSFERCTRL, *PCE_DMA_RAWDMATRANSFERCTRL;
// OUT lpOutPtr with nOutLen

//HalAllocateCommonBuffer
#define IOCTL_CE_DMA_DMAALLOCBUFFER  _CE_DMA_CTL_CODE(0xa)
// IN
typedef struct _CE_DMA_DMAALLOCBUFFER_IN {
    CE_DMA_ADAPTER             Adapter;
    ULONG                   Length;
    IN  BOOLEAN             CacheEnabled;
} CE_DMA_DMAALLOCBUFFER_IN, *PCE_DMA_DMAALLOCBUFFER_IN ;
//
typedef struct _CE_DMA_DMAALLOCBUFFER_OUT {
    OUT PHYSICAL_ADDRESS    PhysicalAddress;
    OUT PVOID               VirtualAddress;
} CE_DMA_DMAALLOCBUFFER_OUT, *PCE_DMA_DMAALLOCBUFFER_OUT ;


//HalFreeCommonBuffer
#define IOCTL_CE_DMA_DMAFREEBUFFER  _CE_DMA_CTL_CODE(0xb)
typedef struct _CE_DMA_DMAFREEBUFFER {
    IN CE_DMA_ADAPTER      Adapter;
    IN ULONG            Length;
    IN PHYSICAL_ADDRESS LogicalAddress;
    IN PVOID            VirtualAddress;
    IN BOOLEAN          CacheEnabled;
} CE_DMA_DMAFREEBUFFER, *PCE_DMA_DMAFREEBUFFER ;


//DMAIssueMultiTransfer
#define IOCTL_CE_DMA_ISSUEMULTIDMATRANSFER _CE_DMA_CTL_CODE(0xc)
//IN 
typedef struct _CE_DMA_ISSUEMULTIDMATRANSFER {
  IN HANDLE hDmaChannel;
  IN DWORD  dwFlags;
  IN DWORD  dwNumOfTransfer;
  IN PCE_DMA_BUFFER_BLOCK pDmaBufferBlock;
  IN HANDLE hNotifyHandle;
  IN PVOID NotifyContext1; IN PVOID NotifyContext2;
  IN PHYSICAL_ADDRESS  phOpDeviceIoAddress;
} CE_DMA_ISSUEMULTIDMATRANSFER, *PCE_DMA_ISSUEMULTIDMATRANSFER;
// OUT
// DMA_TRANSFER_HANDLE hDmaHandle,

//DMAStartTransfer
#define IOCTL_CE_DMA_STARTTRANSFER _CE_DMA_CTL_CODE(0xd)
// IN DMA_TRANSFER_HANDLE

//DMAGetContexts
#define IOCTL_CE_DMA_GETDMACONTEXTS _CE_DMA_CTL_CODE(0xe)
// IN DMA_TRANSFER_HANDLE
// OUT
typedef struct _CE_DMA_GETDMACONTEXTS {
  OUT PVOID dmaContext1;
  OUT PVOID dmaContext2;
} CE_DMA_GETDMACONTEXTS ,*PCE_DMA_GETDMACONTEXTS ;


#define IOCTL_CE_DMA_OEM_IO_CONTROL_START   0x100

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cedrv_guid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    cedrv_guid.h

Abstract:

    GUID Definitions for Windows CE driver.

Revision History:

--*/

#pragma once

#define CE_DRIVER_POWER_MANAGEABLE_GENERIC_GUID     TEXT("{A32942B7-920C-486b-B0E6-92A702A99B35}")

#define CE_DRIVER_POWER_MANAGEABLE_NDIS_GUID        TEXT("{98C5250D-C29A-4985-AE5F-AFE5367E5006}")

#define CE_DRIVER_BLOCK_GUID                        TEXT("{A4E7EDDA-E575-4252-9D6B-4195D48BB865}")
#define CE_DRIVER_POWER_MANAGEABLE_BLOCK_GUID       TEXT("{8DD679CE-8AB4-43c8-A14A-EA4963FAA715}")

#define CE_DRIVER_POWER_MANAGEABLE_DISPLAY_GUID     TEXT("{EB91C7C9-8BF6-4a2d-9AB8-69724EED97D1}")

#define CE_DRIVER_BACKLIGHT_GUID                    TEXT("{F922DDE3-6A6D-4775-B23C-6842DB4BF094}")
#define CE_DRIVER_POWER_MANAGEABLE_BACKLIGHT_GUID   TEXT("{0007AE3D-413C-4E7E-8786-E2A696E73A6E}")

#define CE_DRIVER_BUS_GUID                          TEXT("{6F40791D-300E-44E4-BC38-E0E63CA8375C}")
#define CE_DRIVER_BUILTIN_BUS_GUID                  TEXT("{B3CC6EBA-5507-4196-8E41-2BF42E4A47C9}")
#define CE_DRIVER_SD_BUS_GUID                       TEXT("{20FA98A8-B298-4b32-8D72-C716AEE2FA84}")
#define CE_DRIVER_USBFN_BUS_GUID                    TEXT("{E2BDC372-598F-4619-BC50-54B3F7848D35}")
#define CE_DRIVER_PCMCIA_BUS_GUID                   TEXT("{6BEAB08A-8914-42fd-B33F-61968B9AAB32}")
#define CE_DRIVER_PCCARD_BUS_GUID                   TEXT("{F6D3DC51-CC71-4916-B3FB-030A85BA0044}")
#define CE_SERVICE_BUS_GUID                         TEXT("{6D4317A0-B5A2-462c-9C59-1E70D2600522}")

#define CE_DRIVER_USB_HOST_CONTROLLER_GUID          TEXT("{7D96B50A-6BB5-4f64-ACD2-A0C3A45375FA}")

#define CE_DRIVER_PCCARD_SOCKET_GUID                TEXT("{57430CF2-A260-4c9b-8F5C-FEF89217FE7C}")
#define CE_DRIVER_PCCARD_SOCKET_ISA_GUID            TEXT("{44985F1F-2C07-4009-A6B7-D250785D5336}")
#define CE_DRIVER_PCCARD_SOCKET_PCI_GUID            TEXT("{35CE81FB-6788-46ec-87D0-B54D96410C09}")

#define CE_DRIVER_GPS_GUID                          TEXT("{5D425811-8668-47bb-9037-BFBAB6DF40B4}")

#define CE_DRIVER_PARALLEL_PORT_GUID                TEXT("{4FE1CEF1-E765-4a1e-B503-5B8C674D7C68}")

#define CE_DRIVER_SERIAL_PORT_GUID                  TEXT("{CC5195AC-BA49-48a0-BE17-DF6D1B0173DD}")
#define CE_DRIVER_SERIAL_MODEM_GUID                 TEXT("{C375C787-B721-4b8e-B67F-A112D5C0A404}")

#define CE_DRIVER_KEYBOARD_GUID                     TEXT("{CBE6DDF2-F5D4-4e16-9F61-4CCC0B6695F3}")
#define CE_DRIVER_HID_MOUSE_GUID                    TEXT("{CF3F6FC3-BBBC-4e49-B74D-540BBF5DC743}")

#define CE_DRIVER_BLUTOOTH_GUID                     TEXT("{54DA86F7-9B78-46d1-8022-51BFA88D7F03}")

#define CE_DRIVER_CAMERA_GUID                       TEXT("{CB998A05-122C-4166-846A-933E4D7E3C86}")

#define CE_DRIVER_WAVEDEV_GUID                      TEXT("{E92BC203-8354-4043-A06F-2A170BF6F227}")
#define CE_DRIVER_WAVEDEV_UNIFIED_GUID              CE_DRIVER_WAVEDEV_GUID
#define CE_DRIVER_MIXERDEV_GUID                     TEXT("{37168569-61C4-45fd-BD54-9442C7DBA46F}")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cemapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
    Copyright (c) Microsoft Corporation. All rights reserved.
*/

#ifndef __cemapi_MAPI_H__
#define __cemapi_MAPI_H__

#include <mapidefs.h>
#include <mapicode.h>
#include <mapitags.h>
#include <mapispi.h>
#include <mapix.h>

#ifndef _PURE
#define _PURE =0
#endif // _PURE





const LPCTSTR kszAppInbox = TEXT ("tmail.exe");





const int g_knMaxSvcs   = 8;         // Max # of services
const int g_knMaxSvcLen = 32;       // Max length of a service name





//----------------------------------------------------------------------------
// MAIL SYNC HANDLER Interfaces
//----------------------------------------------------------------------------

#define SYNCPROGRESSITEM_STATUSTEXT                 0x0001
#define SYNCPROGRESSITEM_STATUSTYPE                 0x0002
#define SYNCPROGRESSITEM_PROGVALUE                  0x0004
#define SYNCPROGRESSITEM_MAXVALUE                   0x0008
#define SYNCPROGRESSITEM_DISCONNECTED               0x0010
#define SYNCPROGRESSITEM_TOTAL_NEW_MAIL             0x0020
#define SYNCPROGRESSITEM_NEW_MESSAGE                0x0040
#define SYNCPROGRESSITEM_DISMISS_STATUSTYPE         0x0080

typedef struct _SYNCPROGRESSITEM
{
    ULONG       cbSize;

    DWORD       mask;

    LPCWSTR     pwszStatusText;
    DWORD       dwStatusType;
    ULONG       ulProgValue;
    ULONG       ulMaxValue;

    ULONG       ulTotalNewMail;

    ULONG       cbIdNewMsg;
    LPENTRYID   pidNewMsg;

} SYNCPROGRESSITEM;

#define SYNC_NORMAL         0
#define SYNC_HIERARCHY      1
#define SYNC_CREATE_FOLDER  2
#define SYNC_RENAME_FOLDER  3
#define SYNC_DELETE_FOLDER  4
#define SYNC_RESETHIERARCHY  5
#define SYNC_FOLDER          6
#define SYNC_SENDONLY        7

typedef struct _MAILSYNCREQUEST
{
    DWORD       cbSize;
    DWORD       cbBufSize;

    DWORD       cbCookie;
    LPBYTE      pbCookie;

    ULONG       ffFlags;

    ULONG       objType;
    LPENTRYID   pid;
    DWORD       cbId;

    LPSPropValue  pval;

} MAILSYNCREQUEST;

typedef struct _SYNCCREDENTIALS
{
    DWORD       cbSize;
    DWORD       cbBufSize;
    LPTSTR      pszUsername;
    LPTSTR      pszDomain;
    LPTSTR      pszPassword;
} SYNCCREDENTIALS;

typedef struct _TRANSPORTEVENT
{
    LPCWSTR pszSourceDLL;
    LPCWSTR pszSourceProfile;
    HRESULT hr;
    DWORD   dwSeverity;
    DWORD   cbData;
    LPBYTE  pbData;
} TRANSPORTEVENT;

typedef struct _MESSAGEFIELDS
{
    LPCWSTR pszwTo;
    LPCWSTR pszwCc;
    LPCWSTR pszwBcc;
    LPCWSTR pszwSubject;
    LPCWSTR pszwBody;
    DWORD flags;
} MESSAGEFIELDS;


typedef enum
{
    MSG_FORMAT_UNKNOWN = 0,
    MSG_FORMAT_TEXT,
    MSG_FORMAT_HTML,
    MSG_FORMAT_RTF,
} MESSAGEFORMAT;


const DWORD kdwOptionValueNone = 0;
const DWORD kdwOptionValueAll  = 0xFFFFFFFF;


const WCHAR kszCapHTMLMail[]                    = L"HTMLMail";
const WCHAR kszCapAutoPostMeetingResponse[]     = L"AutoPostMeetingResponse";
const WCHAR kszCapAmountToFetch[]               = L"FetchSize";
const WCHAR kszCapAttachAmount[]                = L"AttachFetchSize";
const WCHAR kszCapAgeFilter[]                   = L"AgeFilter";
const WCHAR kszCapSaveSent[]                    = L"SaveSent";
const WCHAR kszCapSMSUnicode[]                  = L"SMSUnicode";
const WCHAR kszCapSMSDeliveryNotify[]           = L"SMSDeliveryNotify";
const WCHAR kszCapSMTPAuthenticate[]            = L"SMTPAuthenticate";
const WCHAR kszCapIncludeOriginal[]             = L"IncludeOriginal";
const WCHAR kszCapIndentBody[]                  = L"IndentBody";
const WCHAR kszCapAddLeading[]                  = L"AddLeading";
const WCHAR kszCapLeadChar[]                    = L"LeadChar";
const WCHAR kszCapSyncMsgClasses[]              = L"SyncMsgClasses";
const WCHAR kszCapSyncMsgClassDef[]             = L"SyncMsgClassDef";
const WCHAR kszCapPropDialog[]                  = L"PropDialog";                    // default: FALSE
const WCHAR kszCapSyncHierarchy[]               = L"SyncHierarchy";
const WCHAR kszCapDeleteAction[]                = L"DeleteAction";
const WCHAR kszCapMoveToTrash[]                 = L"TrashMoves";

const WCHAR kszCapReturnAddress[]               = L"ReturnAddress";
const WCHAR kszCapCurrentService[]              = L"CurrentService";
const WCHAR kszCapCreateSpecialFldrs[]          = L"CreateSpecialFolders";

// Boolean service capabilities which have default values.
// Override the default in GetCapability().
const WCHAR kszCapFolders[]                     = L"Folders";                       // default: TRUE
const WCHAR kszCapFolderNotifications[]         = L"FolderNotifications";           // default: FALSE

// New for 2003 devices
const WCHAR kszCapClearAll[]                    = L"ClearAll";                      // default: TRUE
const WCHAR kszCapEmptyDeleteItem[]             = L"EmptyDeleteItem";               // default: TRUE
const WCHAR kszCapEditProperties[]              = L"EditProperties";                // default: TRUE
const WCHAR kszCapFolderOptions[]               = L"EmptyFolderOptions";            // default: TRUE
const WCHAR kszCapMgmtFolder[]                  = L"MgmtFolder";                    // default: TRUE
const WCHAR kszCapSync[]                        = L"Sync";                          // default: TRUE
const WCHAR kszCapSyncOnDockEvent[]             = L"SyncOnDockEvent";               // default: TRUE
const WCHAR kszCapConnect[]                     = L"Connect";                       // default: TRUE
const WCHAR kszCapRequireRadio[]                = L"RequireRadio";                  // default: FALSE
const WCHAR kszCapMarkAttachments[]             = L"MarkAttachments";               // default: FALSE
const WCHAR kszCapReplyAll[]                    = L"ReplyAll";                      // default: TRUE (can't be TRUE if no compose capability)
const WCHAR kszCapAlwaysIncludeOriginal[]       = L"AlwaysIncludeOriginal";         // default: FALSE
const WCHAR kszCapCompose[]                     = L"Compose";                       // default: TRUE
const WCHAR kszCapOfflineStatus[]               = L"OfflineStatus";                 // default: TRUE
const WCHAR kszCapCallSender[]                  = L"CallSender";                    // default: FALSE
const WCHAR kszCapLanguage[]                    = L"Language";                      // default: TRUE
const WCHAR kszCapAttachments[]                 = L"Attachments";                   // default: TRUE
const WCHAR kszCapFolderManagementAllowCreate[] = L"FolderManagementAllowCreate";   // default: TRUE
const WCHAR kszCapFolderManagementAllowRename[] = L"FolderManagementAllowRename";   // default: TRUE
const WCHAR kszCapFolderManagementAllowDelete[] = L"FolderManagementAllowDelete";   // default: TRUE

const WCHAR kszCapSMIME[]                       = L"SMIME";                         // default: FALSE
const WCHAR kszCapCannotSendMeetingRequests[]   = L"CannotSendMeetingRequests";     // default: FALSE
const WCHAR kszCapClearAllOnServer[]            = L"ClearAllDeletesFromServer";     // default: TRUE
const WCHAR kszCapServiceFromMessage[]          = L"ServiceFromMessage";            // Only used in GetGlobalSetting
const WCHAR kszCapPolicyEnabled[]               = L"PolicyEnabled";                 // Only used in GetGlobalSetting


const WCHAR kszCapFollowUpFlags[]               = L"FollowUpFlags";                 // default: FALSE

// Fetch / AUTD
const WCHAR kszCapImmediateDownload[]           = L"ImmediateDownload";             // default: FALSE
const WCHAR kszCapSwitchFormat[]                = L"SwitchFormat";                  // default: FALSE
const WCHAR kszCapConnectHomeNetwork[]          = L"ConnectHomeNetwork";            // default: TRUE

// Sync outgoing mail
const WCHAR kszCapSyncSendOnly[]                = L"SyncSendOnly";                  // default: FALSE

// kszCapDeleteAction above allows the user to specify
// what delete options should be taken during laster syncs...
#define DELACTION_IMMEDIATELY            0x00000000
#define DELACTION_MANUALLY               0x00000001


// {96D2552D-B83B-4b48-8E89-DCC26512DBA4}
static const GUID IID_IMailRuleClient =
{ 0x96d2552d, 0xb83b, 0x4b48, { 0x8e, 0x89, 0xdc, 0xc2, 0x65, 0x12, 0xdb, 0xa4 } };

typedef enum _MRCACCESS
{
    MRC_ACCESS_NONE = 0,         // Client isn't interested in this message
    MRC_ACCESS_READ_ONLY = 1,    // Client is only interested in read access for messages
    MRC_ACCESS_WRITE = 2         // Client wants write access for messages
} MRCACCESS;

typedef enum _MRCHANDLED {
    MRC_NOT_HANDLED = 0,         // Client didn't handle the message
    MRC_HANDLED_CONTINUE = 1,    // Client handled message, let others handle too
    MRC_HANDLED_DONTCONTINUE = 2 // Client handled message, don't let others handle
} MRCHANDLED;

interface IMailRuleClient : public IUnknown
{
public:
    MAPIMETHOD(Initialize)(
            IMsgStore *pMsgStore,
            MRCACCESS *pmaDesired
            ) _PURE;

    MAPIMETHOD(ProcessMessage)(
            IMsgStore *pMsgStore,
            ULONG cbMsg,
            LPENTRYID lpMsg,
            ULONG cbDestFolder,
            LPENTRYID lpDestFolder,
            ULONG *pulEventType,
            MRCHANDLED *pHandled
            ) _PURE;
};


// forward declaration
class IMailSyncHandler;



// {447DAA3A-E420-4e87-B440-0045B9FE73BC}
static const GUID IID_IMailSyncCallBack =
{ 0x447daa3a, 0xe420, 0x4e87, { 0xb4, 0x40, 0x0, 0x45, 0xb9, 0xfe, 0x73, 0xbc } };

class IMailSyncCallBack : public IUnknown
{
public:
    MAPIMETHOD(RequestSync)(
            LPCWSTR pszProfile,
            DWORD cbCookie,
            LPBYTE pbCookie
            ) _PURE;

    MAPIMETHOD(Progress)(
            LPCWSTR pszProfile,
            SYNCPROGRESSITEM* pinfo
            ) _PURE;

    MAPIMETHOD(GetGlobalSetting)(
            LPCWSTR pszSetting,
            LPSPropValue pval
            ) _PURE;

    MAPIMETHOD_(UINT, DisplayMessageBox)(
            LPCWSTR pszProfile,
            LPCWSTR pszTitle,
            LPCWSTR pszMessage,
            UINT uType
            ) _PURE;

    MAPIMETHOD(RequestCredentials)(
            LPCWSTR pszProfile,
            SYNCCREDENTIALS*  ppcredsSource,
            SYNCCREDENTIALS** ppcreds
            ) _PURE;

    MAPIMETHOD(LogEvent)(
            TRANSPORTEVENT* pevt
            ) _PURE;

    MAPIMETHOD(AllocateMem)(
            DWORD cbSize,
            LPBYTE* ppb
            ) _PURE;

    MAPIMETHOD(FreeMem)(
            LPVOID pvmem
            ) _PURE;
};

#define FOLDER_HIDE             0x00010000
#define FOLDER_SPECIAL          0x00020000
#define FOLDER_INBOX            0x00040000
#define FOLDER_DELETED_ITEMS    0x00080000
#define FOLDER_SENT_ITEMS       0x00100000
#define FOLDER_OUTBOX           0x00200000
#define FOLDER_DRAFTS           0x00400000
#define FOLDER_IPM              0x00800000
#define FOLDER_SEARCH_ROOT      0x01000000

typedef struct _FOLDERNODE {
    _FOLDERNODE*    pSibbling;
    _FOLDERNODE*    pChild;
    _FOLDERNODE*    pParent;
    DWORD           ffFlags;
    LPWSTR          szName;
} FOLDERNODE;


// flag for Shutdown function
#define SHUTDOWNFLAG_LOSTCONNECTION     0x0001

class IMailSyncHandler : public IUnknown
{
public:
    MAPIMETHOD(Initialize)(
            IMailSyncCallBack* pCallBack,
            LPCWSTR pszProfileName,
            IMsgStore* pMsgStore
            ) _PURE;

    MAPIMETHOD(ShutDown)(
            DWORD dwReserved
            ) _PURE;

    MAPIMETHOD(Synchronize)(
            MAILSYNCREQUEST* pRqst
            ) _PURE;

    MAPIMETHOD(DoProperties)(
            HWND hwndParent
            ) _PURE;

    MAPIMETHOD(GetCapability)(
            LPCWSTR pszName,
            LPSPropValue pval
            ) _PURE;

    MAPIMETHOD(SetCapability)(
            LPCWSTR pszName,
            LPSPropValue pval
            ) _PURE;

    MAPIMETHOD(Install)(
            LPCWSTR pszProfileName,
            LPCWSTR pszIncomingServer,
            LPCWSTR pszOutgoingServer,
            GUID*   pidNetwork
            ) _PURE;

    MAPIMETHOD(UnInstall)(
            ) _PURE;

    MAPIMETHOD(DecodeEvent)(
            TRANSPORTEVENT* pevt,
            LPWSTR* ppszEvent
            ) _PURE;

    MAPIMETHOD(GetFolderHierarchy)(
            FOLDERNODE** ppRootNode
            ) _PURE;

    enum FOLDEROPTIONS {
        koptNA = 0,
        koptDownload,
        koptQueryDownload,
        koptNotifications,
        koptQueryNotifications,
        koptGetRemotePath,
        koptCreate,
        koptQueryCreate,
        koptSetAge,
        koptSetBodyFetchSize,
        koptSetAttachFetchSize,
        koptGetAge,
        koptGetBodyFetchSize,
        koptGetAttachFetchSize,
    };

    MAPIMETHOD(SetFolderOptions)(
            IMAPIFolder*    pfldr,
            FOLDERNODE*     pnode,
            FOLDEROPTIONS   opts,
            LPSPropValue    pval
            ) _PURE;

    MAPIMETHOD(Connect)(
            DWORD dwReserved,
            SYNCCREDENTIALS* pCredentials
            ) _PURE;

    MAPIMETHOD(Disconnect)(
            DWORD dwReserved
            ) _PURE;
};

#define MAX_ONESTOP_TYPE_NAME   32
#define MAX_MESSAGE_CLASS_NAME   64
#define MAX_MESSAGE_CLASS_DISPLAY_NAME      64
#define MAX_MESSAGE_CLASSES_SUPPORTED_STRING    1024

typedef HRESULT (WINAPI *ONESTOPFACTORYFUNC)(LPCWSTR pszType, IMailSyncHandler** ppObj);




typedef enum tagSMIME_SENDFLAG
{
    SMIME_SENDFLAG_SIGN    = 0x00000001,
    SMIME_SENDFLAG_ENCRYPT = 0x00000002
} SMIME_SENDFLAG;


//----------------------------------------------------------------------------
// ICEMAPISession Interface
//----------------------------------------------------------------------------

#define MAPI_ICEMAPISESSION_METHODS(IPURE)                              \
    MAPIMETHOD(CreateMsgStore)                                          \
        (THIS_  LPCWSTR                     pszDisplayName,             \
                IMsgStore**                 ppMsgStore) IPURE;          \
    MAPIMETHOD(DeleteMsgStore)                                          \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \


#undef       INTERFACE
#define      INTERFACE  ICEMAPISession
DECLARE_MAPI_INTERFACE_(ICEMAPISession, IMAPISession)
{
public:
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPISESSION_METHODS(PURE)
    MAPI_ICEMAPISESSION_METHODS(PURE)
};

//----------------------------------------------------------------------------
// Custom CE Property Tags
//----------------------------------------------------------------------------

#define PR_CE_IMAP_UID                      PROP_TAG(PT_LONG,    0x8100)
#define PR_CE_MIME_TEXT                     PROP_TAG(PT_BINARY,  0x8103)    // This is CHAR text
#define PR_CE_IPM_DRAFTS_ENTRYID            PROP_TAG(PT_BINARY,  0x8104)
#define PR_CE_IPM_SEARCH_ENTRYID            PROP_TAG(PT_BINARY,  0x8105)
#define PR_CE_IPM_INBOX_ENTRYID             PROP_TAG(PT_BINARY,  0x8106)
#define PR_CONTENT_LENGTH_EX                PROP_TAG(PT_LONG,    0x8108)    // Full size of the message on the server.

#define PR_CE_XPRT_MSG_STATUS               PROP_TAG(PT_LONG,    0x8102)    // For transport flags.
#define PR_CE_XPRT_MESSAGE_FLAGS            PROP_TAG(PT_LONG,    0x810b)

#define PR_CE_ITEM_GENERATION               PROP_TAG(PT_LONG,    0x810c)    // Item generation

// This is the index of the item in a sorted folder list.  It's
// only returned from a IMAPITable::QueryRows() call.
#define PR_CE_ITEM_INDEX                    PROP_TAG(PT_LONG,    0x810d)

// This property contains a single wide string
// for all x-headers, (including all the \r\n).
#define PR_CE_XHEADERS                      PROP_TAG(PT_UNICODE, 0x8110)

#ifndef PR_MESSAGE_SIZE_EX
#define PR_MESSAGE_SIZE_EX                  PROP_TAG(PT_LONG,    0x8111)
#endif

// This property, when set, suppresses pop-up notification of the message's arrival
#define PR_CE_NO_NOTIFICATION               PROP_TAG(PT_BOOLEAN, 0x8112)

// This property is to uniquely identify a store. It's a guid.
#define PR_CE_UNIQUE_STORE_ID               PROP_TAG(PT_CLSID, 0x8113)

// This property is for storing EMS header data that comes with a SMS message
#define PR_CE_EMS_HEADER_DATA               PROP_TAG(PT_BINARY, 0x8114)

// Set this property on a message store to prevent it from being shown on the today page/homescreen unread counts
#define PR_CE_HIDE_FROM_TODAY_PAGE          PROP_TAG(PT_BOOLEAN, 0x8115)

// a property to determine if a folder is a search folder or not
#define PR_CE_IS_SEARCH_FOLDER              PROP_TAG(PT_BOOLEAN, 0x8116)

// This property is the name of the transport used for an account (e.g. SMS, POP3)
// This name is not localized
#define PR_CE_TRANSPORT_NAME                PROP_TAG (PT_UNICODE, 0x8117)

// Set this property on a message to indicate that various menu commands should be greyed out
#define PR_CE_CONTEXT_FLAGS                 PROP_TAG (PT_LONG, 0x8118)
#define CE_CONTEXT_DISABLE_REPLY            0x00000001  // The Reply and Reply All menu item should be disabled for this message
#define CE_CONTEXT_DISABLE_FORWARD          0x00000002  // The Forward menu item should be disabled for this message
#define CE_CONTEXT_DISABLE_DELETE           0x00000004  // The Delete menu item should be disabled for this message
#define CE_CONTEXT_DISABLE_MOVE             0x00000008  // The Move menu item should be disabled for this message
#define CE_CONTEXT_DISABLE_FLAG             0x00000010  // The Flag-related menu items should be disabled for this message
#define CE_CONTEXT_DISABLE_MARKREAD         0x00000020  // The Mark as Read/Unread menu items should be disabled for this message

// Account signature
#define PR_CE_SIGNATURE                     PROP_TAG (PT_UNICODE, 0x8119)

// Indicates whether the signature should be used for new messages
#define PR_CE_USE_SIGNATURE                 PROP_TAG (PT_BOOLEAN, 0x811A)

// Indicates whether the signature should be included in replies
#define PR_CE_USE_SIGNATURE_REPLY_FORWARD   PROP_TAG (PT_BOOLEAN, 0x811B)

// Account domain
#define PR_CE_DOMAIN                PROP_TAG (PT_UNICODE, 0x811F)

// Number of minutes between syncs
#define PR_CE_CHECK_INTERVAL        PROP_TAG (PT_I4,      0x8120)

// Number of bytes to download for a message
#define PR_CE_FETCH_SIZE            PROP_TAG (PT_I4,      0x8121)

// Maximum attachment size
#define PR_CE_ATTACH_FETCH_SIZE     PROP_TAG (PT_I4,      0x8122)

// Number of days to display
#define PR_CE_AGE_FILTER            PROP_TAG (PT_I4,      0x8123)

// Indicates whether the SMTP server requires authentication
#define PR_CE_SMTP_AUTHENTICATION   PROP_TAG (PT_BOOLEAN, 0x8124)

// Mail server for receiving mail
#define PR_CE_INCOMING_SERVER       PROP_TAG (PT_UNICODE, 0x8125)

// Mail server for sending mail
#define PR_CE_OUTGOING_SERVER       PROP_TAG (PT_UNICODE, 0x8126)

// Connection used to connect to servers
#define PR_CE_CONNECTION_GUID       PROP_TAG (PT_CLSID,   0x8127)

// Account requires SSL
#define PR_CE_REQUIRE_SSL           PROP_TAG (PT_BOOLEAN, 0x8128)

// What is the alternative SMTP account name?
#define PR_CE_SMTPALT_ACCOUNT       PROP_TAG (PT_UNICODE, 0x8129)

// What is the alternative SMTP domain?
#define PR_CE_SMTPALT_DOMAIN        PROP_TAG (PT_UNICODE, 0x812A)

// Are alternative creds needed for SMTP server?
#define PR_CE_SMTPALT_ENABLED       PROP_TAG (PT_BOOLEAN, 0x812B)

// Does SMTP server require SSL?
#define PR_CE_SMTPALT_SSL           PROP_TAG (PT_BOOLEAN, 0x812C)

// The SMS callback number for a message (on networks supporting SMS callback)
#define PR_CE_SMS_CALLBACK          PROP_TAG (PT_UNICODE, 0x812D)


// Message Format properties
// -------------------------
// (legal values are members of the MESSAGEFORMAT enumeration)

// The message format that a transport should prefer to retrieve if available,
// unless overriden on a particular message by PR_CE_PENDING_BODY_FORMAT.
//
// Set and read on message stores.
#define PR_CE_PREFERRED_DOWNLOAD_FORMAT PROP_TAG (PT_I4, 0x812E)

// The message format that should be fetched on either the next out of band fetch
// or the next mark for download.
//
// Set and read on messages.
#define PR_CE_PENDING_BODY_FORMAT       PROP_TAG (PT_I4,      0x812F)

// The original message format as it exists on the server, since we can download
// a different format than the native. (Used only for messages sync'ed from a transport,
// not messages authored on the device for sending.)
//
// Set and read on received messages.
#define PR_CE_NATIVE_MESSAGE_FORMAT     PROP_TAG (PT_I4,      0x8130)

// Raw binary data from a raw SMS message
#define PR_CE_SMS_RAW_HEADER            PROP_TAG (PT_BINARY,  0x8131)
#define PR_CE_SMS_RAW_BODY              PROP_TAG (PT_BINARY,  0x8132)

// Fetch Failure Indication properties
// -----------------------------------
//
// Used in conjunction with kszCapImmediateDownload. These properties
// indicate via MAPI notifications whether an attempt to retrieve a
// message outside of the normal send/receive flow has failed.

// Indicates via notification that the attempt to retrieve the message
// body has failed. The value of this property is not used.
#define PR_CE_FETCH_BODY_FAILURE        PROP_TAG (PT_LONG,      0x8133)

// Indicates via notification that the attempt to retrieve attachments
// for the message has failed. The binary value is an array of ULONG
// indices of attachments that failed. The size of the array can be
// found by dividing the total binary size by sizeof(ULONG).
// The value is valid only until the next attachment failure.
#define PR_CE_FETCH_ATTACHMENT_FAILURE  PROP_TAG (PT_BINARY,    0x8134)


// An account property that indicates that the application should
// automatically invoke a Send/Receive when a message is sent to the Outbox.
#define PR_CE_SYNC_ON_SEND              PROP_TAG (PT_BOOLEAN,   0x8135)

// Indicates that the MAPI notification should not initiate
// an immediate download (fetch) of the modified object.
#define PR_CE_SUPPRESS_FETCH                    PROP_TAG (PT_LONG,  0x8136)

// Prevents an account from automatically connecting while roaming
#define PR_CE_SYNC_MANUALLY_WHEN_ROAMING        PROP_TAG (PT_LONG,  0x8137)


// For quick recognition of the recipient types for a message.
#define MSGSTATUS_RECTYPE_SMTP                  0x00020000
#define MSGSTATUS_RECTYPE_SMS                   0x00040000

// Re-use the above flags for incoming SMS status messages
// which are mutually exclusive from outgoing messages.
#define MSGSTATUS_SMSSTATUS_SUCCESS             0x00020000

// To determine if any transport still needs to send the message...
#define MSGSTATUS_RECTYPE_ALLTYPES              (MSGSTATUS_RECTYPE_SMTP | MSGSTATUS_RECTYPE_SMS)

// This flag should be set if only the header has been downloaded.
#define MSGSTATUS_HEADERONLY                    0x00010000

// This flag is set if the item should be partially downloaded.
#define MSGSTATUS_PARTIAL_DOWNLOAD              0x00080000

// This flag is set if the item is only partially downloaded.
#define MSGSTATUS_PARTIAL                       0x00100000

// This flag is set if the message has at least one attachment marked for downloaded.
#define MSGSTATUS_REMOTE_DOWNLOAD_ATTACH        0x00200000

// This flag is set if the MIME header needs to be downloaded.
#define MSGSTATUS_REMOTE_DOWNLOAD_HEADER        0x00400000

// This flag is set if the message has a TNEF blob attached.
#define MSGSTATUS_HAS_TNEF                      0x00800000

// This flag is set if the TNEF of a message needs to be downloaded.
#define MSGSTATUS_REMOTE_DOWNLOAD_TNEF          0x01000000

// This flag is set if the attachment has a copy on the server.
#define MSGSTATUS_GHOSTED_ATTACH                0x02000000

// This flag is set if there are attachments on the message that
// have not yet been downloaded.
#define MSGSTATUS_PENDING_ATTACHMENTS           0x04000000

// This flag is set if the message has PR_CE_MIME_TEXT property
#define MSGSTATUS_HAS_PR_CE_MIME_TEXT           0x08000000

// This flag is set if the message has PR_BODY property
#define MSGSTATUS_HAS_PR_BODY                   0x10000000

// This flag is set if the message has PR_CE_SMIME_TEXT property
#define MSGSTATUS_HAS_PR_CE_SMIME_TEXT          0x20000000

// This flag is set if the message has PR_CE_CRYPT_MIME_TEXT property
#define MSGSTATUS_HAS_PR_CE_CRYPT_MIME_TEXT     0x40000000

// This flag is set if the message has PR_BODY_HTML property
#define MSGSTATUS_HAS_PR_BODY_HTML              0x80000000




//===========================================================================
// Mail application functions
//===========================================================================

// MAILCOMPOSEFIELDS flag values
#define MCF_ACCOUNT_IS_NAME             0x01
#define MCF_ACCOUNT_IS_TRANSPORT        0x02
#define MCF_MAILTO_FORMAT               0x04  // pszTo is in "mailto" format
#define MCF_RUN_IN_BACKGROUND           0x08  // App should run in background, used with MailSyncMessages

// Structure of flags used for composing a new message
typedef struct _MAILCOMPOSEFIELDS
{
    DWORD cbSize;                    // Set to structure size
    DWORD dwFlags;                   // Combination of MCF_ flags above
    LPCTSTR pszTo;                   // To address
    LPCTSTR pszCc;                   // Cc address
    LPCTSTR pszBcc;                  // Bcc address
    LPCTSTR pszSubject;              // Message subject
    LPCTSTR pszBody;                 // Message body
    LPCTSTR pszAttachments;          // NULL-separated list of attachment file names
    UINT cAttachments;               // Number of attachments in pszAttachFiles
    LPCTSTR pszAccount;              // Name of account to use (whether is name of account or transport name is determined by dwFlags)
    LPCTSTR pszMsgClass;             // Name of message class to use (default if NULL)
} MAILCOMPOSEFIELDS;


extern "C"
{
 
// Displays a new message, determined by the information in MAILCOMPOSEFIELDS.  pmcf can be NULL.
HRESULT WINAPI MailComposeMessage(MAILCOMPOSEFIELDS *pmcf);
 
// Displays an existing message as opposed to creating a new one.  Message is determined by ENTRYID.
HRESULT WINAPI MailDisplayMessage(LPENTRYID lpEntryID, ULONG cbEntryID);

// Switches to a folder.  lpEntryID is the ENTRYID of the folder we want to switch to in listview, cbEntryID is the size of the ENTRYID.
HRESULT WINAPI MailSwitchToFolder(LPENTRYID lpEntryID, ULONG cbEntryID);

// Switches to an account.  Specify the account by name or transport (determined by dwFlags which takes an MCF_ value).
HRESULT WINAPI MailSwitchToAccount(LPCTSTR pszAccount, DWORD dwFlags);

// Syncs mail.  Specify the account by name or transport (determined by dwFlags which takes an MCF_ value).  
// If pszAccount is NULL, the current account is synced.
HRESULT WINAPI MailSyncMessages(LPCTSTR pszAccount, DWORD dwFlags);

// Launches the Messaging application and invokes the new account wizard. Returns immediately.
//
// return values - S_OK for success, error code if failure
HRESULT WINAPI MailLaunchNewAccountWizard();

}


class IMessageCard;


///<summary>
///     IMessageCardHost contains methods an messaging card host must implement. 
///</summary>

// {8ac886b4-7482-4f0d-9b20-4847d086d1bd}
static const GUID IID_IMessageCardHost =
{ 0x8ac886b4, 0x7482, 0x4f0d, { 0x9b, 0x20, 0x48, 0x47, 0xd0, 0x86, 0xd1, 0xbd } };

class __declspec(uuid("8ac886b4-7482-4f0d-9b20-4847d086d1bd"))
IMessageCardHost 
{
public:
    
    /// <summary>
    ///     A set of actions a Card expects the host may be able to do.  Those
    ///     actions enums should be used as the passed-in value when the Card 
    ///     calling DoAction() and CanDoAction(). 
    /// </summary>
    enum HOST_ACTION
    {
       HOST_ACTION_FIRST                    = 0,
        
       HOST_ACTION_REPLY                    = 0,
       HOST_ACTION_REPLYALL                 = 1,
       HOST_ACTION_REPLYWITH                = 2,
       HOST_ACTION_FORWARD                  = 3,
       HOST_ACTION_COMPOSENEW               = 4,
       HOST_ACTION_SHOWMESSAGE              = 5,
       // HOST_ACTION_DELETE: Additional param needed to specify the deletion flag.
       HOST_ACTION_DELETE                   = 6,           
       HOST_ACTION_LOADNEXTMESSAGE          = 7,  
       HOST_ACTION_LOADPREVMESSAGE          = 8,  
       HOST_ACTION_MOVETOFOLDER             = 9,
       HOST_ACTION_MARKASUNREAD             = 10,
       HOST_ACTION_ACCEPTVCARD              = 11,
       HOST_ACTION_DOWNLOADMESSAGE          = 12,
       HOST_ACTION_CANCELDOWNLOADMESSAGE    = 13,
       HOST_ACTION_TOGGLEDOWNLOADMESSAGE    = 14,
       HOST_ACTION_TOGGLESENDRECEIVE        = 15,
       // HOST_ACTION_TOGGLEATTACHMENTDOWNLOAD: Additional param needed to 
       // specify attachment index.
       HOST_ACTION_TOGGLEATTACHMENTDOWNLOAD = 16,  
       HOST_ACTION_SETFOLLOWUP              = 17, 
       HOST_ACTION_COMPLETEFOLLOWUP         = 18,
       HOST_ACTION_CLEARFOLLOWUP            = 19,
       HOST_ACTION_TOGGLEFOLLOWUP           = 20,
       HOST_ACTION_SIM_COPYTOSIM            = 21,    
       HOST_ACTION_SIM_COPYTOINBOX          = 22,  
       HOST_ACTION_CLOSECARD                = 23,
       
       HOST_ACTION_LAST
    };


    /// <summary>
    ///     Determine the state of the queried action item.
    ///     ACTION_STATE_INVALID:  The action is not supported by the card host. 
    ///                            The card should not present the invalid action 
    ///                            in the menu or to the user.
    ///     ACTION_STATE_DISABLED: The action can not be performed at this point
    ///                            and should be disabled by the card.
    ///     ACTION_STATE_ENABLED:  The action can be performed currently and 
    ///                            should be enabled by the card.
    /// </summary>
    enum ACTION_STATE {
        ACTION_STATE_INVALID  = -1,
        ACTION_STATE_DISABLED = 0,
        ACTION_STATE_ENABLED  = 1,
    };

    /// <summary>
    ///     Flags to be passed in when a card requesting to delete a message.
    ///     ACTION_DELETE_FLAG_DISPLAYPROMPT: The host displays a confirmation
    ///                                       dialog asking a user's permission
    ///                                       before deleting the message.
    ///     ACTION_DELETE_FLAG_NOPROMPT: The host can delete the message without
    ///                                  prompting to the user for confirmation.
    /// </summary>
    enum ACTION_DELETE_FLAG {
        ACTION_DELETE_FLAG_DISPLAYPROMPT = 0,
        ACTION_DELETE_FLAG_NOPROMPT = 1,
    };


    /// <summary>
    ///     A list of settings that a card can query from the host.
    /// </summary>
    enum HOST_SETTING {
        HOST_SETTING_ISMESSAGEDOWNLOADING       = 0,
        HOST_SETTING_ISATTACHMENTDOWNLOADING    = 1,
        HOST_SETTING_ISSYNCINPROGRESS           = 2,
        HOST_SETTING_PREFEREDDOWNLOADFORMAT     = 3,
        HOST_SETTING_INCLUDEORIGINAL            = 4,
        HOST_SETTING_CANSMIME                   = 5,
        HOST_SETTING_RETURNADDRESS              = 6,
        HOST_SETTING_CURRENTSERVICENAME         = 7,
        HOST_SETTING_CAPABILITYCOMPOSE          = 8,
    };


    /// <summary>
    ///     Query the state of an action to determine whether this action can
    ///     be performed currently.
    /// </summary>
    /// <param name="pMessage">
    ///     [in]Reference to the IMessage object displaying in the card. 
    /// </param>
    /// <param name="pMessageCard">
    ///     [in] Reference to the IMessageCard object
    /// </param>
    /// <param name="dwAction">
    ///     [in] The action specified by the <see cref="HOST_ACTION"/> enumeration.
    /// </param>
    /// <param name="pdwActionState">
    ///     [out] The action state returned by the function. The value should be
    ///           one of the <see cref="ACTION_STATE"/> enumeration.
    /// </param>
    /// <returns>
    ///     S_OK on success, 
    ///     E_NOTIMPL if the action is not one of the enums defined in 
    ///               <see cref="HOST_ACTION"/>.
    ///     otherwise standard HRESULT error code.
    /// </returns>
    MAPIMETHOD(CanDoAction)(
        IMessage*       pMessage,
        IMessageCard*   pMessageCard, 
        DWORD           dwAction,
        DWORD*          pdwActionState 
    ) _PURE;


    /// <summary>
    ///     This is called to have the card host perform a messaging 
    ///     action (command).
    /// </summary>
    /// <param name="pMessage">
    ///     [in] Reference to the IMessage object displaying in the card. 
    /// </param>
    /// <param name="pMessageCard">
    ///     [in] Reference to the IMessageCard object
    /// </param>
    /// <param name="dwAction">
    ///     [in] The action specified by the <see cref="HOST_ACTION"/> enumeration.
    /// </param>
    /// <param name="dwActionParam">
    ///     [in] Depending on different actions, this might or might not be used.
    ///          Currently it is used by the following actions:
    ///          HOST_ACTION_TOGGLEATTACHMENTSYNC: specifying the index of an 
    ///          attachment to download/undownload.
    ///          HOST_ACTION_DELETE: specifying one of the deletion flags. The
    ///                              value should be one of the 
    ///                              <see cref="ACTION_DELETE_FLAG"/> enumeration.
    /// </param>
    /// <returns>
    ///     S_OK on success, 
    ///     S_FALSE if dwAction is HOST_ACTION_DELETE, dwActionParam is 
    ///             ACTION_DELETE_FLAG_DISPLAYPROMPT, and a user has chosen 
    ///             cancel on deletion.
    ///     E_NOTIMPL if the action is not one of the enums defined in 
    ///               <see cref="HOST_ACTION"/>.
    ///     otherwise standard HRESULT error code.
    /// </returns>
    MAPIMETHOD(DoAction)(
        IMessage* pMessage,
        IMessageCard* pMessageCard, 
        DWORD dwAction,
        DWORD dwActionParam
    ) _PURE;


    /// <summary>
    ///     This is called to query one of messaging application settings.
    /// </summary>
    /// <param name="pMessage">
    ///     [in] Reference to the IMessage object displaying in the card. 
    /// </param>
    /// <param name="dwSetting">
    ///     [in] The setting specified by the <see cref="HOST_SETTING"/> 
    ///     enumeration.
    /// </param>
    /// <param name="pVal">
    ///     [out] Pointer to a caller provided SPropValue structure to store 
    ///     the data of the queried setting.
    /// </param>
    /// <returns>
    ///     S_OK on success, 
    ///     E_NOTIMPL if the setting is not implemented by the host.
    ///     otherwise standard HRESULT error code.
    /// </returns>
    MAPIMETHOD(GetSetting)(
        IMessage*       pMessage,
        IMessageCard*   pMessageCard, 
        DWORD           dwSetting,
        LPSPropValue    pVal
    ) _PURE;
};



///<summary>
///     IMessageCard contains methods a messaging card must implement so that
///     it can be plugged into the messaging application.
///</summary>

// {eea2a286-ddc5-4827-a55d-96b8736dcb27}
static const GUID IID_IMessageCard =
{ 0xeea2a286, 0xddc5, 0x4827, { 0xa5, 0x5d, 0x96, 0xb8, 0x73, 0x6d, 0xcb, 0x27 } };

class __declspec(uuid("eea2a286-ddc5-4827-a55d-96b8736dcb27"))
IMessageCard : public IUnknown
{
public:

    /// <summary>
    ///     A set of actions indicating the purpose of SetMessage().  They
    ///     are used as the passed-in value when a card host calls SetMessage(). 
    /// </summary>
    enum MESSAGEACTION
    {
        MESSAGEACTION_UNKNOWN          = -1,

        MESSAGEACTION_FIRST            = 0,            

        MESSAGEACTION_READ             = 0,
        MESSAGEACTION_NEW              = 1, 
        MESSAGEACTION_REPLY            = 2,
        MESSAGEACTION_REPLYALL         = 3, 
        MESSAGEACTION_REPLYWITH        = 4,
        MESSAGEACTION_FORWARD          = 5,
        MESSAGEACTION_LOADFROMDRAFTS   = 6,

        MESSAGEACTION_LAST
    };
   
 
    /// <summary> 
    ///     Initialize a card object.
    /// </summary> 
    /// <param name="pHost">
    ///     [in] Reference to a IMessageCardHost object. 
    /// </param>
    /// <param name="hwndParent">
    ///     [in] The parent Window for the card window.
    /// </param>
    /// <remarks>
    ///     Initialize() should be called after CoCreateInstance(). No other 
    ///     IMessageCard methods succeed if the card object is not yet
    ///     initialized.
    /// </remarks>
    /// <returns>
    ///     S_OK on success, otherwise standard HRESULT error code.
    /// </returns>
    MAPIMETHOD(Initialize)(
            IMessageCardHost* pHost, 
            HWND              hwndParent
    ) _PURE;

    

    /// <summary> 
    ///     The host calls TranslateAccelerator() and passes the current
    ///     Window Message to the Card _prior_ to call TranslateMessage().  
    ///     This allows the Card to handle accelerator keys and other key 
    ///     strokes before the host does. This is analogous to 
    ///     IOleInPlaceActiveObject::TranslateAccelerator 
    /// </summary> 
    /// <param name="pWinMsg">
    ///     [in] Pointer to the window message that might need to be translated.
    /// </param>
    /// <returns>
    ///     S_OK 
    ///         The message was translated successfully
    ///     S_FALSE
    ///         The message was not translated.
    ///     E_ABORT
    ///         The card object is not yet initialized.
    ///     Otherwise, standard HRESULT error code.
    /// </returns>

    MAPIMETHOD(TranslateAccelerator)(
            LPMSG   pWinMsg
    ) _PURE; 



    /// <summary>
    ///     Returns the card's current window.  
    /// </summary>
    /// <remarks>
    ///     The caller should NEVER cache this value, NOR assume the window is 
    ///     valid. The returned handle is the window handle to the current card
    ///     view. It should be called after SetMessage() is called.
    /// </remarks>
    /// <returns>
    ///     Handle of the current card window.
    /// </returns>

    MAPIMETHOD_(HWND, GetHwnd)() _PURE;

    

    /// <summary>
    ///     Called by a card host to close the card. This does not imply card 
    ///     destruction since the host or other object may still hold a ref 
    ///     count to this.
    /// </summary>  
    /// <returns>
    ///     S_OK 
    ///         The card is closed successfully. 
    ///     E_ABORT
    ///         The card object is not yet initialized.
    ///     Otherwise, standard HRESULT error code.
    /// </returns>
    
    MAPIMETHOD(Close)() _PURE;


    /// <summary>
    ///     Called by a card host to set the message for various card actions.
    /// </summary>  
    /// <param name="dwActionType">
    ///     [in] Specified by the <see cref="MESSAGEACTION"/> enumeration. 
    ///          Depending on the message class of the message, if it is
    ///          MESSAGEACTION_READ, a corresponding read card view is 
    ///          displayed. Otherwise, a corresponding compose card view  
    ///          be displayed.
    /// </param>
    /// <param name="pMessage">
    ///     [in] The message to view or compose.
    /// </param>
    /// <param name="pBaseMessage">
    ///     [in] When the dwActionType is MESSAGEACTION_REPLY, 
    ///          MESSAGEACTION_REPLYALL, MESSAGEACTION_REPLYWITH, or
    ///          MESSAGEACTION_FORWARD, a base message should also provided.
    /// </param>
    /// <returns>
    ///     S_OK 
    ///         The card is closed successfully. 
    ///     E_ABORT
    ///         The card object is not yet initialized.
    ///     Otherwise, standard HRESULT error code.
    /// </returns>
    
    MAPIMETHOD(SetMessage)(
            DWORD           dwActionType,
            LPMESSAGE       pMessage,
            LPMESSAGE       pBaseMessage
    ) _PURE;


    /// <summary>
    ///     Called by a card host when the messaging application requests the
    ///     card to close all of its child windows. 
    /// </summary>  
    /// <returns>
    ///     S_OK 
    ///         The card is closed successfully. 
    ///     E_ABORT
    ///         The card object is not yet initialized.
    ///     Otherwise, standard HRESULT error code.
    /// </returns>
    
    MAPIMETHOD(CloseChildWindows)() _PURE;

};



// Used with FORMACT_LANGUAGE
//  dwFlags == Query => Form should fill uiCodePage with current CP
//  dwFlags == Select => Form should use uiCodePage as current CP
//  dwFlags == Init => Form should not refresh its data on initial CP setting
typedef struct _FORMACTLANGUAGEDATA
{
    enum
    {
        Query   = 0x01,
        Select  = 0x02,
        Init    = 0x04,
    };

    DWORD   dwFlags;
    UINT    uiCodePage;
} FORMACTLANGUAGEDATA;




// Menu extensions -- see appext.h for the definition of ItemRef
// Within the ItemRef array, pType will point to one of these GUIDs
// The value of pType determines what pRef points to as noted

// pRef will point to an SBinary structure containing the ENTRYID of a message and the size of that ENTRYID
// {412F24E9-87E6-4bd5-9820-23E9230D6E8D}
static const GUID ITI_MessageItemRef = 
{ 0x412f24e9, 0x87e6, 0x4bd5, { 0x98, 0x20, 0x23, 0xe9, 0x23, 0xd, 0x6e, 0x8d } };

// pRef will point to an SBinary structure containing the ENTRYID of a folder and the size of that ENTRYID
// {1477399E-B31D-4d3d-AFFA-070E71CA8719}
static const GUID ITI_FolderItemRef = 
{ 0x1477399e, 0xb31d, 0x4d3d, { 0xaf, 0xfa, 0x7, 0xe, 0x71, 0xca, 0x87, 0x19 } };

// pRef will point to an SBinary structure containing the ENTRYID of a store and the size of that ENTRYID
// {258E8499-B7C5-49a0-9A82-8B346D1E3976}
static const GUID ITI_StoreItemRef = 
{ 0x258e8499, 0xb7c5, 0x49a0, { 0x9a, 0x82, 0x8b, 0x34, 0x6d, 0x1e, 0x39, 0x76 } };

// pRef will point to the IMessageCard pointer of the active card
// {ddb73820-4f13-4f47-959e-0feb4c809ed1}
static const GUID ITI_MessageCardItemRef = 
{ 0xddb73820, 0x4f13, 0x4f47, { 0x95, 0x9e, 0x0f, 0xeb, 0x4c, 0x80, 0x9e, 0xd1 } };


// Error codes...

#define CEMAPI_E_PLAINTEXT_NOTSUPPORTED         MAKE_MAPI_E(0x901)
#define CEMAPI_E_PROTOCOL_ERROR                 MAKE_MAPI_E(0x902)
#define CEMAPI_E_NO_ACCOUNT_INFO                MAKE_MAPI_E(0x903)
#define CEMAPI_E_NEED_TO_CONNECT                MAKE_MAPI_E(0x904)
#define CEMAPI_E_MUST_SYNC_ONCE                 MAKE_MAPI_E(0x905)
#define CEMAPI_E_STORE_UNAVAILABLE              MAKE_MAPI_E(0x906)


#endif // eof...
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\celog.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//------------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//------------------------------------------------------------------------------
//
//  Module Name:
//
//      celog.h
//
//  Abstract:
//
//      Interface to the CELog event logging infrastructure.
//
//------------------------------------------------------------------------------
#ifndef __CELOG_H__
#define __CELOG_H__

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning(disable:4200) // nonstandard extensions warning

// This version number is used to denote significant revisions to the CeLog
// log file format, so that log file parsing tools can distinguish between logs
// from different OS versions.
#define CELOG_VERSION 3
#include <evntprov.h>
#include <evntcons.h>
#include <evntrace.h>

//------------------------------------------------------------------------------
// Common header for all event data
//------------------------------------------------------------------------------

// Header for CELOG_VERSION=1 & 2
typedef struct  __CEL_HEADER {
    DWORD   Length : 16;                // Length in bytes (excluding 32 bit header and optional 32 bit timestamp)
    DWORD   ID : 14;                    // CELID - See Below
    DWORD   Reserved : 1;               // Reserved - must be zero
    DWORD   fTimeStamp : 1;             // Is there a 32 bit TimeStamp following the header?
} CEL_HEADER, *PCEL_HEADER;

// Header for CELOG_VERSION=3
typedef struct {
    DWORD   Length : 12;                // Length in bytes (excluding 32 bit header and optional 32 bit timestamp)
    DWORD   CPU : 4;                    // CPU#, if <= 16 CPUs
    DWORD   ID : 14;                    // CELID - See Below
    DWORD   Reserved : 1;               // Reserved - must be zero
    DWORD   fTimeStamp : 1;             // Is there a 32 bit TimeStamp following the header?
} CEL_HEADER_V3, *PCEL_HEADER_V3;

#define CEL_HEADER_TIMESTAMP   0x80000000
#define CEL_HEADER_CPU_MASK    0x0000F000
#define CEL_HEADER_LENGTH_MASK 0x00000FFF
#define CEL_HEADER_ID_MASK     0x3FFF0000


//-------------------------------------------------------
// Critical Section - Only logged if we block
//
// hCS for each of these is actually the pointer to the CS
#define CELID_CS_INIT                   11
typedef struct  __CEL_CRITSEC_INIT {
    HANDLE  hCS;
} CEL_CRITSEC_INIT, *PCEL_CRITSEC_INIT;

#define CELID_CS_DELETE                 12
typedef struct  __CEL_CRITSEC_DELETE {
    HANDLE  hCS;
} CEL_CRITSEC_DELETE, *PCEL_CRITSEC_DELETE;

#define CELID_CS_ENTER                  1
typedef struct  __CEL_CRITSEC_ENTER {
    HANDLE  hCS;
    HANDLE  hOwnerThread;               // If CS already held, who owns it?
} CEL_CRITSEC_ENTER, *PCEL_CRITSEC_ENTER;

#define CELID_CS_LEAVE                  2
typedef struct  __CEL_CRITSEC_LEAVE {
    HANDLE  hCS;
    HANDLE  hOwnerThread;               // Who gets the CS next?
} CEL_CRITSEC_LEAVE, *PCEL_CRITSEC_LEAVE;


//-------------------------------------------------------
// Events
//
#define CELID_EVENT_CREATE              3
typedef struct  __CEL_EVENT_CREATE {
    HANDLE  hEvent;
    DWORD   fManual       : 1;          // Boolean - Manual Flag
    DWORD   fInitialState : 1;          // Boolean - Initial State
    DWORD   fCreate       : 1;          // Boolean - Is it a create or just an open?
    DWORD   dwReserved    : 29;
    WCHAR   szName[0];                  // OPTIONAL Name (length inferred from entry length)
} CEL_EVENT_CREATE, *PCEL_EVENT_CREATE;

#define CELID_EVENT_SET                 4
typedef struct  __CEL_EVENT_SET {
    HANDLE  hEvent;
} CEL_EVENT_SET, *PCEL_EVENT_SET;

#define CELID_EVENT_RESET               5
typedef struct  __CEL_EVENT_RESET {
    HANDLE  hEvent;
} CEL_EVENT_RESET, *PCEL_EVENT_RESET;

#define CELID_EVENT_PULSE               6
typedef struct  __CEL_EVENT_PULSE {
    HANDLE  hEvent;
} CEL_EVENT_PULSE, *PCEL_EVENT_PULSE;

#define CELID_EVENT_DELETE              8
typedef struct  __CEL_EVENT_DELETE {
    HANDLE  hEvent;
} CEL_EVENT_DELETE, *PCEL_EVENT_DELETE;


//-------------------------------------------------------
// WaitForSingleObject / WaitForMultipleObjects
//

// NOTE: currently calls to WaitForSingleObject are
// logged as calls to WaitForMultipleObjects because
// WaitForSingleObject calls WaitForMultipleObjects.

#define CELID_WAIT_MULTI                9
typedef struct  __CEL_WAIT_MULTI {
    DWORD   dwTimeout;
    DWORD   fWaitAll   : 1;
    DWORD   dwReserved : 31;
    HANDLE  hHandles[0];                // List of handles, count indicated by length
} CEL_WAIT_MULTI, *PCEL_WAIT_MULTI;     // Max # handles = MAXIMUM_WAIT_OBJECTS


//-------------------------------------------------------
// Sleep
//
#define CELID_SLEEP                     10
typedef struct  __CEL_SLEEP {
    DWORD   dwTimeout;
} CEL_SLEEP, *PCEL_SLEEP;


//-------------------------------------------------------
// Semaphores
//
#define CELID_SEM_CREATE                15
typedef struct  __CEL_SEM_CREATE {
    HANDLE  hSem;
    DWORD   dwInitCount;
    DWORD   dwMaxCount;
    WCHAR   szName[0];                  // OPTIONAL Name (length inferred from entry length)
} CEL_SEM_CREATE, *PCEL_SEM_CREATE;

#define CELID_SEM_RELEASE               16
typedef struct  __CEL_SEM_RELEASE {
    HANDLE  hSem;
    DWORD   dwReleaseCount;
    DWORD   dwPreviousCount;
} CEL_SEM_RELEASE, *PCEL_SEM_RELEASE;

#define CELID_SEM_DELETE                18
typedef struct  __CEL_SEM_DELETE {
    HANDLE  hSem;
} CEL_SEM_DELETE, *PCEL_SEM_DELETE;


//-------------------------------------------------------
// Heap
//
#define CELID_HEAP_CREATE               25
typedef struct  __CEL_HEAP_CREATE {
    DWORD   dwOptions;
    DWORD   dwInitSize;
    DWORD   dwMaxSize;
    HANDLE  hHeap;
    DWORD   dwTID;
    DWORD   dwPID;
} CEL_HEAP_CREATE, *PCEL_HEAP_CREATE;

#define CELID_HEAP_ALLOC                26
typedef struct  __CEL_HEAP_ALLOC {
    HANDLE  hHeap;
    DWORD   dwFlags;
    DWORD   dwBytes;
    DWORD   lpMem;
    DWORD   dwTID;
    DWORD   dwPID;
    DWORD   dwCallerPID;
    DWORD   adwStackTrace[0];
} CEL_HEAP_ALLOC, *PCEL_HEAP_ALLOC;

#define CELID_HEAP_REALLOC              27
typedef struct  __CEL_HEAP_REALLOC {
    HANDLE  hHeap;
    DWORD   dwFlags;
    DWORD   dwBytes;
    DWORD   lpMemOld;
    DWORD   lpMem;
    DWORD   dwTID;
    DWORD   dwPID;
    DWORD   dwCallerPID;
    DWORD   adwStackTrace[0];
} CEL_HEAP_REALLOC, *PCEL_HEAP_REALLOC;

#define CELID_HEAP_FREE                 28
typedef struct  __CEL_HEAP_FREE {
    HANDLE  hHeap;
    DWORD   dwFlags;
    DWORD   lpMem;
    DWORD   dwTID;
    DWORD   dwPID;
    DWORD   dwCallerPID;
    DWORD   adwStackTrace[0];
} CEL_HEAP_FREE, *PCEL_HEAP_FREE;

#define CELID_HEAP_DESTROY              29
typedef struct  __CEL_HEAP_DESTROY {
    HANDLE  hHeap;
    DWORD   dwTID;
    DWORD   dwPID;
} CEL_HEAP_DESTROY, *PCEL_HEAP_DESTROY;


//-------------------------------------------------------
// Virtual Memory
//
#define CELID_VIRTUAL_ALLOC_EX          32
typedef struct  __CEL_VIRTUAL_ALLOC_EX {
    HANDLE  hProcess;                   // This is really the process ID
    DWORD   dwResult;
    DWORD   dwAddress;
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   dwProtect;
} CEL_VIRTUAL_ALLOC_EX, *PCEL_VIRTUAL_ALLOC_EX;

#define CELID_VIRTUAL_COPY_EX           33
typedef struct  __CEL_VIRTUAL_COPY_EX {
    HANDLE  hDestProc;                  // This is really the process ID
    DWORD   dwDest;
    HANDLE  hSrcProc;                   // This is really the process ID
    DWORD   dwSource;
    DWORD   dwSize;
    DWORD   dwProtect;
} CEL_VIRTUAL_COPY_EX, *PCEL_VIRTUAL_COPY_EX;

#define CELID_VIRTUAL_FREE_EX           34
typedef struct  __CEL_VIRTUAL_FREE_EX {
    HANDLE  hProcess;                   // This is really the process ID
    DWORD   dwAddress;
    DWORD   dwSize;
    DWORD   dwType;
} CEL_VIRTUAL_FREE_EX, *PCEL_VIRTUAL_FREE_EX;


//-------------------------------------------------------
//  Paging and memory-mapped files

// Page-in event for non-XIP code and for memory-mapped file data.  Used for
// beginning and end of page fault.
#define CELID_SYSTEM_PAGE_IN            111
typedef struct __CEL_SYSTEM_PAGE_IN {
    DWORD   dwAddress;
    DWORD   fReadWrite : 1;             // 0=read-only, 1=read/write (only used on start of page-in)
    DWORD   fEndPageIn : 1;             // 0=start of page-in, 1=end of page-in
    DWORD   fSuccess   : 1;             // 0=failed, 1=success (only used on end of page-in)
    DWORD   dwReserved : 29;
    HANDLE  hProcess;                   // This is really the process ID
} CEL_SYSTEM_PAGE_IN, *PCEL_SYSTEM_PAGE_IN;

// Page-out event: Struct TBD
#define CELID_SYSTEM_PAGE_OUT           79


#define CELID_MAPFILE_CREATE_EX         112
typedef struct {
    HANDLE  hMap;
    DWORD   flProtect;
    DWORD   dwMapFlags;
    DWORD   dwMaxSizeHigh;
    DWORD   dwMaxSizeLow;
    WCHAR   szName[0];                  // OPTIONAL Name (length inferred from entry length)
} CEL_MAPFILE_CREATE_EX, *PCEL_MAPFILE_CREATE_EX;

#define CELID_MAPFILE_DESTROY           39
typedef struct {
    HANDLE  hMap;
} CEL_MAPFILE_DESTROY, *PCEL_MAPFILE_DESTROY;

#define CELID_MAPFILE_VIEW_OPEN_EX      113
typedef struct {
    HANDLE  hMap;
    HANDLE  hProcess;                   // This is really the process ID
    DWORD   dwDesiredAccess;
    DWORD   dwFileOffsetHigh;
    DWORD   dwFileOffsetLow;
    DWORD   dwLen;
    LPVOID  lpBaseAddress;
} CEL_MAPFILE_VIEW_OPEN_EX, *PCEL_MAPFILE_VIEW_OPEN_EX;

#define CELID_MAPFILE_VIEW_CLOSE        41
typedef struct {
    HANDLE  hProcess;                   // This is really the process ID
    LPVOID  lpBaseAddress;
} CEL_MAPFILE_VIEW_CLOSE, *PCEL_MAPFILE_VIEW_CLOSE;

#define CELID_MAPFILE_VIEW_FLUSH        114
typedef struct {
    HANDLE  hProcess;                   // This is really the process ID
    LPVOID  lpBaseAddress;              // Start of range being flushed.
    DWORD   dwLen;                      // Length (bytes) of range being flushed
    DWORD   dwNumPages;                 // Number of dirty pages in view
    WORD    wFlushFlags;                // Flags and flush type, as defined below
} CEL_MAPFILE_VIEW_FLUSH, *PCEL_MAPFILE_VIEW_FLUSH;

// wFlushFlags 
#define CEL_MAPFLUSH_FLAGMASK           ((WORD)0xFFF0)  // 12 bits flags
#define CEL_MAPFLUSH_TYPEMASK           ((WORD)0x000F)  // 4 bits type
typedef enum {
    CEL_INVALID_MAPFLUSH    = 0,  // Reserved value
    CEL_FlushMapSimple      = 1,
    CEL_FlushMapAtomic      = 2,
    CEL_ValidateFile        = 3,
    CEL_FlushMapGather      = 4,

    CEL_NUM_MAPFLUSH_TYPES  // Count of types
} CEL_MAPFLUSH_TYPE;
#define CEL_MAPFLUSH_BEGIN              0x00000010  // clear=end of call; set=begin
#define CEL_MAPFLUSH_FULLDISCARD        0x00000020  // set=FMB_DOFULLDISCARD flag set
#define CEL_MAPFLUSH_NOWRITEOUT         0x00000040  // set=FMB_NOWRITEOUT flag set

#define CELID_CACHE_ALLOCVIEW           115
#define CELID_CACHE_FREEVIEW            116
#define CELID_CACHE_FLUSHVIEW           117


//-------------------------------------------------------
// Scheduler
//
#define CELID_THREAD_SWITCH             45
typedef struct  __CEL_THREAD_SWITCH {
    HANDLE  hThread;                    // This is really the thread ID
} CEL_THREAD_SWITCH, *PCEL_THREAD_SWITCH;

#define CELID_THREAD_MIGRATE            46
typedef struct  __CEL_THREAD_MIGRATE {
    HANDLE  hProcess;                   // This is really the process ID
    DWORD   dwReserved;
} CEL_THREAD_MIGRATE, *PCEL_THREAD_MIGRATE;

#define CELID_THREAD_CREATE             47
typedef struct  __CEL_THREAD_CREATE {
    HANDLE  hThread;                    // This is really the thread ID
    HANDLE  hProcess;                   // This is really the process ID
    HANDLE  hModule;
    DWORD   dwStartAddr;
    int     nPriority;
    WCHAR   szName[0];                  // OPTIONAL Name (length inferred from entry length)
} CEL_THREAD_CREATE, *PCEL_THREAD_CREATE;

#define CELID_THREAD_TERMINATE          49
typedef struct __CEL_THREAD_TERMINATE {
    HANDLE  hThread;                    // This is really the thread ID
} CEL_THREAD_TERMINATE, *PCEL_THREAD_TERMINATE;

#define CELID_THREAD_DELETE             50
typedef struct __CEL_THREAD_DELETE {
    HANDLE  hThread;                    // This is really the thread ID
} CEL_THREAD_DELETE, *PCEL_THREAD_DELETE;

#define CELID_PROCESS_CREATE            51
typedef struct  __CEL_PROCESS_CREATE {
    HANDLE  hProcess;                   // This is really the process ID
    DWORD   dwVMBase;
    WCHAR   szName[0];                  // OPTIONAL Name (length inferred from entry length)
} CEL_PROCESS_CREATE, *PCEL_PROCESS_CREATE;

#define CELID_PROCESS_TERMINATE         53
typedef struct __CEL_PROCESS_TERMINATE {
    HANDLE  hProcess;                   // This is really the process ID
} CEL_PROCESS_TERMINATE, *PCEL_PROCESS_TERMINATE;

#define CELID_PROCESS_DELETE            54
typedef struct __CEL_PROCESS_DELETE {
    HANDLE  hProcess;                   // This is really the process ID
} CEL_PROCESS_DELETE, *PCEL_PROCESS_DELETE;

#define CELID_THREAD_SUSPEND            55
typedef struct __CEL_THREAD_SUSPEND {
    HANDLE  hThread;                    // This is really the thread ID
} CEL_THREAD_SUSPEND, *PCEL_THREAD_SUSPEND;

#define CELID_THREAD_RESUME             56
typedef struct __CEL_THREAD_RESUME {
    HANDLE  hThread;                    // This is really the thread ID
} CEL_THREAD_RESUME, *PCEL_THREAD_RESUME;

#define CELID_THREAD_QUANTUMEXPIRE      57  // No related struct


// Extra information that is not logged in the CEL_PROCESS_CREATE struct
#define CELID_EXTRA_PROCESS_INFO        58
typedef struct  __CEL_EXTRA_PROCESS_INFO {
    HANDLE  hProcess;                   // This is really the process ID
    DWORD   dwCodeBase;                 // Start address where the exe code is loaded
    DWORD   dwVMLen;                    // Length of exe code that starts at dwCodeBase
    DWORD   dwOID;                      // Non-zero if valid file OID, zero if file is not in RAM/ROM file system
    WCHAR   szFullPath[0];              // Full path to exe, if file is not in RAM/ROM file system (length inferred from entry length)
} CEL_EXTRA_PROCESS_INFO, *PCEL_EXTRA_PROCESS_INFO;


#define CELID_SYSTEM_INVERT             82
typedef struct __CEL_SYSTEM_INVERT {
    HANDLE  hThread;                    // This is really the thread ID
    int     nPriority;
} CEL_SYSTEM_INVERT, *PCEL_SYSTEM_INVERT;

#define CELID_THREAD_PRIORITY           83
typedef struct __CEL_THREAD_PRIORITY {
    HANDLE  hThread;                    // This is really the thread ID
    int     nPriority;
} CEL_THREAD_PRIORITY, *PCEL_THREAD_PRIORITY;

#define CELID_THREAD_QUANTUM            84
typedef struct __CEL_THREAD_QUANTUM {
    HANDLE  hThread;                    // This is really the thread ID
    DWORD   dwQuantum;
} CEL_THREAD_QUANTUM, *PCEL_THREAD_QUANTUM;


//-------------------------------------------------------
// Modules / Loader
//

#define CELID_MODULE_LOAD               85
typedef struct __CEL_MODULE_LOAD {
    HANDLE  hProcess;                   // This is really the process ID
    HANDLE  hModule;
    DWORD   dwBase;
    WCHAR   szName[0];                  // OPTIONAL Name (length inferred from entry length)
} CEL_MODULE_LOAD, *PCEL_MODULE_LOAD;

#define CELID_MODULE_FREE               86
typedef struct __CEL_MODULE_FREE {
    HANDLE  hProcess;                   // This is really the process ID
    HANDLE  hModule;
} CEL_MODULE_FREE, *PCEL_MODULE_FREE;

#define CELID_MODULE_FAILED_LOAD        119
// NOTE: the data stored in the file will usually be SMALLER than this struct, because it
// will only contain as many characters as needed for the name - likely less than MAX_PATH.
typedef struct __CEL_MODULE_FAILED_LOAD {
    DWORD dwProcessId;                  // Same as hProcess from other CeLog events
    DWORD dwFlags;
    DWORD dwError;
    WCHAR szName[MAX_PATH];             // Name (length is inferred from entry length - between 0 and MAX_PATH)
} CEL_MODULE_FAILED_LOAD, *PCEL_MODULE_FAILED_LOAD;

// If set, module is being loaded into the kernel; if clear, module is loaded
// into a different process.
#define CEL_MODULE_FLAG_KERNEL          ((DWORD)1)
// If set, module is only being loaded for data, eg. resources; if clear,
// module code is also being executed.
#define CEL_MODULE_FLAG_DATAONLY        ((DWORD)2)

// Extra information that is not logged in the CEL_MODULE_LOAD struct
#define CELID_EXTRA_MODULE_INFO         98
typedef struct  __CEL_EXTRA_MODULE_INFO {
    HANDLE  hModule;
    DWORD   dwVMLen;                    // Code length, to complement dwVMBase from the CEL_MODULE_LOAD struct
    DWORD   dwModuleFlags;              // Bitmask of CEL_MODULE_FLAG_* describing module state
    DWORD   dwOID;                      // Non-zero if valid file OID, zero if file is not in RAM/ROM file system
    WCHAR   szFullPath[0];              // Full path to dll, if file is not in RAM/ROM file system (length inferred from entry length)
} CEL_EXTRA_MODULE_INFO, *PCEL_EXTRA_MODULE_INFO;


typedef struct __CEL_PROCESS_REFCOUNT {
    HANDLE  hProcess;                   // This is really the process ID
    DWORD   dwRefCount;
} CEL_PROCESS_REFCOUNT, *PCEL_PROCESS_REFCOUNT;

// List of process refcounts for a module
#define CELID_MODULE_REFERENCES         97
typedef struct __CEL_MODULE_REFERENCES {
    HANDLE  hModule;
    CEL_PROCESS_REFCOUNT ref[1];        // Array of refcounts (length inferred from entry length)
} CEL_MODULE_REFERENCES, *PCEL_MODULE_REFERENCES;



//-------------------------------------------------------
// Mutexes
//
#define CELID_MUTEX_CREATE              60
typedef struct  __CEL_MUTEX_CREATE {
    HANDLE  hMutex;
    WCHAR   szName[0];                  // OPTIONAL Name (length inferred from entry length)
} CEL_MUTEX_CREATE, *PCEL_MUTEX_CREATE;

#define CELID_MUTEX_RELEASE             61
typedef struct __CEL_MUTEX_RELEASE {
    HANDLE  hMutex;
} CEL_MUTEX_RELEASE, *PCEL_MUTEX_RELEASE;

#define CELID_MUTEX_DELETE              63
typedef struct __CEL_MUTEX_DELETE {
    HANDLE  hMutex;
} CEL_MUTEX_DELETE, *PCEL_MUTEX_DELETE;


//-------------------------------------------------------
// Data types for logging raw data

#define CELID_RAW_LONG                  70
#define CELID_RAW_ULONG                 71
#define CELID_RAW_SHORT                 72
#define CELID_RAW_USHORT                73
#define CELID_RAW_WCHAR                 74
#define CELID_RAW_CHAR                  75
#define CELID_RAW_UCHAR                 76
#define CELID_RAW_FLOAT                 77
#define CELID_RAW_DOUBLE                78

// To log raw data, call CELOGDATA or CELOGDATAFLAGGED directly.  For example:
//
// CELOGDATA(TRUE, CELID_RAW_LONG, &lMyData, (WORD) (iMyDataLen * sizeof(LONG)),
//           1, CELZONE_MISC);
//
// CELOGDATAFLAGGED(TRUE, CELID_RAW_LONG, &lMyData, (WORD) (iMyDataLen * sizeof(LONG)),
//           1, CELZONE_MISC, wMyFlag);
//
// Make sure to include the null character at the end of a string.


//-------------------------------------------------------
// Miscellaneous

#define CELID_SYSTEM_TLB                80
typedef struct __CEL_SYSTEM_TLB {
    DWORD   dwCount;
} CEL_SYSTEM_TLB, *PCEL_SYSTEM_TLB;
                       
#define CELID_INTERRUPTS                87
typedef struct __CEL_INT_DATA {
    DWORD   dwTimeStamp;
    WORD    wSysIntr;
    WORD    wNestingLevel;
} CEL_INT_DATA, *PCEL_INT_DATA;

typedef struct __CEL_INTERRUPTS {
    DWORD   dwDiscarded;                // Number of interrupts not logged.
    CEL_INT_DATA IntData[0];            // variable number of interrupts
} CEL_INTERRUPTS, *PCEL_INTERRUPTS;

// Used to keep track of entry/exit from kcalls (implies a single int of data)
#define CELID_KCALL_ENTER               88
#define CELID_KCALL_LEAVE               89

// Do not log directly using CELID_FLAGGED.  Instead use the CELOGDATAFLAGGED macro.
#define CELID_FLAGGED                   90

//  Callstack data always refers to the previous event in the log
#define CELID_CALLSTACK                 91
// Data will be an array of DWORDs (like adwStackTrace in the memtrack structs)
#define CELID_CALLSTACK_EX              95
// Data will be the output of GetThreadCallStack with STACKSNAP_NEW_VM.

// CePerf events are defined separately.
#define CELID_CEPERF                    92

// For timer events the most important data is the timestamp.  Use flags to 
// distinguish between different timers.  A Unicode string may optionally be
// included as the "data" buffer.
#define CELID_TIMER_START               93
#define CELID_TIMER_STOP                94

// Out of Memory condition detected and signalled by kernel
#define CELID_LOWMEM_SIGNALLED          96
typedef struct __CEL_LOWMEM_DATA {
    long pageFreeCount;
    int  cpNeed;
    long cpLowThreshold;
    long cpCriticalThreshold;
    long cpLowBlockSize;
    long cpCriticalBlockSize;
} CEL_LOWMEM_DATA, *PCEL_LOWMEM_DATA;


//-------------------------------------------------------
//  Memtrack

// Detach is a false process terminate used to terminate the memtrack session
#define CELID_MEMTRACK_DETACHP          99
typedef CEL_PROCESS_TERMINATE CEL_MEMTRACK_DETACHP, *PCEL_MEMTRACK_DETACHP;

#define CELID_MEMTRACK_BASELINE         102
typedef struct __CEL_MEMTRACK_BASELINE {
    DWORD dwReserved;
} CEL_MEMTRACK_BASELINE, *PCEL_MEMTRACK_BASELINE;


//-------------------------------------------------------
// Boot time

#define CELID_BOOT_TIME    103
typedef struct _CEL_BOOT_TIME {
    DWORD dwAction;
        #define BOOT_TIME_LAUNCHING_FS 01
        #define BOOT_TIME_FS_INITED 10
        #define BOOT_TIME_FS_OBJ_STORE_INITIALIZED 11
        #define BOOT_TIME_FS_FILES_INITIALIZED 12
        #define BOOT_TIME_FS_REG_INITIALIZED 13
        #define BOOT_TIME_FS_DB_INITIALIZED 14
        #define BOOT_TIME_FS_LAUNCH 15
        #define BOOT_TIME_DEV_ACTIVATE 20
        #define BOOT_TIME_DEV_FINISHED 21
        #define BOOT_TIME_GWES_FINISHED 30
        #define BOOT_TIME_SYSTEM_STARTED 40
        #define BOOT_TIME_START_DELAYED_WORK 50
    WCHAR szName[0];
} CEL_BOOT_TIME, *PCEL_BOOT_TIME;


//-------------------------------------------------------
// CELog GDI calls
#define CELID_GDI                       104
typedef struct _CEL_GDI_INFO {
    DWORD   dwGDIOp;
#define CEL_GDI_AddFontResource             0
#define CEL_GDI_PatBlt                      1
#define CEL_GDI_BitBlt                      2
#define CEL_GDI_CombineRgn                  3
#define CEL_GDI_CreateBitmap                4
#define CEL_GDI_CreateCompatibleBitmap      5
#define CEL_GDI_CreateCompatibleDC          6
#define CEL_GDI_CreateDIBPatternBrushPt     7
#define CEL_GDI_CreateFontIndirectW         8
#define CEL_GDI_CreateRectRgnIndirect       9
#define CEL_GDI_CreatePenIndirect           10
#define CEL_GDI_CreateSolidBrush            11
#define CEL_GDI_DeleteDC                    12
#define CEL_GDI_DeleteObject                13
#define CEL_GDI_DrawEdge                    14
#define CEL_GDI_DrawFocusRect               15
#define CEL_GDI_DrawTextW                   16
#define CEL_GDI_Ellipse                     17
#define CEL_GDI_EnumFontFamiliesW           18
#define CEL_GDI_EnumFontsW                  19
#define CEL_GDI_ExcludeClipRect             20
#define CEL_GDI_ExtTextOutW                 21
#define CEL_GDI_SetTextAlign                22
#define CEL_GDI_GetTextAlign                23
#define CEL_GDI_FillRect                    24
#define CEL_GDI_GetBkColor                  25
#define CEL_GDI_GetBkMode                   26
#define CEL_GDI_GetClipRgn                  27
#define CEL_GDI_GetClipBox                  28
#define CEL_GDI_GetCurrentObject            29
#define CEL_GDI_GetDeviceCaps               30
#define CEL_GDI_GetNearestColor             31
#define CEL_GDI_GetObjectW                  32
#define CEL_GDI_GetObjectType               33
#define CEL_GDI_GetPixel                    34
#define CEL_GDI_GetRegionData               35
#define CEL_GDI_GetSysColorBrush            36
#define CEL_GDI_GetRgnBox                   37
#define CEL_GDI_GetStockObject              38
#define CEL_GDI_GetTextColor                39
#define CEL_GDI_GetTextExtentExPointW       40
#define CEL_GDI_GetTextFaceW                41
#define CEL_GDI_GetTextMetricsW             42
#define CEL_GDI_GetCharWidth32              43
#define CEL_GDI_IntersectClipRect           44
#define CEL_GDI_MaskBlt                     45
#define CEL_GDI_OffsetRgn                   46
#define CEL_GDI_MoveToEx                    47
#define CEL_GDI_LineTo                      48
#define CEL_GDI_GetCurrentPositionEx        49
#define CEL_GDI_Polygon                     50
#define CEL_GDI_Polyline                    51
#define CEL_GDI_PtInRegion                  52
#define CEL_GDI_Rectangle                   53
#define CEL_GDI_RectInRegion                54
#define CEL_GDI_RemoveFontResourceW         55
#define CEL_GDI_RestoreDC                   56
#define CEL_GDI_RoundRect                   57
#define CEL_GDI_SaveDC                      58
#define CEL_GDI_SelectClipRgn               59
#define CEL_GDI_SelectObject                60
#define CEL_GDI_SetBkColor                  61
#define CEL_GDI_SetBkMode                   62
#define CEL_GDI_SetBrushOrgEx               63
#define CEL_GDI_SetPixel                    64
#define CEL_GDI_SetTextColor                65
#define CEL_GDI_StretchBlt                  66
#define CEL_GDI_StretchDIBits               67
#define CEL_GDI_CloseEnhMetaFile            68
#define CEL_GDI_CreateEnhMetaFileW          69
#define CEL_GDI_DeleteEnhMetaFile           70
#define CEL_GDI_PlayEnhMetaFile             71
#define CEL_GDI_CreatePalette               72
#define CEL_GDI_SelectPalette               73
#define CEL_GDI_RealizePalette              74
#define CEL_GDI_GetPaletteEntries           75
#define CEL_GDI_SetPaletteEntries           76
#define CEL_GDI_GetSystemPaletteEntries     77
#define CEL_GDI_GetNearestPaletteIndex      78
#define CEL_GDI_GetDIBColorTable            79
#define CEL_GDI_SetDIBColorTable            80
#define CEL_GDI_CreatePen                   81
#define CEL_GDI_StartDocW                   82
#define CEL_GDI_EndDoc                      83
#define CEL_GDI_StartPage                   84
#define CEL_GDI_EndPage                     85
#define CEL_GDI_AbortDoc                    86
#define CEL_GDI_SetAbortProc                87
#define CEL_GDI_CreateDCW                   88
#define CEL_GDI_CreateRectRgn               89
#define CEL_GDI_ExtCreateRegion             90
#define CEL_GDI_FillRgn                     91
#define CEL_GDI_SetROP2                     92
#define CEL_GDI_RectVisible                 93
#define CEL_GDI_SetRectRgn                  94
#define CEL_GDI_CreatePatternBrush          95
#define CEL_GDI_CreateBitmapFromPointer     96
#define CEL_GDI_SetViewportOrgEx            97
#define CEL_GDI_TransparentImage            98
#define CEL_GDI_TranslateCharsetInfo        99
#define CEL_GDI_ExtEscape                   100
#define CEL_GDI_SetDIBitsToDevice           101
#define CEL_GDI_GradientFill                102
#define CEL_GDI_InvertRect                  103
#define CEL_GDI_GetCharABCWidths            104
#define CEL_GDI_GetStretchBltMode           105
#define CEL_GDI_SetStretchBltMode           106
#define CEL_GDI_SetLayout                   107
#define CEL_GDI_GetLayout                   108
#define CEL_GDI_BitmapEscape                109

    DWORD   dwEntryTime;    // Entry time is saved in this struct, exit time is logged with event
    DWORD   dwContext;      // Usually dest DC involved.
    DWORD   dwContext2;
    DWORD   dwContext3;
    DWORD   dwContext4;
} CEL_GDI_INFO, *PCEL_GDI_INFO;


//-------------------------------------------------------
// CELog RDP Info
#define CELID_RDP                       105
typedef struct _CEL_RDP_INFO {
    BYTE    bOrderType;
    BYTE    bOrder;
    DWORD   dwTimeSpent;    // If -1 then start of operation.
} CEL_RDP_INFO, *PCEL_RDP_INFO;


//-------------------------------------------------------
//  Kernel Profiler Events

// NOTENOTE the structs that correspond to these events are not exposed to
// applications, see profiler.h in the OAK.

#define CELID_PROFILER_START            106
#define CELID_PROFILER_STOP             107
#define CELID_PROFILER_MARK             125
#define CELID_PROFILER_NAME             126

#define CELID_MONTECARLO_HIT            108
#define CELID_OEMPROFILER_HIT           109
#define CELID_APP_PROFILER_HIT          118

#define CELID_CAP_OVERHEAD              120
#define CELID_CALLCAP_ENTER             121
#define CELID_CALLCAP_EXIT              122
#define CELID_FASTCAP_ENTER             123
#define CELID_FASTCAP_EXIT              124


//-------------------------------------------------------
//  Kernel Debug Events

#define CELID_DEBUG_MSG                 69
typedef struct  _CEL_DEBUG_MSG {
    DWORD pid;
    DWORD tid;
    WCHAR szMessage[0];
} CEL_DEBUG_MSG, *PCEL_DEBUG_MSG;

#define CELID_DEBUG_TRAP                110
typedef struct _CEL_DEBUG_TRAP {
    WORD wFlags;

#define CEL_DEBUG_TRAP_SECONDCHANCE         0x0001

    WORD cbStackTraceOffset;
    EXCEPTION_RECORD er;
    CONTEXT context;
    DWORD adwStackTrace[0];
} CEL_DEBUG_TRAP, *PCEL_DEBUG_TRAP;


//-------------------------------------------------------
//  GWES Events

// Reserved range of events for GWES to log
#define CELID_GWES                      200
#define CELID_GWES_MAX                  299


//-------------------------------------------------------

// Eventlog Events


#define CELID_EVENTLOG_CHANNEL_MSG           300
typedef struct _CEL_EVENTLOG_CHANNEL_MSG {
    GUID ProviderID;
    DWORD CPUType;
    EVENT_DESCRIPTOR EventDescriptor;
    DWORD cbUserData;
    DWORD eUserDataCount;
    DWORD SequenceNumber;
    DWORD AlignmentPadding;
    BYTE UserData[4];
} CEL_EVENTLOG_CHANNEL_MSG, *PCEL_EVENTLOG_CHANNEL_MSG;

#define CELID_EVENTLOG_WPP_HEADER           301

/*  This may be necessary later, so don't delete it immediately.
typedef struct _CEL_EVENTLOG_WPP_CLOSE {
    LARGE_INTEGER StopTime;
}CEL_EVENTLOG_WPP_CLOSE, *PCEL_EVENTLOG_WPP_CLOSE;
*/

//
// The MESSAGE_TRACE_HEADERS and their data will immediately follow this structure
//
#define CELID_EVENTLOG_WPP_MSG           302
typedef struct _CEL_EVENTLOG_WPP_MSG {
    DWORD cMissedEvents;
//    LARGE_INTEGER FlushTime;  Take the flush time from the event. 
    FILETIME KernelTime;
    FILETIME UserTime;
} CEL_EVENTLOG_WPP_MSG, *PCEL_EVENTLOG_WPP_MSG;



//-------------------------------------------------------
// CELog control info

#define CELID_DATA_LOSS                 150
typedef struct  __CEL_DATA_LOSS {
    DWORD  dwBytes;                     // Number of bytes lost
} CEL_DATA_LOSS, *PCEL_DATA_LOSS;

#define CELID_SYNC_END                  0x1FFE      // No struct, just a header

#define CELID_LOG_MARKER                0x1FFF

// Marker for CELOG_VERSION=1 & 2
typedef struct __CEL_LOG_MARKER {
   DWORD   dwFrequency;                 // TimeStamp counter frequency
   DWORD   dwDefaultQuantum;
   DWORD   dwVersion;
} CEL_LOG_MARKER, *PCEL_LOG_MARKER;

// Marker for CELOG_VERSION=3
typedef struct {
   DWORD   dwFrequency;                 // TimeStamp counter frequency
   DWORD   dwDefaultQuantum;
   DWORD   dwVersion;
   DWORD   dwNumCPUs;                   // Number of CPUs on the device
} CEL_LOG_MARKER_V3, *PCEL_LOG_MARKER_V3;

#define CELID_USER                      0x2000      // Min value for User ID
#define CELID_MAX                       0x3FFF      // Max value for User ID


//-------------------------------------------------------
// Deprecated events that are no longer logged by the system.
// These events are only included in celog.h for backward
// compatibility reasons.

// The OS no longer logs the CELID_EVENT_CLOSE event.
#define CELID_EVENT_CLOSE               7
typedef struct  __CEL_EVENT_CLOSE {
    HANDLE  hEvent;
} CEL_EVENT_CLOSE, *PCEL_EVENT_CLOSE;

// The OS no longer logs the CELID_SEM_CLOSE event.
#define CELID_SEM_CLOSE                 17
typedef struct  __CEL_SEM_CLOSE {
    HANDLE  hSem;
} CEL_SEM_CLOSE, *PCEL_SEM_CLOSE;

// The OS no longer logs the CELID_THREAD_CLOSE event.
#define CELID_THREAD_CLOSE              48
typedef struct __CEL_THREAD_CLOSE {
    HANDLE  hThread;
} CEL_THREAD_CLOSE, *PCEL_THREAD_CLOSE;

// The OS no longer logs the CELID_PROCESS_CLOSE event.
#define CELID_PROCESS_CLOSE             52
typedef struct __CEL_PROCESS_CLOSE {
    HANDLE  hProcess;
} CEL_PROCESS_CLOSE, *PCEL_PROCESS_CLOSE;

// The OS no longer logs the CELID_MUTEX_CLOSE event.
#define CELID_MUTEX_CLOSE               62
typedef struct __CEL_MUTEX_CLOSE {
    HANDLE  hMutex;
} CEL_MUTEX_CLOSE, *PCEL_MUTEX_CLOSE;

// The OS now logs CELID_VIRTUAL_ALLOC_EX instead of CELID_VIRTUAL_ALLOC.
#define CELID_VIRTUAL_ALLOC             35
typedef struct  __CEL_VIRTUAL_ALLOC {
    DWORD   dwResult;
    DWORD   dwAddress;
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   dwProtect;
    BYTE    bReserved[0];
} CEL_VIRTUAL_ALLOC, *PCEL_VIRTUAL_ALLOC;

// The OS now logs CELID_VIRTUAL_COPY_EX instead of CELID_VIRTUAL_COPY.
#define CELID_VIRTUAL_COPY              36
typedef struct  __CEL_VIRTUAL_COPY {
    DWORD   dwDest;
    DWORD   dwSource;
    DWORD   dwSize;
    DWORD   dwProtect;
} CEL_VIRTUAL_COPY, *PCEL_VIRTUAL_COPY;

// The OS now logs CELID_VIRTUAL_FREE_EX instead of CELID_VIRTUAL_FREE.
#define CELID_VIRTUAL_FREE              37
typedef struct  __CEL_VIRTUAL_FREE {
    DWORD   dwAddress;
    DWORD   dwSize;
    DWORD   dwType;
    BYTE    bReserved[0];
} CEL_VIRTUAL_FREE, *PCEL_VIRTUAL_FREE;

// The OS now logs CELID_SYSTEM_PAGE_IN instead of CELID_SYSTEM_PAGE.
#define CELID_SYSTEM_PAGE               81
typedef struct __CEL_SYSTEM_PAGE {
    DWORD   dwAddress;
    DWORD   fReadWrite : 1;             // 0=read-only, 1=read/write (only used on start of page-in)
    DWORD   fEndPageIn : 1;             // 0=start of page-in, 1=end of page-in
    DWORD   fSuccess   : 1;             // 0=failed, 1=success (only used on end of page-in)
    DWORD   dwReserved : 29;
} CEL_SYSTEM_PAGE, *PCEL_SYSTEM_PAGE;

// The OS now logs CELID_MAPFILE_CREATE_EX instead of CELID_MAPFILE_CREATE.
#define CELID_MAPFILE_CREATE            38
typedef struct {
    HANDLE  hMap;
    DWORD   flProtect;
    DWORD   dwMapFlags;
    DWORD   dwMaxSize;
    WCHAR   szName[0];                  // OPTIONAL Name (length inferred from entry length)
} CEL_MAPFILE_CREATE, *PCEL_MAPFILE_CREATE;

// The OS now logs CELID_MAPFILE_VIEW_OPEN_EX instead of CELID_MAPFILE_VIEW_OPEN.
#define CELID_MAPFILE_VIEW_OPEN         40
typedef struct {
    HANDLE  hMap;
    HANDLE  hProcess;
    DWORD   dwDesiredAccess;
    DWORD   dwFileOffset;
    DWORD   dwLen;
    LPVOID  lpBaseAddress;
} CEL_MAPFILE_VIEW_OPEN, *PCEL_MAPFILE_VIEW_OPEN;

// The OS now logs CELID_MAPFILE_VIEW_FLUSH instead of CELID_MAPFILE_FLUSH.
#define CELID_MAPFILE_FLUSH             42
typedef struct {
    LPVOID  lpBaseAddress;              // Start of range being flushed.
    DWORD   dwLen;                      // Length (bytes) of range being flushed
    WORD    wFlushFlags;                // Flags and flush type, as defined below
    WORD    wNumPages;                  // Number of dirty pages to flush
} CEL_MAPFILE_FLUSH, *PCEL_MAPFILE_FLUSH;


//-------------------------------------------------------
// Logging zones.
//

// NOTENOTE New zones must be added to AVAILABLE_ZONES in nk\kernel\logger.c
// before they can be used.
#define CELZONE_INTERRUPT    0x00000001
#define CELZONE_RESCHEDULE   0x00000002
#define CELZONE_MIGRATE      0x00000004
#define CELZONE_TLB          0x00000008
#define CELZONE_DEMANDPAGE   0x00000010
#define CELZONE_THREAD       0x00000020
#define CELZONE_PROCESS      0x00000040
#define CELZONE_PRIORITYINV  0x00000080
#define CELZONE_CRITSECT     0x00000100
#define CELZONE_SYNCH        0x00000200
#define CELZONE_PROFILER     0x00000400
#define CELZONE_HEAP         0x00000800
#define CELZONE_VIRTMEM      0x00001000
#define CELZONE_GWES         0x00002000
#define CELZONE_LOADER       0x00004000
#define CELZONE_MEMTRACKING  0x00008000
#define CELZONE_BOOT_TIME    0x00010000
#define CELZONE_GDI          0x00020000
#define CELZONE_LOWMEM       0x00040000
#define CELZONE_KCALL        0x00400000
#define CELZONE_DEBUG        0x00800000

#define CELZONE_RESERVED2    0x10000000 // Reserved for system use, apps cannot turn this zone on
#define CELZONE_RESERVED1    0x20000000 // Reserved for system use, apps cannot turn this zone on
#define CELZONE_ALWAYSON     0x40000000 // Always logged, even if zones are turned off
#define CELZONE_MISC         0x80000000


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// Shared data access
#define CELOG_DATAMAP_NAME      TEXT("SYSTEM/CeLog Data")
#define CELOG_DATAMAP_SIGNATURE ((DWORD) 0xCE106B7F)  // CELOGBUF
#define CELOG_FILLEVENT_NAME    TEXT("SYSTEM/CeLog Fill")


// Old structs are provided for convenience of supporting interoperability
// between versions.

// Used on CE versions before 6.0
typedef struct {
    DWORD  dwBufSize;   // Size of data buffer (does not include header)
    LPBYTE pWrite;      // Writer moves this pointer
    LPBYTE pRead;       // Reader moves this pointer
    BOOL   fSetEvent;   // OK to set event?  Writer sets to FALSE, reader sets to TRUE
    BYTE   bReserved;   // Padding for DWORD alignment
    DWORD  dwLostBytes; // Total count of lost bytes, set by writer, reader only reads it
} MAPHEADER_V1;


// Used on CE6.0
typedef struct {
    // VERSION 1 DATA
    DWORD  dwBufSize;     // Size of data buffer (does not include header)
    LPBYTE pWrite;        // OBSOLETE -- will be NULL, see dwWriteOffset below
    LPBYTE pRead;         // OBSOLETE -- will be NULL, see dwReadOffset below
    BOOL   fSetEvent;     // OK to set event?  Writer sets to FALSE, reader sets to TRUE
    BYTE   bReserved;     // Unused
    DWORD  dwLostBytes;   // Total count of lost bytes, set by writer, reader only reads it
    
    // VERSION 2 DATA
    DWORD  dwVersion;     // Version of this structure -- should be 2.
    DWORD  dwBufferStart; // Offset of buffer start from the beginning of the map.
    DWORD  dwWriteOffset; // Offset of write pointer from the beginning of the
                          // map.  Writer moves this pointer.
    DWORD  dwReadOffset;  // Offset of read pointer from the beginning of the
                          // map.  Reader moves this pointer.
    
    // Followed by the data buffer, which starts at dwBufferStart from the start
    // of the map and ends dwBufSize bytes beyond that.
} MAPHEADER_V2;


// Post-CE6
typedef struct {
    // VERSION 1 DATA
    DWORD  dwBufSize;     // Size of data buffer (does not include header)
    LPBYTE pWrite;        // OBSOLETE -- will be NULL, see dwWriteOffset below
    LPBYTE pRead;         // OBSOLETE -- will be NULL, see dwReadOffset below
    BOOL   fSetEvent;     // OK to set event?  Writer sets to FALSE, reader sets to TRUE
    BYTE   bReserved;     // Unused
    DWORD  dwLostBytes;   // Total count of lost bytes, set by writer, reader only reads it
    
    // VERSION 2 DATA
    DWORD  dwVersion;     // Version of this structure -- should be 3.
    DWORD  dwBufferStart; // Offset of buffer start from the beginning of the map.
    DWORD  dwWriteOffset; // Offset of write pointer from buffer start.  Writer moves this pointer.
    DWORD  dwReadOffset;  // Offset of read pointer from buffer start.  Reader moves this pointer.
    
    // VERSION 3 DATA
    DWORD  Signature;     // Used to determine if the map persisted across boots
    BOOL   IsLocked;      // Stop logging while locked
    DWORD  dwSyncBufferStart; // Offset of sync buffer start from the beginning of the map.
    DWORD  dwSyncBufferSize;  // Size of sync buffer
    DWORD  dwSyncWriteOffset; // Offset of write pointer from sync buffer start.
    DWORD  dwSyncReadOffset;  // Offset of read pointer from sync buffer start.
    DWORD  dwIntBufferStart;  // Offset of interrupt buffer start from the beginning of the map.
    DWORD  dwIntBufferSize;   // Size of interrupt buffer
    DWORD  dwIntWriteOffset;  // Offset of write pointer from interrupt buffer start.
    DWORD  dwIntReadOffset;   // Offset of read pointer from interrupt buffer start.
    
    // Followed by the data buffer, which starts at dwBufferStart from the start
    // of the map and ends dwBufSize bytes beyond that.
} MAPHEADER_V3;


#ifndef MAPHEADER  // Easy quick-n-dirty replacement
#define MAPHEADER MAPHEADER_V3
#endif
typedef MAPHEADER *PMAPHEADER;


#ifdef UNDER_CE


//------------------------------------------------------------------------------
//
// Functions for performing data logging.  Note that typically you should
// use the macros defined below, rather than calling this function
// directly.  In a ship build, CeLogData normally thunks to a stub, so
// calling the function directly just increasing your code size.
//

// Check if macros were previously defined (building coredll)
#ifndef WIN32_CALL

void CeLogData(BOOL  fTimeStamp, // Should timestamp be used?
               WORD  wID,        // ID of event/data.
               PVOID pData,      // pointer to data buffer
               WORD  wLen,       // Len of data (in bytes)
               DWORD dwZoneUser, // User-defined zone
               DWORD dwZoneCE,   // Predefined zone
               WORD  wFlag,      // data flag
               BOOL  fFlagged);  // Is data flag being used?


void CeLogSetZones(DWORD dwZoneUser,        // User-defined zones
                   DWORD dwZoneCE,          // Predefined zones
                   DWORD dwZoneProcess);    // Process zones


BOOL CeLogGetZones(LPDWORD lpdwZoneUser,    // User-defined zones
                   LPDWORD lpdwZoneCE,      // Predefined zones
                   LPDWORD lpdwZoneProcess, // Process zones
                   LPDWORD lpdwAvailableZones); // Zones supported by this kernel

BOOL CeLogReSync();

__inline static void
CeLogMsg(
    __format_string const WCHAR* szFormat,
    ...
    )
{
    va_list arglist;
    WCHAR   szTemp[MAX_PATH];
    size_t  cchLen;
    HRESULT hr;

    // Compose a single string using the input args
    va_start(arglist, szFormat);
    hr = StringCchVPrintfW(szTemp, MAX_PATH, szFormat, arglist);
    if (SUCCEEDED(hr)) {
        hr = StringCchLengthW(szTemp, MAX_PATH, &cchLen);
        if (SUCCEEDED(hr)) {
            CeLogData(TRUE, CELID_RAW_WCHAR, szTemp, (WORD)((cchLen + 1) * sizeof(WCHAR)),
                      0, CELZONE_ALWAYSON, 0, FALSE);
        }
    }
}

#endif // WIN32_CALL

// Macros for CELogData.
#ifdef SHIP_BUILD

    #define CELOGDATA(Time, ID, Data, Len, Zone1, Zone2)               ((void)0)
    #define CELOGDATAFLAGGED(Time, ID, Data, Len, Zone1, Zone2, Flag)  ((void)0)
    #define RETAILCELOG(Cond, ID, Data, Len)                           ((void)0)
    #define DEBUGCELOG(Cond, ID, Data, Len)                            ((void)0)
    #define RETAILCELOGMSG(Cond, Printf_exp)                           ((void)0)
    #define DEBUGCELOGMSG(Cond, Printf_exp)                            ((void)0)

#else // SHIP_BUILD

    #define CELOGDATA(Time, ID, Data, Len, Zone1, Zone2) \
            CeLogData(Time, ID, Data, Len, Zone1, Zone2, 0, FALSE)

    #define CELOGDATAFLAGGED(Time, ID, Data, Len, Zone1, Zone2, Flag) \
            CeLogData(Time, ID, Data, Len, Zone1, Zone2, Flag, TRUE)

    #define RETAILCELOG(Cond, ID, Data, Len) \
            ((void)((Cond) ? CeLogData(TRUE, ID, Data, Len, 0, CELZONE_ALWAYSON, 0, FALSE), 1 : 0))

    #define RETAILCELOGMSG(Cond, Printf_exp) \
            ((void)((Cond) ? (CeLogMsg Printf_exp), 1 : 0))

#ifdef DEBUG
    #define DEBUGCELOG(Cond, ID, Data, Len) \
            ((void)((Cond) ? CeLogData(TRUE, ID, Data, Len, 0, CELZONE_ALWAYSON, 0, FALSE), 1 : 0))

    #define DEBUGCELOGMSG(Cond, Printf_exp) \
            ((void)((Cond) ? (CeLogMsg Printf_exp), 1 : 0))
#else
    #define DEBUGCELOG(Cond, ID, Data, Len)                            ((void)0)
    #define DEBUGCELOGMSG(Cond, Printf_exp)                            ((void)0)
#endif // DEBUG


#endif // IF/ELSE SHIP_BUILD



//------------------------------------------------------------------------------
//
// Variables to control the logging.  If they are not set during OEMInit, they
// will default to reasonable values.
//

extern DWORD dwCeLogLargeBuf;
extern DWORD dwCeLogSmallBuf;
extern DWORD dwCeLogFlushTimeout;
extern int   nCeLogThreadPrio;


#endif // UNDER_CE


#pragma warning(default:4200) // nonstandard extensions warning

#ifdef __cplusplus
}
#endif

#endif // __CELOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ceconfig.h ===
#ifndef __CECONFIG_H__
#define __CECONFIG_H__
// CEFilter Component List:
#define CE_MODULES_COREDLL 1
#define CE_MODULES_KCOREDLL 1
#define CE_MODULES_NK 1
#define CE_MODULES_NKLOADER 1
#define CE_MODULES_OEM 1
#define CE_MODULES_OALIOCTL 1
#define CE_MODULES_FPCRT 1
#define CE_MODULES_SOFTKB 1
#define CE_MODULES_CESIPWNDMAN 1
#define CE_MODULES_LVMOD_FULL 1
#define CE_MODULES_LVMOD_STUB 1
#define CE_MODULES_REGEXTDEV 1
#define CE_MODULES_COMMCTRL 1
#define CE_MODULES_COMMDLG 1
#define CE_MODULES_SHELL 1
#define CE_MODULES_LOADDBG 1
#define CE_MODULES_SHELLCELOG 1
#define CE_MODULES_OSAXST0 1
#define CE_MODULES_DLLHEAPINFOEXT 1
#define CE_MODULES_RELFSD 1
#define CE_MODULES_RELFSDEXT 1
#define CE_MODULES_LPCD 1
#define CE_MODULES_LPCRT 1
#define CE_MODULES_SCARD 1
#define CE_MODULES_WINSCARD 1
#define CE_MODULES_BFE 1
#define CE_MODULES_FWPUCLNT 1
#define CE_MODULES_IKEEXT 1
#define CE_MODULES_FWPKCLNT 1
#define CE_MODULES_NETAPI32 1
#define CE_MODULES_WLDAP32 1
#define CE_MODULES_SECUR32 1
#define CE_MODULES_NTLMSSP 1
#define CE_MODULES_NTLMSSP_SVC 1
#define CE_MODULES_SPNEGO 1
#define CE_MODULES_SCHANNEL 1
#define CE_MODULES_CREDMAN 1
#define CE_MODULES_PCL 1
#define CE_MODULES_PRNPORT 1
#define CE_MODULES_PRNERR 1
#define CE_MODULES_CUSTSAT 1
#define CE_MODULES_SQMCE 1
#define CE_MODULES_IRI 1
#define CE_MODULES_GPSID 1
#define CE_MODULES_GPSAPI 1
#define CE_MODULES_USP_CE 1
#define CE_MODULES_NETUI 1
#define CE_MODULES_CMNET 1
#define CE_MODULES_CMSERVICE 1
#define CE_MODULES_CMCSPIP 1
#define CE_MODULES_CMCSPWWAN 1
#define CE_MODULES_CMCSPRAS 1
#define CE_MODULES_CMCSPIPSECVPN 1
#define CE_MODULES_WSCMEXT 1
#define CE_MODULES_PROXYSVC 1
#define CE_MODULES_PROXYDBS 1
#define CE_MODULES_RMNET 1
#define CE_MODULES_RSPBASIC 1
#define CE_MODULES_RSPCELLULAR 1
#define CE_MODULES_ASYNCMAC 1
#define CE_MODULES_UNIMODEM 1
#define CE_MODULES_SERVICESFILTER 1
#define CE_MODULES_SERVICESSTART 1
#define CE_MODULES_SERVICESENUM 1
#define CE_MODULES_SERVICES 1
#define CE_MODULES_TCPIP 1
#define CE_MODULES_NETIO 1
#define CE_MODULES_NSI 1
#define CE_MODULES_NSIPROXY 1
#define CE_MODULES_WINNSI 1
#define CE_MODULES_NSISVC 1
#define CE_MODULES_TCPIPREG 1
#define CE_MODULES_DNSAPI 1
#define CE_MODULES_WINSOCK 1
#define CE_MODULES_AFD 1
#define CE_MODULES_NETIO 1
#define CE_MODULES_WS2 1
#define CE_MODULES_WS2INSTL 1
#define CE_MODULES_WSPM 1
#define CE_MODULES_NSPM 1
#define CE_MODULES_WS2K 1
#define CE_MODULES_WS2SERV 1
#define CE_MODULES_SSLLSP 1
#define CE_MODULES_RTL8139 1
#define CE_MODULES_E100BEX 1
#define CE_MODULES_SMSC100FD 1
#define CE_MODULES_NE2000 1
#define CE_MODULES_DHCP 1
#define CE_MODULES_NWIFI 1
#define CE_MODULES_RTLNWIFI 1
#define CE_MODULES_ISLP2NDS 1
#define CE_MODULES_AR6K_NDIS_SDIO 1
#define CE_MODULES_AR6K_NWF 1
#define CE_MODULES_EAPOL 1
#define CE_MODULES_EAP 1
#define CE_MODULES_EAPCHAP 1
#define CE_MODULES_EAPTLS 1
#define CE_MODULES_NDISUIO 1
#define CE_MODULES_VEIM 1
#define CE_MODULES_DHCPSRV 1
#define CE_MODULES_NDIS 1
#define CE_MODULES_PPP 1
#define CE_MODULES_TAPI 1
#define CE_MODULES_PPTP 1
#define CE_MODULES_L2TP 1
#define CE_MODULES_CRYPT32 1
#define CE_MODULES_NCRYPT 1
#define CE_MODULES_KEYISO 1
#define CE_MODULES_MSASN1 1
#define CE_MODULES_BCRYPT 1
#define CE_MODULES_CCFGSVC 1
#define CE_MODULES_ALPCD 1
#define CE_MODULES_RPCRT4 1
#define CE_MODULES_REDIR 1
#define CE_MODULES_NETBIOS 1
#define CE_MODULES_CEPERF_MODULE 1
#define CE_MODULES_BTHHID 1
#define CE_MODULES_BTA2DP 1
#define CE_MODULES_SBC 1
#define CE_MODULES_BTD 1
#define CE_MODULES_BTDRT 1
#define CE_MODULES_BTHUNIV 1
#define CE_MODULES_BTAVDTP 1
#define CE_MODULES_BTAVCTP 1
#define CE_MODULES_BTAVRCP 1
#define CE_MODULES_BTHUART 1
#define CE_MODULES_BTHAMB 1
#define CE_MODULES_BTHSC 1
#define CE_MODULES_BTHCSR 1
#define CE_MODULES_WENDYSER 1
#define CE_MODULES_WCESTREAMBT 1
#define CE_MODULES_SIO950 1
#define CE_MODULES_BTHUSB 1
#define CE_MODULES_IPHLPAPI 1
#define CE_MODULES_NETLOG 1
#define CE_MODULES_NETLOGCTL 1
#define CE_MODULES_KBDA1 1
#define CE_MODULES_KBDHEB 1
#define CE_MODULES_KBDTH0 1
#define CE_MODULES_KBDINHIN 1
#define CE_MODULES_KBDINMAR 1
#define CE_MODULES_KBDINPUN 1
#define CE_MODULES_KBDINTEL 1
#define CE_MODULES_KBDINGUJ 1
#define CE_MODULES_KBDINKAN 1
#define CE_MODULES_KBDINTAM 1
#define CE_MODULES_KBDUS 1
#define CE_MODULES_KBDJPN 1
#define CE_MODULES_KBDKOR 1
#define CE_MODULES_KBDRUS 1
#define CE_MODULES_SAMPLECAM 1
#define CE_MODULES_XGF 1
#define CE_MODULES_KEYBD 1
#define CE_MODULES_POINTER 1
#define CE_MODULES_TOUCH 1
#define CE_MODULES_DISPLAY 1
#define CE_MODULES_FONTS 1
#define CE_MODULES_HGCORE 1
#define CE_MODULES_KHGCORE 1
#define CE_MODULES_COMPOSITOR 1
#define CE_MODULES_OGLES2PAL 1
#define CE_MODULES_DDGUID 1
#define CE_MODULES_PHYSICSENGINE 1
#define CE_MODULES_DMSRV 1
#define CE_MODULES_AUDIORTGMGR 1
#define CE_MODULES_AUDIORTGENGINE 1
#define CE_MODULES_GSM610 1
#define CE_MODULES_WAVEAPI 1
#define CE_MODULES_AUDIODRV 1
#define CE_MODULES_WAVESAMPLES 1
#define CE_MODULES_WAVEAPIC 1
#define CE_MODULES_UIPROXY 1
#define CE_MODULES_CXPORT 1
#define CE_MODULES_BACKLIGHT 1
#define CE_MODULES_BATTDRVR 1
#define CE_MODULES_NLEDDRVR 1
#define CE_MODULES_CRITICALAPPMONITOR 1
#define CE_MODULES_DELAYEDBOOTWORK 1
#define CE_MODULES_TIMEZONES 1
#define CE_MODULES_DEVICE 1
#define CE_MODULES_REGENUM 1
#define CE_MODULES_BUSENUM 1
#define CE_MODULES_PM 1
#define CE_MODULES_GIISR 1
#define CE_MODULES_MMTIMER 1
#define CE_MODULES_PCI 1
#define CE_MODULES_PCMCONV 1
#define CE_MODULES_SERIAL 1
#define CE_MODULES_8042KEYBOARD 1
#define CE_MODULES_NOPKEYBOARD 1
#define CE_MODULES_PCCARD 1
#define CE_MODULES_ATADISK 1
#define CE_MODULES_USBHOST 1
#define CE_MODULES_USBD 1
#define CE_MODULES_USBOTG 1
#define CE_MODULES_USBHID 1
#define CE_MODULES_USBMSC 1
#define CE_MODULES_USBDISK6 1
#define CE_MODULES_HIDPARSE 1
#define CE_MODULES_KBDHID 1
#define CE_MODULES_CONSHID 1
#define CE_MODULES_MOUHID 1
#define CE_MODULES_USBFN 1
#define CE_MODULES_USBMSFN 1
#define CE_MODULES_RNDISFN 1
#define CE_MODULES_SERIALUSBFN 1
#define CE_MODULES_COMPOSITEFN 1
#define CE_MODULES_STRATAD 1
#define CE_MODULES_SDNPCID 1
#define CE_MODULES_RAMFMD 1
#define CE_MODULES_ENUMFASLPCI 1
#define CE_MODULES_FASLD 1
#define CE_MODULES_CEDDK 1
#define CE_MODULES_EXFAT 1
#define CE_MODULES_FATUTIL 1
#define CE_MODULES_DISKCACHE 1
#define CE_MODULES_MENCFILT 1
#define CE_MODULES_CACHEFILT 1
#define CE_MODULES_RAWFS 1
#define CE_MODULES_CEREG 1
#define CE_MODULES_IMGUPD 1
#define CE_MODULES_PACKAGEINFOAPI 1
#define CE_MODULES_UPDATEVALIDATOR 1
#define CE_MODULES_IMGFS 1
#define CE_MODULES_MSPART 1
#define CE_MODULES_ZLIB 1
#define CE_MODULES_XMLLITE 1
#define CE_MODULES_TUX 1
#define CE_MODULES_TUX_LS 1
#define CE_MODULES_XTUX 1
#define CE_MODULES_KTUX 1
#define CE_MODULES_KATO 1
#define CE_MODULES_CMDLINE 1
#define CE_MODULES_DBPTAGS 1
#define CE_MODULES_XMLTAGS 1
#define CE_MODULES_FILESYS 1
#define CE_MODULES_FSDMGR 1
#define CE_MODULES_ROMFSD 1
#define CE_MODULES_FSREPLXFILT 1
#define CE_MODULES_POLICYENGINE 1
#define CE_MODULES_POLICYEXT 1
#define CE_MODULES_UBA 1
#define CE_MODULES_RSAENH 1
#define CE_MODULES_DSSDH 1
#define CE_MODULES_CECOMPR 1
#define CE_MODULES_OPENMPCE 1
#define CE_MODULES_TOOLHELP 1
#define CE_MODULES_VMINI 1
#define CE_MODULES_LASSD 1
#define CE_MODULES_RT_TESTS 1
#define CE_MODULES_COREDLL 1
#define CE_MODULES_KCOREDLL 1
#define CE_MODULES_NOTIFY 1
#define CE_MODULES_COMMCTRL 1
#define CE_MODULES_BTAGSVC 1
#define CE_MODULES_GWES 1
#define CE_MODULES_MGTT_O 1
#define CE_MODULES_GWEUSER 1
#define DCOM_MODULES_ATL 1
#define DCOM_MODULES_DLLHOST 1
#define DCOM_MODULES_DCOMSSD 1
#define DCOM_MODULES_OLE32 1
#define DCOM_MODULES_OLEAUT32 1
#define DCOM_MODULES_RPCRT4LEGACY 1
#define DCOM_MODULES_KOLE32 1
#define DCOM_MODULES_KOLEAUT32 1
#define DCOM_MODULES_UUID 1
#define GDIEX_MODULES_GDIPLUS 1
#define GDIEX_MODULES_IMAGING 1
#define IE7_MODULES_PNGFILT 1
#define IE7_MODULES_IMGUTIL 1
#define IE7_MODULES_DXTMSFT 1
#define IE7_MODULES_DXTRANS 1
#define IE7_MODULES_MSHTML 1
#define IE7_MODULES_MSHTMLED 1
#define IE7_MODULES_IETHEME 1
#define IE7_MODULES_IETHMWM 1
#define IE7_MODULES_HTMLVIEW 1
#define IE7_MODULES_IEFRAME 1
#define IE7_MODULES_THUMBVW 1
#define IE7_MODULES_MSXML3 1
#define IE7_MODULES_URLMON 1
#define IE7_MODULES_WININET 1
#define IE7_MODULES_SHLWAPI 1
#define IE7_MODULES_MLANG 1
#define IE7_MODULES_MSLS31 1
#define IE7_MODULES_UUID 1
#define SCRIPT_MODULES_JSCRIPT 1
#define SCRIPT_MODULES_VBSCRIPT 1
#define SERVERS_MODULES_WLIDSVC 1
#define SERVERS_MODULES_MSIDCRL 1
#define SERVERS_MODULES_PPCRLCONFIG_PRODUCTION 1
#define SERVERS_MODULES_PPCRLCONFIG_INT 1
#define SERVERS_MODULES_OBEXAPI 1
#define SERVERS_MODULES_OBEXSRVR 1
#define SERVERS_MODULES_SQMSVC 1
#define SERVERS_MODULES_SQMEVENT 1
#define SERVERS_MODULES_DSTSVC 1
#define SERVERS_MODULES_LFGPSPROVIDER 1
#define SERVERS_MODULES_LFWIFIPROVIDER 1
#define SERVERS_MODULES_LFSVC 1
#define SERVERS_MODULES_LFAPI 1
#define SERVERS_MODULES_ONEX 1
#define SERVERS_MODULES_WLANSEC 1
#define SERVERS_MODULES_WLANMSM 1
#define SERVERS_MODULES_WLANEXT 1
#define SERVERS_MODULES_WLANUTIL 1
#define SERVERS_MODULES_WLANSVC 1
#define SERVERS_MODULES_WLANAPI 1
#define SERVERS_MODULES_WLANTOOL 1
#define SERVERS_MODULES_ONEX 1
#define SERVERS_MODULES_WLANSEC 1
#define SERVERS_MODULES_WLANMSM 1
#define SERVERS_MODULES_WLANUTIL 1
#define SERVERS_MODULES_WLANSVC 1
#define SERVERS_MODULES_WLANAPI 1
#define SERVERS_MODULES_WLANTOOL 1
#define SERVERS_MODULES_WLANCFGSP 1
#define SERVERS_MODULES_EAPPHOST 1
#define SERVERS_MODULES_EAPPCFG 1
#define SERVERS_MODULES_EAPPPRXY 1
#define SERVERS_MODULES_EAPSVC 1
#define SERVERS_MODULES_EAPP3HST 1
#define SERVERS_MODULES_EAP3SVC 1
#define CELLCORE_MODULES_NETWORKPOLICYCSP 1
#define CELLCORE_MODULES_CELLTSP 1
#define CELLCORE_MODULES_RIL 1
#define CELLCORE_MODULES_RILENFORA 1
#define CELLCORE_MODULES_RILLOG 1
#define CELLCORE_MODULES_CELLCOREEVENTLOGMSGS 1
#define CELLCORE_MODULES_MUX07_10 1
#define CELLCORE_MODULES_SIM 1
#define CELLCORE_MODULES_SIMDRV 1
#define CELLCORE_MODULES_SIMTKIT 1
#define CELLCORE_MODULES_SIMTKITUICE 1
#define CELLCORE_MODULES_TKITAPP 1
#define CELLCORE_MODULES_SMS_PROVIDERS 1
#define CELLCORE_MODULES_SMS 1
#define CELLCORE_MODULES_SMSDRV 1
#define CELLCORE_MODULES_WAP 1
#define CELLCORE_MODULES_WAPDRV 1
#define CELLCORE_MODULES_WWAN 1
#define CELLCORE_MODULES_CONNCFG 1
#define CELLCORE_MODULES_CONNMGR 1
#define CELLCORE_MODULES_CONNPLAN 1
#define CELLCORE_MODULES_CSPNET 1
#define CELLCORE_MODULES_CSPOMADMCONN 1
#define CELLCORE_MODULES_CSPPROXY 1
#define CELLCORE_MODULES_CSPRAS 1
#define CELLCORE_MODULES_NETRES 1
#define CELLCORE_MODULES_DTPT_NSP 1
#define CELLCORE_MODULES_DTPT_SRV 1
#define CELLCORE_MODULES_ATCMDINT 1
#define CELLCORE_MODULES_GSMDLL 1
#define CELLCORE_MODULES_ATCISAMP 1
#define CELLCORE_MODULES_GSMEMUL 1
#define CELLCORE_MODULES_CELLCORE 1
#define CELLCORE_MODULES_CCOREUTL 1
#define CELLCORE_MODULES_RIL 1
#define CELLCORE_MODULES_SIM 1
#define CELLCORE_MODULES_SMS 1
#define CELLCORE_MODULES_CCORERES 1
#define CELLCORE_MODULES_FAKERIL 1
#define CELLCORE_MODULES_FRINTERFACE 1
#define CELLCORE_MODULES_FAKERIL_INTERMEDIATE 1
#define OSSVCS_MODULES_BTHAGPHONEBOOK 1
#define OSSVCS_MODULES_BTHPBAP 1
#define OSSVCS_MODULES_OSSVCS 1
#define OSSVCS_MODULES_RUNDLL32 1
#define OSSVCS_MODULES_CONFIGMANAGER 1
#define OSSVCS_MODULES_CONFIGMANAGER2 1
#define OSSVCS_MODULES_PUSHPRXY 1
#define OSSVCS_MODULES_METABASEPROXY 1
#define OSSVCS_MODULES_METABASESERVICE 1
#define OSSVCS_MODULES_CONFIGMETABASE2 1
#define OSSVCS_MODULES_WSP 1
#define OSSVCS_MODULES_WSPPUSH 1
#define OSSVCS_MODULES_DEVAUTH 1
#define OSSVCS_MODULES_AUTHCODE 1
#define OSSVCS_MODULES_DIAGINFO 1
#define OSSVCS_MODULES_PNDTAPI 1
#define OSSVCS_MODULES_EXSMIME 1
#define OSSVCS_MODULES_UTCORE 1
#define OSSVCS_MODULES_SSUPDATE 1
#define OSSVCS_MODULES_DMSAPI 1
#define OSSVCS_MODULES_ENROLLSVC 1
#define OSSVCS_MODULES_ENROLLNOT 1
#define OSSVCS_MODULES_AUXDISPEXTERN 1
#define OSSVCS_MODULES_SWMGMTSERVICE 1
#define OSSVCS_MODULES_SWMGMTREGTODATABASE 1
#define OSSVCS_MODULES_OMADMSVC 1
#define OSSVCS_MODULES_DMSCHEDULERCALLBACK 1
#define OSSVCS_MODULES_REMOTEWIPESERVICE 1
#define OSSVCS_MODULES_FILELOGGER 1
#define OSSVCS_MODULES_BTHUTIL 1
#define SHELL_MODULES_MEXPLORER 1
#define SHELL_MODULES_DMDLUUID 1
#define SHELL_MODULES_DATAMODEL 1
#define SHELL_MODULES_MENUMANAGER 1
#define SHELL_MODULES_SHCORE 1
#define SHELL_MODULES_CESHELL 1
#define SHELL_MODULES_SHUTIL 1
#define SHELL_MODULES_AYGSHELL 1
#define SHELL_MODULES_VGAL 1
#define SHELL_MODULES_SHELLRES 1
#define WCESHELLFE_MODULES_CHNIME_SC 1
#define WCESHELLFE_MODULES_CHNIME_DB_1 1
#define WCESHELLFE_MODULES_DWXFER 1
#define DIRECTX_MODULES_IPLAYAUDIO 1
#define DIRECTX_MODULES_WMVDMOD 1
#define DIRECTX_MODULES_WMADMOD 1
#define DIRECTX_MODULES_WMADMOD 1
#define DIRECTX_MODULES_STRMBASE 1
#define DIRECTX_MODULES_QUARTZ 1
#define DIRECTX_MODULES_MSRLE32 1
#define DIRECTX_MODULES_ICM 1
#define DIRECTX_MODULES_MSDMO 1
#define DIRECTX_MODULES_WMVDMOE 1
#define DIRECTX_MODULES_DSHOWREMOTE 1
#define DIRECTX_MODULES_DSHOWREMOTESERV 1
#define DIRECTX_MODULES_CEDRM2 1
#define DIRECTX_MODULES_XDRMREMOTESERV 1
#define DIRECTX_MODULES_MULTIMEDIALAUNCHER 1
#define DIRECTX_MODULES_DIRECTDRAW 1
#define DIRECTX_MODULES_DDSAMPLES 1
#define DIRECTX_MODULES_MSADPCM 1
#define DIRECTX_MODULES_IMAADPCM 1
#define DIRECTX_MODULES_MSG711 1
#define DIRECTX_MODULES_MIDIPARSER 1
#define DIRECTX_MODULES_MIDISYNTH 1
#define NETCFV37_MODULES_DOTNETV37_SMARTFON 1
#define MSF_MODULES_SYNCHRONIZATION 1
#define MSF_MODULES_FEEDSYNC 1
#define MSF_MODULES_METASTORE 1
#define SQLCOMPACT_MODULES_EDB 1
#define SQLCOMPACT_MODULES_SQLCOMPACTMP 1
#define SQLCOMPACT_MODULES_SQLCOMPACT 1
#define SQLCOMPACT_MODULES_EDB 1
#define SHELLW_MODULES_MSIM 1
#define SHELLW_MODULES_MSIMFR 1
#define SHELLW_MODULES_MSIMES 1
#define SHELLW_MODULES_MSIMDE 1
#define SHELLW_MODULES_MSIMPT 1
#define SHELLW_MODULES_MSIMIT 1
#define SHELLW_MODULES_MSIMNL 1
#define SHELLW_MODULES_MSIMPTG 1
#define SHELLW_MODULES_MSIMNO 1
#define SHELLW_MODULES_MSIMDA 1
#define SHELLW_MODULES_MSIMSW 1
#define SHELLW_MODULES_MSIMRU 1
#define SHELLW_MODULES_MSIMPL 1
#define SHELLW_MODULES_MSIMCS 1
#define SHELLW_MODULES_MSIMEL 1
#define SHELLW_MODULES_MSIMJ 1
#define SHELLW_MODULES_MSKANA 1
#define SHELLW_MODULES_MSIMK 1
#define SHELLW_MODULES_SSKIM 1
#define SHELLW_MODULES_MSPY4RES 1
#define SHELLW_MODULES_PHONIM 1
#define SHELLW_MODULES_CHAJEIIM 1
#define SHELLW_MODULES_TELSHELL 1
#define SHELLW_MODULES_LOCINFO 1
#define SHELLW_MODULES_FEXPLORE 1
#define SHELLW_MODULES_PHONEIME 1
#define SHELLW_MODULES_PHON_IME 1
#define SHELLW_MODULES_COMPIME 1
#define SHELLW_MODULES_COMPIMECPL 1
#define SHELLW_MODULES_IHCPSERVER 1
#define SHELLW_MODULES_CANDIDATEWINDOW 1
#define SHELLW_MODULES_UIME_SMARTFON 1
#define SHELLW_MODULES_MSPY4CPL 1
#define SHELLW_MODULES_MSIM 1
#define SHELLW_MODULES_MSIMFR 1
#define SHELLW_MODULES_MSIMES 1
#define SHELLW_MODULES_MSIMDE 1
#define SHELLW_MODULES_MSIMPT 1
#define SHELLW_MODULES_MSIMIT 1
#define SHELLW_MODULES_MSIMNL 1
#define SHELLW_MODULES_MSIMPTG 1
#define SHELLW_MODULES_MSIMNO 1
#define SHELLW_MODULES_MSIMDA 1
#define SHELLW_MODULES_MSIMSW 1
#define SHELLW_MODULES_MSIMRU 1
#define SHELLW_MODULES_MSIMPL 1
#define SHELLW_MODULES_MSIMCS 1
#define SHELLW_MODULES_MSIMEL 1
#define SHELLW_MODULES_MSIMJ 1
#define SHELLW_MODULES_MSKANA 1
#define SHELLW_MODULES_MSIMK 1
#define SHELLW_MODULES_SSKIM 1
#define SHELLW_MODULES_MSPY4RES 1
#define SHELLW_MODULES_PHONIM 1
#define SHELLW_MODULES_CHAJEIIM 1
#define SHELLW_MODULES_SIPWNDMAN 1
#define SHELLW_MODULES_STYLUSKB 1
#define SHELLW_MODULES_STYLUSKBRES 1
#define SHELLW_MODULES_IMGDECMP 1
#define SHELLW_MODULES_MSSCRIPT 1
#define SHELLW_MODULES_NETUI 1
#define SHELLW_MODULES_OBEXINBX 1
#define SHELLW_MODULES_AUDIORTGBTHEXT 1
#define SHELLW_MODULES_TSHRES 1
#define SHELLW_MODULES_RNAAPP 1
#define SHELLW_MODULES_BROWSUI 1
#define SHELLW_MODULES_WMLVIEW 1
#define SHELLW_MODULES_EEHOST 1
#define SHELLW_MODULES_IEXPLORE 1
#define SHELLW_MODULES_CCORE 1
#define SHELLW_MODULES_CONTACTSDLL 1
#define SHELLW_MODULES_SYSCSPS 1
#define SHELLW_MODULES_DMCSPS 1
#define SHELLW_MODULES_BTHIDSVC 1
#define SHELLW_MODULES_SPDUMMY 1
#define SHELLW_MODULES_CEIPUI 1
#define SHELLW_MODULES_THMSVC 1
#define SHELLW_MODULES_BROWSRESDLL 1
#define SHELLW_MODULES_SHELLRESWPCDLL 1
#define SHELLW_MODULES_SHELLCTRLS 1
#define SHELLW_MODULES_SMARTSEARCH 1
#define SHELLW_MODULES_SMARTSEARCHRES 1
#define SHELLW_MODULES_STARTUPWIZARD 1
#define SHELLW_MODULES_STARTUPWIZARDRES 1
#define SHELLW_MODULES_NOTIFCME 1
#define SHELLW_MODULES_NOTIFCOM 1
#define SHELLW_MODULES_SSDISPATCH 1
#define SHELLW_MODULES_SBOM 1
#define SHELLW_MODULES_RIAHOST 1
#define SHELLW_MODULES_RIAUTL 1
#define SHELLW_MODULES_RIAMIMEHANDLER 1
#define SHELLW_MODULES_RIPLUGIN 1
#define SHELLW_MODULES_GADGETOMUTILS 1
#define SHELLW_MODULES_PCLUI 1
#define SHELLW_MODULES_SETTINGS 1
#define SHELLW_MODULES_SETTINGS2 1
#define SHELLW_MODULES_CPLCONTROLLERS 1
#define SHELLW_MODULES_SETTINGSQUICKACCESS 1
#define SHELLW_MODULES_SETTINGSRES 1
#define SHELLW_MODULES_CLOCKSALARMS 1
#define SHELLW_MODULES_CLOCKRES 1
#define SHELLW_MODULES_CLOCKUTIL 1
#define SHELLW_MODULES_START 1
#define SHELLW_MODULES_STARTRES 1
#define SHELLW_MODULES_HOMEX 1
#define SHELLW_MODULES_HOMERES 1
#define SHELLW_MODULES_WININETUI 1
#define SHELLW_MODULES_URLMONUI 1
#define DATASYNC_MODULES_REPLLOG 1
#define DATASYNC_MODULES_ASRES 1
#define DATASYNC_MODULES_RAPICLNT 1
#define DATASYNC_MODULES_ASUTIL 1
#define DATASYNC_MODULES_WINMOBILE 1
#define DATASYNC_MODULES_CEFOBJ 1
#define DATASYNC_MODULES_TASKSCHEDULER 1
#define DATASYNC_MODULES_TSKSCHSRV 1
#define DATASYNC_MODULES_TASKSCHEDULER 1
#define DATASYNC_MODULES_TSKSCHSRV 1
#define MEDIAAPPS_MODULES_MLSERVICE 1
#define MEDIAAPPS_MODULES_MEDIALIBRARY 1
#define MEDIAAPPS_MODULES_MEDIALIBRARYUUID 1
#define MEDIAAPPS_MODULES_METADATAPARSER 1
#define MEDIAAPPS_MODULES_METADATAPARSERUUID 1
#define MEDIAAPPS_MODULES_MSCAMCORE 1
#define MEDIAAPPS_MODULES_MSCAMERA 1
#define MEDIAAPPS_MODULES_MSCAMRES 1
#define MEDIAAPPS_MODULES_PHOTOVIEWERUX 1
#define MEDIAAPPS_MODULES_PHOTOUX 1
#define MEDIAAPPS_MODULES_PHOTOVIEWER 1
#define MEDIAAPPS_MODULES_POSTCAPVIEW 1
#define MEDIAAPPS_MODULES_PHOTOSHARING 1
#define MEDIAAPPS_MODULES_PHOTOSHARINGUX 1
#define MEDIAAPPS_MODULES_PHOTOEDITOR 1
#define MEDIAAPPS_MODULES_SLIDESHOW 1
#define MEDIAAPPS_MODULES_VIEWERCORE 1
#define MEDIAAPPS_MODULES_IMAGEDOC 1
#define MEDIAAPPS_MODULES_MEDIASETTINGS 1
#define MEDIAAPPS_MODULES_PHOTORES 1
#define MEDIAAPPS_MODULES_MEDIAUX 1
#define MEDIAAPPS_MODULES_AUDIOVIDEOUX 1
#define MEDIAAPPS_MODULES_AUDIOVIDEOUXRES 1
#define MEDIAAPPS_MODULES_MEDIADATAACCESS 1
#define MEDIAAPPS_MODULES_AVRCP_MPPLUGIN 1
#define MEDIAAPPS_MODULES_WMPOCX 1
#define MEDIAAPPS_MODULES_WMPOCX_LOC 1
#define MEDIAAPPS_MODULES_WMPOCX_SKIN 1
#define MEDIAAPPS_MODULES_WMDRMHELPER 1
#define MEDIAAPPS_MODULES_MEDIAAPPSCOMMONDLL 1
#define OSTEST_MODULES_TOOLTALK 1
#define OSTEST_MODULES_SCLIENT 1
#define OSTEST_MODULES_STRESSUTILS 1
#define OSTEST_MODULES_STRESSMOD 1
#define OSTEST_MODULES_TTRACKER 1
#define OSTEST_MODULES_TTRACKERK 1
#define OSTEST_MODULES_ITLGEN 1
#define OSTEST_MODULES_NDTCRYPTLIB 1
#define HWR_MODULES_HWRFRAMEWORK 1
#define HWR_MODULES_HWRLATIN 1
#define HWR_MODULES_HWRIMLINE 1
#define HWR_MODULES_HWRIMBOX 1
#define HWR_MODULES_HWRIMEA 1
#define HWR_MODULES_HWRCHS 1
#define HWR_MODULES_HWRCHSR 1
#define HWR_MODULES_HWRCHT 1
#define HWR_MODULES_HWRCHTR 1
#define HWR_MODULES_HWRJPN 1
#define HWR_MODULES_HWRJPNR 1
#define HWR_MODULES_HWRKOR 1
#define HWR_MODULES_HWRKORR 1
#define RM_MODULES_MSDRM 1
#define RM_MODULES_SECPROC 1
#define RM_MODULES_SECPROC_TEST 1
#define RM_MODULES_RMACTIVATE 1
#define RM_MODULES_RMACTIVATE_TEST 1
#define RM_MODULES_RMUT_END2END 1
#define APPS_MODULES_DOCLIST 1
#define APPS_MODULES_WISPLITE 1
#define APPS_MODULES_INKCTRLS 1
#define APPS_MODULES_NOTE_PRJ 1
#define APPS_MODULES_VOICECTL 1
#define APPS_MODULES_RICHED20 1
#define APPS_MODULES_MSLS4 1
#define APPS_MODULES_MGDWINMOB 1
#define APPS_MODULES_MGDFORMS 1
#define APPS_MODULES_MGDCFG 1
#define APPS_MODULES_MGDCONTROLS 1
#define APPS_MODULES_MGDTELAPI 1
#define APPS_MODULES_VCOMCTL 1
#define APPS_MODULES_DWUI 1
#define APPS_MODULES_PERFMAN 1
#define APPS_MODULES_FSDSPY 1
#define APPS_MODULES_WLIDUI 1
#define APPS_MODULES_WLIDCONFIG 1
#define APPS_MODULES_CLOCKNOT 1
#define APPS_MODULES_RRA_STM 1
#define APPS_MODULES_INREPLCE 1
#define APPS_MODULES_UDP2TCP 1
#define APPS_MODULES_CEMEDIA 1
#define APPS_MODULES_PXL 1
#define APPS_MODULES_XLS2PXL 1
#define APPS_MODULES_PXL2XLS 1
#define APPS_MODULES_PWWIFF 1
#define APPS_MODULES_PWORD 1
#define APPS_MODULES_PPT 1
#define APPS_MODULES_OFFICE 1
#define APPS_MODULES_ONENOTEMOBILE 1
#define APPS_MODULES_ONMDATAACCESS 1
#define APPS_MODULES_OMGRAPHICS 1
#define APPS_MODULES_CEWS 1
#define APPS_MODULES_OFFINET 1
#define APPS_MODULES_SPELLERV3 1
#define APPS_MODULES_SPELLMANAGER 1
#define APPS_MODULES_ZIPVIEW 1
#define APPS_MODULES_FAXVIEW 1
#define APPS_MODULES_SPSYNC 1
#define APPS_MODULES_SPAPI 1
#define APPS_MODULES_SPMC 1
#define APPS_MODULES_SPMCSITES 1
#define APPS_MODULES_SPMCDOCLIB 1
#define APPS_MODULES_SPOBJECTS 1
#define APPS_MODULES_SPDATASTORE 1
#define APPS_MODULES_SPSITE 1
#define APPS_MODULES_SPLIST 1
#define APPS_MODULES_SPDOCITEM 1
#define APPS_MODULES_PIMUTIL 1
#define APPS_MODULES_CALSTORE 1
#define APPS_MODULES_IRSQRT 1
#define APPS_MODULES_PIMSTORE 1
#define APPS_MODULES_STVWCTRL 1
#define APPS_MODULES_MGDMAPIPOOM 1
#define APPS_MODULES_UNISTORE 1
#define APPS_MODULES_POSYNCSERVICES 1
#define APPS_MODULES_CALDLL 1
#define APPS_MODULES_TASKDLL 1
#define APPS_MODULES_CALNOT 1
#define APPS_MODULES_CONTACTSAPPDLL 1
#define APPS_MODULES_GALCONTACTSDLL 1
#define APPS_MODULES_CONTACTSRESOURCES 1
#define APPS_MODULES_CONTACTSSHARED 1
#define APPS_MODULES_CONTACTPOOMUI 1
#define APPS_MODULES_MCF 1
#define APPS_MODULES_CALENDARRES 1
#define APPS_MODULES_READCARDRES 1
#define APPS_MODULES_TASKSRES 1
#define APPS_MODULES_TASKS 1
#define APPS_MODULES_CALENDAR 1
#define APPS_MODULES_POUTLOOK 1
#define APPS_MODULES_CONTACTS 1
#define APPS_MODULES_NOTESAPP 1
#define APPS_MODULES_MDDRM 1
#define APPS_MODULES_IRMACTIVATE 1
#define APPS_MODULES_IRMTEST 1
#define APPS_MODULES_RMACTIVATE 1
#define APPS_MODULES_PPROV 1
#define APPS_MODULES_CALUPD 1
#define APPS_MODULES_SIMINIT 1
#define APPS_MODULES_CHNGTRK 1
#define APPS_MODULES_CEMAPI 1
#define APPS_MODULES_OUTRES 1
#define APPS_MODULES_MSGRES 1
#define APPS_MODULES_HTMLNOTE 1
#define APPS_MODULES_REHOST 1
#define APPS_MODULES_SHPTUTIL 1
#define APPS_MODULES_TMAILUTL 1
#define APPS_MODULES_TMAILUTLPRIV 1
#define APPS_MODULES_TMAIL 1
#define APPS_MODULES_MAILTRNS 1
#define APPS_MODULES_CMMAILTRNS 1
#define APPS_MODULES_MSNMOBILEPLUS 1
#define APPS_MODULES_PHONTRNS 1
#define APPS_MODULES_MAILCSP2 1
#define APPS_MODULES_SICLNT 1
#define APPS_MODULES_TOXICD 1
#define APPS_MODULES_SYNCRES 1
#define APPS_MODULES_SYNCUTIL 1
#define APPS_MODULES_SYNCMGR 1
#define APPS_MODULES_ACTSYNCC 1
#define APPS_MODULES_SYNCCSP 1
#define APPS_MODULES_SYNCLOG 1
#define APPS_MODULES_TASKSCHEDULERV1 1
#define APPS_MODULES_TSKSCHCSP 1
#define APPS_MODULES_TSKSCHEDULE 1
#define APPS_MODULES_PUSHROUTER 1
#define APPS_MODULES_CORESECPROVIDERS 1
#define APPS_MODULES_CFGHOST 1
#define APPS_MODULES_OMADMPRC 1
#define APPS_MODULES_OMADMCLIENT 1
#define APPS_MODULES_COREDPUS 1
#define APPS_MODULES_CERTINSTALLER 1
#define APPS_MODULES_MOBILECALC 1
#define APPS_MODULES_UPDATEBIN 1
#define APPS_MODULES_COLDINIT 1
#define APPS_MODULES_CIPHASE2 1
#define APPS_MODULES_TPCSOLITARE 1
#define APPS_MODULES_AUXDISP 1
#define APPS_MODULES_CMCLIENT 1
#define APPS_MODULES_LAP_PW 1
#define APPS_MODULES_ARINVALID 1
#define APPS_MODULES_LVRES 1
#define APPS_MODULES_TAPRES 1
#define APPS_MODULES_TPCUTIL 1
#define APPS_MODULES_PROFILES 1
#define APPS_MODULES_SETTINGS 1
#define APPS_MODULES_CORERESDLL 1
#define APPS_MODULES_OFFICERESDLL 1
#define APPS_MODULES_SHELLRESAPPSDLL 1
#define APPS_MODULES_TAPRES 1
#define APPS_MODULES_BTHASPLUGIN 1
#define APPS_MODULES_BTHAGSMS 1
#define APPS_MODULES_CEBITS 1
#define APPS_MODULES_IMGUPDATECSP 1
#define APPS_MODULES_DLREGCSP 1
#define APPS_MODULES_MDSRES 1
#define APPS_MODULES_HISTORYAPI 1
#define APPS_MODULES_HISTORYUI 1
#define APPS_MODULES_DOWNLOADSERVICE 1
#define APPS_MODULES_DOWNLOADINSTALLSERVICEMANAGER 1
#define APPS_MODULES_DOWNLOADINSTALLSERVICE 1
#define APPS_MODULES_DOWNLOADINSTALLSERVICEINTERNAL 1
#define APPS_MODULES_DOWNLOADINSTALLSERVICERPCSERVER 1
#define APPS_MODULES_INSTALLSERVICE 1
#define APPS_MODULES_DOWNLOADSERVICEPROCESS 1
#define APPS_MODULES_UISERVICE 1
#define APPS_MODULES_DOWNLOADINSTALLSERVICESENDRESULT 1
#define APPS_MODULES_DULOGGER 1
#define APPS_MODULES_WMUSTORE 1
#define APPS_MODULES_WMUUPDATE 1
#define APPS_MODULES_UPDATEBASE 1
#define APPS_MODULES_WMUCLIENT 1
#define APPS_MODULES_WMURES 1
#define APPS_MODULES_SQMDATA 1
#define APPS_MODULES_SQMCONN 1
#define APPS_MODULES_UPTIME 1
#define APPS_MODULES_UPTIMESQM 1
#define APPS_MODULES_WCELOAD 1
#define APPS_MODULES_CABINSTL 1
#define APPS_MODULES_INSTALLHOST 1
#define APPS_MODULES_REMOVEPROGRAMSCPL 1
#define APPS_MODULES_INSTALLPCL 1
#define APPS_MODULES_APPMGMNTSCHEDULER 1
#define APPS_MODULES_TRUSTREGSERVER 1
#define APPS_MODULES_APPINSTALLER 1
#define APPS_MODULES_HARVESTERNETLOG 1
#define APPS_MODULES_HARVESTERCOMMONTESTMODULE 1
#define APPS_MODULES_HARVESTERSYNCMODULE 1
#define APPS_MODULES_HARVESTERWIFIMODULE 1
#define APPS_MODULES_HARVESTERBLUETOOTHMODULE 1
#define APPS_MODULES_HARVESTERCONNMGRLISTENER 1
#define APPS_MODULES_HARVESTER 1
#define APPS_MODULES_NODEMONCSP 1
#define APPS_MODULES_NODEMONINITSESS 1
#define APPS_MODULES_OMDATAACCESSUTIL 1
#define APPS_MODULES_CONTACTSDATAACCESS 1
#define APPS_MODULES_TASKSDATAACCESS 1
#define APPS_MODULES_APPTSDATAACCESS 1
#define APPS_MODULES_MAPIDATAACCESS 1
#define APPS_MODULES_SMARTSEARCHPAGES 1
#define APPS_MODULES_PIMINDEXMAINTENANCE 1
#define APPS_MODULES_SETPROXY 1
#define APPS_MODULES_LPCOMMON 1
#define APPS_MODULES_LPWIZARDFULL 1
#define APPS_MODULES_LPWIZARDOOBE 1
#define APPS_MODULES_LANGPROVRES 1
#define APPS_MODULES_TEXTINPUTCPL 1
#define APPS_MODULES_SAS 1
#define APPS_MODULES_REGIONALCPL 1
#define APPS_MODULES_MACHINEENROLLER 1
#define APPS_MODULES_MACHINEENROLLERLAUNCH 1
#define APPS_MODULES_MENROLL 1
#define APPS_MODULES_CALENDARPLUGIN 1
#define APPS_MODULES_UBARENDERDRV 1
#define APPS_MODULES_IPSECVPNVNIC 1
#define APPS_MODULES_IPSECVPN 1
#define APPS_MODULES_IPSECVPNPM 1
#define APPS_MODULES_IPSECVPNCSP 1
#define APPS_MODULES_IPSECVPNRES 1
#define APPS_MODULES_IPSECVPNAPP 1
#define APPS_MODULES_ALERTER 1
#define APPS_MODULES_TDETCLIENT 1
#define PHONE_MODULES_CPROG 1
#define PHONE_MODULES_PHCONTROLLER 1
#define PHONE_MODULES_CELLTAPIHELPER 1
#define PHONE_MODULES_SETPROVIDER 1
#define PHONE_MODULES_PHONE 1
#define PHONE_MODULES_PHONEUTIL 1
#define PHONE_MODULES_SUPSVCS 1
#define PHONE_MODULES_PHDATAPROVIDERS 1
#define PHONE_MODULES_PHONEEXTUI 1
#define PHONE_MODULES_WRLSMGR 1
#define PHONE_MODULES_CONNECTUX 1
#define PHONE_MODULES_CONNSETTINGS 1
#define PHONE_MODULES_BLUETOOTHUX 1
#define PHONE_MODULES_BLUETOOTHCPL 1
#define PHONE_MODULES_SIMSEC 1
#define PHONE_MODULES_PHLOGUTL 1
#define PHONE_MODULES_AUDIORTGPHONECLIENT 1
#define PHONE_MODULES_PHONEPLUGIN 1
#define PHONE_MODULES_PHONERESDLL 1
#define PHONE_MODULES_PHONERES 1
#define PHONE_MODULES_PHONERES 1
#define PHONE_MODULES_PHONERES 1
#define PHONE_MODULES_PHONERES 1
#define PHONE_MODULES_CONNECTUXRESDLL 1
#define PHONE_MODULES_CONNECTUXRES 1
#define PHONE_MODULES_CONNECTUXRES 1
#define PHONE_MODULES_CONNECTUXRES 1
#define PHONE_MODULES_CONNECTUXRES 1
#define WINDOWSLIVE_MODULES_WINDOWSLIVE 1
#define COREDLL_COREMAIN 1
#define COREDLL_THUNKS 1
#define COREDLL_COREPOLICY 1
#define COREDLL_SHOWERR 1
#define COREDLL_CORECRT 1
#define COREDLL_CORESTRW 1
#define COREDLL_CORESIP 1
#define COREDLL_REGEXT 1
#define COREDLL_COREDLL_HANDLEARRAY 1
#define COREDLL_CCPSELECT 1
#define COREDLL_TNOTIFY 1
#define COREDLL_TAPILIB 1
#define COREDLL_TBTCORE 1
#define COREDLL_RECTAPI 1
#define COREDLL_WMGR_C 1
#define COREDLL_MGDI_C 1
#define COREDLL_ACCEL_C 1
#define COREDLL_RENDERCORE 1
#define COREDLL_MESSAGEDIALOGBOXTHUNK 1
#define COREDLL_SHCORE 1
#define COREDLL_IDLIST 1
#define COREDLL_PATH 1
#define COREDLL_SHORTCUT 1
#define COREDLL_SHEXEC 1
#define COREDLL_SHMISC 1
#define COREDLL_FILEOPEN 1
#define COREDLL_FILEINFO 1
#define COREDLL_SHELLAPIS 1
#define COREDLL_AYGTHUNKS 1
#define COREDLL_MRUSTUB 1
#define COREDLL_DSA 1
#define COREDLL_MMACM 1
#define COREDLL_MMACMUI 1
#define COREDLL_MMWAVE 1
#define COREDLL_MMSND 1
#define COREDLL_MMMIX 1
#define COREDLL_WAVEAPICFWD 1
#define COREDLL_BACKLIGHT 1
#define COREDLL_BATTERY 1
#define COREDLL_NLED 1
#define COREDLL_ASYNCIO 1
#define COREDLL_CORELOC 1
#define COREDLL_DEVENUM 1
#define COREDLL_DEVLOAD 1
#define COREDLL_COREVERSIONPKG 1
#define COREDLL_FIBER 1
#define COREDLL_COREIMM 1
#define COREDLL_INPUTSCOPES 1
#define COREDLL_CORESIOA 1
#define COREDLL_CORESTRA 1
#define COREDLL_CORESIOW 1
#define COREDLL_CRYPTAPI 1
#define COREDLL_FMTMSG 1
#define COREDLL_SERDEV 1
#define COREDLL_MULTIUI 1
#define COREDLL_CORELOC 1
#define COREDLL_CRT_CPP_EH_AND_RTTI 1
#define COREDLL_DELAYEDBOOTWORKAPI 1
#define COREDLL_FULL_CRT 1
#define COREDLL_CRYPTHASH 1
#define COREDLL_RSA32 1
#define COREDLL_SHOWERR 1
#define COREDLL_MSGBOX_SMARTFON 1
#define KCOREDLL_KCOREMAIN 1
#define KCOREDLL_KTHUNKS 1
#define KCOREDLL_KCOREPOLICY 1
#define KCOREDLL_SHOWERR 1
#define KCOREDLL_CORECRT 1
#define KCOREDLL_CORESTRW 1
#define KCOREDLL_CORESIP 1
#define KCOREDLL_REGEXT 1
#define KCOREDLL_COREDLL_HANDLEARRAY 1
#define KCOREDLL_CCPSELECT 1
#define KCOREDLL_TNOTIFY 1
#define KCOREDLL_TAPILIB 1
#define KCOREDLL_TBTCORE 1
#define KCOREDLL_RECTAPI 1
#define KCOREDLL_WMGR_C 1
#define KCOREDLL_MGDI_C 1
#define KCOREDLL_ACCEL_C 1
#define KCOREDLL_RENDERCORE 1
#define KCOREDLL_MESSAGEDIALOGBOXTHUNK 1
#define KCOREDLL_SHCORE 1
#define KCOREDLL_IDLIST 1
#define KCOREDLL_PATH 1
#define KCOREDLL_SHORTCUT 1
#define KCOREDLL_SHEXEC 1
#define KCOREDLL_SHMISC 1
#define KCOREDLL_FILEOPEN 1
#define KCOREDLL_FILEINFO 1
#define KCOREDLL_SHELLAPIS 1
#define KCOREDLL_AYGTHUNKS 1
#define KCOREDLL_MRUSTUB 1
#define KCOREDLL_DSA 1
#define KCOREDLL_MMACM 1
#define KCOREDLL_MMACMUI 1
#define KCOREDLL_MMWAVE 1
#define KCOREDLL_MMSND 1
#define KCOREDLL_MMMIX 1
#define KCOREDLL_WAVEAPICFWD 1
#define KCOREDLL_BACKLIGHT 1
#define KCOREDLL_BATTERY 1
#define KCOREDLL_NLED 1
#define KCOREDLL_ASYNCIO 1
#define KCOREDLL_CORELOC 1
#define KCOREDLL_DEVENUM 1
#define KCOREDLL_DEVLOAD 1
#define KCOREDLL_COREVERSIONPKG 1
#define KCOREDLL_FIBER 1
#define KCOREDLL_COREIMM 1
#define KCOREDLL_INPUTSCOPES 1
#define KCOREDLL_CORESIOA 1
#define KCOREDLL_CORESTRA 1
#define KCOREDLL_CORESIOW 1
#define KCOREDLL_CRYPTAPI 1
#define KCOREDLL_FMTMSG 1
#define KCOREDLL_SERDEV 1
#define KCOREDLL_MULTIUI 1
#define KCOREDLL_CORELOC 1
#define KCOREDLL_CRT_CPP_EH_AND_RTTI 1
#define KCOREDLL_DELAYEDBOOTWORKAPI 1
#define KCOREDLL_FULL_CRT 1
#define KCOREDLL_CRYPTHASH 1
#define KCOREDLL_RSA32 1
#define NK_NKCOMPR 1
#define NK_NKTZINIT 1
#define NK_NKMAPFILE 1
#define NK_NKMSGQ 1
#define NK_KACL 1
#define NK_OEMSTUB 1
#define NK_NKLOGGER 1
#define NKLOADER_NKLDR 1
#define OEM_NKSTUB 1
#define OEM_OEMMAIN 1
#define OEM_OEMMAIN_STATICKITL 1
#define COMMCTRL_TOOLBAR 1
#define COMMCTRL_UPDOWN 1
#define COMMCTRL_STATUS 1
#define COMMCTRL_PROPSHEET 1
#define COMMCTRL_LISTVIEW 1
#define COMMCTRL_TREEVIEW 1
#define COMMCTRL_DATE 1
#define COMMCTRL_TAB 1
#define COMMCTRL_PROGRESS 1
#define COMMCTRL_TRACKBAR 1
#define COMMCTRL_CAPEDIT 1
#define COMMCTRL_REBAR 1
#define COMMCTRL_CMDBAR 1
#define COMMCTRL_DSA 1
#define COMMCTRL_TOOLTIPS 1
#define COMMCTRL_FE 1
#define COMMCTRL_ANIMATE 1
#define COMMCTRL_LINK 1
#define COMMCTRL_LABELEDIT 1
#define COMMCTRL_BOXSELECT 1
#define COMMCTRL_SHAPIS 1
#define COMMCTRL_COMMCTRLVIEW 1
#define WINSOCK_SSLSOCK 1
#define PPP_PPP2SRVSTUB 1
#define FONTS_TAHOMA_1_08 1
#define FONTS_TAHOMABD_1_08 1
#define FONTS_COUR_1_30 1
#define FONTS_MANGAL 1
#define FONTS_LATHA 1
#define FONTS_GAUTAMI 1
#define FONTS_RAAVI 1
#define FONTS_SHRUTI 1
#define FONTS_TUNGA 1
#define FONTS_WINGDING 1
#define WAVEAPI_WAPIWAVE 1
#define WAVEAPI_AUDEVMAN 1
#define WAVEAPI_SWMIXER 1
#define WAVEAPIC_WAVEAPIC_ACM 1
#define WAVEAPIC_WAVEAPIC_ACMUI 1
#define WAVEAPIC_WAVEAPIC_WAVE 1
#define WAVEAPIC_WAVEAPIC_SND 1
#define WAVEAPIC_WAVEAPIC_MIX 1
#define DEVICE_DEVCORE 1
#define DEVICE_IORM 1
#define DEVICE_PMIF 1
#define PM_PM_PDA_PDD 1
#define PM_PM_MDD 1
#define PM_PM_PDD_COMMON 1
#define FATUTIL_FATUTIL_NOUI 1
#define FATUTIL_FATUTIL_MAIN 1
#define FATUTIL_EXFATUTIL 1
#define IMGUPD_KEY_FILE 1
#define IMGUPD_CIF_FILE 1
#define IMGUPD_SOF_FILE 1
#define IMGUPD_FSDMGR_INI 1
#define IMGFS_IMGFS_MAIN 1
#define IMGFS_IMGFS_NOWRITE 1
#define FILESYS_FSHEAP 1
#define FILESYS_FSMAIN 1
#define FILESYS_FSPROFILE 1
#define FILESYS_FSADVERTISE 1
#define FILESYS_FSEVENTLOG 1
#define FILESYS_FSREGHIVE 1
#define FILESYS_FSSECUREWIPE 1
#define FILESYS_FSREPLBIT 1
#define FILESYS_FSDBASE 1
#define FILESYS_FSPASS 1
#define FILESYS_FSACL 1
#define FILESYS_ADB 1
#define CECOMPR_XPRDECOMP 1
#define COREDLL_COREMAIN 1
#define COREDLL_THUNKS 1
#define COREDLL_COREPOLICY 1
#define COREDLL_SHOWERR 1
#define COREDLL_CORECRT 1
#define COREDLL_CORESTRW 1
#define COREDLL_CORESIP 1
#define COREDLL_REGEXT 1
#define COREDLL_COREDLL_HANDLEARRAY 1
#define COREDLL_CCPSELECT 1
#define COREDLL_TNOTIFY 1
#define COREDLL_TAPILIB 1
#define COREDLL_TBTCORE 1
#define COREDLL_RECTAPI 1
#define COREDLL_WMGR_C 1
#define COREDLL_MGDI_C 1
#define COREDLL_ACCEL_C 1
#define COREDLL_RENDERCORE 1
#define COREDLL_MESSAGEDIALOGBOXTHUNK 1
#define COREDLL_SHCORE 1
#define COREDLL_IDLIST 1
#define COREDLL_PATH 1
#define COREDLL_SHORTCUT 1
#define COREDLL_SHEXEC 1
#define COREDLL_SHMISC 1
#define COREDLL_FILEOPEN 1
#define COREDLL_FILEINFO 1
#define COREDLL_SHELLAPIS 1
#define COREDLL_AYGTHUNKS 1
#define COREDLL_MRUSTUB 1
#define COREDLL_DSA 1
#define COREDLL_MMACM 1
#define COREDLL_MMACMUI 1
#define COREDLL_MMWAVE 1
#define COREDLL_MMSND 1
#define COREDLL_MMMIX 1
#define COREDLL_WAVEAPICFWD 1
#define COREDLL_BACKLIGHT 1
#define COREDLL_BATTERY 1
#define COREDLL_NLED 1
#define COREDLL_ASYNCIO 1
#define COREDLL_CORELOC 1
#define COREDLL_DEVENUM 1
#define COREDLL_DEVLOAD 1
#define COREDLL_COREVERSIONPKG 1
#define COREDLL_FIBER 1
#define COREDLL_COREIMM 1
#define COREDLL_INPUTSCOPES 1
#define COREDLL_CORESIOA 1
#define COREDLL_CORESTRA 1
#define COREDLL_CORESIOW 1
#define COREDLL_CRYPTAPI 1
#define COREDLL_FMTMSG 1
#define COREDLL_SERDEV 1
#define COREDLL_MULTIUI 1
#define COREDLL_CORELOC 1
#define COREDLL_CRT_CPP_EH_AND_RTTI 1
#define COREDLL_DELAYEDBOOTWORKAPI 1
#define COREDLL_FULL_CRT 1
#define COREDLL_CRYPTHASH 1
#define COREDLL_RSA32 1
#define COREDLL_SHOWERR 1
#define COREDLL_MSGBOX_SMARTFON 1
#define KCOREDLL_KCOREMAIN 1
#define KCOREDLL_KTHUNKS 1
#define KCOREDLL_KCOREPOLICY 1
#define KCOREDLL_SHOWERR 1
#define KCOREDLL_CORECRT 1
#define KCOREDLL_CORESTRW 1
#define KCOREDLL_CORESIP 1
#define KCOREDLL_REGEXT 1
#define KCOREDLL_COREDLL_HANDLEARRAY 1
#define KCOREDLL_CCPSELECT 1
#define KCOREDLL_TNOTIFY 1
#define KCOREDLL_TAPILIB 1
#define KCOREDLL_TBTCORE 1
#define KCOREDLL_RECTAPI 1
#define KCOREDLL_WMGR_C 1
#define KCOREDLL_MGDI_C 1
#define KCOREDLL_ACCEL_C 1
#define KCOREDLL_RENDERCORE 1
#define KCOREDLL_MESSAGEDIALOGBOXTHUNK 1
#define KCOREDLL_SHCORE 1
#define KCOREDLL_IDLIST 1
#define KCOREDLL_PATH 1
#define KCOREDLL_SHORTCUT 1
#define KCOREDLL_SHEXEC 1
#define KCOREDLL_SHMISC 1
#define KCOREDLL_FILEOPEN 1
#define KCOREDLL_FILEINFO 1
#define KCOREDLL_SHELLAPIS 1
#define KCOREDLL_AYGTHUNKS 1
#define KCOREDLL_MRUSTUB 1
#define KCOREDLL_DSA 1
#define KCOREDLL_MMACM 1
#define KCOREDLL_MMACMUI 1
#define KCOREDLL_MMWAVE 1
#define KCOREDLL_MMSND 1
#define KCOREDLL_MMMIX 1
#define KCOREDLL_WAVEAPICFWD 1
#define KCOREDLL_BACKLIGHT 1
#define KCOREDLL_BATTERY 1
#define KCOREDLL_NLED 1
#define KCOREDLL_ASYNCIO 1
#define KCOREDLL_CORELOC 1
#define KCOREDLL_DEVENUM 1
#define KCOREDLL_DEVLOAD 1
#define KCOREDLL_COREVERSIONPKG 1
#define KCOREDLL_FIBER 1
#define KCOREDLL_COREIMM 1
#define KCOREDLL_INPUTSCOPES 1
#define KCOREDLL_CORESIOA 1
#define KCOREDLL_CORESTRA 1
#define KCOREDLL_CORESIOW 1
#define KCOREDLL_CRYPTAPI 1
#define KCOREDLL_FMTMSG 1
#define KCOREDLL_SERDEV 1
#define KCOREDLL_MULTIUI 1
#define KCOREDLL_CORELOC 1
#define KCOREDLL_CRT_CPP_EH_AND_RTTI 1
#define KCOREDLL_DELAYEDBOOTWORKAPI 1
#define KCOREDLL_FULL_CRT 1
#define KCOREDLL_CRYPTHASH 1
#define KCOREDLL_RSA32 1
#define NOTIFY_NOTIFPUB 1
#define NOTIFY_NOTIFUI 1
#define NOTIFY_NOTIFPUB 1
#define NOTIFY_DLGCMN2 1
#define COMMCTRL_TOOLBAR 1
#define COMMCTRL_UPDOWN 1
#define COMMCTRL_STATUS 1
#define COMMCTRL_PROPSHEET 1
#define COMMCTRL_LISTVIEW 1
#define COMMCTRL_TREEVIEW 1
#define COMMCTRL_DATE 1
#define COMMCTRL_TAB 1
#define COMMCTRL_PROGRESS 1
#define COMMCTRL_TRACKBAR 1
#define COMMCTRL_CAPEDIT 1
#define COMMCTRL_REBAR 1
#define COMMCTRL_CMDBAR 1
#define COMMCTRL_DSA 1
#define COMMCTRL_TOOLTIPS 1
#define COMMCTRL_FE 1
#define COMMCTRL_ANIMATE 1
#define COMMCTRL_LINK 1
#define COMMCTRL_LABELEDIT 1
#define COMMCTRL_BOXSELECT 1
#define COMMCTRL_SHAPIS 1
#define COMMCTRL_COMMCTRLVIEW 1
#define BTAGSVC_BTAG_MDD_PHONEEXT 1
#define BTAGSVC_BTAG_MDD_NETWORK 1
#define BTAGSVC_BTAG_MDD_BOND 1
#define GWES_GWE1 1
#define GWES_WMBASE 1
#define GWES_GWESHARE 1
#define GWES_GWESMAIN 1
#define GWES_IMMTHUNK 1
#define GWES_MSGQUE 1
#define GWES_GSETWINLONG 1
#define GWES_CEPTR 1
#define GWES_GWEPERF 1
#define GWES_FOREGND 1
#define GWES_IDLE 1
#define GWES_KBDUI 1
#define GWES_UIBASE 1
#define GWES_MSGBEEP 1
#define GWES_PIXELDOUBLE 1
#define GWES_RCTHUNK 1
#define GWES_AUDIO 1
#define GWES_GWE2 1
#define GWES_MGBASE 1
#define GWES_MGBITMAP 1
#define GWES_MGBLT 1
#define GWES_MGBLT2 1
#define GWES_MGDC 1
#define GWES_MGDIBSEC 1
#define GWES_MGDRAW 1
#define GWES_MGRGN 1
#define GWES_MGWINMGR 1
#define GWES_TCHUI 1
#define GWES_MGGRADFILL 1
#define GWES_MGALPHABLEND 1
#define GWES_MGTT 1
#define GWES_MGFE 1
#define GWES_MGFNTFIX 1
#define GWES_MGDRWTXT 1
#define GWES_MGPRINT 1
#define GWES_MGPAL 1
#define GWES_MGPALNAT 1
#define GWES_GWE3 1
#define GWES_ACCEL 1
#define GWES_BTNCTL 1
#define GWES_CARET 1
#define GWES_CASCADE 1
#define GWES_IMECTL 1
#define GWES_CLIPBD 1
#define GWES_CMBCTL 1
#define GWES_DEFWNDPROC 1
#define GWES_DLGMGR 1
#define GWES_DLGMNEM 1
#define GWES_EDCTL 1
#define GWES_GCACHE 1
#define GWES_GWECTRL 1
#define GWES_ICON 1
#define GWES_ICONCMN 1
#define GWES_IMGCTL 1
#define GWES_LBCTL 1
#define GWES_LOADBMP 1
#define GWES_LOADIMG 1
#define GWES_MENU 1
#define GWES_MENUSCRL 1
#define GWES_MOVERLAP 1
#define GWES_MENUGDI 1
#define GWES_MENURC 1
#define GWES_MOUSEANDTOUCHCURSOR 1
#define GWES_ICONCURS 1
#define GWES_MCURSOR 1
#define GWES_MCURSOR8 1
#define GWES_CURSOR 1
#define GWES_CURSOR8 1
#define GWES_CMENU 1
#define GWES_MENUPG 1
#define GWES_MTAPUI 1
#define GWES_TOUCHGESTURE 1
#define GWES_GESTUREANIMATION 1
#define GWES_PHYSICSWRAPPER 1
#define GWES_MENUGESTURES 1
#define GWES_GWE4 1
#define GWES_NCLIENT 1
#define GWES_SBCMN 1
#define GWES_SCBCTL 1
#define GWES_STARTUP 1
#define GWES_STCCTL 1
#define GWES_WINMGR 1
#define GWES_WINMOBILEOOM 1
#define GWES_SBCMNVIEW 1
#define GWES_NCLIENTVIEW 1
#define GWES_GCACHEVIEW 1
#define GWES_BTNCTLVIEW 1
#define GWES_STCCTLVIEW 1
#define GWES_CMBCTLVIEW 1
#define GWES_EDCTLVIEW 1
#define GWES_LBCTLVIEW 1
#define GWES_MENUVIEW 1
#define GWES_EDIMEFETPC 1
#define GWES_BTNGDI 1
#define GWES_BTNRC 1
#define GWES_SBUIGDI 1
#define GWES_SBUIRC 1
#define GWES_MSGBOX 1
#define GWES_MSGBOX_HPC 1
#define GWES_DLGMGR_TPC 1
#define GWES_MENU_TPC 1
#define GWES_CMBCTL_TPC 1
#define GWES_LBCTL_TPC 1
#define GWES_BTNCTL_TPC 1
#define GWES_EDITCONTROLTPC 1
#define GWES_AGCOREPAL_GWES 1
#define GWES_COMPOSITIONCORE_GWES 1
#define GWES_GWESCOMPOSITION_COMMON 1
#define GWES_GWESCOMPOSITION_KERNEL 1
#define GWES_GWESCOMPOSITION_USER 1
#define GWES_TIMER 1
#define GWES_COLUMN 1
#define GWES_ATOM 1
#define GWES_DRAWMBAR 1
#define GWES_HOTKEY 1
#define GWES_SYSCOLOR 1
#define GWES_MGALIAS 1
#define GWES_JOURNAL 1
#define GWES_DDCORE 1
#define GWES_MGTCI 1
#define GWES_GCACHEVIEW 1
#define GWES_GCACHEVW_SMARTFON 1
#define GWES_CURSOR8 1
#define GWES_NCLIENTVIEW 1
#define GWES_NCLIENTVIEW_SMARTFON 1
#define GWES_CURSOR 1
#define GWES_BTNCTLVIEW 1
#define GWES_BTNCTLVIEW_SMARTFON 1
#define GWES_CMBCTLVIEW 1
#define GWES_EDCTLVIEW 1
#define GWES_LBCTLVIEW 1
#define GWES_LBCTLVIEW_SMARTFON 1
#define GWES_MENUVIEW 1
#define GWES_SBCMNVIEW_SMARTFON 1
#define GWES_STCCTLVIEW 1
#define MGTT_O_DECOMPDRV 1
#define GWEUSER_GWEUSERMAIN 1
#define GWEUSER_GWEUSERSTARTUI 1
#define GWEUSER_GWEUSEROOMUI 1
#define GWEUSER_GWEUSERCALIBRATEUI 1
#define GWEUSER_STARTUI_SMARTFON 1
#define GWEUSER_OOMUI_SMARTFON 1
#define GWEUSER_CALIBRUI_SMARTFON 1
#define GWEUSER_DLGCMN 1
#define OLE32_DCOMOLE 1
#define OLE32_STG 1
#define OLEAUT32_OAALL 1
#define OLEAUT32_IDISPPROXY 1
#define IMAGING_IMG_ICO 1
#define IMAGING_IMG_TIFF 1
#define IMAGING_IMG_LIBTIFF 1
#define IMAGING_IMG_PNG 1
#define IMAGING_IMG_LIBPNG 1
#define IMAGING_IMG_PNGENCODER 1
#define IMAGING_IMG_PNGDECODER 1
#define IMAGING_IMG_GIF 1
#define IMAGING_IMG_LIBLZW 1
#define IMAGING_IMG_GIFENCODER 1
#define IMAGING_IMG_GIFDECODER 1
#define IMAGING_IMG_JPEG 1
#define IMAGING_IMG_JPEGFULL 1
#define IMAGING_IMG_JPEGMEM 1
#define IMAGING_IMG_JPEGENCODER 1
#define IMAGING_IMG_JPEGDECODER 1
#define IMAGING_IMG_BMP 1
#define IMAGING_IMG_BMPENCODER 1
#define IMAGING_IMG_BMPDECODER 1
#define MSXML3_XMLDOM 1
#define MSXML3_XMLMIME 1
#define MSXML3_XMLXSLT 1
#define MSXML3_XMLXQL 1
#define MSXML3_XMLSAX 1
#define MSXML3_XMLHTTP 1
#define MSXML3_XMLNETFULL 1
#define WININET_PPSTUBS 1
#define VBSCRIPT_VBSSTUBS 1
#define EXSMIME_DSTRUCT 1
#define EXSMIME_EXSMIME_COMMON 1
#define SHCORE_IDLIST 1
#define SHCORE_PATH 1
#define CESHELL_CESHAPI 1
#define CESHELL_CESHUI 1
#define CESHELL_TASKBARLIST 1
#define CESHELL_FOLDERATTRIBUTES 1
#define CESHELL_CESHUIMOBILE 1
#define CESHELL_CESHNORECBIN 1
#define SHUTIL_SHUTIL_SMARTFON 1
#define QUARTZ_QUARTZ0 1
#define QUARTZ_AMUTIL 1
#define QUARTZ_FGCTL 1
#define QUARTZ_FILGRAPH 1
#define QUARTZ_QUARTZ1 1
#define QUARTZ_WAVEOUT 1
#define QUARTZ_WAVEMSR 1
#define QUARTZ_AVIMSR 1
#define QUARTZ_AVIDEC 1
#define QUARTZ_MPGADEC 1
#define QUARTZ_MPGVDEC 1
#define QUARTZ_MP3FILTER 1
#define QUARTZ_MPGSPLIT 1
#define QUARTZ_ACMWRAP 1
#define QUARTZ_DMOWRAP 1
#define QUARTZ_URLRDR 1
#define QUARTZ_QUARTZ2 1
#define QUARTZ_ASYNCRDR 1
#define QUARTZ_QTZBASE 1
#define QUARTZ_IMGSINK 1
#define QUARTZ_SMARTTEE 1
#define QUARTZ_QUARTZ3 1
#define QUARTZ_VMRALLOCLIB 1
#define QUARTZ_VMRALLOCATORPRESENTER 1
#define QUARTZ_VMRWINDOWMANAGER 1
#define QUARTZ_VMRIMAGESYNC 1
#define QUARTZ_VMRMIXER 1
#define QUARTZ_VMRRENDERER 1
#define QUARTZ_ASFWRITER 1
#define QUARTZ_ASFMUXCORE 1
#define QUARTZ_WAVEIN 1
#define QUARTZ_VIDCAP 1
#define QUARTZ_FILCAP 1
#define QUARTZ_SCMDOUT 1
#define QUARTZ_FILEREND 1
#define QUARTZ_WMT_STRMCORE 1
#define QUARTZ_WMT_SPLITTER 1
#define QUARTZ_ACMOBJ 1
#define QUARTZ_ICMOBJ 1
#define QUARTZ_M3UPLAYL 1
#define QUARTZ_ASXPLAYL 1
#define QUARTZ_XMLPLAYL 1
#define QUARTZ_URLGRAB 1
#define QUARTZ_URLOBJ 1
#define QUARTZ_WMT_HTTPSTRM 1
#define QUARTZ_WMT_MMSSTRM 1
#define QUARTZ_WMT_MSBSTRM 1
#define QUARTZ_WMT_NETHELP 1
#define QUARTZ_WMT_FILESTRM 1
#define QUARTZ_PLAYREADYDRM 1
#define QUARTZ_CONNECTHELPER 1
#define QUARTZ_QUARTZ4 1
#define QUARTZ_COLOUR 1
#define QUARTZ_BUFFILTER 1
#define QUARTZ_COLOUR 1
#define QUARTZ_GENSTREAMER 1
#define QUARTZ_QUARTZ4 1
#define QUARTZ_COLOUR 1
#define QUARTZ_BUFFILTER 1
#define QUARTZ_COLOUR 1
#define QUARTZ_GENSTREAMER 1
#define QUARTZ_QUARTZ3 1
#define QUARTZ_VMRALLOCLIB 1
#define QUARTZ_VMRALLOCATORPRESENTER 1
#define QUARTZ_VMRWINDOWMANAGER 1
#define QUARTZ_VMRIMAGESYNC 1
#define QUARTZ_VMRMIXER 1
#define QUARTZ_VMRRENDERER 1
#define QUARTZ_ASFWRITER 1
#define QUARTZ_ASFMUXCORE 1
#define QUARTZ_WAVEIN 1
#define QUARTZ_VIDCAP 1
#define QUARTZ_FILCAP 1
#define QUARTZ_SCMDOUT 1
#define QUARTZ_FILEREND 1
#define QUARTZ_WMT_STRMCORE 1
#define QUARTZ_WMT_SPLITTER 1
#define QUARTZ_ACMOBJ 1
#define QUARTZ_ICMOBJ 1
#define QUARTZ_M3UPLAYL 1
#define QUARTZ_ASXPLAYL 1
#define QUARTZ_XMLPLAYL 1
#define QUARTZ_URLGRAB 1
#define QUARTZ_URLOBJ 1
#define QUARTZ_WMT_HTTPSTRM 1
#define QUARTZ_WMT_MMSSTRM 1
#define QUARTZ_WMT_MSBSTRM 1
#define QUARTZ_WMT_NETHELP 1
#define QUARTZ_WMT_FILESTRM 1
#define QUARTZ_PLAYREADYDRM 1
#define QUARTZ_CONNECTHELPER 1
#define QUARTZ_QUARTZ3 1
#define QUARTZ_VMRALLOCLIB 1
#define QUARTZ_VMRALLOCATORPRESENTER 1
#define QUARTZ_VMRWINDOWMANAGER 1
#define QUARTZ_VMRIMAGESYNC 1
#define QUARTZ_VMRMIXER 1
#define QUARTZ_VMRRENDERER 1
#define QUARTZ_ASFWRITER 1
#define QUARTZ_ASFMUXCORE 1
#define QUARTZ_WAVEIN 1
#define QUARTZ_VIDCAP 1
#define QUARTZ_FILCAP 1
#define QUARTZ_SCMDOUT 1
#define QUARTZ_FILEREND 1
#define QUARTZ_WMT_STRMCORE 1
#define QUARTZ_WMT_SPLITTER 1
#define QUARTZ_ACMOBJ 1
#define QUARTZ_ICMOBJ 1
#define QUARTZ_M3UPLAYL 1
#define QUARTZ_ASXPLAYL 1
#define QUARTZ_XMLPLAYL 1
#define QUARTZ_URLGRAB 1
#define QUARTZ_URLOBJ 1
#define QUARTZ_WMT_HTTPSTRM 1
#define QUARTZ_WMT_MMSSTRM 1
#define QUARTZ_WMT_MSBSTRM 1
#define QUARTZ_WMT_NETHELP 1
#define QUARTZ_WMT_FILESTRM 1
#define QUARTZ_PLAYREADYDRM 1
#define QUARTZ_CONNECTHELPER 1
#define SYSCSPS_CERTIFICATECSP 1
#define SYSCSPS_SOUNDCSP 1
#define SYSCSPS_LOCALECSP 1
#define SYSCSPS_DEVINFOCSP 1
#define SYSCSPS_CLOCKCSP 1
#define SYSCSPS_POLICYCSP 1
#define SYSCSPS_PROFILECSP 1
#define SYSCSPS_NOTIFCSP 1
#define SYSCSPS_REVOCATIONLISTCSP 1
#define SYSCSPS_APPDISABLECSP 1
#define SYSCSPS_WAPCSP 1
#define SYSCSPS_FILECSP 1
#define SYSCSPS_UNINSTALLCSP 1
#define SYSCSPS_INSTDLLCSP 1
#define SYSCSPS_METABASECSP 1
#define SYSCSPS_BTHCSP 1
#define SYSCSPS_OBEXCSP 1
#define SYSCSPS_LEGACYCSP 1
#define SYSCSPS_SPEEDDIALCSP 1
#define SYSCSPS_APPLCSP 1
#define SYSCSPS_ENCRYPTIONCSP 1
#define SYSCSPS_CERTIFICATEENROLLERCSP 1
#define SYSCSPS_REMOTEWIPECSP 1
#define SYSCSPS_TEXTINPUTCSP 1
#define SYSCSPS_PCLCSP 1
#define SYSCSPS_DEVINFO2CSP 1
#define SYSCSPS_DEVDETAILCSP 1
#define SYSCSPS_DMACCCSP 1
#define SYSCSPS_DMSCSP 1
#define SYSCSPS_DOWNLOADCSP 1
#define SYSCSPS_INVENTORYCSP 1
#define SYSCSPS_FILESYSTEMCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define DMCSPS_V2INTEROPCSP 1
#define MLSERVICE_MLSUPDATE 1
#define MLSERVICE_MLSNOTIFY 1
#define MLSERVICE_MLSINDEX 1
#define PIMUTIL_PARSERX 1
#define PIMUTIL_PARSERXSTUBS_SMARTFON 1
#define PIMUTIL_PARSERO11 1
#define CEMAPI_MAILUTIL_MISC 1
#define CEMAPI_MSGLIB_DUPSTRING 1
#define CEMAPI_MSGLIB_XLIST 1
#define CEMAPI_MSGLIB_FILESTM 1
#define OUTRES_OUTRES_SMARTFON 1
#define TMAILUTL_MAILUTIL_MISC 1
#define TMAILUTL_MAILUTIL_TPCMISC 1
#define TMAILUTL_MSGLIB_ACCOUNTNAME 1
#define TMAILUTL_MSGLIB_DUPSTRING 1
#define TMAILUTL_MSGLIB_FILESTM 1
#define TMAILUTL_MSGLIB_MIMEADDR 1
#define TMAILUTL_MSGLIB_XLIST 1
#define TMAILUTL_MAILUTIL_TNEF 1
#define TMAILUTL_MAILUTIL_VCAL 1
#define TMAILUTL_MAILUTIL_VCAL_SMARTFON 1
#define TMAILUTL_MAILUTIL_RTF 1
#define TMAILUTL_MAILUTIL_NOTIFYREDIRECTOR 1
#define TMAILUTLPRIV_MAILUTILPRIV_CRYPTO 1
#define TMAILUTLPRIV_MAILUTILPRIV_IRMUTILS 1
#define TMAILUTLPRIV_MAILUTILPRIV_MIME 1
#define TMAILUTLPRIV_MAILUTILPRIV_MISC 1
#define TMAILUTLPRIV_MSGLIB_DUPSTRING 1
#define TMAILUTLPRIV_MSGLIB_FILESTM 1
#define TMAILUTLPRIV_MSGLIB_XLIST 1
#define MAILTRNS_MSGLIB_XLIST 1
#define MAILTRNS_MSGLIB_DUPSTRING 1
#define MAILTRNS_IMAP_LIB 1
#define MAILTRNS_SMTP_LIB 1
#define MAILTRNS_POP3_LIB 1
#define MAILTRNS_MAILTRNS_SUPPORT 1
#define CMMAILTRNS_MSGLIB_XLIST 1
#define CMMAILTRNS_MSGLIB_DUPSTRING 1
#define CMMAILTRNS_SMTP_LIB 1
#define CMMAILTRNS_CMPOP3_LIB 1
#define CMMAILTRNS_MAILTRNS_SUPPORT 1
#define PHONTRNS_SMSTRN_LIB 1
#define PHONTRNS_MAILTRNS_SUPPORT 1
#define PHONTRNS_MSGLIB_XLIST 1
#define PHONTRNS_MSGLIB_DUPSTRING 1
#define CORESECPROVIDERS_DEFAULTAUTHPROV 1
#define CORESECPROVIDERS_WAPAUTHPROV_SMARTFON 1
#define CORESECPROVIDERS_SYNCMLAUTHPROV 1

// <SYSGENS>
// SYSGEN_ACCOUNTDB
// SYSGEN_ACL
// SYSGEN_ACM_GSM610
// SYSGEN_ASSOCENG
// SYSGEN_ASYNCMAC
// SYSGEN_ATADISK
// SYSGEN_ATL
// SYSGEN_AUDIO
// SYSGEN_AUDIO_ACM
// SYSGEN_AUDIO_AUDIORTGMGR
// SYSGEN_AUTH
// SYSGEN_AUTH_NTLM
// SYSGEN_AUTH_SCHANNEL
// SYSGEN_AVRCP_MPPLUGIN
// SYSGEN_BACKLIGHT
// SYSGEN_BATTERY
// SYSGEN_BTH
// SYSGEN_BTH_A2DP
// SYSGEN_BTH_AG
// SYSGEN_BTH_AVCTP
// SYSGEN_BTH_AVDTP
// SYSGEN_BTH_AVRCP
// SYSGEN_BTH_HID_KEYBOARD
// SYSGEN_CACHEFILT
// SYSGEN_CAMERA_NULL
// SYSGEN_CCPSELECT
// SYSGEN_CECOMPR_XPR_DECOMPRESS
// SYSGEN_CEDDK
// SYSGEN_CELLCORE
// SYSGEN_CELLCORE_710MUX
// SYSGEN_CELLCORE_ATCI
// SYSGEN_CELLCORE_CELLTSP
// SYSGEN_CELLCORE_EVENTLOG
// SYSGEN_CELLCORE_RIL
// SYSGEN_CELLCORE_RILLOG
// SYSGEN_CELLCORE_SIM
// SYSGEN_CELLCORE_SIMTKIT
// SYSGEN_CELLCORE_SMS
// SYSGEN_CELLCORE_WAP
// SYSGEN_CELLCORE_WWAN
// SYSGEN_CEPERF
// SYSGEN_CERTS
// SYSGEN_CERTS_PFX
// SYSGEN_CHNIME4_DB_1
// SYSGEN_CHNIME_SC
// SYSGEN_CNG_CORE
// SYSGEN_CNG_KEY
// SYSGEN_COMMCTRL
// SYSGEN_COMMCTRL_ANIMATE
// SYSGEN_COMMCTRL_LINK
// SYSGEN_COMMDLG
// SYSGEN_COMPOSITION
// SYSGEN_COMPOSITION_HARDWARE
// SYSGEN_CONNMGR
// SYSGEN_CONNMGR2
// SYSGEN_CORELOC
// SYSGEN_CORESTRA
// SYSGEN_CPP_EH_AND_RTTI
// SYSGEN_CPP_SEH
// SYSGEN_CREDMAN
// SYSGEN_CRYPTMSG
// SYSGEN_CRYPTO
// SYSGEN_CRYPTO_DSSDH
// SYSGEN_CURSOR
// SYSGEN_CXPORT
// SYSGEN_DCOM
// SYSGEN_DDRAW
// SYSGEN_DEVICE
// SYSGEN_DHCP
// SYSGEN_DHCPSRV
// SYSGEN_DISPLAY
// SYSGEN_DMSRV
// SYSGEN_DNSAPI
// SYSGEN_DOTNETV2
// SYSGEN_DOTNETV37
// SYSGEN_DOTNETV37_SMARTFON
// SYSGEN_DOTNETV37_SUPPORT
// SYSGEN_DSHOW
// SYSGEN_DSHOW_ACMWRAP
// SYSGEN_DSHOW_AUDIO
// SYSGEN_DSHOW_AVI
// SYSGEN_DSHOW_CAPTURE
// SYSGEN_DSHOW_DISPLAY
// SYSGEN_DSHOW_DMO
// SYSGEN_DSHOW_DSHOWREMOTE
// SYSGEN_DSHOW_GENERICSTREAMER
// SYSGEN_DSHOW_ICM
// SYSGEN_DSHOW_IMAADPCM
// SYSGEN_DSHOW_MIDIPARSER
// SYSGEN_DSHOW_MIDISYNTH
// SYSGEN_DSHOW_MP3
// SYSGEN_DSHOW_MPEGA
// SYSGEN_DSHOW_MPEGSPLITTER
// SYSGEN_DSHOW_MPEGV
// SYSGEN_DSHOW_MSADPCM
// SYSGEN_DSHOW_MSG711
// SYSGEN_DSHOW_MSRLE
// SYSGEN_DSHOW_URLRDR
// SYSGEN_DSHOW_VMR
// SYSGEN_DSHOW_WAV
// SYSGEN_DSHOW_WAVEOUT
// SYSGEN_DSHOW_WMA
// SYSGEN_DSHOW_WMA_VOICE
// SYSGEN_DSHOW_WMT
// SYSGEN_DSHOW_WMT_ASXV1
// SYSGEN_DSHOW_WMT_ASXV2
// SYSGEN_DSHOW_WMT_ASXV3
// SYSGEN_DSHOW_WMT_DRMOCX
// SYSGEN_DSHOW_WMT_HTTP
// SYSGEN_DSHOW_WMT_LOCAL
// SYSGEN_DSHOW_WMT_MMS
// SYSGEN_DSHOW_WMT_MULTI
// SYSGEN_DSHOW_WMT_PLAYREADYDRM
// SYSGEN_DSHOW_WMV
// SYSGEN_DSHOW_XDRMREMOTE
// SYSGEN_DSTSVC
// SYSGEN_DTPT
// SYSGEN_EAP
// SYSGEN_EAPHOST
// SYSGEN_EDB
// SYSGEN_ENCFILT
// SYSGEN_ETHERNET
// SYSGEN_ETH_80211
// SYSGEN_ETH_80211_NWIFI
// SYSGEN_EVGEN
// SYSGEN_FATFS
// SYSGEN_FATUTIL_NOUI
// SYSGEN_FDRM2
// SYSGEN_FIBER
// SYSGEN_FMTMSG
// SYSGEN_FONTS_COUR_1_30
// SYSGEN_FONTS_GAUTAMI
// SYSGEN_FONTS_LATHA
// SYSGEN_FONTS_MANGAL
// SYSGEN_FONTS_RAAVI
// SYSGEN_FONTS_SHRUTI
// SYSGEN_FONTS_TAHOMABD_1_08
// SYSGEN_FONTS_TAHOMA_1_08
// SYSGEN_FONTS_TUNGA
// SYSGEN_FONTS_WINGDING
// SYSGEN_FSDBASE
// SYSGEN_FSDMGR
// SYSGEN_FSPASSWORD
// SYSGEN_FSREGHIVE
// SYSGEN_FSREPLBIT
// SYSGEN_FSREPLXFILT
// SYSGEN_FSROMONLY
// SYSGEN_FULLGWES
// SYSGEN_FULL_CRT
// SYSGEN_GDI_ALPHABLEND
// SYSGEN_GDI_FONTFIX
// SYSGEN_GESTUREANIMATION
// SYSGEN_GPE_CLEARTYPE
// SYSGEN_GPSID
// SYSGEN_GRADFILL
// SYSGEN_GSMSKU
// SYSGEN_HWR
// SYSGEN_IE7_DXTMSFT
// SYSGEN_IE7_DXTRANS
// SYSGEN_IE7_GESTURESUPPORT
// SYSGEN_IE7_HTMLVIEW
// SYSGEN_IE7_IEFRAME
// SYSGEN_IE7_IETHEME
// SYSGEN_IE7_IETHMWM
// SYSGEN_IE7_IMGUTIL
// SYSGEN_IE7_MLANG
// SYSGEN_IE7_MOBILEWORKINGMODE
// SYSGEN_IE7_MSHTML
// SYSGEN_IE7_MSLS
// SYSGEN_IE7_PANELDETECTION
// SYSGEN_IE7_PNGFILT
// SYSGEN_IE7_SHLWAPI
// SYSGEN_IE7_THUMBVW
// SYSGEN_IE7_URLMON
// SYSGEN_IE7_WININET
// SYSGEN_IMAGING
// SYSGEN_IMAGING_BMP_DECODE
// SYSGEN_IMAGING_BMP_ENCODE
// SYSGEN_IMAGING_GIF_DECODE
// SYSGEN_IMAGING_GIF_ENCODE
// SYSGEN_IMAGING_ICO_DECODE
// SYSGEN_IMAGING_ICO_ENCODE
// SYSGEN_IMAGING_JPG_DECODE
// SYSGEN_IMAGING_JPG_ENCODE
// SYSGEN_IMAGING_PNG_DECODE
// SYSGEN_IMAGING_PNG_ENCODE
// SYSGEN_IMAGING_TIFF_DECODE
// SYSGEN_IMGFS
// SYSGEN_IMGUPD
// SYSGEN_IMGUPD_ALL
// SYSGEN_IMGUPD_KEY
// SYSGEN_IMM
// SYSGEN_INPUTSCOPES
// SYSGEN_INTERNET_SHARING
// SYSGEN_IPHLPAPI
// SYSGEN_IPLAYAUDIO
// SYSGEN_IPSEC
// SYSGEN_JSCRIPT
// SYSGEN_KBD_ARABIC_101
// SYSGEN_KBD_GUJARATI
// SYSGEN_KBD_HEBREW
// SYSGEN_KBD_HINDI_TRADITIONAL
// SYSGEN_KBD_JAPANESE
// SYSGEN_KBD_KANNADA
// SYSGEN_KBD_KOREAN
// SYSGEN_KBD_MARATHI
// SYSGEN_KBD_PUNJABI
// SYSGEN_KBD_RUSSIAN
// SYSGEN_KBD_TAMIL
// SYSGEN_KBD_TELUGU
// SYSGEN_KBD_THAI_KEDMANEE
// SYSGEN_KBD_US
// SYSGEN_L2TP
// SYSGEN_LASS
// SYSGEN_LDAP
// SYSGEN_LOCATION_FRAMEWORK
// SYSGEN_LOCATION_GPS_PROVIDER
// SYSGEN_LOCATION_WIFI_PROVIDER
// SYSGEN_LVMOD_STUB
// SYSGEN_MEDIAAPPS_MEDIALIBRARY
// SYSGEN_MEDIAAPPS_MEDIALIBRARY_INDEX
// SYSGEN_MEDIAAPPS_MEDIALIBRARY_NOTIFY
// SYSGEN_MEDIAAPPS_MEDIALIBRARY_SERVICE
// SYSGEN_MEDIAAPPS_MEDIALIBRARY_UPDATE
// SYSGEN_MEDIAAPPS_WMPOCX
// SYSGEN_MENU_OVERLAP
// SYSGEN_MENU_TAP_UI
// SYSGEN_MGFE
// SYSGEN_MINGDI
// SYSGEN_MINGWES
// SYSGEN_MINICOM
// SYSGEN_MININPUT
// SYSGEN_MINWMGR
// SYSGEN_MODEM
// SYSGEN_MSF
// SYSGEN_MSFLASH
// SYSGEN_MSFLASH_FASLD
// SYSGEN_MSFLASH_RAMFMD
// SYSGEN_MSFLASH_SDNPCID
// SYSGEN_MSFLASH_STRATAD
// SYSGEN_MSGQUEUE
// SYSGEN_MSPART
// SYSGEN_MSXML_DOM
// SYSGEN_MSXML_HTTP
// SYSGEN_MSXML_MIMEVIEWER
// SYSGEN_MSXML_SAX
// SYSGEN_MSXML_XQL
// SYSGEN_MSXML_XSLT
// SYSGEN_MULTIUI
// SYSGEN_NDIS
// SYSGEN_NDISUIO
// SYSGEN_NETLOG
// SYSGEN_NETLOGCTL
// SYSGEN_NETWORK_POLICY
// SYSGEN_NET_WFP
// SYSGEN_NKCOMPR
// SYSGEN_NKMAPFILE
// SYSGEN_NKTZINIT
// SYSGEN_NLED
// SYSGEN_NOTIFY
// SYSGEN_OBEX_CLIENT
// SYSGEN_OBEX_SERVER
// SYSGEN_OLE
// SYSGEN_OLE_GUIDS
// SYSGEN_OLE_STG
// SYSGEN_OPENMP
// SYSGEN_OSTEST
// SYSGEN_OSTEST_LIBS
// SYSGEN_OSTEST_STRESS
// SYSGEN_OSTEST_TTRACKER
// SYSGEN_OSTEST_TUX
// SYSGEN_PCCARD
// SYSGEN_PCL
// SYSGEN_PHYSICSENGINE
// SYSGEN_PIXELDOUBLE
// SYSGEN_PM
// SYSGEN_PM_PDA
// SYSGEN_PPP
// SYSGEN_PPTP
// SYSGEN_PRINTING
// SYSGEN_RAWFS
// SYSGEN_REDIR
// SYSGEN_RELFSD
// SYSGEN_REPLACE_DWCONN
// SYSGEN_RPCRT4
// SYSGEN_RTTI
// SYSGEN_SECUREWIPE
// SYSGEN_SERDEV
// SYSGEN_SERVICES
// SYSGEN_SHELL
// SYSGEN_SMARTCARD
// SYSGEN_SOFTKB
// SYSGEN_SQLCOMPACT
// SYSGEN_SQLCOMPACTMP
// SYSGEN_SQM_ENGINE
// SYSGEN_SQM_UPLOAD
// SYSGEN_STATE_NOTIFICATIONS
// SYSGEN_STDIO
// SYSGEN_STDIOA
// SYSGEN_STOREMGR
// SYSGEN_STRSAFE
// SYSGEN_TAPI
// SYSGEN_TASK_SCHEDULER
// SYSGEN_TCPIP
// SYSGEN_TFAT
// SYSGEN_TIMEZONES
// SYSGEN_TOOLHELP
// SYSGEN_TOUCH
// SYSGEN_TOUCHGESTURE
// SYSGEN_UIPROXY
// SYSGEN_UNIMODEM
// SYSGEN_UNISCRIBE
// SYSGEN_USB
// SYSGEN_USBFN
// SYSGEN_USBFN_COMPOSITE
// SYSGEN_USBFN_ETHERNET
// SYSGEN_USBFN_SERIAL
// SYSGEN_USBFN_STORAGE
// SYSGEN_USB_HID
// SYSGEN_USB_HID_CLIENTS
// SYSGEN_USB_HID_KEYBOARD
// SYSGEN_USB_HID_MOUSE
// SYSGEN_USB_STORAGE
// SYSGEN_VBSCRIPT
// SYSGEN_VEM
// SYSGEN_VOIP
// SYSGEN_WATSON
// SYSGEN_WATSON_CLIENT
// SYSGEN_WATSON_DMPGEN
// SYSGEN_WATSON_XFER
// SYSGEN_WINDOWSLIVE
// SYSGEN_WININET
// SYSGEN_WINSOCK
// SYSGEN_WLIDSVC
// SYSGEN_WMAYGSHELL
// SYSGEN_WMPHONE
// SYSGEN_XGF
// SYSGEN_XMLLITE
// </SYSGENS>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ceotgbus.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// Module Name:  
//     CEBUS.h
// 
// Abstract: Provides Liberary for OTG Bus Access.
// 
// Notes: 
//
#ifndef __CEOTGBUS_H_
#define __CEOTGBUS_H_
#include <cebus.h>

#define IOCTL_BUS_USBOTG_GETOTG_ENABLE_BIT  _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE)
#define IOCTL_BUS_USBOTG_REQUEST_BUS        _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE+1)
#define IOCTL_BUS_USBOTG_DROP_BUS           _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE+2)
#define IOCTL_BUS_USBOTG_RESUME             _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE+3)
#define IOCTL_BUS_USBOTG_SUSPEND            _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE+4)
#define IOCTL_BUS_USBOTG_HNP_ENABLE         _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE+5)
#define IOCTL_BUS_USBOTG_HNP_DISABLE        _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE+6)
#define IOCTL_BUS_USBOTG_GET_HOST_PORT      _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE+7)
#define IOCTL_BUS_USBOTG_NOTIFY_DETACH      _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE+8)
#define IOCTL_BUS_USBOTG_GET_A_ATTACH_EVENT _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE+9)
#define IOCTL_BUS_USBOTG_USBFN_ACTIVE       _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE+10)
#define IOCTL_BUS_USBOTG_HCD_ACCEPT         _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE+11)

#define BUS_USBOTG_EXTENTION_PLATFORM_CODE  (BUS_USBOTG_EXTENTION_FUNCTIONCODE+0x10)
// For IOCTL_BUS_USBOTG_GETOTG_ENABLE_BIT The output on *pOutBuf.
#define USBOTG_HCD_ENABLE 1
#define USBOTG_DEVICE_ENABLE 2

#define USBOTG_CONNECT_DEFAULT_A 0x10

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ceshlguid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//
// For shell-reserved GUID
//
//  The Win95 Shell has been allocated a block of 256 GUIDs,
// which follow the general format:
//
//  000214xx-0000-0000-C000-000000000046
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
#pragma once

#define DEFINE_SHLGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

DEFINE_SHLGUID(CLSID_ShellDesktop,      0x00021400L, 0, 0);
DEFINE_SHLGUID(IID_IShellCommandUI,     0x000214FEL, 0, 0);

DEFINE_SHLGUID(IID_IShellFind,          0x000214D0L, 0, 0);
DEFINE_SHLGUID(IID_IShellFindItem,      0x000214D1L, 0, 0);
DEFINE_SHLGUID(IID_IShellFindCallback,  0x000214D2L, 0, 0);

DEFINE_SHLGUID(IID_IShellNotificationCallback, 0x000214C0L, 0, 0);

// {4032412D-EB8E-40ff-A9AB-A6979D50B3F2}
DEFINE_GUID(IID_IAutoSuggestionGenerator, 0x4032412d, 0xeb8e, 0x40ff, 0xa9, 0xab, 0xa6, 0x97, 0x9d, 0x50, 0xb3, 0xf2);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cesdbus.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// Module Name:  
//     CESDBUS.h
// 
// Abstract: Provides Liberary for SD Bus Access.
// 
// Notes: 
//

#ifndef __CESDBUS_H_
#define __CESDBUS_H_
#include <cebus.h>
#include <SDCardDDK.h>

// Callback.
#define IOCTL_BUS_SD_REQUEST_CALLBACK               _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+0)
typedef struct _IO_BUS_SD_REQUEST_CALLBACK {
    PSD_BUS_REQUEST_CALLBACK pRequestCallback;
    HANDLE          hDevice;    
    HANDLE          hBusRequest;
    PVOID           pDeviceContext;
    DWORD           dwRequestParam;
} IO_BUS_SD_REQUEST_CALLBACK, *PIO_BUS_SD_REQUEST_CALLBACK ;

#define IOCTL_BUS_SD_SLOT_EVENT_CALLBACK            _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+1)
typedef struct _IO_BUS_SD_SLOT_EVENT_CALLBACK {
    PSD_SLOT_EVENT_CALLBACK pSdSlotEventCallback;
    HANDLE          hDevice;
    PVOID           pDeviceContext;
    SD_SLOT_EVENT_TYPE SdSlotEventType;
    DWORD           dwDataOffset;
    DWORD           dwInSize;
} IO_BUS_SD_SLOT_EVENT_CALLBACK, *PIO_BUS_SD_SLOT_EVENT_CALLBACK;

#define IOCTL_BUS_SD_INTERRUPT_CALLBACK            _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+2)
typedef struct _IO_BUS_SD_INTERRUPT_CALLBACK {
    PSD_INTERRUPT_CALLBACK pSdInterruptCallback;
    HANDLE          hDevice;
    PVOID           pDeviceContext;
} IO_BUS_SD_INTERRUPT_CALLBACK, *PIO_BUS_SD_INTERRUPT_CALLBACK;


// API STATUS get back by GetLastError. the Value is defined in SDCardDDK.h


#define IOCTL_BUS_SD_REGISTER_CLIENT                _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+0)
typedef struct _IO_SD_REGISTERCLIENTDEVICE { // Input
    HANDLE      hDevice;
    PVOID       pDeviceContext;
    HANDLE      hCallbackAPI;
    SDCARD_CLIENT_REGISTRATION_INFO sdClientRegistrationInfo;
} IO_SD_REGISTERCLIENTDEVICE, *PIO_SD_REGISTERCLIENTDEVICE;

#define IOCTL_BUS_SD_SYNCHRONOUS_BUS_REQUEST        _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+1)
typedef struct _IO_SD_SYNCHRONOUS_BUS_REQUEST { // Input.
    HANDLE      hDevice;
    UCHAR       Command;
    DWORD       Argument;
    SD_TRANSFER_CLASS      TransferClass;
    SD_RESPONSE_TYPE       ResponseType;
    ULONG                  NumBlocks;
    ULONG       BlockSize;
    PUCHAR      pBuffer;        // Embedded Buffer.
    DWORD       Flags;
} IO_SD_SYNCHRONOUS_BUS_REQUEST, *PIO_SD_SYNCHRONOUS_BUS_REQUEST;
// Output : PSD_COMMAND_RESPONSE   pResponse;


#define IOCTL_BUS_SD_BUS_REQUEST                    _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+2)
typedef struct _IO_SD_BUS_REQUEST { // Input
    HANDLE      hDevice;
    UCHAR       Command;
    DWORD       Argument;
    SD_TRANSFER_CLASS   TransferClass;
    SD_RESPONSE_TYPE    ResponseType;
    ULONG       NumBlocks;
    ULONG       BlockSize;
    PUCHAR      pBuffer;  // Embedded Buffer.
    IO_BUS_SD_REQUEST_CALLBACK ceDriverCallbackParam;
    DWORD       Flags;
} IO_SD_BUS_REQUEST, *PIO_SD_BUS_REQUEST ;
// Out  HBUS_REQUEST            hRequest;

#define IOCTL_BUS_SD_FREE_BUS_REQUEST               _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+3)
// Input hRequest:
// Output None

#define IOCTL_BUS_SD_CARD_INFO_QUERY                _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+4)
typedef struct _IO_SD_CARD_INFO_QUERY { // Input
    HANDLE          hDevice;
    SD_INFO_TYPE    InfoType;
} IO_SD_CARD_INFO_QUERY, *PIO_SD_CARD_INFO_QUERY ;
// Output Card Info.

#define IOCTL_BUS_SD_READ_WRITE_REGISTERS_DIRECT    _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+5)
typedef struct _SD_READ_WRITE_REGISTERS_DIRECT {
    HANDLE      hDevice;
    SD_IO_TRANSFER_TYPE    ReadWrite;
    UCHAR                  Function;
    DWORD                  Address;
    BOOLEAN                ReadAfterWrite;
    PUCHAR                 pBuffer;     // Embedded pointer.
    ULONG                  Length;
} IO_SD_READ_WRITE_REGISTERS_DIRECT,*PIO_SD_READ_WRITE_REGISTERS_DIRECT ;

#define IOCTL_BUS_SD_CANCEL_BUS_REQUEST             _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+6)
// Input hRequest:
// Output None

#define IOCTL_BUS_SD_GET_TUPLE                      _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+7)
typedef struct _IO_BUS_SD_GET_TUPLE { // INPUT
    HANDLE      hDevice;
    UCHAR       TupleCode;
    BOOL        CommonCIS;
} IO_BUS_SD_GET_TUPLE, *PIO_BUS_SD_GET_TUPLE;
// Output DataBuffer.

#define IOCTL_BUS_SD_IO_CONNECT_INTERRUPT           _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+8)
typedef struct _IO_BUS_SD_IO_CONNECT_INTERRUPT { // Input
    HANDLE      hDevice;    
    IO_BUS_SD_INTERRUPT_CALLBACK sdInterruptCallback;
} IO_SD_IO_CONNECT_INTERRUPT, *PIO_SD_IO_CONNECT_INTERRUPT;
//Ouput : None

#define IOCTL_BUS_SD_IO_DISCONNECT_INTERRUPT        _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+9)
// Input hDevice
// Output NONE;


#define IOCTL_BUS_SD_SET_CARD_FEATURE               _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+0xa)
typedef struct _IO_SD_SET_CARD_FEATURE {
    HANDLE      hDevice;    
    SD_SET_FEATURE_TYPE  CardFeature;
    PVOID       pInBuf;     // embedded point
    DWORD       nInBufSize;
} IO_SD_SET_CARD_FEATURE, *PIO_SD_SET_CARD_FEATURE ;


#define IOCTL_BUS_SD_REQUEST_RESPONSE               _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+0xb)
// INPUT HBUS_REQUEST
// OUTPUT PSD_COMMAND_RESPONSE

#define IOCTL_BUS_SD_GETCLIENT_FUNCTION             _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+0xc)
// INPUT NULL
// OUTPUT PSDCARD_API_FUNCTIONS

#define IOCTL_BUS_SD_SYNCHRONOUS_BUS_REQUEST_EX      _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+0xd)
typedef struct _IO_SD_SYNCHRONOUS_BUS_REQUEST_EX { // Input.
    HANDLE      hDevice;
    UCHAR       Command;
    DWORD       Argument;
    SD_TRANSFER_CLASS      TransferClass;
    SD_RESPONSE_TYPE       ResponseType;
    ULONG                  NumBlocks;
    ULONG       BlockSize;
    PUCHAR      pBuffer;        // Embedded Buffer.
    DWORD       Flags;
    DWORD       cbSize;     // Size inbyte.
    PPHYS_BUFF_LIST pPhysBuffList;
    
} IO_SD_SYNCHRONOUS_BUS_REQUEST_EX, *PIO_SD_SYNCHRONOUS_BUS_REQUEST_EX;
// Output : PSD_COMMAND_RESPONSE   pResponse;


#define IOCTL_BUS_SD_BUS_REQUEST_EX                  _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+0xe)
typedef struct _IO_SD_BUS_REQUEST_EX { // Input
    HANDLE      hDevice;
    UCHAR       Command;
    DWORD       Argument;
    SD_TRANSFER_CLASS   TransferClass;
    SD_RESPONSE_TYPE    ResponseType;
    ULONG       NumBlocks;
    ULONG       BlockSize;
    PUCHAR      pBuffer;  // Embedded Buffer.
    IO_BUS_SD_REQUEST_CALLBACK ceDriverCallbackParam;
    DWORD       Flags;
    DWORD       cbSize;     // Size inbyte.
    PPHYS_BUFF_LIST pPhysBuffList;
} IO_SD_BUS_REQUEST_EX, *PIO_SD_BUS_REQUEST_EX ;
// Out  HBUS_REQUEST            hRequest;
#ifdef __cplusplus
extern "C" {
#endif
HANDLE  GetBusAccessHandle();

#ifdef __cplusplus
};
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cerwlock.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:
    cerwlock.h

Abstract:
    Shared/Exclusive lock APIs. This implementation supports:
        a) Recursion
            Thread holding the lock calling to acquire the lock again
        b) Fair
            Lock acquire is fair to threads requesting shared or exclusive access
        c) Lock upgrade/downgrade
            A thread can upgrade a lock from shared to exclusive access or vice-versa
        d) Timeouts
            Lock acquire functions take a timeout to wait for the lock to be available if
            the lock cannot be granted immediately.

--*/

#ifndef _CERWLOCK_H
#define _CERWLOCK_H

#if (_MSC_VER >= 1000)
#pragma once
#endif

#ifdef __cplusplus 
extern "C" { 
#endif 

#include <windows.h>

DECLARE_HANDLE(HRWLOCK);

//
// lock type used by APIs
//

///<topic name="CERWLOCK" displayname="Reader Writer Locks">
///<summary>APIs to create and use reader / writer locks</summary>
///</topic>

typedef enum tagCERW_TYPE
{
    CERW_TYPE_SHARED,
    CERW_TYPE_EXCLUSIVE
    
} CERW_TYPE;

///<topic_scope tref="CERWLOCK">

/// <summary>
///     Creates a new shared/exclusive object and returns a handle to the object.
/// </summary>
/// <param name="dwFlags">
///     [in] Currently the only flag supported is CERW_RECURSION. If this flag is
///     passed, lock is created with recursion support; otherwise the lock is created
///     without the recursion support.
/// </param>
/// <returns>
///     If API call is successful, this function will return a handle to the newly created
///     shared/exclusive object. If API call is unsuccessful, this function will return NULL 
///     handle value. In this case, callers can use <c>GetlastError</c> API to find out the 
///     cause of the failure.
/// </returns>
/// <remarks>
///     Locks created with this API call have the following properties:
///     <list type="bullet">
///         <item>
///             <description>
///                 Multiple shared owners: The lock can be acquired in shared mode by more 
///                 than one thread at the same time. When the lock is acquired by at-least 
///                 one thread in shared mode, lock cannot be acquired for exclusive access 
///                 by any other thread.
///             </description>
///         </item>
///         <item>
///             <description>
///                 Single exclusive owner: The lock can be acquired in exclusive mode by at-
///                 most one thread in the process. When the lock is acquired in exclusive mode,
///                 lock cannot be acquired by other threads for shared or exclusive access until 
///                 the thread which owns the lock in exclusive mode releases the ownership of 
///                 the lock.
///             </description>
///         </item>
///         <item>
///             <description>
///                 Fairness: Lock is granted in the order of lock requests and there is no preference 
///                 given to either shared or exclusive lock requests. Note that this assumes that
///                 all the requesting threads are of the same priority. If threads have different
///                 priority then the locks are granted in the order of priority with the highest priority
///                 thread gaining the lock ownership as soon as it is available ahead of any other
///                 waiting threads.
///             </description>
///         </item>
///         <item>
///             <description>
///                 Timeout: Lock acquire APIs take timeout value. Timeout value of 0 means the acquire
///                 call will return immediately even if the lock is not currently avaialble. Timeout value of
///                 INFINITY means the calling thread will block until the lock is acquired in the given mode.
///                 Any other timeout value will block the calling thread for the set timeout value if the lock
///                 is not available immediately.
///             </description>
///         </item>
///         <item>
///             <description>
///                 Recursion support: This implies that a thread which currently owns the lock 
///                 in shared/exclusive mode can acquire the same lock in the same mode again 
///                 without potential for deadlock. Only when the thread recursion count for a given 
///                 lock goes to 0, the lock is considered not owned by that particular thread.
///             </description>
///         </item>
///     </list>
/// </remarks>

HRWLOCK
CeCreateRwLock (
    __in DWORD dwFlags
    );


/// <summary>
///     Deletes the specified shared/exclusive lock object or marks the specified
///     lock object to be deleted when all threads have relinquished ownership of
///     the lock.
/// </summary>
/// <param name="hLock">
///     [in] Handle to the lock.
/// </param>
/// <returns>
///     <list type="bullet">
///         <item>
///             <description>
///                 TRUE: Lock object is successfully deleted or marked for delete.
///             </description>
///         </item>
///         <item>
///             <description>
///                 FALSE: Lock object is not valid.
///             </description>
///         </item>
///     </list>
/// </returns>
/// <remarks>
///     This call releases any resources allocated in <c> CeCreateRwLock </c> API call. It 
///     is possible that there are threads with outstanding ownership on the lock being 
///     deleted or threads waiting on the lock. In this case the lock is marked to be deleted 
///     when the last thread relinquishes ownership of the lock. Once this API is called, any 
///     subsequent calls to acquire this lock by any thread in the process will fail.
/// </remarks>

BOOL
CeDeleteRwLock(
    __in HRWLOCK hLock
    );


/// <summary>
///     Acquire the specified lock in the requested mode (shared or exclusive).
/// </summary>
/// <param name="hLock">
///     [in] Handle to the lock.
/// </param>
/// <param name="type">
///     [in] Specifies the lock type. Lock can be acquired as:
///     <list type="bullet">
///         <item>
///             <description>
///                 CERW_TYPE_SHARED: Acquire shared access to the lock for the calling thread.
///             </description>
///         </item>
///         <item>
///             <description>
///                 CERW_TYPE_EXCLUSIVE: Acquire exclusive access to the lock for the calling thread.
///             </description>
///         </item>
///     </list>
/// </param>
/// <param name="dwTimeout">
///     [in] Time, in milliseconds, to wait for the lock to become available if access cannot be 
///     granted immediately.
/// </param>
/// <returns>
///     <list type="bullet">
///         <item>
///             <description>
///                 TRUE: The calling thread has ownership of the given lock.
///             </description>
///         </item>
///         <item>
///             <description>
///                 FALSE: Lock could not be granted within the given timeout.
///             </description>
///         </item>
///     </list>
/// </returns>
/// <remarks>
///     Passing a value of "0" for the Timeout argument forces the API call to return immediately 
///     whether the lock is granted or not. If the lock is not granted, calling thread can call 
///     <c>GetLastError</c> API to find out the cause of the failure.
///     When acquiring either _SHARED or _EXCLUSIVE, a simple timeout will
///	    result in GetLastError returning WAIT_TIMEOUT.  However, when acquiring
///	    _EXCLUSIVE recursively, it's possible to encounter a deadlock condition.
///	    In this case, locking fails immediately to prevent deadlock, and
///	    GetLastError returns ERROR_LOCK_VIOLATION.
/// </remarks>

BOOL
CeAcquireRwLock(
    __in HRWLOCK hLock,
    __in CERW_TYPE typeLock,
    __in DWORD dwTimeout
    );


/// <summary>
///     Release shared/exclusive access to the specified lock.
/// </summary>
/// <param name="hLock">
///     [in] Handle to the lock.
/// </param>
/// <param name="type">
///     [in] Specifies the lock type. Lock can be released as:
///     <list type="bullet">
///         <item>
///             <description>
///                 CERW_TYPE_SHARED: Release shared access to the lock by the calling thread.
///             </description>
///         </item>
///         <item>
///             <description>
///                 CERW_TYPE_EXCLUSIVE: Release exclusive access to the lock by the calling thread.
///             </description>
///         </item>
///     </list>
/// </param>
/// <returns>
///     <list type="bullet">
///         <item>
///             <description>
///                 TRUE: Thread recursion count for the given lock is decremented by a count of 1. 
///                 It is possible that the calling thread still has ownership of the lock if the 
///                 calling thread recursion count for the lock is non-zero. Calling thread has to 
///                 call <c>CeReleaseRwLock</c> for every call to <c>CeAcquireRwLock</c> for the 
///                 given lock. Only when the calling thread recursion count for the given lock is 
///                 zero, the lock is assumed to be not owned by the calling thread.
///             </description>
///         </item>
///         <item>
///             <description>
///                 FALSE: Lock is invalid or lock is currently not owned by the calling thread.
///             </description>
///         </item>
///     </list>
/// </returns>
/// <remarks>
///     Once the lock is released, any threads currently waiting for the lock to be available become 
///     signalled if current thread does not own the lock anymore (current thread recursion count for 
///     this lock is zero) or lock is being downgraded (exclusive mode on the lock is being downgraded 
///     to shared mode).
/// </remarks>

BOOL
CeReleaseRwLock(
    __in HRWLOCK hLock,
    __in CERW_TYPE typeLock
    );


/// <summary>
///     Checks whether the calling thread holds the lock in the given mode at the time of the call.
/// </summary>
/// <param name="hLock">
///     [in] Handle to the lock.
/// </param>
/// <param name="type">
///     [in] Specifies the type of the lock to check against. This can be:
///     <list type="bullet">
///         <item>
///             <description>
///                 CERW_TYPE_SHARED: lock in shared mode.
///             </description>
///         </item>
///         <item>
///             <description>
///                 CERW_TYPE_EXCLUSIVE: lock in exclusive mode.
///             </description>
///         </item>
///     </list>
/// </param>
/// <returns>
///     <list type="bullet">
///         <item>
///             <description>
///                 TRUE: Lock is valid and either the calling thread holds the lock in given mode (if the lock
///                 is created with recursion support) or lock is valid and lock is held in given mode by
///                 a thread in the system (if the lock is created without recursion support).
///             </description>
///         </item>
///         <item>
///             <description>
///                 FALSE: Lock is invalid or the lock is not held in the given mode either by current thread
///                 (if lock is created with recursion support) or globally by any thread (if the lock is created
///                 with no recursion support). Calling threads can use <c>GetLastError</c> API to figure 
///                 out if there was an error (due to invalid lock handle) during the call.
///             </description>
///         </item>
///     </list>
/// </returns>
/// <remarks>
/// </remarks>

BOOL
CeIsRwLockAcquired(
    __in HRWLOCK     hLock,
    __in CERW_TYPE typeLock
    );

///</topic_scope> //CERWLOCK


#ifdef __cplusplus 
}
#endif 

#endif  // _CERWLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cfgmgrapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// DESCRIPTION:
// Configmanager API to process XML configuration files

#ifndef _PROCESSCFG_H_
#define _PROCESSCFG_H_

#ifdef __cplusplus
extern "C" {
#endif

// Possible error codes returned by Configmanager
#define CONFIG_E_OBJECTBUSY                 _HRESULT_TYPEDEF_(0x80042001)
#define CONFIG_E_CANCELTIMEOUT              _HRESULT_TYPEDEF_(0x80042002)
#define CONFIG_E_ENTRYNOTFOUND              _HRESULT_TYPEDEF_(0x80042004)
#define CONFIG_S_PROCESSINGCANCELED         _HRESULT_TYPEDEF_(0x00042005)
#define CONFIG_E_CSPEXCEPTION               _HRESULT_TYPEDEF_(0x80042007)
#define CONFIG_E_TRANSACTIONINGFAILURE      _HRESULT_TYPEDEF_(0x80042008)
#define CONFIG_E_BAD_XML                    _HRESULT_TYPEDEF_(0x80042009)

// Configmanager flags
#define CFGFLAG_PROCESS                     0x0001
#define CFGFLAG_METADATA                    0x0002

HRESULT DMProcessConfigXML(__in LPCWSTR pszWXMLin, DWORD dwFlags, __deref_out LPWSTR *ppszwXMLout);

#ifdef __cplusplus
}
#endif

#endif // _PROCESSCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cesvsbus.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// Module Name:  
//     CESVSBUS.h
// 
// Abstract: Provides Service Bus Service.
// 
// Notes: 
//
#pragma once
#include <cebus.h>

// Callback.
#define IOCTL_BUS_SVS_ACTIVATE              _BUSACCESS_CTL_CODE(BUS_SERVICES_EXTENTION_FUNCTIONCODE+0)
// pInBuf
typedef struct __BUS_SVS_ACTIVATE_SERVICE {
    DWORD dwStructSize;
    DWORD dwClientInfo;
    TCHAR sRegPath[DEVKEY_LEN];
} BUS_SVS_ACTIVATE_SERVICE, *PBUS_SVS_ACTIVATE_SERVICE;
// pOutBuff
// HANDLE // DeviceHandle
#define IOCTL_BUS_SVS_DEACTIVATE            _BUSACCESS_CTL_CODE(BUS_SERVICES_EXTENTION_FUNCTIONCODE+1)
// pInBuf,
// HANDLE // DeviceHandle
// pOutBuf
// NULL
#define IOCTL_BUS_SVS_DEACTIVATE_BY_NAME    _BUSACCESS_CTL_CODE(BUS_SERVICES_EXTENTION_FUNCTIONCODE+2)
// pInBuf,
// NAME STRING 
// pOutBuf
// NULL
#define IOCTL_BUS_SVS_ENUM_SERVICES         _BUSACCESS_CTL_CODE(BUS_SERVICES_EXTENTION_FUNCTIONCODE+0x10)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\changeinfo.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef _CHANGEINFO_H_
#define _CHANGEINFO_H_


#ifdef __cplusplus
extern "C" {
#endif

typedef struct _FILECHANGEINFO {
    DWORD cbSize;              //  Size of this structure
    LONG wEventId;             //  File System Notification flags
    ULONG uFlags;              //  Flags
    DWORD dwItem1;            
    DWORD dwItem2;
    DWORD dwAttributes;        //  File attributes
    FILETIME ftModified;       //  Modified time
    ULONG nFileSize;           
} FILECHANGEINFO, * LPFILECHANGEINFO;
typedef const FILECHANGEINFO * LPCFILECHANGEINFO;

#ifdef __cplusplus
}
#endif

#endif // _CHANGEINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cesync.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:


    cesync.h

Abstract:

    Include file for synchronization modules for Windows CE

--*/
#ifndef _INC_CESYNC_H
#define _INC_CESYNC_H

// max size of the object type name
#define MAX_OBJTYPE_NAME    100

// max. size of a packet in IReplObjHandler::GetPacket & IReplObjHandler::SetPacket (about 254K)
#define MAX_PACKET_SIZE     260000

#define MAX_ACTIVE_VOL      16                  // up to 16 active volumes (including the default system volume) can be synchronized during each connection

typedef struct _tagReplSetup *PREPLSETUP;

typedef TCHAR   OBJTYPENAME[ MAX_OBJTYPE_NAME ];
typedef char    OBJTYPENAMEA[ MAX_OBJTYPE_NAME ];
typedef WCHAR   OBJTYPENAMEW[ MAX_OBJTYPE_NAME ];

#define FACILITY_CESYNC     0x14
#define MAKE_RERR(code)     ((HRESULT)(MAKE_SCODE( SEVERITY_ERROR, FACILITY_CESYNC, code )))
#define MAKE_RWRN(code)     ((HRESULT)(MAKE_SCODE( SEVERITY_SUCCESS, FACILITY_CESYNC, code )))

#ifndef UNDER_CE
typedef struct _REPLOBJ FAR *HREPLOBJ;
typedef struct _REPLITEM FAR *HREPLITEM;
typedef struct _REPLFLD FAR *HREPLFLD;

#endif

// Error/Return code used
#define RERR_SHUT_DOWN      MAKE_RERR( 0x0001 ) // serious error, asking implementation to shut down immediately
#define RERR_STORE_REPLACED MAKE_RERR( 0x0002 ) // the store was replaced.
#define RERR_CANCEL         MAKE_RERR( 0x0003 ) // user cancel the operation
#define RERR_RESTART        MAKE_RERR( 0x0004 ) // restart the operation, applicable in RSC_END_SYNC & RSC_END_CHECK
#define RERR_IGNORE         MAKE_RERR( 0x0005 ) // used by IReplStore::GetConflictInfo.
#define RERR_UNLOAD         MAKE_RERR( 0x0006 ) // used by IReplStore::ActivateDialog or IReplStore::IsFolderChanged to request unloading of replication modules
#define RERR_OBJECT_DELETED MAKE_RERR( 0x0007 ) // used by IReplStore::IsValidObject, indicates the object identified by the hObject is deleted
#define RERR_CORRUPT        MAKE_RERR( 0x0008 ) // used by IReplStore::IsValidObject, indicates the object identified by the hObject is corrupted
#define RERR_NO_DEVICE      MAKE_RERR( 0x0009 ) // returned by IReplNotify::QueryDevice. indicates no selected or connected device exists
#define RERR_NO_ERR_PROMPT  MAKE_RERR( 0x0010 ) // returned by IReplStore::Initialize. indicates error initializing. No UI is needed to show this error.
#define RERR_DISCARD        MAKE_RERR( 0x0011 ) // returned by IReplObjHandler::SetPacket. indicates this object should be discarded from the device immediately.
#define RERR_DISCARD_LOCAL  MAKE_RERR( 0x0012 ) // returned by IReplObjHandler::SetPaket. indicates this object should be discarded from the desktop only.
#define RERR_VOL_INACTIVE   MAKE_RERR( 0x0013 ) // returned by IReplObjHandler::GetPacket && IReplObjHandler::SetPacket, the volume has become inactive.
#define RERR_BIG_OBJ_TYPE   MAKE_RERR( 0x0014 ) // returned by IReplNotify::QueryDevice on QDC_SYNC_DATA
#define RERR_BIG_CODE       MAKE_RERR( 0x0015 ) // returned by IReplNotify::QueryDevice on QDC_SYNC_DATA
#define RERR_UNMATCHED      MAKE_RERR( 0x0016 ) // returned by IReplNotify::QueryDevice on QDC_SYNC_DATA
#define RERR_DEVICE_WIN     MAKE_RERR( 0x0017 ) // returned by IReplStore::GetConflictInfo, resolve the conflict so device object wins
#define RERR_DESKTOP_WIN    MAKE_RERR( 0x0018 ) // returned by IReplStore::GetConflictInfo, resolve the conflict so desktop object wins
#define RERR_SKIP_ALL_OBJ   MAKE_RERR( 0x0019 ) // returned by IReplStore::ReportStatus on RSC_WRITE_OBJ_FAILED, skip sync of all remaining objects
#define RERR_SETUP_NOT_COMPLETE MAKE_RERR(0x001A) // Returned by IReplStore::Initialize. Indicates the object cannot sync because further setup is needed

// use by IReplObjHandler
#define RERR_SKIP_ALL       MAKE_RERR( 0x0100 )  // skip all incoming packets because of write errors
#define RERR_BAD_OBJECT     MAKE_RERR( 0x0101 )  // this is a bad object because of read error, server should not try to replicate it again
#define RERR_TRY_AGAIN      MAKE_RERR( 0x0102 )  // this is a bad object because of read error, server should can try to replicate it again later
#define RERR_USER_SKIP      MAKE_RERR( 0x0103 )  // object skipped by the user

// Used by WCESMgr
#define ERROR_NOT_INITIALIZED        MAKE_RERR( 0x0500 ) // Object is used without being initialized #define ERROR_INVALID_RESOURCE      MAKE_RERR( 0x0501 ) // Attempeted to load invalid resource
#define ERROR_INVALID_ID             MAKE_RERR( 0x0502 ) // ID/GUID is invalid
#define ERROR_ADD_FAILED             MAKE_RERR( 0x0503 ) // Add failed for example of DataSource, Engine or SSP
#define ERROR_DELETE_FAILED          MAKE_RERR( 0x0504 ) // Delete Failed 
#define ERROR_ARRAY_OPERATION_FAILED MAKE_RERR( 0x0505 ) // When enumerate, sort or filter fails 
#define ERROR_LOCK_ALREADY_HELD      MAKE_RERR( 0x0506 ) // When a thread synching object attempts to acquire a locka nd it is aleady held
#define ERROR_NODE_HAS_NO_CHILD      MAKE_RERR( 0x0507 ) // The XML Node has no children
#define ERROR_INVALID_GUID           MAKE_RERR( 0x0508 ) // Invalid GUID
#define ERROR_SAVE_FAILED            MAKE_RERR( 0x0509 ) // Save failed for example of DataSource, Engine or SSP
#define ERROR_CREATION_FAILED        MAKE_RERR( 0x0510 ) // Creation failed

// these are warning codes
#define RWRN_LAST_PACKET             MAKE_RWRN( 0x0001 )
#define RWRN_DIRECTORY_EXISTS        MAKE_RWRN( 0x0002 ) // Directory already exists

// flags used in RSC_BEGIN_SYNC
#define BSF_AUTO_SYNC           ((UINT)0x00000001)  // This flag is being obsoleted in ActiveSync 3.0
#define BSF_REMOTE_SYNC         ((UINT)0x00000002)  // consistent with RSC_REMOTE_SYNC, set if we are sync'ing remotely
#define BSF_SHOW_FATAL_ERRORS   ((UINT)0x00000004)  // If an error occurs which prevents the SSP from synchronizing at all, it can show the error to the user when this flag is set
#define BSF_SHOW_RESOLVE_ERRORS ((UINT)0x00000008)  // The SSP can show any error messages that it comes across as during the resolve items phase
#define BSF_RESERVED            ((UINT)0x80000000)  // Reserved by ActiveSync server.

// Code for ReportStatus
#define RSC_BEGIN_SYNC          ((UINT)1)   // Synchronization is about to start, uReserved is combination of bit flags, see BSF_* above
#define RSC_END_SYNC            ((UINT)2)   // Synchronization is about to end
#define RSC_BEGIN_CHECK         ((UINT)3)   // FindFirstItem is about to be called, followed by FindNextItem
#define RSC_END_CHECK           ((UINT)4)   // FindItemClose has been called
#define RSC_DATE_CHANGED        ((UINT)5)   // System Date has changed, this is called for each known desktop object, unless when both hFolder & hItem are NULL
#define RSC_RELEASE             ((UINT)6)   // Replication is about to release the store
#define RSC_REMOTE_SYNC         ((UINT)7)   // Indicates if remote sync is enabled. uParam will TRUE if all sync
                                            // will be remote until this status is reported again with uParam set to FALSE
#define RSC_INTERRUPT           ((UINT)8)   // interrupt current operation
#define RSC_BEGIN_SYNC_OBJ      ((UINT)9)   // Synchronization is about to start on an object type. uReserved points to
#define RSC_END_SYNC_OBJ        ((UINT)10)  // Synchronization is about to end on an object type.
#define RSC_OBJ_TYPE_ENABLED    ((UINT)11)  // Synchronization of the given object is enabled, hFolder is indeed a pointer to a string (object type name)
#define RSC_OBJ_TYPE_DISABLED   ((UINT)12)  // Synchronization of the given object is disabled, hFolder is indeed a pointer to a string (object type name)
#define RSC_BEGIN_BATCH_WRITE   ((UINT)13)  // A series of SetPacket will be called on a number of objects, this is the right time for some service providers to start a transaction
#define RSC_END_BATCH_WRITE     ((UINT)14)  // above write ends, this is the right time for some service providers to commit the transaction
#define RSC_CONNECTION_CHG      ((UINT)15)  // connection status has changed. uParam is TRUE if connection established. FALSE otherwise.
#define RSC_WRITE_OBJ_FAILED    ((UINT)16)  // failed writing an object on the device. uParam is the HRESULT code.
#define RSC_DELETE_OBJ_FAILED   ((UINT)17)  // failed deleting an object on the device. uParam is the HRESULT code.
#define RSC_WRITE_OBJ_SUCCESS   ((UINT)18)  // writing of an object succeeded on the device. uParam is a pointer to SDREQUEST (with (lpbData, cbData) representing the volume ID)
#define RSC_DELETE_OBJ_SUCCESS  ((UINT)19)  // deletion of an object succeeded on the device. uParam is a pointer to SDREQUEST (with (lpbData, cbData) representing the volume ID)
#define RSC_READ_OBJ_FAILED     ((UINT)20)  // failed to read an object from the device. uParam is the HRESULT code
#define RSC_TIME_CHANGED        ((UINT)21)  // System time has changed, this is called only once.

#define RSC_BEGIN_BACKUP        ((UINT)22)  // Backup is about to start.
#define RSC_END_BACKUP          ((UINT)23)  // Backup has ended.
#define RSC_BEGIN_RESTORE       ((UINT)24)  // Restore is about to start.

#define RSC_PREPARE_SYNC_FLD    ((UINT)26)  // Prepare to sync one specific folder whether or not any objects of the type are dirty. hFolder is a pointer to the object name that will be synced. 

//
//========================= IReplNotify ==============================
//

typedef struct tagDevInfo
{
    DWORD   pid;                // device ID
    char    szName[ MAX_PATH ]; // device name
    char    szType[ 80 ];       // device type
    char    szPath[ MAX_PATH ]; // device path
} DEVINFO, *PDEVINFO;

// a structure used to get/set custom sync. data from/to the device
typedef struct SDREQUEST
{
#ifdef UNDER_CE
    OBJTYPENAME szObjType;  // the object type where this data is coming from
#else
    OBJTYPENAMEA szObjType;  // the object type where this data is coming from
#endif
    BOOL        fSet;       // TRUE if sending data down and FALSE if getting data up
    UINT        uCode;      // for getting data from the device, this code must be less than 8
    LPBYTE      lpbData;
    UINT        cbData;
} SDREQUEST, *PSDREQUEST;

// code for QueryDevice
#define QDC_SEL_DEVICE      1   // Selected device info, *ppvData points to DEVINFO
#define QDC_CON_DEVICE      2   // Connected device info, *ppvData points to DEVINFO
#define QDC_SEL_DEVICE_KEY  3   // get a registry key that can be used to store selected device specific settings.
                                // *ppvData points to HKEY, caller must close reg key when its usage is over
#define QDC_CON_DEVICE_KEY  4   // get a registry key that can be used to store connnected device specific settings.
                                // *ppvData points to HKEY, caller must close reg key when its usage is over
#define QDC_SYNC_DATA   5       // get or set custom sync data from the device, *ppvData points to SDREQUEST

#define INF_OVERRIDE        ((UINT)0x0001000)   // used for OnItemNotify, override the default action of "delete wins over change"

#undef  INTERFACE
#define INTERFACE   IReplNotify
DECLARE_INTERFACE_( IReplNotify, IUnknown )
{
#ifndef UNDER_CE
    STDMETHOD(       SetStatusText)     ( THIS_ LPSTR lpszText ) PURE;  // lpszText can have special syntax, see programmer's guide
    STDMETHOD_(HWND, GetWindow)         ( THIS_ UINT uFlags ) PURE;
    STDMETHOD(       OnItemNotify )     ( THIS_ UINT uCode, LPSTR lpszProgId, LPSTR lpszName, HREPLITEM hItem, ULONG ulFlags ) PURE;
    STDMETHOD(       QueryDevice )      ( THIS_ UINT uCode, LPVOID *ppvData ) PURE;
#endif

    // Internal use only
    STDMETHOD(       OnItemCompleted )  ( THIS_ PREPLSETUP pSetup ) PURE;
};

#define RNC_CREATED     1
#define RNC_MODIFIED    2
#define RNC_DELETED     3
#define RNC_SHUTDOWN    4
#define RNC_IDLE        5

#ifndef UNDER_CE

#define SCF_SINGLE_THREAD   ((UINT)0x00000001)  // set if the implementation only supports single thread operation.
#define SCF_SIMULATE_RTS    ((UINT)0x00000002)  // set if the implementation wants to simulate detection of real-time change/deletes

typedef struct tagStoreInfo
{
    UINT    cbStruct;               // Size of this structure
    UINT    uFlags;                 // Miscelleanous flags on the store, see SCF_xxx above
#ifdef UNDER_CE
    TCHAR   szProgId[ 256 ];        // Output, ProgID name of the store object
    TCHAR   szStoreDesc[ 200 ];     // Output, description of the store, will be displayed to the user
#else
    CHAR   szProgId[ 256 ];        // Output, ProgID name of the store object
    CHAR   szStoreDesc[ 200 ];     // Output, description of the store, will be displayed to the user
#endif
    UINT    uTimerRes;              // Input/Output, resolution of timer in micro-seconds. 5000 by default.

    UINT    cbMaxStoreId;           // Input, max. size of the store ID that can be stored in buffer pointed by lpbStoreId.
    UINT    cbStoreId;              // Output, actual size of the store ID stored in buffer pointed by lpbStoreId
    LPBYTE  lpbStoreId;             // Output pointer to a buffer of anything that uniquely
                                    // identifies the current store instance (Eg. a schedule file)
} STOREINFO, *PSTOREINFO;

typedef struct tagObjUIData
{
    UINT        cbStruct;               // size of this structure
    HICON       hIconLarge;             // Handle of a large icon used in the list view display in Synchronization Status
    HICON       hIconSmall;             // Handle of a small icon used in the list view display in Synchronization Status
    char        szName[ MAX_PATH ];     // Text displayed in the "Name" column in Synchronization Status
    char        szSyncText[ MAX_PATH ]; // Text displayed in the  "Sync Copy In" column in Synchronization Status
    char        szTypeText[ 80 ];       // Text displayed in the  "Type" column in Synchronization Status
    char        szPlTypeText[ 80 ];     // Plural form of text displayed in the  "Type" column in Synchronization Status
} OBJUIDATA, *POBJUIDATA;

enum ReplDialogs
{
    OPTIONS_DIALOG
};

//
//========================= IEnumReplItem ==============================
//
DEFINE_GUID( IID_IEnumReplItem,              /* a417bc0e-7be1-11ce-ad82-00aa006ec559 */
    0xa417bc0e,
    0x7be1,
    0x11ce,
    0xad, 0x82, 0x00, 0xaa, 0x00, 0x6e, 0xc5, 0x59
);

#undef  INTERFACE
#define INTERFACE   IEnumReplItem
DECLARE_INTERFACE_( IEnumReplItem, IUnknown )
{
    STDMETHOD(Next)                         ( THIS_ ULONG celt, HREPLITEM *phItem, ULONG *pceltFetched ) PURE;
    STDMETHOD(Skip)                         ( THIS_ ULONG celt ) PURE;
    STDMETHOD(Reset)                        ( THIS ) PURE;
    STDMETHOD(Clone)                        ( THIS_ IEnumReplItem **ppenum ) PURE;
    STDMETHOD_( HREPLFLD, GetFolderHandle)  ( THIS ) PURE;
};

typedef struct tagConfInfo
{
    UINT        cbStruct;
    HREPLFLD    hFolder;
    HREPLITEM   hLocalItem;
    HREPLITEM   hRemoteItem;

#ifdef UNDER_CE
    OBJTYPENAME szLocalName;
    TCHAR       szLocalDesc[ 512 ];

    OBJTYPENAME szRemoteName;
    TCHAR       szRemoteDesc[ 512 ];
#else
    OBJTYPENAMEA szLocalName;
    CHAR         szLocalDesc[ 512 ];

    OBJTYPENAMEA szRemoteName;
    CHAR         szRemoteDesc[ 512 ];
#endif
} CONFINFO, *PCONFINFO;

// flags for uParam of IReplStore::ReportStatus
#define PSA_RESET_INTERRUPT ((UINT)0x00000001)  // this flag is set if we're clearing the interrupt state (ie. we go back to normal operation)
#define PSA_SYS_SHUTDOWN    ((UINT)0x00000002)  // Windows is shutting down

// Actions for Setup
#define RSTP_SETUP          ((WORD)0x0001)  // New setup
#define RSTP_CREATE         ((WORD)0x0002)  // New profile
#define RSTP_RENAME         ((WORD)0x0003)  // Rename profile
#define RSTP_DELETE         ((WORD)0x0004)  // Delete profile

//========================= IReplSetup ==============================
//

DEFINE_GUID( IID_IReplSetup, /* 60178ec0-c670-11d0-837a-0000f80220b9 */
    0x60178ec0,
    0xc670,
    0x11d0,
    0x83, 0x7a, 0x00, 0x00, 0xf8, 0x02, 0x20, 0xb9
);

#undef  INTERFACE
#define INTERFACE   IReplSetup

//
//  IReplSetup is included but is obsolete
//
DECLARE_INTERFACE_( IReplSetup, IUnknown )
{
    // *** IReplSetup methods ***
    STDMETHOD(          Setup )             ( THIS_ HWND hwndParent, DWORD dwDeviceId, WORD wAction ) PURE;
};

//
//========================= IReplStore ==============================
//
DEFINE_GUID (IID_IReplStore,            // a417bc0f-7be1-11ce-ad82-00aa006ec559
    0xa417bc0f,
    0x7be1,
    0x11ce,
    0xad, 0x82, 0x00, 0xaa, 0x00, 0x6e, 0xc5, 0x59
);

// Flags for Initialize
#define ISF_SELECTED_DEVICE     ((UINT)0x00000001)  // set if the store is initialized for selected device
                                                    // otherwise it's initialized for connected device
#define ISF_REMOTE_CONNECTED    ((UINT)0x00000002)  // set if the store is initialized during remote connection, all UI should be suppressed.

#undef  INTERFACE
#define INTERFACE   IReplStore
DECLARE_INTERFACE_( IReplStore, IUnknown )
{
    // *** IReplStore methods ***
    STDMETHOD(          Initialize )        ( THIS_ IReplNotify *pNotify, UINT uFlags ) PURE;
    STDMETHOD(          GetStoreInfo )      ( THIS_ PSTOREINFO pStoreInfo ) PURE;
    STDMETHOD(          ReportStatus )      ( THIS_ HREPLFLD hFld, HREPLITEM hItem, UINT uStatus, UINT uParam ) PURE;
    STDMETHOD_( int,    CompareStoreIDs)    ( THIS_ LPBYTE, UINT, LPBYTE, UINT ) PURE;

    // Item related routines
    STDMETHOD_( int,    CompareItem )       ( THIS_ HREPLITEM hItem1, HREPLITEM hItem2 ) PURE;
    STDMETHOD_( BOOL,   IsItemChanged)      ( THIS_ HREPLFLD hFld, HREPLITEM hItem, HREPLITEM hItemComp ) PURE;
    STDMETHOD_( BOOL,   IsItemReplicated )  ( THIS_ HREPLFLD hFld, HREPLITEM hItem ) PURE;
    STDMETHOD_( void,   UpdateItem )        ( THIS_ HREPLFLD hFld, HREPLITEM hItemDst, HREPLITEM hItemSrc ) PURE;

    // Folder related routines
    STDMETHOD(          GetFolderInfo )     ( THIS_ LPSTR lpszObjType, HREPLFLD *phFld, IUnknown ** ) PURE;
    STDMETHOD(          IsFolderChanged )   ( THIS_ HREPLFLD hFld, BOOL *pfChanged ) PURE;

    // Enumeration of folders
    STDMETHOD(          FindFirstItem )     ( THIS_ HREPLFLD hFld,  HREPLITEM *phItem, BOOL *pfExist ) PURE;   // get first object the folder
    STDMETHOD(          FindNextItem )      ( THIS_ HREPLFLD hFld,  HREPLITEM *phItem, BOOL *pfExist ) PURE;   // get next object the folder
    STDMETHOD(          FindItemClose )     ( THIS_ HREPLFLD hFld ) PURE;                   // done enumerating

    // Object management routines
    STDMETHOD_(UINT,    ObjectToBytes )     ( THIS_ HREPLOBJ hObject, LPBYTE lpb ) PURE;
    STDMETHOD_(HREPLOBJ,BytesToObject )     ( THIS_ LPBYTE lpb, UINT cb ) PURE;
    STDMETHOD_(void,    FreeObject )        ( THIS_ HREPLOBJ hObject ) PURE;
    STDMETHOD_(BOOL,    CopyObject )        ( THIS_ HREPLOBJ hObjSrc, HREPLOBJ hObjDest ) PURE;
    STDMETHOD(          IsValidObject )     ( THIS_ HREPLFLD hFld, HREPLITEM hObject, UINT uFlags ) PURE;

    // UI related routines
    STDMETHOD(          ActivateDialog)     ( THIS_ UINT uidDialog, HWND hwndParent, HREPLFLD hFld, IEnumReplItem *penumItem ) PURE;
    STDMETHOD(          GetObjTypeUIData)   ( THIS_ HREPLFLD hFld, POBJUIDATA pData ) PURE;
    STDMETHOD(          GetConflictInfo )   ( THIS_ PCONFINFO pConfInfo ) PURE;
    STDMETHOD(          RemoveDuplicates )  ( THIS_ LPSTR lpszObjType, UINT uFlags ) PURE;
};

//
//=========== Function prototypes for Enable/Disable Callbacks  ==================
//
typedef HRESULT (WINAPI * PFNONSSPENABLE)(HWND);    //For exported function "OnSSPEnable"
typedef HRESULT (WINAPI * PFNONSSPDISABLE)(HWND);   //For exported function "OnSSPDisable"


//
//========================= IReplStore2 ==========================================
//
DEFINE_GUID (IID_IReplStore2,            // 4a696d00-f75f-11d2-b549-00c04f5b9a11
    0x4a696d00,
    0xf75f,
    0x11d2,
    0xb5, 0x49, 0x00, 0xc0, 0x4f, 0x5b, 0x9a, 0x11
);

#undef  INTERFACE
#define INTERFACE   IReplStore2
DECLARE_INTERFACE_( IReplStore2, IReplStore )
{
    // *** IReplStore2 methods ***

    // UI related routines
    STDMETHOD(DoOptionsDialog)     ( THIS_ HWND hwndParent, LPCSTR lpszObjType, IReplNotify * pntfy) PURE;
};


#endif

//
//=========== Section for object serializing & deserializing interfaces ==========
//
#define RSF_CONFLICT_OBJECT             0x00000001  // this is about getting/writting a conflicting object
#define RSF_NEW_OBJECT                  0x00000002  // this is a new object to be written
#define RSF_DUPLICATED_OBJECT           0x00000004  // the object is an exact duplicate of an existing object
#define RSF_COMBINE                     0x00000008  // the object is being writen to desktop during a combine operation
#define RSF_SYNC_DEVICE_ONLY            0x00000010  // the object should be sync'ed from device to desktop only
#define RSF_SYNC_DESKTOP_ONLY           0x00000020  // the object should be sync'ed from desktop to device only
#define RSF_UPDATED_HANDLE              0x00000040  // this is a new object, but the oid already exists (eg, file rename)
#define RSF_DISCARDED_OBJ               0x00000080  // used in DeleteObj. indicates the object is deleted as a result of RERR_DISCARD being returned by SetPacket
#define RSF_NEW_VOLUME                  0x00000100  // used by ActiveSync manager only.
#define RSF_AUTO_COMBINE                0x00000200  // the object is being written to the desktop, similar to RSF_COMBINE except there were no items on the desktop to combine with

#define RSF_RESERVED1                   0x00100000  // reserved by ActiveSync manager: DO NOT USE THESE
#define RSF_RESERVED2                   0x00200000
#define RSF_RESERVED3                   0x00400000
#define RSF_RESERVED4                   0x00800000  

typedef struct _tagReplSetup
{
    UINT        cbStruct;
    BOOL        fRead;
    DWORD       dwFlags;                // see RSF_xxx above.
    HRESULT     hr;
#ifdef UNDER_CE
    OBJTYPENAME szObjType;
#else
    OBJTYPENAMEA szObjType;
#endif
    IReplNotify *pNotify;

    DWORD       oid;
    DWORD       oidNew;

#ifndef UNDER_CE
    IReplStore  *pStore;

    HREPLFLD    hFolder;
    HREPLITEM   hItem;
#endif

    LPBYTE  lpbVolumeID;    // ID of the volume for the object. NULL if the object is in the default volume
    UINT    cbVolumeID;     // size of above ID in bytes
} REPLSETUP, *PREPLSETUP;


//========================= IReplObjHandler ==============================
//
// Specifies the interface for replication object handler
// (object serializer/deserializer)
#undef  INTERFACE
#define INTERFACE   IReplObjHandler
DECLARE_INTERFACE_( IReplObjHandler, IUnknown )
{
    //  Called everytime when an object is about to be serialized/deserialized
    STDMETHOD( Setup )  ( THIS_ PREPLSETUP pSetup ) PURE;

    //  Called everytime when it's the time to clean up the serializer/deserializer for the object
    STDMETHOD( Reset ) ( THIS_ PREPLSETUP pSetup ) PURE;

    /* A request to get a data packet (serialize the object)
    handler should pass back the buffer along with the size bytes */
    STDMETHOD( GetPacket )(  THIS_ LPBYTE *lppbData,  DWORD *pcbData, DWORD cbRecommend ) PURE;

    /* A request to set a data packet (deserialize the byte stream) */
    STDMETHOD( SetPacket )( THIS_ LPBYTE lpbData, DWORD cbData ) PURE;

    /* A request to delete the given object */
    STDMETHOD( DeleteObj )( THIS_ PREPLSETUP pSetup ) PURE;
};

typedef struct tagObjTypeInfo
{
    UINT            cbStruct;       // Input. Size of the structure in bytes.
    OBJTYPENAMEW    szObjType;      // Input, the object type name
    UINT            uFlags;         // Reserved. Not in use yet.
    WCHAR           szName[ 80 ];   // Output, the name of a file system object storing all these object
    UINT            cObjects;       // Output, number of existing objects
    UINT            cbAllObj;       // Output, total number of bytes used to store existing objects
    FILETIME        ftLastModified; // Output, last time any object is modified
} OBJTYPEINFO, *POBJTYPEINFO;

#ifdef UNDER_CE

#define ONF_FILE            ((UINT)0x00000001)
#define ONF_DIRECTORY       ((UINT)0x00000002)
#define ONF_DATABASE        ((UINT)0x00000004)
#define ONF_RECORD          ((UINT)0x00000008)

#define ONF_CHANGED         ((UINT)0x00000010)  // set if the file system object is changed
#define ONF_DELETED         ((UINT)0x00000020)  // set if the file system object is deleted

#define ONF_CLEAR_CHANGE    ((UINT)0x00000040)  // client should clear the change bit for the object whose object id is pointed at by poid
#define ONF_CALL_BACK       ((UINT)0x00000080)  // Output, client asks server to call ObjectNotify 2 sec. later. (ObjectNotify is callback 
                                                // function, see definition of POBJNOTIFYPROC)
#define ONF_CALLING_BACK    ((UINT)0x00000100)  // set if this call is a result of ONF_CALL_BACK being set earlier

/*  Definitions of cOidChg, cOidDel and poid
    in all cases, poid points to a list of object id's

1) when ONF_CHANGED is set, cOidChg is the number of object id's in the list that should be synchronized. cOidDel is not used
2) when ONF_DELETED is set, cOidChg is not used, cOidDel is the number of deleted object id's in the list that should be synchronized
3) when both ONF_CHANGED & ONF_DELETED is not set,
    cOidChg is count of object id's in the first part of the list for objects that are changed
    cOidDel is count of object id's in the later part of the list for objects that are not changed

*/

typedef struct tagObjNotify
{
    UINT        cbStruct;       // Input. Size of the structure in bytes.
#ifdef UNDER_CE
    OBJTYPENAME szObjType;      // Input, the object type name
#else
    OBJTYPENAMEA szObjType;      // Input, the object type name
#endif
    UINT        uFlags;         // Input, Flags, see ONF_xxx above
    UINT        uPartnerBit;    // Input, which partner this
    CEOID       oidObject;      // Input. CEOID of the file system object changed/deleted
    CEOIDINFO   oidInfo;        // Input. Information about the file system object

    UINT        cOidChg;        // Output, see above comment for definition.
    UINT        cOidDel;        // Output, see above comment for definition.
    UINT        *poid;          // Output, see above comment for definition.
                                // Note that, memory pointed to by this pointer is owned by the clients.
                                // It will not be freed by replication.
    LPBYTE      lpbVolumeID;    // ID of the volume where all above objects lives. NULL if the objects are in RAM
    UINT        cbVolumeID;     // size of above ID in bytes
} OBJNOTIFY, *POBJNOTIFY;

#define FO_MORE_VOLUME      ((UINT)0x00000001)  // set by ActiveSync module. there are more volumes of objects
#define FO_DONE_ONE_VOL     ((UINT)0x00000002)  // set by ActiveSync manager, let ActiveSync module to free up the memory allocated in FINDOBJINFO

typedef struct tagFindObjInfo
{
    UINT        uFlags;         // See FO_* above
#ifdef UNDER_CE
    OBJTYPENAME szObjType;      // what object type we need to enumerate
#else
    OBJTYPENAMEA szObjType;      // what object type we need to enumerate
#endif

    UINT        *poid;          // points to list of object ID's,
                                // first part is for unchanged objects, last part is for changed objects

    UINT        cUnChg;         // # of unchanged object ID's in above list
    UINT        cChg;           // # of changed object ID's in above list

    LPBYTE      lpbVolumeID;    // ID of the volume where all above objects lives. NULL if the objects are in RAM
    UINT        cbVolumeID;     // size of above ID in bytes

    LPVOID      lpvUser;        // an ActiveSync module can save anything it wants in this variable
} FINDOBJINFO, *PFINDOBJINFO;

#ifdef __cplusplus
extern "C"{
#endif

// Functions exported by client's device module

// for Function: InitObjType
typedef BOOL (*PINITOBJPROC)( LPWSTR lpszObjType, IReplObjHandler **ppObjHandler, UINT uPartnerBit );

// for Function: ObjectNofity
typedef BOOL (*POBJNOTIFYPROC)( POBJNOTIFY );

// for Function: GetObjTypeInfo
typedef BOOL (*PGETOBJTYPEINFO)( POBJTYPEINFO );

// for Function: ReportStatus
typedef BOOL (*PREPORTSTATUS)( LPWSTR lpszObjType, UINT uCode, UINT uParam );

// for Function: FindObjects
typedef HRESULT (*PFINDOBJECTS)( PFINDOBJINFO );

// for Function: SyncData
typedef HRESULT (*PSYNCDATA )( PSDREQUEST psd );

#ifdef __cplusplus
}
#endif

#endif  // UNDER_CE

#define SZ_OUTSTORE_PROG_ID     TEXT( "MS.WinCE.OutLook" )
#define SZ_SCDSTORE_PROG_ID     TEXT( "MS.WinCE.SchedulePlus" )

#define SZ_APPT                 TEXT( "Appointment" )
#define SZ_CONTACT              TEXT( "Contact" )
#define SZ_TASK                 TEXT( "Task" )
#define SZ_FILE                 TEXT( "File" )
#define SZ_INBOX                TEXT( "Inbox" )
#define SZ_CHANNELS             TEXT( "Channel" )
#endif  // _INC_CESYNC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ce_setup.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;
//
// CE_SETUP.H
//
// This public header file specifies function prototypes that WCELOAD.EXE will call
// in the ISV application's "SETUP.DLL", as well as the supported return values.

#ifdef __cplusplus
extern "C" {
#endif

//
// Install_Init
//
// @comm    Called before any part of the application is installed
//
typedef enum
{
    codeINSTALL_INIT_CONTINUE  = 0,     // @comm Continue with the installation
    codeINSTALL_INIT_CANCEL             // @comm Immediately cancel the installation
}
codeINSTALL_INIT;

codeINSTALL_INIT
Install_Init(
    HWND        hwndParent,
    BOOL        fFirstCall,     // is this the first time this function is being called?
    BOOL        fPreviouslyInstalled,
    LPCTSTR     pszInstallDir
);

typedef codeINSTALL_INIT (*pfnINSTALL_INIT)( HWND, BOOL, BOOL, LPCTSTR );
const TCHAR szINSTALL_INIT[]    = TEXT("Install_Init");

//
// Install_Exit
//
// @comm    Called after the application is installed
//
typedef enum
{
    codeINSTALL_EXIT_DONE       = 0,    // @comm Exit the installation successfully
    codeINSTALL_EXIT_UNINSTALL          // @comm Uninstall the application before exiting the installation
}
codeINSTALL_EXIT;

codeINSTALL_EXIT
Install_Exit(
    HWND    hwndParent,
    LPCTSTR pszInstallDir,      // final install directory
    WORD    cFailedDirs,
    WORD    cFailedFiles,
    WORD    cFailedRegKeys,
    WORD    cFailedRegVals,
    WORD    cFailedShortcuts
);

typedef codeINSTALL_EXIT (*pfnINSTALL_EXIT)( HWND, LPCTSTR, WORD, WORD, WORD, WORD, WORD );
const TCHAR szINSTALL_EXIT[]    = TEXT("Install_Exit");

//
// Uninstall_Init
//
// @comm    Called before the application is uninstalled
//
typedef enum
{
    codeUNINSTALL_INIT_CONTINUE = 0,    // @comm Continue with the uninstallation
    codeUNINSTALL_INIT_CANCEL           // @comm Immediately cancel the uninstallation
}
codeUNINSTALL_INIT;

codeUNINSTALL_INIT
Uninstall_Init(
    HWND        hwndParent,
    LPCTSTR     pszInstallDir
);

typedef codeUNINSTALL_INIT (*pfnUNINSTALL_INIT)( HWND, LPCTSTR );
const TCHAR szUNINSTALL_INIT[]  = TEXT("Uninstall_Init");

//
// Uninstall_Exit
//
// @comm    Called after the application is uninstalled
//
typedef enum
{
    codeUNINSTALL_EXIT_DONE     = 0     // @comm Exit the uninstallation successfully
}
codeUNINSTALL_EXIT;

codeUNINSTALL_EXIT
Uninstall_Exit(
    HWND    hwndParent
);

typedef codeUNINSTALL_EXIT (*pfnUNINSTALL_EXIT)( HWND );
const TCHAR szUNINSTALL_EXIT[]  = TEXT("Uninstall_Exit");

#ifdef __cplusplus
}       // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cmcspmobilevpn.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//

#pragma once

#ifndef _CmCspMobileVpn_h_
#define _CmCspMobileVpn_h_

#include <CmNet.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
#define CM_CONST(name, value) \
        const DWORD name = DWORD(value)
#else
#define CM_CONST(name, value) \
        enum { name = value }
#endif

//
// The Mobile VPN CSP version
//
CM_CONST(CM_CSP_MOBILEVPN_CURRENT_VERSION, 1);

//
// A fixed Mobile VPN connection name, any use of other connection name for Mobile VPN type will be rejected.
//
static const TCHAR CM_CSP_MOBILEVPN_CONNECTION[] = TEXT("{E17DCB4B-30D5-4484-B429-519403826D3F}");

//
// Defining a Mobile VPN type
//
// {D08E2B6A-419C-4225-ACE9-A990EE6184CF}
static const CM_CONNECTION_TYPE CM_CSP_MOBILEVPN_TYPE = 
{ 0xd08e2b6a, 0x419c, 0x4225, { 0xac, 0xe9, 0xa9, 0x90, 0xee, 0x61, 0x84, 0xcf } };

//
// The Mobile VPN network type.
//
DEFINE_GUID(CMCN_VIRTUAL_VPN_MOBILE,  0x5eb0a246, 0x46df, 0x4d13, 0xb1, 0x5e, 0xcd, 0xc1, 0x42, 0x19, 0xbe, 0xd6); // {5EB0A246-46DF-4d13-B15E-CDC14219BED6}

//
// Mobile VPN Key exchange types
//
enum CM_CSP_MOBILEVPN_KEY_EXCHANGE_ALGORITHMS
{
    CM_CSP_MOBILEVPN_KEY_EXCHANGE_DH_GROUP_2      = 0x00000002,
    CM_CSP_MOBILEVPN_KEY_EXCHANGE_DH_GROUP_5      = 0x00000004,
    CM_CSP_MOBILEVPN_KEY_EXCHANGE_DH_GROUP_14     = 0x00000008,
    CM_CSP_MOBILEVPN_KEY_EXCHANGE_DH_GROUP_15     = 0x00000010,
    CM_CSP_MOBILEVPN_KEY_EXCHANGE_DH_GROUP_16     = 0x00000020
};

//
// Mobile VPN Data encryption types
//
enum CM_CSP_MOBILEVPN_DATA_ENCRYPTION_ALGORITHMS
{
    CM_CSP_MOBILEVPN_DATA_ENCRYPTION_3DES      = 0x00000010,
    CM_CSP_MOBILEVPN_DATA_ENCRYPTION_AES       = 0x00000020
};


//
// The following are the suggested default value for Mobile VPN connection.
// These values are used in the Mobile VPN Configuration Service Provider as well.
//

static ULONG const CM_CSP_MOBILEVPN_DEFAULT_KEY_EXCHANGE_ALGORITHMS =
    CM_CSP_MOBILEVPN_KEY_EXCHANGE_DH_GROUP_2 |
    CM_CSP_MOBILEVPN_KEY_EXCHANGE_DH_GROUP_5 |
    CM_CSP_MOBILEVPN_KEY_EXCHANGE_DH_GROUP_14|
    CM_CSP_MOBILEVPN_KEY_EXCHANGE_DH_GROUP_15|
    CM_CSP_MOBILEVPN_KEY_EXCHANGE_DH_GROUP_16;

static ULONG const CM_CSP_MOBILEVPN_DEFAULT_DATA_ENCRYPTION_ALGORITHMS =
    CM_CSP_MOBILEVPN_DATA_ENCRYPTION_3DES |
    CM_CSP_MOBILEVPN_DATA_ENCRYPTION_AES;

static BOOL const CM_CSP_MOBILEVPN_DEFAULT_USER_SWITCHABLE = TRUE;
static BOOL const CM_CSP_MOBILEVPN_DEFAULT_WWAN_ROAMING_KEEPALIVE = FALSE;
static BOOL const CM_CSP_MOBILEVPN_DEFAULT_WWAN_CONNECTION_FAILOVER = TRUE;
static BOOL const CM_CSP_MOBILEVPN_DEFAULT_WLAN_CONNECTION_FAILOVER = TRUE;
static BOOL const CM_CSP_MOBILEVPN_DEFAULT_ENABLE = TRUE;

static ULONG const CM_CSP_MOBILEVPN_DEFAULT_NAT_KEEPALIVE_INTERVAL = 0;
static ULONG const CM_CSP_MOBILEVPN_DEFAULT_NON_NAT_KEEPALIVE_INTERVAL = 1680;   // 28 minutes
static ULONG const CM_CSP_MOBILEVPN_DEFAULT_IKESA_LIFETIME = 26280;    // 7.3 hours
static ULONG const CM_CSP_MOBILEVPN_DEFAULT_IPSECSA_LIFETIME = 21600;  // 6 hours

CM_CONST(CM_CSP_MOBILEVPN_STRING_LENGTH, 256);
CM_CONST(CM_CSP_MOBILEVPN_CTL_HASH_LENGTH, 41); // single SHA1 + null terminated char


//
// represent a position in the config existence bitmask of every config parameter.
//
typedef enum 
{
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_NONE                       = 0x0,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_IKASALIFETIME              = 0x00000001,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_IPSECSALIFETIME            = 0x00000002,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_NONNATKEEPALIVEINTERVAL    = 0x00000004,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_NATKEEPALIVEINTERVAL       = 0x00000008,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_KEYEXCHANGEALGORITHMS      = 0x00000010,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_DATAENCRYPTIONALGORITHMS   = 0x00000020,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_SERVERNAME                 = 0x00000040,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_CLIENTCERTSEARCHCRITERIA   = 0x00000080,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_CTLHASH                    = 0x00000100,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_WWANCONNECTION             = 0x00000200,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_WLANCONNECTION             = 0x00000400,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_USERSWITCHABLE             = 0x00000800,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_WWANROAMINGKEEPALIVE       = 0x00001000,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_WWANCONNECTIONFAILOVER     = 0x00002000,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_WLANCONNECTIONFAILOVER     = 0x00004000
} CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_EXISTENCE_BITMASK;

//
// Internal used Macro, it is highly recommended to use method call such as
// CmCspMobileVpnDoesConfigParamExist, CmCspMobileVpnUnsetConfigParamExist, CmCspMobileVpnSetConfigParamExist
// instead.
//
#define CM_CSP_MOBILEVPN_DOES_CONFIG_PARAM_EXIST(_bitmaskConfig_, _paramIndex_) (_bitmaskConfig_ & _paramIndex_)
#define CM_CSP_MOBILEVPN_MARK_CONFIG_PARAM_NOT_EXIST(_bitmaskConfig_, _paramIndex_) (_bitmaskConfig_ &= (~_paramIndex_))
#define CM_CSP_MOBILEVPN_MARK_CONFIG_PARAM_EXIST(_bitmaskConfig_, _paramIndex_) (_bitmaskConfig_ |= _paramIndex_)


//
// This data structure describes the format of type specific configuration
// data used by MobileVPN CSP. (these are "input" of VPN)
//
typedef struct CM_CSP_MOBILEVPN_SPECIFIC_CONFIG
{
    DWORD   dwVersion;
#define CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_VERSION_1  1
    DWORD   dwBitMaskConfigParamExistence;
    DWORD   dwBitMaskKeyExchangeExistence;
    DWORD   dwBitMaskDataEncryptionExistence;
    DWORD   dwIKESALifetime;
    DWORD   dwIPSecSALifetime;
    DWORD   dwNonNATKeepAliveInterval;
    DWORD   dwNATKeepAliveInterval;
    DWORD   dwKeyExchangeAlgorithms;
    DWORD   dwDataEncryptionAlgorithms;
    WCHAR   wszServerName[CM_CSP_MOBILEVPN_STRING_LENGTH];
    WCHAR   wszClientCertSearchCriteria[CM_CSP_MOBILEVPN_STRING_LENGTH];
    WCHAR   wszCTLHash[CM_CSP_MOBILEVPN_CTL_HASH_LENGTH];
    WCHAR   wszWWANConnection[CM_CSP_MOBILEVPN_STRING_LENGTH];
    WCHAR   wszWLANConnection[CM_CSP_MOBILEVPN_STRING_LENGTH];
    BOOL    fUserSwitchable;
    BOOL    fWWANRoamingKeepalive;
    BOOL    fWWANConnectionFailover;
    BOOL    fWLANConnectionFailover;
} CM_CSP_MOBILEVPN_SPECIFIC_CONFIG;

//
// This data structure describes the format of type specific inforamtion
// data used by MobileVPN CSP. (these are "output" of VPN)
//
typedef struct CM_CSP_MOBILEVPN_SPECIFIC_INFO
{
    DWORD   dwVersion;
#define CM_CSP_MOBILEVPN_SPECIFIC_INFO_VERSION_1    1
    DWORD   dwReserved1;
    DWORD   dwReserved2;
    DWORD   dwReserved3;
    DWORD   dwReserved4;
    DWORD   dwKeepAliveInterval;
    WCHAR   wszBaseConnectionName[CM_CONNECTION_NAME_LENGTH];
    SOCKADDR_STORAGE    saGatewayAddr;
} CM_CSP_MOBILEVPN_SPECIFIC_INFO;


//
// The following methods are used to check/set/unset the config parameter existence bitmask.
//

//
// This method to check if a parameter in the MobileVPN config structure
// existed or not.
//
FORCEINLINE BOOL CmCspMobileVpnDoesConfigParamExist(
    const CM_CSP_MOBILEVPN_SPECIFIC_CONFIG* pConfigInfo,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_EXISTENCE_BITMASK eConfigParam)
{
    ASSERT(pConfigInfo);
    if (eConfigParam != CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_NONE)
    {
        return CM_CSP_MOBILEVPN_DOES_CONFIG_PARAM_EXIST(pConfigInfo->dwBitMaskConfigParamExistence, eConfigParam);
    }
    return TRUE;
}

//
// This method to unset the existence bit of a parameter. It is expected to be called
// after a MobileVPN config parameter has been removed.
//
FORCEINLINE void CmCspMobileVpnUnsetConfigParamExist(
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG* pConfigInfo,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_EXISTENCE_BITMASK eConfigParam)
{
    ASSERT(pConfigInfo);
    if (eConfigParam != CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_NONE)
    {
        CM_CSP_MOBILEVPN_MARK_CONFIG_PARAM_NOT_EXIST(pConfigInfo->dwBitMaskConfigParamExistence, eConfigParam);
    }
}

//
// This method to set the existence bit of a parameter. It is expected to be called
// when a MobileVPN config parameter is add/set.
//
FORCEINLINE void CmCspMobileVpnSetConfigParamExist(
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG* pConfigInfo,
    CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_EXISTENCE_BITMASK eConfigParam)
{
    ASSERT(pConfigInfo);
    if (eConfigParam != CM_CSP_MOBILEVPN_SPECIFIC_CONFIG_NONE)
    {
        CM_CSP_MOBILEVPN_MARK_CONFIG_PARAM_EXIST(pConfigInfo->dwBitMaskConfigParamExistence, eConfigParam);
    }
}

#ifdef __cplusplus
}
#endif

#endif // _CmCspMobileVpn_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\CmCspRas.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//

#pragma once

#include <CmNet.h>
#include <ras.h>

// {59B09E94-9E0E-456b-A02B-F73AED543130}
static const CM_CONNECTION_TYPE CM_CSP_RAS_TYPE = 
{ 0x59b09e94, 0x9e0e, 0x456b, { 0xa0, 0x2b, 0xf7, 0x3a, 0xed, 0x54, 0x31, 0x30 } };

//
// This data structure describes the format of type specific configuration
// data used by CSPRAS.
//
struct CspRasSpecificInfo
{
    DWORD         Version;
#define CSP_RAS_SPECIFIC_INFO_VERSION_1     1
    RASENTRY      RasEntry;
    RASDIALPARAMS RasDialParams;
    DWORD         cbDevConfig;
    BYTE          DevConfig[1];   // Variable length array, actual length is cbDevConfig bytes
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cguid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       cguid.h
//
//--------------------------------------------------------------------------

#pragma once

#ifndef __CGUID_H__
#define __CGUID_H__

#ifdef __cplusplus
extern "C" {
#endif

extern const IID GUID_NULL;
extern const IID IID_IRpcChannel;
extern const IID IID_IRpcStub;
extern const IID IID_IStubManager;
extern const IID IID_IRpcProxy;
extern const IID IID_IProxyManager;
extern const IID IID_IPSFactory;
extern const IID IID_IInternalMoniker;
extern const IID IID_IDfReserved1;
extern const IID IID_IDfReserved2;
extern const IID IID_IDfReserved3;
extern const CLSID CLSID_StdMarshal;
extern const IID IID_IStub;
extern const IID IID_IProxy;
extern const IID IID_IEnumGeneric;
extern const IID IID_IEnumHolder;
extern const IID IID_IEnumCallback;
extern const IID IID_IOleManager;
extern const IID IID_IOlePresObj;
extern const IID IID_IDebug;
extern const IID IID_IDebugStream;
extern const CLSID CLSID_PSGenObject;
extern const CLSID CLSID_PSClientSite;
extern const CLSID CLSID_PSClassObject;
extern const CLSID CLSID_PSInPlaceActive;
extern const CLSID CLSID_PSInPlaceFrame;
extern const CLSID CLSID_PSDragDrop;
extern const CLSID CLSID_PSBindCtx;
extern const CLSID CLSID_PSEnumerators;
extern const CLSID CLSID_StaticMetafile;
extern const CLSID CLSID_StaticDib;
extern const CLSID CID_CDfsVolume;
extern const CLSID CLSID_DCOMAccessControl;
extern const CLSID CLSID_StdGlobalInterfaceTable;
extern const CLSID CLSID_ComBinding;

//********************************************
//
// CD Forms CLSIDs
//
//********************************************

//
// Form Kernel objects
//
extern const CLSID CLSID_CCDFormKrnl;
extern const CLSID CLSID_CCDPropertyPage;
extern const CLSID CLSID_CCDFormDialog;

//
// Control objects
//
extern const CLSID CLSID_CCDCommandButton;
extern const CLSID CLSID_CCDComboBox;
extern const CLSID CLSID_CCDTextBox;
extern const CLSID CLSID_CCDCheckBox;
extern const CLSID CLSID_CCDLabel;
extern const CLSID CLSID_CCDOptionButton;
extern const CLSID CLSID_CCDListBox;
extern const CLSID CLSID_CCDScrollBar;
extern const CLSID CLSID_CCDGroupBox;

//
// Property Pages
//
extern const CLSID CLSID_CCDGeneralPropertyPage;
extern const CLSID CLSID_CCDGenericPropertyPage;
extern const CLSID CLSID_CCDFontPropertyPage;
extern const CLSID CLSID_CCDColorPropertyPage;
extern const CLSID CLSID_CCDLabelPropertyPage;
extern const CLSID CLSID_CCDCheckBoxPropertyPage;
extern const CLSID CLSID_CCDTextBoxPropertyPage;
extern const CLSID CLSID_CCDOptionButtonPropertyPage;
extern const CLSID CLSID_CCDListBoxPropertyPage;
extern const CLSID CLSID_CCDCommandButtonPropertyPage;
extern const CLSID CLSID_CCDComboBoxPropertyPage;
extern const CLSID CLSID_CCDScrollBarPropertyPage;
extern const CLSID CLSID_CCDGroupBoxPropertyPage;
extern const CLSID CLSID_CCDXObjectPropertyPage;

extern const CLSID CLSID_CStdPropertyFrame;

extern const CLSID CLSID_CFormPropertyPage;
extern const CLSID CLSID_CGridPropertyPage;

extern const CLSID CLSID_CWSJArticlePage;
extern const CLSID CLSID_CSystemPage;

extern const CLSID CLSID_IdentityUnmarshal;
extern const CLSID CLSID_InProcFreeMarshaler;

extern const CLSID CLSID_Picture_Metafile;
extern const CLSID CLSID_Picture_EnhMetafile;
extern const CLSID CLSID_Picture_Dib;

//
// Enumerations
//
extern const GUID GUID_TRISTATE;

#ifdef __cplusplus
}
#endif


#endif // __CGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\CmCsp.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _CmCsp_h_
#define _CmCsp_h_

#include <CmNet.h>
#include <RmNet.h>

#ifdef __cplusplus
extern "C" {
#endif

/*! \file CmCsp.h */

//! Notification type and structure used by CSP to send to CM.
//!
typedef enum CM_CSP_NOTIFICATION_TYPE
{
    CMPN_CONNECTION_STATE_CHANGE,
    CMPN_CONNECTION_NETWORK_TYPE_CHANGE,
    CMPN_CHARACTERISTIC_VALUE_CHANGE,
    CMPN_TYPE_SPECIFIC_NOTIFICATION

} CM_CSP_NOTIFICATION_TYPE;

typedef struct CM_CSP_NOTIFICATION
{
    DWORD Version;
    WCHAR ConnectionName[CM_CONNECTION_NAME_LENGTH];

    CM_CSP_NOTIFICATION_TYPE Type;
    union
    {
        // Used for CMPN_CONNECTION_STATE_CHANGE.
        struct
        {
            CM_CONNECTION_STATE State;
            
        } State;

        // Used for CMPN_CONNECTION_NETWORK_TYPE_CHANGE.
        struct
        {
            CM_CONNECTION_NETWORK_TYPE Network;
            
        } NetworkType;

        // Used for CMPN_CHARACTERISTIC_VALUE_CHANGE.
        struct
        {
            CM_CHARACTERISTIC Characteristic;
            DWORD Value;
            
        } Characteristic;

        // Used for CMPN_TYPE_SPECIFIC_NOTIFICATION.
        struct
        {
            DWORD cbData;
            BYTE Data[1];
            
        } TypeSpecific;
    };

} CM_CSP_NOTIFICATION;

//! Function used by CSP to notify CM of connection status changes.
//!
typedef void (*CM_CSP_ASYNC_NOTIFICATION)(
    __in_bcount(cbNotification) const CM_CSP_NOTIFICATION* const pNotification,
    __in DWORD cbNotification,
    __in DWORD NotificationParam);

//! Information provided by CM to CSP at initialization.
//!
typedef struct CM_CSP_HOST_INFO
{
    DWORD Version;
    CM_CSP_ASYNC_NOTIFICATION pfnNotification;
    DWORD NotificationParam;

} CM_CSP_HOST_INFO;

//! Information provided by CSP to CM at initialization.
//!
typedef struct CM_CSP_PROVIDER_INFO
{
    DWORD Version;
    DWORD cConnectionType;
    CM_CONNECTION_TYPE ConnectionType[1];

} CM_CSP_PROVIDER_INFO;

//! Connection information available at the CSP.
//!
typedef struct CM_CSP_CONNECTION_INFO
{
    DWORD Version;
    WCHAR szAdapter[CM_CONNECTION_ADAPTER_NAME_LENGTH];
    CM_CONNECTION_TYPE Type;
    CM_CONNECTION_DEVICE_TYPE Device;
    CM_CONNECTION_NETWORK_TYPE Network;
    CM_CONNECTION_STATE State;
    DWORD Characteristic[CMCH_LAST];

} CM_CSP_CONNECTION_INFO;

//! Called by CM Service to initialize CSP.  The intent of the call is to:
//! 1. Initialize CSP, such that it is ready to handle other API calls.
//! 2. Register connection types handled by the CSP with CM.
//! 3. Register an asynchronous method of message passing between CSP and CM.
//!
//! If initialization succeeds, function returns CMRE_SUCCEEDED.  Possible
//! results indicating failure are:
//!
//! CMRE_INVALID_VERSION indicates that CSP cannot handle the CM version.  This
//!     may happen if CM is of a lower version than CSP, and the CSP requires
//!     CM functionality that is not available in the indicated version.
//! CMRE_INSUFFICIENT_BUFFER indicates that the output buffer is too small.
//! CMRE_INVALID_PARAMETER indicates that one or more of input and/or output
//!     paramters are invalid.
//! CMRE_UNEXPECTED indicates any other failure to initialize.
//!
CM_RESULT CmCspInitialize(
    __in_bcount(cbHostInfo) const CM_CSP_HOST_INFO* pHostInfo,
    __in DWORD const cbHostInfo,
    __out_bcount(*pcbProviderInfo) CM_CSP_PROVIDER_INFO* pProviderInfo,
    __inout DWORD* pcbProviderInfo);

typedef CM_RESULT (*CM_CSP_INITIALIZE)(
    __in_bcount(cbHostInfo) const CM_CSP_HOST_INFO* pHostInfo,
    __in const DWORD cbHostInfo,
    __out_bcount(*pcbProviderInfo) CM_CSP_PROVIDER_INFO* pProviderInfo,
    __inout DWORD* pcbProviderInfo);

//! Called by CM Service to deinitialize CSP prior to unloading it.
//!
void CmCspDeinitialize();

typedef void (*CM_CSP_DEINITIALIZE)();

//! Called by CM Service to configure a new named connection with CSP.
//! The connection name is guaranteed to be unique.
//!
CM_RESULT CmCspAddConnectionConfig(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) const WCHAR* szConnection,
    __in CM_CONNECTION_TYPE Type,
    __in_bcount(cbTypeSpecificInfo) const BYTE* pTypeSpecificInfo,
    __in DWORD cbTypeSpecificInfo);

typedef CM_RESULT (*CM_CSP_ADD_CONNECTION_CONFIG)(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) const WCHAR* szConnection,
    __in CM_CONNECTION_TYPE Type,
    __in_bcount(cbTypeSpecificInfo) const BYTE* pTypeSpecificInfo,
    __in DWORD cbTypeSpecificInfo);

//! Called by CM Service to get configuration associated with the named
//! connection.
//!
//! If configuration has been retrieved, function returns CMRE_SUCCEEDED.
//! Possible results indicating failure are:
//!
//! CMRE_INVALID_CONNECTION indicates that the connection doesn't exist.
//! CMRE_INVALID_PARAMETER indicates that one or more of input and/or output
//!     paramters other than the name of the connection are invalid.
//! CMRE_INSUFFICIENT_BUFFER indicates that the configuration requires a larger
//!     output buffer.  pcbTypeSpecificInfo will be set to point to size of
//!     required buffer.
//! CMRE_UNEXPECTED indicates any other failure to delete the connection.
//!
CM_RESULT CmCspGetConnectionConfig(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) const WCHAR* szConnection,
    __inout_bcount(*pcbTypeSpecificInfo) BYTE* pTypeSpecificInfo,
    __inout DWORD* pcbTypeSpecificInfo);

typedef CM_RESULT (*CM_CSP_GET_CONNECTION_CONFIG)(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) const WCHAR* szConnection,
    __inout_bcount(pcbTypeSpecificInfo) BYTE* pTypeSpecificInfo,
    __inout DWORD* pcbTypeSpecificInfo);

//! Called by CM Service to update configuration settings associated with the
//! named connection.  The two configuration structures, "previous" and "new",
//! allow the CSP to determine which parts of the configuration structure were
//! updated (the delta) and make decisions in how to apply the updates (ex.
//! does connection need to be disconnected for settings to take effect?), or
//! whether to fail the call (ex. an earlier configuration change, possibly
//! from another application, modified part or parts of the structure described
//! by the delta between "previous" and "new" and contents of "previous" are
//! not the same as current; application of such delta could have unintended
//! effect on the configuration and produce inconsistent configuration).
//!
//! If configuration update succeeds, function returns CMRE_SUCCEEDED.  Possible
//! results indicating failure are:
//!
//! CMRE_INVALID_CONNECTION indicates that the connection to be updated doesn't
//!     exist.
//! CMRE_INVALID_PARAMETER indicates that one or more of input and/or output
//!     parameters other than the name of the connection are invalid.
//! CMRE_INCONSISTENT_CONFIGURATION indicates that application of delta would
//!     cause configuration to be inconsistent so it has been rejected.
//! CMRE_UNEXPECTED indicates any other failure to update configuration.
//
CM_RESULT CmCspUpdateConnectionConfig(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) const WCHAR* szConnection,
    __in_bcount(cbTypeSpecificInfoPrevious) const BYTE* pTypeSpecificInfoPrevious,
    __in DWORD cbTypeSpecificInfoPrevious,
    __in_bcount(cbTypeSpecificInfoNew) const BYTE* pTypeSpecificInfoNew,
    __in DWORD cbTypeSpecificInfoNew,
    __out BOOL* pfDisconnectToApplyChanges);

typedef CM_RESULT (*CM_CSP_UPDATE_CONNECTION_CONFIG)(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) const WCHAR* szConnection,
    __in_bcount(cbTypeSpecificInfoPrevious) const BYTE* pTypeSpecificInfoPrevious,
    __in DWORD cbTypeSpecificInfoPrevious,
    __in_bcount(cbTypeSpecificInfoNew) const BYTE* pTypeSpecificInfoNew,
    __in DWORD cbTypeSpecificInfoNew,
    __out BOOL* pfDisconnectToApplyChanges);

//! Called by CM Service to delete the named connection.
//!
//! If configuration delete succeeds, function returns CMRE_SUCCEEDED.  Possible
//! results indicating failure are:
//!
//! CMRE_INVALID_CONNECTION indicates that the connection to be deleted doesn't
//!     exist.
//! CMRE_UNEXPECTED indicates any other failure to delete the connection.
//!
CM_RESULT CmCspDeleteConnectionConfig(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) const WCHAR* szConnection);

typedef CM_RESULT (*CM_CSP_DELETE_CONNECTION_CONFIG)(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) const WCHAR* szConnection);

//! Called by CM Service to get resource(s) required to be reserved for the
//! named connection prior to connecting it.  The values that the function
//! returns depend on the case that the connection falls into:
//!
//! 1. The connection needs one specific resource to be acquired before it can
//!    be connected, in which case it returns the resource ID in pResourceId,
//!    and sets pcbResourceId to the sizeof RM_RESOURCE_ID.
//! 2. The connection can use any one of N resources (R_1 or R_2 or ... R_N),
//!    in which case it populates array of RM_RESOURCE_IDs pointed by
//!    pResourceId with the possible resources, and sets pcbResourceId to
//!    N * sizeof RM_RESOURCE_ID.
//! 3. If the connection has the same connection type specific information as
//!    another one that is already connected, then CSP should set phResource to
//!    resource handle associated with the already connected connection.  Note
//!    that CmCspConnect will pass-in the resource handle of the acquired
//!    resource ID.
//!
//! If the call succeeds, the function returns CMRE_SUCCEEDED.  Possible results
//! indicating failures are:
//!
//! CMRE_INVALID_CONNECTION indicates that the connection to be updated doesn't
//!     exist.
//! CMRE_INVALID_PARAMETER indicates that one or more of input and/or output
//!     parameters other than the name of the connection are invalid.
//! CMRE_INSUFFICIENT_BUFFER indicates that the pResourceId requires a larger
//!     output buffer.  pcbResourceId is set to point to size of required
//!     buffer.
//! CMRE_UNEXPECTED indicates an unexpected failure.
//!
CM_RESULT CmCspGetResource(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) WCHAR* szConnection,
    __out_bcount(*pcbResourceId) RM_RESOURCE_ID* pResourceId,
    __out DWORD* pcbResourceId,
    __out RM_RESOURCE_HANDLE* phResource);

typedef CM_RESULT (*CM_CSP_GET_RESOURCE)(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) WCHAR* szConnection,
    __out_bcount(*pcbResourceId) RM_RESOURCE_ID* pResourceId,
    __out DWORD* pcbResourceId,
    __out RM_RESOURCE_HANDLE* phResource);

//! Called by CM Service to connect the named connection after successfully
//! allocating the required resource.  The resource handle corresponding to
//! the acquired resource is passed in hResource parameter.
//!
//! This API must return only when attempt to connect connection has succeeded
//! (CMRE_SUCCESS) or failed (result other than CMRE_SUCCESS).  Success 
//! indicates that connection is ready to be used to send and receive data, that
//! is, IP interface that corresponds to the CM connection is available and has
//! been assigned a valid IP address.  The name of the adapter returned in
//! szAdapter parameter is case sensitive and must correspond to adapter
//! indicated by the TCP/IP stack.
//!
//! Prior to calling this API, CM automatically transitions connection state to
//! CMCS_CONNECTING.  When this API returns with success CM automatically
//! transitions state to CMCS_CONNECTED, otherwise to CMCS_DISCONNECTED.
//!
//! It is important that this API returns as soon as possible.  Delays in
//! returning will cause delays in applications attempting to use the
//! connection and potentially lead to bad user experience.
//!
//! CM will serialize calls to CmCspConnect, CmCspDisconnect and
//! CmCspGetConnectionInfo.
//!
//! Possible results are:
//!
//! CMRE_SUCCESS indicates that the connection has been successfully connected.
//! CMRE_INVALID_CONNECTION indicates that the connection doesn't exist.
//! CMRE_UNEXPECTED indicates an unexpected failure, such as connection or
//!     underlying device is in a state that is not able to handle a connection
//!     attempt.
//!
CM_RESULT CmCspConnect(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) WCHAR* szConnection,
    __in RM_RESOURCE_HANDLE hResource,
    __out_bcount(cbAdapter) WCHAR* szAdapter,
    __in DWORD cbAdapter);

typedef CM_RESULT (*CM_CSP_CONNECT)(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) WCHAR* szConnection,
    __in RM_RESOURCE_HANDLE hResource,
    __out_bcount(cbAdapter) WCHAR* szAdapter,
    __in DWORD cbAdapter);

//! Called by CM Service to disconnect the named connection.  This call
//! notifies CSP that the connection is no longer needed by any application.
//! Immediately after the call returns CM will free the resources associated
//! with the connection, so it is important that the CSP implementation of
//! this API doesn't return until the disconnection was completed.
//!
//! This API must return only when connection has been completely disconnected
//! and the IP address of the interface has been released.  Prior to calling
//! this API, CM automatically transitions connection state to
//! CMCS_DISCONNECTING.  When this API returns transitions state to
//! CMCS_DISCONNECTED.
//!
//! It is important that this API returns as soon as possible.  Delays in
//! returning will cause delays in attempts to reconnect the connection.  This
//! will impact waiting application and potentially lead to bad user experience.
//!
//! CM will serialize calls to CmCspConnect, CmCspDisconnect and
//! CmCspGetConnectionInfo.
//!
//! Any result returned from this API indicates that the named connection is 
//! disconnected.
//!
CM_RESULT CmCspDisconnect(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) WCHAR* szConnection);

typedef CM_RESULT (*CM_CSP_DISCONNECT)(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) WCHAR* szConnection);

//! Called by CM Service to query connection information as seen by the CSP.
//! The passed-in pInfo will contain info that CM knows about the connection.
//! The CSP can update this info with more accurate values.  For example, if
//! value of one of the characteristics is unknown
//! (CM_UNKNOWN_CHARACTERISTIC_VALUE), CSP can update this value with an actual
//! value.  If CSP doesn't have a value for one or more of the attributes, it
//! it should leave it unchanged.
//!
CM_RESULT CmCspGetConnectionInfo(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) WCHAR* szConnection,
    __inout_bcount(*pcbInfo) CM_CSP_CONNECTION_INFO* pInfo,
    __inout DWORD* pcbInfo);

typedef CM_RESULT (*CM_CSP_GET_CONNECTION_INFO)(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) WCHAR* szConnection,
    __out_bcount(*cbInfo) CM_CSP_CONNECTION_INFO* pInfo,
    __inout DWORD* pcbInfo);

//! Called by CM Service to decide if type specific configuration of two
//! configured connections is the same.  If the configurations are the same,
//! then CM will apply the same state between the two connections.  For example,
//! if one connection is connected, and there is a request to connect another
//! that has the same type specific configuration, then CM will automatically
//! connect it without calling CmCspConnect.
//!
//! Possible results are:
//! TRUE indicates that type specific configuration of the two connection is
//!     the same.
//! FALSE indicates that the configurations are different, or the two
//!     configurations could not be compared.
//!
BOOL CmCspCompareConnectionConfig(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) const WCHAR* szConnection1,
    __in CM_CONNECTION_TYPE TypeConnection2,
    __in_bcount(cbTypeSpecificConnection2) const BYTE* pTypeSpecificConnection2,
    __in DWORD cbTypeSpecificConnection2);

typedef BOOL (*CM_CSP_COMPARE_CONNECTION_CONFIG)(
    __in_bcount(CM_CONNECTION_NAME_LENGTH) const WCHAR* szConnection1,
    __in CM_CONNECTION_TYPE TypeConnection2,
    __in_bcount(cbTypeSpecificConnection2) const BYTE* pTypeSpecificConnection2,
    __in DWORD cbTypeSpecificConnection2);

//! Called by CM Service when it discovers an IP adapter that is not managed
//! by any of the CSPs.  A typical scenario of this is when an IP connection
//! has been activated out-of-band.  The CSP should handle this call by:
//!
//!     IF CSP can handle out-of-band connections AND
//!             recognizes the given adapter as one that would be created
//!             as a result of connecting one of its connection that it has
//!             configured THEN
//!         Accept connection by returning CMRE_SUCCESS and configured
//!         connection name associated with the adapter.
//!         Subsequently, the CSP should not allow this connection to be
//!         disconnected by CM.  That is, it should fail calls to
//!         CmCspDisconnect on this connection.
//!     ELSE
//!         reject connection by returning CMRE_INVALID_CONNECTION.
//!
CM_RESULT CmCspClaimConnection(
    __in WCHAR* szAdapter,
    __inout_bcount(CM_CONNECTION_NAME_LENGTH) WCHAR* szConnection);

typedef CM_RESULT (*CM_CSP_CLAIM_CONNECTION)(
    __in WCHAR* szAdapter,
    __inout_bcount(CM_CONNECTION_NAME_LENGTH) WCHAR* szConnection);

#ifdef __cplusplus
}
#endif

#endif // _CmCsp_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\CmCspWiFi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//

#pragma once

#include <CmNet.h>

// {8568B401-858E-4b7b-B3DF-0FD4927F131B}
static const CM_CONNECTION_TYPE  CM_CSP_WIFI_TYPE = 
{ 0x8568b401, 0x858e, 0x4b7b, {0xb3, 0xdf, 0xf, 0xd4, 0x92, 0x7f, 0x13, 0x1b} };

//
// The WiFi device type.
//
DEFINE_GUID(CMCD_WIFI,      0x3ad5e5a6, 0x6448, 0x4273, 0xa2, 0x65, 0xa5, 0xe7, 0x9e, 0x38, 0x52, 0xf6); // {3AD5E5A6-6448-4273-A265-A5E79E3852F6}

//
// Supported WiFi network types.
//
DEFINE_GUID(CMCN_WIFI_UNKNOWN,        0x334fe23f, 0x115, 0x450c, 0x86, 0xba, 0x64, 0xf9, 0x5e, 0xb6, 0x7d, 0xd8); // {334FE23F-0115-450c-86BA-64F95EB67DD8}
DEFINE_GUID(CMCN_WIFI_802_11_G,       0x151ee71b, 0xa534, 0x449f, 0x97, 0xa0, 0xd, 0x2c, 0x5f, 0x8, 0xbf, 0xfb);  // {151EE71B-A534-449f-97A0-0D2C5F08BFFB}
DEFINE_GUID(CMCN_WIFI_802_11_B,       0x85703fb, 0xa93c, 0x4d78, 0xa3, 0x64, 0xa1, 0xb6, 0xe9, 0xd6, 0x88, 0x26); // {085703FB-A93C-4d78-A364-A1B6E9D68826}
DEFINE_GUID(CMCN_WIFI_802_11_A,       0x2a1150a4, 0x7dc3, 0x4e91, 0xaa, 0x8, 0xc4, 0xe2, 0x71, 0x67, 0x4f, 0x7b); // {2A1150A4-7DC3-4e91-AA08-C4E271674F7B}
DEFINE_GUID(CMCN_WIFI_802_11_N,       0xd4ada027, 0x8907, 0x4b17, 0x9e, 0x39, 0xd4, 0x4b, 0xad, 0xe1, 0xfc, 0x12); //{d4ada027-8907-4b17-9e39-d44bade1fc12}
DEFINE_GUID(CMCN_WIFI_DSSS,           0xf33fafce, 0x77b8, 0x4c1e, 0xba, 0x9a, 0x73, 0x38, 0x35, 0x18, 0x47, 0xc4); //{f33fafce-77b8-4c1e-ba9a-7338351847c4}
DEFINE_GUID(CMCN_WIFI_FSSS,           0x991241c6, 0x01cc, 0x42cf, 0x8c, 0x07, 0x0d, 0x97, 0x07, 0x94, 0x96, 0xca); //{991241c6-01cc-42cf-8c07-0d97079496ca}
DEFINE_GUID(CMCN_WIFI_IR_BASEBAND,    0x44a769df, 0x9d5e, 0x426f, 0xa0, 0x1d, 0xc0, 0x45, 0x69, 0xf3, 0x6d, 0x0e); //{44a769df-9d5e-426f-a01d-c04569f36d0e}

// {C54DC729-87FA-48da-A1B5-479E209D9752}
static const RM_RESOURCE_ID RM_WIFI_RESOURCE_ID = 
{ 0xc54dc729, 0x87fa, 0x48da, { 0xa1, 0xb5, 0x47, 0x9e, 0x20, 0x9d, 0x97, 0x52 } };

//
// The following data structure describes the format of type specific configuration
// data used by CSPWIFI.
//
#define CSP_WIFI_SPECIFIC_INFO_VERSION  	1

struct CspWiFiSpecificInfo
{
    DWORD   Version;            // Version of this type specific info
    BOOL    InterfaceSpecific;  // Indicates if config is adapter-specific
    GUID    InterfaceGuid;      // Must be supplied if InterfaceSpecific is TRUE. Ignored otherwise
    DWORD   cbDevConfig;        // Size in bytes of DevConfigXml buffer
    BYTE    DevConfigXml[1];    // Variable length array containing connection profile in WLAN XML form
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\CmCspShare.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef __CMCSPSHARE_H__
#define __CMCSPSHARE_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <CmNet.h>
#include <RmNet.h>

// {A05DC613-E393-40ad-AA89-CCCE04277CD9}
static const CM_CONNECTION_TYPE CM_CSP_GSM_PACKET_TYPE =
{
    0xa05dc613,
    0xe393,
    0x40ad,
    { 0xaa, 0x89, 0xcc, 0xce, 0x4, 0x27, 0x7c, 0xd9 }
};

 // {1D0A197C-B982-4791-BFC1-D8E4B156E0B7}
static const RM_RESOURCE_ID RM_GSM_PACKET_RESOURCE_ID =
{
    0x1d0a197c,
    0xb982,
    0x4791,
    { 0xbf, 0xc1, 0xd8, 0xe4, 0xb1, 0x56, 0xe0, 0xb7 }
};

// {BD09B5B5-98C0-47b9-B3F3-D92555D86BAE}
static const RM_RESOURCE_ID RM_CSD_RESOURCE_ID =
{
    0xbd09b5b5,
    0x98c0,
    0x47b9,
    { 0xb3, 0xf3, 0xd9, 0x25, 0x55, 0xd8, 0x6b, 0xae }
};

// {54075C70-FC1A-4836-8110-602BC41E719B}
static const RM_RESOURCE_ID RM_CDMA_RESOURCE_ID =
{
    0x54075c70,
    0xfc1a,
    0x4836,
    { 0x81, 0x10, 0x60, 0x2b, 0xc4, 0x1e, 0x71, 0x9b }
};


#ifdef __cplusplus
}
#endif

#endif // __CMCSPSHARE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cmnintrin.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//  This file includes the function prototypes and support definitions
//  for the new common intrinsic functions.
//  This file also describes the level of support for each of the
//  common intrinsics.  All machines supporting the common intrinsics
//  will have a machine dependent description of support in this file.

#if defined(_CMMN_INTRIN_FUNC)

#include <crtdefs.h>

#if defined(__cplusplus)
extern "C" {
#endif

// general-purpose integer functions
// (from stdlib.h)
int  __cdecl abs(int);
long __cdecl labs(long);

unsigned int _rotl( unsigned int, int);
unsigned int _rotr( unsigned int, int);
unsigned long _lrotl( unsigned long, int);
unsigned long _lrotr( unsigned long, int);

// (new)
__int64 __cdecl _abs64(__int64);
unsigned __int64 __cdecl _rotl64(unsigned __int64,int);
unsigned __int64 __cdecl _rotr64(unsigned __int64,int);
__int32 _CopyInt32FromFloat(float);
float _CopyFloatFromInt32(__int32);
__int64 _CopyInt64FromDouble(double);
double _CopyDoubleFromInt64(__int64);

long __cdecl _MulHigh(long,long);
unsigned long __cdecl _MulUnsignedHigh (unsigned long,unsigned long);

unsigned short __cdecl _byteswap_ushort(unsigned short);
unsigned long __cdecl _byteswap_ulong(unsigned long);
unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64);

unsigned __cdecl _CountOneBits(long);
unsigned __cdecl _CountOneBits64(__int64);
unsigned __cdecl _CountLeadingZeros(long);
unsigned __cdecl _CountLeadingZeros64(__int64);
unsigned __cdecl _CountLeadingOnes(long);
unsigned __cdecl _CountLeadingOnes64(__int64);
unsigned __cdecl _CountLeadingSigns(long);
unsigned __cdecl _CountLeadingSigns64(__int64);

#if !defined(_CMNINTRIN_DECLARE_ONLY)
#pragma intrinsic (abs, labs)
#pragma intrinsic (_rotl, _rotr, _lrotl, _lrotr)
#pragma intrinsic(_abs64, _rotl64, _rotr64)
#pragma intrinsic(_MulHigh, _MulUnsignedHigh)
#pragma intrinsic(_byteswap_ushort, _byteswap_ulong, _byteswap_uint64)
#pragma intrinsic(_CountOneBits, _CountOneBits64)
#pragma intrinsic(_CountLeadingZeros, _CountLeadingZeros64)
#pragma intrinsic(_CountLeadingOnes, _CountLeadingOnes64)
#pragma intrinsic(_CountLeadingSigns, _CountLeadingSigns64)
#pragma intrinsic(_CopyInt32FromFloat)
#pragma intrinsic(_CopyFloatFromInt32)
#pragma intrinsic(_CopyInt64FromDouble)
#pragma intrinsic(_CopyDoubleFromInt64)
#endif

// floating-point intrinsic functions
// (from math.h)
float     __cdecl ceilf(float);
float     __cdecl fabsf(float);
float     __cdecl floorf(float);
float     __cdecl fmodf(float,float);
float     __cdecl sqrtf(float);
double    __cdecl acos(double);
double    __cdecl asin(double);
double    __cdecl atan(double);
double    __cdecl atan2(double, double);
double    __cdecl cos(double);
double    __cdecl cosh(double);
double    __cdecl exp(double);
double    __cdecl fabs(double);
double    __cdecl fmod(double, double);
double    __cdecl log(double);
double    __cdecl log10(double);
double    __cdecl pow(double, double);
double    __cdecl sin(double);
double    __cdecl sinh(double);
double    __cdecl sqrt(double);
double    __cdecl tan(double);
double    __cdecl tanh(double);
double    __cdecl ceil(double);
double    __cdecl floor(double);

// (new)
int __cdecl _isnan(double);
int __cdecl _isnanf(float);
int __cdecl _isunordered(double,double);
int __cdecl _isunorderedf(float,float);

#if !defined(_CMNINTRIN_DECLARE_ONLY)
#pragma intrinsic (ceilf, fabsf, floorf, fmodf, sqrtf)
#pragma intrinsic (acos, asin, atan, atan2)
#pragma intrinsic (cos, cosh, exp, fabs)
#pragma intrinsic (fmod, log, log10, pow)
#pragma intrinsic (sin, sinh, sqrt, tan)
#pragma intrinsic (tanh, ceil, floor)
#pragma intrinsic(_isnan, _isnanf, _isunordered, _isunorderedf)
#endif

#if defined(_M_MRX000) // MIPS
#pragma function(floor, floorf, ceil, ceilf)
#endif

// new system intrinsic functions
void __cdecl __prefetch(void *);
void __cdecl __CacheRelease(void *);
void __cdecl __CacheWriteback(void *);
void __cdecl __ICacheRefresh(void *);

void __cdecl _ReadWriteBarrier(void);
void __cdecl _WriteBarrier(void);

void __cdecl __debugbreak(void);
int __cdecl __trap(int,...);

#if !defined(_CMNINTRIN_DECLARE_ONLY)
#pragma intrinsic(__prefetch, __CacheRelease, __CacheWriteback, __ICacheRefresh)
#pragma intrinsic(_ReadWriteBarrier, _WriteBarrier)
#pragma intrinsic(__debugbreak, __trap)
#endif

// old intrinsic functions from string.h

int    __cdecl memcmp(const void *, const void *, size_t);
void * __cdecl memcpy(void *, const void *, size_t);
void * __cdecl memset(void *, int, size_t);
_CONST_RETURN void * __cdecl memchr(const void *, int, size_t);

size_t __cdecl strlen(const char *);
int    __cdecl strcmp(const char *, const char *);
char * __cdecl strcat(char *, const char *);
char * __cdecl strcpy(char *, const char *);
int __cdecl strncmp( const char *, const char *, size_t );
char * __cdecl strncpy( char *, const char *, size_t );
char *  __cdecl _strset(char *, int);
size_t    __cdecl wcslen(const wchar_t *);
int       __cdecl wcscmp(const wchar_t *, const wchar_t *);
wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
int __cdecl wcsncmp( const wchar_t *, const wchar_t *, size_t );
wchar_t * __cdecl wcsncpy( wchar_t *, const wchar_t *, size_t );
wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);


#if !defined(_CMNINTRIN_DECLARE_ONLY)
#pragma intrinsic (memcmp, memcpy, memset, memchr)
#pragma intrinsic (strlen, strcmp, strcat, strcpy, strncmp, strncpy, _strset)
#pragma intrinsic (wcslen, wcscmp, wcscat, wcscpy, wcsncmp, wcsncpy, _wcsset)
#endif


// start level of support description

// the intrinsic is defined and recognized but does nothing
#define _INTRINSIC_UNSUPPORTED      0
// instantiated with a call to the CRT
#define _INTRINSIC_HELPER           1
// may be one or more lines
#define _INTRINSIC_INLINE           2

//OS was not used to instantiate the intrinsic.
#define _INTRINSIC_SYSTEM_SAFE      4
//OS was used to instantiate the intrinsic.
#define _INTRINSIC_SYSTEM_UNSAFE    8


#define _INTRINSIC_IS_SUPPORTED(arg) ((_INTRINSIC_ ## arg) != 0)
#define _INTRINSIC_IS_SAFE(arg)      (((_INTRINSIC_ ## arg) & _INTRINSIC_SYSTEM_SAFE) != 0)
#define _INTRINSIC_IS_UNSAFE(arg)    (((_INTRINSIC_ ## arg) & _INTRINSIC_SYSTEM_UNSAFE) != 0)
#define _INTRINSIC_IS_HELPER(arg)    (((_INTRINSIC_ ## arg) & _INTRINSIC_HELPER) != 0)
#define _INTRINSIC_IS_INLINE(arg)    (((_INTRINSIC_ ## arg) & _INTRINSIC_INLINE) != 0)

//each chip should have it's own defines

// common intrinsic function support for SH-4
#if defined(_M_SH)

//general floating point
#define _INTRINSIC_ceil                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_ceilf                _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_floor                _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_floorf               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_fmod                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_fmodf                _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_fabs                 _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_fabsf                _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_sqrt                 _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_sqrtf                _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE

//transcendental floating point
#define _INTRINSIC_acos                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_asin                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_atan                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_atan2                _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_cos                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_cosh                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_exp                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_log                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_log10                _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_pow                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_sin                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_sinh                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_tan                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_tanh                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE

//general integer
#define _INTRINSIC_abs                  _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__abs64               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__byteswap_ushort     _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__byteswap_ulong      _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__byteswap_uint64     _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingOnes    _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingSigns   _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingZeros   _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingOnes64  _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingSigns64 _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingZeros64 _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountOneBits        _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountOneBits64      _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_labs                 _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__lrotl               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__lrotr               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__MulHigh             _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__MulUnsignedHigh     _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__rotl                _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__rotl64              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__rotr                _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__rotr64              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE

//floating point
#define _INTRINSIC__isnan               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__isnanf              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__isunordered         _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__isunorderedf        _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE

//string and block
#define _INTRINSIC_memchr               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_memcmp               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_memcpy               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_memset               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strcat               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strcmp               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strcpy               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strlen               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strncmp              _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strncpy              _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__strset              _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcscat               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcscmp               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcscpy               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcslen               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcsncmp              _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcsncpy              _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__wcsset              _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE

//system
#define _INTRINSIC___CacheRelease        _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC___CacheWriteback      _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC___ICacheRefresh       _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__debugbreak           _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC___ICacheRefresh       _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC___prefetch            _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__ReadWriteBarrier     _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__ReturnAddress        _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC___trap                _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_UNSAFE
#define _INTRINSIC__WriteBarrier         _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE

#endif // SH

#if defined (_M_ARM)

//general floating point
#define _INTRINSIC_ceil                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_fabs                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_floor                _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_fmod                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_sqrt                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE

//transcendental floating point
#define _INTRINSIC_acos                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_asin                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_atan                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_atan2                _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_cos                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_cosh                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_exp                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_log                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_log10                _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_pow                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_sin                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_sinh                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_tan                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_tanh                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE

//general integer
#define _INTRINSIC_abs                  _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__abs64               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__byteswap_ushort     _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__byteswap_ulong      _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__byteswap_uint64     _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingOnes    _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingSigns   _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingZeros   _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingOnes64  _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingSigns64 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingZeros64 _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountOneBits        _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountOneBits64      _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_labs                 _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__lrotl               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__lrotr               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__MulHigh             _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__MulUnsignedHigh     _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__rotl                _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__rotl64              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__rotr                _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__rotr64              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE

//floating point
#define _INTRINSIC__isnan               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__isnanf              _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__isunordered         _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__isunorderedf        _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE

//string and block
#define _INTRINSIC_memchr               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_memcmp               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_memcpy               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_memset               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strcat               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strcmp               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strcpy               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strlen               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strncmp              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strncpy              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__strset              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcscat               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcscmp               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcscpy               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcslen               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcsncmp              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcsncpy              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__wcsset              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE

//system
#define _INTRINSIC___CacheRelease       _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC___CacheWriteback     _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC___ICacheRefresh      _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC___ICacheRefresh      _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__ReadWriteBarrier    _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__WriteBarrier        _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE

#define _INTRINSIC__debugbreak          _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__ReturnAddress       _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC___trap               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_UNSAFE
#endif  // ARM

#if defined (_M_MRX000)  // MIPS

//general floating point
#define _INTRINSIC_ceil                 _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_fabs                 _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_floor                _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_fmod                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_sqrt                 _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE

//transcendental floating point
#define _INTRINSIC_acos                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_asin                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_atan                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_atan2                _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_cos                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_cosh                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_exp                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_log                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_log10                _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_pow                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_sin                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_sinh                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_tan                  _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_tanh                 _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE

//general integer
#define _INTRINSIC_abs                  _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__abs64               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__byteswap_ushort     _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__byteswap_ulong      _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__byteswap_uint64     _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingOnes    _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingSigns   _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingZeros   _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingOnes64  _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingSigns64 _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountLeadingZeros64 _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountOneBits        _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__CountOneBits64      _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_labs                 _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__lrotl               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__lrotr               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__MulHigh             _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__MulUnsignedHigh     _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__rotl                _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__rotl64              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__rotr                _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__rotr64              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE

//floating point
#define _INTRINSIC__isnan               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__isnanf              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__isunordered         _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__isunorderedf        _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE

//string and block
#define _INTRINSIC_memchr               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_memcmp               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_memcpy               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_memset               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strcat               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strcmp               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strcpy               _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strlen               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strncmp              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_strncpy              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__strset              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcscat               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcscmp               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcscpy               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcslen               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcsncmp              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC_wcsncpy              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__wcsset              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE

//system
#define _INTRINSIC__alloca              _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__abnormal_termination _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC___CacheRelease       _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC___CacheWriteback     _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC___ICacheRefresh      _INTRINSIC_UNSUPPORTED
#define _INTRINSIC__debugbreak          _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__exception_code      _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__exception_info      _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__InterlockedAdd      _INTRINSIC_UNSUPPORTED
#define _INTRINSIC__InterlockedExchange _INTRINSIC_HELPER|_INTRINSIC_SYSTEM_UNSAFE
#define _INTRINSIC___prefetch           _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__ReadWriteBarrier    _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC__ReturnAddress       _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE
#define _INTRINSIC___trap               _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_UNSAFE
#define _INTRINSIC__WriteBarrier        _INTRINSIC_INLINE|_INTRINSIC_SYSTEM_SAFE

#endif //MIPS

#if defined(__cplusplus)
}
#endif

#else  // _CMMN_INTRIN_FUNC

// compiler does not use common intrinsics

#define _INTRINSIC_IS_SUPPORTED(arg) (0)
#define _INTRINSIC_IS_SAFE(arg)      (0)
#define _INTRINSIC_IS_UNSAFE(arg)    (0)
#define _INTRINSIC_IS_HELPER(arg)    (0)
#define _INTRINSIC_IS_INLINE(arg)    (0)

#endif  // _CMMN_INTRIN_FUNC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cmnet.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _CmNet_h_
#define _CmNet_h_

#include <basetyps.h>
#include <winsock2.h>
#include <winnt.h>
#include <windns.h>
#include <ipexport.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
#define CM_CONST(name, value) \
        const DWORD name = DWORD(value)
#else
#define CM_CONST(name, value) \
        enum { name = value }
#endif

/*! \file CmNet.h */

//
// Connection selection data structures and APIs.
//

//! Version parameter for all structures.
//!
CM_CONST(CM_CURRENT_VERSION, 1);

//
// Connectivity data structures and APIs.
//

//! Captures all possible results in calls to CM client APIs.
//!
CM_CONST(CM_RESULT_BASE, 13000);

typedef enum CM_RESULT
{
    CMRE_SUCCESS = 0,

    CMRE_INVALID_REQUIREMENTS = CM_RESULT_BASE,
    CMRE_INVALID_PREFERENCES,
    CMRE_INVALID_SESSION,
    CMRE_INVALID_CONNECTION,
    CMRE_INVALID_CONNECTION_TYPE,
    CMRE_INVALID_PARAMETER,
    CMRE_INVALID_VERSION,
    CMRE_INCONSISTENT_CONFIGURATION,
    CMRE_INSUFFICIENT_BUFFER,
    CMRE_CONNECTION_ITERATION_NOT_STARTED,
    CMRE_NO_CONNECTIONS,
    CMRE_HOST_ADDRESS_ITERATION_NOT_STARTED,
    CMRE_NO_HOST_ADDRESSES,
    CMRE_CONNECTION_ACQUIRE_FAILED,
    CMRE_CONNECTION_ALREADY_ACQUIRED,
    CMRE_CONNECTION_NOT_ACQUIRED,
    CMRE_CONNECTION_RELEASE_FAILED,
    CMRE_CONNECTION_ALREADY_EXISTS,
    CMRE_CONNECTION_DOES_NOT_EXIST,
    CMRE_NOT_ALLOWED,
    CMRE_NO_NOTIFICATIONS,
    CMRE_NO_POLICIES,
    CMRE_OUT_OF_MEMORY,
    CMRE_PENDING,
    CMRE_ACCESS_DENIED,
    CMRE_NOT_SUPPORTED,
    CMRE_NOT_IMPLEMENTED,
    CMRE_UNEXPECTED,

    CMRE_LAST

} CM_RESULT;

//! Used by an application to set its connection requirements, preferences and
//! priority.
//!
DECLARE_HANDLE(CM_SESSION_HANDLE);

//! Attributes of a connection that can be used by an application to select
//! connections using requirements and preferences.
//!
typedef enum CM_CHARACTERISTIC
{
    CMCH_BANDWIDTH_KBITPS,          //! Network device bandwidth in Kbits/s.
    CMCH_SUPPORTS_WAKE_ON_INCOMING, //! Able to wake device on incoming traffic.
    CMCH_ROAMING,                   //! Registered on network other than home.
    
    CMCH_LAST

} CM_CHARACTERISTIC;

//! Used to compare connection characteristic against a required value.
//!
typedef enum CM_REQUIREMENT_OPERATOR
{
    CMRO_LESS_OR_EQUAL,
    CMRO_GREATER_OR_EQUAL,
    CMRO_EQUAL,
    CMRO_NOT_EQUAL,
    
    CMRO_LAST

} CM_REQUIREMENT_OPERATOR;

//! Describes connections that can be used by an application.
//! 
typedef struct CM_REQUIREMENTS
{
    DWORD Version;
    DWORD cRequirement;
    struct
    {
        CM_CHARACTERISTIC Characteristic;
        CM_REQUIREMENT_OPERATOR Operator;
        DWORD Value;

    } Requirement[1];

} CM_REQUIREMENTS;

FORCEINLINE DWORD CmGetRequirementsNeededSize(DWORD cRequirement)
{
    return (sizeof(CM_REQUIREMENTS) - offsetof(CM_REQUIREMENTS, Requirement))
            * cRequirement + offsetof(CM_REQUIREMENTS, Requirement);
}

//! Used to describe the preference order for connections.
//!
typedef enum CM_PREFERENCE_OPERATOR
{
    //! Unary.
    //!
    CMPO_LOWEST,
    CMPO_HIGHEST,

    //! Binary.
    //!
    CMPO_LESS_OR_EQUAL,
    CMPO_GREATER_OR_EQUAL,
    CMPO_EQUAL,
    CMPO_NOT_EQUAL,

    CMPO_LAST

} CM_PREFERENCE_OPERATOR;

//! Describe the order in which connections will be tried to connect an
//! application.
//!
typedef struct CM_PREFERENCES
{
    DWORD Version;
    DWORD cPreference;
    struct
    {
        CM_CHARACTERISTIC Characteristic;
        CM_PREFERENCE_OPERATOR Operator;
        DWORD Value; 

    } Preference[1];

} CM_PREFERENCES;

FORCEINLINE DWORD CmGetPreferencesNeededSize(DWORD cPreference)
{
    return (sizeof(CM_PREFERENCES) - offsetof(CM_PREFERENCES, cPreference))
            * cPreference + offsetof(CM_PREFERENCES, cPreference);
}

//! Describes priority of obtaining a suitable connection for an application
//! between its multiple requests used simultaneously.
//!
typedef int CM_PRIORITY;
//!
//! The priority is subdivided into user interactive and background.  The user
//! interactive priority range is intended to be used for cases where a
//! connection is acquired as a result of explicit request from user.  The
//! background priority is intended for acquiring connections
//! for background tasks.

//! User interactive priority ranges from 0 (lowest) to 2^31-1 (highest).
//! By default, connections are acquired with priority 0.
//!
CM_CONST(CM_PRIORITY_USER_INTERACTIVE_LOWEST, 0);
CM_CONST(CM_PRIORITY_USER_INTERACTIVE_HIGHEST, 0x7FFFFFFF);

//! User background priority starts from -1 (highest) to -2^31 (lowest).
//!
CM_CONST(CM_PRIORITY_BACKGROUND_LOWEST, 0x80000000);
CM_CONST(CM_PRIORITY_BACKGROUND_HIGHEST, -1);

//! Identifies an instance of a connection that can be used by an application;
//! application uses connection handle to acquire connection for its use, and
//! other operations.
//!
DECLARE_HANDLE(CM_CONNECTION_HANDLE);

//! A pair of addresses: the source address, and the destination address.  The
//! source address specifies the address to which a socket needs to be bound in
//! order to reach the destination.
//!
typedef struct CM_ADDRESS_PAIR
{
    DWORD Version;
    SOCKADDR_STORAGE Src;
    SOCKADDR_STORAGE Dst;

} CM_ADDRESS_PAIR;

//! Defines option to select modifiers used in connection selection.
//!
typedef enum CM_CONNECTION_SELECTION_OPTION
{
    //! Default connection selection algorithm.
    //!
    CMSO_DEFAULT = 0,

    CMSO_LAST

} CM_CONNECTION_SELECTION_OPTION;

//! Creates CM session for the purpose of selecting and acquiring a connection
//! for use.
//!
CM_SESSION_HANDLE CmCreateSession();

//! Closes the CM session.  Note that for applications that use Winsock
//! and WinInet, an existing session is closed implicitly as a result of
//! closing SOCKET or releasing HINTERNET handle, respectively.
//! However, if an application gets CM session associated with SOCKET or
//! HINTERNET handle, it must close it explicitly.
//!
//! Returns:
//! CMRE_SUCCESS on success.
//! CMRE_INVALID_SESSION if passed in session is not valid.
//!
CM_RESULT CmCloseSession(CM_SESSION_HANDLE hSession);

//! Associates connection requirements with a session that will be used to
//! select a connection for an application.
//!
//! Returns:
//! CMRE_SUCCESS on success.
//! CMRE_INVALID_SESSION if passed in session is not valid.
//! CMRE_OUT_OF_MEMORY if memory could not be allocated to complete operation.
//! CMRE_INVALID_VERSION if passed in version is not supported.
//!
CM_RESULT CmSetRequirements(
    __in CM_SESSION_HANDLE hSession,
    __in_bcount(cbRequirements) const CM_REQUIREMENTS* pRequirements,
    __in DWORD cbRequirements);

//! Associates connection preferences with a session that will be used to
//! influence the order in which connections are tried.
//!
//! Returns:
//! CMRE_SUCCESS on success.
//! CMRE_INVALID_SESSION if passed in session is not valid.
//! CMRE_OUT_OF_MEMORY if memory could not be allocated to complete operation.
//! CMRE_INVALID_VERSION if passed in version is not supported.
//!
CM_RESULT CmSetPreferences(
    __in CM_SESSION_HANDLE hSession,
    __in_bcount(cbPreferences) const CM_PREFERENCES* pPreferences,
    __in DWORD cbPreferences);

//! Associates a priority with a session.
//!
//! Returns:
//! CMRE_SUCCESS on success.
//! CMRE_INVALID_SESSION if passed in session is not valid.
//!
CM_RESULT CmSetPriority(
    __in CM_SESSION_HANDLE hSession,
    __in CM_PRIORITY Priority);

//! Gets the first candidate connection that can be used by an application to
//! try to connect to the wanted destination host.  Note that selected Winsock
//! and WinInet APIs can automatically connect SOCKET or HINTERNET handle to the
//! requested destination host.
//!
//! Returns:
//! CMRE_SUCCESS on success.
//! CMRE_INVALID_SESSION if passed in session is not valid.
//! CMRE_INVALID_PARAMETER if passed in parameter, other than session, is not 
//!   valid.
//! CMRE_OUT_OF_MEMORY if memory could not be allocated to complete operation.
//! CMRE_NO_CONNECTIONS if list of candidate connections is empty, that is,
//!   no connections are configured, meet requirements and/or policy of the
//!   caller.
//! CMRE_UNEXPECTED if unexpected failure occurred.
//!
CM_RESULT CmGetFirstCandidateConnection(
    __in CM_SESSION_HANDLE hSession,
    __in const WCHAR* pszHost,
    __in CM_CONNECTION_SELECTION_OPTION Option,
    __out CM_CONNECTION_HANDLE* phConnection);

//! Gets the next candidate connection.
//!
//! Returns:
//! CMRE_SUCCESS on success.
//! CMRE_INVALID_SESSION if passed in session is not valid.
//! CMRE_INVALID_PARAMETER if passed in parameter, other than session, is not 
//!   valid.
//! CMRE_CONNECTION_ITERATION_NOT_STARTED if connection iteration has not
//!   been started with CmGetFirstCandidateConnection.
//! CMRE_NO_CONNECTIONS if list of candidate connections has been exhausted.
//! 
CM_RESULT CmGetNextCandidateConnection(
    __in CM_SESSION_HANDLE hSession,
    __out CM_CONNECTION_HANDLE* phConnection);

//! Acquires connection for use.  Only one connection can be acquired in
//! context of a single session.  Note that selected Winsock and WinInet APIs
//! will automatically acquire connection as needed.
//!
//! Returns:
//! CMRE_SUCCESS on success.
//! CMRE_INVALID_CONNECTION if passed in connection is not valid.
//! CMRE_CONNECTION_ALREADY_ACQUIRED if this or any other connection has been
//!   already acquired in the context of this session.
//! CMRE_ACCESS_DENIED if caller doesn't have sufficient permissions to acquire
//!   connection.
//! CMRE_UNEXPECTED if unexpected failure occurred.
//!
CM_RESULT CmAcquireConnection(
    __in CM_CONNECTION_HANDLE hConnection);

//! Releases connection that was previously acquired and is no longer needed.
//!
//! Returns:
//! CMRE_SUCCESS on success.
//! CMRE_INVALID_CONNECTION if passed in connection is not valid.
//! CMRE_UNEXPECTED if unexpected failure occurred.
//!
CM_RESULT CmReleaseConnection(
    __in CM_CONNECTION_HANDLE hConnection);

//! Gets the first address associated with the wanted destination host.
//!
//! Returns:
//! CMRE_SUCCESS on success.
//! CMRE_INVALID_CONNECTION if passed in connection is not valid.
//! CMRE_CONNECTION_NOT_ACQUIRED if passed in connection is not acquired.
//! CMRE_NO_HOST_ADDRESSES if list of addresses is empty, that is, the passed in
//!   host name could not be resolved using the connection.
//! CMRE_INSUFFICIENT_BUFFER if pAddressPair is too small to hold the address
//!   pair.  Required size is returned in pcbAddressPair.
//! CMRE_NOT_SUPPORTED if passed in address family is not supported.
//! CMRE_OUT_OF_MEMORY if memory could not be allocated to complete operation.
//! CMRE_INVALID_VERSION if passed in version of address pair is not supported.
//! CMRE_UNEXPECTED if unexpected failure occurred.
//!
CM_RESULT CmGetFirstIpAddr(
    __in CM_CONNECTION_HANDLE hConnection,
    __in const WCHAR* pszHost,
    __in ADDRESS_FAMILY AddrFamily,
    __in USHORT SrcPort,
    __in USHORT DstPort,
    __inout_bcount(*pcbAddressPair) CM_ADDRESS_PAIR* pAddressPair,
    __inout DWORD* pcbAddressPair);

//! Gets next address associated with the wanted destination host.
//!
//! Returns:
//! CMRE_SUCCESS on success.
//! CMRE_INVALID_CONNECTION if passed in connection is not valid.
//! CMRE_HOST_ADDRESS_ITERATION_NOT_STARTED if host address iteration has not
//!   been started with CmGetFirstIpAddr.
//! CMRE_NO_HOST_ADDRESSES if list of addresses has been exhausted.
//! CMRE_INSUFFICIENT_BUFFER if pAddressPair is too small to hold the address
//!   pair.  Required size is returned in pcbAddressPair.
//! CMRE_INVALID_VERSION if passed in version of address pair is not supported.
//! CMRE_UNEXPECTED if unexpected failure occurred.
//!
CM_RESULT CmGetNextIpAddr(
    __in CM_CONNECTION_HANDLE hConnection,
    __inout_bcount(*pcbAddressPair) CM_ADDRESS_PAIR* pAddressPair,
    __inout DWORD* pcbAddressPair);

//! Gets the best CM result from the last connection selection. This API is
//! designed to be used by applications that depend on Winsock or WinInet for
//! connection selection, but need visibility into the CM result encountered by
//! those APIs during connection selection.  This API should be called only once
//! the Winsock or WinInet API returns.
//!
//! Returns:
//! CMRE_SUCCESS if at least one connection during the last connection iteration
//!   was successfully acquired and at least one IP address pair was found for
//!   for the required destination host.
//! Any other result indicates the best result in an attempt to acquire
//!   connection and find IP address pair.
//!
CM_RESULT CmGetConnectionSelectionResult(
    __in CM_SESSION_HANDLE hSession);

//
// Connection configuration data structures and APIs.
//

CM_CONST(CM_CONNECTION_NAME_LENGTH, 64);
CM_CONST(CM_CONNECTION_DESCRIPTION_LENGTH, 128);

//! The type of a connection.
//!
typedef GUID CM_CONNECTION_TYPE;

DEFINE_GUID(CMCT_UNKNOWN,   0x72fc7dc, 0x1d93, 0x40d1, 0x9b, 0xb0, 0x21, 0x14, 0xd7, 0xd7, 0x34, 0x34); // {072FC7DC-1D93-40d1-9BB0-2114D7D73434}

//! The unknown value of a characteristic can be used when a precise value is
//! not available at the time of connection configuration.  The value may be
//! dynamically updated by Connection Manager.
//!
CM_CONST(CM_UNKNOWN_CHARACTERISTIC_VALUE, 0xffffffff);

//! The connection configuration structure consists of two parts:  the
//! generic connection description and type specific connection information.
//!
typedef enum CM_TIME_BASED_AUTO_RECONNECT_ALGORITHM
{
    CMTR_NONE,
    CMTR_LINEAR,
    CMTR_EXPONENTIAL_RANDOMIZED_BACKOFF,

    CMTR_LAST

} CM_TIME_BASED_AUTO_RECONNECT_ALGORITHM;

//! Describes when connection is connected.
//!
typedef enum CM_CONNECTION_CONNECT_BEHAVIOR
{
    //! Default connect behavior, typically CMCB_ALWAYS_CONNECTED.
    //!
    CMCB_DEFAULT,

    //! Connection is connected whenever possible without need for outstanding
    //! request from application.
    //!
    CMCB_ALWAYS_CONNECTED,

    //! Connection is connected only on demand and disconnected if not being
    //! used.  Once an on demand connection is connected it can be shared by
    //! any other application permitted by security policy.
    //!
    CMCB_ON_DEMAND,

    //! Connection is CMCB_ALWAYS_CONNECTED when not roaming and CMCB_ON_DEMAND
    //! when roaming.
    //!
    CMCB_ON_DEMAND_WHEN_ROAMING,

    //! Connection requires policy to be connected and subsequently follows
    //! the same bahavior as CMCB_ON_DEMAND.
    //!
    CMCB_PER_POLICY,

    CMCB_LAST

} CM_CONNECTION_CONNECT_BEHAVIOR;

//! Describes configuration of every CM connection.
//!
typedef struct CM_CONNECTION_CONFIG
{
    DWORD Version;
    WCHAR szDescription[CM_CONNECTION_DESCRIPTION_LENGTH];
    CM_CONNECTION_TYPE Type;

    //! Initial values of characteristics.
    //!
    DWORD Characteristic[CMCH_LAST];

    CM_CONNECTION_CONNECT_BEHAVIOR ConnectBehavior;
    union
    {
        //! For CMCB_ON_DEMAND connections or other types that borrow from
        //! this model.
        //!
        DWORD IdleDisconnectTimeoutSec;

        //! For CMCB_ALWAYS_CONNECTED connections.
        //!
        struct
        {
            CM_TIME_BASED_AUTO_RECONNECT_ALGORITHM ReconnectAlg;
            DWORD DelaySec;
            DWORD Attempts;
            DWORD AttemptsExceededDelaySec;

        } AutoReconnect;
    };

    //! Connections will be connected only when enabled, otherwise it will
    //! remain disconnected.
    //!
    BOOL fEnabled;

    //! Connection type specific.
    //!
    DWORD cbTypeSpecificInfo;
    BYTE TypeSpecificInfo[1];

} CM_CONNECTION_CONFIG;

FORCEINLINE DWORD CmGetConnectionConfigNeededSize(DWORD cbTypeSpecificInfo)
{
    return offsetof(CM_CONNECTION_CONFIG, TypeSpecificInfo)
            + cbTypeSpecificInfo;
}

typedef enum CM_CONFIG_OPTION
{
    //! Causes the new configuration to be applied immediately, possibly
    //! affecting the state of the target (connection or policy).
    //!
    CMCO_IMMEDIATE_APPLY,

    //! Causes the new configuration to be applied opportunistically possibly
    //! avoiding affecting the state of the target if it is being used.
    //!
    CMCO_NON_IMMEDIATE_APPLY,

    CMCO_LAST

} CM_CONFIG_OPTION;

typedef struct CM_CONNECTION_NAME_LIST
{
    DWORD Version;
    DWORD cConnection;
    struct
    {
        WCHAR szName[CM_CONNECTION_NAME_LENGTH];

    } Connection[1];

} CM_CONNECTION_NAME_LIST;

DECLARE_HANDLE(CM_CONFIG_CHANGE_HANDLE);

//! Adds a new connection along with its settings.  The name of the connection
//! must be unique.
//!
//! Returns:
//! CMRE_INVALID_CONNECTION if name of connection is not valid.
//! CMRE_INVALID_PARAMETER if passed in parameter, other than connection, is not 
//!   valid.
//! CMRE_INVALID_CONNECTION_TYPE if type of connection is not handled by any of
//!   the loaded Connection Service Providers (CSPs).
//! CMRE_CONNECTION_ALREADY_EXISTS if connection of the same name already
//!   exists.
//! CMRE_OUT_OF_MEMORY if memory could not be allocated to complete operation.
//! CMRE_INVALID_VERSION if passed in version of connection configuration not
//!   supported.
//! CMRE_ACCESS_DENIED if caller doesn't have sufficient permissions to add
//!   connection configuration.
//! CMRE_UNEXPECTED if unexpected failure occurred.
//! 
CM_RESULT CmAddConnectionConfig(
    __in const WCHAR* pszConnection,
    __in_bcount(cbConfig) CM_CONNECTION_CONFIG* pConfig,
    __in DWORD cbConfig);

//! Retrieves settings associated with an earlier configured connection.
//!
//! Returns:
// TODO: Document other possible returned results.
//! CMRE_ACCESS_DENIED if caller doesn't have sufficient permissions to add
//!   connection configuration.
//! CMRE_UNEXPECTED if unexpected failure occurred.
//!
CM_RESULT CmGetConnectionConfig(
    __in const WCHAR* pszConnection,
    __inout_bcount(*pcbConfig) CM_CONNECTION_CONFIG* pConfig,
    __inout DWORD* pcbConfig);

//! Retrieves settings associated with an earlier configured connection
//! with the intention of updating them.  The returned change handle is
//! freed in the subsequent call to CmUpdateConnectionConfig.
//!
//! Returns:
// TODO: Document other possible returned results.
//! CMRE_ACCESS_DENIED if caller doesn't have sufficient permissions to get
//!   connection configuration.
//! CMRE_UNEXPECTED if unexpected failure occurred.
//!
CM_RESULT CmGetToUpdateConnectionConfig(
    __in const WCHAR* pszConnection,
    __inout_bcount(*pcbConfig) CM_CONNECTION_CONFIG* pConfig,
    __inout DWORD* pcbConfig,
    __out CM_CONFIG_CHANGE_HANDLE* phConfig);

//! Updates settings associated with an existing connection and frees the
//! change handle.
//!
//! Returns:
// TODO: Document other possible returned results.
//! CMRE_ACCESS_DENIED if caller doesn't have sufficient permissions to update
//!   connection configuration.
//! CMRE_UNEXPECTED if unexpected failure occurred.
//!
CM_RESULT CmUpdateConnectionConfig(
    __in CM_CONFIG_CHANGE_HANDLE hConfig,
    __in CM_CONFIG_OPTION Option,
    __in_bcount(cbConfig) CM_CONNECTION_CONFIG* pConfig,
    __in DWORD cbConfig);

//! Deletes the existing connection.
//!
//! Returns:
// TODO: Document other possible returned results.
//! CMRE_ACCESS_DENIED if caller doesn't have sufficient permissions to delete
//!   connection configuration.
//! CMRE_UNEXPECTED if unexpected failure occurred.
//!
CM_RESULT CmDeleteConnectionConfig(
    __in const WCHAR* pszConnection);

//! Enumerates all configured connections.
//!
CM_RESULT CmEnumConnectionsConfig(
    __inout_bcount(*pcbNameList) CM_CONNECTION_NAME_LIST* pNameList,
    __inout DWORD* pcbNameList);

//! Enumerates all configured connections by type.
//!
CM_RESULT CmEnumConnectionsConfigByType(
    __in CM_CONNECTION_TYPE Type,
    __inout_bcount(*pcbNameList) CM_CONNECTION_NAME_LIST* pNameList,
    __inout DWORD* pcbNameList);

//
// Policy configuration data structures and APIs.
//

//! Describes device type used by connection.
//!
typedef GUID CM_CONNECTION_DEVICE_TYPE;

//! Describes network type used by connection.
//!
typedef GUID CM_CONNECTION_NETWORK_TYPE;

typedef enum CM_CONNECTION_SELECTION_TYPE
{
    CMST_CONNECTION_ALL,            //! Any connection.
    CMST_CONNECTION_NAME,           //! Connection specified by name.
    CMST_CONNECTION_TYPE,           //! Any connection of given type.
    CMST_CONNECTION_DEVICE_TYPE,    //! Any connection of given device type.
    CMST_CONNECTION_NETWORK_TYPE,   //! Any connection of given network type.

    CMST_LAST

} CM_CONNECTION_SELECTION_TYPE;

typedef struct CM_CONNECTION_SELECTION
{
    //
    // Note: this structure doesn't have an explicit version field.  It is
    // always embedded in another structure that contains a version field.
    // 
    
    CM_CONNECTION_SELECTION_TYPE Selection;
    union
    {
        //! No need to specify param for CMST_CONNECTION_ALL.

        //! For CMST_CONNECTION_NAME.
        WCHAR szName[CM_CONNECTION_NAME_LENGTH];

        //! For CMST_CONNECTION_TYPE.
        CM_CONNECTION_TYPE Type;

        //! For CMST_CONNECTION_DEVICE_TYPE.
        CM_CONNECTION_DEVICE_TYPE DeviceType;

        //! For CMST_CONNECTION_NETWORK_TYPE.
        CM_CONNECTION_NETWORK_TYPE NetworkType;

    };

} CM_CONNECTION_SELECTION;

CM_CONST(CM_HOST_NAME_LENGTH, DNS_MAX_NAME_BUFFER_LENGTH);
CM_CONST(CM_ACCOUNT_NAME_LENGTH, 128); // Same as ADB_MAX_ACCOUNTNAME_SIZE in public\oak\inc\adb.h

typedef enum CM_POLICY_TYPE
{
    //! Used to define application and/or host to a connection or connection
    //! list mappings policy.
    //!
    CMPT_CONNECTION_MAPPINGS,

    CMPT_LAST

} CM_POLICY_TYPE;

typedef struct CM_POLICY_CONFIG_KEY
{
    DWORD Version;
    CM_POLICY_TYPE Type;
    union
    {
        //! For CMPT_CONNECTION_MAPPINGS.
        struct
        {
            //! Application is identified by the account under which it
            //! runs.  A wildcard "*" can be used to match all accounts.
            //!
            WCHAR szAccount[CM_ACCOUNT_NAME_LENGTH];

            //! Identifies host for which the mapping applies.  A host can 
            //! be specified by name or IP address in square brackets
            //! ("[...]").  A wildcard "*" may be used to match prefix segments
            //! or all of host name, e.g. "*.live.com", will match
            //! "www.live.com", "maps.live.com".  A slash "/" following an IP
            //! address prefix specifies its size in bits, and thereby the
            //! network, e.g. "[157.56.0.0/16]", "[2001:0db8:1234::/48]".
            //!
            WCHAR szHost[CM_HOST_NAME_LENGTH];
            
        } ConnectionMappings;
    };
} CM_POLICY_CONFIG_KEY;

typedef struct CM_POLICY_CONFIG_DATA
{
    DWORD Version;
    CM_POLICY_TYPE Type;
    union
    {
        //! For CMPT_CONNECTION_MAPPINGS.
        struct
        {
            //! Specifies if order in which connections are listed needs to
            //! be enforced.
            //!
            BOOL fUseConnectionsInOrder;

            //! Specifies number and connections in list.
            //!
            DWORD cConnection;
            CM_CONNECTION_SELECTION Connection[1];
            
        } ConnectionMappings;
    };
} CM_POLICY_CONFIG_DATA;

FORCEINLINE DWORD CmGetPolicyConnectionMappingsDataNeededSize(DWORD cConnection)
{
    return sizeof(CM_POLICY_CONFIG_DATA)
            + (cConnection > 0 ? cConnection - 1 : 0 )
            * sizeof(CM_CONNECTION_SELECTION);
}

//! Retrieves policy Data given Key.
//!
CM_RESULT CmGetPolicyConfig(
    __in_bcount(cbKey) CM_POLICY_CONFIG_KEY* pKey,
    __in DWORD cbKey,
    __out_bcount(*pcbData) CM_POLICY_CONFIG_DATA* pData,
    __inout DWORD* pcbData);

//! Retrieves policy Data with the intention of changing it with subsequent call
//! to CmUpdatePolicyconfig.
//!
CM_RESULT CmGetToUpdatePolicyConfig(
    __in_bcount(cbKey) CM_POLICY_CONFIG_KEY* pKey,
    __in DWORD cbKey,
    __out_bcount(*pcbData) CM_POLICY_CONFIG_DATA* pData,
    __inout DWORD* pcbData,
    __out CM_CONFIG_CHANGE_HANDLE* phConfig);

//! Updates policy Data.
//!
CM_RESULT CmUpdatePolicyConfig(
    __in CM_CONFIG_CHANGE_HANDLE hConfig,
    __in_bcount(cbData) CM_POLICY_CONFIG_DATA* pData,
    __in DWORD cbData);

//! Enumerate all policy keys containing non-default data.
//!
//! Returns:
//!
//! CMRE_SUCCESS on success.
//! CMRE_NO_POLICIES if no policy keys exist that have non-default data.
//! CMRE_INSUFFICIENT_BUFFER if size of pKeys, as described by pcbKeys,
//!   is too small to hold all policies.  Required size is returned
//!   in pcbKeys.
//! CMRE_INVALID_PARAMETER if any parameter is not valid.
//! CMRE_UNEXPECTED if unexpected failure occurs.
//!
CM_RESULT CmEnumPolicyConfig(
    __inout_bcount(*pcbKeys) CM_POLICY_CONFIG_KEY* pKeys,
    __inout DWORD* pcbKeys);

//
// Connection status data structures and APIs.
//

//! Common CM_CONNECTION_DEVICE_TYPE types.
//!
//! Note: CSP specific header files may define other device types not listed
//! here.
//!
DEFINE_GUID(CMCD_UNKNOWN,   0x71a26171, 0x11ee, 0x4acb, 0x80, 0xa2, 0x63, 0xa7, 0x72, 0x40, 0xc9, 0x71); // {71A26171-11EE-4ACB-80A2-63A77240C971}
DEFINE_GUID(CMCD_CELLULAR,  0xf9a53167, 0x4016, 0x4198, 0x9b, 0x41, 0x86, 0xd9, 0x52, 0x2d, 0xc0, 0x19); // {F9A53167-4016-4198-9B41-86D9522DC019}
DEFINE_GUID(CMCD_ETHERNET,  0x97844272, 0xc7, 0x4572, 0xb2, 0xa, 0xd8, 0xd8, 0x61, 0xc0, 0x95, 0xf2); // {97844272-00C7-4572-B20A-D8D861C095F2}
DEFINE_GUID(CMCD_BLUETOOTH, 0x1d793123, 0x701a, 0x4fd0, 0xb6, 0xae, 0x9c, 0x3c, 0x57, 0xe9, 0x9c, 0x2c); // {1D793123-701A-4fd0-B6AE-9C3C57E99C2C}
DEFINE_GUID(CMCD_VIRTUAL,   0xeaa02ce5, 0x9c70, 0x4e87, 0x97, 0xfe, 0x55, 0xc9, 0xde, 0xc8, 0x47, 0xd4); // {1D793123-701A-4fd0-B6AE-9C3C57E99C2C}
//!
//! Other device types should be defined by CSPs that expose them in their
//! respective public header files.

//
// TODO: Move the above defined device types (except unknown) into respective
// TODO: CSP header files.
//

//! Common CM_CONNECTION_NETWORK_TYPE types.
//!
//! Note: CSP specific header files may define other network types not listed
//! here.
//!
DEFINE_GUID(CMCN_UNKNOWN,             0x6a1ee122, 0x1bb7, 0x4a46, 0x8c, 0x17, 0x85, 0xfb, 0xca, 0xe5, 0xa6, 0x7a); // {6A1EE122-1BB7-4a46-8C17-85FBCAE5A67A}
DEFINE_GUID(CMCN_CELLULAR_UNKNOWN,    0x1c9031ab, 0xd7cf, 0x4781, 0xa8, 0x31, 0xc4, 0x5d, 0xa7, 0x45, 0xf4, 0xad); // {1C9031AB-D7CF-4781-A831-C45DA745F4AD}
DEFINE_GUID(CMCN_CELLULAR_CSD,        0x4e7c6c6c, 0x54fb, 0x4bb2, 0x92, 0x3b, 0x94, 0x7a, 0xfb, 0x19, 0x99, 0x2a); // {4E7C6C6C-54FB-4bb2-923B-947AFB19992A}
DEFINE_GUID(CMCN_CELLULAR_GPRS,       0xafb7d659, 0xfc1f, 0x4ea5, 0xbd, 0xd0, 0xf, 0xda, 0x62, 0x67, 0x6d, 0x96); // // {AFB7D659-FC1F-4ea5-BDD0-0FDA62676D96}
DEFINE_GUID(CMCN_CELLULAR_1XRTT /* CDMA2000 */, 0xb1e700ae, 0xa62f, 0x49ff, 0x9b, 0xbe, 0xb8, 0x80, 0xc9, 0x95, 0xf2, 0x7d); // {B1E700AE-A62F-49ff-9BBE-B880C995F27D}
DEFINE_GUID(CMCN_CELLULAR_EDGE /* E-GPRS */, 0xc347f8ec, 0x7095, 0x423d, 0xb8, 0x38, 0x7c, 0x7a, 0x7f, 0x38, 0xcd, 0x3); // {C347F8EC-7095-423d-B838-7C7A7F38CD03}
DEFINE_GUID(CMCN_CELLULAR_WCDMA_UMTS, 0xa72f04c6, 0x9be6, 0x4151, 0xb5, 0xef, 0x15, 0xa5, 0x3e, 0x12, 0xc4, 0x82); // {A72F04C6-9BE6-4151-B5EF-15A53E12C482}
DEFINE_GUID(CMCN_CELLULAR_WCDMA_FOMA, 0xb8326098, 0xf845, 0x42f3, 0x80, 0x4e, 0x8c, 0xc3, 0xff, 0x7b, 0x50, 0xb4); // {B8326098-F845-42f3-804E-8CC3FF7B50B4}
DEFINE_GUID(CMCN_CELLULAR_1XEVDO,     0xdd42df39, 0xebdf, 0x407c, 0x81, 0x46, 0x16, 0x85, 0x41, 0x64, 0x1, 0xb2); // {DD42DF39-EBDF-407c-8146-1685416401B2}
DEFINE_GUID(CMCN_CELLULAR_HSPA_HSDPA, 0x47f7282, 0xbabd, 0x4893, 0xaa, 0x77, 0xb8, 0xb3, 0x12, 0x65, 0x7f, 0x8c); // {047F7282-BABD-4893-AA77-B8B312657F8C}
DEFINE_GUID(CMCN_CELLULAR_HSPA_HSUPA, 0x1536a1c6, 0xa4af, 0x423c, 0x88, 0x84, 0x6b, 0xdd, 0xa3, 0x65, 0x6f, 0x84); // {1536A1C6-A4AF-423c-8884-6BDDA3656F84}
DEFINE_GUID(CMCN_CELLULAR_WIMAX,      0x67effec1, 0xd649, 0x49d2, 0x8f, 0x98, 0x6f, 0x5e, 0xfe, 0xb9, 0x4, 0x55); // {67EFFEC1-D649-49d2-8F98-6F5EFEB90455}

DEFINE_GUID(CMCN_ETHERNET_UNKNOWN,    0x275ec68c, 0x4588, 0x4a30, 0x86, 0x96, 0xff, 0x13, 0x8, 0x34, 0x94, 0x8e); // {275EC68C-4588-4a30-8696-FF130834948E}
DEFINE_GUID(CMCN_ETHERNET_10MBPS,     0x97d3d1b3, 0x854a, 0x4c32, 0xbd, 0x1c, 0xc1, 0x30, 0x69, 0x7, 0x83, 0x70); // {97D3D1B3-854A-4c32-BD1C-C13069078370}
DEFINE_GUID(CMCN_ETHERNET_100MBPS,    0xa8f4fe66, 0x8d04, 0x43f5, 0x9d, 0xd2, 0x2a, 0x85, 0xbd, 0x21, 0x2, 0x9b); // {A8F4FE66-8D04-43f5-9DD2-2A85BD21029B}
DEFINE_GUID(CMCN_ETHERNET_GBPS,       0x556c1e6b, 0xb8d4, 0x448e, 0x83, 0x6d, 0x94, 0x51, 0xba, 0x4c, 0xce, 0x75); // {556C1E6B-B8D4-448e-836D-9451BA4CCE75}

DEFINE_GUID(CMCN_BLUETOOTH_UNKNOWN,   0x73e4eaef, 0xfce1, 0x4a95, 0xa6, 0xce, 0xba, 0x5d, 0xa2, 0xb8, 0xbf, 0xe2); // {73E4EAEF-FCE1-4a95-A6CE-BA5DA2B8BFE2}

DEFINE_GUID(CMCN_VIRTUAL_UNKNOWN,     0x7be37a57, 0x9abe, 0x4cd3, 0xb0, 0xee, 0x32, 0x5c, 0x72, 0x4, 0xed, 0xec); // {7BE37A57-9ABE-4cd3-B0EE-325C7204EDEC}
DEFINE_GUID(CMCN_VIRTUAL_VPN_PPTP,    0x824442fb, 0x9d58, 0x41d3, 0xab, 0xc8, 0xce, 0x9a, 0x42, 0x77, 0x3b, 0x77); // {824442FB-9D58-41d3-ABC8-CE9A42773B77}
DEFINE_GUID(CMCN_VIRTUAL_VPN_L2TP,    0x3eb42af3, 0x14cd, 0x4c10, 0xb0, 0xed, 0x19, 0xc6, 0x45, 0x73, 0xf5, 0xa3); // {3EB42AF3-14CD-4c10-B0ED-19C64573F5A3}

//!
//! Other network types should be defined by CSPs that expose them in their
//! respective public header files.

//
// TODO: Move the above defined network types (except unknown) into respective
// TODO: CSP header files.
//

//! Defines possible states of a connection.
//!
typedef enum CM_CONNECTION_STATE
{
    CMCS_DISCONNECTED = 0,
      CMCS_DISCONNECTED_UNAVAILABLE,    //! Equipment not ready, out of range.
      CMCS_DISCONNECTED_DISABLED,       //! Connection disabled by configuration.

    CMCS_CONNECTING = 100,
      CMCS_CONNECTING_ASSOCIATING,
      CMCS_CONNECTING_AUTHENTICATING,
      CMCS_CONNECTING_WAITING_FOR_IP,

    CMCS_CONNECTED = 200,
    
    CMCS_SUSPENDED = 300,

    CMCS_DISCONNECTING = 400

} CM_CONNECTION_STATE;

//! Currently only used between CM client and CM service.
//!
typedef DWORD CM_CONNECTION_ID;

CM_CONST(CM_CONNECTION_ADAPTER_NAME_LENGTH, MAX_ADAPTER_NAME);

typedef struct CM_CONNECTION_DETAILS
{
    DWORD Version;
    WCHAR szName[CM_CONNECTION_NAME_LENGTH];
    WCHAR szDescription[CM_CONNECTION_DESCRIPTION_LENGTH];
    WCHAR szAdapter[CM_CONNECTION_ADAPTER_NAME_LENGTH];
    CM_CONNECTION_TYPE Type;
    CM_CONNECTION_DEVICE_TYPE Device;
    CM_CONNECTION_NETWORK_TYPE Network;
    CM_CONNECTION_STATE State;

    DWORD Characteristic[CMCH_LAST];

    DWORD cIpAddr;
    SOCKADDR_STORAGE IpAddr[1];

} CM_CONNECTION_DETAILS;

//! Retrieves real-time connection information, such as its state,
//! characteristics, etc. based on the connection handle retrieved from
//! CmGetFirstCandidateConnection and CmGetNextCandidateConnection.
//!
//! Returns:
//!
//! CMRE_SUCCESS on success.
//! CMRE_INSUFFICIENT_BUFFER if size of pDetails, as described by pcbDetails,
//!   is too small to hold the connection details.  Required size is returned
//!   in pcbDetails.
//! CMRE_INVALID_CONNECTION if passed in connection handle is not valid.
//! CMRE_INVALID_PARAMETER if any parameter other than hConnection is not valid.
//! CMRE_UNEXPECTED if unexpected failure occurs.
//!
CM_RESULT CmGetConnectionDetailsByHandle(
    __in CM_CONNECTION_HANDLE hConnection,
    __inout_bcount(*pcbDetails) CM_CONNECTION_DETAILS* pDetails,
    __inout DWORD* pcbDetails);

//! Retrieves real-time connection information, such as its state,
//! characteristics, etc. based on connection name retrieved from
//! CmEnumConnectionsConfig.
//!
//! Returns:
//!
//! CMRE_SUCCESS on success.
//! CMRE_INSUFFICIENT_BUFFER if size of pDetails, as described by pcbDetails,
//!   is too small to hold the connection details.  Required size is returned
//!   in pcbDetails.
//! CMRE_INVALID_CONNECTION if passed in connection name is not valid.
//! CMRE_INVALID_PARAMETER if any parameter other than hConnection is not valid.
//! CMRE_UNEXPECTED if unexpected failure occurs.
//!
CM_RESULT CmGetConnectionDetailsByName(
    __in const WCHAR* pszConnection,
    __inout_bcount(*pcbDetails) CM_CONNECTION_DETAILS* pDetails,
    __inout DWORD* pcbDetails);

//
// Notification data structures and APIs.
//

typedef enum CM_NOTIFICATION_TYPE
{
    CMNT_ALL = 0,

    //! Update of connection state.
    //!
    CMNT_CONNECTION_STATE = 100,
      CMNT_CONNECTION_STATE_CONNECTED,
      CMNT_CONNECTION_STATE_DISCONNECTED,

      CMNT_CONNECTION_STATE_LAST,

    //! Update of connection characteristic value.
    //!
    CMNT_CHARACTERISTIC_UPDATE = 200,

      CMNT_CHARACTERISTIC_UPDATE_LAST,

    //! Update to connection network type.
    //!
    CMNT_CONNECTION_NETWORK_TYPE = 300,

      CMNT_CONNECTION_NETWORK_TYPE_LAST,

    //! Update to connection type specific information.
    //!
    CMNT_CONNECTION_TYPE_SPECIFIC = 400,

      CMNT_CONNECTION_TYPE_SPECIFIC_LAST,

    //! Update to connection configuration.
    //!
    CMNT_CONNECTION_CONFIGURATION = 500,
      CMNT_CONNECTION_CONFIGURATION_ADDED,
      CMNT_CONNECTION_CONFIGURATION_UPDATED,
      CMNT_CONNECTION_CONFIGURATION_DELETED,

      CMNT_CONNECTION_CONFIGURATION_LAST,

    //! Change of system/connection state that implies availability of
    //! an existing or new connection.
    //!
    CMNT_SESSION_CONNECT_RETRY = 600,

      CMNT_SESSION_CONNECT_RETRY_LAST,

    //! Notifications describing progress in connecting a session.
    //! Note that clients registering for this notification should expect to
    //! receive both CM_NOTIFICATION::SelectionProgress and
    //! CM_NOTIFICATION::StateUpdate.
    //!
    CMNT_SESSION_CONNECTION_SELECTION_PROGRESS = 700,

      CMNT_SESSION_CONNECTION_SELECTION_PROGRESS_LAST,

    CMNT_LAST

} CM_NOTIFICATION_TYPE;

typedef enum CM_SESSION_CONNECT_RETRY_REASON
{
    CMRR_CONNECTION_CONNECTED,
    CMRR_CONNECTION_AVAILABLE_TO_CONNECT,
    
    CMRR_LAST

} CM_SESSION_CONNECT_RETRY_REASON;

typedef enum CM_SESSION_CONNECTION_SELECTION_PROGRESS_ACTION
{
    CMSA_ACQUIRE_BEGIN,
    CMSA_ACQUIRE_END,
    CMSA_RELEASE_BEGIN,
    CMSA_RELEASE_END,

    CMSA_LAST

} CM_SESSION_CONNECTION_SELECTION_PROGRESS_ACTION;

typedef struct CM_NOTIFICATIONS_LISTENER_REGISTRATION
{
    DWORD Version;

    //! Notifications event must be manual-reset event.  The event is signaled
    //! when the first notification arrives on the listener's notifications
    //! queue and will keep the event signaled until all notifications have
    //! been retrieved by the listener.
    //!
    HANDLE hNotificationsAvailableEvent;
    
    DWORD cRegistration;
    struct
    {
        CM_NOTIFICATION_TYPE NotificationType;
        union
        {
            //! For CMNT_SESSION_CONNECT_RETRY, 
            //! CMNT_SESSION_CONNECTION_SELECTION_PROGRESS.
            //!
            CM_SESSION_HANDLE hSession;

            //! For all others than above.
            //!
            CM_CONNECTION_SELECTION Connection;
        };

    } Registration[1];
    
} CM_NOTIFICATIONS_LISTENER_REGISTRATION;

FORCEINLINE DWORD CmGetNotificationsListenerRegistrationNeededSize(
    DWORD cRegistration)
{
    return (sizeof(CM_NOTIFICATIONS_LISTENER_REGISTRATION) -
            offsetof(CM_NOTIFICATIONS_LISTENER_REGISTRATION, cRegistration))
            * cRegistration + offsetof(CM_NOTIFICATIONS_LISTENER_REGISTRATION,
                    Registration);
}

typedef struct CM_NOTIFICATION
{
    DWORD Version;
    CM_NOTIFICATION_TYPE Type;
    union
    {
        //! For CMNT_CONNECTION_STATE_xxx,
        //! CMNT_SESSION_CONNECTION_SELECTION_PROGRESS.
        //!
        struct
        {
            WCHAR szConnection[CM_CONNECTION_NAME_LENGTH];
            CM_CONNECTION_STATE State;
            CM_RESULT LastResult;
            
        } StateUpdate;

        //! For CMNT_CHARACTERISTIC_UPDATE_xxx.
        //!
        struct
        {
            WCHAR szConnection[CM_CONNECTION_NAME_LENGTH];
            CM_CHARACTERISTIC Characteristic;
            DWORD Value;

        } CharacteristicUpdate;

        //! For CMT_CONNECTION_NETWORK_TYPE_xxx.
        //!
        struct
        {
            WCHAR szConnection[CM_CONNECTION_NAME_LENGTH];
            CM_CONNECTION_NETWORK_TYPE Network;

        } NetworkUpdate;
        
        //! For CMNT_CONNECTION_TYPE_SPECIFIC_xxx.
        //!
        struct
        {
            WCHAR szConnection[CM_CONNECTION_NAME_LENGTH];
            DWORD cbData;
            BYTE Data[1];

        } TypeSpecific;

        //! For CMNT_CONNECTION_CONFIGURATION_xxx.
        //!
        struct
        {
            WCHAR szConnection[CM_CONNECTION_NAME_LENGTH];

        } ConfigUpdate;

        //! For CMNT_SESSION_CONNECT_RETRY_xxx.
        //!
        struct
        {
            CM_SESSION_CONNECT_RETRY_REASON Reason;

        } Retry;

        //! For CMNT_SESSION_CONNECTION_SELECTION_PROGRESS_xxx.
        //!
        struct
        {
            CM_SESSION_CONNECTION_SELECTION_PROGRESS_ACTION Action;
            WCHAR szConnection[CM_CONNECTION_NAME_LENGTH];
            CM_RESULT Result;
            
        } SelectionProgress;
    };

} CM_NOTIFICATION;

//! Notifications listener handle. 
//!
DECLARE_HANDLE(CM_NOTIFICATIONS_LISTENER_HANDLE);

//! Registers notifications listener.
//!
//! Returns:
//! CMRE_SUCCESS on success.
//! CMRE_INVALID_PARAMETER if any parameter is not valid.
//! CMRE_OUT_OF_MEMORY if memory needed to register listener is not available.
//! CMRE_UNEXPECTED if unexpected failure occurred.
//!
CM_RESULT CmRegisterNotificationsListener(
    __in_bcount(cbRegistration) CM_NOTIFICATIONS_LISTENER_REGISTRATION* pRegistration,
    __in DWORD cbRegistration,
    __out CM_NOTIFICATIONS_LISTENER_HANDLE* phListener);

//! Unregisters notifications listener.
//!
//! Returns:
//! CMRE_SUCCESS on success.
//! CMRE_INVALID_PARAMETER if any parameter is not valid.
//! CMRE_UNEXPECTED if unexpected failure occurred.
//!
CM_RESULT CmUnregisterNotificationsListener(
    __in CM_NOTIFICATIONS_LISTENER_HANDLE hListener);

//! Retrieves next queued notification.
//!
//! Returns:
//! CMRE_SUCCESS on success.
//! CMRE_INSUFFICIENT_BUFFER if pNotification is too small to hold the
//!   notification.  Required size is returned in pcbNotification.
//! CMRE_NO_NOTIFICATIONS if there are no queued notifications.
//! CMRE_INVALID_PARAMETER if any parameter is not valid.
//! CMRE_UNEXPECTED if unexpected failure occurs.
//!
CM_RESULT CmGetNotification(
    __in CM_NOTIFICATIONS_LISTENER_HANDLE hListener,
    __inout_bcount_opt(*pcbNotification) CM_NOTIFICATION* pNotification,
    __inout DWORD* pcbNotification);

//
// CM extensions.
//

//! Retrieves the CM_SESSION_HANDLE associated with the specified SOCKET.
//!
//! Returns:
//! The CM_SESSION_HANDLE associated with the specified SOCKET.
//! One will be created if one did not already exist.
//! A NULL is returned on failure.
//!
CM_SESSION_HANDLE WSAGetCmSession(SOCKET s);

//
// Asset control related data structures and APIs.
//

typedef enum CM_ACCESS_TYPE_BIT_FLAG
{
    //! Right to acquire a non-roaming connection.
    CMAT_ACQUIRE_NON_ROAMING    = 0x00000001,

    //! Right to acquire a roaming connection.
    CMAT_ACQUIRE_ROAMING        = 0x00000002,

    //! Right to acquire connection regardless or roaming state.
    CMAT_ACQUIRE                = 0x00000003,

    //! Right to create a new connection.
    CMAT_CREATE                 = 0x00000004,

    //! Right to disconnect a connection.
    CMAT_DISCONNECT             = 0x00000008,

    //! Right to establish (connect) CM connection in a non-roaming state.
    CMAT_CONNECT_NON_ROAMING    = 0x00000010,

    //! Right to establish (connect) CM connection in a roaming state.
    CMAT_CONNECT_ROAMING        = 0x00000020,

    //! Right to establish (connect) CM connection regardless or roaming state.
    CMAT_CONNECT                = 0x00000030,

    //! Right to perform any operation on CM connection.
    CMAT_ALL                    = 0xC000003F

} CM_ACCESS_TYPE_BIT_FLAG;

DEFINE_GUID(CE_POLICY_RESOURCE_TYPE_CM_CONNECTION, 0xb482ff23, 0x2804, 0x4234, 0xbb, 0xe1, 0xef, 0xf1, 0x8a, 0xb6, 0x94, 0x8a); // {B482FF23-2804-4234-BBE1-0EF18AB6948A}

#undef CM_CONST

#ifdef __cplusplus
}
#endif

#endif // _CmNet_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\coguid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*****************************************************************************\
*                                                                             *
* coguid.h -    Master definition of GUIDs for compobj.dll                    *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*                                                                             *
\*****************************************************************************/

/* this file is the master definition of all GUIDs for the component object
   model and is included in compobj.h.  Some GUIDs for monikers and storage
   appear here as well.  All of these GUIDs are OLE GUIDs only in the sense
   that part of the GUID range owned by OLE was used to define them.

   NOTE: The second byte of all of these GUIDs is 0.
*/


DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);

/* RPC related interfaces */
DEFINE_OLEGUID(IID_IRpcChannel,         0x00000004L, 0, 0);
DEFINE_OLEGUID(IID_IRpcStub,            0x00000005L, 0, 0);
DEFINE_OLEGUID(IID_IStubManager,        0x00000006L, 0, 0);
DEFINE_OLEGUID(IID_IRpcProxy,           0x00000007L, 0, 0);
DEFINE_OLEGUID(IID_IProxyManager,       0x00000008L, 0, 0);
DEFINE_OLEGUID(IID_IPSFactory,          0x00000009L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);

/* moniker related interfaces */
DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);

/* concurrency related interfaces */
DEFINE_OLEGUID(IID_IMessageFilter,      0x00000016L, 0, 0);

/* CLSID of standard marshaler */
DEFINE_OLEGUID(CLSID_StdMarshal,        0x00000017L, 0, 0);

/* interface on server for getting info for std marshaler */
DEFINE_OLEGUID(IID_IStdMarshalInfo,     0x00000018L, 0, 0);

/* interface to inform object of number of external connections */
DEFINE_OLEGUID(IID_IExternalConnection, 0x00000019L, 0, 0);

/* NOTE: LSB 0x1a through 0xff are reserved for future use */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\comlite.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

/******************************Module*Header*******************************\
* Module Name: ComLite.h
*
* This header file is to provide a migration path for uses of ActiveMovie
* betas 1 and 2.
*
\**************************************************************************/


#ifndef _INC_COMLITE_
#define _INC_COMLITE_

#define QzInitialize            CoInitialize
#define QzUninitialize          CoUninitialize
#define QzFreeUnusedLibraries   CoFreeUnusedLibraries

#define QzGetMalloc             CoGetMalloc
#define QzTaskMemAlloc          CoTaskMemAlloc
#define QzTaskMemRealloc        CoTaskMemRealloc
#define QzTaskMemFree           CoTaskMemFree
#define QzCreateFilterObject    CoCreateInstance
#define QzCLSIDFromString       CLSIDFromString
#define QzStringFromGUID2       StringFromGUID2

#endif  // _INC_COMLITE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\comcat.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Fri Jan 26 18:31:15 2007
 */
/* Compiler settings for ..\comcat.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comcat_h__
#define __comcat_h__

/* Forward Declarations */ 

#ifndef __IEnumGUID_FWD_DEFINED__
#define __IEnumGUID_FWD_DEFINED__
typedef interface IEnumGUID IEnumGUID;
#endif 	/* __IEnumGUID_FWD_DEFINED__ */


#ifndef __IEnumCATEGORYINFO_FWD_DEFINED__
#define __IEnumCATEGORYINFO_FWD_DEFINED__
typedef interface IEnumCATEGORYINFO IEnumCATEGORYINFO;
#endif 	/* __IEnumCATEGORYINFO_FWD_DEFINED__ */


#ifndef __ICatRegister_FWD_DEFINED__
#define __ICatRegister_FWD_DEFINED__
typedef interface ICatRegister ICatRegister;
#endif 	/* __ICatRegister_FWD_DEFINED__ */


#ifndef __ICatInformation_FWD_DEFINED__
#define __ICatInformation_FWD_DEFINED__
typedef interface ICatInformation ICatInformation;
#endif 	/* __ICatInformation_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_comcat_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// ComCat.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//=--------------------------------------------------------------------------=
// OLE Componet Categories Interfaces.
//=--------------------------------------------------------------------------=
//
// suppress warning: parameter type mismatch
#pragma warning( disable : 4024 )
#pragma warning( disable : 4047 )


EXTERN_C const CLSID CLSID_StdComponentCategoriesMgr;

////////////////////////////////////////////////////////////////////////////
//  Types
typedef GUID CATID;

typedef REFGUID REFCATID;

#define IID_IEnumCLSID              IID_IEnumGUID
#define IEnumCLSID                  IEnumGUID
#define LPENUMCLSID                 LPENUMGUID
#define CATID_NULL                   GUID_NULL
#define IsEqualCATID(rcatid1, rcatid2)       IsEqualGUID(rcatid1, rcatid2)
#define IID_IEnumCATID       IID_IEnumGUID
#define IEnumCATID           IEnumGUID

////////////////////////////////////////////////////////////////////////////
//  Category IDs (link to uuid3.lib)
EXTERN_C const CATID CATID_Insertable;
EXTERN_C const CATID CATID_Control;
EXTERN_C const CATID CATID_Programmable;
EXTERN_C const CATID CATID_IsShortcut;
EXTERN_C const CATID CATID_NeverShowExt;
EXTERN_C const CATID CATID_DocObject;
EXTERN_C const CATID CATID_Printable;
EXTERN_C const CATID CATID_RequiresDataPathHost;
EXTERN_C const CATID CATID_PersistsToMoniker;
EXTERN_C const CATID CATID_PersistsToStorage;
EXTERN_C const CATID CATID_PersistsToStreamInit;
EXTERN_C const CATID CATID_PersistsToStream;
EXTERN_C const CATID CATID_PersistsToMemory;
EXTERN_C const CATID CATID_PersistsToFile;
EXTERN_C const CATID CATID_PersistsToPropertyBag;
EXTERN_C const CATID CATID_InternetAware;
EXTERN_C const CATID CATID_DesignTimeUIActivatableControl;

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPENUMGUID_DEFINED
#define _LPENUMGUID_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_v0_0_s_ifspec;

#ifndef __IEnumGUID_INTERFACE_DEFINED__
#define __IEnumGUID_INTERFACE_DEFINED__

/* interface IEnumGUID */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumGUID __RPC_FAR *LPENUMGUID;


EXTERN_C const IID IID_IEnumGUID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E000-0000-0000-C000-000000000046")
    IEnumGUID : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumGUIDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumGUID __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumGUID __RPC_FAR * This,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumGUIDVtbl;

    interface IEnumGUID
    {
        CONST_VTBL struct IEnumGUIDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumGUID_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumGUID_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumGUID_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumGUID_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumGUID_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumGUID_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumGUID_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumGUID_Next_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumGUID_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Skip_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumGUID_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Reset_Proxy( 
    IEnumGUID __RPC_FAR * This);


void __RPC_STUB IEnumGUID_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Clone_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumGUID_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumGUID_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_comcat_0007 */
/* [local] */ 

#endif
#ifndef _LPENUMCATEGORYINFO_DEFINED
#define _LPENUMCATEGORYINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0007_v0_0_s_ifspec;

#ifndef __IEnumCATEGORYINFO_INTERFACE_DEFINED__
#define __IEnumCATEGORYINFO_INTERFACE_DEFINED__

/* interface IEnumCATEGORYINFO */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumCATEGORYINFO __RPC_FAR *LPENUMCATEGORYINFO;

typedef struct tagCATEGORYINFO
    {
    CATID catid;
    LCID lcid;
    OLECHAR szDescription[ 128 ];
    }	CATEGORYINFO;

typedef struct tagCATEGORYINFO __RPC_FAR *LPCATEGORYINFO;


EXTERN_C const IID IID_IEnumCATEGORYINFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E011-0000-0000-C000-000000000046")
    IEnumCATEGORYINFO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCATEGORYINFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumCATEGORYINFOVtbl;

    interface IEnumCATEGORYINFO
    {
        CONST_VTBL struct IEnumCATEGORYINFOVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCATEGORYINFO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCATEGORYINFO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCATEGORYINFO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCATEGORYINFO_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumCATEGORYINFO_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCATEGORYINFO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCATEGORYINFO_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Next_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCATEGORYINFO_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Skip_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCATEGORYINFO_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Reset_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This);


void __RPC_STUB IEnumCATEGORYINFO_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Clone_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumCATEGORYINFO_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCATEGORYINFO_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_comcat_0008 */
/* [local] */ 

#endif
#ifndef _LPCATREGISTER_DEFINED
#define _LPCATREGISTER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0008_v0_0_s_ifspec;

#ifndef __ICatRegister_INTERFACE_DEFINED__
#define __ICatRegister_INTERFACE_DEFINED__

/* interface ICatRegister */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ICatRegister __RPC_FAR *LPCATREGISTER;


EXTERN_C const IID IID_ICatRegister;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E012-0000-0000-C000-000000000046")
    ICatRegister : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatRegisterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatRegister __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatRegister __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        END_INTERFACE
    } ICatRegisterVtbl;

    interface ICatRegister
    {
        CONST_VTBL struct ICatRegisterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatRegister_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatRegister_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatRegister_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatRegister_RegisterCategories(This,cCategories,rgCategoryInfo)	\
    (This)->lpVtbl -> RegisterCategories(This,cCategories,rgCategoryInfo)

#define ICatRegister_UnRegisterCategories(This,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterCategories(This,cCategories,rgcatid)

#define ICatRegister_RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatRegister_RegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);


void __RPC_STUB ICatRegister_RegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_RegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_RegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatRegister_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_comcat_0009 */
/* [local] */ 

#endif
#ifndef _LPCATINFORMATION_DEFINED
#define _LPCATINFORMATION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0009_v0_0_s_ifspec;

#ifndef __ICatInformation_INTERFACE_DEFINED__
#define __ICatInformation_INTERFACE_DEFINED__

/* interface ICatInformation */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ICatInformation __RPC_FAR *LPCATINFORMATION;


EXTERN_C const IID IID_ICatInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E013-0000-0000-C000-000000000046")
    ICatInformation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumCategories( 
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategoryDesc( 
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EnumClassesOfCategories( 
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ const CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ const CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE IsClassOfCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ const CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ const CATID __RPC_FAR rgcatidReq[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumImplCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumReqCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatInformation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatInformation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCategoryDesc )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumClassesOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ const CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ const CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClassOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ const CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ const CATID __RPC_FAR rgcatidReq[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumImplCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumReqCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
        END_INTERFACE
    } ICatInformationVtbl;

    interface ICatInformation
    {
        CONST_VTBL struct ICatInformationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatInformation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatInformation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatInformation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatInformation_EnumCategories(This,lcid,ppenumCategoryInfo)	\
    (This)->lpVtbl -> EnumCategories(This,lcid,ppenumCategoryInfo)

#define ICatInformation_GetCategoryDesc(This,rcatid,lcid,pszDesc)	\
    (This)->lpVtbl -> GetCategoryDesc(This,rcatid,lcid,pszDesc)

#define ICatInformation_EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)	\
    (This)->lpVtbl -> EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)

#define ICatInformation_IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)	\
    (This)->lpVtbl -> IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)

#define ICatInformation_EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)

#define ICatInformation_EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatInformation_EnumCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ LCID lcid,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);


void __RPC_STUB ICatInformation_EnumCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_GetCategoryDesc_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCATID rcatid,
    /* [in] */ LCID lcid,
    /* [out] */ LPWSTR __RPC_FAR *pszDesc);


void __RPC_STUB ICatInformation_GetCategoryDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_RemoteEnumClassesOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ const CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ const CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);


void __RPC_STUB ICatInformation_RemoteEnumClassesOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_RemoteIsClassOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ const CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ const CATID __RPC_FAR rgcatidReq[  ]);


void __RPC_STUB ICatInformation_RemoteIsClassOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_EnumImplCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumImplCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_EnumReqCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumReqCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatInformation_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_comcat_0010 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_comcat_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0010_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ const CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ const CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Stub( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ const CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ const CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);

/* [local] */ HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ const CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ const CATID __RPC_FAR rgcatidReq[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Stub( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ const CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ const CATID __RPC_FAR rgcatidReq[  ]);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\commdlg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/************************************************************************
*                                                                       *
*   commdlg.h -- This module defines the 32-Bit Common Dialog APIs      *
*                                                                       *
*                                                                       *
************************************************************************/
#ifndef _INC_COMMDLG
#define _INC_COMMDLG

#include <pshpack1.h>         /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#if(WINVER >= 0x0400)
#ifdef __cplusplus

#ifndef SNDMSG
#ifndef UNDER_CE
#define SNDMSG ::SendMessage
#else  // UNDER_CE
#define SNDMSG SendMessage
#endif // !UNDER_CE
#endif // !SNDMSG

#else   // __cplusplus

#ifndef SNDMSG
#define SNDMSG SendMessage
#endif

#endif // __cplusplus 
#endif // WINVER >= 0x0400 

// Fileopen Edit Control IDs 
#define edt1  0x0480
#define edt2  0x0481

typedef UINT (APIENTRY *LPOFNHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagOFNA {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCSTR       lpstrFilter;
   LPSTR        lpstrCustomFilter; // not supported
   DWORD        nMaxCustFilter;  // not supported
   DWORD        nFilterIndex;
   LPSTR        lpstrFile;
   DWORD        nMaxFile;
   LPSTR        lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCSTR       lpstrInitialDir;
   LPCSTR       lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCSTR       lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
} OPENFILENAMEA, *LPOPENFILENAMEA;
typedef struct tagOFNW {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCWSTR      lpstrFilter;
   LPWSTR       lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPWSTR       lpstrFile;
   DWORD        nMaxFile;
   LPWSTR       lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCWSTR      lpstrInitialDir;
   LPCWSTR      lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCWSTR      lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
} OPENFILENAMEW, *LPOPENFILENAMEW;
#ifdef UNICODE
typedef OPENFILENAMEW OPENFILENAME;
typedef LPOPENFILENAMEW LPOPENFILENAME;
#else
typedef OPENFILENAMEA OPENFILENAME;
typedef LPOPENFILENAMEA LPOPENFILENAME;
#endif // UNICODE


// @CESYSGEN IF COREDLL_FILEOPEN

BOOL  APIENTRY     GetOpenFileNameA(LPOPENFILENAMEA);
BOOL APIENTRY 	 GetOpenFileNameW ( LPOPENFILENAMEW );
BOOL  APIENTRY     GetSaveFileNameW(LPOPENFILENAMEW);
BOOL  APIENTRY     GetSaveFileNameA(LPOPENFILENAMEA);
#ifdef UNICODE
#define GetOpenFileName  GetOpenFileNameW
#define GetSaveFileName  GetSaveFileNameW
#else
#define GetSaveFileName  GetSaveFileNameA
#define GetOpenFileName  GetOpenFileNameA
#endif // !UNICODE

// @CESYSGEN ENDIF

#define OFN_READONLY		     0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000
#define OFN_NONETWORKBUTTON          0x00020000
#define OFN_NOLONGNAMES              0x00040000     // force no long names for 4.x modules
#if(WINVER >= 0x0400)
#define OFN_EXPLORER                 0x00080000
#define OFN_NODEREFERENCELINKS       0x00100000
#define OFN_LONGNAMES                0x00200000     // force long names for 3.x modules
#endif /* WINVER >= 0x0400 */
#define OFN_PROJECT                  0x00400000     // If this flag is set, the GetOpenFileName API will open the Project dialog for Windows Mobile
#define OFN_PROPERTY                 0x00800000     // If this flag is set, the GetSaveFileName API will open the Propery dialog for Windows Mobile
#define OFN_SHOW_ALL                 0x01000000     // If OFN_PROJECT is set,  show the <All Folders> item

// Return values for the registered message sent to the hook function
// when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
// filename to be accepted, OFN_SHARENOWARN rejects the name but puts
// up no warning (returned when the app has already put up a warning
// message), and OFN_SHAREWARN puts up the default warning message
// for sharing violations.
//
// Note:  Undefined return values map to OFN_SHAREWARN, but are
//        reserved for future use.

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

typedef UINT (APIENTRY *LPCCHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

#if(WINVER >= 0x0400)
// Structure used for all OpenFileName notifications
typedef struct _OFNOTIFYW
{
        NMHDR           hdr;
        LPOPENFILENAMEW lpOFN;
        LPWSTR          pszFile;        // May be NULL
} OFNOTIFYW, FAR *LPOFNOTIFYW;
typedef struct _OFNOTIFYA
{
        NMHDR           hdr;
        LPOPENFILENAMEA lpOFN;
        LPSTR           pszFile;        // May be NULL
} OFNOTIFYA, FAR *LPOFNOTIFYA;
#ifdef UNICODE
typedef OFNOTIFYW OFNOTIFY;
typedef LPOFNOTIFYW LPOFNOTIFY;
#else
typedef OFNOTIFYA OFNOTIFY;
typedef LPOFNOTIFYA LPOFNOTIFY;
#endif // UNICODE

#define CDN_FIRST   (0U-601U)
#define CDN_LAST    (0U-699U)

// Notifications when Open or Save dialog status changes
#define CDN_INITDONE            (CDN_FIRST - 0x0000)
#define CDN_SELCHANGE           (CDN_FIRST - 0x0001)
#define CDN_FOLDERCHANGE        (CDN_FIRST - 0x0002)
#define CDN_SHAREVIOLATION      (CDN_FIRST - 0x0003)
#define CDN_HELP                (CDN_FIRST - 0x0004)
#define CDN_FILEOK              (CDN_FIRST - 0x0005)
#define CDN_TYPECHANGE          (CDN_FIRST - 0x0006)

#define CDM_FIRST       (WM_USER + 100)
#define CDM_LAST        (WM_USER + 200)

// Messages to query information from the Open or Save dialogs

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETSPEC             (CDM_FIRST + 0x0000)
#define CommDlg_OpenSave_GetSpecA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETSPEC, (WPARAM)_cbmax, (LPARAM)(LPSTR)_psz)
#define CommDlg_OpenSave_GetSpecW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETSPEC, (WPARAM)_cbmax, (LPARAM)(LPWSTR)_psz)
#ifdef UNICODE
#define CommDlg_OpenSave_GetSpec  CommDlg_OpenSave_GetSpecW
#else
#define CommDlg_OpenSave_GetSpec  CommDlg_OpenSave_GetSpecA
#endif // !UNICODE

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETFILEPATH         (CDM_FIRST + 0x0001)
#define CommDlg_OpenSave_GetFilePathA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFILEPATH, (WPARAM)_cbmax, (LPARAM)(LPSTR)_psz)
#define CommDlg_OpenSave_GetFilePathW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFILEPATH, (WPARAM)_cbmax, (LPARAM)(LPWSTR)_psz)
#ifdef UNICODE
#define CommDlg_OpenSave_GetFilePath  CommDlg_OpenSave_GetFilePathW
#else
#define CommDlg_OpenSave_GetFilePath  CommDlg_OpenSave_GetFilePathA
#endif // !UNICODE

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETFOLDERPATH       (CDM_FIRST + 0x0002)
#define CommDlg_OpenSave_GetFolderPathA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERPATH, (WPARAM)_cbmax, (LPARAM)(LPSTR)_psz)
#define CommDlg_OpenSave_GetFolderPathW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERPATH, (WPARAM)_cbmax, (LPARAM)(LPWSTR)_psz)
#ifdef UNICODE
#define CommDlg_OpenSave_GetFolderPath  CommDlg_OpenSave_GetFolderPathW
#else
#define CommDlg_OpenSave_GetFolderPath  CommDlg_OpenSave_GetFolderPathA
#endif // !UNICODE

// lParam = pointer to ITEMIDLIST buffer that gets filled in
// wParam = size of the ITEMIDLIST buffer
// return = < 0 if error; length of buffer needed
#define CDM_GETFOLDERIDLIST     (CDM_FIRST + 0x0003)
#define CommDlg_OpenSave_GetFolderIDList(_hdlg, _pidl, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERIDLIST, (WPARAM)_cbmax, (LPARAM)(LPVOID)_pidl)

// lParam = pointer to a string
// wParam = ID of control to change
// return = not used
#define CDM_SETCONTROLTEXT      (CDM_FIRST + 0x0004)
#define CommDlg_OpenSave_SetControlText(_hdlg, _id, _text) \
        (void)SNDMSG(_hdlg, CDM_SETCONTROLTEXT, (WPARAM)_id, (LPARAM)(LPSTR)_text)

// lParam = not used
// wParam = ID of control to change
// return = not used
#define CDM_HIDECONTROL         (CDM_FIRST + 0x0005)
#define CommDlg_OpenSave_HideControl(_hdlg, _id) \
        (void)SNDMSG(_hdlg, CDM_HIDECONTROL, (WPARAM)_id, 0)

// lParam = pointer to default extension (no dot)
// wParam = not used
// return = not used
#define CDM_SETDEFEXT           (CDM_FIRST + 0x0006)
#define CommDlg_OpenSave_SetDefExt(_hdlg, _pszext) \
        (void)SNDMSG(_hdlg, CDM_SETDEFEXT, 0, (LPARAM)(LPSTR)_pszext)
#endif /* WINVER >= 0x0400 */

#ifdef WINCEOEM
#ifdef WINCEMACRO
#include <mcommdlg.h>
#endif
#endif

typedef UINT (APIENTRY *LPCCHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagCHOOSECOLOR  {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   COLORREF     rgbResult;
   COLORREF*    lpCustColors;
   DWORD        Flags;
   LPARAM       lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCTSTR      lpTemplateName;
} CHOOSECOLOR , *LPCHOOSECOLOR ;

BOOL  APIENTRY ChooseColor (LPCHOOSECOLOR );

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040
#if(WINVER >= 0x0400)
#define CC_SOLIDCOLOR            0x00000080
#define CC_ANYCOLOR              0x00000100
#endif /* WINVER >= 0x0400 */

// **************************************************
// PrintDlg is now obsolete
// It is included only for backwards compatability
// Use PageSetupDlg from now on
// **************************************************
typedef UINT (APIENTRY *LPPRINTHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
typedef struct tagPD  {
   DWORD            cbStruct;
   HWND             hwndOwner;
   HDC              hdc;
   DWORD            dwFlags;
   RECT             rcMinMargin;
   RECT             rcMargin;
   HINSTANCE        hinst;
   LPARAM           lCustData;
   LPPRINTHOOKPROC  pfnPrintHook;
   LPCTSTR          pszPrintTemplateName;
   HGLOBAL          hglbPrintTemplateResource;
} PRINTDLG , *LPPRINTDLG ;

BOOL  APIENTRY     PrintDlg (LPPRINTDLG);
// Out only
#define PD_SELECTALLPAGES                 0x00000001
#define PD_SELECTSELECTION                0x00000002
#define PD_SELECTDRAFTMODE                0x00000008
#define PD_SELECTA4                       0x00000010
#define PD_SELECTLETTER                   0x00000020
#define PD_SELECTINFRARED                 0x00000040 
#define PD_SELECTSERIAL                   0x00000080

// In only
#define PD_DISABLEPAPERSIZE               0x00000100
#define PD_DISABLEPRINTRANGE              0x00000200
#define PD_DISABLEMARGINS                 0x00000400
#define PD_DISABLEORIENTATION             0x00000800
#define PD_RETURNDEFAULTDC                0x00002000
#define PD_ENABLEPRINTHOOK                0x00004000
#define PD_ENABLEPRINTTEMPLATE            0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE      0x00010000
#define PD_TITLE						  0x00020000

// In-Out
#define PD_SELECTPORTRAIT                 0x00040000
#define PD_SELECTLANDSCAPE                0x00080000
#define PD_MARGINS                        0x00100000
#define PD_INTHOUSANDTHSOFINCHES          0x00200000
#define PD_INHUNDREDTHSOFMILLIMETERS      0x00400000
#define PD_MINMARGINS                     0x00800000

// New in for CE v2.10 and later: Out-only
#define PD_SELECTPARALLEL				  0x01000000
#define PD_SELECTNETWORK				  0x02000000
#define PD_SELECTLEGAL					  0x04000000
#define PD_SELECTB5						  0x08000000
#define PD_SELECTPRINTINCOLOR			  0x10000000

// **************************************************
// PrintDlg is now obsolete
// It is included only for backwards compatability
// Use PageSetupDlg from now on
// **************************************************

typedef struct tagDEVNAMES {
   WORD wDriverOffset;
   WORD wDeviceOffset;
   WORD wOutputOffset;
   WORD wDefault;
} DEVNAMES;

typedef DEVNAMES * LPDEVNAMES;

#define DN_DEFAULTPRN      0x0001

DWORD APIENTRY     CommDlgExtendedError(VOID);

typedef UINT (APIENTRY* LPPAGEPAINTHOOK)( HWND, UINT, WPARAM, LPARAM );
typedef UINT (APIENTRY* LPPAGESETUPHOOK)( HWND, UINT, WPARAM, LPARAM );

// only wide types supported in CE - include for synchronization with nt .h
typedef struct tagPSDA
{
    DWORD           lStructSize;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize;
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook;
    LPCSTR          lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
} PAGESETUPDLGA, * LPPAGESETUPDLGA;
typedef struct tagPSDW
{
    DWORD           lStructSize;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize; // ignored in CE
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook; // ignored in CE
    LPCWSTR         lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
} PAGESETUPDLGW, * LPPAGESETUPDLGW;
#ifdef UNICODE
typedef PAGESETUPDLGW PAGESETUPDLG;
typedef LPPAGESETUPDLGW LPPAGESETUPDLG;
#else
typedef PAGESETUPDLGA PAGESETUPDLG;
typedef LPPAGESETUPDLGA LPPAGESETUPDLG;
#endif // UNICODE

BOOL APIENTRY PageSetupDlgA( LPPAGESETUPDLGA );
BOOL APIENTRY PageSetupDlgW( LPPAGESETUPDLGW );
#ifdef UNICODE
#define PageSetupDlg  PageSetupDlgW
#else
#define PageSetupDlg  PageSetupDlgA
#endif // !UNICODE

typedef UINT (APIENTRY* LPPRINTERSPECIFICSETTINGSHOOK)( LPPAGESETUPDLG, HWND );

#define PSD_DEFAULTMINMARGINS             0x00000000 // default (printer's)
#define PSD_INWININIINTLMEASURE           0x00000000 // 1st of 4 possible

#define PSD_MINMARGINS                    0x00000001 // use caller's
#define PSD_MARGINS                       0x00000002 // use caller's
#define PSD_INTHOUSANDTHSOFINCHES         0x00000004 // 2nd of 4 possible
#define PSD_INHUNDREDTHSOFMILLIMETERS     0x00000008 // 3rd of 4 possible
#define PSD_DISABLEMARGINS                0x00000010
#define PSD_DISABLEPRINTER                0x00000020
// #define PSD_NOWARNING                  0x00000080 // not used in CE
#define PSD_DISABLEORIENTATION            0x00000100
#define PSD_DISABLEPAPER                  0x00000200
#define PSD_RETURNDEFAULT                 0x00000400
// #define PSD_SHOWHELP                   0x00000800 // not used in CE
#define PSD_ENABLEPAGESETUPHOOK           0x00002000
#define PSD_ENABLEPAGESETUPTEMPLATE       0x00008000
#define PSD_ENABLEPAGESETUPTEMPLATEHANDLE 0x00020000
// #define PSD_ENABLEPAGEPAINTHOOK        0x00040000 // not used in CE
// #define PSD_DISABLEPAGEPAINTING        0x00080000 // not used in CE
// #define PSD_NONETWORKBUTTON            0x00200000 // not used in CE

// new in Win CE - print range flags
#define PSD_DISABLEPRINTRANGE		      0x10000000
#define PSD_RANGESELECTION				  0x20000000

// Errors returned by CommDlgExtendedError()

#define CDERR_DIALOGFAILURE   0xFFFF

#define CDERR_GENERALCODES     0x0000
#define CDERR_STRUCTSIZE       0x0001
#define CDERR_INITIALIZATION   0x0002
#define CDERR_NOTEMPLATE       0x0003
#define CDERR_NOHINSTANCE      0x0004
#define CDERR_LOADSTRFAILURE   0x0005
#define CDERR_FINDRESFAILURE   0x0006
#define CDERR_LOADRESFAILURE   0x0007
#define CDERR_LOCKRESFAILURE   0x0008
#define CDERR_MEMALLOCFAILURE  0x0009
#define CDERR_MEMLOCKFAILURE   0x000A
#define CDERR_NOHOOK           0x000B
#define CDERR_REGISTERMSGFAIL  0x000C

#define PDERR_PRINTERCODES     0x1000
#define PDERR_SETUPFAILURE     0x1001
#define PDERR_PARSEFAILURE     0x1002
#define PDERR_RETDEFFAILURE    0x1003
#define PDERR_LOADDRVFAILURE   0x1004
#define PDERR_GETDEVMODEFAIL   0x1005
#define PDERR_INITFAILURE      0x1006
#define PDERR_NODEVICES        0x1007
#define PDERR_NODEFAULTPRN     0x1008
#define PDERR_DNDMMISMATCH     0x1009
#define PDERR_CREATEICFAILURE  0x100A
#define PDERR_PRINTERNOTFOUND  0x100B
#define PDERR_DEFAULTDIFFERENT 0x100C

// WinCE specific
#define CDERR_REGISTRYFAILURE  0x0100
#define PDERR_NOPORTS          PDERR_NODEVICES
#define PDERR_NOPRINTERS       PDERR_NODEFAULTPRN
#define PDERR_CREATEDCFAILURE  PDERR_CREATEICFAILURE


//
//	Font common dialog data
//
typedef UINT (APIENTRY *LPCFHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagCHOOSEFONTW {
   DWORD           lStructSize;
   HWND            hwndOwner;          // caller's window handle
   HDC             hDC;                // printer DC/IC or NULL
   LPLOGFONTW      lpLogFont;          // ptr. to a LOGFONT struct
   INT             iPointSize;         // 10 * size in points of selected font
   DWORD           Flags;              // enum. type flags
   COLORREF        rgbColors;          // returned text color
   LPARAM          lCustData;          // data passed to hook fn.
   LPCFHOOKPROC    lpfnHook;           // ptr. to hook function
   LPCWSTR         lpTemplateName;     // custom template name
   HINSTANCE       hInstance;          // instance handle of.EXE that
                                       //   contains cust. dlg. template
   LPWSTR          lpszStyle;          // return the style field here
                                       // must be LF_FACESIZE or bigger
   WORD            nFontType;          // same value reported to the EnumFonts
                                       //   call back with the extra FONTTYPE_
                                       //   bits added
   WORD            ___MISSING_ALIGNMENT__;
   INT             nSizeMin;           // minimum pt size allowed &
   INT             nSizeMax;           // max pt size allowed if
                                       //   CF_LIMITSIZE is used
} CHOOSEFONTW, *LPCHOOSEFONTW;

typedef CHOOSEFONTW CHOOSEFONT;
typedef LPCHOOSEFONTW LPCHOOSEFONT;

BOOL APIENTRY ChooseFontW(LPCHOOSEFONTW);
#define ChooseFont  ChooseFontW

#define CF_SCREENFONTS             0x00000001
#define CF_PRINTERFONTS            0x00000002
#define CF_BOTH                    (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP                0x00000004L
#define CF_ENABLEHOOK              0x00000008L
#define CF_ENABLETEMPLATE          0x00000010L
#define CF_ENABLETEMPLATEHANDLE    0x00000020L
#define CF_INITTOLOGFONTSTRUCT     0x00000040L
#define CF_USESTYLE                0x00000080L
#define CF_EFFECTS                 0x00000100L
#define CF_APPLY                   0x00000200L
#define CF_ANSIONLY                0x00000400L
#define CF_SCRIPTSONLY             CF_ANSIONLY
#define CF_NOVECTORFONTS           0x00000800L
#define CF_NOOEMFONTS              CF_NOVECTORFONTS
#define CF_NOSIMULATIONS           0x00001000L
#define CF_LIMITSIZE               0x00002000L
#define CF_FIXEDPITCHONLY          0x00004000L
#define CF_WYSIWYG                 0x00008000L // must also have CF_SCREENFONTS & CF_PRINTERFONTS
#define CF_FORCEFONTEXIST          0x00010000L
#define CF_SCALABLEONLY            0x00020000L
#define CF_TTONLY                  0x00040000L
#define CF_NOFACESEL               0x00080000L
#define CF_NOSTYLESEL              0x00100000L
#define CF_NOSIZESEL               0x00200000L
#define CF_SELECTSCRIPT            0x00400000L
#define CF_NOSCRIPTSEL             0x00800000L
#define CF_NOVERTFONTS             0x01000000L

// these are extra nFontType bits that are added to what is returned to the
// EnumFonts callback routine

#define SIMULATED_FONTTYPE    0x8000
#define PRINTER_FONTTYPE      0x4000
#define SCREEN_FONTTYPE       0x2000
#define BOLD_FONTTYPE         0x0100
#define ITALIC_FONTTYPE       0x0200
#define REGULAR_FONTTYPE      0x0400

#define WM_CHOOSEFONT_GETLOGFONT      (WM_USER + 1)

#define CDERR_LOADSTRFAILURE   0x0005

#define CFERR_CHOOSEFONTCODES  0x2000
#define CFERR_NOFONTS          0x2001
#define CFERR_MAXLESSTHANMIN   0x2002

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include <poppack.h>
#endif  /* !_INC_COMMDLG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\commctrl.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*****************************************************************************\
*                                                                             *
* commctrl.h - - Interface for the Windows Common Controls                    *
*                                                                             *
* Version 1.2                                                                 *
*                                                                             *
*                                                                             *
\*****************************************************************************/

#pragma once

#ifndef _INC_COMMCTRL
#define _INC_COMMCTRL

// @CESYSGEN IF CE_MODULES_COMMCTRL

#ifndef _WIN32_IE
#define _WIN32_IE 0x0700
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;
#endif // _HRESULT_DEFINED

#ifndef NOUSER

#ifdef UNDER_CE
//versioning stuff from the desktop
#define COMCTL32_VERSION 0x020e

#define CCM_FIRST               0x2000      // Common control shared messages
#define CCM_LAST                (CCM_FIRST + 0x200)

#define CCM_SETBKCOLOR          (CCM_FIRST + 0x1) // lParam is bkColor
#define CCM_SETVERSION          (CCM_FIRST + 0x7)
#define CCM_GETVERSION          (CCM_FIRST + 0x8)
#endif

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME          u
#define DUMMYUNIONNAME2         u2
#define DUMMYUNIONNAME3         u3
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#endif
#endif // DUMMYUNIONNAME

#ifndef UNDER_CE
#ifdef _WIN32
#include <pshpack1.h>
#endif
#endif // !UNDER_CE

#ifdef __cplusplus
extern "C" {
#endif

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NOTOOLBAR    Customizable bitmap-button toolbar control.
//    NOUPDOWN     Up and Down arrow increment/decrement control.
//    NOSTATUSBAR  Status bar control.
//    NOMENUHELP   APIs to help manage menus, especially with a status bar.
//    NOTRACKBAR   Customizable column-width tracking control.
//    NODRAGLIST   APIs to make a listbox source and sink drag&drop actions.
//    NOPROGRESS   Progress gas gauge.
//    NOHOTKEY     HotKey control
//    NOHEADER     Header bar control.
//    NOIMAGEAPIS  ImageList apis.
//    NOLISTVIEW   ListView control.
//    NOTREEVIEW   TreeView control.
//    NOTABCONTROL Tab control.
//    NOANIMATE    Animate control.
//
//=============================================================================

#include <prsht.h>

#ifndef UNDER_CE
#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG
#else // UNDER_CE
#ifndef SNDMSG
#define SNDMSG SendMessage
#endif
#endif // !UNDER_CE

#ifdef UNDER_CE // Moved from pcommctr.h.
#define LVIS_ALL                0xFFFF
#endif //UNDER_CE

WINCOMMCTRLAPI void WINAPI InitCommonControls(void);

#if (_WIN32_IE >= 0x0300)
typedef struct tagINITCOMMONCONTROLSEX {
    DWORD dwSize;             // size of this structure
    DWORD dwICC;              // flags indicating which classes to be initialized
} INITCOMMONCONTROLSEX, *LPINITCOMMONCONTROLSEX;
#define ICC_LISTVIEW_CLASSES 0x00000001 // listview, header
#define ICC_TREEVIEW_CLASSES 0x00000002 // treeview, tooltips
#define ICC_BAR_CLASSES      0x00000004 // toolbar, statusbar, trackbar, tooltips
#define ICC_TAB_CLASSES      0x00000008 // tab, tooltips
#define ICC_UPDOWN_CLASS     0x00000010 // updown
#define ICC_PROGRESS_CLASS   0x00000020 // progress
#define ICC_ANIMATE_CLASS    0x00000080 // animate
#define ICC_WIN95_CLASSES    0x0000007F // on WinCE Animate is not part of WIN95 classes
#define ICC_DATE_CLASSES     0x00000100 // month picker, date picker, time picker, updown
#define ICC_COOL_CLASSES     0x00000400 // rebar (coolbar) control
#if defined(WINCEOSVER) && WINCEOSVER >= 400
#if (_WIN32_IE >= 0x0400)
#define ICC_INTERNET_CLASSES 0x00000800 // IP Address control
#endif // (_WIN32_IE >= 0x0400)
#endif 
#define ICC_TOOLTIP_CLASSES  0x00001000 // Tooltip static & button
#define ICC_CAPEDIT_CLASS    0x00002000 // All-caps edit control
#define ICC_LINK_CLASS       0x00008000 // SysLink control
#define ICC_FE_CLASSES       0x40000000 // FE specific input subclasses
WINCOMMCTRLAPI BOOL WINAPI InitCommonControlsEx(LPINITCOMMONCONTROLSEX);
#endif      // _WIN32_IE >= 0x0300

#define ODT_HEADER              100
#define ODT_TAB                 101
#define ODT_LISTVIEW            102


//====== Ranges for control message IDs =======================================

#define LVM_FIRST               0x1000      // ListView messages
#define TV_FIRST                0x1100      // TreeView messages
#define HDM_FIRST               0x1200      // Header messages

#if (_WIN32_IE >= 0x0400)
// for tooltips
#define INFOTIPSIZE 1024
#endif

//====== WM_NOTIFY Macros =====================================================

#define HANDLE_WM_NOTIFY(hwnd, wParam, lParam, fn) \
    (fn)((hwnd), (int)(wParam), (NMHDR FAR*)(lParam))
#define FORWARD_WM_NOTIFY(hwnd, idFrom, pnmhdr, fn) \
    (LRESULT)(fn)((hwnd), WM_NOTIFY, (WPARAM)(int)(idFrom), (LPARAM)(NMHDR FAR*)(pnmhdr))


//====== Generic WM_NOTIFY notification codes =================================

#define NM_OUTOFMEMORY          (NM_FIRST-1)
#define NM_CLICK                (NM_FIRST-2)
#define NM_DBLCLK               (NM_FIRST-3)
#define NM_RETURN               (NM_FIRST-4)
#define NM_RCLICK               (NM_FIRST-5)
#define NM_RDBLCLK              (NM_FIRST-6)
#define NM_SETFOCUS             (NM_FIRST-7)
#define NM_KILLFOCUS            (NM_FIRST-8)
#if (_WIN32_IE >= 0x0300)
#define NM_CUSTOMDRAW           (NM_FIRST-12)
#define NM_HOVER                (NM_FIRST-13)
#endif
#if (_WIN32_IE >= 0x0400)
#define NM_NCHITTEST            (NM_FIRST-14)
#define NM_KEYDOWN              (NM_FIRST-15)
#endif

#define NM_CUSTOMTEXT           (NM_FIRST-24)   // uses NMCUSTOMTEXT struct

#if _WIN32_WINNT >= 0x0600
#define NM_FONTCHANGED          (NM_FIRST-23)
#define NM_TVSTATEIMAGECHANGING (NM_FIRST-24)   // uses NMTVSTATEIMAGECHANGING struct, defined after HTREEITEM
#endif

//
//@msg NM_RECOGNIZEGESTURE | To allow the application to decide if it wants
// automatic gesture recognition in common controls or not.
//
//@parm NMRGINFO * | nmrgi = (NMRGINFO*)lParam | Additional message info
//
//@rdesc Parent must return TRUE if it does not want gesture recognition.
// Otherwise, gesture will be recognized, animation will be shown and
// context menu messages (GN_CONTEXTMENU, WM_CONTEXTMENU) will be sent
// to parent.
//
//@comm
// nmrgi->ptAction will have X and Y client coordinates to aid the decision
// to have gesture recognition or not.
//
#define NM_RECOGNIZEGESTURE   (NM_FIRST-50)

#if (_WIN32_IE >= 0x0400)
//====== Generic WM_NOTIFY notification structures ============================

typedef struct tagNMMOUSE {
    NMHDR   hdr;
    DWORD   dwItemSpec;
    DWORD   dwItemData;
    POINT   pt;
} NMMOUSE, FAR* LPNMMOUSE;

typedef NMMOUSE NMCLICK;
typedef LPNMMOUSE LPNMCLICK;

// Generic structure for a key

typedef struct tagNMKEY
{
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} NMKEY, FAR *LPNMKEY;


typedef struct tagNMCUSTOMTEXT
{
    NMHDR hdr;
    HDC hDC;
    LPCWSTR lpString;
    int nCount;
    LPRECT lpRect;
    UINT uFormat;
    BOOL fLink;
} NMCUSTOMTEXT, *LPNMCUSTOMTEXT;


#endif           // _WIN32_IE >= 0x0400

//====== WM_NOTIFY codes (NMHDR.code values) ==================================

#define NM_FIRST                (0U-  0U)       // generic to all controls
#define NM_LAST                 (0U- 99U)

#define LVN_FIRST               (0U-100U)       // listview
#define LVN_LAST                (0U-199U)

#define HDN_FIRST               (0U-300U)       // header
#define HDN_LAST                (0U-399U)

#define TVN_FIRST               (0U-400U)       // treeview
#define TVN_LAST                (0U-499U)

#define TTN_FIRST               (0U-520U)       // tooltips
#define TTN_LAST                (0U-549U)

#define TCN_FIRST               (0U-550U)       // tab control
#define TCN_LAST                (0U-580U)

// Shell reserved               (0U-580U) -  (0U-589U)

#define CDN_FIRST               (0U-601U)       // common dialog (new)
#define CDN_LAST                (0U-699U)

#define TBN_FIRST               (0U-700U)       // toolbar
#define TBN_LAST                (0U-720U)

#define UDN_FIRST               (0U-721)        // updown
#define UDN_LAST                (0U-740)
#if (_WIN32_IE >= 0x0300)
#define MCN_FIRST               (0U-750U)       // monthcal
#define MCN_LAST                (0U-759U)

#define DTN_FIRST               (0U-760U)       // datetimepick
#define DTN_LAST                (0U-799U)

#define RBN_FIRST               (0U-831U)       // rebar
#define RBN_LAST                (0U-859U)
#endif

#if defined(WINCEOSVER) && WINCEOSVER >= 400
#if (_WIN32_IE >= 0x0400)
#define IPN_FIRST               (0U-860U)       // internet address
#define IPN_LAST                (0U-879U)       // internet address
#endif // (_WIN32_IE >= 0x0400)
#endif

#if (_WIN32_IE >= 0x0400)
#define SBN_FIRST               (0U-880U)        // status bar
#define SBN_LAST                (0U-900U)       
#endif

#define SHN_FIRST               (0U-1400U)       // Shell reserved
#define SHN_LAST                (0U-1500U)

#define MSGF_COMMCTRL_BEGINDRAG     0x4200
#define MSGF_COMMCTRL_SIZEHEADER    0x4201
#define MSGF_COMMCTRL_DRAGSELECT    0x4202

#if (_WIN32_IE >= 0x0300)
//==================== CUSTOM DRAW ==========================================


// custom draw return flags
// values under 0x00010000 are reserved for global custom draw values.
// above that are for specific controls
#define CDRF_DODEFAULT          0x00000000
#define CDRF_NEWFONT            0x00000002
#define CDRF_SKIPDEFAULT        0x00000004
//For TBSTYLE_DROPDOWN buttons, don't draw vertical separator bar
#define CDRF_NOVERTBAR          0x00000008


#define CDRF_NOTIFYPOSTPAINT    0x00000010
#define CDRF_NOTIFYITEMDRAW     0x00000020
#if (_WIN32_IE >= 0x0400)
#define CDRF_NOTIFYSUBITEMDRAW  0x00000020  // flags are the same, we can distinguish by context
#endif
#define CDRF_NOTIFYPOSTERASE    0x00000040



// drawstage flags
// values under 0x00010000 are reserved for global custom draw values.
// above that are for specific controls
#define CDDS_PREPAINT           0x00000001
#define CDDS_POSTPAINT          0x00000002
#define CDDS_PREERASE           0x00000003
#define CDDS_POSTERASE          0x00000004
// the 0x000010000 bit means it's individual item specific
#define CDDS_ITEM               0x00010000
#define CDDS_ITEMPREPAINT       (CDDS_ITEM | CDDS_PREPAINT)
#define CDDS_ITEMPOSTPAINT      (CDDS_ITEM | CDDS_POSTPAINT)
#define CDDS_ITEMPREERASE       (CDDS_ITEM | CDDS_PREERASE)
#define CDDS_ITEMPOSTERASE      (CDDS_ITEM | CDDS_POSTERASE)
#if (_WIN32_IE >= 0x0400)
#define CDDS_SUBITEM            0x00020000
#endif


// itemState flags
#define CDIS_SELECTED           0x0001
#define CDIS_GRAYED             0x0002
#define CDIS_DISABLED           0x0004
#define CDIS_CHECKED            0x0008
#define CDIS_FOCUS              0x0010
#define CDIS_DEFAULT            0x0020
#define CDIS_HOT                0x0040
#define CDIS_NOCONTROLFOCUS     0x8000

typedef struct tagNMCUSTOMDRAWINFO
{
    NMHDR hdr;
    DWORD dwDrawStage;
    HDC hdc;
    RECT rc;
    DWORD dwItemSpec;  // this is control specific, but it's how to specify an item.  valid only with CDDS_ITEM bit set
    UINT  uItemState;
    LPARAM lItemlParam;
} NMCUSTOMDRAW, FAR * LPNMCUSTOMDRAW;



// for tooltips

typedef struct tagNMTTCUSTOMDRAW
{
    NMCUSTOMDRAW nmcd;
    UINT uDrawFlags;
} NMTTCUSTOMDRAW, FAR * LPNMTTCUSTOMDRAW;

#endif      // _WIN32_IE >= 0x0300


//====== IMAGE APIS ===========================================================

#ifndef NOIMAGEAPIS

#define CLR_NONE                0xFFFFFFFFL
#define CLR_DEFAULT             0xFF000000L

struct _IMAGELIST;
typedef struct _IMAGELIST NEAR* HIMAGELIST;

#if (_WIN32_IE >= 0x0300)
typedef struct _IMAGELISTDRAWPARAMS {
    DWORD       cbSize;
    HIMAGELIST  himl;
    int         i;
    HDC         hdcDst;
    int         x;
    int         y;
    int         cx;
    int         cy;
    int         xBitmap;        // x offest from the upperleft of bitmap
    int         yBitmap;        // y offset from the upperleft of bitmap
    COLORREF    rgbBk;
    COLORREF    rgbFg;
    UINT        fStyle;
    DWORD       dwRop;
} IMAGELISTDRAWPARAMS, FAR * LPIMAGELISTDRAWPARAMS;
#endif      // _WIN32_IE >= 0x0300

#define ILC_MASK                0x0001
#define ILC_COLOR               0x0000
#define ILC_COLORDDB            0x00FE
#define ILC_COLOR4              0x0004
#define ILC_COLOR8              0x0008
#define ILC_COLOR16             0x0010
#define ILC_COLOR24             0x0018
#define ILC_COLOR32             0x0020
#define ILC_PALETTE             0x0800      // no longer supported
#define ILC_MIRROR		0x2000      

WINCOMMCTRLAPI HIMAGELIST  WINAPI ImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_Destroy(HIMAGELIST himl);
WINCOMMCTRLAPI int         WINAPI ImageList_GetImageCount(HIMAGELIST himl);
#if (_WIN32_IE >= 0x0300)
WINCOMMCTRLAPI BOOL        WINAPI ImageList_SetImageCount(HIMAGELIST himl, UINT uNewCount);
#endif
WINCOMMCTRLAPI int         WINAPI ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask);
WINCOMMCTRLAPI int         WINAPI ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon);
WINCOMMCTRLAPI COLORREF    WINAPI ImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk);
WINCOMMCTRLAPI COLORREF    WINAPI ImageList_GetBkColor(HIMAGELIST himl);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay);

#define     ImageList_AddIcon(himl, hicon) ImageList_ReplaceIcon(himl, -1, hicon)

#define ILD_NORMAL              0x0000
#define ILD_TRANSPARENT         0x0001
#define ILD_MASK                0x0010
#define ILD_IMAGE               0x0020
#if (_WIN32_IE >= 0x0300)
#define ILD_ROP                 0x0040
#endif
#define ILD_BLEND25             0x0002
#define ILD_BLEND50             0x0004
#define ILD_OVERLAYMASK         0x0F00
#define INDEXTOOVERLAYMASK(i)   ((i) << 8)

#define ILD_SELECTED            ILD_BLEND50
#define ILD_FOCUS               ILD_BLEND25
#define ILD_BLEND               ILD_BLEND50
#define CLR_HILIGHT             CLR_DEFAULT

WINCOMMCTRLAPI BOOL WINAPI ImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle);


#ifdef _WIN32

WINCOMMCTRLAPI BOOL        WINAPI ImageList_Replace(HIMAGELIST himl, int i, HBITMAP hbmImage, HBITMAP hbmMask);
WINCOMMCTRLAPI int         WINAPI ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle);
#if (_WIN32_IE >= 0x0300)
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DrawIndirect(__in IMAGELISTDRAWPARAMS* pimldp);
#endif
WINCOMMCTRLAPI BOOL        WINAPI ImageList_Remove(HIMAGELIST himl, int i);
WINCOMMCTRLAPI HICON       WINAPI ImageList_GetIcon(HIMAGELIST himl, int i, UINT flags);

#ifndef UNDER_CE // The W&A versions of this function did not exist in previous versions.
                 // WinCE only supports the Unicode version.
WINCOMMCTRLAPI HIMAGELIST  WINAPI ImageList_LoadImageA(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
WINCOMMCTRLAPI HIMAGELIST  WINAPI ImageList_LoadImageW(HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);

#ifdef UNICODE
#define ImageList_LoadImage     ImageList_LoadImageW
#else
#define ImageList_LoadImage     ImageList_LoadImageA
#endif

#else  // UNDER_CE
WINCOMMCTRLAPI HIMAGELIST  WINAPI ImageList_LoadImage(HINSTANCE hi, __in_opt LPCTSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
#endif // !UNDER_CE

#if (_WIN32_IE >= 0x0300)
#define ILCF_MOVE   (0x00000000)
#define ILCF_SWAP   (0x00000001)
WINCOMMCTRLAPI BOOL        WINAPI ImageList_Copy(HIMAGELIST himlDst, int iDst, HIMAGELIST himlSrc, int iSrc, UINT uFlags);
#endif

WINCOMMCTRLAPI BOOL        WINAPI ImageList_BeginDrag(HIMAGELIST himlTrack, int iTrack, int dxHotspot, int dyHotspot);
WINCOMMCTRLAPI void        WINAPI ImageList_EndDrag();
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DragEnter(HWND hwndLock, int x, int y);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DragLeave(HWND hwndLock);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DragMove(int x, int y);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_SetDragCursorImage(HIMAGELIST himlDrag, int iDrag, int dxHotspot, int dyHotspot);

WINCOMMCTRLAPI BOOL        WINAPI ImageList_DragShowNolock(BOOL fShow);
WINCOMMCTRLAPI HIMAGELIST  WINAPI ImageList_GetDragImage(__out_opt POINT FAR* ppt, __out_opt POINT FAR* pptHotspot);

#define     ImageList_RemoveAll(himl) ImageList_Remove(himl, -1)
#define     ImageList_ExtractIcon(hi, himl, i) ImageList_GetIcon(himl, i, 0)
#define     ImageList_LoadBitmap(hi, lpbmp, cx, cGrow, crMask) ImageList_LoadImage(hi, lpbmp, cx, cGrow, crMask, IMAGE_BITMAP, 0)

typedef struct _IMAGEINFO
{
    HBITMAP hbmImage;
    HBITMAP hbmMask;
    int     Unused1;
    int     Unused2;
    RECT    rcImage;
} IMAGEINFO, FAR *LPIMAGEINFO;

WINCOMMCTRLAPI BOOL        WINAPI ImageList_GetIconSize(HIMAGELIST himl, __out int FAR *cx, __out int FAR *cy);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_SetIconSize(HIMAGELIST himl, int cx, int cy);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_GetImageInfo(HIMAGELIST himl, int i, __out IMAGEINFO FAR* pImageInfo);
WINCOMMCTRLAPI HIMAGELIST  WINAPI ImageList_Merge(HIMAGELIST himl1, int i1, HIMAGELIST himl2, int i2, int dx, int dy);
#if (_WIN32_IE >= 0x0400)
WINCOMMCTRLAPI HIMAGELIST  WINAPI ImageList_Duplicate(HIMAGELIST himl);
#endif

#ifdef UNDER_CE // Retaining for backward compatibility because this was in 1.0
HBITMAP CreateColorBitmap(int cx, int cy);
HBITMAP CreateMonoBitmap(int cx, int cy);
void WINAPI ImageList_CopyDitherImage (HIMAGELIST himlDest, WORD iDst, int xDst, int yDst, HIMAGELIST himlSrc,
        int iSrc, UINT fStyle);
#endif // UNDER_CE

#endif

#endif


//====== HEADER CONTROL =======================================================

#ifndef NOHEADER

#ifdef _WIN32
#define WC_HEADERA              "SysHeader32"
#define WC_HEADERW              L"SysHeader32"

#ifdef UNICODE
#define WC_HEADER               WC_HEADERW
#else
#define WC_HEADER               WC_HEADERA
#endif

#else
#define WC_HEADER               "SysHeader"
#endif

// begin_r_commctrl                     

#define HDS_HORZ                0x0000
#define HDS_BUTTONS             0x0002
#define HDS_HIDDEN              0x0008


#if (_WIN32_IE >= 0x0300)
#define HDS_DRAGDROP            0x0040
#define HDS_FULLDRAG            0x0080
#endif

// end_r_commctrl

#if (_WIN32_IE >= 0x0300)
#define HD_ITEMA HDITEMA
#define HD_ITEMW HDITEMW
#else
#define HDITEMW  HD_ITEMW
#define HDITEMA  HD_ITEMA
#endif
#define HD_ITEM HDITEM

typedef struct _HD_ITEMA
{
    UINT    mask;
    int     cxy;
    LPSTR   pszText;
    HBITMAP hbm;
    int     cchTextMax;
    int     fmt;
    LPARAM  lParam;
#if (_WIN32_IE >= 0x0300)
    int     iImage;        // index of bitmap in ImageList
    int     iOrder;        // where to draw this item
#endif
} HDITEMA, FAR * LPHDITEMA;


typedef struct _HD_ITEMW
{
    UINT    mask;
    int     cxy;
    LPWSTR   pszText;
    HBITMAP hbm;
    int     cchTextMax;
    int     fmt;
    LPARAM  lParam;
#if (_WIN32_IE >= 0x0300)
    int     iImage;        // index of bitmap in ImageList
    int     iOrder;
#endif
} HDITEMW, FAR * LPHDITEMW;

#ifdef UNICODE
#define HDITEM HDITEMW
#define LPHDITEM LPHDITEMW
#else
#define HDITEM HDITEMA
#define LPHDITEM LPHDITEMW
#endif


#define HDI_WIDTH               0x0001
#define HDI_HEIGHT              HDI_WIDTH
#define HDI_TEXT                0x0002
#define HDI_FORMAT              0x0004
#define HDI_LPARAM              0x0008
#define HDI_BITMAP              0x0010
#if (_WIN32_IE >= 0x0300)
#define HDI_IMAGE               0x0020
#define HDI_DI_SETITEM          0x0040
#define HDI_ORDER               0x0080
#endif

#define HDF_LEFT                0
#define HDF_RIGHT               1
#define HDF_CENTER              2
#define HDF_JUSTIFYMASK         0x0003
#define HDF_RTLREADING          4

#define HDF_OWNERDRAW           0x8000
#define HDF_STRING              0x4000
#define HDF_BITMAP              0x2000
#if (_WIN32_IE >= 0x0300)
#define HDF_BITMAP_ON_RIGHT     0x1000
#define HDF_IMAGE               0x0800
#endif

#define HDM_GETITEMCOUNT        (HDM_FIRST + 0)
#define Header_GetItemCount(hwndHD) \
    (int)SNDMSG((hwndHD), HDM_GETITEMCOUNT, 0, 0L)


#define HDM_INSERTITEMA         (HDM_FIRST + 1)
#define HDM_INSERTITEMW         (HDM_FIRST + 10)

#ifdef UNICODE
#define HDM_INSERTITEM          HDM_INSERTITEMW
#else
#define HDM_INSERTITEM          HDM_INSERTITEMA
#endif

#define Header_InsertItem(hwndHD, i, phdi) \
    (int)SNDMSG((hwndHD), HDM_INSERTITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM FAR*)(phdi))


#define HDM_DELETEITEM          (HDM_FIRST + 2)
#define Header_DeleteItem(hwndHD, i) \
    (BOOL)SNDMSG((hwndHD), HDM_DELETEITEM, (WPARAM)(int)(i), 0L)


#define HDM_GETITEMA            (HDM_FIRST + 3)
#define HDM_GETITEMW            (HDM_FIRST + 11)

#ifdef UNICODE
#define HDM_GETITEM             HDM_GETITEMW
#else
#define HDM_GETITEM             HDM_GETITEMA
#endif

#define Header_GetItem(hwndHD, i, phdi) \
    (BOOL)SNDMSG((hwndHD), HDM_GETITEM, (WPARAM)(int)(i), (LPARAM)(HD_ITEM FAR*)(phdi))


#define HDM_SETITEMA            (HDM_FIRST + 4)
#define HDM_SETITEMW            (HDM_FIRST + 12)

#ifdef UNICODE
#define HDM_SETITEM             HDM_SETITEMW
#else
#define HDM_SETITEM             HDM_SETITEMA
#endif

#define Header_SetItem(hwndHD, i, phdi) \
    (BOOL)SNDMSG((hwndHD), HDM_SETITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM FAR*)(phdi))

#if (_WIN32_IE >= 0x0300)
#define HD_LAYOUT  HDLAYOUT
#else
#define HDLAYOUT   HD_LAYOUT
#endif

typedef struct _HD_LAYOUT
{
    RECT FAR* prc;
    WINDOWPOS FAR* pwpos;
} HDLAYOUT, FAR *LPHDLAYOUT;


#define HDM_LAYOUT              (HDM_FIRST + 5)
#define Header_Layout(hwndHD, playout) \
    (BOOL)SNDMSG((hwndHD), HDM_LAYOUT, 0, (LPARAM)(HD_LAYOUT FAR*)(playout))


#define HHT_NOWHERE             0x0001
#define HHT_ONHEADER            0x0002
#define HHT_ONDIVIDER           0x0004
#define HHT_ONDIVOPEN           0x0008
#define HHT_ABOVE               0x0100
#define HHT_BELOW               0x0200
#define HHT_TORIGHT             0x0400
#define HHT_TOLEFT              0x0800

#if (_WIN32_IE >= 0x0300)
#define HD_HITTESTINFO HDHITTESTINFO
#else
#define HDHITTESTINFO  HD_HITTESTINFO
#endif

typedef struct _HD_HITTESTINFO
{
    POINT pt;
    UINT flags;
    int iItem;
} HDHITTESTINFO, FAR *LPHDHITTESTINFO;


#define HDM_HITTEST             (HDM_FIRST + 6)

#if (_WIN32_IE >= 0x0300)

#define HDM_GETITEMRECT         (HDM_FIRST + 7)
#define Header_GetItemRect(hwnd, iItem, lprc) \
        (BOOL)SNDMSG((hwnd), HDM_GETITEMRECT, (WPARAM)iItem, (LPARAM)lprc)

#define HDM_SETIMAGELIST        (HDM_FIRST + 8)
#define Header_SetImageList(hwnd, himl) \
        (HIMAGELIST)SNDMSG((hwnd), HDM_SETIMAGELIST, 0, (LPARAM)himl)

#define HDM_GETIMAGELIST        (HDM_FIRST + 9)
#define Header_GetImageList(hwnd) \
        (HIMAGELIST)SNDMSG((hwnd), HDM_GETIMAGELIST, 0, 0)


#define HDM_ORDERTOINDEX        (HDM_FIRST + 15)
#define Header_OrderToIndex(hwnd, i) \
        (int)SNDMSG((hwnd), HDM_ORDERTOINDEX, (WPARAM)i, 0)

#define HDM_CREATEDRAGIMAGE     (HDM_FIRST + 16)  // wparam = which item (by index)
#define Header_CreateDragImage(hwnd, i) \
        (HIMAGELIST)SNDMSG((hwnd), HDM_CREATEDRAGIMAGE, (WPARAM)i, 0)

#define HDM_GETORDERARRAY       (HDM_FIRST + 17)
#define Header_GetOrderArray(hwnd, iCount, lpi) \
        (BOOL)SNDMSG((hwnd), HDM_GETORDERARRAY, (WPARAM)iCount, (LPARAM)lpi)

#define HDM_SETORDERARRAY       (HDM_FIRST + 18)
#define Header_SetOrderArray(hwnd, iCount, lpi) \
        (BOOL)SNDMSG((hwnd), HDM_SETORDERARRAY, (WPARAM)iCount, (LPARAM)lpi)
// lparam = int array of size HDM_GETITEMCOUNT
// the array specifies the order that all items should be displayed.
// e.g.  { 2, 0, 1}
// says the index 2 item should be shown in the 0ths position
//      index 0 should be shown in the 1st position
//      index 1 should be shown in the 2nd position


#define HDM_SETHOTDIVIDER          (HDM_FIRST + 19)
#define Header_SetHotDivider(hwnd, fPos, dw) \
        (int)SNDMSG((hwnd), HDM_SETHOTDIVIDER, (WPARAM)fPos, (LPARAM)dw)
// convenience message for external dragdrop
// wParam = BOOL  specifying whether the lParam is a dwPos of the cursor
//              position or the index of which divider to hotlight
// lParam = depends on wParam  (-1 and wParm = FALSE turns off hotlight)
#endif      // _WIN32_IE >= 0x0300

#define HDN_ITEMCHANGINGA       (HDN_FIRST-0)
#define HDN_ITEMCHANGINGW       (HDN_FIRST-20)
#define HDN_ITEMCHANGEDA        (HDN_FIRST-1)
#define HDN_ITEMCHANGEDW        (HDN_FIRST-21)
#define HDN_ITEMCLICKA          (HDN_FIRST-2)
#define HDN_ITEMCLICKW          (HDN_FIRST-22)
#define HDN_ITEMDBLCLICKA       (HDN_FIRST-3)
#define HDN_ITEMDBLCLICKW       (HDN_FIRST-23)
#define HDN_DIVIDERDBLCLICKA    (HDN_FIRST-5)
#define HDN_DIVIDERDBLCLICKW    (HDN_FIRST-25)
#define HDN_BEGINTRACKA         (HDN_FIRST-6)
#define HDN_BEGINTRACKW         (HDN_FIRST-26)
#define HDN_ENDTRACKA           (HDN_FIRST-7)
#define HDN_ENDTRACKW           (HDN_FIRST-27)
#define HDN_TRACKA              (HDN_FIRST-8)
#define HDN_TRACKW              (HDN_FIRST-28)
#if (_WIN32_IE >= 0x0300)
#define HDN_GETDISPINFOA        (HDN_FIRST-9)
#define HDN_GETDISPINFOW        (HDN_FIRST-29)
#define HDN_BEGINDRAG           (HDN_FIRST-10)
#define HDN_ENDDRAG             (HDN_FIRST-11)
#endif

#ifdef UNICODE
#define HDN_ITEMCHANGING         HDN_ITEMCHANGINGW
#define HDN_ITEMCHANGED          HDN_ITEMCHANGEDW
#define HDN_ITEMCLICK            HDN_ITEMCLICKW
#define HDN_ITEMDBLCLICK         HDN_ITEMDBLCLICKW
#define HDN_DIVIDERDBLCLICK      HDN_DIVIDERDBLCLICKW
#define HDN_BEGINTRACK           HDN_BEGINTRACKW
#define HDN_ENDTRACK             HDN_ENDTRACKW
#define HDN_TRACK                HDN_TRACKW
#if (_WIN32_IE >= 0x0300)
#define HDN_GETDISPINFO          HDN_GETDISPINFOW
#endif
#else
#define HDN_ITEMCHANGING         HDN_ITEMCHANGINGA
#define HDN_ITEMCHANGED          HDN_ITEMCHANGEDA
#define HDN_ITEMCLICK            HDN_ITEMCLICKA
#define HDN_ITEMDBLCLICK         HDN_ITEMDBLCLICKA
#define HDN_DIVIDERDBLCLICK      HDN_DIVIDERDBLCLICKA
#define HDN_BEGINTRACK           HDN_BEGINTRACKA
#define HDN_ENDTRACK             HDN_ENDTRACKA
#define HDN_TRACK                HDN_TRACKA
#if (_WIN32_IE >= 0x0300)
#define HDN_GETDISPINFO          HDN_GETDISPINFOA
#endif
#endif



#if (_WIN32_IE >= 0x0300)
#define HD_NOTIFYA              NMHEADERA
#define HD_NOTIFYW              NMHEADERW
#else
#define tagNMHEADERA            _HD_NOTIFY
#define NMHEADERA               HD_NOTIFYA
#define tagHMHEADERW            _HD_NOTIFYW
#define NMHEADERW               HD_NOTIFYW
#endif
#define HD_NOTIFY               NMHEADER

typedef struct tagNMHEADERA
{
    NMHDR   hdr;
    int     iItem;
    int     iButton;
    HDITEMA FAR* pitem;
}  NMHEADERA, FAR* LPNMHEADERA;


typedef struct tagNMHEADERW
{
    NMHDR   hdr;
    int     iItem;
    int     iButton;
    HDITEMW FAR* pitem;
} NMHEADERW, FAR* LPNMHEADERW;

#ifdef UNICODE
#define NMHEADER                NMHEADERW
#define LPNMHEADER              LPNMHEADERW
#else
#define NMHEADER                NMHEADERA
#define LPNMHEADER              LPNMHEADERA
#endif

typedef struct tagNMHDDISPINFOW
{
    NMHDR   hdr;
    int     iItem;
    UINT    mask;
    LPWSTR  pszText;
    int     cchTextMax;
    int     iImage;
    LPARAM  lParam;
} NMHDDISPINFOW, FAR* LPNMHDDISPINFOW;

typedef struct tagNMHDDISPINFOA
{
    NMHDR   hdr;
    int     iItem;
    UINT    mask;
    LPSTR   pszText;
    int     cchTextMax;
    int     iImage;
    LPARAM  lParam;
} NMHDDISPINFOA, FAR* LPNMHDDISPINFOA;


#ifdef UNICODE
#define NMHDDISPINFO            NMHDDISPINFOW
#define LPNMHDDISPINFO          LPNMHDDISPINFOW
#else
#define NMHDDISPINFO            NMHDDISPINFOA
#define LPNMHDDISPINFO          LPNMHDDISPINFOA
#endif

#endif      // NOHEADER

#if defined(WINCEOSVER) && WINCEOSVER >= 400

//====== IP ADDRESS CONTROL ===================================================


#if (_WIN32_IE >= 0x0400)

#ifndef NOIPADDRESS

// Messages sent to IPAddress controls

#define IPM_CLEARADDRESS (WM_USER+100) // no parameters
#define IPM_SETADDRESS   (WM_USER+101) // lparam = TCP/IP address
#define IPM_GETADDRESS   (WM_USER+102) // lresult = # of non black fields.  lparam = LPDWORD for TCP/IP address
#define IPM_SETRANGE (WM_USER+103) // wparam = field, lparam = range
#define IPM_SETFOCUS (WM_USER+104) // wparam = field
#define IPM_ISBLANK  (WM_USER+105) // no parameters

#define WC_IPADDRESSW           L"SysIPAddress32"
#define WC_IPADDRESSA           "SysIPAddress32"

#ifdef UNICODE
#define WC_IPADDRESS          WC_IPADDRESSW
#else
#define WC_IPADDRESS          WC_IPADDRESSA
#endif

#define IPN_FIELDCHANGED                (IPN_FIRST - 0)

// The following is a useful macro for passing the range values in the
// IPM_SETRANGE message.

#define MAKEIPRANGE(low, high)    ((LPARAM)(WORD)(((BYTE)(high) << 8) + (BYTE)(low)))

// And this is a useful macro for making the IP Address to be passed
// as a LPARAM.

#define MAKEIPADDRESS(b1,b2,b3,b4)  ((LPARAM)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

// Get individual number
#define FIRST_IPADDRESS(x)  ((x>>24) & 0xff)
#define SECOND_IPADDRESS(x) ((x>>16) & 0xff)
#define THIRD_IPADDRESS(x)  ((x>>8) & 0xff)
#define FOURTH_IPADDRESS(x) (x & 0xff)

// IP Address style bits

#define	IP_LEFT		0x00000001L	// left justify fields
#define IP_RIGHT	0x00000002L	// right justify fields
#define	IP_CENTER	0x00000004L	// center fields
#define IP_ZERO		0x00000008L	// Zero fill the fields

#endif // NOIPADDRESS

#endif      // _WIN32_IE >= 0x0400
// END IP ADDRESS CONTROL 
#endif

//====== TOOLBAR CONTROL ======================================================

#ifndef NOTOOLBAR

#ifdef _WIN32
#define TOOLBARCLASSNAMEW       L"ToolbarWindow32"
#define TOOLBARCLASSNAMEA       "ToolbarWindow32"

#ifdef  UNICODE
#define TOOLBARCLASSNAME        TOOLBARCLASSNAMEW
#else
#define TOOLBARCLASSNAME        TOOLBARCLASSNAMEA
#endif

#else
#define TOOLBARCLASSNAME        "ToolbarWindow"
#endif

typedef struct _TBBUTTON {
    int iBitmap;
    int idCommand;
    BYTE fsState;
    BYTE fsStyle;
#ifdef _WIN32
    BYTE bReserved[2];
#endif
    DWORD dwData;
    int iString;
} TBBUTTON, NEAR* PTBBUTTON, FAR* LPTBBUTTON;
typedef const TBBUTTON FAR* LPCTBBUTTON;

WINCOMMCTRLAPI HWND WINAPI CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps,
                        HINSTANCE hBMInst, UINT wBMID, LPCTBBUTTON lpButtons,
                        int iNumButtons, int dxButton, int dyButton,
                        int dxBitmap, int dyBitmap, UINT uStructSize);

#define TBSTATE_CHECKED         0x01
#define TBSTATE_PRESSED         0x02
#define TBSTATE_ENABLED         0x04
#define TBSTATE_HIDDEN          0x08
#define TBSTATE_INDETERMINATE   0x10
#define TBSTATE_WRAP            0x20
#if (_WIN32_IE >= 0x0300)
#define TBSTATE_ELLIPSES        0x40
#endif
#if (_WIN32_IE >= 0x0400)
#define TBSTATE_HIGHLIGHTED     0x80
#endif

#define TBSTYLE_BUTTON          0x0000
#define TBSTYLE_SEP             0x0001
#define TBSTYLE_CHECK           0x0002
#define TBSTYLE_GROUP           0x0004
#define TBSTYLE_CHECKGROUP      (TBSTYLE_GROUP | TBSTYLE_CHECK)
#if (_WIN32_IE >= 0x0300)
#define TBSTYLE_DROPDOWN        0x0008
#endif
#if (_WIN32_IE >= 0x0400)
#define TBSTYLE_AUTOSIZE        0x0010 // automatically calculate the cx of the button
#endif

#define TBSTYLE_TOOLTIPS        0x0100
#define TBSTYLE_WRAPABLE        0x0200
#define TBSTYLE_ALTDRAG         0x0400
#if (_WIN32_IE >= 0x0300)
#define TBSTYLE_FLAT            0x0800
#define TBSTYLE_LIST            0x1000
#define TBSTYLE_CUSTOMERASE     0x2000
#endif
#if (_WIN32_IE >= 0x0400)
#define TBSTYLE_TRANSPARENT     0x8000
#endif

#ifdef UNDER_CE
#define I_IMAGENONE  (-2) // Desktop listview uses this same value for I_IMAGENONE when (_WIN32_IE >= 0x0501)
#endif

#define TB_ENABLEBUTTON         (WM_USER + 1)
#define TB_CHECKBUTTON          (WM_USER + 2)
#define TB_PRESSBUTTON          (WM_USER + 3)
#define TB_HIDEBUTTON           (WM_USER + 4)
#define TB_INDETERMINATE        (WM_USER + 5)
#if (_WIN32_IE >= 0x0400)
#define TB_HIGHLIGHTBUTTON      (WM_USER + 6)
#endif
#define TB_ISBUTTONENABLED      (WM_USER + 9)
#define TB_ISBUTTONCHECKED      (WM_USER + 10)
#define TB_ISBUTTONPRESSED      (WM_USER + 11)
#define TB_ISBUTTONHIDDEN       (WM_USER + 12)
#define TB_ISBUTTONINDETERMINATE (WM_USER + 13)
#if (_WIN32_IE >= 0x0400)
#define TB_ISBUTTONHIGHLIGHTED  (WM_USER + 14)
#endif
#define TB_SETSTATE             (WM_USER + 17)
#define TB_GETSTATE             (WM_USER + 18)
#define TB_ADDBITMAP            (WM_USER + 19)

#ifdef _WIN32
typedef struct tagTBADDBITMAP {
        HINSTANCE       hInst;
        UINT            nID;
} TBADDBITMAP, *LPTBADDBITMAP;

#define HINST_COMMCTRL          ((HINSTANCE)-1)
#define IDB_STD_SMALL_COLOR     0
#define IDB_STD_LARGE_COLOR     1
#define IDB_VIEW_SMALL_COLOR    4
#define IDB_VIEW_LARGE_COLOR    5

// icon indexes for standard bitmap

#define STD_CUT                 0
#define STD_COPY                1
#define STD_PASTE               2
#define STD_UNDO                3
#define STD_REDOW               4
#define STD_DELETE              5
#define STD_FILENEW             6
#define STD_FILEOPEN            7
#define STD_FILESAVE            8
#define STD_PRINTPRE            9
#define STD_PROPERTIES          10
#define STD_HELP                11
#define STD_FIND                12
#define STD_REPLACE             13
#define STD_PRINT               14

// icon indexes for standard view bitmap

#define VIEW_LARGEICONS         0
#define VIEW_SMALLICONS         1
#define VIEW_LIST               2
#define VIEW_DETAILS            3
#define VIEW_SORTNAME           4
#define VIEW_SORTSIZE           5
#define VIEW_SORTDATE           6
#define VIEW_SORTTYPE           7
#define VIEW_PARENTFOLDER       8
#define VIEW_NETCONNECT         9
#define VIEW_NETDISCONNECT      10
#define VIEW_NEWFOLDER          11

#endif

#if (_WIN32_IE >= 0x0400)
#define TB_ADDBUTTONSA          (WM_USER + 20)
#define TB_INSERTBUTTONA        (WM_USER + 21)
#else
#define TB_ADDBUTTONS           (WM_USER + 20)
#define TB_INSERTBUTTON         (WM_USER + 21)
#endif

#define TB_DELETEBUTTON         (WM_USER + 22)
#define TB_GETBUTTON            (WM_USER + 23)
#define TB_BUTTONCOUNT          (WM_USER + 24)
#define TB_COMMANDTOINDEX       (WM_USER + 25)

#define TB_ADDSTRINGA           (WM_USER + 28)
#define TB_ADDSTRINGW           (WM_USER + 77)
#define TB_GETITEMRECT          (WM_USER + 29)
#define TB_BUTTONSTRUCTSIZE     (WM_USER + 30)
#define TB_SETBUTTONSIZE        (WM_USER + 31)
#define TB_SETBITMAPSIZE        (WM_USER + 32)
#define TB_AUTOSIZE             (WM_USER + 33)
#define TB_GETTOOLTIPS          (WM_USER + 35)
#ifndef UNDER_CE // TB_SETTOOLTIPS is used differently on WinCE, so its definition has changed
#define TB_SETTOOLTIPS          (WM_USER + 36)
#else
#define TB_SETTOOLTIPS          (WM_USER + 81)
#endif // !UNDER_CE
#define TB_SETPARENT            (WM_USER + 37)
#define TB_SETROWS              (WM_USER + 39)
#define TB_GETROWS              (WM_USER + 40)
#define TB_SETCMDID             (WM_USER + 42)
#define TB_CHANGEBITMAP         (WM_USER + 43)
#define TB_GETBITMAP            (WM_USER + 44)
#define TB_GETBUTTONTEXTA       (WM_USER + 45)
#define TB_GETBUTTONTEXTW       (WM_USER + 75)
#define TB_REPLACEBITMAP        (WM_USER + 46)
#if (_WIN32_IE >= 0x0300)
#define TB_SETINDENT            (WM_USER + 47)
#define TB_SETIMAGELIST         (WM_USER + 48)
#define TB_GETIMAGELIST         (WM_USER + 49)
#define TB_LOADIMAGES           (WM_USER + 50)
#define TB_GETRECT              (WM_USER + 51) // wParam is the Cmd instead of index
#define TB_SETDISABLEDIMAGELIST (WM_USER + 54)
#define TB_GETDISABLEDIMAGELIST (WM_USER + 55)
#define TB_SETSTYLE             (WM_USER + 56)
#define TB_GETSTYLE             (WM_USER + 57)
#define TB_GETBUTTONSIZE        (WM_USER + 58)
#define TB_SETBUTTONWIDTH       (WM_USER + 59)
#define TB_SETMAXTEXTROWS       (WM_USER + 60)
#define TB_GETTEXTROWS          (WM_USER + 61)
#endif      // _WIN32_IE >= 0x0300

#ifdef UNICODE
#define TB_GETBUTTONTEXT        TB_GETBUTTONTEXTW
#define TB_SAVERESTORE          TB_SAVERESTOREW
#define TB_ADDSTRING            TB_ADDSTRINGW
#else
#define TB_GETBUTTONTEXT        TB_GETBUTTONTEXTA
#define TB_SAVERESTORE          TB_SAVERESTOREA
#define TB_ADDSTRING            TB_ADDSTRINGA
#endif

typedef struct {
    HINSTANCE       hInstOld;
    UINT            nIDOld;
    HINSTANCE       hInstNew;
    UINT            nIDNew;
    int             nButtons;
} TBREPLACEBITMAP, *LPTBREPLACEBITMAP;

#ifdef _WIN32

#define TBBF_LARGE              0x0001

#define TB_GETBITMAPFLAGS       (WM_USER + 41)

#if (_WIN32_IE >= 0x0400)
#define TBIF_IMAGE              0x00000001
#define TBIF_TEXT               0x00000002
#define TBIF_STATE              0x00000004
#define TBIF_STYLE              0x00000008
#define TBIF_LPARAM             0x00000010
#define TBIF_COMMAND            0x00000020
#define TBIF_SIZE               0x00000040

typedef struct {
    UINT cbSize;
    DWORD dwMask;
    int idCommand;
    int iImage;
    BYTE fsState;
    BYTE fsStyle;
    WORD cx;
    DWORD lParam;
    LPSTR pszText;
    int cchText;
} TBBUTTONINFOA, *LPTBBUTTONINFOA;

typedef struct {
    UINT cbSize;
    DWORD dwMask;
    int idCommand;
    int iImage;
    BYTE fsState;
    BYTE fsStyle;
    WORD cx;
    DWORD lParam;
    LPWSTR pszText;
    int cchText;
} TBBUTTONINFOW, *LPTBBUTTONINFOW;

#ifdef UNICODE
#define TBBUTTONINFO TBBUTTONINFOW
#define LPTBBUTTONINFO LPTBBUTTONINFOW
#else
#define TBBUTTONINFO TBBUTTONINFOA
#define LPTBBUTTONINFO LPTBBUTTONINFOA
#endif


// BUTTONINFO APIs do NOT support the string pool.
#define TB_GETBUTTONINFOW        (WM_USER + 63)
#define TB_SETBUTTONINFOW        (WM_USER + 64)
#define TB_GETBUTTONINFOA        (WM_USER + 65)
#define TB_SETBUTTONINFOA        (WM_USER + 66)
#ifdef UNICODE
#define TB_GETBUTTONINFO        TB_GETBUTTONINFOW
#define TB_SETBUTTONINFO        TB_SETBUTTONINFOW
#else
#define TB_GETBUTTONINFO        TB_GETBUTTONINFOA
#define TB_SETBUTTONINFO        TB_SETBUTTONINFOA
#endif


#define TB_INSERTBUTTONW        (WM_USER + 67)
#define TB_ADDBUTTONSW          (WM_USER + 68)

#define TB_HITTEST              (WM_USER + 69)


// New post Win95/NT4 for InsertButton and AddButton.  if iString member 
// is a pointer to a string, it will be handled as a string like listview
// (although LPSTR_TEXTCALLBACK is not supported).
#ifdef UNICODE
#define TB_INSERTBUTTON         TB_INSERTBUTTONW
#define TB_ADDBUTTONS           TB_ADDBUTTONSW
#else
#define TB_INSERTBUTTON         TB_INSERTBUTTONA
#define TB_ADDBUTTONS           TB_ADDBUTTONSA
#endif

#define TB_SETDRAWTEXTFLAGS     (WM_USER + 70)  // wParam == mask lParam == bit values

#endif         // _WIN32_IE >= 0x0400

#define TBN_GETBUTTONINFOA      (TBN_FIRST-0)
#define TBN_GETBUTTONINFOW      (TBN_FIRST-20)
#define TBN_BEGINDRAG           (TBN_FIRST-1)
#define TBN_ENDDRAG             (TBN_FIRST-2)
#if (_WIN32_IE >= 0x0300)
#define TBN_DROPDOWN            (TBN_FIRST - 10)
#endif
#if (_WIN32_IE >= 0x0400)
#define TBN_DRAGOUT             (TBN_FIRST - 14) // this is sent when the user clicks down on a button then drags off the button
#endif

#ifdef UNICODE
#define TBN_GETBUTTONINFO       TBN_GETBUTTONINFOW
#else
#define TBN_GETBUTTONINFO       TBN_GETBUTTONINFOA
#endif

#if (_WIN32_IE >= 0x0300)
#define TBNOTIFYA NMTOOLBARA
#define TBNOTIFYW NMTOOLBARW
#define LPTBNOTIFYA LPNMTOOLBARA
#define LPTBNOTIFYW LPNMTOOLBARW
#else
#define tagNMTOOLBARA  tagTBNOTIFYA
#define NMTOOLBARA     TBNOTIFYA
#define LPNMTOOLBARA   LPTBNOTIFYA
#define tagNMTOOLBARW  tagTBNOTIFYW
#define NMTOOLBARW     TBNOTIFYW
#define LPNMTOOLBARW   LPTBNOTIFYW
#endif

#define TBNOTIFY       NMTOOLBAR
#define LPTBNOTIFY     LPNMTOOLBAR

typedef struct tagNMTOOLBARA {
#if (_WIN32_IE >= 0x0300)
    NMHDR   hdr;
#endif
    int     iItem;
    TBBUTTON tbButton;
    int     cchText;
    LPSTR   pszText;
} NMTOOLBARA, FAR* LPNMTOOLBARA;


typedef struct tagNMTOOLBARW {
#if (_WIN32_IE >= 0x0300)
    NMHDR   hdr;
#endif
    int     iItem;
    TBBUTTON tbButton;
    int     cchText;
    LPWSTR   pszText;
} NMTOOLBARW, FAR* LPNMTOOLBARW;


#ifdef UNICODE
#define NMTOOLBAR               NMTOOLBARW
#define LPNMTOOLBAR             LPNMTOOLBARW
#else
#define NMTOOLBAR               NMTOOLBARA
#define LPNMTOOLBAR             LPNMTOOLBARA
#endif

#endif

#endif      // NOTOOLBAR


#if (_WIN32_IE >= 0x0300)
//====== REBAR CONTROL ========================================================

#ifndef NOREBAR

#ifdef _WIN32
#define REBARCLASSNAMEW         L"ReBarWindow32"
#define REBARCLASSNAMEA         "ReBarWindow32"

#ifdef  UNICODE
#define REBARCLASSNAME          REBARCLASSNAMEW
#else
#define REBARCLASSNAME          REBARCLASSNAMEA
#endif

#else
#define REBARCLASSNAME          "ReBarWindow"
#endif

#define RBIM_IMAGELIST  0x00000001

#if (_WIN32_IE >= 0x0400)
#define RBS_VARHEIGHT       0x0200
#define RBS_BANDBORDERS     0x0400
#define RBS_FIXEDORDER      0x0800
#ifndef UNDER_CE // WinCE doesn't support RBS_REGISTERDROP
#define RBS_REGISTERDROP    0x1000
#else
#define RBS_SMARTLABELS     0x1000
#endif // UNDER_CE
#define RBS_AUTOSIZE        0x2000
#define RBS_VERTICALGRIPPER  0x4000  // this always has the vertical gripper (default for horizontal mode)
#else
#define RBS_VARHEIGHT       0x00000200
#define RBS_BANDBORDERS     0x00000400
#define RBS_FIXEDORDER      0x00000800
#endif      // _WIN32_IE >= 0x0400


typedef struct tagREBARINFO
{
    UINT        cbSize;
    UINT        fMask;
#ifndef NOIMAGEAPIS
    HIMAGELIST  himl;
#else
    HANDLE      himl;
#endif
}   REBARINFO, FAR *LPREBARINFO;

#define RBBS_BREAK          0x00000001  // break to new line
#define RBBS_FIXEDSIZE      0x00000002  // band can't be sized
#define RBBS_CHILDEDGE      0x00000004  // edge around top & bottom of child window
#define RBBS_HIDDEN         0x00000008  // don't show
#define RBBS_NOVERT         0x00000010  // don't show when vertical
#define RBBS_FIXEDBMP       0x00000020  // bitmap doesn't move during band resize
#if (_WIN32_IE >= 0x0400)
#define RBBS_VARIABLEHEIGHT 0x00000040  // allow autosizing of this child vertically
#define RBBS_GRIPPERALWAYS  0x00000080  // always show the gripper
#ifdef UNDER_CE
#define RBBS_NOGRIPPER      0x00000100  // never show gripper for this band
#endif // UNDER_CE
#endif

#define RBBIM_STYLE         0x00000001
#define RBBIM_COLORS        0x00000002
#define RBBIM_TEXT          0x00000004
#define RBBIM_IMAGE         0x00000008
#define RBBIM_CHILD         0x00000010
#define RBBIM_CHILDSIZE     0x00000020
#define RBBIM_SIZE          0x00000040
#define RBBIM_BACKGROUND    0x00000080
#define RBBIM_ID            0x00000100
#if (_WIN32_IE >= 0x0400)
#define RBBIM_IDEALSIZE     0x00000200
#define RBBIM_LPARAM        0x00000400
#endif

typedef struct tagREBARBANDINFOA
{
    UINT        cbSize;
    UINT        fMask;
    UINT        fStyle;
    COLORREF    clrFore;
    COLORREF    clrBack;
    LPSTR       lpText;
    UINT        cch;
    int         iImage;
    HWND        hwndChild;
    UINT        cxMinChild;
    UINT        cyMinChild;
    UINT        cx;
    HBITMAP     hbmBack;
    UINT        wID;
#if (_WIN32_IE >= 0x0400)
    UINT        cyChild;
    UINT        cyMaxChild;
    UINT        cyIntegral;
    UINT        cxIdeal;
    LPARAM      lParam;
#endif
}   REBARBANDINFOA, FAR *LPREBARBANDINFOA;
typedef REBARBANDINFOA CONST FAR *LPCREBARBANDINFOA;

typedef struct tagREBARBANDINFOW
{
    UINT        cbSize;
    UINT        fMask;
    UINT        fStyle;
    COLORREF    clrFore;
    COLORREF    clrBack;
    LPWSTR      lpText;
    UINT        cch;
    int         iImage;
    HWND        hwndChild;
    UINT        cxMinChild;
    UINT        cyMinChild;
    UINT        cx;
    HBITMAP     hbmBack;
    UINT        wID;
#if (_WIN32_IE >= 0x0400)
    UINT        cyChild;
    UINT        cyMaxChild;
    UINT        cyIntegral;
    UINT        cxIdeal;
    LPARAM      lParam;
#endif
}   REBARBANDINFOW, FAR *LPREBARBANDINFOW;
typedef REBARBANDINFOW CONST FAR *LPCREBARBANDINFOW;

#ifdef UNICODE
#define REBARBANDINFO       REBARBANDINFOW
#define LPREBARBANDINFO     LPREBARBANDINFOW
#define LPCREBARBANDINFO    LPCREBARBANDINFOW
#else
#define REBARBANDINFO       REBARBANDINFOA
#define LPREBARBANDINFO     LPREBARBANDINFOA
#define LPCREBARBANDINFO    LPCREBARBANDINFOA
#endif

#define RB_INSERTBANDA  (WM_USER +  1)
#define RB_DELETEBAND   (WM_USER +  2)
#define RB_GETBARINFO   (WM_USER +  3)
#define RB_SETBARINFO   (WM_USER +  4)
#if (_WIN32_IE < 0x0400)
#define RB_GETBANDINFO  (WM_USER +  5)
#endif
#define RB_SETBANDINFOA (WM_USER +  6)
#define RB_SETPARENT    (WM_USER +  7)
#if (_WIN32_IE >= 0x0400)
#define RB_HITTEST      (WM_USER +  8)
#define RB_GETRECT      (WM_USER +  9)
#endif
#define RB_INSERTBANDW  (WM_USER +  10)
#define RB_SETBANDINFOW (WM_USER +  11)
#define RB_GETBANDCOUNT (WM_USER +  12)
#define RB_GETROWCOUNT  (WM_USER +  13)
#define RB_GETROWHEIGHT (WM_USER +  14)
#if (_WIN32_IE >= 0x0400)
#define RB_IDTOINDEX    (WM_USER +  16) // wParam == id
#define RB_SETBKCOLOR   (WM_USER +  19) // sets the default BK color
#define RB_GETBKCOLOR   (WM_USER +  20) // defaults to CLR_NONE
#define RB_SETTEXTCOLOR (WM_USER +  21)
#define RB_GETTEXTCOLOR (WM_USER +  22) // defaults to 0x00000000
#define RB_SIZETORECT   (WM_USER +  23) // resize the rebar/break bands and such to this rect (lparam)
#endif      // _WIN32_IE >= 0x0400

#ifdef UNICODE
#define RB_INSERTBAND   RB_INSERTBANDW
#define RB_SETBANDINFO   RB_SETBANDINFOW
#else
#define RB_INSERTBAND   RB_INSERTBANDA
#define RB_SETBANDINFO   RB_SETBANDINFOA
#endif

#if (_WIN32_IE >= 0x0400)
// for manual drag control
// lparam == cursor pos
        // -1 means do it yourself.
        // -2 means use what you had saved before
#define RB_BEGINDRAG    (WM_USER + 24)
#define RB_ENDDRAG      (WM_USER + 25)
#define RB_DRAGMOVE     (WM_USER + 26)
#define RB_GETBARHEIGHT (WM_USER + 27)
#define RB_GETBANDINFOW (WM_USER + 28)
#define RB_GETBANDINFOA (WM_USER + 29)

#ifdef UNICODE
#define RB_GETBANDINFO   RB_GETBANDINFOW
#else
#define RB_GETBANDINFO   RB_GETBANDINFOA
#endif

#define RB_MINIMIZEBAND (WM_USER + 30)
#define RB_MAXIMIZEBAND (WM_USER + 31)

#define RB_GETBANDBORDERS (WM_USER + 34)  // returns in lparam = lprc the amount of edges added to band wparam

#define RB_SHOWBAND     (WM_USER + 35)      // show/hide band
#if defined(WINCEOSVER) && WINCEOSVER >= 400
#define RB_MOVEBAND     (WM_USER + 36)
#endif

#endif      // _WIN32_IE >= 0x0400

#define RBN_HEIGHTCHANGE    (RBN_FIRST - 0)

#if (_WIN32_IE >= 0x0400)
#define RBN_LAYOUTCHANGED   (RBN_FIRST - 2)
#define RBN_AUTOSIZE        (RBN_FIRST - 3)
#define RBN_BEGINDRAG       (RBN_FIRST - 4)
#define RBN_ENDDRAG         (RBN_FIRST - 5)


typedef struct tagNMREBAR
{
        NMHDR hdr;
        UINT uBand;
        UINT wID;
        UINT cyChild;
        UINT cyBand;
} NMREBAR, *LPNMREBAR;

typedef struct tagNMRBAUTOSIZE
{
        NMHDR hdr;
        BOOL fChanged;
        RECT rcTarget;
        RECT rcActual;
} NMRBAUTOSIZE, *LPNMRBAUTOSIZE;

#define RBHT_NOWHERE    0x0001
#define RBHT_CAPTION    0x0002
#define RBHT_CLIENT     0x0003
#define RBHT_GRABBER    0x0004

typedef struct _RB_HITTESTINFO
{
    POINT pt;
    UINT flags;
    int iBand;
} RBHITTESTINFO, FAR *LPRBHITTESTINFO;

#endif      // _WIN32_IE >= 0x0400

#endif      // NOREBAR

#endif      // _WIN32_IE >= 0x0300

//====== COMMANDBAR CONTROL =================================================

#ifdef UNDER_CE
#ifndef NOCOMMANDBAR

// Command Bar API's

typedef struct tagCOMMANDBANDSRESTOREINFO
{
    UINT        cbSize;
    UINT        wID;
    UINT        fStyle;
    UINT        cxRestored;
    BOOL        fMaximized;
} COMMANDBANDSRESTOREINFO, *LPCOMMANDBANDSRESTOREINFO;
typedef COMMANDBANDSRESTOREINFO CONST *LPCCOMMANDBANDSRESTOREINFO;
	
WINCOMMCTRLAPI HWND  WINAPI CommandBar_Create(HINSTANCE hInst, HWND hwndParent, int idCmdBar);
WINCOMMCTRLAPI BOOL  WINAPI CommandBar_Show(HWND hwndCB, BOOL fShow);
WINCOMMCTRLAPI int   WINAPI CommandBar_AddBitmap(HWND hwndCB, HINSTANCE hInst, int idBitmap,
								  int iNumImages, int iImageWidth,
								  int iImageHeight);
WINCOMMCTRLAPI HWND  WINAPI CommandBar_InsertComboBox(HWND hwndCB, HINSTANCE hInstance,
									   int  iWidth, UINT dwStyle,
									   WORD idComboBox, WORD iButton);
WINCOMMCTRLAPI BOOL  WINAPI CommandBar_InsertMenubar(HWND hwndCB, HINSTANCE hInst,
									  WORD idMenu, WORD iButton);
WINCOMMCTRLAPI BOOL WINAPI CommandBar_InsertMenubarEx(HWND hwndCB,
						               HINSTANCE hinst,
						               LPTSTR pszMenu,
						               WORD iButton);
WINCOMMCTRLAPI BOOL WINAPI CommandBar_DrawMenuBar(HWND hwndCB,
					                              WORD iButton);
WINCOMMCTRLAPI HMENU WINAPI CommandBar_GetMenu(HWND hwndCB, WORD iButton);
WINCOMMCTRLAPI BOOL  WINAPI CommandBar_AddAdornments(HWND hwndCB,
													 DWORD dwFlags,
													 DWORD dwReserved);
WINCOMMCTRLAPI void  WINAPI CommandBar_AlignAdornments(HWND hwndCB);
WINCOMMCTRLAPI int   WINAPI CommandBar_Height(HWND hwndCB);
WINCOMMCTRLAPI BOOL  WINAPI IsCommandBarMessage(HWND hwndCB, LPMSG lpMsg);


WINCOMMCTRLAPI HWND WINAPI CommandBands_Create(HINSTANCE hinst, 
                                               HWND hwndParent, 
                                               UINT wID, 
                                               DWORD dwStyles, 
                                               HIMAGELIST himl);
WINCOMMCTRLAPI BOOL WINAPI CommandBands_AddBands(HWND hwndCmdBands,  
                                                 HINSTANCE hinst,
                                                 UINT cBands, 
                                                 LPREBARBANDINFO prbbi);
WINCOMMCTRLAPI HWND WINAPI CommandBands_GetCommandBar(HWND hwndCmdBands, UINT uBand);
WINCOMMCTRLAPI BOOL WINAPI CommandBands_AddAdornments(HWND hwndCmdBands, 
                                                      HINSTANCE hinst, 
                                                      DWORD dwFlags, 
                                                      LPREBARBANDINFO prbbi);

WINCOMMCTRLAPI BOOL WINAPI CommandBands_Show(HWND hwndCmdBands, BOOL fShow);
WINCOMMCTRLAPI BOOL WINAPI CommandBands_GetRestoreInformation(HWND hwndCmdBands, 
                                               UINT uBand, 
                                               LPCOMMANDBANDSRESTOREINFO pcbri);

// Command Bar Helper Macros

#define CommandBar_Destroy(hwndCB) \
	DestroyWindow((hwndCB))

#define CommandBar_IsVisible(hwndCB) \
    IsWindowVisible((hwndCB))	

#define CommandBar_AddButtons(hwndCB, cbButtons, lpButtons) \
	SendMessage((hwndCB), TB_ADDBUTTONS, (WPARAM)(cbButtons), \
				(LPARAM)(lpButtons))

#define CommandBar_InsertButton(hwndCB, iButton, lpButton) \
    SendMessage((hwndCB), TB_INSERTBUTTON, (WPARAM)(iButton), \
	            (LPARAM)(lpButton))

#define CommandBar_AddToolTips(hwndCB, cbToolTips, lpToolTipsStrings) \
	SendMessage((hwndCB), TB_SETTOOLTIPS, (WPARAM)(cbToolTips), \
				(LPARAM)(lpToolTipsStrings))

#define CommandBands_Height(hwndCmdBands)\
	((UINT) SendMessage((hwndCmdBands), RB_GETBARHEIGHT, 0, 0))

#define CommandBands_IsVisible(hwndCmdBands) \
    IsWindowVisible((hwndCmdBands))

#define CMDBAR_HELP     0x000b
#define CMDBAR_OK		0xf000

#endif // NOCOMMANDBAR
#endif // UNDER_CE

//====== STATUS BAR CONTROL ===================================================

#ifndef NOSTATUSBAR

// begin_r_commctrl

// end_r_commctrl

WINCOMMCTRLAPI void WINAPI DrawStatusTextA(HDC hDC, LPRECT lprc, LPCSTR pszText, UINT uFlags);
WINCOMMCTRLAPI void WINAPI DrawStatusTextW(HDC hDC, LPRECT lprc, LPCWSTR pszText, UINT uFlags);

WINCOMMCTRLAPI HWND WINAPI CreateStatusWindowA(LONG style, LPCSTR lpszText, HWND hwndParent, UINT wID);
WINCOMMCTRLAPI HWND WINAPI CreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID);

#ifdef UNICODE
#define CreateStatusWindow      CreateStatusWindowW
#define DrawStatusText          DrawStatusTextW
#else
#define CreateStatusWindow      CreateStatusWindowA
#define DrawStatusText          DrawStatusTextA
#endif

#ifdef _WIN32
#define STATUSCLASSNAMEW        L"msctls_statusbar32"
#define STATUSCLASSNAMEA        "msctls_statusbar32"

#ifdef UNICODE
#define STATUSCLASSNAME         STATUSCLASSNAMEW
#else
#define STATUSCLASSNAME         STATUSCLASSNAMEA
#endif

#else
#define STATUSCLASSNAME         "msctls_statusbar"
#endif

#define SB_SETTEXTA             (WM_USER+1)
#define SB_SETTEXTW             (WM_USER+11)
#define SB_GETTEXTA             (WM_USER+2)
#define SB_GETTEXTW             (WM_USER+13)
#define SB_GETTEXTLENGTHA       (WM_USER+3)
#define SB_GETTEXTLENGTHW       (WM_USER+12)

#ifdef UNICODE
#define SB_GETTEXT              SB_GETTEXTW
#define SB_SETTEXT              SB_SETTEXTW
#define SB_GETTEXTLENGTH        SB_GETTEXTLENGTHW
#else
#define SB_GETTEXT              SB_GETTEXTA
#define SB_SETTEXT              SB_SETTEXTA
#define SB_GETTEXTLENGTH        SB_GETTEXTLENGTHA
#endif


#define SB_SETPARTS             (WM_USER+4)
#define SB_GETPARTS             (WM_USER+6)
#define SB_GETBORDERS           (WM_USER+7)
#define SB_SETMINHEIGHT         (WM_USER+8)
#define SB_SIMPLE               (WM_USER+9)
#define SB_GETRECT              (WM_USER+10)
#if (_WIN32_IE >= 0x0300)
#define SB_ISSIMPLE             (WM_USER+14)
#endif
#if (_WIN32_IE >= 0x0400)
#define SB_SETICON              (WM_USER+15)
#define SB_GETICON              (WM_USER+20)
#endif



#define SBT_OWNERDRAW            0x1000
#define SBT_NOBORDERS            0x0100
#define SBT_POPOUT               0x0200
#define SBT_RTLREADING           0x0400

#define SB_SETBKCOLOR           CCM_SETBKCOLOR      // lParam = bkColor

/// status bar notifications
#if (_WIN32_IE >= 0x0400)
#define SBN_SIMPLEMODECHANGE    (SBN_FIRST - 0)
#endif

#endif      // NOSTATUSBAR

//====== TRACKBAR CONTROL =====================================================

#ifndef NOTRACKBAR

#ifdef _WIN32

#define TRACKBAR_CLASSA         "msctls_trackbar32"
#define TRACKBAR_CLASSW         L"msctls_trackbar32"

#ifdef UNICODE
#define  TRACKBAR_CLASS         TRACKBAR_CLASSW
#else
#define  TRACKBAR_CLASS         TRACKBAR_CLASSA
#endif

#else
#define TRACKBAR_CLASS          "msctls_trackbar"
#endif


// begin_r_commctrl

#define TBS_AUTOTICKS           0x0001
#define TBS_VERT                0x0002
#define TBS_HORZ                0x0000
#define TBS_TOP                 0x0004
#define TBS_BOTTOM              0x0000
#define TBS_LEFT                0x0004
#define TBS_RIGHT               0x0000
#define TBS_BOTH                0x0008
#define TBS_NOTICKS             0x0010
#define TBS_ENABLESELRANGE      0x0020
#define TBS_FIXEDLENGTH         0x0040
#define TBS_NOTHUMB             0x0080
#define TBS_DOWNISLEFT          0x0400  // Down=Left and Up=Right (default is Down=Right and Up=Left)

// end_r_commctrl

#define TBM_GETPOS              (WM_USER)
#define TBM_GETRANGEMIN         (WM_USER+1)
#define TBM_GETRANGEMAX         (WM_USER+2)
#define TBM_GETTIC              (WM_USER+3)
#define TBM_SETTIC              (WM_USER+4)
#define TBM_SETPOS              (WM_USER+5)
#define TBM_SETRANGE            (WM_USER+6)
#define TBM_SETRANGEMIN         (WM_USER+7)
#define TBM_SETRANGEMAX         (WM_USER+8)
#define TBM_CLEARTICS           (WM_USER+9)
#define TBM_SETSEL              (WM_USER+10)
#define TBM_SETSELSTART         (WM_USER+11)
#define TBM_SETSELEND           (WM_USER+12)
#define TBM_GETPTICS            (WM_USER+14)
#define TBM_GETTICPOS           (WM_USER+15)
#define TBM_GETNUMTICS          (WM_USER+16)
#define TBM_GETSELSTART         (WM_USER+17)
#define TBM_GETSELEND           (WM_USER+18)
#define TBM_CLEARSEL            (WM_USER+19)
#define TBM_SETTICFREQ          (WM_USER+20)
#define TBM_SETPAGESIZE         (WM_USER+21)
#define TBM_GETPAGESIZE         (WM_USER+22)
#define TBM_SETLINESIZE         (WM_USER+23)
#define TBM_GETLINESIZE         (WM_USER+24)
#define TBM_GETTHUMBRECT        (WM_USER+25)
#define TBM_GETCHANNELRECT      (WM_USER+26)
#define TBM_SETTHUMBLENGTH      (WM_USER+27)
#define TBM_GETTHUMBLENGTH      (WM_USER+28)
#if (_WIN32_IE >= 0x0300)
#define TBM_SETBUDDY            (WM_USER+32) // wparam = BOOL fLeft; (or right)
#define TBM_GETBUDDY            (WM_USER+33) // wparam = BOOL fLeft; (or right)
#endif


#define TB_LINEUP               0
#define TB_LINEDOWN             1
#define TB_PAGEUP               2
#define TB_PAGEDOWN             3
#define TB_THUMBPOSITION        4
#define TB_THUMBTRACK           5
#define TB_TOP                  6
#define TB_BOTTOM               7
#define TB_ENDTRACK             8


#if (_WIN32_IE >= 0x0300)
// custom draw item specs
#define TBCD_TICS    0x0001
#define TBCD_THUMB   0x0002
#define TBCD_CHANNEL 0x0003
#endif

#endif // trackbar

//====== UPDOWN CONTROL =======================================================

#ifndef NOUPDOWN

#ifdef _WIN32

#define UPDOWN_CLASSA           "msctls_updown32"
#define UPDOWN_CLASSW           L"msctls_updown32"

#ifdef UNICODE
#define  UPDOWN_CLASS           UPDOWN_CLASSW
#else
#define  UPDOWN_CLASS           UPDOWN_CLASSA
#endif

#else
#define UPDOWN_CLASS            "msctls_updown"
#endif


typedef struct _UDACCEL {
    UINT nSec;
    UINT nInc;
} UDACCEL, FAR *LPUDACCEL;

#define UD_MAXVAL               0x7fff
#define UD_MINVAL               (-UD_MAXVAL)

// begin_r_commctrl

#define UDS_WRAP                0x0001
#define UDS_SETBUDDYINT         0x0002
#define UDS_ALIGNRIGHT          0x0004
#define UDS_ALIGNLEFT           0x0008
#define UDS_AUTOBUDDY           0x0010
#define UDS_ARROWKEYS           0x0020
#define UDS_HORZ                0x0040
#define UDS_NOTHOUSANDS         0x0080
#if (_WIN32_IE >= 0x0300)
#define UDS_HOTTRACK            0x0100
#endif
#define UDS_EXPANDABLE          0x0200   // Smartphone only 
#define UDS_NOSCROLL            0x0400   // Smartphone only   

// end_r_commctrl

#define UDM_SETRANGE            (WM_USER+101)
#define UDM_GETRANGE            (WM_USER+102)
#define UDM_SETPOS              (WM_USER+103)
#define UDM_GETPOS              (WM_USER+104)
#define UDM_SETBUDDY            (WM_USER+105)
#define UDM_GETBUDDY            (WM_USER+106)
#define UDM_SETACCEL            (WM_USER+107)
#define UDM_GETACCEL            (WM_USER+108)
#define UDM_SETBASE             (WM_USER+109)
#define UDM_GETBASE             (WM_USER+110)
#if (_WIN32_IE >= 0x0400)
#define UDM_SETRANGE32          (WM_USER+111)
#define UDM_GETRANGE32          (WM_USER+112) // wParam & lParam are LPINT
#endif
#define UDM_SETPOS32            (WM_USER+113)
#define UDM_GETPOS32            (WM_USER+114)

WINCOMMCTRLAPI HWND WINAPI CreateUpDownControl(DWORD dwStyle, int x, int y, int cx, int cy,
                                HWND hParent, int nID, HINSTANCE hInst,
                                HWND hBuddy,
                                int nUpper, int nLower, int nPos);

#if (_WIN32_IE >= 0x0300)
#define NM_UPDOWN      NMUPDOWN
#define LPNM_UPDOWN  LPNMUPDOWN
#else
#define NMUPDOWN      NM_UPDOWN
#define LPNMUPDOWN  LPNM_UPDOWN
#endif

typedef struct _NM_UPDOWN
{
    NMHDR hdr;
    int iPos;
    int iDelta;
} NMUPDOWN, FAR *LPNMUPDOWN;

#define UDN_DELTAPOS            (UDN_FIRST - 1)
#define UDN_EXPANDING           (UDN_FIRST - 2) // Smartphone only 

#endif  // NOUPDOWN


//====== PROGRESS CONTROL =====================================================

#ifndef NOPROGRESS

#ifdef _WIN32

#define PROGRESS_CLASSA         "msctls_progress32"
#define PROGRESS_CLASSW         L"msctls_progress32"

#ifdef UNICODE
#define  PROGRESS_CLASS         PROGRESS_CLASSW
#else
#define  PROGRESS_CLASS         PROGRESS_CLASSA
#endif

#else
#define PROGRESS_CLASS          "msctls_progress"
#endif


#if (_WIN32_IE >= 0x0300)
#define PBS_SMOOTH              0x01
#define PBS_VERTICAL            0x04
#endif

#define PBS_MARQUEE             0x08

#define PBM_SETRANGE            (WM_USER+1)
#define PBM_SETPOS              (WM_USER+2)
#define PBM_DELTAPOS            (WM_USER+3)
#define PBM_SETSTEP             (WM_USER+4)
#define PBM_STEPIT              (WM_USER+5)
#if (_WIN32_IE >= 0x0300)
#define PBM_SETRANGE32          (WM_USER+6)  // lParam = high, wParam = low
typedef struct
{
   int iLow;
   int iHigh;
} PBRANGE, *PPBRANGE;
#define PBM_GETRANGE            (WM_USER+7)  // wParam = return (TRUE ? low : high). lParam = PPBRANGE or NULL
#define PBM_GETPOS              (WM_USER+8)
#endif      // _WIN32_IE >= 0x0300

#define PBM_SETMARQUEE          (WM_USER+10)

#endif  // NOPROGRESS

// begin_r_commctrl

//====== COMMON CONTROL STYLES ================================================

#define CCS_TOP                 0x00000001L
#define CCS_NOMOVEY             0x00000002L
#define CCS_BOTTOM              0x00000003L
#define CCS_NORESIZE            0x00000004L
#define CCS_NOPARENTALIGN       0x00000008L
#define CCS_ADJUSTABLE          0x00000020L
#define CCS_NODIVIDER           0x00000040L
#if (_WIN32_IE >= 0x0300)
#define CCS_VERT                0x00000080L
#define CCS_LEFT                (CCS_VERT | CCS_TOP)
#define CCS_RIGHT               (CCS_VERT | CCS_BOTTOM)
#define CCS_NOMOVEX             (CCS_VERT | CCS_NOMOVEY)
#endif

// end_r_commctrl

//====== SysLink control =========================================
#ifdef _WIN32

#define INVALID_LINK_INDEX  (-1)
#define MAX_LINKID_TEXT     48
#define L_MAX_URL_LENGTH    (2048 + 32 + sizeof("://"))

#define WC_LINK         L"SysLink"

// begin_r_commctrl

#define LWS_TRANSPARENT     0x0001
#define LWS_IGNORERETURN    0x0002
#define LWS_NOPREFIX        0x0004
#define LWS_USEVISUALSTYLE  0x0008
#define LWS_USECUSTOMTEXT   0x0010
#define LWS_RIGHT           0x0020

// end_r_commctrl

#define LIF_ITEMINDEX    0x00000001
#define LIF_STATE        0x00000002
#define LIF_ITEMID       0x00000004
#define LIF_URL          0x00000008

#define LIS_FOCUSED         0x00000001
#define LIS_ENABLED         0x00000002
#define LIS_VISITED         0x00000004
#define LIS_HOTTRACK        0x00000008
#define LIS_DEFAULTCOLORS   0x00000010 // Don't use any custom text colors

typedef struct tagLITEM
{
    UINT        mask ;
    int         iLink ;
    UINT        state ;
    UINT        stateMask ;
    WCHAR       szID[MAX_LINKID_TEXT] ;
    WCHAR       szUrl[L_MAX_URL_LENGTH] ;
} LITEM, * PLITEM ;

typedef struct tagLHITTESTINFO
{
    POINT       pt ;
    LITEM     item ;
} LHITTESTINFO, *PLHITTESTINFO ;

typedef struct tagNMLINK
{
    NMHDR       hdr;
    LITEM     item ;
} NMLINK,  *PNMLINK;

//  SysLink notifications
//  NM_CLICK   // wParam: control ID, lParam: PNMLINK, ret: ignored.

//  LinkWindow messages
#define LM_HITTEST         (WM_USER+0x300)  // wParam: n/a, lparam: PLHITTESTINFO, ret: BOOL
#define LM_GETIDEALHEIGHT  (WM_USER+0x301)  // wParam: cxMaxWidth, lparam: n/a, ret: cy
#define LM_SETITEM         (WM_USER+0x302)  // wParam: n/a, lparam: LITEM*, ret: BOOL
#define LM_GETITEM         (WM_USER+0x303)  // wParam: n/a, lparam: LITEM*, ret: BOOL
#define LM_GETIDEALSIZE    (LM_GETIDEALHEIGHT)  // wParam: cxMaxWidth, lparam: SIZE*, ret: cy

#endif // _WIN32
//====== End SysLink control =========================================


//====== LISTVIEW CONTROL =====================================================

#ifndef NOLISTVIEW

#ifdef _WIN32

#define WC_LISTVIEWA            "SysListView32"
#define WC_LISTVIEWW            L"SysListView32"

#ifdef UNICODE
#define WC_LISTVIEW             WC_LISTVIEWW
#else
#define WC_LISTVIEW             WC_LISTVIEWA
#endif

#else
#define WC_LISTVIEW             "SysListView"
#endif

// begin_r_commctrl

#define LVS_ICON                0x0000
#define LVS_REPORT              0x0001
#define LVS_SMALLICON           0x0002
#define LVS_LIST                0x0003
#define LVS_TYPEMASK            0x0003
#define LVS_SINGLESEL           0x0004
#define LVS_SHOWSELALWAYS       0x0008
#define LVS_SORTASCENDING       0x0010
#define LVS_SORTDESCENDING      0x0020
#define LVS_SHAREIMAGELISTS     0x0040
#define LVS_NOLABELWRAP         0x0080
#define LVS_AUTOARRANGE         0x0100
#define LVS_EDITLABELS          0x0200
#if (_WIN32_IE >= 0x0300)
#define LVS_OWNERDATA           0x1000
#endif
#define LVS_NOSCROLL            0x2000

#define LVS_TYPESTYLEMASK       0xfc00

#define LVS_ALIGNTOP            0x0000
#define LVS_ALIGNLEFT           0x0800
#define LVS_ALIGNMASK           0x0c00

#define LVS_OWNERDRAWFIXED      0x0400
#define LVS_NOCOLUMNHEADER      0x4000
#define LVS_NOSORTHEADER        0x8000

// end_r_commctrl

#define LVM_GETBKCOLOR          (LVM_FIRST + 0)
#define ListView_GetBkColor(hwnd)  \
    (COLORREF)SNDMSG((hwnd), LVM_GETBKCOLOR, 0, 0L)

#define LVM_SETBKCOLOR          (LVM_FIRST + 1)
#define ListView_SetBkColor(hwnd, clrBk) \
    (BOOL)SNDMSG((hwnd), LVM_SETBKCOLOR, 0, (LPARAM)(COLORREF)(clrBk))

#define LVM_GETIMAGELIST        (LVM_FIRST + 2)
#define ListView_GetImageList(hwnd, iImageList) \
    (HIMAGELIST)SNDMSG((hwnd), LVM_GETIMAGELIST, (WPARAM)(INT)(iImageList), 0L)

#define LVSIL_NORMAL            0
#define LVSIL_SMALL             1
#define LVSIL_STATE             2
#ifdef UNDER_CE
#define LVSIL_HEADER            3
#endif // UNDER_CE

#define LVM_SETIMAGELIST        (LVM_FIRST + 3)
#define ListView_SetImageList(hwnd, himl, iImageList) \
    (HIMAGELIST)(UINT)SNDMSG((hwnd), LVM_SETIMAGELIST, (WPARAM)(iImageList), (LPARAM)(UINT)(HIMAGELIST)(himl))

#define LVM_GETITEMCOUNT        (LVM_FIRST + 4)
#define ListView_GetItemCount(hwnd) \
    (int)SNDMSG((hwnd), LVM_GETITEMCOUNT, 0, 0L)


#define LVIF_TEXT               0x0001
#define LVIF_IMAGE              0x0002
#define LVIF_PARAM              0x0004
#define LVIF_STATE              0x0008
#if (_WIN32_IE >= 0x0300)
#define LVIF_INDENT             0x0010
#define LVIF_NORECOMPUTE        0x0800
#endif

#define LVIF_GROUPID            0x0100
#define LVIF_COLUMNS            0x0200


#define LVIS_FOCUSED            0x0001
#define LVIS_SELECTED           0x0002
#define LVIS_CUT                0x0004
#define LVIS_DROPHILITED        0x0008

#define LVIS_OVERLAYMASK        0x0F00
#define LVIS_STATEIMAGEMASK     0xF000

#define INDEXTOSTATEIMAGEMASK(i) ((i) << 12)

#if (_WIN32_IE >= 0x0300)
#define I_INDENTCALLBACK        (-1)
#define LV_ITEMA LVITEMA
#define LV_ITEMW LVITEMW
#else
#define tagLVITEMA    _LV_ITEMA
#define LVITEMA       LV_ITEMA
#define tagLVITEMW    _LV_ITEMW
#define LVITEMW       LV_ITEMW
#endif


#define I_GROUPIDCALLBACK   (-1)
#define I_GROUPIDNONE       (-2)


#define LV_ITEM LVITEM

typedef struct tagLVITEMA
{
    UINT mask;
    int iItem;
    int iSubItem;
    UINT state;
    UINT stateMask;
    LPSTR pszText;
    int cchTextMax;
    int iImage;
    LPARAM lParam;
#if (_WIN32_IE >= 0x0300)
    int iIndent;
#endif
    int iGroupId;
} LVITEMA, FAR* LPLVITEMA;

typedef struct tagLVITEMW
{
    UINT mask;
    int iItem;
    int iSubItem;
    UINT state;
    UINT stateMask;
    LPWSTR pszText;
    int cchTextMax;
    int iImage;
    LPARAM lParam;
#if (_WIN32_IE >= 0x0300)
    int iIndent;
#endif
    int iGroupId;
} LVITEMW, FAR* LPLVITEMW;


#ifdef UNICODE
#define LVITEM    LVITEMW
#define LPLVITEM  LPLVITEMW
#else
#define LVITEM    LVITEMA
#define LPLVITEM  LPLVITEMA
#endif


#define LPSTR_TEXTCALLBACKW     ((LPWSTR)-1L)
#define LPSTR_TEXTCALLBACKA     ((LPSTR)-1L)
#ifdef UNICODE
#define LPSTR_TEXTCALLBACK      LPSTR_TEXTCALLBACKW
#else
#define LPSTR_TEXTCALLBACK      LPSTR_TEXTCALLBACKA
#endif

#define I_IMAGECALLBACK         (-1)

#define LVM_GETITEMA            (LVM_FIRST + 5)
#define LVM_GETITEMW            (LVM_FIRST + 75)
#ifdef UNICODE
#define LVM_GETITEM             LVM_GETITEMW
#else
#define LVM_GETITEM             LVM_GETITEMA
#endif

#define ListView_GetItem(hwnd, pitem) \
    (BOOL)SNDMSG((hwnd), LVM_GETITEM, 0, (LPARAM)(LV_ITEM FAR*)(pitem))


#define LVM_SETITEMA            (LVM_FIRST + 6)
#define LVM_SETITEMW            (LVM_FIRST + 76)
#ifdef UNICODE
#define LVM_SETITEM             LVM_SETITEMW
#else
#define LVM_SETITEM             LVM_SETITEMA
#endif

#define ListView_SetItem(hwnd, pitem) \
    (BOOL)SNDMSG((hwnd), LVM_SETITEM, 0, (LPARAM)(const LV_ITEM FAR*)(pitem))


#define LVM_INSERTITEMA         (LVM_FIRST + 7)
#define LVM_INSERTITEMW         (LVM_FIRST + 77)
#ifdef UNICODE
#define LVM_INSERTITEM          LVM_INSERTITEMW
#else
#define LVM_INSERTITEM          LVM_INSERTITEMA
#endif
#define ListView_InsertItem(hwnd, pitem)   \
    (int)SNDMSG((hwnd), LVM_INSERTITEM, 0, (LPARAM)(const LV_ITEM FAR*)(pitem))


#define LVM_DELETEITEM          (LVM_FIRST + 8)
#define ListView_DeleteItem(hwnd, i) \
    (BOOL)SNDMSG((hwnd), LVM_DELETEITEM, (WPARAM)(int)(i), 0L)


#define LVM_DELETEALLITEMS      (LVM_FIRST + 9)
#define ListView_DeleteAllItems(hwnd) \
    (BOOL)SNDMSG((hwnd), LVM_DELETEALLITEMS, 0, 0L)


#define LVM_GETCALLBACKMASK     (LVM_FIRST + 10)
#define ListView_GetCallbackMask(hwnd) \
    (BOOL)SNDMSG((hwnd), LVM_GETCALLBACKMASK, 0, 0)


#define LVM_SETCALLBACKMASK     (LVM_FIRST + 11)
#define ListView_SetCallbackMask(hwnd, mask) \
    (BOOL)SNDMSG((hwnd), LVM_SETCALLBACKMASK, (WPARAM)(UINT)(mask), 0)


#define LVNI_ALL                0x0000
#define LVNI_FOCUSED            0x0001
#define LVNI_SELECTED           0x0002
#define LVNI_CUT                0x0004
#define LVNI_DROPHILITED        0x0008

#define LVNI_ABOVE              0x0100
#define LVNI_BELOW              0x0200
#define LVNI_TOLEFT             0x0400
#define LVNI_TORIGHT            0x0800


#define LVM_GETNEXTITEM         (LVM_FIRST + 12)
__inline
int
WINAPI
ListView_GetNextItem(HWND hwnd, int i, UINT flags)
{
    int iResult = (int)SendMessage(hwnd, LVM_GETNEXTITEM, (WPARAM)i, MAKELPARAM(flags, 0));
    return ((0 == iResult) && !IsWindow(hwnd)) ? -1 : iResult;
}

#define LVFI_PARAM              0x0001
#define LVFI_STRING             0x0002
#define LVFI_PARTIAL            0x0008
#define LVFI_WRAP               0x0020
#define LVFI_NEARESTXY          0x0040

#if (_WIN32_IE >= 0x0300)
#define LV_FINDINFOA    LVFINDINFOA
#define LV_FINDINFOW    LVFINDINFOW
#else
#define tagLVFINDINFOA  _LV_FINDINFOA
#define    LVFINDINFOA   LV_FINDINFOA
#define tagLVFINDINFOW  _LV_FINDINFOW
#define    LVFINDINFOW   LV_FINDINFOW
#endif

#define LV_FINDINFO  LVFINDINFO

typedef struct tagLVFINDINFOA
{
    UINT flags;
    LPCSTR psz;
    LPARAM lParam;
    POINT pt;
    UINT vkDirection;
} LVFINDINFOA, FAR* LPFINDINFOA;

typedef struct tagLVFINDINFOW
{
    UINT flags;
    LPCWSTR psz;
    LPARAM lParam;
    POINT pt;
    UINT vkDirection;
} LVFINDINFOW, FAR* LPFINDINFOW;

#ifdef UNICODE
#define  LVFINDINFO            LVFINDINFOW
#else
#define  LVFINDINFO            LVFINDINFOA
#endif

#define LVM_FINDITEMA           (LVM_FIRST + 13)
#define LVM_FINDITEMW           (LVM_FIRST + 83)
#ifdef UNICODE
#define  LVM_FINDITEM           LVM_FINDITEMW
#else
#define  LVM_FINDITEM           LVM_FINDITEMA
#endif

#define ListView_FindItem(hwnd, iStart, plvfi) \
    (int)SNDMSG((hwnd), LVM_FINDITEM, (WPARAM)(int)(iStart), (LPARAM)(const LV_FINDINFO FAR*)(plvfi))

#define LVIR_BOUNDS             0
#define LVIR_ICON               1
#define LVIR_LABEL              2
#define LVIR_SELECTBOUNDS       3


#define LVM_GETITEMRECT         (LVM_FIRST + 14)
#define ListView_GetItemRect(hwnd, i, prc, code) \
     (BOOL)SNDMSG((hwnd), LVM_GETITEMRECT, (WPARAM)(int)(i), \
           ((prc) ? (((RECT FAR *)(prc))->left = (code),(LPARAM)(RECT FAR*)(prc)) : (LPARAM)(RECT FAR*)NULL))


#define LVM_SETITEMPOSITION     (LVM_FIRST + 15)
#define ListView_SetItemPosition(hwndLV, i, x, y) \
    (BOOL)SNDMSG((hwndLV), LVM_SETITEMPOSITION, (WPARAM)(int)(i), MAKELPARAM((x), (y)))


#define LVM_GETITEMPOSITION     (LVM_FIRST + 16)
#define ListView_GetItemPosition(hwndLV, i, ppt) \
    (BOOL)SNDMSG((hwndLV), LVM_GETITEMPOSITION, (WPARAM)(int)(i), (LPARAM)(POINT FAR*)(ppt))


#define LVM_GETSTRINGWIDTHA     (LVM_FIRST + 17)
#define LVM_GETSTRINGWIDTHW     (LVM_FIRST + 87)
#ifdef UNICODE
#define  LVM_GETSTRINGWIDTH     LVM_GETSTRINGWIDTHW
#else
#define  LVM_GETSTRINGWIDTH     LVM_GETSTRINGWIDTHA
#endif

#define ListView_GetStringWidth(hwndLV, psz) \
    (int)SNDMSG((hwndLV), LVM_GETSTRINGWIDTH, 0, (LPARAM)(LPCTSTR)(psz))


#define LVHT_NOWHERE            0x00000001
#define LVHT_ONITEMICON         0x00000002
#define LVHT_ONITEMLABEL        0x00000004
#define LVHT_ONITEMSTATEICON    0x00000008
#define LVHT_ONITEM             (LVHT_ONITEMICON | LVHT_ONITEMLABEL | LVHT_ONITEMSTATEICON)

#define LVHT_ABOVE              0x00000008
#define LVHT_BELOW              0x00000010
#define LVHT_TORIGHT            0x00000020
#define LVHT_TOLEFT             0x00000040


#define LVHT_GROUP_HEADER       0x10000000
#define LVHT_GROUP_FOOTER       0x20000000
#define LVHT_GROUP_COLLAPSE     0x40000000
#define LVHT_GROUP_BACKGROUND   0x80000000
#define LVHT_GROUP              (LVHT_GROUP_BACKGROUND | LVHT_GROUP_COLLAPSE | LVHT_GROUP_FOOTER | LVHT_GROUP_HEADER)

#if (_WIN32_IE >= 0x0300)
#define LV_HITTESTINFO LVHITTESTINFO
#else
#define tagLVHITTESTINFO  _LV_HITTESTINFO
#define    LVHITTESTINFO   LV_HITTESTINFO
#endif

typedef struct tagLVHITTESTINFO
{
    POINT pt;
    UINT flags;
    int iItem;
#if (_WIN32_IE >= 0x0300)
    int iSubItem;    // this is was NOT in Win95.  valid only for LVM_SUBITEMHITTEST
#endif
} LVHITTESTINFO, FAR* LPLVHITTESTINFO;

#define LVM_HITTEST             (LVM_FIRST + 18)
#define ListView_HitTest(hwndLV, pinfo) \
    (int)SNDMSG((hwndLV), LVM_HITTEST, 0, (LPARAM)(LV_HITTESTINFO FAR*)(pinfo))


#define LVM_ENSUREVISIBLE       (LVM_FIRST + 19)
#define ListView_EnsureVisible(hwndLV, i, fPartialOK) \
    (BOOL)SNDMSG((hwndLV), LVM_ENSUREVISIBLE, (WPARAM)(int)(i), MAKELPARAM((fPartialOK), 0))


#define LVM_SCROLL              (LVM_FIRST + 20)
#define ListView_Scroll(hwndLV, dx, dy) \
    (BOOL)SNDMSG((hwndLV), LVM_SCROLL, (WPARAM)(int)dx, (LPARAM)(int)dy)


#define LVM_REDRAWITEMS         (LVM_FIRST + 21)
#define ListView_RedrawItems(hwndLV, iFirst, iLast) \
    (BOOL)SNDMSG((hwndLV), LVM_REDRAWITEMS, (WPARAM)(int)iFirst, (LPARAM)(int)iLast)


#define LVA_DEFAULT             0x0000
#define LVA_ALIGNLEFT           0x0001
#define LVA_ALIGNTOP            0x0002
#define LVA_SNAPTOGRID          0x0005


#define LVM_ARRANGE             (LVM_FIRST + 22)
#define ListView_Arrange(hwndLV, code) \
    (BOOL)SNDMSG((hwndLV), LVM_ARRANGE, (WPARAM)(UINT)(code), 0L)


#define LVM_EDITLABELA          (LVM_FIRST + 23)
#define LVM_EDITLABELW          (LVM_FIRST + 118)
#ifdef UNICODE
#define LVM_EDITLABEL           LVM_EDITLABELW
#else
#define LVM_EDITLABEL           LVM_EDITLABELA
#endif

#define ListView_EditLabel(hwndLV, i) \
    (HWND)SNDMSG((hwndLV), LVM_EDITLABEL, (WPARAM)(int)(i), 0L)


#define LVM_GETEDITCONTROL      (LVM_FIRST + 24)
#define ListView_GetEditControl(hwndLV) \
    (HWND)SNDMSG((hwndLV), LVM_GETEDITCONTROL, 0, 0L)


#if (_WIN32_IE >= 0x0300)
#define LV_COLUMNA      LVCOLUMNA
#define LV_COLUMNW      LVCOLUMNW
#else
#define tagLVCOLUMNA    _LV_COLUMNA
#define    LVCOLUMNA     LV_COLUMNA
#define tagLVCOLUMNW    _LV_COLUMNW
#define    LVCOLUMNW     LV_COLUMNW
#endif

#define LV_COLUMN       LVCOLUMN

typedef struct tagLVCOLUMNA
{
    UINT mask;
    int fmt;
    int cx;
    LPSTR pszText;
    int cchTextMax;
    int iSubItem;
#if (_WIN32_IE >= 0x0300)
    int iImage;
    int iOrder;
#endif
} LVCOLUMNA, FAR* LPLVCOLUMNA;

typedef struct tagLVCOLUMNW
{
    UINT mask;
    int fmt;
    int cx;
    LPWSTR pszText;
    int cchTextMax;
    int iSubItem;
#if (_WIN32_IE >= 0x0300)
    int iImage;
    int iOrder;
#endif
} LVCOLUMNW, FAR* LPLVCOLUMNW;

#ifdef UNICODE
#define  LVCOLUMN               LVCOLUMNW
#define  LPLVCOLUMN             LPLVCOLUMNW
#else
#define  LVCOLUMN               LVCOLUMNA
#define  LPLVCOLUMN             LPLVCOLUMNA
#endif


#define LVCF_FMT                0x0001
#define LVCF_WIDTH              0x0002
#define LVCF_TEXT               0x0004
#define LVCF_SUBITEM            0x0008
#if (_WIN32_IE >= 0x0300)
#define LVCF_IMAGE              0x0010
#define LVCF_ORDER              0x0020
#endif

#define LVCFMT_LEFT             0x0000
#define LVCFMT_RIGHT            0x0001
#define LVCFMT_CENTER           0x0002
#define LVCFMT_JUSTIFYMASK      0x0003
#if (_WIN32_IE >= 0x0300)
#define LVCFMT_IMAGE            0x0800
#define LVCFMT_BITMAP_ON_RIGHT  0x1000
#define LVCFMT_COL_HAS_IMAGES   0x8000
#endif

#define LVM_GETCOLUMNA          (LVM_FIRST + 25)
#define LVM_GETCOLUMNW          (LVM_FIRST + 95)
#ifdef UNICODE
#define  LVM_GETCOLUMN          LVM_GETCOLUMNW
#else
#define  LVM_GETCOLUMN          LVM_GETCOLUMNA
#endif

#define ListView_GetColumn(hwnd, iCol, pcol) \
    (BOOL)SNDMSG((hwnd), LVM_GETCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(LV_COLUMN FAR*)(pcol))


#define LVM_SETCOLUMNA          (LVM_FIRST + 26)
#define LVM_SETCOLUMNW          (LVM_FIRST + 96)
#ifdef UNICODE
#define  LVM_SETCOLUMN          LVM_SETCOLUMNW
#else
#define  LVM_SETCOLUMN          LVM_SETCOLUMNA
#endif

#define ListView_SetColumn(hwnd, iCol, pcol) \
    (BOOL)SNDMSG((hwnd), LVM_SETCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(const LV_COLUMN FAR*)(pcol))


#define LVM_INSERTCOLUMNA       (LVM_FIRST + 27)
#define LVM_INSERTCOLUMNW       (LVM_FIRST + 97)
#ifdef UNICODE
#   define  LVM_INSERTCOLUMN    LVM_INSERTCOLUMNW
#else
#   define  LVM_INSERTCOLUMN    LVM_INSERTCOLUMNA
#endif

#define ListView_InsertColumn(hwnd, iCol, pcol) \
    (int)SNDMSG((hwnd), LVM_INSERTCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(const LV_COLUMN FAR*)(pcol))


#define LVM_DELETECOLUMN        (LVM_FIRST + 28)
#define ListView_DeleteColumn(hwnd, iCol) \
    (BOOL)SNDMSG((hwnd), LVM_DELETECOLUMN, (WPARAM)(int)(iCol), 0)


#define LVM_GETCOLUMNWIDTH      (LVM_FIRST + 29)
#define ListView_GetColumnWidth(hwnd, iCol) \
    (int)SNDMSG((hwnd), LVM_GETCOLUMNWIDTH, (WPARAM)(int)(iCol), 0)


#define LVSCW_AUTOSIZE              -1
#define LVSCW_AUTOSIZE_USEHEADER    -2
#define LVM_SETCOLUMNWIDTH          (LVM_FIRST + 30)

#define ListView_SetColumnWidth(hwnd, iCol, cx) \
    (BOOL)SNDMSG((hwnd), LVM_SETCOLUMNWIDTH, (WPARAM)(int)(iCol), MAKELPARAM((cx), 0))

#if (_WIN32_IE >= 0x0300)
#define LVM_GETHEADER               (LVM_FIRST + 31)
#define ListView_GetHeader(hwnd)\
    (HWND)SNDMSG((hwnd), LVM_GETHEADER, 0, 0L)
#endif

#define LVM_CREATEDRAGIMAGE     (LVM_FIRST + 33)
#define ListView_CreateDragImage(hwnd, i, lpptUpLeft) \
    (HIMAGELIST)SNDMSG((hwnd), LVM_CREATEDRAGIMAGE, (WPARAM)(int)(i), (LPARAM)(LPPOINT)(lpptUpLeft))


#define LVM_GETVIEWRECT         (LVM_FIRST + 34)
#define ListView_GetViewRect(hwnd, prc) \
    (BOOL)SNDMSG((hwnd), LVM_GETVIEWRECT, 0, (LPARAM)(RECT FAR*)(prc))


#define LVM_GETTEXTCOLOR        (LVM_FIRST + 35)
#define ListView_GetTextColor(hwnd)  \
    (COLORREF)SNDMSG((hwnd), LVM_GETTEXTCOLOR, 0, 0L)


#define LVM_SETTEXTCOLOR        (LVM_FIRST + 36)
#define ListView_SetTextColor(hwnd, clrText) \
    (BOOL)SNDMSG((hwnd), LVM_SETTEXTCOLOR, 0, (LPARAM)(COLORREF)(clrText))


#define LVM_GETTEXTBKCOLOR      (LVM_FIRST + 37)
#define ListView_GetTextBkColor(hwnd)  \
    (COLORREF)SNDMSG((hwnd), LVM_GETTEXTBKCOLOR, 0, 0L)


#define LVM_SETTEXTBKCOLOR      (LVM_FIRST + 38)
#define ListView_SetTextBkColor(hwnd, clrTextBk) \
    (BOOL)SNDMSG((hwnd), LVM_SETTEXTBKCOLOR, 0, (LPARAM)(COLORREF)(clrTextBk))


#define LVM_GETTOPINDEX         (LVM_FIRST + 39)
#define ListView_GetTopIndex(hwndLV) \
    (int)SNDMSG((hwndLV), LVM_GETTOPINDEX, 0, 0)


#define LVM_GETCOUNTPERPAGE     (LVM_FIRST + 40)
#define ListView_GetCountPerPage(hwndLV) \
    (int)SNDMSG((hwndLV), LVM_GETCOUNTPERPAGE, 0, 0)


#define LVM_GETORIGIN           (LVM_FIRST + 41)
#define ListView_GetOrigin(hwndLV, ppt) \
    (BOOL)SNDMSG((hwndLV), LVM_GETORIGIN, (WPARAM)0, (LPARAM)(POINT FAR*)(ppt))


#define LVM_UPDATE              (LVM_FIRST + 42)
#define ListView_Update(hwndLV, i) \
    (BOOL)SNDMSG((hwndLV), LVM_UPDATE, (WPARAM)i, 0L)


#define LVM_SETITEMSTATE        (LVM_FIRST + 43)
#define ListView_SetItemState(hwndLV, i, data, mask) \
{ LV_ITEM _ms_lvi;\
  _ms_lvi.stateMask = mask;\
  _ms_lvi.state = data;\
  SNDMSG((hwndLV), LVM_SETITEMSTATE, (WPARAM)i, (LPARAM)(LV_ITEM FAR *)&_ms_lvi);\
}

#if (_WIN32_IE >= 0x0300)
#define ListView_SetCheckState(hwndLV, i, fCheck) \
   ListView_SetItemState(hwndLV, i, INDEXTOSTATEIMAGEMASK((fCheck)?2:1), LVIS_STATEIMAGEMASK)
#endif


#define LVM_GETITEMSTATE        (LVM_FIRST + 44)
#define ListView_GetItemState(hwndLV, i, mask) \
   (UINT)SNDMSG((hwndLV), LVM_GETITEMSTATE, (WPARAM)i, (LPARAM)mask)

#if (_WIN32_IE >= 0x0300)
#define ListView_GetCheckState(hwndLV, i) \
   ((((UINT)(SNDMSG((hwndLV), LVM_GETITEMSTATE, (WPARAM)i, LVIS_STATEIMAGEMASK))) >> 12) -1)
#endif

#define LVM_GETITEMTEXTA        (LVM_FIRST + 45)
#define LVM_GETITEMTEXTW        (LVM_FIRST + 115)

#ifdef UNICODE
#define  LVM_GETITEMTEXT        LVM_GETITEMTEXTW
#else
#define  LVM_GETITEMTEXT        LVM_GETITEMTEXTA
#endif

#define ListView_GetItemText(hwndLV, i, iSubItem_, pszText_, cchTextMax_) \
{ LV_ITEM _ms_lvi;\
  _ms_lvi.iSubItem = iSubItem_;\
  _ms_lvi.cchTextMax = cchTextMax_;\
  _ms_lvi.pszText = pszText_;\
  SNDMSG((hwndLV), LVM_GETITEMTEXT, (WPARAM)i, (LPARAM)(LV_ITEM FAR *)&_ms_lvi);\
}


#define LVM_SETITEMTEXTA        (LVM_FIRST + 46)
#define LVM_SETITEMTEXTW        (LVM_FIRST + 116)

#ifdef UNICODE
#define  LVM_SETITEMTEXT        LVM_SETITEMTEXTW
#else
#define  LVM_SETITEMTEXT        LVM_SETITEMTEXTA
#endif

#define ListView_SetItemText(hwndLV, i, iSubItem_, pszText_) \
{ LV_ITEM _ms_lvi;\
  _ms_lvi.iSubItem = iSubItem_;\
  _ms_lvi.pszText = pszText_;\
  SNDMSG((hwndLV), LVM_SETITEMTEXT, (WPARAM)i, (LPARAM)(LV_ITEM FAR *)&_ms_lvi);\
}

#if (_WIN32_IE >= 0x0300)
// these flags only apply to LVS_OWNERDATA listviews in report or list mode
#define LVSICF_NOINVALIDATEALL  0x00000001
#define LVSICF_NOSCROLL         0x00000002
#endif

#define LVM_SETITEMCOUNT        (LVM_FIRST + 47)
#define ListView_SetItemCount(hwndLV, cItems) \
  SNDMSG((hwndLV), LVM_SETITEMCOUNT, (WPARAM)cItems, 0)

#if (_WIN32_IE >= 0x0300)
#define ListView_SetItemCountEx(hwndLV, cItems, dwFlags) \
  SNDMSG((hwndLV), LVM_SETITEMCOUNT, (WPARAM)cItems, (LPARAM)dwFlags)
#endif

typedef int (CALLBACK *PFNLVCOMPARE)(LPARAM, LPARAM, LPARAM);


#define LVM_SORTITEMS           (LVM_FIRST + 48)
#define ListView_SortItems(hwndLV, _pfnCompare, _lPrm) \
  (BOOL)SNDMSG((hwndLV), LVM_SORTITEMS, (WPARAM)(LPARAM)_lPrm, \
  (LPARAM)(PFNLVCOMPARE)_pfnCompare)


#define LVM_SETITEMPOSITION32   (LVM_FIRST + 49)
#define ListView_SetItemPosition32(hwndLV, i, x, y) \
{ POINT ptNewPos = {x,y}; \
    SNDMSG((hwndLV), LVM_SETITEMPOSITION32, (WPARAM)(int)(i), (LPARAM)&ptNewPos); \
}


#define LVM_GETSELECTEDCOUNT    (LVM_FIRST + 50)
#define ListView_GetSelectedCount(hwndLV) \
    (UINT)SNDMSG((hwndLV), LVM_GETSELECTEDCOUNT, 0, 0L)


#define LVM_GETITEMSPACING      (LVM_FIRST + 51)
#define ListView_GetItemSpacing(hwndLV, fSmall) \
        (DWORD)SNDMSG((hwndLV), LVM_GETITEMSPACING, fSmall, 0L)


#define LVM_GETISEARCHSTRINGA   (LVM_FIRST + 52)
#define LVM_GETISEARCHSTRINGW   (LVM_FIRST + 117)

#ifdef UNICODE
#define LVM_GETISEARCHSTRING    LVM_GETISEARCHSTRINGW
#else
#define LVM_GETISEARCHSTRING    LVM_GETISEARCHSTRINGA
#endif

#define ListView_GetISearchString(hwndLV, lpsz) \
        (BOOL)SNDMSG((hwndLV), LVM_GETISEARCHSTRING, 0, (LPARAM)(LPTSTR)lpsz)

#if (_WIN32_IE >= 0x0300)
#define LVM_SETICONSPACING      (LVM_FIRST + 53)
// -1 for cx and cy means we'll use the default (system settings)
// 0 for cx or cy means use the current setting (allows you to change just one param)
#define ListView_SetIconSpacing(hwndLV, cx, cy) \
        (DWORD)SNDMSG((hwndLV), LVM_SETICONSPACING, 0, MAKELONG(cx,cy))


#define LVM_SETEXTENDEDLISTVIEWSTYLE (LVM_FIRST + 54)   // optional wParam == mask
#define ListView_SetExtendedListViewStyle(hwndLV, dw)\
        (DWORD)SNDMSG((hwndLV), LVM_SETEXTENDEDLISTVIEWSTYLE, 0, dw)
#if (_WIN32_IE >= 0x0400)
#define ListView_SetExtendedListViewStyleEx(hwndLV, dwMask, dw)\
        (DWORD)SNDMSG((hwndLV), LVM_SETEXTENDEDLISTVIEWSTYLE, dwMask, dw)
#endif

#define LVM_GETEXTENDEDLISTVIEWSTYLE (LVM_FIRST + 55)
#define ListView_GetExtendedListViewStyle(hwndLV)\
        (DWORD)SNDMSG((hwndLV), LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0)

#define LVS_EX_GRIDLINES        0x00000001
#define LVS_EX_SUBITEMIMAGES    0x00000002
#define LVS_EX_CHECKBOXES       0x00000004
#define LVS_EX_TRACKSELECT      0x00000008
#define LVS_EX_HEADERDRAGDROP   0x00000010
#define LVS_EX_FULLROWSELECT    0x00000020 // applies to report mode only
#define LVS_EX_ONECLICKACTIVATE 0x00000040
#if (_WIN32_IE >= 0x0400)
#define LVS_EX_INFOTIP          0x00000400 // listview does InfoTips for you
#endif
#define LVS_EX_DOUBLEBUFFER     0x00010000
#define LVS_EX_NOFOCUSRECT      0x01000000 // Don't draw a focus rectangle for the focused item
#define LVS_EX_NOHSCROLL        0x10000000
#define LVS_EX_GRADIENT         0x20000000 // draw a background gradient
#define LVS_EX_DISJOINTFOCUS    0x40000000 // Allow disjoint focus and selection


#define LVM_GETSUBITEMRECT      (LVM_FIRST + 56)
#define ListView_GetSubItemRect(hwnd, iItem, iSubItem, code, prc) \
        (BOOL)SNDMSG((hwnd), LVM_GETSUBITEMRECT, (WPARAM)(int)(iItem), \
                ((prc) ? ((((LPRECT)(prc))->top = iSubItem), (((LPRECT)(prc))->left = code), (LPARAM)(prc)) : (LPARAM)(LPRECT)NULL))

#define LVM_SUBITEMHITTEST      (LVM_FIRST + 57)
#define ListView_SubItemHitTest(hwnd, plvhti) \
        (int)SNDMSG((hwnd), LVM_SUBITEMHITTEST, 0, (LPARAM)(LPLVHITTESTINFO)(plvhti))

#define LVM_SETCOLUMNORDERARRAY (LVM_FIRST + 58)
#define ListView_SetColumnOrderArray(hwnd, iCount, pi) \
        (BOOL)SNDMSG((hwnd), LVM_SETCOLUMNORDERARRAY, (WPARAM)iCount, (LPARAM)(LPINT)pi)

#define LVM_GETCOLUMNORDERARRAY (LVM_FIRST + 59)
#define ListView_GetColumnOrderArray(hwnd, iCount, pi) \
        (BOOL)SNDMSG((hwnd), LVM_GETCOLUMNORDERARRAY, (WPARAM)iCount, (LPARAM)(LPINT)pi)

#define LVM_APPROXIMATEVIEWRECT (LVM_FIRST + 64)
#define ListView_ApproximateViewRect(hwnd, iWidth, iHeight, iCount) \
        (DWORD)SNDMSG((hwnd), LVM_APPROXIMATEVIEWRECT, iCount, MAKELPARAM(iWidth, iHeight))
#endif      // _WIN32_IE >= 0x0300

#if (_WIN32_IE >= 0x0400)
#define LVM_GETSELECTIONMARK    (LVM_FIRST + 66)
#define ListView_GetSelectionMark(hwnd) \
    (int)SNDMSG((hwnd), LVM_GETSELECTIONMARK, 0, 0)

#define LVM_SETSELECTIONMARK    (LVM_FIRST + 67)
#define ListView_SetSelectionMark(hwnd, i) \
    (int)SNDMSG((hwnd), LVM_SETSELECTIONMARK, 0, (LPARAM)i)

#define LV_MAX_WORKAREAS         16
#define LVM_SETWORKAREAS         (LVM_FIRST + 65)
#define ListView_SetWorkAreas(hwnd, nWorkAreas, prc) \
    (BOOL)SNDMSG((hwnd), LVM_SETWORKAREAS, (WPARAM)(int)nWorkAreas, (LPARAM)(RECT FAR*)(prc))

#define LVM_GETWORKAREAS        (LVM_FIRST + 70)
#define ListView_GetWorkAreas(hwnd, nWorkAreas, prc) \
    (BOOL)SNDMSG((hwnd), LVM_GETWORKAREAS, (WPARAM)(int)nWorkAreas, (LPARAM)(RECT FAR*)(prc))

#define LVM_GETNUMBEROFWORKAREAS  (LVM_FIRST + 73)
#define ListView_GetNumberOfWorkAreas(hwnd, pnWorkAreas) \
    (BOOL)SNDMSG((hwnd), LVM_GETNUMBEROFWORKAREAS, 0, (LPARAM)(UINT *)(pnWorkAreas))

#define LVM_SETTOOLTIPS       (LVM_FIRST + 74)
#define ListView_SetToolTips(hwndLV, hwndNewHwnd)\
        (HWND)SNDMSG((hwndLV), LVM_SETTOOLTIPS, (WPARAM)(hwndNewHwnd), 0)

#define LVM_GETTOOLTIPS       (LVM_FIRST + 78)
#define ListView_GetToolTips(hwndLV)\
        (HWND)SNDMSG((hwndLV), LVM_GETTOOLTIPS, 0, 0)

typedef struct tagLVBKIMAGEA
{
    ULONG ulFlags;              // LVBKIF_*
    HBITMAP hbm;
    LPSTR pszImage;
    UINT cchImageMax;
    int xOffsetPercent;
    int yOffsetPercent;
} LVBKIMAGEA, *LPLVBKIMAGEA;
typedef struct tagLVBKIMAGEW
{
    ULONG ulFlags;              // LVBKIF_*
    HBITMAP hbm;
    LPWSTR pszImage;
    UINT cchImageMax;
    int xOffsetPercent;
    int yOffsetPercent;
} LVBKIMAGEW, *LPLVBKIMAGEW;

#define LVBKIF_SOURCE_NONE      0x00000000
#define LVBKIF_SOURCE_HBITMAP   0x00000001
#define LVBKIF_SOURCE_URL       0x00000002
#define LVBKIF_SOURCE_MASK      0x00000003
#define LVBKIF_STYLE_NORMAL     0x00000000
#define LVBKIF_STYLE_TILE       0x00000010
#define LVBKIF_STYLE_MASK       0x00000010
#define LVBKIF_FLAG_TILEOFFSET  0x00000100

#define LVM_SETBKIMAGEA         (LVM_FIRST + 68)
#define LVM_SETBKIMAGEW         (LVM_FIRST + 138)
#define LVM_GETBKIMAGEA         (LVM_FIRST + 69)
#define LVM_GETBKIMAGEW         (LVM_FIRST + 139)

#ifdef UNICODE
#define LVBKIMAGE               LVBKIMAGEW
#define LPLVBKIMAGE             LPLVBKIMAGEW
#define LVM_SETBKIMAGE          LVM_SETBKIMAGEW
#define LVM_GETBKIMAGE          LVM_GETBKIMAGEW
#else
#define LVBKIMAGE               LVBKIMAGEA
#define LPLVBKIMAGE             LPLVBKIMAGEA
#define LVM_SETBKIMAGE          LVM_SETBKIMAGEA
#define LVM_GETBKIMAGE          LVM_GETBKIMAGEA
#endif

#define ListView_SetBkImage(hwnd, plvbki) \
    (BOOL)SNDMSG((hwnd), LVM_SETBKIMAGE, 0, (LPARAM)(plvbki))

#define ListView_GetBkImage(hwnd, plvbki) \
    (BOOL)SNDMSG((hwnd), LVM_GETBKIMAGE, 0, (LPARAM)(plvbki))

#endif      // _WIN32_IE >= 0x0400


#define LVGF_NONE           0x00000000
#define LVGF_HEADER         0x00000001
#define LVGF_FOOTER         0x00000002
#define LVGF_STATE          0x00000004
#define LVGF_ALIGN          0x00000008
#define LVGF_GROUPID        0x00000010

#define LVGS_NORMAL         0x00000000
#define LVGS_COLLAPSED      0x00000001
#define LVGS_HIDDEN         0x00000002
#define LVGS_NOHEADER       0x00000004
#define LVGS_COLLAPSIBLE    0x00000008
#define LVGS_FOCUSED        0x00000010
#define LVGS_SELECTED       0x00000020

#define LVGA_HEADER_LEFT    0x00000001
#define LVGA_HEADER_CENTER  0x00000002
#define LVGA_HEADER_RIGHT   0x00000004  // Don't forget to validate exclusivity
#define LVGA_FOOTER_LEFT    0x00000008
#define LVGA_FOOTER_CENTER  0x00000010
#define LVGA_FOOTER_RIGHT   0x00000020  // Don't forget to validate exclusivity

typedef struct tagLVGROUP
{
    UINT    cbSize;
    UINT    mask;
    LPWSTR  pszHeader;
    int     cchHeader;

    LPWSTR  pszFooter;
    int     cchFooter;

    int     iGroupId;

    UINT    stateMask;
    UINT    state;
    UINT    uAlign;
} LVGROUP, *PLVGROUP;


#define LVM_INSERTGROUP         (LVM_FIRST + 145)
#define ListView_InsertGroup(hwnd, index, pgrp) \
    SNDMSG((hwnd), LVM_INSERTGROUP, (WPARAM)index, (LPARAM)pgrp)


#define LVM_SETGROUPINFO         (LVM_FIRST + 147)
#define ListView_SetGroupInfo(hwnd, iGroupId, pgrp) \
    SNDMSG((hwnd), LVM_SETGROUPINFO, (WPARAM)iGroupId, (LPARAM)pgrp)


#define LVM_GETGROUPINFO         (LVM_FIRST + 149)
#define ListView_GetGroupInfo(hwnd, iGroupId, pgrp) \
    SNDMSG((hwnd), LVM_GETGROUPINFO, (WPARAM)iGroupId, (LPARAM)pgrp)


#define LVM_REMOVEGROUP         (LVM_FIRST + 150)
#define ListView_RemoveGroup(hwnd, iGroupId) \
    SNDMSG((hwnd), LVM_REMOVEGROUP, (WPARAM)iGroupId, 0)

#define LVM_MOVEGROUP         (LVM_FIRST + 151)
#define ListView_MoveGroup(hwnd, iGroupId, toIndex) \
    SNDMSG((hwnd), LVM_MOVEGROUP, (WPARAM)iGroupId, (LPARAM)toIndex)

#define LVM_GETGROUPCOUNT         (LVM_FIRST + 152)
#define ListView_GetGroupCount(hwnd) \
    SNDMSG((hwnd), LVM_GETGROUPCOUNT, (WPARAM)0, (LPARAM)0)

#define LVM_GETGROUPINFOBYINDEX         (LVM_FIRST + 153)
#define ListView_GetGroupInfoByIndex(hwnd, iIndex, pgrp) \
    SNDMSG((hwnd), LVM_GETGROUPINFOBYINDEX, (WPARAM)iIndex, (LPARAM)pgrp)

#define LVM_MOVEITEMTOGROUP            (LVM_FIRST + 154)
#define ListView_MoveItemToGroup(hwnd, idItemFrom, idGroupTo) \
    SNDMSG((hwnd), LVM_MOVEITEMTOGROUP, (WPARAM)idItemFrom, (LPARAM)idGroupTo)


#define LVGMF_NONE          0x00000000
#define LVGMF_BORDERSIZE    0x00000001
#define LVGMF_BORDERCOLOR   0x00000002
#define LVGMF_TEXTCOLOR     0x00000004

typedef struct tagLVGROUPMETRICS
{
    UINT cbSize;
    UINT mask;
    UINT Left;
    UINT Top;
    UINT Right;
    UINT Bottom;
    COLORREF crLeft;
    COLORREF crTop;
    COLORREF crRight;
    COLORREF crBottom;
    COLORREF crHeader;
    COLORREF crFooter;
} LVGROUPMETRICS, *PLVGROUPMETRICS;

#define LVM_SETGROUPMETRICS         (LVM_FIRST + 155)
#define ListView_SetGroupMetrics(hwnd, pGroupMetrics) \
    SNDMSG((hwnd), LVM_SETGROUPMETRICS, 0, (LPARAM)pGroupMetrics)

#define LVM_GETGROUPMETRICS         (LVM_FIRST + 156)
#define ListView_GetGroupMetrics(hwnd, pGroupMetrics) \
    SNDMSG((hwnd), LVM_GETGROUPMETRICS, 0, (LPARAM)pGroupMetrics)

#define LVM_ENABLEGROUPVIEW         (LVM_FIRST + 157)
#define ListView_EnableGroupView(hwnd, fEnable) \
    SNDMSG((hwnd), LVM_ENABLEGROUPVIEW, (WPARAM)fEnable, 0)

typedef int (CALLBACK *PFNLVGROUPCOMPARE)(int, int, void *);

#define LVM_SORTGROUPS         (LVM_FIRST + 158)
#define ListView_SortGroups(hwnd, _pfnGroupCompare, _plv) \
    SNDMSG((hwnd), LVM_SORTGROUPS, (WPARAM)_pfnGroupCompare, (LPARAM)_plv)

typedef struct tagLVINSERTGROUPSORTED
{
    PFNLVGROUPCOMPARE pfnGroupCompare;
    void *pvData;
    LVGROUP lvGroup;
}LVINSERTGROUPSORTED, *PLVINSERTGROUPSORTED;

#define LVM_INSERTGROUPSORTED           (LVM_FIRST + 159)
#define ListView_InsertGroupSorted(hwnd, structInsert) \
    SNDMSG((hwnd), LVM_INSERTGROUPSORTED, (WPARAM)structInsert, 0)

#define LVM_REMOVEALLGROUPS             (LVM_FIRST + 160)
#define ListView_RemoveAllGroups(hwnd) \
    SNDMSG((hwnd), LVM_REMOVEALLGROUPS, 0, 0)

#define LVM_HASGROUP                    (LVM_FIRST + 161)
#define ListView_HasGroup(hwnd, dwGroupId) \
    SNDMSG((hwnd), LVM_HASGROUP, dwGroupId, 0)

typedef struct tagLVSETINFOTIP
{
    UINT cbSize;
    DWORD dwFlags;
    LPWSTR pszText;
    int iItem;
    int iSubItem;
} LVSETINFOTIP, *PLVSETINFOTIP;

#define  LVM_SETINFOTIP         (LVM_FIRST + 173)
#define ListView_SetInfoTip(hwndLV, plvInfoTip)\
        (BOOL)SNDMSG((hwndLV), LVM_SETINFOTIP, (WPARAM)0, (LPARAM)(plvInfoTip))

#define LVM_ISGROUPVIEWENABLED  (LVM_FIRST + 175)
#define ListView_IsGroupViewEnabled(hwnd) \
    (BOOL)SNDMSG((hwnd), LVM_ISGROUPVIEWENABLED, 0, 0)


// These next to methods make it easy to identify an item that can be repositioned
// within listview. For example: Many developers use the lParam to store an identifier that is
// unique. Unfortunatly, in order to find this item, they have to iterate through all of the items
// in the listview. Listview will maintain a unique identifier.  The upper bound is the size of a DWORD.
#define LVM_MAPINDEXTOID     (LVM_FIRST + 180)
#define ListView_MapIndexToID(hwnd, index) \
    (UINT)SNDMSG((hwnd), LVM_MAPINDEXTOID, (WPARAM)index, (LPARAM)0)

#define LVM_MAPIDTOINDEX     (LVM_FIRST + 181)
#define ListView_MapIDToIndex(hwnd, id) \
    (UINT)SNDMSG((hwnd), LVM_MAPIDTOINDEX, (WPARAM)id, (LPARAM)0)


#if (_WIN32_IE >= 0x0300)
#define LPNM_LISTVIEW   LPNMLISTVIEW
#define NM_LISTVIEW     NMLISTVIEW
#else
#define tagNMLISTVIEW   _NM_LISTVIEW
#define    NMLISTVIEW    NM_LISTVIEW
#define  LPNMLISTVIEW  LPNM_LISTVIEW
#endif

typedef struct tagNMLISTVIEW
{
    NMHDR   hdr;
    int     iItem;
    int     iSubItem;
    UINT    uNewState;
    UINT    uOldState;
    UINT    uChanged;
    POINT   ptAction;
    LPARAM  lParam;
} NMLISTVIEW, FAR *LPNMLISTVIEW;


#if (_WIN32_IE >= 0x0300)
typedef struct tagNMLVCUSTOMDRAW
{
    NMCUSTOMDRAW nmcd;
    COLORREF clrText;
    COLORREF clrTextBk;
#if (_WIN32_IE >= 0x0400)
    int iSubItem;
#endif
    DWORD dwItemType;

    // Group Custom Draw
    RECT rcText;
    UINT uAlign;      // Alignment. Use LVGA_HEADER_CENTER, LVGA_HEADER_RIGHT, LVGA_HEADER_LEFT
} NMLVCUSTOMDRAW, *LPNMLVCUSTOMDRAW;

// dwItemType
#define LVCDI_ITEM      0x00000000
#define LVCDI_GROUP     0x00000001

// ListView custom draw return values
#define LVCDRF_NOSELECT             0x00010000
#define LVCDRF_NOGROUPFRAME         0x00020000  


typedef struct tagNMLVCACHEHINT
{
    NMHDR   hdr;
    int     iFrom;
    int     iTo;
} NMLVCACHEHINT, FAR *LPNMLVCACHEHINT;

#define LPNM_CACHEHINT  LPNMLVCACHEHINT
#define PNM_CACHEHINT   LPNMLVCACHEHINT
#define NM_CACHEHINT    NMLVCACHEHINT

typedef struct tagNMLVFINDITEM
{
    NMHDR   hdr;
    int     iStart;
    LVFINDINFO lvfi;
} NMLVFINDITEM, FAR *LPNMLVFINDITEM;

#define PNM_FINDITEM    LPNMLVFINDITEM
#define LPNM_FINDITEM   LPNMLVFINDITEM
#define NM_FINDITEM     NMLVFINDITEM

typedef struct tagNMLVODSTATECHANGE
{
    NMHDR hdr;
    int iFrom;
    int iTo;
    UINT uNewState;
    UINT uOldState;
} NMLVODSTATECHANGE, FAR *LPNMLVODSTATECHANGE;

#define PNM_ODSTATECHANGE   LPNMLVODSTATECHANGE
#define LPNM_ODSTATECHANGE  LPNMLVODSTATECHANGE
#define NM_ODSTATECHANGE    NMLVODSTATECHANGE
#endif      // _WIN32_IE >= 0x0300


#define LVN_ITEMCHANGING        (LVN_FIRST-0)
#define LVN_ITEMCHANGED         (LVN_FIRST-1)
#define LVN_INSERTITEM          (LVN_FIRST-2)
#define LVN_DELETEITEM          (LVN_FIRST-3)
#define LVN_DELETEALLITEMS      (LVN_FIRST-4)
#define LVN_BEGINLABELEDITA     (LVN_FIRST-5)
#define LVN_BEGINLABELEDITW     (LVN_FIRST-75)
#define LVN_ENDLABELEDITA       (LVN_FIRST-6)
#define LVN_ENDLABELEDITW       (LVN_FIRST-76)
#define LVN_COLUMNCLICK         (LVN_FIRST-8)
#define LVN_BEGINDRAG           (LVN_FIRST-9)
#define LVN_BEGINRDRAG          (LVN_FIRST-11)

#if (_WIN32_IE >= 0x0300)
#define LVN_ODCACHEHINT         (LVN_FIRST-13)
#define LVN_ODFINDITEMA         (LVN_FIRST-52)
#define LVN_ODFINDITEMW         (LVN_FIRST-79)

#define LVN_ITEMACTIVATE        (LVN_FIRST-14)
#define LVN_ODSTATECHANGED      (LVN_FIRST-15)

#ifdef UNICODE
#define LVN_ODFINDITEM          LVN_ODFINDITEMW
#else
#define LVN_ODFINDITEM          LVN_ODFINDITEMA
#endif
#endif      // _WIN32_IE >= 0x0300

#define LVN_GETDISPINFOA        (LVN_FIRST-50)
#define LVN_GETDISPINFOW        (LVN_FIRST-77)
#define LVN_SETDISPINFOA        (LVN_FIRST-51)
#define LVN_SETDISPINFOW        (LVN_FIRST-78)

#ifdef UNICODE
#define LVN_BEGINLABELEDIT      LVN_BEGINLABELEDITW
#define LVN_ENDLABELEDIT        LVN_ENDLABELEDITW
#define LVN_GETDISPINFO         LVN_GETDISPINFOW
#define LVN_SETDISPINFO         LVN_SETDISPINFOW
#else
#define LVN_BEGINLABELEDIT      LVN_BEGINLABELEDITA
#define LVN_ENDLABELEDIT        LVN_ENDLABELEDITA
#define LVN_GETDISPINFO         LVN_GETDISPINFOA
#define LVN_SETDISPINFO         LVN_SETDISPINFOA
#endif

#ifdef UNDER_CE
#define LVBD_DRAGSELECT         200
#endif // UNDER_CE

#define LVIF_DI_SETITEM         0x1000

#if (_WIN32_IE >= 0x0300)
#define LV_DISPINFOA    NMLVDISPINFOA
#define LV_DISPINFOW    NMLVDISPINFOW
#else
#define tagLVDISPINFO   _LV_DISPINFO
#define NMLVDISPINFOA    LV_DISPINFOA
#define tagLVDISPINFOW  _LV_DISPINFOW
#define NMLVDISPINFOW    LV_DISPINFOW
#endif

#define LV_DISPINFO     NMLVDISPINFO

typedef struct tagLVDISPINFO {
    NMHDR hdr;
    LVITEMA item;
} NMLVDISPINFOA, FAR *LPNMLVDISPINFOA;

typedef struct tagLVDISPINFOW {
    NMHDR hdr;
    LVITEMW item;
} NMLVDISPINFOW, FAR * LPNMLVDISPINFOW;

#ifdef UNICODE
#define  NMLVDISPINFO           NMLVDISPINFOW
#else
#define  NMLVDISPINFO           NMLVDISPINFOA
#endif

#define LVN_KEYDOWN             (LVN_FIRST-55)

#if (_WIN32_IE >= 0x0300)
#define LV_KEYDOWN              NMLVKEYDOWN
#else
#define tagLVKEYDOWN            _LV_KEYDOWN
#define NMLVKEYDOWN              LV_KEYDOWN
#endif

typedef struct tagLVKEYDOWN
{
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} NMLVKEYDOWN, FAR *LPNMLVKEYDOWN;

#if (_WIN32_IE >= 0x0300)
#define LVN_MARQUEEBEGIN        (LVN_FIRST-56)
#endif

#if (_WIN32_IE >= 0x0400)
typedef struct tagNMLVGETINFOTIPA
{
    NMHDR hdr;
    DWORD dwFlags;
    LPSTR pszText;
    int cchTextMax;
    int iItem;
    int iSubItem;
    LPARAM lParam;
} NMLVGETINFOTIPA, *LPNMLVGETINFOTIPA;

typedef struct tagNMLVGETINFOTIPW
{
    NMHDR hdr;
    DWORD dwFlags;
    LPWSTR pszText;
    int cchTextMax;
    int iItem;
    int iSubItem;
    LPARAM lParam;
} NMLVGETINFOTIPW, *LPNMLVGETINFOTIPW;

// NMLVGETINFOTIPA.dwFlag values

#define LVGIT_UNFOLDED  0x0001

#define LVN_GETINFOTIPA          (LVN_FIRST-57)
#define LVN_GETINFOTIPW          (LVN_FIRST-58)

#ifdef UNICODE
#define LVN_GETINFOTIP          LVN_GETINFOTIPW
#define NMLVGETINFOTIP          NMLVGETINFOTIPW
#define LPNMLVGETINFOTIP        LPNMLVGETINFOTIPW
#else
#define LVN_GETINFOTIP          LVN_GETINFOTIPA
#define NMLVGETINFOTIP          NMLVGETINFOTIPA
#define LPNMLVGETINFOTIP        LPNMLVGETINFOTIPA
#endif

#endif      // _WIN32_IE >= 0x0400

#endif // NOLISTVIEW

//====== TREEVIEW CONTROL =====================================================

#ifndef NOTREEVIEW

#ifdef _WIN32
#define WC_TREEVIEWA            "SysTreeView32"
#define WC_TREEVIEWW            L"SysTreeView32"

#ifdef UNICODE
#define  WC_TREEVIEW            WC_TREEVIEWW
#else
#define  WC_TREEVIEW            WC_TREEVIEWA
#endif

#else
#define WC_TREEVIEW             "SysTreeView"
#endif

// begin_r_commctrl

#define TVS_HASBUTTONS          0x0001
#define TVS_HASLINES            0x0002
#define TVS_LINESATROOT         0x0004
#define TVS_EDITLABELS          0x0008
#define TVS_DISABLEDRAGDROP     0x0010
#define TVS_SHOWSELALWAYS       0x0020
#if (_WIN32_IE >= 0x0300)
#define TVS_RTLREADING          0x0040

#define TVS_NOTOOLTIPS          0x0080
#define TVS_CHECKBOXES          0x0100
#define TVS_TRACKSELECT         0x0200
#if (_WIN32_IE >= 0x0400)
#define TVS_SINGLEEXPAND        0x0400
#endif

#endif

// end_r_commctrl

typedef struct _TREEITEM FAR* HTREEITEM;

#define TVIF_TEXT               0x0001
#define TVIF_IMAGE              0x0002
#define TVIF_PARAM              0x0004
#define TVIF_STATE              0x0008
#define TVIF_HANDLE             0x0010
#define TVIF_SELECTEDIMAGE      0x0020
#define TVIF_CHILDREN           0x0040

#define TVIS_SELECTED           0x0002
#define TVIS_CUT                0x0004
#define TVIS_DROPHILITED        0x0008
#define TVIS_BOLD               0x0010
#define TVIS_EXPANDED           0x0020
#define TVIS_EXPANDEDONCE       0x0040
#if (_WIN32_IE >= 0x0300)
#define TVIS_EXPANDPARTIAL      0x0080
#endif

#define TVIS_OVERLAYMASK        0x0F00
#define TVIS_STATEIMAGEMASK     0xF000
#define TVIS_USERMASK           0xF000


#define I_CHILDRENCALLBACK  (-1)

#if (_WIN32_IE >= 0x0300)
#define LPTV_ITEMW              LPTVITEMW
#define LPTV_ITEMA              LPTVITEMA
#define TV_ITEMW                TVITEMW
#define TV_ITEMA                TVITEMA
#else
#define tagTVITEMA             _TV_ITEMA
#define    TVITEMA              TV_ITEMA
#define  LPTVITEMA            LPTV_ITEMA
#define tagTVITEMW             _TV_ITEMW
#define    TVITEMW              TV_ITEMW
#define  LPTVITEMW            LPTV_ITEMW
#endif

#define LPTV_ITEM               LPTVITEM
#define TV_ITEM                 TVITEM

typedef struct tagTVITEMA {
    UINT      mask;
    HTREEITEM hItem;
    UINT      state;
    UINT      stateMask;
    LPSTR     pszText;
    int       cchTextMax;
    int       iImage;
    int       iSelectedImage;
    int       cChildren;
    LPARAM    lParam;
} TVITEMA, FAR *LPTVITEMA;

typedef struct tagTVITEMW {
    UINT      mask;
    HTREEITEM hItem;
    UINT      state;
    UINT      stateMask;
    LPWSTR    pszText;
    int       cchTextMax;
    int       iImage;
    int       iSelectedImage;
    int       cChildren;
    LPARAM    lParam;
} TVITEMW, FAR *LPTVITEMW;

#ifdef UNICODE
#define  TVITEM                 TVITEMW
#define  LPTVITEM               LPTVITEMW
#else
#define  TVITEM                 TVITEMA
#define  LPTVITEM               LPTVITEMA
#endif


#define TVI_ROOT                ((HTREEITEM)0xFFFF0000)
#define TVI_FIRST               ((HTREEITEM)0xFFFF0001)
#define TVI_LAST                ((HTREEITEM)0xFFFF0002)
#define TVI_SORT                ((HTREEITEM)0xFFFF0003)

#if (_WIN32_IE >= 0x0300)
#define LPTV_INSERTSTRUCTA      LPTVINSERTSTRUCTA
#define LPTV_INSERTSTRUCTW      LPTVINSERTSTRUCTW
#define TV_INSERTSTRUCTA        TVINSERTSTRUCTA
#define TV_INSERTSTRUCTW        TVINSERTSTRUCTW
#else
#define tagTVINSERTSTRUCTA     _TV_INSERTSTRUCTA
#define    TVINSERTSTRUCTA      TV_INSERTSTRUCTA
#define  LPTVINSERTSTRUCTA    LPTV_INSERTSTRUCTA
#define tagTVINSERTSTRUCTW     _TV_INSERTSTRUCTW
#define    TVINSERTSTRUCTW      TV_INSERTSTRUCTW
#define  LPTVINSERTSTRUCTW    LPTV_INSERTSTRUCTW
#endif

#define TV_INSERTSTRUCT         TVINSERTSTRUCT
#define LPTV_INSERTSTRUCT       LPTVINSERTSTRUCT

typedef struct tagTVINSERTSTRUCTA {
    HTREEITEM hParent;
    HTREEITEM hInsertAfter;
    TV_ITEMA item;
} TVINSERTSTRUCTA, FAR *LPTVINSERTSTRUCTA;

typedef struct tagTVINSERTSTRUCTW {
    HTREEITEM hParent;
    HTREEITEM hInsertAfter;
    TV_ITEMW item;
} TVINSERTSTRUCTW, FAR *LPTVINSERTSTRUCTW;

#ifdef UNICODE
#define  TVINSERTSTRUCT         TVINSERTSTRUCTW
#define  LPTVINSERTSTRUCT       LPTVINSERTSTRUCTW
#else
#define  TVINSERTSTRUCT         TVINSERTSTRUCTA
#define  LPTVINSERTSTRUCT       LPTVINSERTSTRUCTA
#endif

#define TVM_INSERTITEMA         (TV_FIRST + 0)
#define TVM_INSERTITEMW         (TV_FIRST + 50)
#ifdef UNICODE
#define  TVM_INSERTITEM         TVM_INSERTITEMW
#else
#define  TVM_INSERTITEM         TVM_INSERTITEMA
#endif

#define TreeView_InsertItem(hwnd, lpis) \
    (HTREEITEM)SNDMSG((hwnd), TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(lpis))


#define TVM_DELETEITEM          (TV_FIRST + 1)
#define TreeView_DeleteItem(hwnd, hitem) \
    (BOOL)SNDMSG((hwnd), TVM_DELETEITEM, 0, (LPARAM)(HTREEITEM)(hitem))


#define TreeView_DeleteAllItems(hwnd) \
    (BOOL)SNDMSG((hwnd), TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT)


#define TVM_EXPAND              (TV_FIRST + 2)
#define TreeView_Expand(hwnd, hitem, code) \
    (BOOL)SNDMSG((hwnd), TVM_EXPAND, (WPARAM)code, (LPARAM)(HTREEITEM)(hitem))


#define TVE_COLLAPSE            0x0001
#define TVE_EXPAND              0x0002
#define TVE_TOGGLE              0x0003
#if (_WIN32_IE >= 0x0300)
#define TVE_EXPANDPARTIAL       0x4000
#endif
#define TVE_COLLAPSERESET       0x8000


#define TVM_GETITEMRECT         (TV_FIRST + 4)
#define TreeView_GetItemRect(hwnd, hitem, prc, code) \
    (*(HTREEITEM FAR *)prc = (hitem), (BOOL)SNDMSG((hwnd), TVM_GETITEMRECT, (WPARAM)(code), (LPARAM)(RECT FAR*)(prc)))


#define TVM_GETCOUNT            (TV_FIRST + 5)
#define TreeView_GetCount(hwnd) \
    (UINT)SNDMSG((hwnd), TVM_GETCOUNT, 0, 0)


#define TVM_GETINDENT           (TV_FIRST + 6)
#define TreeView_GetIndent(hwnd) \
    (UINT)SNDMSG((hwnd), TVM_GETINDENT, 0, 0)


#define TVM_SETINDENT           (TV_FIRST + 7)
#define TreeView_SetIndent(hwnd, indent) \
    (BOOL)SNDMSG((hwnd), TVM_SETINDENT, (WPARAM)indent, 0)


#define TVM_GETIMAGELIST        (TV_FIRST + 8)
#define TreeView_GetImageList(hwnd, iImage) \
    (HIMAGELIST)SNDMSG((hwnd), TVM_GETIMAGELIST, iImage, 0)


#define TVSIL_NORMAL            0
#define TVSIL_STATE             2


#define TVM_SETIMAGELIST        (TV_FIRST + 9)
#define TreeView_SetImageList(hwnd, himl, iImage) \
    (HIMAGELIST)SNDMSG((hwnd), TVM_SETIMAGELIST, iImage, (LPARAM)(UINT)(HIMAGELIST)(himl))


#define TVM_GETNEXTITEM         (TV_FIRST + 10)
#define TreeView_GetNextItem(hwnd, hitem, code) \
    (HTREEITEM)SNDMSG((hwnd), TVM_GETNEXTITEM, (WPARAM)code, (LPARAM)(HTREEITEM)(hitem))


#define TVGN_ROOT               0x0000
#define TVGN_NEXT               0x0001
#define TVGN_PREVIOUS           0x0002
#define TVGN_PARENT             0x0003
#define TVGN_CHILD              0x0004
#define TVGN_FIRSTVISIBLE       0x0005
#define TVGN_NEXTVISIBLE        0x0006
#define TVGN_PREVIOUSVISIBLE    0x0007
#define TVGN_DROPHILITE         0x0008
#define TVGN_CARET              0x0009

#define TreeView_GetChild(hwnd, hitem)          TreeView_GetNextItem(hwnd, hitem, TVGN_CHILD)
#define TreeView_GetNextSibling(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_NEXT)
#define TreeView_GetPrevSibling(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_PREVIOUS)
#define TreeView_GetParent(hwnd, hitem)         TreeView_GetNextItem(hwnd, hitem, TVGN_PARENT)
#define TreeView_GetFirstVisible(hwnd)          TreeView_GetNextItem(hwnd, NULL,  TVGN_FIRSTVISIBLE)
#define TreeView_GetNextVisible(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_NEXTVISIBLE)
#define TreeView_GetPrevVisible(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_PREVIOUSVISIBLE)
#define TreeView_GetSelection(hwnd)             TreeView_GetNextItem(hwnd, NULL,  TVGN_CARET)
#define TreeView_GetDropHilight(hwnd)           TreeView_GetNextItem(hwnd, NULL,  TVGN_DROPHILITE)
#define TreeView_GetRoot(hwnd)                  TreeView_GetNextItem(hwnd, NULL,  TVGN_ROOT)


#define TVM_SELECTITEM          (TV_FIRST + 11)
#define TreeView_Select(hwnd, hitem, code) \
    (BOOL)SNDMSG((hwnd), TVM_SELECTITEM, (WPARAM)code, (LPARAM)(HTREEITEM)(hitem))


#define TreeView_SelectItem(hwnd, hitem)            TreeView_Select(hwnd, hitem, TVGN_CARET)
#define TreeView_SelectDropTarget(hwnd, hitem)      TreeView_Select(hwnd, hitem, TVGN_DROPHILITE)
#define TreeView_SelectSetFirstVisible(hwnd, hitem) TreeView_Select(hwnd, hitem, TVGN_FIRSTVISIBLE)


#define TVM_GETITEMA            (TV_FIRST + 12)
#define TVM_GETITEMW            (TV_FIRST + 62)

#ifdef UNICODE
#define  TVM_GETITEM            TVM_GETITEMW
#else
#define  TVM_GETITEM            TVM_GETITEMA
#endif

#define TreeView_GetItem(hwnd, pitem) \
    (BOOL)SNDMSG((hwnd), TVM_GETITEM, 0, (LPARAM)(TV_ITEM FAR*)(pitem))


#define TVM_SETITEMA            (TV_FIRST + 13)
#define TVM_SETITEMW            (TV_FIRST + 63)

#ifdef UNICODE
#define  TVM_SETITEM            TVM_SETITEMW
#else
#define  TVM_SETITEM            TVM_SETITEMA
#endif

#define TreeView_SetItem(hwnd, pitem) \
    (BOOL)SNDMSG((hwnd), TVM_SETITEM, 0, (LPARAM)(const TV_ITEM FAR*)(pitem))


#define TVM_EDITLABELA          (TV_FIRST + 14)
#define TVM_EDITLABELW          (TV_FIRST + 65)
#ifdef UNICODE
#define TVM_EDITLABEL           TVM_EDITLABELW
#else
#define TVM_EDITLABEL           TVM_EDITLABELA
#endif

#define TreeView_EditLabel(hwnd, hitem) \
    (HWND)SNDMSG((hwnd), TVM_EDITLABEL, 0, (LPARAM)(HTREEITEM)(hitem))


#define TVM_GETEDITCONTROL      (TV_FIRST + 15)
#define TreeView_GetEditControl(hwnd) \
    (HWND)SNDMSG((hwnd), TVM_GETEDITCONTROL, 0, 0)


#define TVM_GETVISIBLECOUNT     (TV_FIRST + 16)
#define TreeView_GetVisibleCount(hwnd) \
    (UINT)SNDMSG((hwnd), TVM_GETVISIBLECOUNT, 0, 0)


#define TVM_HITTEST             (TV_FIRST + 17)
#define TreeView_HitTest(hwnd, lpht) \
    (HTREEITEM)SNDMSG((hwnd), TVM_HITTEST, 0, (LPARAM)(LPTV_HITTESTINFO)(lpht))


#if (_WIN32_IE >= 0x0300)
#define LPTV_HITTESTINFO   LPTVHITTESTINFO
#define   TV_HITTESTINFO     TVHITTESTINFO
#else
#define tagTVHITTESTINFO    _TV_HITTESTINFO
#define    TVHITTESTINFO     TV_HITTESTINFO
#define  LPTVHITTESTINFO   LPTV_HITTESTINFO
#endif

typedef struct tagTVHITTESTINFO {
    POINT       pt;
    UINT        flags;
    HTREEITEM   hItem;
} TVHITTESTINFO, FAR *LPTVHITTESTINFO;

#define TVHT_NOWHERE            0x0001
#define TVHT_ONITEMICON         0x0002
#define TVHT_ONITEMLABEL        0x0004
#define TVHT_ONITEM             (TVHT_ONITEMICON | TVHT_ONITEMLABEL | TVHT_ONITEMSTATEICON)
#define TVHT_ONITEMINDENT       0x0008
#define TVHT_ONITEMBUTTON       0x0010
#define TVHT_ONITEMRIGHT        0x0020
#define TVHT_ONITEMSTATEICON    0x0040

#define TVHT_ABOVE              0x0100
#define TVHT_BELOW              0x0200
#define TVHT_TORIGHT            0x0400
#define TVHT_TOLEFT             0x0800


#define TVM_CREATEDRAGIMAGE     (TV_FIRST + 18)
#define TreeView_CreateDragImage(hwnd, hitem) \
    (HIMAGELIST)SNDMSG((hwnd), TVM_CREATEDRAGIMAGE, 0, (LPARAM)(HTREEITEM)(hitem))


#define TVM_SORTCHILDREN        (TV_FIRST + 19)
#define TreeView_SortChildren(hwnd, hitem, recurse) \
    (BOOL)SNDMSG((hwnd), TVM_SORTCHILDREN, (WPARAM)recurse, (LPARAM)(HTREEITEM)(hitem))


#define TVM_ENSUREVISIBLE       (TV_FIRST + 20)
#define TreeView_EnsureVisible(hwnd, hitem) \
    (BOOL)SNDMSG((hwnd), TVM_ENSUREVISIBLE, 0, (LPARAM)(HTREEITEM)(hitem))


#define TVM_SORTCHILDRENCB      (TV_FIRST + 21)
#define TreeView_SortChildrenCB(hwnd, psort, recurse) \
    (BOOL)SNDMSG((hwnd), TVM_SORTCHILDRENCB, (WPARAM)recurse, \
    (LPARAM)(LPTV_SORTCB)(psort))


#define TVM_ENDEDITLABELNOW     (TV_FIRST + 22)
#define TreeView_EndEditLabelNow(hwnd, fCancel) \
    (BOOL)SNDMSG((hwnd), TVM_ENDEDITLABELNOW, (WPARAM)fCancel, 0)


#define TVM_GETISEARCHSTRINGA   (TV_FIRST + 23)
#define TVM_GETISEARCHSTRINGW   (TV_FIRST + 64)

#ifdef UNICODE
#define TVM_GETISEARCHSTRING     TVM_GETISEARCHSTRINGW
#else
#define TVM_GETISEARCHSTRING     TVM_GETISEARCHSTRINGA
#endif

#define TreeView_GetISearchString(hwndTV, lpsz) \
        (BOOL)SNDMSG((hwndTV), TVM_GETISEARCHSTRING, 0, (LPARAM)(LPTSTR)lpsz)

// lparam = y spacing between items
#define TVM_SETITEMSPACING      (TV_FIRST + 56)


typedef int (CALLBACK *PFNTVCOMPARE)(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

#if (_WIN32_IE >= 0x0300)
#define LPTV_SORTCB    LPTVSORTCB
#define   TV_SORTCB      TVSORTCB
#else
#define tagTVSORTCB    _TV_SORTCB
#define    TVSORTCB     TV_SORTCB
#define  LPTVSORTCB   LPTV_SORTCB
#endif

typedef struct tagTVSORTCB
{
        HTREEITEM       hParent;
        PFNTVCOMPARE    lpfnCompare;
        LPARAM          lParam;
} TVSORTCB, FAR *LPTVSORTCB;


#if (_WIN32_IE >= 0x0300)
#define LPNM_TREEVIEWA          LPNMTREEVIEWA
#define LPNM_TREEVIEWW          LPNMTREEVIEWW
#define NM_TREEVIEWW            NMTREEVIEWW
#define NM_TREEVIEWA            NMTREEVIEWA
#else
#define tagNMTREEVIEWA          _NM_TREEVIEWA
#define tagNMTREEVIEWW          _NM_TREEVIEWW
#define NMTREEVIEWA             NM_TREEVIEWA
#define NMTREEVIEWW             NM_TREEVIEWW
#define LPNMTREEVIEWA           LPNM_TREEVIEWA
#define LPNMTREEVIEWW           LPNM_TREEVIEWW
#endif

#define LPNM_TREEVIEW           LPNMTREEVIEW
#define NM_TREEVIEW             NMTREEVIEW

typedef struct tagNMTREEVIEWA {
    NMHDR       hdr;
    UINT        action;
    TVITEMA    itemOld;
    TVITEMA    itemNew;
    POINT       ptDrag;
} NMTREEVIEWA, FAR *LPNMTREEVIEWA;


typedef struct tagNMTREEVIEWW {
    NMHDR       hdr;
    UINT        action;
    TVITEMW    itemOld;
    TVITEMW    itemNew;
    POINT       ptDrag;
} NMTREEVIEWW, FAR *LPNMTREEVIEWW;


#ifdef UNICODE
#define  NMTREEVIEW             NMTREEVIEWW
#define  LPNMTREEVIEW           LPNMTREEVIEWW
#else
#define  NMTREEVIEW             NMTREEVIEWA
#define  LPNMTREEVIEW           LPNMTREEVIEWA
#endif


#define TVN_SELCHANGINGA        (TVN_FIRST-1)
#define TVN_SELCHANGINGW        (TVN_FIRST-50)
#define TVN_SELCHANGEDA         (TVN_FIRST-2)
#define TVN_SELCHANGEDW         (TVN_FIRST-51)

#define TVC_UNKNOWN             0x0000
#define TVC_BYMOUSE             0x0001
#define TVC_BYKEYBOARD          0x0002

#define TVN_GETDISPINFOA        (TVN_FIRST-3)
#define TVN_GETDISPINFOW        (TVN_FIRST-52)
#define TVN_SETDISPINFOA        (TVN_FIRST-4)
#define TVN_SETDISPINFOW        (TVN_FIRST-53)

#define TVIF_DI_SETITEM         0x1000

#if (_WIN32_IE >= 0x0300)
#define TV_DISPINFOA            NMTVDISPINFOA
#define TV_DISPINFOW            NMTVDISPINFOW
#else
#define tagTVDISPINFOA  _TV_DISPINFOA
#define NMTVDISPINFOA    TV_DISPINFOA
#define tagTVDISPINFOW  _TV_DISPINFOW
#define NMTVDISPINFOW    TV_DISPINFOW
#endif

#define TV_DISPINFO             NMTVDISPINFO

typedef struct tagTVDISPINFOA {
    NMHDR hdr;
    TVITEMA item;
} NMTVDISPINFOA, FAR *LPNMTVDISPINFOA;

typedef struct tagTVDISPINFOW {
    NMHDR hdr;
    TVITEMW item;
} NMTVDISPINFOW, FAR *LPNMTVDISPINFOW;


#ifdef UNICODE
#define NMTVDISPINFO            NMTVDISPINFOW
#define LPNMTVDISPINFO          LPNMTVDISPINFOW
#else
#define NMTVDISPINFO            NMTVDISPINFOA
#define LPNMTVDISPINFO          LPNMTVDISPINFOA
#endif

#define TVN_ITEMEXPANDINGA      (TVN_FIRST-5)
#define TVN_ITEMEXPANDINGW      (TVN_FIRST-54)
#define TVN_ITEMEXPANDEDA       (TVN_FIRST-6)
#define TVN_ITEMEXPANDEDW       (TVN_FIRST-55)
#define TVN_BEGINDRAGA          (TVN_FIRST-7)
#define TVN_BEGINDRAGW          (TVN_FIRST-56)
#define TVN_BEGINRDRAGA         (TVN_FIRST-8)
#define TVN_BEGINRDRAGW         (TVN_FIRST-57)
#define TVN_DELETEITEMA         (TVN_FIRST-9)
#define TVN_DELETEITEMW         (TVN_FIRST-58)
#define TVN_BEGINLABELEDITA     (TVN_FIRST-10)
#define TVN_BEGINLABELEDITW     (TVN_FIRST-59)
#define TVN_ENDLABELEDITA       (TVN_FIRST-11)
#define TVN_ENDLABELEDITW       (TVN_FIRST-60)
#define TVN_KEYDOWN             (TVN_FIRST-12)

#if (_WIN32_IE >= 0x0300)
#define TV_KEYDOWN      NMTVKEYDOWN
#else
#define tagTVKEYDOWN    _TV_KEYDOWN
#define  NMTVKEYDOWN     TV_KEYDOWN
#endif

typedef struct tagTVKEYDOWN {
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} NMTVKEYDOWN, FAR *LPNMTVKEYDOWN;


#ifdef UNICODE
#define TVN_SELCHANGING         TVN_SELCHANGINGW
#define TVN_SELCHANGED          TVN_SELCHANGEDW
#define TVN_GETDISPINFO         TVN_GETDISPINFOW
#define TVN_SETDISPINFO         TVN_SETDISPINFOW
#define TVN_ITEMEXPANDING       TVN_ITEMEXPANDINGW
#define TVN_ITEMEXPANDED        TVN_ITEMEXPANDEDW
#define TVN_BEGINDRAG           TVN_BEGINDRAGW
#define TVN_BEGINRDRAG          TVN_BEGINRDRAGW
#define TVN_DELETEITEM          TVN_DELETEITEMW
#define TVN_BEGINLABELEDIT      TVN_BEGINLABELEDITW
#define TVN_ENDLABELEDIT        TVN_ENDLABELEDITW
#else
#define TVN_SELCHANGING         TVN_SELCHANGINGA
#define TVN_SELCHANGED          TVN_SELCHANGEDA
#define TVN_GETDISPINFO         TVN_GETDISPINFOA
#define TVN_SETDISPINFO         TVN_SETDISPINFOA
#define TVN_ITEMEXPANDING       TVN_ITEMEXPANDINGA
#define TVN_ITEMEXPANDED        TVN_ITEMEXPANDEDA
#define TVN_BEGINDRAG           TVN_BEGINDRAGA
#define TVN_BEGINRDRAG          TVN_BEGINRDRAGA
#define TVN_DELETEITEM          TVN_DELETEITEMA
#define TVN_BEGINLABELEDIT      TVN_BEGINLABELEDITA
#define TVN_ENDLABELEDIT        TVN_ENDLABELEDITA
#endif

#if (_WIN32_IE >= 0x0300)
typedef struct tagNMTVCUSTOMDRAW
{
    NMCUSTOMDRAW nmcd;
    COLORREF     clrText;
    COLORREF     clrTextBk;
} NMTVCUSTOMDRAW, *LPNMTVCUSTOMDRAW;
#endif

#endif      // NOTREEVIEW

//====== TAB CONTROL ==========================================================

#ifndef NOTABCONTROL

#ifdef _WIN32

#define WC_TABCONTROLA          "SysTabControl32"
#define WC_TABCONTROLW          L"SysTabControl32"

#ifdef UNICODE
#define  WC_TABCONTROL          WC_TABCONTROLW
#else
#define  WC_TABCONTROL          WC_TABCONTROLA
#endif

#else
#define WC_TABCONTROL           "SysTabControl"
#endif

// begin_r_commctrl

#if (_WIN32_IE >= 0x0300)
#define TCS_SCROLLOPPOSITE      0x0001   // assumes multiline tab
#define TCS_BOTTOM              0x0002
#define TCS_RIGHT               0x0002
#define TCS_MULTISELECT         0x0004  // allow multi-select in button mode
#endif
#if (_WIN32_IE >= 0x0400)
#define TCS_FLATBUTTONS         0x0008
#endif
#define TCS_FORCEICONLEFT       0x0010
#define TCS_FORCELABELLEFT      0x0020
#if (_WIN32_IE >= 0x0300)
#define TCS_HOTTRACK            0x0040
#define TCS_VERTICAL            0x0080
#endif
#define TCS_TABS                0x0000
#define TCS_BUTTONS             0x0100
#define TCS_SINGLELINE          0x0000
#define TCS_MULTILINE           0x0200
#define TCS_RIGHTJUSTIFY        0x0000
#define TCS_FIXEDWIDTH          0x0400
#define TCS_RAGGEDRIGHT         0x0800
#define TCS_FOCUSONBUTTONDOWN   0x1000
#define TCS_OWNERDRAWFIXED      0x2000
#define TCS_FOCUSNEVER          0x8000

#if (_WIN32_IE >= 0x0400)
// EX styles for CreateWindowEx
#define TCS_EX_FLATSEPARATORS   0x00000001
#endif

// end_r_commctrl

#define TCM_FIRST               0x1300





#define TCM_GETIMAGELIST        (TCM_FIRST + 2)
#define TabCtrl_GetImageList(hwnd) \
    (HIMAGELIST)SNDMSG((hwnd), TCM_GETIMAGELIST, 0, 0L)


#define TCM_SETIMAGELIST        (TCM_FIRST + 3)
#define TabCtrl_SetImageList(hwnd, himl) \
    (HIMAGELIST)SNDMSG((hwnd), TCM_SETIMAGELIST, 0, (LPARAM)(UINT)(HIMAGELIST)(himl))


#define TCM_GETITEMCOUNT        (TCM_FIRST + 4)
#define TabCtrl_GetItemCount(hwnd) \
    (int)SNDMSG((hwnd), TCM_GETITEMCOUNT, 0, 0L)


#define TCIF_TEXT               0x0001
#define TCIF_IMAGE              0x0002
#define TCIF_RTLREADING         0x0004
#define TCIF_PARAM              0x0008
#if (_WIN32_IE >= 0x0300)
#define TCIF_STATE              0x0010


#define TCIS_BUTTONPRESSED      0x0001
#endif
#if (_WIN32_IE >= 0x0400)
#define TCIS_HIGHLIGHTED        0x0002
#endif

#if (_WIN32_IE >= 0x0300)
#define TC_ITEMHEADERA         TCITEMHEADERA
#define TC_ITEMHEADERW         TCITEMHEADERW
#else
#define tagTCITEMHEADERA       _TC_ITEMHEADERA
#define    TCITEMHEADERA        TC_ITEMHEADERA
#define tagTCITEMHEADERW       _TC_ITEMHEADERW
#define    TCITEMHEADERW        TC_ITEMHEADERW
#endif
#define TC_ITEMHEADER          TCITEMHEADER

typedef struct tagTCITEMHEADERA
{
    UINT mask;
    UINT lpReserved1;
    UINT lpReserved2;
    LPSTR pszText;
    int cchTextMax;
    int iImage;
} TCITEMHEADERA, FAR *LPTCITEMHEADERA;

typedef struct tagTCITEMHEADERW
{
    UINT mask;
    UINT lpReserved1;
    UINT lpReserved2;
    LPWSTR pszText;
    int cchTextMax;
    int iImage;
} TCITEMHEADERW, FAR *LPTCITEMHEADERW;

#ifdef UNICODE
#define  TCITEMHEADER          TCITEMHEADERW
#define  LPTCITEMHEADER        LPTCITEMHEADERW
#else
#define  TCITEMHEADER          TCITEMHEADERA
#define  LPTCITEMHEADER        LPTCITEMHEADERA
#endif


#if (_WIN32_IE >= 0x0300)
#define TC_ITEMA                TCITEMA
#define TC_ITEMW                TCITEMW
#else
#define tagTCITEMA              _TC_ITEMA
#define    TCITEMA               TC_ITEMA
#define tagTCITEMW              _TC_ITEMW
#define    TCITEMW               TC_ITEMW
#endif
#define TC_ITEM                 TCITEM

typedef struct tagTCITEMA
{
    UINT mask;
#if (_WIN32_IE >= 0x0300)
    DWORD dwState;
    DWORD dwStateMask;
#else
    UINT lpReserved1;
    UINT lpReserved2;
#endif
    LPSTR pszText;
    int cchTextMax;
    int iImage;

    LPARAM lParam;
} TCITEMA, FAR *LPTCITEMA;

typedef struct tagTCITEMW
{
    UINT mask;
#if (_WIN32_IE >= 0x0300)
    DWORD dwState;
    DWORD dwStateMask;
#else
    UINT lpReserved1;
    UINT lpReserved2;
#endif
    LPWSTR pszText;
    int cchTextMax;
    int iImage;

    LPARAM lParam;
} TCITEMW, FAR *LPTCITEMW;

#ifdef UNICODE
#define  TCITEM                 TCITEMW
#define  LPTCITEM               LPTCITEMW
#else
#define  TCITEM                 TCITEMA
#define  LPTCITEM               LPTCITEMA
#endif


#define TCM_GETITEMA            (TCM_FIRST + 5)
#define TCM_GETITEMW            (TCM_FIRST + 60)

#ifdef UNICODE
#define TCM_GETITEM             TCM_GETITEMW
#else
#define TCM_GETITEM             TCM_GETITEMA
#endif

#define TabCtrl_GetItem(hwnd, iItem, pitem) \
    (BOOL)SNDMSG((hwnd), TCM_GETITEM, (WPARAM)(int)iItem, (LPARAM)(TC_ITEM FAR*)(pitem))


#define TCM_SETITEMA            (TCM_FIRST + 6)
#define TCM_SETITEMW            (TCM_FIRST + 61)

#ifdef UNICODE
#define TCM_SETITEM             TCM_SETITEMW
#else
#define TCM_SETITEM             TCM_SETITEMA
#endif

#define TabCtrl_SetItem(hwnd, iItem, pitem) \
    (BOOL)SNDMSG((hwnd), TCM_SETITEM, (WPARAM)(int)iItem, (LPARAM)(TC_ITEM FAR*)(pitem))


#define TCM_INSERTITEMA         (TCM_FIRST + 7)
#define TCM_INSERTITEMW         (TCM_FIRST + 62)

#ifdef UNICODE
#define TCM_INSERTITEM          TCM_INSERTITEMW
#else
#define TCM_INSERTITEM          TCM_INSERTITEMA
#endif

#define TabCtrl_InsertItem(hwnd, iItem, pitem)   \
    (int)SNDMSG((hwnd), TCM_INSERTITEM, (WPARAM)(int)iItem, (LPARAM)(const TC_ITEM FAR*)(pitem))


#define TCM_DELETEITEM          (TCM_FIRST + 8)
#define TabCtrl_DeleteItem(hwnd, i) \
    (BOOL)SNDMSG((hwnd), TCM_DELETEITEM, (WPARAM)(int)(i), 0L)


#define TCM_DELETEALLITEMS      (TCM_FIRST + 9)
#define TabCtrl_DeleteAllItems(hwnd) \
    (BOOL)SNDMSG((hwnd), TCM_DELETEALLITEMS, 0, 0L)


#define TCM_GETITEMRECT         (TCM_FIRST + 10)
#define TabCtrl_GetItemRect(hwnd, i, prc) \
    (BOOL)SNDMSG((hwnd), TCM_GETITEMRECT, (WPARAM)(int)(i), (LPARAM)(RECT FAR*)(prc))


#define TCM_GETCURSEL           (TCM_FIRST + 11)
#define TabCtrl_GetCurSel(hwnd) \
    (int)SNDMSG((hwnd), TCM_GETCURSEL, 0, 0)


#define TCM_SETCURSEL           (TCM_FIRST + 12)
#define TabCtrl_SetCurSel(hwnd, i) \
    (int)SNDMSG((hwnd), TCM_SETCURSEL, (WPARAM)i, 0)


#define TCHT_NOWHERE            0x0001
#define TCHT_ONITEMICON         0x0002
#define TCHT_ONITEMLABEL        0x0004
#define TCHT_ONITEM             (TCHT_ONITEMICON | TCHT_ONITEMLABEL)

#if (_WIN32_IE >= 0x0300)
#define LPTC_HITTESTINFO        LPTCHITTESTINFO
#define TC_HITTESTINFO          TCHITTESTINFO
#else
#define tagTCHITTESTINFO        _TC_HITTESTINFO
#define    TCHITTESTINFO         TC_HITTESTINFO
#define  LPTCHITTESTINFO       LPTC_HITTESTINFO
#endif

typedef struct tagTCHITTESTINFO
{
    POINT pt;
    UINT flags;
} TCHITTESTINFO, FAR * LPTCHITTESTINFO;

#define TCM_HITTEST             (TCM_FIRST + 13)
#define TabCtrl_HitTest(hwndTC, pinfo) \
    (int)SNDMSG((hwndTC), TCM_HITTEST, 0, (LPARAM)(TC_HITTESTINFO FAR*)(pinfo))


#define TCM_SETITEMEXTRA        (TCM_FIRST + 14)
#define TabCtrl_SetItemExtra(hwndTC, cb) \
    (BOOL)SNDMSG((hwndTC), TCM_SETITEMEXTRA, (WPARAM)(cb), 0L)


#define TCM_ADJUSTRECT          (TCM_FIRST + 40)
#define TabCtrl_AdjustRect(hwnd, bLarger, prc) \
    (int)SNDMSG(hwnd, TCM_ADJUSTRECT, (WPARAM)(BOOL)bLarger, (LPARAM)(RECT FAR *)prc)


#define TCM_SETITEMSIZE         (TCM_FIRST + 41)
#define TabCtrl_SetItemSize(hwnd, x, y) \
    (DWORD)SNDMSG((hwnd), TCM_SETITEMSIZE, 0, MAKELPARAM(x,y))


#define TCM_REMOVEIMAGE         (TCM_FIRST + 42)
#define TabCtrl_RemoveImage(hwnd, i) \
        (void)SNDMSG((hwnd), TCM_REMOVEIMAGE, i, 0L)


#define TCM_SETPADDING          (TCM_FIRST + 43)
#define TabCtrl_SetPadding(hwnd,  cx, cy) \
        (void)SNDMSG((hwnd), TCM_SETPADDING, 0, MAKELPARAM(cx, cy))


#define TCM_GETROWCOUNT         (TCM_FIRST + 44)
#define TabCtrl_GetRowCount(hwnd) \
        (int)SNDMSG((hwnd), TCM_GETROWCOUNT, 0, 0L)

#define TCM_GETCURFOCUS         (TCM_FIRST + 47)
#define TabCtrl_GetCurFocus(hwnd) \
    (int)SNDMSG((hwnd), TCM_GETCURFOCUS, 0, 0)

#define TCM_SETCURFOCUS         (TCM_FIRST + 48)
#define TabCtrl_SetCurFocus(hwnd, i) \
    SNDMSG((hwnd),TCM_SETCURFOCUS, i, 0)

#if (_WIN32_IE >= 0x0300)
#define TCM_SETMINTABWIDTH      (TCM_FIRST + 49)
#define TabCtrl_SetMinTabWidth(hwnd, x) \
        (int)SNDMSG((hwnd), TCM_SETMINTABWIDTH, 0, x)


#define TCM_DESELECTALL         (TCM_FIRST + 50)
#define TabCtrl_DeselectAll(hwnd, fExcludeFocus)\
        (void)SNDMSG((hwnd), TCM_DESELECTALL, fExcludeFocus, 0)
#endif

#if (_WIN32_IE >= 0x0400)

#define TCM_HIGHLIGHTITEM       (TCM_FIRST + 51)
#define TabCtrl_HighlightItem(hwnd, i, fHighlight) \
    (BOOL)SNDMSG((hwnd), TCM_HIGHLIGHTITEM, (WPARAM)i, (LPARAM)MAKELONG (fHighlight, 0))

#define TCM_SETEXTENDEDSTYLE    (TCM_FIRST + 52)  // optional wParam == mask
#define TabCtrl_SetExtendedStyle(hwnd, dw)\
        (DWORD)SNDMSG((hwnd), TCM_SETEXTENDEDSTYLE, 0, dw)

#define TCM_GETEXTENDEDSTYLE    (TCM_FIRST + 53)
#define TabCtrl_GetExtendedStyle(hwnd)\
        (DWORD)SNDMSG((hwnd), TCM_GETEXTENDEDSTYLE, 0, 0)

#endif      // _WIN32_IE >= 0x0400

#define TCN_KEYDOWN             (TCN_FIRST - 0)

#if (_WIN32_IE >= 0x0300)
#define TC_KEYDOWN              NMTCKEYDOWN
#else
#define tagTCKEYDOWN            _TC_KEYDOWN
#define  NMTCKEYDOWN             TC_KEYDOWN
#endif

typedef struct tagTCKEYDOWN
{
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} NMTCKEYDOWN;

#define TCN_SELCHANGE           (TCN_FIRST - 1)
#define TCN_SELCHANGING         (TCN_FIRST - 2)

#endif      // NOTABCONTROL


//====== ANIMATE CONTROL ======================================================

#ifndef NOANIMATE

#ifdef _WIN32

#define ANIMATE_CLASSW          L"SysAnimate32"
#define ANIMATE_CLASSA          "SysAnimate32"

#ifdef UNICODE
#define ANIMATE_CLASS           ANIMATE_CLASSW
#else
#define ANIMATE_CLASS           ANIMATE_CLASSA
#endif

// begin_r_commctrl

#define ACS_CENTER              0x0001
#define ACS_TRANSPARENT         0x0002
#define ACS_AUTOPLAY            0x0004
#if (_WIN32_IE >= 0x0300)
#define ACS_TIMER               0x0008  // don't use threads... use timers
#endif

// end_r_commctrl

#define ACM_OPENA               (WM_USER+100)
#define ACM_OPENW               (WM_USER+103)

#ifdef UNICODE
#define ACM_OPEN                ACM_OPENW
#else
#define ACM_OPEN                ACM_OPENA
#endif

#define ACM_PLAY                (WM_USER+101)
#define ACM_STOP                (WM_USER+102)


#define ACN_START               1
#define ACN_STOP                2


#define Animate_Create(hwndP, id, dwStyle, hInstance)   \
            CreateWindow(ANIMATE_CLASS, NULL,           \
                dwStyle, 0, 0, 0, 0, hwndP, (HMENU)(id), hInstance, NULL)

#define Animate_Open(hwnd, szName)          (BOOL)SNDMSG(hwnd, ACM_OPEN, 0, (LPARAM)(LPTSTR)(szName))
#define Animate_OpenEx(hwnd, hInst, szName) (BOOL)SNDMSG(hwnd, ACM_OPEN, (WPARAM)(hInst), (LPARAM)(LPTSTR)(szName))
#define Animate_Play(hwnd, from, to, rep)   (BOOL)SNDMSG(hwnd, ACM_PLAY, (WPARAM)(UINT)(rep), (LPARAM)MAKELONG(from, to))
#define Animate_Stop(hwnd)                  (BOOL)SNDMSG(hwnd, ACM_STOP, 0, 0)
#define Animate_Close(hwnd)                 Animate_Open(hwnd, NULL)
#define Animate_Seek(hwnd, frame)           Animate_Play(hwnd, frame, frame, 1)
#endif

#endif      // NOANIMATE


#if (_WIN32_IE >= 0x0300)
//====== MONTHCAL CONTROL ======================================================

#ifndef NOMONTHCAL
#ifdef _WIN32

#define MONTHCAL_CLASSW          L"SysMonthCal32"
#define MONTHCAL_CLASSA          "SysMonthCal32"

#ifdef UNICODE
#define MONTHCAL_CLASS           MONTHCAL_CLASSW
#else
#define MONTHCAL_CLASS           MONTHCAL_CLASSA
#endif

// bit-packed array of "bold" info for a month
// if a bit is on, that day is drawn bold
typedef DWORD MONTHDAYSTATE, FAR * LPMONTHDAYSTATE;


#define MCM_FIRST           0x1000

// BOOL MonthCal_GetCurSel(HWND hmc, LPSYSTEMTIME pst)
//   returns FALSE if MCS_MULTISELECT
//   returns TRUE and sets *pst to the currently selected date otherwise
#define MCM_GETCURSEL       (MCM_FIRST + 1)
#define MonthCal_GetCurSel(hmc, pst)    (BOOL)SNDMSG(hmc, MCM_GETCURSEL, 0, (LPARAM)(pst))

// BOOL MonthCal_SetCurSel(HWND hmc, LPSYSTEMTIME pst)
//   returns FALSE if MCS_MULTISELECT
//   returns TURE and sets the currently selected date to *pst otherwise
#define MCM_SETCURSEL       (MCM_FIRST + 2)
#define MonthCal_SetCurSel(hmc, pst)    (BOOL)SNDMSG(hmc, MCM_SETCURSEL, 0, (LPARAM)(pst))

// DWORD MonthCal_GetMaxSelCount(HWND hmc)
//   returns the maximum number of selectable days allowed
#define MCM_GETMAXSELCOUNT  (MCM_FIRST + 3)
#define MonthCal_GetMaxSelCount(hmc)    (DWORD)SNDMSG(hmc, MCM_GETMAXSELCOUNT, 0, 0L)

// BOOL MonthCal_SetMaxSelCount(HWND hmc, UINT n)
//   sets the max number days that can be selected iff MCS_MULTISELECT
#define MCM_SETMAXSELCOUNT  (MCM_FIRST + 4)
#define MonthCal_SetMaxSelCount(hmc, n) (BOOL)SNDMSG(hmc, MCM_SETMAXSELCOUNT, (WPARAM)(n), 0L)

// BOOL MonthCal_GetSelRange(HWND hmc, LPSYSTEMTIME rgst)
//   sets rgst[0] to the first day of the selection range
//   sets rgst[1] to the last day of the selection range
#define MCM_GETSELRANGE     (MCM_FIRST + 5)
#define MonthCal_GetSelRange(hmc, rgst) SNDMSG(hmc, MCM_GETSELRANGE, 0, (LPARAM)(rgst))

// BOOL MonthCal_SetSelRange(HWND hmc, LPSYSTEMTIME rgst)
//   selects the range of days from rgst[0] to rgst[1]
#define MCM_SETSELRANGE     (MCM_FIRST + 6)
#define MonthCal_SetSelRange(hmc, rgst) SNDMSG(hmc, MCM_SETSELRANGE, 0, (LPARAM)(rgst))

// DWORD MonthCal_GetMonthRange(HWND hmc, DWORD gmr, LPSYSTEMTIME rgst)
//   if rgst specified, sets rgst[0] to the starting date and
//      and rgst[1] to the ending date of the the selectable (non-grayed)
//      days if GMR_VISIBLE or all the displayed days (including grayed)
//      if GMR_DAYSTATE.
//   returns the number of months spanned by the above range.
#define MCM_GETMONTHRANGE   (MCM_FIRST + 7)
#define MonthCal_GetMonthRange(hmc, gmr, rgst)  (DWORD)SNDMSG(hmc, MCM_GETMONTHRANGE, (WPARAM)(gmr), (LPARAM)(rgst))

// BOOL MonthCal_SetDayState(HWND hmc, int cbds, DAYSTATE *rgds)
//   cbds is the count of DAYSTATE items in rgds and it must be equal
//   to the value returned from MonthCal_GetMonthRange(hmc, GMR_DAYSTATE, NULL)
//   This sets the DAYSTATE bits for each month (grayed and non-grayed
//   days) displayed in the calendar. The first bit in a month's DAYSTATE
//   corresponts to bolding day 1, the second bit affects day 2, etc.
#define MCM_SETDAYSTATE     (MCM_FIRST + 8)
#define MonthCal_SetDayState(hmc, cbds, rgds)   SNDMSG(hmc, MCM_SETDAYSTATE, (WPARAM)(cbds), (LPARAM)(rgds))

// BOOL MonthCal_GetMinReqRect(HWND hmc, LPRECT prc)
//   sets *prc the minimal size needed to display one month
//   To display two months, undo the AdjustWindowRect calculation already done to
//   this rect, double the width, and redo the AdjustWindowRect calculation --
//   the monthcal control will display two calendars in this window (if you also
//   double the vertical size, you will get 4 calendars)
//   NOTE: if you want to gurantee that the "Today" string is not clipped,
//   get the MCM_GETMAXTODAYWIDTH and use the max of that width and this width
#define MCM_GETMINREQRECT   (MCM_FIRST + 9)
#define MonthCal_GetMinReqRect(hmc, prc)        SNDMSG(hmc, MCM_GETMINREQRECT, 0, (LPARAM)(prc))

// set colors to draw control with -- see MCSC_ bits below
#define MCM_SETCOLOR            (MCM_FIRST + 10)
#define MonthCal_SetColor(hmc, iColor, clr) SNDMSG(hmc, MCM_SETCOLOR, iColor, clr)

#define MCM_GETCOLOR            (MCM_FIRST + 11)
#define MonthCal_GetColor(hmc, iColor) SNDMSG(hmc, MCM_GETCOLOR, iColor, 0)

#define MCSC_BACKGROUND   0   // the background color (between months)
#define MCSC_TEXT         1   // the dates
#define MCSC_TITLEBK      2   // background of the title
#define MCSC_TITLETEXT    3
#define MCSC_MONTHBK      4   // background within the month cal
#define MCSC_TRAILINGTEXT 5   // the text color of header & trailing days

// set what day is "today"   send NULL to revert back to real date
#define MCM_SETTODAY    (MCM_FIRST + 12)
#define MonthCal_SetToday(hmc, pst)             SNDMSG(hmc, MCM_SETTODAY, 0, (LPARAM)pst)

// get what day is "today"
// returns BOOL for success/failure
#define MCM_GETTODAY    (MCM_FIRST + 13)
#define MonthCal_GetToday(hmc, pst)             (BOOL)SNDMSG(hmc, MCM_GETTODAY, 0, (LPARAM)pst)

// determine what pinfo->pt is over
#define MCM_HITTEST          (MCM_FIRST + 14)
#define MonthCal_HitTest(hmc, pinfo) \
        SNDMSG(hmc, MCM_HITTEST, 0, (LPARAM)(PMCHITTESTINFO)pinfo)

typedef struct {
        UINT cbSize;
        POINT pt;

        UINT uHit;   // out param
        SYSTEMTIME st;
} MCHITTESTINFO, *PMCHITTESTINFO;

#define MCHT_TITLE                      0x00010000
#define MCHT_CALENDAR                   0x00020000
#define MCHT_TODAYLINK                  0x00030000
#define MCHT_NONELINK					0x00040000

#define MCHT_NEXT                       0x01000000   // these indicate that hitting
#define MCHT_PREV                       0x02000000  // here will go to the next/prev month

#define MCHT_NOWHERE                    0x00000000

#define MCHT_TITLEBK                    (MCHT_TITLE)
#define MCHT_TITLEMONTH                 (MCHT_TITLE | 0x0001)
#define MCHT_TITLEYEAR                  (MCHT_TITLE | 0x0002)
#define MCHT_TITLEBTNNEXT               (MCHT_TITLE | MCHT_NEXT | 0x0003)
#define MCHT_TITLEBTNPREV               (MCHT_TITLE | MCHT_PREV | 0x0003)

#define MCHT_CALENDARBK                 (MCHT_CALENDAR)
#define MCHT_CALENDARDATE               (MCHT_CALENDAR | 0x0001)
#define MCHT_CALENDARDATENEXT           (MCHT_CALENDARDATE | MCHT_NEXT)
#define MCHT_CALENDARDATEPREV           (MCHT_CALENDARDATE | MCHT_PREV)
#define MCHT_CALENDARDAY                (MCHT_CALENDAR | 0x0002)
#define MCHT_CALENDARWEEKNUM            (MCHT_CALENDAR | 0x0003)

// set first day of week to iDay:
// 0 for Monday, 1 for Tuesday, ..., 6 for Sunday
// -1 for means use locale info
#define MCM_SETFIRSTDAYOFWEEK (MCM_FIRST + 15)
#define MonthCal_SetFirstDayOfWeek(hmc, iDay) \
        SNDMSG(hmc, MCM_SETFIRSTDAYOFWEEK, 0, iDay)

// DWORD result...  low word has the day.  high word is bool if this is app set
// or not (FALSE == using locale info)
#define MCM_GETFIRSTDAYOFWEEK (MCM_FIRST + 16)
#define MonthCal_GetFirstDayOfWeek(hmc) \
        (DWORD)SNDMSG(hmc, MCM_GETFIRSTDAYOFWEEK, 0, 0)

// DWORD MonthCal_GetRange(HWND hmc, LPSYSTEMTIME rgst)
//   modifies rgst[0] to be the minimum ALLOWABLE systemtime (or 0 if no minimum)
//   modifies rgst[1] to be the maximum ALLOWABLE systemtime (or 0 if no maximum)
//   returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit
#define MCM_GETRANGE (MCM_FIRST + 17)
#define MonthCal_GetRange(hmc, rgst) \
        (DWORD)SNDMSG(hmc, MCM_GETRANGE, 0, (LPARAM)(rgst))

// BOOL MonthCal_SetRange(HWND hmc, DWORD gdtr, LPSYSTEMTIME rgst)
//   if GDTR_MIN, sets the minimum ALLOWABLE systemtime to rgst[0], otherwise removes minimum
//   if GDTR_MAX, sets the maximum ALLOWABLE systemtime to rgst[1], otherwise removes maximum
//   returns TRUE on success, FALSE on error (such as invalid parameters)
#define MCM_SETRANGE (MCM_FIRST + 18)
#define MonthCal_SetRange(hmc, gd, rgst) \
        (BOOL)SNDMSG(hmc, MCM_SETRANGE, (WPARAM)(gd), (LPARAM)(rgst))

// int MonthCal_GetMonthDelta(HWND hmc)
//   returns the number of months one click on a next/prev button moves by
#define MCM_GETMONTHDELTA (MCM_FIRST + 19)
#define MonthCal_GetMonthDelta(hmc) \
        (int)SNDMSG(hmc, MCM_GETMONTHDELTA, 0, 0)

// int MonthCal_SetMonthDelta(HWND hmc, int n)
//   sets the month delta to n. n==0 reverts to moving by a page of months
//   returns the previous value of n.
#define MCM_SETMONTHDELTA (MCM_FIRST + 20)
#define MonthCal_SetMonthDelta(hmc, n) \
        (int)SNDMSG(hmc, MCM_SETMONTHDELTA, n, 0)

// DWORD MonthCal_GetMaxTodayWidth(HWND hmc, LPSIZE psz)
//   sets *psz to the maximum width/height of the "Today" string displayed
//   at the bottom of the calendar (as long as MCS_NOTODAY is not specified)
#define MCM_GETMAXTODAYWIDTH (MCM_FIRST + 21)
#define MCM_GETMAXNONEWIDTH (MCM_FIRST + 22)
#define MonthCal_GetMaxTodayWidth(hmc) \
        (DWORD)SNDMSG(hmc, MCM_GETMAXTODAYWIDTH, 0, 0)

// MCN_SELCHANGE is sent whenever the currently displayed date changes
// via month change, year change, keyboard navigation, prev/next button
//
typedef struct tagNMSELCHANGE
{
    NMHDR           nmhdr;  // this must be first, so we don't break WM_NOTIFY

    SYSTEMTIME      stSelStart;
    SYSTEMTIME      stSelEnd;
} NMSELCHANGE, FAR * LPNMSELCHANGE;

#define MCN_SELCHANGE       (MCN_FIRST + 1)

// MCN_GETDAYSTATE is sent for MCS_DAYSTATE controls whenever new daystate
// information is needed (month or year scroll) to draw bolding information.
// The app must fill in cDayState months worth of information starting from
// stStart date. The app may fill in the array at prgDayState or change
// prgDayState to point to a different array out of which the information
// will be copied. (similar to tooltips)
//
typedef struct tagNMDAYSTATE
{
    NMHDR           nmhdr;  // this must be first, so we don't break WM_NOTIFY

    SYSTEMTIME      stStart;
    int             cDayState;

    LPMONTHDAYSTATE prgDayState; // points to cDayState MONTHDAYSTATEs
} NMDAYSTATE, FAR * LPNMDAYSTATE;

#define MCN_GETDAYSTATE     (MCN_FIRST + 3)

// MCN_SELECT is sent whenever a selection has occured (via mouse or keyboard)
//
typedef NMSELCHANGE NMSELECT, FAR * LPNMSELECT;


#define MCN_SELECT          (MCN_FIRST + 4)
#define MCN_SELECTNONE      (MCN_FIRST + 5)

#define MCS_DAYSTATE        0x0001
#define MCS_MULTISELECT     0x0002
#define MCS_WEEKNUMBERS     0x0004
#define MCS_SHOWNONE		0x0080
#if (_WIN32_IE >= 0x0400)
#define MCS_NOTODAYCIRCLE   0x0008
#define MCS_NOTODAY         0x0010
#else
#define MCS_NOTODAY         0x0008
#endif      


#define GMR_VISIBLE     0       // visible portion of display
#define GMR_DAYSTATE    1       // above plus the grayed out parts of
                                // partially displayed months


#endif // _WIN32
#endif // NOMONTHCAL


//====== TOOLTIPS CONTROL =====================================================

#ifndef NOTOOLTIPS

#ifdef _WIN32

#define TOOLTIPS_CLASSW         L"tooltips_class32"
#define TOOLTIPS_CLASSA         "tooltips_class32"

#ifdef UNICODE
#define TOOLTIPS_CLASS          TOOLTIPS_CLASSW
#else
#define TOOLTIPS_CLASS          TOOLTIPS_CLASSA
#endif

#else
#define TOOLTIPS_CLASS          "tooltips_class"
#endif // _WIN32

#if (_WIN32_IE >= 0x0300)
#define LPTOOLINFOA   LPTTTOOLINFOA
#define LPTOOLINFOW   LPTTTOOLINFOW
#define TOOLINFOA       TTTOOLINFOA
#define TOOLINFOW       TTTOOLINFOW
#else
#define   TTTOOLINFOA   TOOLINFOA
#define LPTTTOOLINFOA LPTOOLINFOA
#define   TTTOOLINFOW   TOOLINFOW
#define LPTTTOOLINFOW LPTOOLINFOW
#endif // (_WIN32_IE >= 0x0300)

#define LPTOOLINFO    LPTTTOOLINFO
#define TOOLINFO        TTTOOLINFO

typedef struct tagTOOLINFOA {
    UINT cbSize;
    UINT uFlags;
    HWND hwnd;
    UINT uId;
    RECT rect;
    HINSTANCE hinst;
    LPSTR lpszText;
#if (_WIN32_IE >= 0x0300)
    LPARAM lParam;
#endif
} TTTOOLINFOA, NEAR *PTOOLINFOA, FAR *LPTTTOOLINFOA;

typedef struct tagTOOLINFOW {
    UINT cbSize;
    UINT uFlags;
    HWND hwnd;
    UINT uId;
    RECT rect;
    HINSTANCE hinst;
    LPWSTR lpszText;
#if (_WIN32_IE >= 0x0300)
    LPARAM lParam;
#endif
} TTTOOLINFOW, NEAR *PTOOLINFOW, FAR* LPTTTOOLINFOW;

#ifdef UNICODE
#define TTTOOLINFO              TTTOOLINFOW
#define PTOOLINFO               PTOOLINFOW
#define LPTTTOOLINFO            LPTTTOOLINFOW
#else
#define PTOOLINFO               PTOOLINFOA
#define TTTOOLINFO              TTTOOLINFOA
#define LPTTTOOLINFO            LPTTTOOLINFOA
#endif

// begin_r_commctrl

#define TTS_ALWAYSTIP           0x01
#define TTS_NOPREFIX            0x02

// end_r_commctrl

#define TTF_IDISHWND            0x0001

// Use this to center around trackpoint in trackmode
// -OR- to center around tool in normal mode.
// Use TTF_ABSOLUTE to place the tip exactly at the track coords when
// in tracking mode.  TTF_ABSOLUTE can be used in conjunction with TTF_CENTERTIP
// to center the tip absolutely about the track point.

#define TTF_CENTERTIP           0x0002
#define TTF_RTLREADING          0x0004
#if (_WIN32_IE >= 0x0300)
#define TTF_SUBCLASS            0x0010
#define TTF_TRACK               0x0020
#define TTF_ABSOLUTE            0x0080
#define TTF_TRANSPARENT         0x0100
#if (_WIN32_IE >= 0x0400)
#define TTF_USEHITTEST          0x0400
#endif
#define TTF_DI_SETITEM          0x8000       // valid only on the TTN_NEEDTEXT callback
#endif      // _WIN32_IE >= 0x0300

#define TTDT_AUTOMATIC          0
#define TTDT_RESHOW             1
#define TTDT_AUTOPOP            2
#define TTDT_INITIAL            3

#define TTM_ACTIVATE            (WM_USER + 1)
#define TTM_SETDELAYTIME        (WM_USER + 3)
#define TTM_ADDTOOLA            (WM_USER + 4)
#define TTM_ADDTOOLW            (WM_USER + 50)
#define TTM_DELTOOLA            (WM_USER + 5)
#define TTM_DELTOOLW            (WM_USER + 51)
#define TTM_NEWTOOLRECTA        (WM_USER + 6)
#define TTM_NEWTOOLRECTW        (WM_USER + 52)
#define TTM_RELAYEVENT          (WM_USER + 7)

#define TTM_GETTOOLINFOA        (WM_USER + 8)
#define TTM_GETTOOLINFOW        (WM_USER + 53)

#define TTM_SETTOOLINFOA        (WM_USER + 9)
#define TTM_SETTOOLINFOW        (WM_USER + 54)

#define TTM_HITTESTA            (WM_USER +10)
#define TTM_HITTESTW            (WM_USER +55)
#define TTM_GETTEXTA            (WM_USER +11)
#define TTM_GETTEXTW            (WM_USER +56)
#define TTM_UPDATETIPTEXTA      (WM_USER +12)
#define TTM_UPDATETIPTEXTW      (WM_USER +57)
#define TTM_GETTOOLCOUNT        (WM_USER +13)
#define TTM_ENUMTOOLSA          (WM_USER +14)
#define TTM_ENUMTOOLSW          (WM_USER +58)
#define TTM_GETCURRENTTOOLA     (WM_USER + 15)
#define TTM_GETCURRENTTOOLW     (WM_USER + 59)
#define TTM_WINDOWFROMPOINT     (WM_USER + 16)
#if (_WIN32_IE >= 0x0300)
#define TTM_TRACKACTIVATE       (WM_USER + 17)  // wParam = TRUE/FALSE start end  lparam = LPTOOLINFO
#define TTM_TRACKPOSITION       (WM_USER + 18)  // lParam = dwPos
#define TTM_SETTIPBKCOLOR       (WM_USER + 19)
#define TTM_SETTIPTEXTCOLOR     (WM_USER + 20)
#define TTM_GETDELAYTIME        (WM_USER + 21)
#define TTM_GETTIPBKCOLOR       (WM_USER + 22)
#define TTM_GETTIPTEXTCOLOR     (WM_USER + 23)
#define TTM_SETMAXTIPWIDTH      (WM_USER + 24)
#define TTM_GETMAXTIPWIDTH      (WM_USER + 25)
#define TTM_SETMARGIN           (WM_USER + 26)  // lParam = lprc
#define TTM_GETMARGIN           (WM_USER + 27)  // lParam = lprc
#define TTM_POP                 (WM_USER + 28)
#endif
#if (_WIN32_IE >= 0x0400)
#define TTM_UPDATE              (WM_USER + 29)
#endif


#ifdef UNICODE
#define TTM_ADDTOOL             TTM_ADDTOOLW
#define TTM_DELTOOL             TTM_DELTOOLW
#define TTM_NEWTOOLRECT         TTM_NEWTOOLRECTW
#define TTM_GETTOOLINFO         TTM_GETTOOLINFOW
#define TTM_SETTOOLINFO         TTM_SETTOOLINFOW
#define TTM_HITTEST             TTM_HITTESTW
#define TTM_GETTEXT             TTM_GETTEXTW
#define TTM_UPDATETIPTEXT       TTM_UPDATETIPTEXTW
#define TTM_ENUMTOOLS           TTM_ENUMTOOLSW
#define TTM_GETCURRENTTOOL      TTM_GETCURRENTTOOLW
#else
#define TTM_ADDTOOL             TTM_ADDTOOLA
#define TTM_DELTOOL             TTM_DELTOOLA
#define TTM_NEWTOOLRECT         TTM_NEWTOOLRECTA
#define TTM_GETTOOLINFO         TTM_GETTOOLINFOA
#define TTM_SETTOOLINFO         TTM_SETTOOLINFOA
#define TTM_HITTEST             TTM_HITTESTA
#define TTM_GETTEXT             TTM_GETTEXTA
#define TTM_UPDATETIPTEXT       TTM_UPDATETIPTEXTA
#define TTM_ENUMTOOLS           TTM_ENUMTOOLSA
#define TTM_GETCURRENTTOOL      TTM_GETCURRENTTOOLA
#endif


#if (_WIN32_IE >= 0x0300)
#define LPHITTESTINFOW    LPTTHITTESTINFOW
#define LPHITTESTINFOA    LPTTHITTESTINFOA
#else
#define LPTTHITTESTINFOA  LPHITTESTINFOA
#define LPTTHITTESTINFOW  LPHITTESTINFOW
#endif

#define LPHITTESTINFO     LPTTHITTESTINFO

typedef struct _TT_HITTESTINFOA {
    HWND hwnd;
    POINT pt;
    TTTOOLINFOA ti;
} TTHITTESTINFOA, FAR * LPTTHITTESTINFOA;

typedef struct _TT_HITTESTINFOW {
    HWND hwnd;
    POINT pt;
    TTTOOLINFOW ti;
} TTHITTESTINFOW, FAR * LPTTHITTESTINFOW;

#ifdef UNICODE
#define TTHITTESTINFO           TTHITTESTINFOW
#define LPTTHITTESTINFO         LPTTHITTESTINFOW
#else
#define TTHITTESTINFO           TTHITTESTINFOA
#define LPTTHITTESTINFO         LPTTHITTESTINFOA
#endif

#define TTN_GETDISPINFOA        (TTN_FIRST - 0)
#define TTN_GETDISPINFOW        (TTN_FIRST - 10)
#define TTN_SHOW                (TTN_FIRST - 1)
#define TTN_POP                 (TTN_FIRST - 2)

#ifdef UNICODE
#define TTN_GETDISPINFO         TTN_GETDISPINFOW
#else
#define TTN_GETDISPINFO         TTN_GETDISPINFOA
#endif

#define TTN_NEEDTEXT            TTN_GETDISPINFO
#define TTN_NEEDTEXTA           TTN_GETDISPINFOA
#define TTN_NEEDTEXTW           TTN_GETDISPINFOW

#if (_WIN32_IE >= 0x0300)
#define TOOLTIPTEXTW NMTTDISPINFOW
#define TOOLTIPTEXTA NMTTDISPINFOA
#define LPTOOLTIPTEXTA LPNMTTDISPINFOA
#define LPTOOLTIPTEXTW LPNMTTDISPINFOW
#else
#define tagNMTTDISPINFOA  tagTOOLTIPTEXTA
#define NMTTDISPINFOA     TOOLTIPTEXTA
#define LPNMTTDISPINFOA   LPTOOLTIPTEXTA
#define tagNMTTDISPINFOW  tagTOOLTIPTEXTW
#define NMTTDISPINFOW     TOOLTIPTEXTW
#define LPNMTTDISPINFOW   LPTOOLTIPTEXTW
#endif

#define TOOLTIPTEXT    NMTTDISPINFO
#define LPTOOLTIPTEXT  LPNMTTDISPINFO

typedef struct tagNMTTDISPIFNOA {
    NMHDR hdr;
    LPSTR lpszText;
    char szText[80];
    HINSTANCE hinst;
    UINT uFlags;
#if (_WIN32_IE >= 0x0300)
    LPARAM lParam;
#endif
} NMTTDISPINFOA, FAR *LPNMTTDISPINFOA;

typedef struct tagNMTTDISPINFOW {
    NMHDR hdr;
    LPWSTR lpszText;
    WCHAR szText[80];
    HINSTANCE hinst;
    UINT uFlags;
#if (_WIN32_IE >= 0x0300)
    LPARAM lParam;
#endif
} NMTTDISPINFOW, FAR *LPNMTTDISPINFOW;

#ifdef UNICODE
#define NMTTDISPINFO            NMTTDISPINFOW
#define LPNMTTDISPINFO          LPNMTTDISPINFOW
#else
#define NMTTDISPINFO            NMTTDISPINFOA
#define LPNMTTDISPINFO          LPNMTTDISPINFOA
#endif

#endif      // NOTOOLTIPS

//====== DATETIMEPICK CONTROL ==================================================

#ifndef NODATETIMEPICK
#ifdef _WIN32

#define DATETIMEPICK_CLASSW          L"SysDateTimePick32"
#define DATETIMEPICK_CLASSA          "SysDateTimePick32"

#ifdef UNICODE
#define DATETIMEPICK_CLASS           DATETIMEPICK_CLASSW
#else
#define DATETIMEPICK_CLASS           DATETIMEPICK_CLASSA
#endif

#define DTM_FIRST        0x1000

// DWORD DateTimePick_GetSystemtime(HWND hdp, LPSYSTEMTIME pst)
//   returns GDT_NONE if "none" is selected (DTS_SHOWNONE only)
//   returns GDT_VALID and modifies *pst to be the currently selected value
#define DTM_GETSYSTEMTIME   (DTM_FIRST + 1)
#define DateTime_GetSystemtime(hdp, pst)    (DWORD)SNDMSG(hdp, DTM_GETSYSTEMTIME, 0, (LPARAM)(pst))

// BOOL DateTime_SetSystemtime(HWND hdp, DWORD gd, LPSYSTEMTIME pst)
//   if gd==GDT_NONE, sets datetimepick to None (DTS_SHOWNONE only)
//   if gd==GDT_VALID, sets datetimepick to *pst
//   returns TRUE on success, FALSE on error (such as bad params)
#define DTM_SETSYSTEMTIME   (DTM_FIRST + 2)
#define DateTime_SetSystemtime(hdp, gd, pst)    (BOOL)SNDMSG(hdp, DTM_SETSYSTEMTIME, (LPARAM)(gd), (LPARAM)(pst))

// DWORD DateTime_GetRange(HWND hdp, LPSYSTEMTIME rgst)
//   modifies rgst[0] to be the minimum ALLOWABLE systemtime (or 0 if no minimum)
//   modifies rgst[1] to be the maximum ALLOWABLE systemtime (or 0 if no maximum)
//   returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit
#define DTM_GETRANGE (DTM_FIRST + 3)
#define DateTime_GetRange(hdp, rgst)  (DWORD)SNDMSG(hdp, DTM_GETRANGE, 0, (LPARAM)(rgst))

// BOOL DateTime_SetRange(HWND hdp, DWORD gdtr, LPSYSTEMTIME rgst)
//   if GDTR_MIN, sets the minimum ALLOWABLE systemtime to rgst[0], otherwise removes minimum
//   if GDTR_MAX, sets the maximum ALLOWABLE systemtime to rgst[1], otherwise removes maximum
//   returns TRUE on success, FALSE on error (such as invalid parameters)
#define DTM_SETRANGE (DTM_FIRST + 4)
#define DateTime_SetRange(hdp, gd, rgst)  (BOOL)SNDMSG(hdp, DTM_SETRANGE, (WPARAM)(gd), (LPARAM)(rgst))

// BOOL DateTime_SetFormat(HWND hdp, LPCTSTR sz)
//   sets the display formatting string to sz (see GetDateFormat and GetTimeFormat for valid formatting chars)
//   NOTE: 'X' is a valid formatting character which indicates that the application
//   will determine how to display information. Such apps must support DTN_WMKEYDOWN,
//   DTN_FORMAT, and DTN_FORMATQUERY.
#define DTM_SETFORMATA (DTM_FIRST + 5)
#define DTM_SETFORMATW (DTM_FIRST + 50)

#ifdef UNICODE
#define DTM_SETFORMAT       DTM_SETFORMATW
#else
#define DTM_SETFORMAT       DTM_SETFORMATA
#endif

#define DateTime_SetFormat(hdp, sz)  (BOOL)SNDMSG(hdp, DTM_SETFORMAT, 0, (LPARAM)(sz))


#define DTM_SETMCCOLOR    (DTM_FIRST + 6)
#define DateTime_SetMonthCalColor(hdp, iColor, clr) SNDMSG(hdp, DTM_SETMCCOLOR, iColor, clr)

#define DTM_GETMCCOLOR    (DTM_FIRST + 7)
#define DateTime_GetMonthCalColor(hdp, iColor) SNDMSG(hdp, DTM_GETMCCOLOR, iColor, 0)

// HWND DateTime_GetMonthCal(HWND hdp)
//   returns the HWND of the MonthCal popup window. Only valid
// between DTN_DROPDOWN and DTN_CLOSEUP notifications.
#define DTM_GETMONTHCAL   (DTM_FIRST + 8)
#define DateTime_GetMonthCal(hdp) (HWND)SNDMSG(hdp, DTM_GETMONTHCAL, 0, 0)

#if (_WIN32_IE >= 0x0400)

#define DTM_SETMCFONT     (DTM_FIRST + 9)
#define DateTime_SetMonthCalFont(hdp, hfont, fRedraw) SNDMSG(hdp, DTM_SETMCFONT, (WPARAM)hfont, (LPARAM)fRedraw)

#define DTM_GETMCFONT     (DTM_FIRST + 10)
#define DateTime_GetMonthCalFont(hdp) SNDMSG(hdp, DTM_GETMCFONT, 0, 0)

#endif      // _WIN32_IE >= 0x0400

#define DTS_UPDOWN          0x0001 // use UPDOWN instead of MONTHCAL
#define DTS_SHOWNONE        0x0002 // allow a NONE or checkbox selection
#define DTS_SHORTDATEFORMAT 0x0000 // use the short date format (app must forward WM_WININICHANGE messages)
#define DTS_LONGDATEFORMAT  0x0004 // use the long date format (app must forward WM_WININICHANGE messages)
#define DTS_SHORTDATECENTURYFORMAT 0x000C// short date format with century (app must forward WM_WININICHANGE messages)
#define DTS_TIMEFORMAT      0x0008 // use the time format (app must forward WM_WININICHANGE messages)
#define DTS_APPCANPARSE     0x0010 // allow user entered strings (app MUST respond to DTN_USERSTRING)
#define DTS_RIGHTALIGN      0x0020 // right-align popup instead of left-align it
#define DTS_NONEBUTTON      0x0080 // use NONE button instead of checkbox
#define DTS_SHOWSECONDS     0x0100 // show seconds when in Time mode (defaults to no seconds)
#define DTS_UPDOWNARROWSCHANGEVALUES 0x0200  // allow the arrow keys to change the time when in a dialog

#define DTN_DATETIMECHANGE  (DTN_FIRST + 1) // the systemtime has changed
typedef struct tagNMDATETIMECHANGE
{
    NMHDR       nmhdr;
    DWORD       dwFlags;    // GDT_VALID or GDT_NONE
    SYSTEMTIME  st;         // valid iff dwFlags==GDT_VALID
} NMDATETIMECHANGE, FAR * LPNMDATETIMECHANGE;

#define DTN_USERSTRINGA  (DTN_FIRST + 2) // the user has entered a string
#define DTN_USERSTRINGW  (DTN_FIRST + 15)
typedef struct tagNMDATETIMESTRINGA
{
    NMHDR      nmhdr;
    LPCSTR     pszUserString;  // string user entered
    SYSTEMTIME st;             // app fills this in
    DWORD      dwFlags;        // GDT_VALID or GDT_NONE
} NMDATETIMESTRINGA, FAR * LPNMDATETIMESTRINGA;

typedef struct tagNMDATETIMESTRINGW
{
    NMHDR      nmhdr;
    LPCWSTR    pszUserString;  // string user entered
    SYSTEMTIME st;             // app fills this in
    DWORD      dwFlags;        // GDT_VALID or GDT_NONE
} NMDATETIMESTRINGW, FAR * LPNMDATETIMESTRINGW;

#ifdef UNICODE
#define DTN_USERSTRING          DTN_USERSTRINGW
#define NMDATETIMESTRING        NMDATETIMESTRINGW
#define LPNMDATETIMESTRING      LPNMDATETIMESTRINGW
#else
#define DTN_USERSTRING          DTN_USERSTRINGA
#define NMDATETIMESTRING        NMDATETIMESTRINGA
#define LPNMDATETIMESTRING      LPNMDATETIMESTRINGA
#endif


#define DTN_WMKEYDOWNA  (DTN_FIRST + 3) // modify keydown on app format field (X)
#define DTN_WMKEYDOWNW  (DTN_FIRST + 16)
typedef struct tagNMDATETIMEWMKEYDOWNA
{
    NMHDR      nmhdr;
    int        nVirtKey;  // virtual key code of WM_KEYDOWN which MODIFIES an X field
    LPCSTR     pszFormat; // format substring
    SYSTEMTIME st;        // current systemtime, app should modify based on key
} NMDATETIMEWMKEYDOWNA, FAR * LPNMDATETIMEWMKEYDOWNA;

typedef struct tagNMDATETIMEWMKEYDOWNW
{
    NMHDR      nmhdr;
    int        nVirtKey;  // virtual key code of WM_KEYDOWN which MODIFIES an X field
    LPCWSTR    pszFormat; // format substring
    SYSTEMTIME st;        // current systemtime, app should modify based on key
} NMDATETIMEWMKEYDOWNW, FAR * LPNMDATETIMEWMKEYDOWNW;

#ifdef UNICODE
#define DTN_WMKEYDOWN           DTN_WMKEYDOWNW
#define NMDATETIMEWMKEYDOWN     NMDATETIMEWMKEYDOWNW
#define LPNMDATETIMEWMKEYDOWN   LPNMDATETIMEWMKEYDOWNW
#else
#define DTN_WMKEYDOWN           DTN_WMKEYDOWNA
#define NMDATETIMEWMKEYDOWN     NMDATETIMEWMKEYDOWNA
#define LPNMDATETIMEWMKEYDOWN   LPNMDATETIMEWMKEYDOWNA
#endif


#define DTN_FORMATA  (DTN_FIRST + 4) // query display for app format field (X)
#define DTN_FORMATW  (DTN_FIRST + 17)
typedef struct tagNMDATETIMEFORMATA
{
    NMHDR nmhdr;
    LPCSTR  pszFormat;   // format substring
    SYSTEMTIME st;       // current systemtime
    LPCSTR pszDisplay;   // string to display
    CHAR szDisplay[64];  // buffer pszDisplay originally points at
} NMDATETIMEFORMATA, FAR * LPNMDATETIMEFORMATA;

typedef struct tagNMDATETIMEFORMATW
{
    NMHDR nmhdr;
    LPCWSTR pszFormat;   // format substring
    SYSTEMTIME st;       // current systemtime
    LPCWSTR pszDisplay;  // string to display
    WCHAR szDisplay[64]; // buffer pszDisplay originally points at
} NMDATETIMEFORMATW, FAR * LPNMDATETIMEFORMATW;

#ifdef UNICODE
#define DTN_FORMAT             DTN_FORMATW
#define NMDATETIMEFORMAT        NMDATETIMEFORMATW
#define LPNMDATETIMEFORMAT      LPNMDATETIMEFORMATW
#else
#define DTN_FORMAT             DTN_FORMATA
#define NMDATETIMEFORMAT        NMDATETIMEFORMATA
#define LPNMDATETIMEFORMAT      LPNMDATETIMEFORMATA
#endif


#define DTN_FORMATQUERYA  (DTN_FIRST + 5) // query formatting info for app format field (X)
#define DTN_FORMATQUERYW (DTN_FIRST + 18)
typedef struct tagNMDATETIMEFORMATQUERYA
{
    NMHDR nmhdr;
    LPCSTR pszFormat;  // format substring
    SIZE szMax;        // max bounding rectangle app will use for this format string
} NMDATETIMEFORMATQUERYA, FAR * LPNMDATETIMEFORMATQUERYA;

typedef struct tagNMDATETIMEFORMATQUERYW
{
    NMHDR nmhdr;
    LPCWSTR pszFormat; // format substring
    SIZE szMax;        // max bounding rectangle app will use for this format string
} NMDATETIMEFORMATQUERYW, FAR * LPNMDATETIMEFORMATQUERYW;

#ifdef UNICODE
#define DTN_FORMATQUERY         DTN_FORMATQUERYW
#define NMDATETIMEFORMATQUERY   NMDATETIMEFORMATQUERYW
#define LPNMDATETIMEFORMATQUERY LPNMDATETIMEFORMATQUERYW
#else
#define DTN_FORMATQUERY         DTN_FORMATQUERYA
#define NMDATETIMEFORMATQUERY   NMDATETIMEFORMATQUERYA
#define LPNMDATETIMEFORMATQUERY LPNMDATETIMEFORMATQUERYA
#endif


#define DTN_DROPDOWN    (DTN_FIRST + 6) // MonthCal has dropped down
#define DTN_CLOSEUP     (DTN_FIRST + 7) // MonthCal is popping up


#define GDTR_MIN     0x0001
#define GDTR_MAX     0x0002

#define GDT_ERROR    -1
#define GDT_VALID    0
#define GDT_NONE     1

#endif // _WIN32
#endif // NODATETIMEPICK

// Pocket PC  special controls (all-caps edit control, tool-tip static & button)
#define WC_CAPEDIT    L"CAPEDIT"
#define WC_TSTATIC    L"TTSTATIC"
#define WC_TBUTTON    L"TTBUTTON"

// for FE, single byte character edit
#define WC_SBEDIT     L"sbedit"


//====== CAPEDIT CONTROL ======================================================

#define CEM_UPCASEALLWORDS    (WM_USER + 1)
#define CEM_ENABLEUPCASE      (WM_USER + 2)

#endif      // _WIN32_IE >= 0x0300

#ifdef __cplusplus
}
#endif

#ifndef UNDER_CE
#ifdef _WIN32
#include <poppack.h>
#endif
#endif // !UNDER_CE

#endif

#ifdef WINCEOEM // UNDER_CE
#include <pcommctr.h>
#endif

// @CESYSGEN ENDIF

#endif  // _INC_COMMCTRL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\commoncontrols.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Tue Jan 23 14:30:37 2007
 */
/* Compiler settings for ..\CommonControls.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __CommonControls_h__
#define __CommonControls_h__

/* Forward Declarations */ 

#ifndef __IImageList_FWD_DEFINED__
#define __IImageList_FWD_DEFINED__
typedef interface IImageList IImageList;
#endif 	/* __IImageList_FWD_DEFINED__ */


#ifndef __IImageList2_FWD_DEFINED__
#define __IImageList2_FWD_DEFINED__
typedef interface IImageList2 IImageList2;
#endif 	/* __IImageList2_FWD_DEFINED__ */


#ifndef __ImageList_FWD_DEFINED__
#define __ImageList_FWD_DEFINED__

#ifdef __cplusplus
typedef class ImageList ImageList;
#else
typedef struct ImageList ImageList;
#endif /* __cplusplus */

#endif 	/* __ImageList_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_CommonControls_0000 */
/* [local] */ 

#if (_WIN32_IE >= 0x0501)
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI
#ifdef MIDL_PASS
typedef DWORD RGBQUAD;

typedef IUnknown __RPC_FAR *HIMAGELIST;

typedef struct _IMAGELIST* HIMAGELIST;
typedef struct _IMAGELISTDRAWPARAMS
    {
    DWORD cbSize;
    HIMAGELIST himl;
    int i;
    HDC hdcDst;
    int x;
    int y;
    int cx;
    int cy;
    int xBitmap;
    int yBitmap;
    COLORREF rgbBk;
    COLORREF rgbFg;
    UINT fStyle;
    DWORD dwRop;
    DWORD fState;
    DWORD Frame;
    COLORREF crEffect;
    }	IMAGELISTDRAWPARAMS;

typedef IMAGELISTDRAWPARAMS __RPC_FAR *LPIMAGELISTDRAWPARAMS;

typedef struct tagIMAGEINFO
    {
    HBITMAP hbmImage;
    HBITMAP hbmMask;
    int Unused1;
    int Unused2;
    RECT rcImage;
    }	IMAGEINFO;

typedef IMAGEINFO __RPC_FAR *LPIMAGEINFO;

#endif
#if _WIN32_WINNT >= 0x0600
WINCOMMCTRLAPI HRESULT WINAPI ImageList_CoCreateInstance(
         __in  REFCLSID rclsid,
         __in  const IUnknown *punkOuter,
         __in  REFIID riid,
         __out void **ppv);
#endif
#define ILIF_ALPHA               0x00000001
#define ILIF_LOWQUALITY          0x00000002
#define ILDRF_IMAGELOWQUALITY    0x00000001
#define ILDRF_OVERLAYLOWQUALITY  0x00000010


extern RPC_IF_HANDLE __MIDL_itf_CommonControls_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_CommonControls_0000_v0_0_s_ifspec;

#ifndef __IImageList_INTERFACE_DEFINED__
#define __IImageList_INTERFACE_DEFINED__

/* interface IImageList */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IImageList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("46EB5926-582E-4017-9FDF-E8998DAA0950")
    IImageList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Add( 
            HBITMAP hbmImage,
            HBITMAP hbmMask,
            int __RPC_FAR *pi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplaceIcon( 
            int i,
            HICON hicon,
            int __RPC_FAR *pi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOverlayImage( 
            int iImage,
            int iOverlay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Replace( 
            int i,
            HBITMAP hbmImage,
            HBITMAP hbmMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMasked( 
            HBITMAP hbmImage,
            COLORREF crMask,
            int __RPC_FAR *pi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Draw( 
            IMAGELISTDRAWPARAMS __RPC_FAR *pimldp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            int i) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIcon( 
            int i,
            UINT flags,
            HICON __RPC_FAR *picon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageInfo( 
            int i,
            IMAGEINFO __RPC_FAR *pImageInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Copy( 
            int iDst,
            IUnknown __RPC_FAR *punkSrc,
            int iSrc,
            UINT uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Merge( 
            int i1,
            IUnknown __RPC_FAR *punk2,
            int i2,
            int dx,
            int dy,
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageRect( 
            int i,
            RECT __RPC_FAR *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconSize( 
            int __RPC_FAR *cx,
            int __RPC_FAR *cy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconSize( 
            int cx,
            int cy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageCount( 
            int __RPC_FAR *pi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetImageCount( 
            UINT uNewCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBkColor( 
            COLORREF clrBk,
            COLORREF __RPC_FAR *pclr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBkColor( 
            COLORREF __RPC_FAR *pclr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginDrag( 
            int iTrack,
            int dxHotspot,
            int dyHotspot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndDrag( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragEnter( 
            HWND hwndLock,
            int x,
            int y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragLeave( 
            HWND hwndLock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragMove( 
            int x,
            int y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDragCursorImage( 
            IUnknown __RPC_FAR *punk,
            int iDrag,
            int dxHotspot,
            int dyHotspot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragShowNolock( 
            BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDragImage( 
            POINT __RPC_FAR *ppt,
            POINT __RPC_FAR *pptHotspot,
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemFlags( 
            int i,
            DWORD __RPC_FAR *dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOverlayImage( 
            int iOverlay,
            int __RPC_FAR *piIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImageList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImageList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImageList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IImageList __RPC_FAR * This,
            HBITMAP hbmImage,
            HBITMAP hbmMask,
            int __RPC_FAR *pi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReplaceIcon )( 
            IImageList __RPC_FAR * This,
            int i,
            HICON hicon,
            int __RPC_FAR *pi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOverlayImage )( 
            IImageList __RPC_FAR * This,
            int iImage,
            int iOverlay);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Replace )( 
            IImageList __RPC_FAR * This,
            int i,
            HBITMAP hbmImage,
            HBITMAP hbmMask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMasked )( 
            IImageList __RPC_FAR * This,
            HBITMAP hbmImage,
            COLORREF crMask,
            int __RPC_FAR *pi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Draw )( 
            IImageList __RPC_FAR * This,
            IMAGELISTDRAWPARAMS __RPC_FAR *pimldp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IImageList __RPC_FAR * This,
            int i);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIcon )( 
            IImageList __RPC_FAR * This,
            int i,
            UINT flags,
            HICON __RPC_FAR *picon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImageInfo )( 
            IImageList __RPC_FAR * This,
            int i,
            IMAGEINFO __RPC_FAR *pImageInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Copy )( 
            IImageList __RPC_FAR * This,
            int iDst,
            IUnknown __RPC_FAR *punkSrc,
            int iSrc,
            UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Merge )( 
            IImageList __RPC_FAR * This,
            int i1,
            IUnknown __RPC_FAR *punk2,
            int i2,
            int dx,
            int dy,
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IImageList __RPC_FAR * This,
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImageRect )( 
            IImageList __RPC_FAR * This,
            int i,
            RECT __RPC_FAR *prc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIconSize )( 
            IImageList __RPC_FAR * This,
            int __RPC_FAR *cx,
            int __RPC_FAR *cy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIconSize )( 
            IImageList __RPC_FAR * This,
            int cx,
            int cy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImageCount )( 
            IImageList __RPC_FAR * This,
            int __RPC_FAR *pi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetImageCount )( 
            IImageList __RPC_FAR * This,
            UINT uNewCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBkColor )( 
            IImageList __RPC_FAR * This,
            COLORREF clrBk,
            COLORREF __RPC_FAR *pclr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBkColor )( 
            IImageList __RPC_FAR * This,
            COLORREF __RPC_FAR *pclr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginDrag )( 
            IImageList __RPC_FAR * This,
            int iTrack,
            int dxHotspot,
            int dyHotspot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndDrag )( 
            IImageList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DragEnter )( 
            IImageList __RPC_FAR * This,
            HWND hwndLock,
            int x,
            int y);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DragLeave )( 
            IImageList __RPC_FAR * This,
            HWND hwndLock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DragMove )( 
            IImageList __RPC_FAR * This,
            int x,
            int y);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDragCursorImage )( 
            IImageList __RPC_FAR * This,
            IUnknown __RPC_FAR *punk,
            int iDrag,
            int dxHotspot,
            int dyHotspot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DragShowNolock )( 
            IImageList __RPC_FAR * This,
            BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDragImage )( 
            IImageList __RPC_FAR * This,
            POINT __RPC_FAR *ppt,
            POINT __RPC_FAR *pptHotspot,
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItemFlags )( 
            IImageList __RPC_FAR * This,
            int i,
            DWORD __RPC_FAR *dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOverlayImage )( 
            IImageList __RPC_FAR * This,
            int iOverlay,
            int __RPC_FAR *piIndex);
        
        END_INTERFACE
    } IImageListVtbl;

    interface IImageList
    {
        CONST_VTBL struct IImageListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageList_Add(This,hbmImage,hbmMask,pi)	\
    (This)->lpVtbl -> Add(This,hbmImage,hbmMask,pi)

#define IImageList_ReplaceIcon(This,i,hicon,pi)	\
    (This)->lpVtbl -> ReplaceIcon(This,i,hicon,pi)

#define IImageList_SetOverlayImage(This,iImage,iOverlay)	\
    (This)->lpVtbl -> SetOverlayImage(This,iImage,iOverlay)

#define IImageList_Replace(This,i,hbmImage,hbmMask)	\
    (This)->lpVtbl -> Replace(This,i,hbmImage,hbmMask)

#define IImageList_AddMasked(This,hbmImage,crMask,pi)	\
    (This)->lpVtbl -> AddMasked(This,hbmImage,crMask,pi)

#define IImageList_Draw(This,pimldp)	\
    (This)->lpVtbl -> Draw(This,pimldp)

#define IImageList_Remove(This,i)	\
    (This)->lpVtbl -> Remove(This,i)

#define IImageList_GetIcon(This,i,flags,picon)	\
    (This)->lpVtbl -> GetIcon(This,i,flags,picon)

#define IImageList_GetImageInfo(This,i,pImageInfo)	\
    (This)->lpVtbl -> GetImageInfo(This,i,pImageInfo)

#define IImageList_Copy(This,iDst,punkSrc,iSrc,uFlags)	\
    (This)->lpVtbl -> Copy(This,iDst,punkSrc,iSrc,uFlags)

#define IImageList_Merge(This,i1,punk2,i2,dx,dy,riid,ppv)	\
    (This)->lpVtbl -> Merge(This,i1,punk2,i2,dx,dy,riid,ppv)

#define IImageList_Clone(This,riid,ppv)	\
    (This)->lpVtbl -> Clone(This,riid,ppv)

#define IImageList_GetImageRect(This,i,prc)	\
    (This)->lpVtbl -> GetImageRect(This,i,prc)

#define IImageList_GetIconSize(This,cx,cy)	\
    (This)->lpVtbl -> GetIconSize(This,cx,cy)

#define IImageList_SetIconSize(This,cx,cy)	\
    (This)->lpVtbl -> SetIconSize(This,cx,cy)

#define IImageList_GetImageCount(This,pi)	\
    (This)->lpVtbl -> GetImageCount(This,pi)

#define IImageList_SetImageCount(This,uNewCount)	\
    (This)->lpVtbl -> SetImageCount(This,uNewCount)

#define IImageList_SetBkColor(This,clrBk,pclr)	\
    (This)->lpVtbl -> SetBkColor(This,clrBk,pclr)

#define IImageList_GetBkColor(This,pclr)	\
    (This)->lpVtbl -> GetBkColor(This,pclr)

#define IImageList_BeginDrag(This,iTrack,dxHotspot,dyHotspot)	\
    (This)->lpVtbl -> BeginDrag(This,iTrack,dxHotspot,dyHotspot)

#define IImageList_EndDrag(This)	\
    (This)->lpVtbl -> EndDrag(This)

#define IImageList_DragEnter(This,hwndLock,x,y)	\
    (This)->lpVtbl -> DragEnter(This,hwndLock,x,y)

#define IImageList_DragLeave(This,hwndLock)	\
    (This)->lpVtbl -> DragLeave(This,hwndLock)

#define IImageList_DragMove(This,x,y)	\
    (This)->lpVtbl -> DragMove(This,x,y)

#define IImageList_SetDragCursorImage(This,punk,iDrag,dxHotspot,dyHotspot)	\
    (This)->lpVtbl -> SetDragCursorImage(This,punk,iDrag,dxHotspot,dyHotspot)

#define IImageList_DragShowNolock(This,fShow)	\
    (This)->lpVtbl -> DragShowNolock(This,fShow)

#define IImageList_GetDragImage(This,ppt,pptHotspot,riid,ppv)	\
    (This)->lpVtbl -> GetDragImage(This,ppt,pptHotspot,riid,ppv)

#define IImageList_GetItemFlags(This,i,dwFlags)	\
    (This)->lpVtbl -> GetItemFlags(This,i,dwFlags)

#define IImageList_GetOverlayImage(This,iOverlay,piIndex)	\
    (This)->lpVtbl -> GetOverlayImage(This,iOverlay,piIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImageList_Add_Proxy( 
    IImageList __RPC_FAR * This,
    HBITMAP hbmImage,
    HBITMAP hbmMask,
    int __RPC_FAR *pi);


void __RPC_STUB IImageList_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_ReplaceIcon_Proxy( 
    IImageList __RPC_FAR * This,
    int i,
    HICON hicon,
    int __RPC_FAR *pi);


void __RPC_STUB IImageList_ReplaceIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_SetOverlayImage_Proxy( 
    IImageList __RPC_FAR * This,
    int iImage,
    int iOverlay);


void __RPC_STUB IImageList_SetOverlayImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_Replace_Proxy( 
    IImageList __RPC_FAR * This,
    int i,
    HBITMAP hbmImage,
    HBITMAP hbmMask);


void __RPC_STUB IImageList_Replace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_AddMasked_Proxy( 
    IImageList __RPC_FAR * This,
    HBITMAP hbmImage,
    COLORREF crMask,
    int __RPC_FAR *pi);


void __RPC_STUB IImageList_AddMasked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_Draw_Proxy( 
    IImageList __RPC_FAR * This,
    IMAGELISTDRAWPARAMS __RPC_FAR *pimldp);


void __RPC_STUB IImageList_Draw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_Remove_Proxy( 
    IImageList __RPC_FAR * This,
    int i);


void __RPC_STUB IImageList_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_GetIcon_Proxy( 
    IImageList __RPC_FAR * This,
    int i,
    UINT flags,
    HICON __RPC_FAR *picon);


void __RPC_STUB IImageList_GetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_GetImageInfo_Proxy( 
    IImageList __RPC_FAR * This,
    int i,
    IMAGEINFO __RPC_FAR *pImageInfo);


void __RPC_STUB IImageList_GetImageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_Copy_Proxy( 
    IImageList __RPC_FAR * This,
    int iDst,
    IUnknown __RPC_FAR *punkSrc,
    int iSrc,
    UINT uFlags);


void __RPC_STUB IImageList_Copy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_Merge_Proxy( 
    IImageList __RPC_FAR * This,
    int i1,
    IUnknown __RPC_FAR *punk2,
    int i2,
    int dx,
    int dy,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IImageList_Merge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_Clone_Proxy( 
    IImageList __RPC_FAR * This,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IImageList_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_GetImageRect_Proxy( 
    IImageList __RPC_FAR * This,
    int i,
    RECT __RPC_FAR *prc);


void __RPC_STUB IImageList_GetImageRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_GetIconSize_Proxy( 
    IImageList __RPC_FAR * This,
    int __RPC_FAR *cx,
    int __RPC_FAR *cy);


void __RPC_STUB IImageList_GetIconSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_SetIconSize_Proxy( 
    IImageList __RPC_FAR * This,
    int cx,
    int cy);


void __RPC_STUB IImageList_SetIconSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_GetImageCount_Proxy( 
    IImageList __RPC_FAR * This,
    int __RPC_FAR *pi);


void __RPC_STUB IImageList_GetImageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_SetImageCount_Proxy( 
    IImageList __RPC_FAR * This,
    UINT uNewCount);


void __RPC_STUB IImageList_SetImageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_SetBkColor_Proxy( 
    IImageList __RPC_FAR * This,
    COLORREF clrBk,
    COLORREF __RPC_FAR *pclr);


void __RPC_STUB IImageList_SetBkColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_GetBkColor_Proxy( 
    IImageList __RPC_FAR * This,
    COLORREF __RPC_FAR *pclr);


void __RPC_STUB IImageList_GetBkColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_BeginDrag_Proxy( 
    IImageList __RPC_FAR * This,
    int iTrack,
    int dxHotspot,
    int dyHotspot);


void __RPC_STUB IImageList_BeginDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_EndDrag_Proxy( 
    IImageList __RPC_FAR * This);


void __RPC_STUB IImageList_EndDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_DragEnter_Proxy( 
    IImageList __RPC_FAR * This,
    HWND hwndLock,
    int x,
    int y);


void __RPC_STUB IImageList_DragEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_DragLeave_Proxy( 
    IImageList __RPC_FAR * This,
    HWND hwndLock);


void __RPC_STUB IImageList_DragLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_DragMove_Proxy( 
    IImageList __RPC_FAR * This,
    int x,
    int y);


void __RPC_STUB IImageList_DragMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_SetDragCursorImage_Proxy( 
    IImageList __RPC_FAR * This,
    IUnknown __RPC_FAR *punk,
    int iDrag,
    int dxHotspot,
    int dyHotspot);


void __RPC_STUB IImageList_SetDragCursorImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_DragShowNolock_Proxy( 
    IImageList __RPC_FAR * This,
    BOOL fShow);


void __RPC_STUB IImageList_DragShowNolock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_GetDragImage_Proxy( 
    IImageList __RPC_FAR * This,
    POINT __RPC_FAR *ppt,
    POINT __RPC_FAR *pptHotspot,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IImageList_GetDragImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_GetItemFlags_Proxy( 
    IImageList __RPC_FAR * This,
    int i,
    DWORD __RPC_FAR *dwFlags);


void __RPC_STUB IImageList_GetItemFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList_GetOverlayImage_Proxy( 
    IImageList __RPC_FAR * This,
    int iOverlay,
    int __RPC_FAR *piIndex);


void __RPC_STUB IImageList_GetOverlayImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_CommonControls_0148 */
/* [local] */ 

#define ILR_DEFAULT                  0x0000
#define ILR_HORIZONTAL_LEFT          0x0000
#define ILR_HORIZONTAL_CENTER        0x0001
#define ILR_HORIZONTAL_RIGHT         0x0002
#define ILR_VERTICAL_TOP             0x0000
#define ILR_VERTICAL_CENTER          0x0010
#define ILR_VERTICAL_BOTTOM          0x0020
#define ILR_SCALE_CLIP               0x0000
#define ILR_SCALE_ASPECTRATIO        0x0100


extern RPC_IF_HANDLE __MIDL_itf_CommonControls_0148_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_CommonControls_0148_v0_0_s_ifspec;

#ifndef __IImageList2_INTERFACE_DEFINED__
#define __IImageList2_INTERFACE_DEFINED__

/* interface IImageList2 */
/* [object][local][uuid] */ 

#define ILGOS_ALWAYS         0x00000000
#define ILGOS_FROMSTANDBY    0x00000001
#define ILFIP_ALWAYS         0x00000000
#define ILFIP_FROMSTANDBY    0x00000001
#define ILDI_PURGE       0x00000001
#define ILDI_STANDBY     0x00000002
#define ILDI_RESETACCESS 0x00000004
#define ILDI_QUERYACCESS 0x00000008
typedef struct tagIMAGELISTSTATS
    {
    DWORD cbSize;
    int cAlloc;
    int cUsed;
    int cStandby;
    }	IMAGELISTSTATS;


EXTERN_C const IID IID_IImageList2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("192b9d83-50fc-457b-90a0-2b82a8b5dae1")
    IImageList2 : public IImageList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Resize( 
            int cxNewIconSize,
            int cyNewIconSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalSize( 
            /* [in] */ int iImage,
            /* [in] */ DWORD dwFlags,
            int __RPC_FAR *pcx,
            int __RPC_FAR *pcy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOriginalSize( 
            /* [in] */ int iImage,
            /* [in] */ int cx,
            /* [in] */ int cy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            IUnknown __RPC_FAR *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallback( 
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceImagePresent( 
            /* [in] */ int iImage,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DiscardImages( 
            /* [in] */ int iFirstImage,
            /* [in] */ int iLastImage,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreloadImages( 
            /* [in] */ IMAGELISTDRAWPARAMS __RPC_FAR *pimldp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [out][in] */ IMAGELISTSTATS __RPC_FAR *pils) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ int cx,
            /* [in] */ int cy,
            /* [in] */ UINT flags,
            /* [in] */ int cInitial,
            /* [in] */ int cGrow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Replace2( 
            int i,
            /* [in] */ HBITMAP hbmImage,
            /* [in] */ HBITMAP hbmMask,
            /* [in] */ IUnknown __RPC_FAR *punk,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplaceFromImageList( 
            int i,
            /* [in] */ IImageList __RPC_FAR *pil,
            int iSrc,
            /* [in] */ IUnknown __RPC_FAR *punk,
            DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageList2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImageList2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImageList2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImageList2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IImageList2 __RPC_FAR * This,
            HBITMAP hbmImage,
            HBITMAP hbmMask,
            int __RPC_FAR *pi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReplaceIcon )( 
            IImageList2 __RPC_FAR * This,
            int i,
            HICON hicon,
            int __RPC_FAR *pi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOverlayImage )( 
            IImageList2 __RPC_FAR * This,
            int iImage,
            int iOverlay);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Replace )( 
            IImageList2 __RPC_FAR * This,
            int i,
            HBITMAP hbmImage,
            HBITMAP hbmMask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMasked )( 
            IImageList2 __RPC_FAR * This,
            HBITMAP hbmImage,
            COLORREF crMask,
            int __RPC_FAR *pi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Draw )( 
            IImageList2 __RPC_FAR * This,
            IMAGELISTDRAWPARAMS __RPC_FAR *pimldp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IImageList2 __RPC_FAR * This,
            int i);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIcon )( 
            IImageList2 __RPC_FAR * This,
            int i,
            UINT flags,
            HICON __RPC_FAR *picon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImageInfo )( 
            IImageList2 __RPC_FAR * This,
            int i,
            IMAGEINFO __RPC_FAR *pImageInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Copy )( 
            IImageList2 __RPC_FAR * This,
            int iDst,
            IUnknown __RPC_FAR *punkSrc,
            int iSrc,
            UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Merge )( 
            IImageList2 __RPC_FAR * This,
            int i1,
            IUnknown __RPC_FAR *punk2,
            int i2,
            int dx,
            int dy,
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IImageList2 __RPC_FAR * This,
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImageRect )( 
            IImageList2 __RPC_FAR * This,
            int i,
            RECT __RPC_FAR *prc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIconSize )( 
            IImageList2 __RPC_FAR * This,
            int __RPC_FAR *cx,
            int __RPC_FAR *cy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIconSize )( 
            IImageList2 __RPC_FAR * This,
            int cx,
            int cy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImageCount )( 
            IImageList2 __RPC_FAR * This,
            int __RPC_FAR *pi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetImageCount )( 
            IImageList2 __RPC_FAR * This,
            UINT uNewCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBkColor )( 
            IImageList2 __RPC_FAR * This,
            COLORREF clrBk,
            COLORREF __RPC_FAR *pclr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBkColor )( 
            IImageList2 __RPC_FAR * This,
            COLORREF __RPC_FAR *pclr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginDrag )( 
            IImageList2 __RPC_FAR * This,
            int iTrack,
            int dxHotspot,
            int dyHotspot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndDrag )( 
            IImageList2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DragEnter )( 
            IImageList2 __RPC_FAR * This,
            HWND hwndLock,
            int x,
            int y);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DragLeave )( 
            IImageList2 __RPC_FAR * This,
            HWND hwndLock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DragMove )( 
            IImageList2 __RPC_FAR * This,
            int x,
            int y);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDragCursorImage )( 
            IImageList2 __RPC_FAR * This,
            IUnknown __RPC_FAR *punk,
            int iDrag,
            int dxHotspot,
            int dyHotspot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DragShowNolock )( 
            IImageList2 __RPC_FAR * This,
            BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDragImage )( 
            IImageList2 __RPC_FAR * This,
            POINT __RPC_FAR *ppt,
            POINT __RPC_FAR *pptHotspot,
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItemFlags )( 
            IImageList2 __RPC_FAR * This,
            int i,
            DWORD __RPC_FAR *dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOverlayImage )( 
            IImageList2 __RPC_FAR * This,
            int iOverlay,
            int __RPC_FAR *piIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resize )( 
            IImageList2 __RPC_FAR * This,
            int cxNewIconSize,
            int cyNewIconSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOriginalSize )( 
            IImageList2 __RPC_FAR * This,
            /* [in] */ int iImage,
            /* [in] */ DWORD dwFlags,
            int __RPC_FAR *pcx,
            int __RPC_FAR *pcy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOriginalSize )( 
            IImageList2 __RPC_FAR * This,
            /* [in] */ int iImage,
            /* [in] */ int cx,
            /* [in] */ int cy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCallback )( 
            IImageList2 __RPC_FAR * This,
            IUnknown __RPC_FAR *punk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCallback )( 
            IImageList2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ForceImagePresent )( 
            IImageList2 __RPC_FAR * This,
            /* [in] */ int iImage,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DiscardImages )( 
            IImageList2 __RPC_FAR * This,
            /* [in] */ int iFirstImage,
            /* [in] */ int iLastImage,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PreloadImages )( 
            IImageList2 __RPC_FAR * This,
            /* [in] */ IMAGELISTDRAWPARAMS __RPC_FAR *pimldp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IImageList2 __RPC_FAR * This,
            /* [out][in] */ IMAGELISTSTATS __RPC_FAR *pils);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IImageList2 __RPC_FAR * This,
            /* [in] */ int cx,
            /* [in] */ int cy,
            /* [in] */ UINT flags,
            /* [in] */ int cInitial,
            /* [in] */ int cGrow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Replace2 )( 
            IImageList2 __RPC_FAR * This,
            int i,
            /* [in] */ HBITMAP hbmImage,
            /* [in] */ HBITMAP hbmMask,
            /* [in] */ IUnknown __RPC_FAR *punk,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReplaceFromImageList )( 
            IImageList2 __RPC_FAR * This,
            int i,
            /* [in] */ IImageList __RPC_FAR *pil,
            int iSrc,
            /* [in] */ IUnknown __RPC_FAR *punk,
            DWORD dwFlags);
        
        END_INTERFACE
    } IImageList2Vtbl;

    interface IImageList2
    {
        CONST_VTBL struct IImageList2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageList2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageList2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageList2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageList2_Add(This,hbmImage,hbmMask,pi)	\
    (This)->lpVtbl -> Add(This,hbmImage,hbmMask,pi)

#define IImageList2_ReplaceIcon(This,i,hicon,pi)	\
    (This)->lpVtbl -> ReplaceIcon(This,i,hicon,pi)

#define IImageList2_SetOverlayImage(This,iImage,iOverlay)	\
    (This)->lpVtbl -> SetOverlayImage(This,iImage,iOverlay)

#define IImageList2_Replace(This,i,hbmImage,hbmMask)	\
    (This)->lpVtbl -> Replace(This,i,hbmImage,hbmMask)

#define IImageList2_AddMasked(This,hbmImage,crMask,pi)	\
    (This)->lpVtbl -> AddMasked(This,hbmImage,crMask,pi)

#define IImageList2_Draw(This,pimldp)	\
    (This)->lpVtbl -> Draw(This,pimldp)

#define IImageList2_Remove(This,i)	\
    (This)->lpVtbl -> Remove(This,i)

#define IImageList2_GetIcon(This,i,flags,picon)	\
    (This)->lpVtbl -> GetIcon(This,i,flags,picon)

#define IImageList2_GetImageInfo(This,i,pImageInfo)	\
    (This)->lpVtbl -> GetImageInfo(This,i,pImageInfo)

#define IImageList2_Copy(This,iDst,punkSrc,iSrc,uFlags)	\
    (This)->lpVtbl -> Copy(This,iDst,punkSrc,iSrc,uFlags)

#define IImageList2_Merge(This,i1,punk2,i2,dx,dy,riid,ppv)	\
    (This)->lpVtbl -> Merge(This,i1,punk2,i2,dx,dy,riid,ppv)

#define IImageList2_Clone(This,riid,ppv)	\
    (This)->lpVtbl -> Clone(This,riid,ppv)

#define IImageList2_GetImageRect(This,i,prc)	\
    (This)->lpVtbl -> GetImageRect(This,i,prc)

#define IImageList2_GetIconSize(This,cx,cy)	\
    (This)->lpVtbl -> GetIconSize(This,cx,cy)

#define IImageList2_SetIconSize(This,cx,cy)	\
    (This)->lpVtbl -> SetIconSize(This,cx,cy)

#define IImageList2_GetImageCount(This,pi)	\
    (This)->lpVtbl -> GetImageCount(This,pi)

#define IImageList2_SetImageCount(This,uNewCount)	\
    (This)->lpVtbl -> SetImageCount(This,uNewCount)

#define IImageList2_SetBkColor(This,clrBk,pclr)	\
    (This)->lpVtbl -> SetBkColor(This,clrBk,pclr)

#define IImageList2_GetBkColor(This,pclr)	\
    (This)->lpVtbl -> GetBkColor(This,pclr)

#define IImageList2_BeginDrag(This,iTrack,dxHotspot,dyHotspot)	\
    (This)->lpVtbl -> BeginDrag(This,iTrack,dxHotspot,dyHotspot)

#define IImageList2_EndDrag(This)	\
    (This)->lpVtbl -> EndDrag(This)

#define IImageList2_DragEnter(This,hwndLock,x,y)	\
    (This)->lpVtbl -> DragEnter(This,hwndLock,x,y)

#define IImageList2_DragLeave(This,hwndLock)	\
    (This)->lpVtbl -> DragLeave(This,hwndLock)

#define IImageList2_DragMove(This,x,y)	\
    (This)->lpVtbl -> DragMove(This,x,y)

#define IImageList2_SetDragCursorImage(This,punk,iDrag,dxHotspot,dyHotspot)	\
    (This)->lpVtbl -> SetDragCursorImage(This,punk,iDrag,dxHotspot,dyHotspot)

#define IImageList2_DragShowNolock(This,fShow)	\
    (This)->lpVtbl -> DragShowNolock(This,fShow)

#define IImageList2_GetDragImage(This,ppt,pptHotspot,riid,ppv)	\
    (This)->lpVtbl -> GetDragImage(This,ppt,pptHotspot,riid,ppv)

#define IImageList2_GetItemFlags(This,i,dwFlags)	\
    (This)->lpVtbl -> GetItemFlags(This,i,dwFlags)

#define IImageList2_GetOverlayImage(This,iOverlay,piIndex)	\
    (This)->lpVtbl -> GetOverlayImage(This,iOverlay,piIndex)


#define IImageList2_Resize(This,cxNewIconSize,cyNewIconSize)	\
    (This)->lpVtbl -> Resize(This,cxNewIconSize,cyNewIconSize)

#define IImageList2_GetOriginalSize(This,iImage,dwFlags,pcx,pcy)	\
    (This)->lpVtbl -> GetOriginalSize(This,iImage,dwFlags,pcx,pcy)

#define IImageList2_SetOriginalSize(This,iImage,cx,cy)	\
    (This)->lpVtbl -> SetOriginalSize(This,iImage,cx,cy)

#define IImageList2_SetCallback(This,punk)	\
    (This)->lpVtbl -> SetCallback(This,punk)

#define IImageList2_GetCallback(This,riid,ppv)	\
    (This)->lpVtbl -> GetCallback(This,riid,ppv)

#define IImageList2_ForceImagePresent(This,iImage,dwFlags)	\
    (This)->lpVtbl -> ForceImagePresent(This,iImage,dwFlags)

#define IImageList2_DiscardImages(This,iFirstImage,iLastImage,dwFlags)	\
    (This)->lpVtbl -> DiscardImages(This,iFirstImage,iLastImage,dwFlags)

#define IImageList2_PreloadImages(This,pimldp)	\
    (This)->lpVtbl -> PreloadImages(This,pimldp)

#define IImageList2_GetStatistics(This,pils)	\
    (This)->lpVtbl -> GetStatistics(This,pils)

#define IImageList2_Initialize(This,cx,cy,flags,cInitial,cGrow)	\
    (This)->lpVtbl -> Initialize(This,cx,cy,flags,cInitial,cGrow)

#define IImageList2_Replace2(This,i,hbmImage,hbmMask,punk,dwFlags)	\
    (This)->lpVtbl -> Replace2(This,i,hbmImage,hbmMask,punk,dwFlags)

#define IImageList2_ReplaceFromImageList(This,i,pil,iSrc,punk,dwFlags)	\
    (This)->lpVtbl -> ReplaceFromImageList(This,i,pil,iSrc,punk,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImageList2_Resize_Proxy( 
    IImageList2 __RPC_FAR * This,
    int cxNewIconSize,
    int cyNewIconSize);


void __RPC_STUB IImageList2_Resize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList2_GetOriginalSize_Proxy( 
    IImageList2 __RPC_FAR * This,
    /* [in] */ int iImage,
    /* [in] */ DWORD dwFlags,
    int __RPC_FAR *pcx,
    int __RPC_FAR *pcy);


void __RPC_STUB IImageList2_GetOriginalSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList2_SetOriginalSize_Proxy( 
    IImageList2 __RPC_FAR * This,
    /* [in] */ int iImage,
    /* [in] */ int cx,
    /* [in] */ int cy);


void __RPC_STUB IImageList2_SetOriginalSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList2_SetCallback_Proxy( 
    IImageList2 __RPC_FAR * This,
    IUnknown __RPC_FAR *punk);


void __RPC_STUB IImageList2_SetCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList2_GetCallback_Proxy( 
    IImageList2 __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IImageList2_GetCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList2_ForceImagePresent_Proxy( 
    IImageList2 __RPC_FAR * This,
    /* [in] */ int iImage,
    DWORD dwFlags);


void __RPC_STUB IImageList2_ForceImagePresent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList2_DiscardImages_Proxy( 
    IImageList2 __RPC_FAR * This,
    /* [in] */ int iFirstImage,
    /* [in] */ int iLastImage,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImageList2_DiscardImages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList2_PreloadImages_Proxy( 
    IImageList2 __RPC_FAR * This,
    /* [in] */ IMAGELISTDRAWPARAMS __RPC_FAR *pimldp);


void __RPC_STUB IImageList2_PreloadImages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList2_GetStatistics_Proxy( 
    IImageList2 __RPC_FAR * This,
    /* [out][in] */ IMAGELISTSTATS __RPC_FAR *pils);


void __RPC_STUB IImageList2_GetStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList2_Initialize_Proxy( 
    IImageList2 __RPC_FAR * This,
    /* [in] */ int cx,
    /* [in] */ int cy,
    /* [in] */ UINT flags,
    /* [in] */ int cInitial,
    /* [in] */ int cGrow);


void __RPC_STUB IImageList2_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList2_Replace2_Proxy( 
    IImageList2 __RPC_FAR * This,
    int i,
    /* [in] */ HBITMAP hbmImage,
    /* [in] */ HBITMAP hbmMask,
    /* [in] */ IUnknown __RPC_FAR *punk,
    DWORD dwFlags);


void __RPC_STUB IImageList2_Replace2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageList2_ReplaceFromImageList_Proxy( 
    IImageList2 __RPC_FAR * This,
    int i,
    /* [in] */ IImageList __RPC_FAR *pil,
    int iSrc,
    /* [in] */ IUnknown __RPC_FAR *punk,
    DWORD dwFlags);


void __RPC_STUB IImageList2_ReplaceFromImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageList2_INTERFACE_DEFINED__ */



#ifndef __CommonControlObjects_LIBRARY_DEFINED__
#define __CommonControlObjects_LIBRARY_DEFINED__

/* library CommonControlObjects */
/* [uuid] */ 


EXTERN_C const IID LIBID_CommonControlObjects;

EXTERN_C const CLSID CLSID_ImageList;

#ifdef __cplusplus

class DECLSPEC_UUID("7C476BA2-02B1-48f4-8048-B24619DDC058")
ImageList;
#endif
#endif /* __CommonControlObjects_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_CommonControls_0149 */
/* [local] */ 

#endif // if (_WIN32_IE >= 0x0501)


extern RPC_IF_HANDLE __MIDL_itf_CommonControls_0149_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_CommonControls_0149_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\connmgr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _connmgr_h_
#define _connmgr_h_

#ifdef __cplusplus
extern "C" {
#endif

// {436EF144-B4FB-4863-A041-8F905A62C572}
DEFINE_GUID(IID_DestNetInternet,     0x436ef144, 0xb4fb, 0x4863, 0xa0, 0x41, 0x8f, 0x90, 0x5a, 0x62, 0xc5, 0x72);

// {A1182988-0D73-439e-87AD-2A5B369F808B}
DEFINE_GUID(IID_DestNetCorp,         0xa1182988, 0x0d73, 0x439e, 0x87, 0xad, 0x2a, 0x5b, 0x36, 0x9f, 0x80, 0x8b);

// {7022E968-5A97-4051-BC1C-C578E2FBA5D9}
DEFINE_GUID(IID_DestNetWAP,          0x7022e968, 0x5a97, 0x4051, 0xbc, 0x1c, 0xc5, 0x78, 0xe2, 0xfb, 0xa5, 0xd9);

// {F28D1F74-72BE-4394-A4A7-4E296219390C}
DEFINE_GUID(IID_DestNetSecureWAP,    0xf28d1f74, 0x72be, 0x4394, 0xa4, 0xa7, 0x4e, 0x29, 0x62, 0x19, 0x39, 0x0c);

//
// Connection Manager
//

//
// Client API
//

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @constants Valid Params | Defines valid parameters in CONNMGR_CONNECTIONINFO
//
// @comm The following flags in the dwParams field of the CONNMGR_CONNECTIONINFO structure
// define which optional parameters are valid.
//
// -----------------------------------------------------------------------------
#define CONNMGR_PARAM_GUIDDESTNET       (0x1) // @constdefine guidDestNet field is valid
#define CONNMGR_PARAM_MAXCOST           (0x2) // @constdefine MaxCost field is valid
#define CONNMGR_PARAM_MINRCVBW          (0x4) // @constdefine MinRcvBw field is valid
#define CONNMGR_PARAM_MAXCONNLATENCY    (0x8) // @constdefine MaxConnLatency field is valid

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @constants Proxy flags | Defines which proxies the application supports
//
// @comm The following flags in the dwFlags field of the CONNMGR_CONNECTIONINFO structure
// define special connection properties supported by client apps, typically which proxies are
// supported by each app. For example, each CONNMGR_FLAG_PROXY_* specifies that this connection
// can be specified by configuring an appropriate proxy server.  e.g. HTTP this is appropriate
// for Internet Explorer and other HTTP based protocols, including HTTP-DAV synchronization.
// If none of these flags are specified, then only a direct IP connection (or tunnel) will be attempted.
//
// -----------------------------------------------------------------------------
#define CONNMGR_FLAG_PROXY_HTTP		(0x1) // @constdefine HTTP Proxy supported
#define CONNMGR_FLAG_PROXY_WAP      (0x2) // @constdefine WAP Proxy (gateway) supported
#define CONNMGR_FLAG_PROXY_SOCKS4   (0x4) // @constdefine SOCKS4 Proxy supported
#define CONNMGR_FLAG_PROXY_SOCKS5   (0x8) // @constdefine SOCKS5 Proxy supported

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @constants Control flags | Defines connection properties
//
// @comm The following flags in the dwFlags field of the CONNMGR_CONNECTIONINFO structure
// define special connection properties supported by client apps,
//
// -----------------------------------------------------------------------------
#define CONNMGR_FLAG_SUSPEND_AWARE    (0x10) // @constdefine suspended connections supported
#define CONNMGR_FLAG_REGISTERED_HOME  (0x20) // @constdefine only dial out if we're registered on the home network
#define CONNMGR_FLAG_NO_ERROR_MSGS    (0x40) // @constdefine don't show any error messages for failed connections
#define CONNMGR_FLAG_WAKE_ON_INCOMING (0x80) // @constdefine to satisfy request use only those interfaces that can wake the system on incoming traffic

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @constants Priority | Defines which priority of the applications connections
//
// @comm The following flags in the dwPriority field of the CONNMGR_CONNECTIONINFO structure
// define the priority of the connection. Connection manager arbitrates among multiple connections,
// satisfying as many as possible at a time but giving preference to higher priorities
//
// -----------------------------------------------------------------------------

#define CONNMGR_PRIORITY_VOICE          		0x20000
// @constdefine Voice, highest priority, reserved for internal use only.

#define CONNMGR_PRIORITY_USERINTERACTIVE		0x08000
// @constdefine User initiated action caused this request, and UI is        	
// currently pending on the creation of this connection.
// This is appropriate for an interactive browsing session,
// or if the user selects "MORE" at the bottom of a truncated
// mail message, etc.


#define CONNMGR_PRIORITY_USERBACKGROUND		    0x02000
// @constdefine User initiated connection which has recently become idle.
// A connection should be marked as idle when it is no
// longer the user's current task.		

#define CONNMGR_PRIORITY_USERIDLE				0x0800		
// @constdefine Interactive user task which has been idle for an application
// specified time.  The application should toggle the state
// between CONNMGR_PRIORITY_USERIDLE and CONNMGR_PRIORITY_USERINTERACTIVE as the user
// uses the application.  This helps ConnectionManager
// optimize responsiveness to the interactive application,
// while sharing the connection with background applications.

#define CONNMGR_PRIORITY_HIPRIBKGND			    0x0200
// @constdefine High priority background connection

#define CONNMGR_PRIORITY_IDLEBKGND			    0x0080
// @constdefine Idle priority background connection

#define CONNMGR_PRIORITY_EXTERNALINTERACTIVE	0x0020
// @constdefine Connection is requested on behalf of an external entity, but
// is an interactive session (e.g. AT Command Iterpreter)

#define CONNMGR_PRIORITY_LOWBKGND               0x0008
// @constdefine Lowest priority. Only connects if another higher priority client is already using the same path.

#define CONNMGR_PRIORITY_CACHED                 0x0002
// @constdefine Cached connection, reserved for internal use only.

#define CONNMGR_PRIORITY_ALWAYS_ON              0x0001
// @constdefine Always on  connection, reserved for internal use only.

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @struct CONNMGR_CONNECTIONINFO | Information about connection request
//
// @comm None
//
// -----------------------------------------------------------------------------
typedef struct _CONNMGR_CONNECTIONINFO
{
    DWORD cbSize;       // @field Size of this structure
    DWORD dwParams;     // @field Valid parms, set of CONNMGR_PARAM_*
    DWORD dwFlags;      // @field Connection flags, set of CONNMGR_FLAG_*
    DWORD dwPriority;   // @field Priority, one of CONNMGR_PRIORITY_*
    BOOL bExclusive;    // @field Connection is exclusive, see comments
    BOOL bDisabled;     // @field Don't actually connect
    GUID guidDestNet;   // @field GUID of network to connect to
    HWND hWnd;          // @field hWnd to post status change messages to
    UINT uMsg;          // @field Msg to use when posting status changes
    LPARAM lParam;      // @field lParam to use when posting status changes
    ULONG ulMaxCost;    // @field Max acceptable cost of connection
    ULONG ulMinRcvBw;   // @field Min acceptable receive bandwidth of connection
    ULONG ulMaxConnLatency; // @field Max acceptable connect latency
} CONNMGR_CONNECTIONINFO;

// @comm bExclusive: If false, the connection is shared among all applications, and other
// applications with an interest in a connection to this network will be notified that
// the connection is available.  If true, then this connection can not be shared with other
// applications, and no other applications will be notified, and any application requesting
// a connection to the same network will be treated as a contender for
// the same resource, and not permitted to share the existing connection.  A decision will be made
// between this connection and the others based on connection priority.

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func Creates a connection request.
//
// @comm Return Value:  S_OK if success, error code otherwise
//
// -----------------------------------------------------------------------------
HRESULT WINAPI ConnMgrEstablishConnection
    (
    CONNMGR_CONNECTIONINFO *pConnInfo,  // @parm Params describing requested connection
    HANDLE *phConnection                // @parm Returned connection handle
    );

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func Creates a connection request.
//
// @comm Return Value:  Same as ConnMgrEstablishConnection, but doesn't return
// until connection has either been established or failed.
//
// -----------------------------------------------------------------------------
HRESULT WINAPI ConnMgrEstablishConnectionSync
    (
    CONNMGR_CONNECTIONINFO *pConnInfo,  // @parm Params describing requested connection
    HANDLE *phConnection,               // @parm Returned connection handle
    DWORD dwTimeout,                    // @parm Timeout
    DWORD *pdwStatus                    // @parm Final status value, one of CONNMGR_STATUS_*
    );

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @constants Status values | Describes the current status of the connection
//
// @comm none
//
// -----------------------------------------------------------------------------

#define CONNMGR_STATUS_UNKNOWN                    0x00  // @constdefine Unknown status

#define CONNMGR_STATUS_CONNECTED                  0x10  // @constdefine Connection is up
#define CONNMGR_STATUS_SUSPENDED                  0x11  // @constdefine Connection is up but suspended

#define CONNMGR_STATUS_DISCONNECTED               0x20  // @constdefine Connection is disconnected
#define CONNMGR_STATUS_CONNECTIONFAILED           0x21  // @constdefine Connection failed and cannot not be reestablished
#define CONNMGR_STATUS_CONNECTIONCANCELED         0x22  // @constdefine User aborted connection
#define CONNMGR_STATUS_CONNECTIONDISABLED         0x23  // @constdefine Connection is ready to connect but disabled
#define CONNMGR_STATUS_NOPATHTODESTINATION        0x24  // @constdefine No path could be found to destination
#define CONNMGR_STATUS_WAITINGFORPATH             0x25  // @constdefine Waiting for a path to the destination
#define CONNMGR_STATUS_WAITINGFORPHONE            0x26  // @constdefine Voice call is in progress
#define CONNMGR_STATUS_PHONEOFF                   0x27  // @constdefine Phone resource needed and phone is off
#define CONNMGR_STATUS_EXCLUSIVECONFLICT          0x28  // @constdefine the connection could not be established because it would multi-home an exclusive connection
#define CONNMGR_STATUS_NORESOURCES                0x29  // @constdefine Failed to allocate resources to make the connection.
#define CONNMGR_STATUS_CONNECTIONLINKFAILED       0x2A  // @constdefine Connection link disconnected prematurely.
#define CONNMGR_STATUS_AUTHENTICATIONFAILED       0x2B  // @constdefine Failed to authenticate user.
#define CONNMGR_STATUS_NOPATHWITHPROPERTY         0x2C  // @constdefine Path with connection having requested property, ex. WAKE_ON_INCOMING, is not available.

#define CONNMGR_STATUS_WAITINGCONNECTION          0x40  // @constdefine Attempting to connect
#define CONNMGR_STATUS_WAITINGFORRESOURCE         0x41  // @constdefine Resource is in use by another connection
#define CONNMGR_STATUS_WAITINGFORNETWORK          0x42  // @constdefine Network is used by higher priority thread or device is roaming.

#define CONNMGR_STATUS_WAITINGDISCONNECTION       0x80  // @constdefine Connection is being brought down
#define CONNMGR_STATUS_WAITINGCONNECTIONABORT     0x81  // @constdefine Aborting connection attempt


// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func Returns status about the current connection.
//
// @comm none
//
// -----------------------------------------------------------------------------
HRESULT WINAPI ConnMgrConnectionStatus
    (
    HANDLE hConnection,    // @parm Handle to connection, returned from ConnMgrEstablishConnection
    DWORD *pdwStatus       // @parm Returns current connection status, one of CONNMGR_STATUS_*
    );

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func Deletes specified connection request, potentially dropping the physical connection.
//
// @comm none
//
// -----------------------------------------------------------------------------
HRESULT WINAPI ConnMgrReleaseConnection
    (
    HANDLE hConnection,    // @parm Handle to connection, returned from ConnMgrEstablishConnection
    LONG lCache            // @parm ConnMgr can cache connection
    );

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func Changes a connection's priority.
//
// @comm none
//
// -----------------------------------------------------------------------------
HRESULT WINAPI ConnMgrSetConnectionPriority
    (
    HANDLE hConnection,    // @parm Handle to connection, returned from ConnMgrEstablishConnection
    DWORD dwPriority       // @parm New priority
    );

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func General purpose (backdoor) API for exchanging information with planner or providers.
//
// @comm none
//
// -----------------------------------------------------------------------------
HRESULT WINAPI ConnMgrProviderMessage
    (
    HANDLE hConnection,         // @parm Optional, Handle to connection
    const GUID *pguidProvider,  // @parm Provider GUID
    DWORD *pdwIndex,            // @parm Optional index, used to address multiple providers associated with connection
    DWORD dwMsg1,               // @parm General param 1
    DWORD dwMsg2,               // @parm General param 2
    PBYTE pParams,              // @param Pointer to params structure
    ULONG cbParamSize           // @param size of params structure
    );

#define CONNMGR_MAX_DESC 128    // @constdefine Max size of a network description

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @struct CONNMGR_DESTINATION_INFO | Information about a specific network
//
// @comm None
//
// -----------------------------------------------------------------------------
typedef struct _CONNMGR_DESTINATION_INFO
{
    GUID guid;  // @field GUID associated with network
    TCHAR szDescription[CONNMGR_MAX_DESC];  // @field Description of network
    BOOL fSecure; // @field Is it OK to allow multi-homing on the network
} CONNMGR_DESTINATION_INFO;


// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func Enumerates available networks.
//
// @comm none
//
// -----------------------------------------------------------------------------
HRESULT WINAPI ConnMgrEnumDestinations
    (
    int nIndex,                            // @param Index of network
    CONNMGR_DESTINATION_INFO *pDestInfo    // @param ptr to structure to fill in with info about network
    );

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @struct SCHEDULEDCONNECTIONINFO | Information about a scheduled connection
//
// @comm None
//
// -----------------------------------------------------------------------------
typedef struct _SCHEDULEDCONNECTIONINFO
{
    GUID guidDest;                  // @field Guid of network
    UINT64 uiStartTime;             // @field Starting time, same ref as filetime
    UINT64 uiEndTime;               // @field Ending time, same ref as filetime
    UINT64 uiPeriod;                // @field Period between schedule attempts
    TCHAR szAppName[MAX_PATH];    // @field App name to execute when scheduled
    TCHAR szCmdLine[MAX_PATH];    // @field Cmd line to execute when scheduled
    TCHAR szToken[32];            // @field Unique token identifying this scheduled connection
    BOOL bPiggyback;                // @field If true, execute app whenever network is available
} SCHEDULEDCONNECTIONINFO;

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func Registers a scheduled connection
//
// @comm none
//
// -----------------------------------------------------------------------------
HRESULT WINAPI ConnMgrRegisterScheduledConnection
    (
     SCHEDULEDCONNECTIONINFO *pSCI  // @param Ptr to struct describing scheduled connection
     );

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func Unregisters a scheduled connection
//
// @comm none
//
// -----------------------------------------------------------------------------
HRESULT WINAPI ConnMgrUnregisterScheduledConnection
    (
     LPCTSTR pwszToken  // @param Token of scheduled connection to unregister
     );

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func Maps a URL to a destination network GUID
//
// @comm none
//
// -----------------------------------------------------------------------------
HRESULT WINAPI ConnMgrMapURL
    (
     LPCTSTR pwszURL, // @parm URL to map
     GUID *pguid,     // @parm Returned network GUID
     DWORD *pdwIndex  // @parm Index in table for next search
     );

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func Returns a handle to an event which becomes signaled when the ConnMgr API
// is ready to be used. Caller is responsible for calling CloseHandle on the returned event.
//
// @comm none
//
// -----------------------------------------------------------------------------
HANDLE WINAPI ConnMgrApiReadyEvent();

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @constants Defines the type of a connection reference
//
// @comm none
//
// -----------------------------------------------------------------------------

typedef enum _ConnMgrConRefTypeEnum
{
    ConRefType_NAP = 0,     // @constdefine NAP connection reference
    ConRefType_PROXY        // @constdefine PROXY connection reference
} ConnMgrConRefTypeEnum;

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func Maps a connection reference to its corresponding GUID
//
// @comm none
//
// -----------------------------------------------------------------------------

HRESULT WINAPI ConnMgrMapConRef
(
    ConnMgrConRefTypeEnum e,        // @parm Specify type of connection reference
    LPCTSTR szConRef,               // @parm Connection reference to map
    GUID *pGUID                     // @parm Returned connection reference GUID
);

#ifdef __cplusplus
}
#endif

#endif // _connmgr_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\combase.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Base class hierachy for creating COM objects, December 1994

/*

a. Derive your COM object from CUnknown

b. Make a static CreateInstance function that takes an LPUNKNOWN, an HRESULT *
   and a TCHAR *. The LPUNKNOWN defines the object to delegate IUnknown calls
   to. The HRESULT * allows error codes to be passed around constructors and
   the TCHAR * is a descriptive name that can be printed on the debugger.

   It is important that constructors only change the HRESULT * if they have
   to set an ERROR code, if it was successful then leave it alone or you may
   overwrite an error code from an object previously created.

   When you call a constructor the descriptive name should be in static store
   as we do not copy the string. To stop large amounts of memory being used
   in retail builds by all these static strings use the NAME macro,

   CMyFilter = new CImplFilter(NAME("My filter"),pUnknown,phr);
   if (FAILED(hr)) {
       return hr;
   }

   In retail builds NAME(_x_) compiles to NULL, the base CBaseObject class
   knows not to do anything with objects that don't have a name.

c. Have a constructor for your object that passes the LPUNKNOWN, HRESULT * and
   TCHAR * to the CUnknown constructor. You can set the HRESULT if you have an
   error, or just simply pass it through to the constructor.

   The object creation will fail in the class factory if the HRESULT indicates
   an error (ie FAILED(HRESULT) == TRUE)

d. Create a FactoryTemplate with your object's class id and CreateInstance
   function.

Then (for each interface) either

Multiple inheritance

1. Also derive it from ISomeInterface
2. Include DECLARE_IUNKNOWN in your class definition to declare
   implementations of QueryInterface, AddRef and Release that
   call the outer unknown
3. Override NonDelegatingQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CUnknown::NonDelegatingQueryInterface(riid, ppv);
     }

4. Declare and implement the member functions of ISomeInterface.

or: Nested interfaces

1. Declare a class derived from CUnknown
2. Include DECLARE_IUNKNOWN in your class definition
3. Override NonDelegatingQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CUnknown::NonDelegatingQueryInterface(riid, ppv);
     }

4. Implement the member functions of ISomeInterface. Use GetOwner() to
   access the COM object class.

And in your COM object class:

5. Make the nested class a friend of the COM object class, and declare
   an instance of the nested class as a member of the COM object class.

   NOTE that because you must always pass the outer unknown and an hResult
   to the CUnknown constructor you cannot use a default constructor, in
   other words you will have to make the member variable a pointer to the
   class and make a NEW call in your constructor to actually create it.

6. override the NonDelegatingQueryInterface with code like this:

     if (riid == IID_ISomeInterface) {
         return m_pImplFilter->
            NonDelegatingQueryInterface(IID_ISomeInterface, ppv);
     } else {
         return CUnknown::NonDelegatingQueryInterface(riid, ppv);
     }

You can have mixed classes which support some interfaces via multiple
inheritance and some via nested classes

*/

#ifndef __COMBASE__
#define __COMBASE__

// Filter Setup data structures no defined in axextend.idl

typedef REGPINTYPES
AMOVIESETUP_MEDIATYPE, * PAMOVIESETUP_MEDIATYPE, * FAR LPAMOVIESETUP_MEDIATYPE;

typedef REGFILTERPINS
AMOVIESETUP_PIN, * PAMOVIESETUP_PIN, * FAR LPAMOVIESETUP_PIN;

typedef struct _AMOVIESETUP_FILTER
{
  const CLSID * clsID;
  const WCHAR * strName;
  DWORD      dwMerit;
  UINT       nPins;
  const AMOVIESETUP_PIN * lpPin;
}
AMOVIESETUP_FILTER, * PAMOVIESETUP_FILTER, * FAR LPAMOVIESETUP_FILTER;

/* The DLLENTRY module initialises the module handle on loading */

extern HINSTANCE g_hInst;

/* On DLL load remember which platform we are running on */

extern DWORD g_amPlatform;
extern OSVERSIONINFO g_osInfo;     // Filled in by GetVersionEx

/* Version of IUnknown that is renamed to allow a class to support both
   non delegating and delegating IUnknowns in the same COM object */

#ifndef INONDELEGATINGUNKNOWN_DEFINED
DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD(NonDelegatingQueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG, NonDelegatingAddRef)(THIS) PURE;
    STDMETHOD_(ULONG, NonDelegatingRelease)(THIS) PURE;
};
#define INONDELEGATINGUNKNOWN_DEFINED
#endif

typedef INonDelegatingUnknown *PNDUNKNOWN;


/* This is the base object class that supports active object counting. As
   part of the debug facilities we trace every time a C++ object is created
   or destroyed. The name of the object has to be passed up through the class
   derivation list during construction as you cannot call virtual functions
   in the constructor. The downside of all this is that every single object
   constructor has to take an object name parameter that describes it */

class CBaseObject
{

private:

    // Disable the copy constructor and assignment by default so you will get
    //   compiler errors instead of unexpected behaviour if you pass objects
    //   by value or assign objects.
    CBaseObject(const CBaseObject& objectSrc);          // no implementation
    void operator=(const CBaseObject& objectSrc);       // no implementation

private:
    static LONG m_cObjects;         /* Total number of objects active */

protected:
#ifdef DEBUG
    DWORD m_dwCookie;               /* Cookie identifying this object */
    static DWORD m_dwBreakOnCookie; /* break into the debugger and set this
                                       to some cookie value to have it break
                                       into the debugger when we addref or
                                       release that object */
    static DWORD m_dwPrintOnCookie; /* set this to some cookie value to have it print out
                                       info when we addref or release just that object */
#endif


public:

    /* These increment and decrement the number of active objects */

    CBaseObject(const TCHAR *pName);
    ~CBaseObject();

    /* Call this to find if there are any CUnknown derived objects active */

    static LONG ObjectsActive() {
        return m_cObjects;
    };
};


/* An object that supports one or more COM interfaces will be based on
   this class. It supports counting of total objects for DLLCanUnloadNow
   support, and an implementation of the core non delegating IUnknown */

class AM_NOVTABLE CUnknown : public INonDelegatingUnknown,
                 public CBaseObject
{
private:
    const LPUNKNOWN m_pUnknown; /* Owner of this object */

protected:                      /* So we can override NonDelegatingRelease() */
    volatile LONG m_cRef;       /* Number of reference counts */

public:

    CUnknown(const TCHAR *pName, LPUNKNOWN pUnk);
    virtual ~CUnknown() {};

    // This is redundant, just use the other constructor
    //   as we never touch the HRESULT in this anyway
    CUnknown(TCHAR *pName, LPUNKNOWN pUnk,HRESULT *phr);

    /* Return the owner of this object */

    LPUNKNOWN GetOwner() const {
        return m_pUnknown;
    };

    /* Called from the class factory to create a new instance, it is
       pure virtual so it must be overriden in your derived class */

    /* static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *) */

    /* Non delegating unknown implementation */

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
};

/* Return an interface pointer to a requesting client
   performing a thread safe AddRef as necessary */

STDAPI GetInterface(LPUNKNOWN pUnk, void **ppv);

/* A function that can create a new COM object */

typedef CUnknown *(CALLBACK *LPFNNewCOMObject)(LPUNKNOWN pUnkOuter, HRESULT *phr);

/*  A function (can be NULL) which is called from the DLL entrypoint
    routine for each factory template:

    bLoading - TRUE on DLL load, FALSE on DLL unload
    rclsid   - the m_ClsID of the entry
*/
typedef void (CALLBACK *LPFNInitRoutine)(BOOL bLoading, const CLSID *rclsid);

inline BOOL InCOMBaseIsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
   return (
      ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
      ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
      ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
      ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}


/* Create one of these per object class in an array so that
   the default class factory code can create new instances */

class CFactoryTemplate {

public:

    const WCHAR *              m_Name;
    const CLSID *              m_ClsID;
    LPFNNewCOMObject           m_lpfnNew;
    LPFNInitRoutine            m_lpfnInit;
    const AMOVIESETUP_FILTER * m_pAMovieSetup_Filter;

    BOOL IsClassID(REFCLSID rclsid) const {
        return (InCOMBaseIsEqualGUID(*m_ClsID,rclsid));
    };

    CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr) const {
        CheckPointer(phr,NULL);
        return m_lpfnNew(pUnk, phr);
    };
};


/* You must override the (pure virtual) NonDelegatingQueryInterface to return
   interface pointers (using GetInterface) to the interfaces your derived
   class supports (the default implementation only supports IUnknown) */

#define DECLARE_IUNKNOWN                                        \
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) {      \
        return GetOwner()->QueryInterface(riid,ppv);            \
    };                                                          \
    STDMETHODIMP_(ULONG) AddRef() {                             \
        return GetOwner()->AddRef();                            \
    };                                                          \
    STDMETHODIMP_(ULONG) Release() {                            \
        return GetOwner()->Release();                           \
    };



HINSTANCE	LoadOLEAut32();


#endif /* __COMBASE__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\connmgr_proxy.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma once

// Proxy CSP config/settings
DEFINE_GUID(IID_ConnPrv_IProxyExtension, 0xaf96b0bd, 0xa481, 0x482c, 0xa0, 0x94, 0xa8, 0x44, 0x87, 0x67, 0xa0, 0xc0);

#define CMPROXY_PROXYSERVER_MAXSIZE 256
#define CMPROXY_USERNAME_MAXSIZE 32
#define CMPROXY_PASSWORD_MAXSIZE 32
#define CMPROXY_EXTRAINFO_MAXSIZE 256
#define CMPROXY_PROXYOVERRIDE_MAXSIZE 64

typedef struct _PROXY_CONFIG
{
    DWORD dwType;
    DWORD dwEnable;
    TCHAR szProxyServer[CMPROXY_PROXYSERVER_MAXSIZE];
    TCHAR szUsername[CMPROXY_USERNAME_MAXSIZE];
    TCHAR szPassword[CMPROXY_PASSWORD_MAXSIZE];
    TCHAR szProxyOverride[CMPROXY_PROXYOVERRIDE_MAXSIZE];
    TCHAR szExtraInfo[CMPROXY_EXTRAINFO_MAXSIZE];
} PROXY_CONFIG;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\control.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for control.odl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __control_h__
#define __control_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAMCollection_FWD_DEFINED__
#define __IAMCollection_FWD_DEFINED__
typedef interface IAMCollection IAMCollection;
#endif 	/* __IAMCollection_FWD_DEFINED__ */


#ifndef __IMediaControl_FWD_DEFINED__
#define __IMediaControl_FWD_DEFINED__
typedef interface IMediaControl IMediaControl;
#endif 	/* __IMediaControl_FWD_DEFINED__ */


#ifndef __IMediaEvent_FWD_DEFINED__
#define __IMediaEvent_FWD_DEFINED__
typedef interface IMediaEvent IMediaEvent;
#endif 	/* __IMediaEvent_FWD_DEFINED__ */


#ifndef __IMediaEventEx_FWD_DEFINED__
#define __IMediaEventEx_FWD_DEFINED__
typedef interface IMediaEventEx IMediaEventEx;
#endif 	/* __IMediaEventEx_FWD_DEFINED__ */


#ifndef __IMediaPosition_FWD_DEFINED__
#define __IMediaPosition_FWD_DEFINED__
typedef interface IMediaPosition IMediaPosition;
#endif 	/* __IMediaPosition_FWD_DEFINED__ */


#ifndef __IBasicAudio_FWD_DEFINED__
#define __IBasicAudio_FWD_DEFINED__
typedef interface IBasicAudio IBasicAudio;
#endif 	/* __IBasicAudio_FWD_DEFINED__ */


#ifndef __IVideoWindow_FWD_DEFINED__
#define __IVideoWindow_FWD_DEFINED__
typedef interface IVideoWindow IVideoWindow;
#endif 	/* __IVideoWindow_FWD_DEFINED__ */


#ifndef __IBasicVideo_FWD_DEFINED__
#define __IBasicVideo_FWD_DEFINED__
typedef interface IBasicVideo IBasicVideo;
#endif 	/* __IBasicVideo_FWD_DEFINED__ */


#ifndef __IBasicVideo2_FWD_DEFINED__
#define __IBasicVideo2_FWD_DEFINED__
typedef interface IBasicVideo2 IBasicVideo2;
#endif 	/* __IBasicVideo2_FWD_DEFINED__ */


#ifndef __IDeferredCommand_FWD_DEFINED__
#define __IDeferredCommand_FWD_DEFINED__
typedef interface IDeferredCommand IDeferredCommand;
#endif 	/* __IDeferredCommand_FWD_DEFINED__ */


#ifndef __IQueueCommand_FWD_DEFINED__
#define __IQueueCommand_FWD_DEFINED__
typedef interface IQueueCommand IQueueCommand;
#endif 	/* __IQueueCommand_FWD_DEFINED__ */


#ifndef __FilgraphManager_FWD_DEFINED__
#define __FilgraphManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class FilgraphManager FilgraphManager;
#else
typedef struct FilgraphManager FilgraphManager;
#endif /* __cplusplus */

#endif 	/* __FilgraphManager_FWD_DEFINED__ */


#ifndef __IFilterInfo_FWD_DEFINED__
#define __IFilterInfo_FWD_DEFINED__
typedef interface IFilterInfo IFilterInfo;
#endif 	/* __IFilterInfo_FWD_DEFINED__ */


#ifndef __IRegFilterInfo_FWD_DEFINED__
#define __IRegFilterInfo_FWD_DEFINED__
typedef interface IRegFilterInfo IRegFilterInfo;
#endif 	/* __IRegFilterInfo_FWD_DEFINED__ */


#ifndef __IMediaTypeInfo_FWD_DEFINED__
#define __IMediaTypeInfo_FWD_DEFINED__
typedef interface IMediaTypeInfo IMediaTypeInfo;
#endif 	/* __IMediaTypeInfo_FWD_DEFINED__ */


#ifndef __IPinInfo_FWD_DEFINED__
#define __IPinInfo_FWD_DEFINED__
typedef interface IPinInfo IPinInfo;
#endif 	/* __IPinInfo_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __QuartzTypeLib_LIBRARY_DEFINED__
#define __QuartzTypeLib_LIBRARY_DEFINED__

/* library QuartzTypeLib */
/* [version][lcid][helpstring][uuid] */ 

#define OATRUE (-1)
#define OAFALSE (0)
typedef double REFTIME;

typedef long OAEVENT;

typedef long OAHWND;

typedef long OAFilterState;


DEFINE_GUID(LIBID_QuartzTypeLib,0x56a868b0,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#ifndef __IAMCollection_INTERFACE_DEFINED__
#define __IAMCollection_INTERFACE_DEFINED__

/* interface IAMCollection */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMCollection,0x56a868b9,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b9-0ad4-11ce-b03a-0020af0ba770")
    IAMCollection : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long lItem,
            /* [out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IAMCollection * This,
            /* [retval][out] */ LONG *plCount);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            IAMCollection * This,
            /* [in] */ long lItem,
            /* [out] */ IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IAMCollection * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IAMCollectionVtbl;

    interface IAMCollection
    {
        CONST_VTBL struct IAMCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMCollection_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define IAMCollection_Item(This,lItem,ppUnk)	\
    ( (This)->lpVtbl -> Item(This,lItem,ppUnk) ) 

#define IAMCollection_get__NewEnum(This,ppUnk)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMCollection_INTERFACE_DEFINED__ */


#ifndef __IMediaControl_INTERFACE_DEFINED__
#define __IMediaControl_INTERFACE_DEFINED__

/* interface IMediaControl */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaControl,0x56a868b1,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b1-0ad4-11ce-b03a-0020af0ba770")
    IMediaControl : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ LONG msTimeout,
            /* [out] */ OAFilterState *pfs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderFile( 
            /* [in] */ BSTR strFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSourceFilter( 
            /* [in] */ BSTR strFilename,
            /* [out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterCollection( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RegFilterCollection( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopWhenReady( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMediaControl * This,
            /* [in] */ LONG msTimeout,
            /* [out] */ OAFilterState *pfs);
        
        HRESULT ( STDMETHODCALLTYPE *RenderFile )( 
            IMediaControl * This,
            /* [in] */ BSTR strFilename);
        
        HRESULT ( STDMETHODCALLTYPE *AddSourceFilter )( 
            IMediaControl * This,
            /* [in] */ BSTR strFilename,
            /* [out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterCollection )( 
            IMediaControl * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RegFilterCollection )( 
            IMediaControl * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *StopWhenReady )( 
            IMediaControl * This);
        
        END_INTERFACE
    } IMediaControlVtbl;

    interface IMediaControl
    {
        CONST_VTBL struct IMediaControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaControl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaControl_Run(This)	\
    ( (This)->lpVtbl -> Run(This) ) 

#define IMediaControl_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IMediaControl_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMediaControl_GetState(This,msTimeout,pfs)	\
    ( (This)->lpVtbl -> GetState(This,msTimeout,pfs) ) 

#define IMediaControl_RenderFile(This,strFilename)	\
    ( (This)->lpVtbl -> RenderFile(This,strFilename) ) 

#define IMediaControl_AddSourceFilter(This,strFilename,ppUnk)	\
    ( (This)->lpVtbl -> AddSourceFilter(This,strFilename,ppUnk) ) 

#define IMediaControl_get_FilterCollection(This,ppUnk)	\
    ( (This)->lpVtbl -> get_FilterCollection(This,ppUnk) ) 

#define IMediaControl_get_RegFilterCollection(This,ppUnk)	\
    ( (This)->lpVtbl -> get_RegFilterCollection(This,ppUnk) ) 

#define IMediaControl_StopWhenReady(This)	\
    ( (This)->lpVtbl -> StopWhenReady(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaControl_INTERFACE_DEFINED__ */


#ifndef __IMediaEvent_INTERFACE_DEFINED__
#define __IMediaEvent_INTERFACE_DEFINED__

/* interface IMediaEvent */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaEvent,0x56a868b6,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b6-0ad4-11ce-b03a-0020af0ba770")
    IMediaEvent : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEventHandle( 
            /* [out] */ OAEVENT *hEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEvent( 
            /* [out] */ long *lEventCode,
            /* [out] */ long *lParam1,
            /* [out] */ long *lParam2,
            /* [in] */ long msTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForCompletion( 
            /* [in] */ long msTimeout,
            /* [out] */ long *pEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelDefaultHandling( 
            /* [in] */ long lEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreDefaultHandling( 
            /* [in] */ long lEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeEventParams( 
            /* [in] */ long lEvCode,
            /* [in] */ long lParam1,
            /* [in] */ long lParam2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventHandle )( 
            IMediaEvent * This,
            /* [out] */ OAEVENT *hEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMediaEvent * This,
            /* [out] */ long *lEventCode,
            /* [out] */ long *lParam1,
            /* [out] */ long *lParam2,
            /* [in] */ long msTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForCompletion )( 
            IMediaEvent * This,
            /* [in] */ long msTimeout,
            /* [out] */ long *pEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *CancelDefaultHandling )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDefaultHandling )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *FreeEventParams )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode,
            /* [in] */ long lParam1,
            /* [in] */ long lParam2);
        
        END_INTERFACE
    } IMediaEventVtbl;

    interface IMediaEvent
    {
        CONST_VTBL struct IMediaEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaEvent_GetEventHandle(This,hEvent)	\
    ( (This)->lpVtbl -> GetEventHandle(This,hEvent) ) 

#define IMediaEvent_GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)	\
    ( (This)->lpVtbl -> GetEvent(This,lEventCode,lParam1,lParam2,msTimeout) ) 

#define IMediaEvent_WaitForCompletion(This,msTimeout,pEvCode)	\
    ( (This)->lpVtbl -> WaitForCompletion(This,msTimeout,pEvCode) ) 

#define IMediaEvent_CancelDefaultHandling(This,lEvCode)	\
    ( (This)->lpVtbl -> CancelDefaultHandling(This,lEvCode) ) 

#define IMediaEvent_RestoreDefaultHandling(This,lEvCode)	\
    ( (This)->lpVtbl -> RestoreDefaultHandling(This,lEvCode) ) 

#define IMediaEvent_FreeEventParams(This,lEvCode,lParam1,lParam2)	\
    ( (This)->lpVtbl -> FreeEventParams(This,lEvCode,lParam1,lParam2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaEvent_INTERFACE_DEFINED__ */


#ifndef __IMediaEventEx_INTERFACE_DEFINED__
#define __IMediaEventEx_INTERFACE_DEFINED__

/* interface IMediaEventEx */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaEventEx,0x56a868c0,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868c0-0ad4-11ce-b03a-0020af0ba770")
    IMediaEventEx : public IMediaEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNotifyWindow( 
            /* [in] */ OAHWND hwnd,
            /* [in] */ long lMsg,
            /* [in] */ long lInstanceData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotifyFlags( 
            /* [in] */ long lNoNotifyFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNotifyFlags( 
            /* [out] */ long *lplNoNotifyFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaEventExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaEventEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaEventEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaEventEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaEventEx * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaEventEx * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaEventEx * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaEventEx * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventHandle )( 
            IMediaEventEx * This,
            /* [out] */ OAEVENT *hEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMediaEventEx * This,
            /* [out] */ long *lEventCode,
            /* [out] */ long *lParam1,
            /* [out] */ long *lParam2,
            /* [in] */ long msTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForCompletion )( 
            IMediaEventEx * This,
            /* [in] */ long msTimeout,
            /* [out] */ long *pEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *CancelDefaultHandling )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDefaultHandling )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *FreeEventParams )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode,
            /* [in] */ long lParam1,
            /* [in] */ long lParam2);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifyWindow )( 
            IMediaEventEx * This,
            /* [in] */ OAHWND hwnd,
            /* [in] */ long lMsg,
            /* [in] */ long lInstanceData);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifyFlags )( 
            IMediaEventEx * This,
            /* [in] */ long lNoNotifyFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetNotifyFlags )( 
            IMediaEventEx * This,
            /* [out] */ long *lplNoNotifyFlags);
        
        END_INTERFACE
    } IMediaEventExVtbl;

    interface IMediaEventEx
    {
        CONST_VTBL struct IMediaEventExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaEventEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaEventEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaEventEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaEventEx_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaEventEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaEventEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaEventEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaEventEx_GetEventHandle(This,hEvent)	\
    ( (This)->lpVtbl -> GetEventHandle(This,hEvent) ) 

#define IMediaEventEx_GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)	\
    ( (This)->lpVtbl -> GetEvent(This,lEventCode,lParam1,lParam2,msTimeout) ) 

#define IMediaEventEx_WaitForCompletion(This,msTimeout,pEvCode)	\
    ( (This)->lpVtbl -> WaitForCompletion(This,msTimeout,pEvCode) ) 

#define IMediaEventEx_CancelDefaultHandling(This,lEvCode)	\
    ( (This)->lpVtbl -> CancelDefaultHandling(This,lEvCode) ) 

#define IMediaEventEx_RestoreDefaultHandling(This,lEvCode)	\
    ( (This)->lpVtbl -> RestoreDefaultHandling(This,lEvCode) ) 

#define IMediaEventEx_FreeEventParams(This,lEvCode,lParam1,lParam2)	\
    ( (This)->lpVtbl -> FreeEventParams(This,lEvCode,lParam1,lParam2) ) 


#define IMediaEventEx_SetNotifyWindow(This,hwnd,lMsg,lInstanceData)	\
    ( (This)->lpVtbl -> SetNotifyWindow(This,hwnd,lMsg,lInstanceData) ) 

#define IMediaEventEx_SetNotifyFlags(This,lNoNotifyFlags)	\
    ( (This)->lpVtbl -> SetNotifyFlags(This,lNoNotifyFlags) ) 

#define IMediaEventEx_GetNotifyFlags(This,lplNoNotifyFlags)	\
    ( (This)->lpVtbl -> GetNotifyFlags(This,lplNoNotifyFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaEventEx_INTERFACE_DEFINED__ */


#ifndef __IMediaPosition_INTERFACE_DEFINED__
#define __IMediaPosition_INTERFACE_DEFINED__

/* interface IMediaPosition */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaPosition,0x56a868b2,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b2-0ad4-11ce-b03a-0020af0ba770")
    IMediaPosition : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ REFTIME *plength) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CurrentPosition( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPosition( 
            /* [retval][out] */ REFTIME *pllTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_StopTime( 
            /* [retval][out] */ REFTIME *pllTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StopTime( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrerollTime( 
            /* [retval][out] */ REFTIME *pllTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PrerollTime( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double dRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [retval][out] */ double *pdRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSeekForward( 
            /* [retval][out] */ LONG *pCanSeekForward) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSeekBackward( 
            /* [retval][out] */ LONG *pCanSeekBackward) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaPositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaPosition * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaPosition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaPosition * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaPosition * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaPosition * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaPosition * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaPosition * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IMediaPosition * This,
            /* [retval][out] */ REFTIME *plength);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IMediaPosition * This,
            /* [retval][out] */ REFTIME *pllTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_StopTime )( 
            IMediaPosition * This,
            /* [retval][out] */ REFTIME *pllTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_StopTime )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrerollTime )( 
            IMediaPosition * This,
            /* [retval][out] */ REFTIME *pllTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrerollTime )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IMediaPosition * This,
            /* [in] */ double dRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IMediaPosition * This,
            /* [retval][out] */ double *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *CanSeekForward )( 
            IMediaPosition * This,
            /* [retval][out] */ LONG *pCanSeekForward);
        
        HRESULT ( STDMETHODCALLTYPE *CanSeekBackward )( 
            IMediaPosition * This,
            /* [retval][out] */ LONG *pCanSeekBackward);
        
        END_INTERFACE
    } IMediaPositionVtbl;

    interface IMediaPosition
    {
        CONST_VTBL struct IMediaPositionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaPosition_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaPosition_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaPosition_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaPosition_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaPosition_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaPosition_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaPosition_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaPosition_get_Duration(This,plength)	\
    ( (This)->lpVtbl -> get_Duration(This,plength) ) 

#define IMediaPosition_put_CurrentPosition(This,llTime)	\
    ( (This)->lpVtbl -> put_CurrentPosition(This,llTime) ) 

#define IMediaPosition_get_CurrentPosition(This,pllTime)	\
    ( (This)->lpVtbl -> get_CurrentPosition(This,pllTime) ) 

#define IMediaPosition_get_StopTime(This,pllTime)	\
    ( (This)->lpVtbl -> get_StopTime(This,pllTime) ) 

#define IMediaPosition_put_StopTime(This,llTime)	\
    ( (This)->lpVtbl -> put_StopTime(This,llTime) ) 

#define IMediaPosition_get_PrerollTime(This,pllTime)	\
    ( (This)->lpVtbl -> get_PrerollTime(This,pllTime) ) 

#define IMediaPosition_put_PrerollTime(This,llTime)	\
    ( (This)->lpVtbl -> put_PrerollTime(This,llTime) ) 

#define IMediaPosition_put_Rate(This,dRate)	\
    ( (This)->lpVtbl -> put_Rate(This,dRate) ) 

#define IMediaPosition_get_Rate(This,pdRate)	\
    ( (This)->lpVtbl -> get_Rate(This,pdRate) ) 

#define IMediaPosition_CanSeekForward(This,pCanSeekForward)	\
    ( (This)->lpVtbl -> CanSeekForward(This,pCanSeekForward) ) 

#define IMediaPosition_CanSeekBackward(This,pCanSeekBackward)	\
    ( (This)->lpVtbl -> CanSeekBackward(This,pCanSeekBackward) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaPosition_INTERFACE_DEFINED__ */


#ifndef __IBasicAudio_INTERFACE_DEFINED__
#define __IBasicAudio_INTERFACE_DEFINED__

/* interface IBasicAudio */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicAudio,0x56a868b3,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b3-0ad4-11ce-b03a-0020af0ba770")
    IBasicAudio : public IDispatch
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ long lVolume) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [retval][out] */ long *plVolume) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Balance( 
            /* [in] */ long lBalance) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Balance( 
            /* [retval][out] */ long *plBalance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicAudioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicAudio * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicAudio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicAudio * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicAudio * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicAudio * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicAudio * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicAudio * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            IBasicAudio * This,
            /* [in] */ long lVolume);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            IBasicAudio * This,
            /* [retval][out] */ long *plVolume);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Balance )( 
            IBasicAudio * This,
            /* [in] */ long lBalance);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Balance )( 
            IBasicAudio * This,
            /* [retval][out] */ long *plBalance);
        
        END_INTERFACE
    } IBasicAudioVtbl;

    interface IBasicAudio
    {
        CONST_VTBL struct IBasicAudioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicAudio_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBasicAudio_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBasicAudio_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBasicAudio_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IBasicAudio_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IBasicAudio_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IBasicAudio_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IBasicAudio_put_Volume(This,lVolume)	\
    ( (This)->lpVtbl -> put_Volume(This,lVolume) ) 

#define IBasicAudio_get_Volume(This,plVolume)	\
    ( (This)->lpVtbl -> get_Volume(This,plVolume) ) 

#define IBasicAudio_put_Balance(This,lBalance)	\
    ( (This)->lpVtbl -> put_Balance(This,lBalance) ) 

#define IBasicAudio_get_Balance(This,plBalance)	\
    ( (This)->lpVtbl -> get_Balance(This,plBalance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBasicAudio_INTERFACE_DEFINED__ */


#ifndef __IVideoWindow_INTERFACE_DEFINED__
#define __IVideoWindow_INTERFACE_DEFINED__

/* interface IVideoWindow */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IVideoWindow,0x56a868b4,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b4-0ad4-11ce-b03a-0020af0ba770")
    IVideoWindow : public IDispatch
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Caption( 
            /* [in] */ BSTR strCaption) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR *strCaption) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowStyle( 
            /* [in] */ long WindowStyle) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowStyle( 
            /* [retval][out] */ long *WindowStyle) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowStyleEx( 
            /* [in] */ long WindowStyleEx) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowStyleEx( 
            /* [retval][out] */ long *WindowStyleEx) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AutoShow( 
            /* [in] */ long AutoShow) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AutoShow( 
            /* [retval][out] */ long *AutoShow) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowState( 
            /* [in] */ long WindowState) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowState( 
            /* [retval][out] */ long *WindowState) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BackgroundPalette( 
            /* [in] */ long BackgroundPalette) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BackgroundPalette( 
            /* [retval][out] */ long *pBackgroundPalette) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ long Visible) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ long *pVisible) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ long Left) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ long *pLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long Width) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ long *pWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ long Top) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ long *pTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long Height) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ long *pHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Owner( 
            /* [in] */ OAHWND Owner) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Owner( 
            /* [retval][out] */ OAHWND *Owner) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MessageDrain( 
            /* [in] */ OAHWND Drain) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MessageDrain( 
            /* [retval][out] */ OAHWND *Drain) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BorderColor( 
            /* [retval][out] */ long *Color) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BorderColor( 
            /* [in] */ long Color) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FullScreenMode( 
            /* [retval][out] */ long *FullScreenMode) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FullScreenMode( 
            /* [in] */ long FullScreenMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWindowForeground( 
            /* [in] */ long Focus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOwnerMessage( 
            /* [in] */ OAHWND hwnd,
            /* [in] */ long uMsg,
            /* [in] */ long wParam,
            /* [in] */ long lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWindowPosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWindowPosition( 
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinIdealImageSize( 
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxIdealImageSize( 
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRestorePosition( 
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HideCursor( 
            /* [in] */ long HideCursor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCursorHidden( 
            /* [out] */ long *CursorHidden) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVideoWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVideoWindow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVideoWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVideoWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVideoWindow * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVideoWindow * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVideoWindow * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVideoWindow * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Caption )( 
            IVideoWindow * This,
            /* [in] */ BSTR strCaption);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Caption )( 
            IVideoWindow * This,
            /* [retval][out] */ BSTR *strCaption);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowStyle )( 
            IVideoWindow * This,
            /* [in] */ long WindowStyle);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowStyle )( 
            IVideoWindow * This,
            /* [retval][out] */ long *WindowStyle);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowStyleEx )( 
            IVideoWindow * This,
            /* [in] */ long WindowStyleEx);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowStyleEx )( 
            IVideoWindow * This,
            /* [retval][out] */ long *WindowStyleEx);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoShow )( 
            IVideoWindow * This,
            /* [in] */ long AutoShow);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoShow )( 
            IVideoWindow * This,
            /* [retval][out] */ long *AutoShow);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowState )( 
            IVideoWindow * This,
            /* [in] */ long WindowState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowState )( 
            IVideoWindow * This,
            /* [retval][out] */ long *WindowState);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_BackgroundPalette )( 
            IVideoWindow * This,
            /* [in] */ long BackgroundPalette);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackgroundPalette )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pBackgroundPalette);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            IVideoWindow * This,
            /* [in] */ long Visible);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pVisible);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Left )( 
            IVideoWindow * This,
            /* [in] */ long Left);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Left )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            IVideoWindow * This,
            /* [in] */ long Width);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Top )( 
            IVideoWindow * This,
            /* [in] */ long Top);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Top )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Height )( 
            IVideoWindow * This,
            /* [in] */ long Height);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Owner )( 
            IVideoWindow * This,
            /* [in] */ OAHWND Owner);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Owner )( 
            IVideoWindow * This,
            /* [retval][out] */ OAHWND *Owner);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MessageDrain )( 
            IVideoWindow * This,
            /* [in] */ OAHWND Drain);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageDrain )( 
            IVideoWindow * This,
            /* [retval][out] */ OAHWND *Drain);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BorderColor )( 
            IVideoWindow * This,
            /* [retval][out] */ long *Color);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_BorderColor )( 
            IVideoWindow * This,
            /* [in] */ long Color);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FullScreenMode )( 
            IVideoWindow * This,
            /* [retval][out] */ long *FullScreenMode);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FullScreenMode )( 
            IVideoWindow * This,
            /* [in] */ long FullScreenMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetWindowForeground )( 
            IVideoWindow * This,
            /* [in] */ long Focus);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOwnerMessage )( 
            IVideoWindow * This,
            /* [in] */ OAHWND hwnd,
            /* [in] */ long uMsg,
            /* [in] */ long wParam,
            /* [in] */ long lParam);
        
        HRESULT ( STDMETHODCALLTYPE *SetWindowPosition )( 
            IVideoWindow * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowPosition )( 
            IVideoWindow * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinIdealImageSize )( 
            IVideoWindow * This,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxIdealImageSize )( 
            IVideoWindow * This,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetRestorePosition )( 
            IVideoWindow * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *HideCursor )( 
            IVideoWindow * This,
            /* [in] */ long HideCursor);
        
        HRESULT ( STDMETHODCALLTYPE *IsCursorHidden )( 
            IVideoWindow * This,
            /* [out] */ long *CursorHidden);
        
        END_INTERFACE
    } IVideoWindowVtbl;

    interface IVideoWindow
    {
        CONST_VTBL struct IVideoWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVideoWindow_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVideoWindow_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVideoWindow_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVideoWindow_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVideoWindow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVideoWindow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVideoWindow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVideoWindow_put_Caption(This,strCaption)	\
    ( (This)->lpVtbl -> put_Caption(This,strCaption) ) 

#define IVideoWindow_get_Caption(This,strCaption)	\
    ( (This)->lpVtbl -> get_Caption(This,strCaption) ) 

#define IVideoWindow_put_WindowStyle(This,WindowStyle)	\
    ( (This)->lpVtbl -> put_WindowStyle(This,WindowStyle) ) 

#define IVideoWindow_get_WindowStyle(This,WindowStyle)	\
    ( (This)->lpVtbl -> get_WindowStyle(This,WindowStyle) ) 

#define IVideoWindow_put_WindowStyleEx(This,WindowStyleEx)	\
    ( (This)->lpVtbl -> put_WindowStyleEx(This,WindowStyleEx) ) 

#define IVideoWindow_get_WindowStyleEx(This,WindowStyleEx)	\
    ( (This)->lpVtbl -> get_WindowStyleEx(This,WindowStyleEx) ) 

#define IVideoWindow_put_AutoShow(This,AutoShow)	\
    ( (This)->lpVtbl -> put_AutoShow(This,AutoShow) ) 

#define IVideoWindow_get_AutoShow(This,AutoShow)	\
    ( (This)->lpVtbl -> get_AutoShow(This,AutoShow) ) 

#define IVideoWindow_put_WindowState(This,WindowState)	\
    ( (This)->lpVtbl -> put_WindowState(This,WindowState) ) 

#define IVideoWindow_get_WindowState(This,WindowState)	\
    ( (This)->lpVtbl -> get_WindowState(This,WindowState) ) 

#define IVideoWindow_put_BackgroundPalette(This,BackgroundPalette)	\
    ( (This)->lpVtbl -> put_BackgroundPalette(This,BackgroundPalette) ) 

#define IVideoWindow_get_BackgroundPalette(This,pBackgroundPalette)	\
    ( (This)->lpVtbl -> get_BackgroundPalette(This,pBackgroundPalette) ) 

#define IVideoWindow_put_Visible(This,Visible)	\
    ( (This)->lpVtbl -> put_Visible(This,Visible) ) 

#define IVideoWindow_get_Visible(This,pVisible)	\
    ( (This)->lpVtbl -> get_Visible(This,pVisible) ) 

#define IVideoWindow_put_Left(This,Left)	\
    ( (This)->lpVtbl -> put_Left(This,Left) ) 

#define IVideoWindow_get_Left(This,pLeft)	\
    ( (This)->lpVtbl -> get_Left(This,pLeft) ) 

#define IVideoWindow_put_Width(This,Width)	\
    ( (This)->lpVtbl -> put_Width(This,Width) ) 

#define IVideoWindow_get_Width(This,pWidth)	\
    ( (This)->lpVtbl -> get_Width(This,pWidth) ) 

#define IVideoWindow_put_Top(This,Top)	\
    ( (This)->lpVtbl -> put_Top(This,Top) ) 

#define IVideoWindow_get_Top(This,pTop)	\
    ( (This)->lpVtbl -> get_Top(This,pTop) ) 

#define IVideoWindow_put_Height(This,Height)	\
    ( (This)->lpVtbl -> put_Height(This,Height) ) 

#define IVideoWindow_get_Height(This,pHeight)	\
    ( (This)->lpVtbl -> get_Height(This,pHeight) ) 

#define IVideoWindow_put_Owner(This,Owner)	\
    ( (This)->lpVtbl -> put_Owner(This,Owner) ) 

#define IVideoWindow_get_Owner(This,Owner)	\
    ( (This)->lpVtbl -> get_Owner(This,Owner) ) 

#define IVideoWindow_put_MessageDrain(This,Drain)	\
    ( (This)->lpVtbl -> put_MessageDrain(This,Drain) ) 

#define IVideoWindow_get_MessageDrain(This,Drain)	\
    ( (This)->lpVtbl -> get_MessageDrain(This,Drain) ) 

#define IVideoWindow_get_BorderColor(This,Color)	\
    ( (This)->lpVtbl -> get_BorderColor(This,Color) ) 

#define IVideoWindow_put_BorderColor(This,Color)	\
    ( (This)->lpVtbl -> put_BorderColor(This,Color) ) 

#define IVideoWindow_get_FullScreenMode(This,FullScreenMode)	\
    ( (This)->lpVtbl -> get_FullScreenMode(This,FullScreenMode) ) 

#define IVideoWindow_put_FullScreenMode(This,FullScreenMode)	\
    ( (This)->lpVtbl -> put_FullScreenMode(This,FullScreenMode) ) 

#define IVideoWindow_SetWindowForeground(This,Focus)	\
    ( (This)->lpVtbl -> SetWindowForeground(This,Focus) ) 

#define IVideoWindow_NotifyOwnerMessage(This,hwnd,uMsg,wParam,lParam)	\
    ( (This)->lpVtbl -> NotifyOwnerMessage(This,hwnd,uMsg,wParam,lParam) ) 

#define IVideoWindow_SetWindowPosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetWindowPosition(This,Left,Top,Width,Height) ) 

#define IVideoWindow_GetWindowPosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetWindowPosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IVideoWindow_GetMinIdealImageSize(This,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetMinIdealImageSize(This,pWidth,pHeight) ) 

#define IVideoWindow_GetMaxIdealImageSize(This,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetMaxIdealImageSize(This,pWidth,pHeight) ) 

#define IVideoWindow_GetRestorePosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetRestorePosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IVideoWindow_HideCursor(This,HideCursor)	\
    ( (This)->lpVtbl -> HideCursor(This,HideCursor) ) 

#define IVideoWindow_IsCursorHidden(This,CursorHidden)	\
    ( (This)->lpVtbl -> IsCursorHidden(This,CursorHidden) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVideoWindow_INTERFACE_DEFINED__ */


#ifndef __IBasicVideo_INTERFACE_DEFINED__
#define __IBasicVideo_INTERFACE_DEFINED__

/* interface IBasicVideo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicVideo,0x56a868b5,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b5-0ad4-11ce-b03a-0020af0ba770")
    IBasicVideo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AvgTimePerFrame( 
            /* [retval][out] */ REFTIME *pAvgTimePerFrame) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BitRate( 
            /* [retval][out] */ long *pBitRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BitErrorRate( 
            /* [retval][out] */ long *pBitErrorRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VideoWidth( 
            /* [retval][out] */ long *pVideoWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VideoHeight( 
            /* [retval][out] */ long *pVideoHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceLeft( 
            /* [in] */ long SourceLeft) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceLeft( 
            /* [retval][out] */ long *pSourceLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceWidth( 
            /* [in] */ long SourceWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceWidth( 
            /* [retval][out] */ long *pSourceWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceTop( 
            /* [in] */ long SourceTop) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceTop( 
            /* [retval][out] */ long *pSourceTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceHeight( 
            /* [in] */ long SourceHeight) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceHeight( 
            /* [retval][out] */ long *pSourceHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationLeft( 
            /* [in] */ long DestinationLeft) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationLeft( 
            /* [retval][out] */ long *pDestinationLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationWidth( 
            /* [in] */ long DestinationWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationWidth( 
            /* [retval][out] */ long *pDestinationWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationTop( 
            /* [in] */ long DestinationTop) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationTop( 
            /* [retval][out] */ long *pDestinationTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationHeight( 
            /* [in] */ long DestinationHeight) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationHeight( 
            /* [retval][out] */ long *pDestinationHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSourcePosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourcePosition( 
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultSourcePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDestinationPosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDestinationPosition( 
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultDestinationPosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoSize( 
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPaletteEntries( 
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ long *pRetrieved,
            /* [out] */ long *pPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentImage( 
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pDIBImage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingDefaultSource( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingDefaultDestination( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicVideoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicVideo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicVideo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicVideo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicVideo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicVideo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicVideo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvgTimePerFrame )( 
            IBasicVideo * This,
            /* [retval][out] */ REFTIME *pAvgTimePerFrame);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitRate )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pBitRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitErrorRate )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pBitErrorRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pVideoWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pVideoHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceLeft )( 
            IBasicVideo * This,
            /* [in] */ long SourceLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLeft )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pSourceLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceWidth )( 
            IBasicVideo * This,
            /* [in] */ long SourceWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pSourceWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceTop )( 
            IBasicVideo * This,
            /* [in] */ long SourceTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceTop )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pSourceTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceHeight )( 
            IBasicVideo * This,
            /* [in] */ long SourceHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pSourceHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationLeft )( 
            IBasicVideo * This,
            /* [in] */ long DestinationLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationLeft )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pDestinationLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationWidth )( 
            IBasicVideo * This,
            /* [in] */ long DestinationWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pDestinationWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationTop )( 
            IBasicVideo * This,
            /* [in] */ long DestinationTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationTop )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pDestinationTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationHeight )( 
            IBasicVideo * This,
            /* [in] */ long DestinationHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pDestinationHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourcePosition )( 
            IBasicVideo * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IBasicVideo * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSourcePosition )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestinationPosition )( 
            IBasicVideo * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationPosition )( 
            IBasicVideo * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultDestinationPosition )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoSize )( 
            IBasicVideo * This,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPaletteEntries )( 
            IBasicVideo * This,
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ long *pRetrieved,
            /* [out] */ long *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IBasicVideo * This,
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pDIBImage);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultSource )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultDestination )( 
            IBasicVideo * This);
        
        END_INTERFACE
    } IBasicVideoVtbl;

    interface IBasicVideo
    {
        CONST_VTBL struct IBasicVideoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicVideo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBasicVideo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBasicVideo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBasicVideo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IBasicVideo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IBasicVideo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IBasicVideo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IBasicVideo_get_AvgTimePerFrame(This,pAvgTimePerFrame)	\
    ( (This)->lpVtbl -> get_AvgTimePerFrame(This,pAvgTimePerFrame) ) 

#define IBasicVideo_get_BitRate(This,pBitRate)	\
    ( (This)->lpVtbl -> get_BitRate(This,pBitRate) ) 

#define IBasicVideo_get_BitErrorRate(This,pBitErrorRate)	\
    ( (This)->lpVtbl -> get_BitErrorRate(This,pBitErrorRate) ) 

#define IBasicVideo_get_VideoWidth(This,pVideoWidth)	\
    ( (This)->lpVtbl -> get_VideoWidth(This,pVideoWidth) ) 

#define IBasicVideo_get_VideoHeight(This,pVideoHeight)	\
    ( (This)->lpVtbl -> get_VideoHeight(This,pVideoHeight) ) 

#define IBasicVideo_put_SourceLeft(This,SourceLeft)	\
    ( (This)->lpVtbl -> put_SourceLeft(This,SourceLeft) ) 

#define IBasicVideo_get_SourceLeft(This,pSourceLeft)	\
    ( (This)->lpVtbl -> get_SourceLeft(This,pSourceLeft) ) 

#define IBasicVideo_put_SourceWidth(This,SourceWidth)	\
    ( (This)->lpVtbl -> put_SourceWidth(This,SourceWidth) ) 

#define IBasicVideo_get_SourceWidth(This,pSourceWidth)	\
    ( (This)->lpVtbl -> get_SourceWidth(This,pSourceWidth) ) 

#define IBasicVideo_put_SourceTop(This,SourceTop)	\
    ( (This)->lpVtbl -> put_SourceTop(This,SourceTop) ) 

#define IBasicVideo_get_SourceTop(This,pSourceTop)	\
    ( (This)->lpVtbl -> get_SourceTop(This,pSourceTop) ) 

#define IBasicVideo_put_SourceHeight(This,SourceHeight)	\
    ( (This)->lpVtbl -> put_SourceHeight(This,SourceHeight) ) 

#define IBasicVideo_get_SourceHeight(This,pSourceHeight)	\
    ( (This)->lpVtbl -> get_SourceHeight(This,pSourceHeight) ) 

#define IBasicVideo_put_DestinationLeft(This,DestinationLeft)	\
    ( (This)->lpVtbl -> put_DestinationLeft(This,DestinationLeft) ) 

#define IBasicVideo_get_DestinationLeft(This,pDestinationLeft)	\
    ( (This)->lpVtbl -> get_DestinationLeft(This,pDestinationLeft) ) 

#define IBasicVideo_put_DestinationWidth(This,DestinationWidth)	\
    ( (This)->lpVtbl -> put_DestinationWidth(This,DestinationWidth) ) 

#define IBasicVideo_get_DestinationWidth(This,pDestinationWidth)	\
    ( (This)->lpVtbl -> get_DestinationWidth(This,pDestinationWidth) ) 

#define IBasicVideo_put_DestinationTop(This,DestinationTop)	\
    ( (This)->lpVtbl -> put_DestinationTop(This,DestinationTop) ) 

#define IBasicVideo_get_DestinationTop(This,pDestinationTop)	\
    ( (This)->lpVtbl -> get_DestinationTop(This,pDestinationTop) ) 

#define IBasicVideo_put_DestinationHeight(This,DestinationHeight)	\
    ( (This)->lpVtbl -> put_DestinationHeight(This,DestinationHeight) ) 

#define IBasicVideo_get_DestinationHeight(This,pDestinationHeight)	\
    ( (This)->lpVtbl -> get_DestinationHeight(This,pDestinationHeight) ) 

#define IBasicVideo_SetSourcePosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetSourcePosition(This,Left,Top,Width,Height) ) 

#define IBasicVideo_GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetSourcePosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IBasicVideo_SetDefaultSourcePosition(This)	\
    ( (This)->lpVtbl -> SetDefaultSourcePosition(This) ) 

#define IBasicVideo_SetDestinationPosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetDestinationPosition(This,Left,Top,Width,Height) ) 

#define IBasicVideo_GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IBasicVideo_SetDefaultDestinationPosition(This)	\
    ( (This)->lpVtbl -> SetDefaultDestinationPosition(This) ) 

#define IBasicVideo_GetVideoSize(This,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetVideoSize(This,pWidth,pHeight) ) 

#define IBasicVideo_GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)	\
    ( (This)->lpVtbl -> GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette) ) 

#define IBasicVideo_GetCurrentImage(This,pBufferSize,pDIBImage)	\
    ( (This)->lpVtbl -> GetCurrentImage(This,pBufferSize,pDIBImage) ) 

#define IBasicVideo_IsUsingDefaultSource(This)	\
    ( (This)->lpVtbl -> IsUsingDefaultSource(This) ) 

#define IBasicVideo_IsUsingDefaultDestination(This)	\
    ( (This)->lpVtbl -> IsUsingDefaultDestination(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBasicVideo_INTERFACE_DEFINED__ */


#ifndef __IBasicVideo2_INTERFACE_DEFINED__
#define __IBasicVideo2_INTERFACE_DEFINED__

/* interface IBasicVideo2 */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicVideo2,0x329bb360,0xf6ea,0x11d1,0x90,0x38,0x00,0xa0,0xc9,0x69,0x72,0x98);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("329bb360-f6ea-11d1-9038-00a0c9697298")
    IBasicVideo2 : public IBasicVideo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPreferredAspectRatio( 
            /* [out] */ long *plAspectX,
            /* [out] */ long *plAspectY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicVideo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicVideo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicVideo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicVideo2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicVideo2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicVideo2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicVideo2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvgTimePerFrame )( 
            IBasicVideo2 * This,
            /* [retval][out] */ REFTIME *pAvgTimePerFrame);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitRate )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pBitRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitErrorRate )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pBitErrorRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pVideoWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pVideoHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceLeft )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLeft )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pSourceLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceWidth )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pSourceWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceTop )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceTop )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pSourceTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceHeight )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pSourceHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationLeft )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationLeft )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pDestinationLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationWidth )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pDestinationWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationTop )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationTop )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pDestinationTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationHeight )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pDestinationHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourcePosition )( 
            IBasicVideo2 * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IBasicVideo2 * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSourcePosition )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestinationPosition )( 
            IBasicVideo2 * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationPosition )( 
            IBasicVideo2 * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultDestinationPosition )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoSize )( 
            IBasicVideo2 * This,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPaletteEntries )( 
            IBasicVideo2 * This,
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ long *pRetrieved,
            /* [out] */ long *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IBasicVideo2 * This,
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pDIBImage);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultSource )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultDestination )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreferredAspectRatio )( 
            IBasicVideo2 * This,
            /* [out] */ long *plAspectX,
            /* [out] */ long *plAspectY);
        
        END_INTERFACE
    } IBasicVideo2Vtbl;

    interface IBasicVideo2
    {
        CONST_VTBL struct IBasicVideo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicVideo2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBasicVideo2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBasicVideo2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBasicVideo2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IBasicVideo2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IBasicVideo2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IBasicVideo2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IBasicVideo2_get_AvgTimePerFrame(This,pAvgTimePerFrame)	\
    ( (This)->lpVtbl -> get_AvgTimePerFrame(This,pAvgTimePerFrame) ) 

#define IBasicVideo2_get_BitRate(This,pBitRate)	\
    ( (This)->lpVtbl -> get_BitRate(This,pBitRate) ) 

#define IBasicVideo2_get_BitErrorRate(This,pBitErrorRate)	\
    ( (This)->lpVtbl -> get_BitErrorRate(This,pBitErrorRate) ) 

#define IBasicVideo2_get_VideoWidth(This,pVideoWidth)	\
    ( (This)->lpVtbl -> get_VideoWidth(This,pVideoWidth) ) 

#define IBasicVideo2_get_VideoHeight(This,pVideoHeight)	\
    ( (This)->lpVtbl -> get_VideoHeight(This,pVideoHeight) ) 

#define IBasicVideo2_put_SourceLeft(This,SourceLeft)	\
    ( (This)->lpVtbl -> put_SourceLeft(This,SourceLeft) ) 

#define IBasicVideo2_get_SourceLeft(This,pSourceLeft)	\
    ( (This)->lpVtbl -> get_SourceLeft(This,pSourceLeft) ) 

#define IBasicVideo2_put_SourceWidth(This,SourceWidth)	\
    ( (This)->lpVtbl -> put_SourceWidth(This,SourceWidth) ) 

#define IBasicVideo2_get_SourceWidth(This,pSourceWidth)	\
    ( (This)->lpVtbl -> get_SourceWidth(This,pSourceWidth) ) 

#define IBasicVideo2_put_SourceTop(This,SourceTop)	\
    ( (This)->lpVtbl -> put_SourceTop(This,SourceTop) ) 

#define IBasicVideo2_get_SourceTop(This,pSourceTop)	\
    ( (This)->lpVtbl -> get_SourceTop(This,pSourceTop) ) 

#define IBasicVideo2_put_SourceHeight(This,SourceHeight)	\
    ( (This)->lpVtbl -> put_SourceHeight(This,SourceHeight) ) 

#define IBasicVideo2_get_SourceHeight(This,pSourceHeight)	\
    ( (This)->lpVtbl -> get_SourceHeight(This,pSourceHeight) ) 

#define IBasicVideo2_put_DestinationLeft(This,DestinationLeft)	\
    ( (This)->lpVtbl -> put_DestinationLeft(This,DestinationLeft) ) 

#define IBasicVideo2_get_DestinationLeft(This,pDestinationLeft)	\
    ( (This)->lpVtbl -> get_DestinationLeft(This,pDestinationLeft) ) 

#define IBasicVideo2_put_DestinationWidth(This,DestinationWidth)	\
    ( (This)->lpVtbl -> put_DestinationWidth(This,DestinationWidth) ) 

#define IBasicVideo2_get_DestinationWidth(This,pDestinationWidth)	\
    ( (This)->lpVtbl -> get_DestinationWidth(This,pDestinationWidth) ) 

#define IBasicVideo2_put_DestinationTop(This,DestinationTop)	\
    ( (This)->lpVtbl -> put_DestinationTop(This,DestinationTop) ) 

#define IBasicVideo2_get_DestinationTop(This,pDestinationTop)	\
    ( (This)->lpVtbl -> get_DestinationTop(This,pDestinationTop) ) 

#define IBasicVideo2_put_DestinationHeight(This,DestinationHeight)	\
    ( (This)->lpVtbl -> put_DestinationHeight(This,DestinationHeight) ) 

#define IBasicVideo2_get_DestinationHeight(This,pDestinationHeight)	\
    ( (This)->lpVtbl -> get_DestinationHeight(This,pDestinationHeight) ) 

#define IBasicVideo2_SetSourcePosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetSourcePosition(This,Left,Top,Width,Height) ) 

#define IBasicVideo2_GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetSourcePosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IBasicVideo2_SetDefaultSourcePosition(This)	\
    ( (This)->lpVtbl -> SetDefaultSourcePosition(This) ) 

#define IBasicVideo2_SetDestinationPosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetDestinationPosition(This,Left,Top,Width,Height) ) 

#define IBasicVideo2_GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IBasicVideo2_SetDefaultDestinationPosition(This)	\
    ( (This)->lpVtbl -> SetDefaultDestinationPosition(This) ) 

#define IBasicVideo2_GetVideoSize(This,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetVideoSize(This,pWidth,pHeight) ) 

#define IBasicVideo2_GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)	\
    ( (This)->lpVtbl -> GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette) ) 

#define IBasicVideo2_GetCurrentImage(This,pBufferSize,pDIBImage)	\
    ( (This)->lpVtbl -> GetCurrentImage(This,pBufferSize,pDIBImage) ) 

#define IBasicVideo2_IsUsingDefaultSource(This)	\
    ( (This)->lpVtbl -> IsUsingDefaultSource(This) ) 

#define IBasicVideo2_IsUsingDefaultDestination(This)	\
    ( (This)->lpVtbl -> IsUsingDefaultDestination(This) ) 


#define IBasicVideo2_GetPreferredAspectRatio(This,plAspectX,plAspectY)	\
    ( (This)->lpVtbl -> GetPreferredAspectRatio(This,plAspectX,plAspectY) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBasicVideo2_INTERFACE_DEFINED__ */


#ifndef __IDeferredCommand_INTERFACE_DEFINED__
#define __IDeferredCommand_INTERFACE_DEFINED__

/* interface IDeferredCommand */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IDeferredCommand,0x56a868b8,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b8-0ad4-11ce-b03a-0020af0ba770")
    IDeferredCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Confidence( 
            /* [out] */ LONG *pConfidence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Postpone( 
            /* [in] */ REFTIME newtime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHResult( 
            /* [out] */ HRESULT *phrResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeferredCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeferredCommand * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeferredCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeferredCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IDeferredCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Confidence )( 
            IDeferredCommand * This,
            /* [out] */ LONG *pConfidence);
        
        HRESULT ( STDMETHODCALLTYPE *Postpone )( 
            IDeferredCommand * This,
            /* [in] */ REFTIME newtime);
        
        HRESULT ( STDMETHODCALLTYPE *GetHResult )( 
            IDeferredCommand * This,
            /* [out] */ HRESULT *phrResult);
        
        END_INTERFACE
    } IDeferredCommandVtbl;

    interface IDeferredCommand
    {
        CONST_VTBL struct IDeferredCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeferredCommand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeferredCommand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeferredCommand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeferredCommand_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IDeferredCommand_Confidence(This,pConfidence)	\
    ( (This)->lpVtbl -> Confidence(This,pConfidence) ) 

#define IDeferredCommand_Postpone(This,newtime)	\
    ( (This)->lpVtbl -> Postpone(This,newtime) ) 

#define IDeferredCommand_GetHResult(This,phrResult)	\
    ( (This)->lpVtbl -> GetHResult(This,phrResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeferredCommand_INTERFACE_DEFINED__ */


#ifndef __IQueueCommand_INTERFACE_DEFINED__
#define __IQueueCommand_INTERFACE_DEFINED__

/* interface IQueueCommand */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IQueueCommand,0x56a868b7,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b7-0ad4-11ce-b03a-0020af0ba770")
    IQueueCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvokeAtStreamTime( 
            /* [out] */ IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ VARIANT *pDispParams,
            /* [out][in] */ VARIANT *pvarResult,
            /* [out] */ short *puArgErr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeAtPresentationTime( 
            /* [out] */ IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ VARIANT *pDispParams,
            /* [out][in] */ VARIANT *pvarResult,
            /* [out] */ short *puArgErr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueueCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueueCommand * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueueCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueueCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeAtStreamTime )( 
            IQueueCommand * This,
            /* [out] */ IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ VARIANT *pDispParams,
            /* [out][in] */ VARIANT *pvarResult,
            /* [out] */ short *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeAtPresentationTime )( 
            IQueueCommand * This,
            /* [out] */ IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ VARIANT *pDispParams,
            /* [out][in] */ VARIANT *pvarResult,
            /* [out] */ short *puArgErr);
        
        END_INTERFACE
    } IQueueCommandVtbl;

    interface IQueueCommand
    {
        CONST_VTBL struct IQueueCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueueCommand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueueCommand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueueCommand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueueCommand_InvokeAtStreamTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)	\
    ( (This)->lpVtbl -> InvokeAtStreamTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr) ) 

#define IQueueCommand_InvokeAtPresentationTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)	\
    ( (This)->lpVtbl -> InvokeAtPresentationTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueueCommand_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_FilgraphManager,0xe436ebb3,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#ifdef __cplusplus

class DECLSPEC_UUID("e436ebb3-524f-11ce-9f53-0020af0ba770")
FilgraphManager;
#endif

#ifndef __IFilterInfo_INTERFACE_DEFINED__
#define __IFilterInfo_INTERFACE_DEFINED__

/* interface IFilterInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IFilterInfo,0x56a868ba,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868ba-0ad4-11ce-b03a-0020af0ba770")
    IFilterInfo : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindPin( 
            /* [in] */ BSTR strPinID,
            /* [out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *strName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VendorInfo( 
            /* [retval][out] */ BSTR *strVendorInfo) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Filter( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Pins( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsFileSource( 
            /* [retval][out] */ LONG *pbIsSource) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Filename( 
            /* [retval][out] */ BSTR *pstrFilename) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Filename( 
            /* [in] */ BSTR strFilename) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFilterInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFilterInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFilterInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *FindPin )( 
            IFilterInfo * This,
            /* [in] */ BSTR strPinID,
            /* [out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFilterInfo * This,
            /* [retval][out] */ BSTR *strName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VendorInfo )( 
            IFilterInfo * This,
            /* [retval][out] */ BSTR *strVendorInfo);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filter )( 
            IFilterInfo * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pins )( 
            IFilterInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsFileSource )( 
            IFilterInfo * This,
            /* [retval][out] */ LONG *pbIsSource);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filename )( 
            IFilterInfo * This,
            /* [retval][out] */ BSTR *pstrFilename);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Filename )( 
            IFilterInfo * This,
            /* [in] */ BSTR strFilename);
        
        END_INTERFACE
    } IFilterInfoVtbl;

    interface IFilterInfo
    {
        CONST_VTBL struct IFilterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFilterInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFilterInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFilterInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFilterInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFilterInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFilterInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFilterInfo_FindPin(This,strPinID,ppUnk)	\
    ( (This)->lpVtbl -> FindPin(This,strPinID,ppUnk) ) 

#define IFilterInfo_get_Name(This,strName)	\
    ( (This)->lpVtbl -> get_Name(This,strName) ) 

#define IFilterInfo_get_VendorInfo(This,strVendorInfo)	\
    ( (This)->lpVtbl -> get_VendorInfo(This,strVendorInfo) ) 

#define IFilterInfo_get_Filter(This,ppUnk)	\
    ( (This)->lpVtbl -> get_Filter(This,ppUnk) ) 

#define IFilterInfo_get_Pins(This,ppUnk)	\
    ( (This)->lpVtbl -> get_Pins(This,ppUnk) ) 

#define IFilterInfo_get_IsFileSource(This,pbIsSource)	\
    ( (This)->lpVtbl -> get_IsFileSource(This,pbIsSource) ) 

#define IFilterInfo_get_Filename(This,pstrFilename)	\
    ( (This)->lpVtbl -> get_Filename(This,pstrFilename) ) 

#define IFilterInfo_put_Filename(This,strFilename)	\
    ( (This)->lpVtbl -> put_Filename(This,strFilename) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFilterInfo_INTERFACE_DEFINED__ */


#ifndef __IRegFilterInfo_INTERFACE_DEFINED__
#define __IRegFilterInfo_INTERFACE_DEFINED__

/* interface IRegFilterInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IRegFilterInfo,0x56a868bb,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bb-0ad4-11ce-b03a-0020af0ba770")
    IRegFilterInfo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *strName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Filter( 
            /* [out] */ IDispatch **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegFilterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegFilterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegFilterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRegFilterInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRegFilterInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRegFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRegFilterInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IRegFilterInfo * This,
            /* [retval][out] */ BSTR *strName);
        
        HRESULT ( STDMETHODCALLTYPE *Filter )( 
            IRegFilterInfo * This,
            /* [out] */ IDispatch **ppUnk);
        
        END_INTERFACE
    } IRegFilterInfoVtbl;

    interface IRegFilterInfo
    {
        CONST_VTBL struct IRegFilterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegFilterInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRegFilterInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRegFilterInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRegFilterInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRegFilterInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRegFilterInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRegFilterInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRegFilterInfo_get_Name(This,strName)	\
    ( (This)->lpVtbl -> get_Name(This,strName) ) 

#define IRegFilterInfo_Filter(This,ppUnk)	\
    ( (This)->lpVtbl -> Filter(This,ppUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRegFilterInfo_INTERFACE_DEFINED__ */


#ifndef __IMediaTypeInfo_INTERFACE_DEFINED__
#define __IMediaTypeInfo_INTERFACE_DEFINED__

/* interface IMediaTypeInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaTypeInfo,0x56a868bc,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bc-0ad4-11ce-b03a-0020af0ba770")
    IMediaTypeInfo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR *strType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Subtype( 
            /* [retval][out] */ BSTR *strType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaTypeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaTypeInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaTypeInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaTypeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaTypeInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaTypeInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaTypeInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaTypeInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IMediaTypeInfo * This,
            /* [retval][out] */ BSTR *strType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Subtype )( 
            IMediaTypeInfo * This,
            /* [retval][out] */ BSTR *strType);
        
        END_INTERFACE
    } IMediaTypeInfoVtbl;

    interface IMediaTypeInfo
    {
        CONST_VTBL struct IMediaTypeInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaTypeInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaTypeInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaTypeInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaTypeInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaTypeInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaTypeInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaTypeInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaTypeInfo_get_Type(This,strType)	\
    ( (This)->lpVtbl -> get_Type(This,strType) ) 

#define IMediaTypeInfo_get_Subtype(This,strType)	\
    ( (This)->lpVtbl -> get_Subtype(This,strType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaTypeInfo_INTERFACE_DEFINED__ */


#ifndef __IPinInfo_INTERFACE_DEFINED__
#define __IPinInfo_INTERFACE_DEFINED__

/* interface IPinInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IPinInfo,0x56a868bd,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bd-0ad4-11ce-b03a-0020af0ba770")
    IPinInfo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Pin( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedTo( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionMediaType( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterInfo( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ LONG *ppDirection) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PinID( 
            /* [retval][out] */ BSTR *strPinID) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MediaTypes( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ IUnknown *pPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectDirect( 
            /* [in] */ IUnknown *pPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectWithType( 
            /* [in] */ IUnknown *pPin,
            /* [in] */ IDispatch *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Render( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPinInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPinInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPinInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPinInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPinInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPinInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPinInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPinInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pin )( 
            IPinInfo * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedTo )( 
            IPinInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionMediaType )( 
            IPinInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterInfo )( 
            IPinInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IPinInfo * This,
            /* [retval][out] */ BSTR *ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            IPinInfo * This,
            /* [retval][out] */ LONG *ppDirection);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PinID )( 
            IPinInfo * This,
            /* [retval][out] */ BSTR *strPinID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaTypes )( 
            IPinInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IPinInfo * This,
            /* [in] */ IUnknown *pPin);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDirect )( 
            IPinInfo * This,
            /* [in] */ IUnknown *pPin);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectWithType )( 
            IPinInfo * This,
            /* [in] */ IUnknown *pPin,
            /* [in] */ IDispatch *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IPinInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IPinInfo * This);
        
        END_INTERFACE
    } IPinInfoVtbl;

    interface IPinInfo
    {
        CONST_VTBL struct IPinInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPinInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPinInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPinInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPinInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IPinInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IPinInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IPinInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IPinInfo_get_Pin(This,ppUnk)	\
    ( (This)->lpVtbl -> get_Pin(This,ppUnk) ) 

#define IPinInfo_get_ConnectedTo(This,ppUnk)	\
    ( (This)->lpVtbl -> get_ConnectedTo(This,ppUnk) ) 

#define IPinInfo_get_ConnectionMediaType(This,ppUnk)	\
    ( (This)->lpVtbl -> get_ConnectionMediaType(This,ppUnk) ) 

#define IPinInfo_get_FilterInfo(This,ppUnk)	\
    ( (This)->lpVtbl -> get_FilterInfo(This,ppUnk) ) 

#define IPinInfo_get_Name(This,ppUnk)	\
    ( (This)->lpVtbl -> get_Name(This,ppUnk) ) 

#define IPinInfo_get_Direction(This,ppDirection)	\
    ( (This)->lpVtbl -> get_Direction(This,ppDirection) ) 

#define IPinInfo_get_PinID(This,strPinID)	\
    ( (This)->lpVtbl -> get_PinID(This,strPinID) ) 

#define IPinInfo_get_MediaTypes(This,ppUnk)	\
    ( (This)->lpVtbl -> get_MediaTypes(This,ppUnk) ) 

#define IPinInfo_Connect(This,pPin)	\
    ( (This)->lpVtbl -> Connect(This,pPin) ) 

#define IPinInfo_ConnectDirect(This,pPin)	\
    ( (This)->lpVtbl -> ConnectDirect(This,pPin) ) 

#define IPinInfo_ConnectWithType(This,pPin,pMediaType)	\
    ( (This)->lpVtbl -> ConnectWithType(This,pPin,pMediaType) ) 

#define IPinInfo_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IPinInfo_Render(This)	\
    ( (This)->lpVtbl -> Render(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPinInfo_INTERFACE_DEFINED__ */

#endif /* __QuartzTypeLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\connmgr_conntypes.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _connmgr_conntypes_h_
#define _connmgr_conntypes_h_

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @constants Connection types | Describes possible connection types and subtypes
//
// @comm none
//
// -----------------------------------------------------------------------------

#define CM_CONNTYPE_UNKNOWN     0
#define CM_CONNTYPE_CELLULAR    1
#define CM_CONNTYPE_NIC         2
#define CM_CONNTYPE_BLUETOOTH   3
#define CM_CONNTYPE_UNIMODEM    4
#define CM_CONNTYPE_VPN         5
#define CM_CONNTYPE_PROXY       6
#define CM_CONNTYPE_PC          7
#define CM_CONNTYPE_MAX         8

#define CM_CONNSUBTYPE_UNKNOWN  0

#define CM_CONNSUBTYPE_CELLULAR_UNKNOWN 0
#define CM_CONNSUBTYPE_CELLULAR_CSD     1
#define CM_CONNSUBTYPE_CELLULAR_GPRS    2
#define CM_CONNSUBTYPE_CELLULAR_1XRTT   3   // @constdefine Not distinct from CSD.
#define CM_CONNSUBTYPE_CELLULAR_1XEVDO  4   // @constdefine Not distinct from CSD.
#define CM_CONNSUBTYPE_CELLULAR_1XEVDV  5   // @constdefine Not distinct from CSD.
#define CM_CONNSUBTYPE_CELLULAR_EDGE    6   // @constdefine Not distinct from GPRS.
#define CM_CONNSUBTYPE_CELLULAR_UMTS    7   // @constdefine Not distinct from GPRS.
#define CM_CONNSUBTYPE_CELLULAR_VOICE   8
#define CM_CONNSUBTYPE_CELLULAR_PTT     9   // @constdefine Push-to-Talk, not supported.
#define CM_CONNSUBTYPE_CELLULAR_HSDPA   10  // @constdefine High-Speed Downlink Packet Access (3.5G).
#define CM_CONNSUBTYPE_CELLULAR_MAX     11

#define CM_CONNSUBTYPE_NIC_UNKNOWN  0
#define CM_CONNSUBTYPE_NIC_ETHERNET 1
#define CM_CONNSUBTYPE_NIC_WIFI     2
#define CM_CONNSUBTYPE_NIC_MAX      3

#define CM_CONNSUBTYPE_BLUETOOTH_UNKNOWN    0
#define CM_CONNSUBTYPE_BLUETOOTH_RAS        1
#define CM_CONNSUBTYPE_BLUETOOTH_PAN        2
#define CM_CONNSUBTYPE_BLUETOOTH_MAX        3

#define CM_CONNSUBTYPE_UNIMODEM_UNKNOWN         0
#define CM_CONNSUBTYPE_UNIMODEM_CSD             1
#define CM_CONNSUBTYPE_UNIMODEM_OOB_CSD         2
//
// Derived from unimodem device types
//
#define CM_CONNSUBTYPE_UNIMODEM_NULL_MODEM      3   // Direct Cable Connect (DCC)
#define CM_CONNSUBTYPE_UNIMODEM_EXTERNAL_MODEM  4   // Serial port attached modem
#define CM_CONNSUBTYPE_UNIMODEM_INTERNAL_MODEM  5
#define CM_CONNSUBTYPE_UNIMODEM_PCMCIA_MODEM    6
#define CM_CONNSUBTYPE_UNIMODEM_IRCOMM_MODEM    7   // DCC over Irda
#define CM_CONNSUBTYPE_UNIMODEM_DYNAMIC_MODEM   8   // Bluetooth modem
#define CM_CONNSUBTYPE_UNIMODEM_DYNAMIC_PORT    9   // DCC over Bluetooth
#define CM_CONNSUBTYPE_UNIMODEM_MAX             10


#define CM_CONNSUBTYPE_VPN_UNKNOWN  0
#define CM_CONNSUBTYPE_VPN_L2TP     1
#define CM_CONNSUBTYPE_VPN_PPTP     2
#define CM_CONNSUBTYPE_VPN_MAX      3

#define CM_CONNSUBTYPE_PROXY_UNKNOWN    0
#define CM_CONNSUBTYPE_PROXY_NULL       1
#define CM_CONNSUBTYPE_PROXY_HTTP       2
#define CM_CONNSUBTYPE_PROXY_WAP        3
#define CM_CONNSUBTYPE_PROXY_SOCKS4     4
#define CM_CONNSUBTYPE_PROXY_SOCKS5     5
#define CM_CONNSUBTYPE_PROXY_MAX        6

#define CM_CONNSUBTYPE_PC_UNKNOWN            0
#define CM_CONNSUBTYPE_PC_DESKTOPPASSTHROUGH 1
#define CM_CONNSUBTYPE_PC_IR                 2
#define CM_CONNSUBTYPE_PC_MODEM_LINK         3
#define CM_CONNSUBTYPE_PC_MAX                4

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @constants Connection options | Describes possible connection options
//
// @comm none
//
// -----------------------------------------------------------------------------

#define CM_DSF_BILLBYTIME       0x00000001  // @constdefine Connection is billed by time.
#define CM_DSF_ALWAYSON         0x00000002  // @constdefine Connection is always on.
#define CM_DSF_SUSPENDRESUME    0x00000004  // @constdefine Connection is suspend/resume capable.

#endif // _connmgr_conntypes_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\connmgr_status.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _connmgr_status_h_
#define _connmgr_status_h_

#include <winsock2.h> // Need this for SOCKADDR_STORAGE

#ifdef __cplusplus
extern "C" {
#endif

#include <winsock2.h>
#include <connmgr_conntypes.h>

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @struct CONNMGR_CONNECTION_IPADDR | Address information for an active connection
//
// @comm None
//
// -----------------------------------------------------------------------------

typedef struct _CONNMGR_CONNECTION_IPADDR
{
    DWORD cIPAddr;                  // @field Count of addresses in array.
    SOCKADDR_STORAGE IPAddr[1];     // @field Array of IPv4 and/or IPv6 addresses.
} CONNMGR_CONNECTION_IPADDR;

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @struct CONNMGR_CONNECTION_DETAILED_STATUS | Information about available connections
//
// @comm None
//
// -----------------------------------------------------------------------------

#define CONNMGRDETAILEDSTATUS_VERSION   1

#define CONNMGRDETAILEDSTATUS_PARAM_TYPE            0x00000001
#define CONNMGRDETAILEDSTATUS_PARAM_SUBTYPE         0x00000002
#define CONNMGRDETAILEDSTATUS_PARAM_DESTNET         0x00000004
#define CONNMGRDETAILEDSTATUS_PARAM_SOURCENET       0x00000008
#define CONNMGRDETAILEDSTATUS_PARAM_FLAGS           0x00000010
#define CONNMGRDETAILEDSTATUS_PARAM_SECURE          0x00000020
#define CONNMGRDETAILEDSTATUS_PARAM_DESCRIPTION     0x00000040
#define CONNMGRDETAILEDSTATUS_PARAM_ADAPTERNAME     0x00000080
#define CONNMGRDETAILEDSTATUS_PARAM_CONNSTATUS      0x00000100
#define CONNMGRDETAILEDSTATUS_PARAM_LASTCONNECT     0x00000200
#define CONNMGRDETAILEDSTATUS_PARAM_SIGNALQUALITY   0x00000400
#define CONNMGRDETAILEDSTATUS_PARAM_IPADDR          0x00000800

typedef struct _CONNMGR_CONNECTION_DETAILED_STATUS
{
    struct _CONNMGR_CONNECTION_DETAILED_STATUS* pNext;
    
    DWORD dwVer;                // @field Structure version; current is CONNMGRDETAILEDSTATUS_VERSION.
    DWORD dwParams;             // @field Combination of CONNMGRDETAILEDSTATUS_PARAM_* values.
    
    DWORD dwType;               // @field One of CM_CONNTYPE_* values.
    DWORD dwSubtype;            // @field One of CM_CONNSUBTYPE_* values.
    
    DWORD dwFlags;              // @field Combination of CM_DSF_* flags.
    DWORD dwSecure;             // @field Secure level (0 == not-secure) of connection.

    GUID guidDestNet;           // @field GUID of destination network.
    GUID guidSourceNet;         // @field GUID of source network.
    
    TCHAR* szDescription;       // @field Name of connection, 0-terminated string or NULL if N/A.
    TCHAR* szAdapterName;       // @field Name of adapter, 0-terminated or NULL if N/A.
    
    DWORD dwConnectionStatus;   // @field One of CONNMGR_STATUS_*.
    SYSTEMTIME LastConnectTime; // @field Time connection was last established.
    DWORD dwSignalQuality;      // @field Signal quality normalized in the range 0-255.
    
    CONNMGR_CONNECTION_IPADDR*  pIPAddr; // @field Available IP addrs, or NULL if N/A.
// End of version 1 fields.

} CONNMGR_CONNECTION_DETAILED_STATUS;

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func ConnMgrQueryDetailedStatus | Returns detailed information about all existing connections.
//
// @comm Standard semantics here, call once to find out buffer size, then call
// again to get array of CONNMGR_CONNECTION_DETAILED_STATUS structures.
// Note: since connections can change often, make sure to allow for possibility
// that between first and second call, the necessary amount of space needed for
// the return structure changes.
//
// -----------------------------------------------------------------------------

HRESULT WINAPI ConnMgrQueryDetailedStatus
(
    CONNMGR_CONNECTION_DETAILED_STATUS *pStatusBuffer,	// @parm Pointer to buffer to be filled status info.
    DWORD *pcbBufferSize    // @parm IN: Size of buffer.  OUT: size of buffer needed.
);

// -----------------------------------------------------------------------------
//
// @doc EXTERNAL
//
// @func ConnMgrRegisterForStatusNotification | Registers a window handle for connection status notifications.
//
// @comm Will post a notification when,
// 1) an inactive connection is created or deleted, ex. via user input.
// 2) any of of the active connections changes connection state, i.e.
//    active to inactive, or inactive to active.
// Note: Notifications will not be generated for other changes, ex. change in
// signal quality.
//
// -----------------------------------------------------------------------------

#define CONNMGR_STATUS_CHANGE_NOTIFICATION_MSG TEXT("CONNMGR_STATUS_CHANGE_NOTIFICATION_MSG")

HRESULT WINAPI ConnMgrRegisterForStatusChangeNotification
(
    BOOL fEnable,   // @parm Turn on or turn off notifications
    HWND hWnd       // @parm Window to post status change notifications to
);

#ifdef __cplusplus
}
#endif

#endif // _connmgr_status_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cprop.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

#ifndef __CPROP__
#define __CPROP__

// Base property page class. Filters typically expose custom properties by
// implementing special control interfaces, examples are IDirectDrawVideo
// and IQualProp on renderers. This allows property pages to be built that
// use the given interface. Applications such as the ActiveMovie OCX query
// filters for the property pages they support and expose them to the user
//
// This class provides all the framework for a property page. A property
// page is a COM object that supports IPropertyPage. We should be created
// with a resource ID for the dialog which we will load when required. We
// should also be given in the constructor a resource ID for a title string
// we will load from the DLLs STRINGTABLE. The property page titles must be
// stored in resource files so that they can be easily internationalised
//
// We have a number of virtual methods (not PURE) that may be overriden in
// derived classes to query for interfaces and so on. These functions have
// simple implementations here that just return NOERROR. Derived classes
// will almost definately have to override the message handler method called
// OnReceiveMessage. We have a static dialog procedure that calls the method
// so that derived classes don't have to fiddle around with the this pointer

class AM_NOVTABLE CBasePropertyPage : public IPropertyPage, public CUnknown
{
protected:

    LPPROPERTYPAGESITE m_pPageSite;       // Details for our property site
    HWND m_hwnd;                          // Window handle for the page
    HWND m_Dlg;                           // Actual dialog window handle
    BOOL m_bDirty;                        // Has anything been changed
    int m_TitleId;                        // Resource identifier for title
    int m_DialogId;                       // Dialog resource identifier

    static INT_PTR CALLBACK DialogProc(HWND hwnd,
                                       UINT uMsg,
                                       WPARAM wParam,
                                       LPARAM lParam);

private:
    BOOL m_bObjectSet ;                  // SetObject has been called or not.
public:

    CBasePropertyPage(TCHAR *pName,      // Debug only name
                      LPUNKNOWN pUnk,    // COM Delegator
                      int DialogId,      // Resource ID
                      int TitleId);      // To get tital

    virtual ~CBasePropertyPage() { };
    DECLARE_IUNKNOWN

    // Override these virtual methods

    virtual HRESULT OnConnect(IUnknown *pUnknown) { return NOERROR; };
    virtual HRESULT OnDisconnect() { return NOERROR; };
    virtual HRESULT OnActivate() { return NOERROR; };
    virtual HRESULT OnDeactivate() { return NOERROR; };
    virtual HRESULT OnApplyChanges() { return NOERROR; };
    virtual INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

    // These implement an IPropertyPage interface

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE pPageSite);
    STDMETHODIMP Activate(HWND hwndParent,LPCRECT prect,BOOL fModal);
    STDMETHODIMP Deactivate(void);
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN *ppUnk);
    STDMETHODIMP Show(UINT nCmdShow);
    STDMETHODIMP Move(LPCRECT prect);
    STDMETHODIMP IsPageDirty(void) { return m_bDirty ? S_OK : S_FALSE; }
    STDMETHODIMP Apply(void);
    STDMETHODIMP Help(LPCWSTR lpszHelpDir) { return E_NOTIMPL; }
    STDMETHODIMP TranslateAccelerator(LPMSG lpMsg) { return E_NOTIMPL; }
};

#endif // __CPROP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\crtdbg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of your Microsoft Windows CE
// Source Alliance Program license form.  If you did not accept the terms of
// such a license, you are not authorized to use this source code.
//
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif /* __cplusplus */


#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _ASSERT(expr) ((void)0)

#define _ASSERTE(expr) ((void)0)


#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

// _CrtSetReportHook is also defined in atlcecrt.h
#ifdef UNDER_CE
#ifndef _CrtSetReportHook
#define _CrtSetReportHook(f)                ((void)0)
#endif // _CrtSetReportHook
#endif // UNDER_CE

#define _CrtSetReportMode(t, f)             ((int)0)

// _CrtSetReportFile is also defined in atlcecrt.h
#ifdef UNDER_CE
#ifndef _CrtSetReportFile
#define _CrtSetReportFile(t, f)             ((void)0)
#endif // _CrtSetReportFile
#endif // UNDER_CE

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((void)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)

#define _CrtSetDumpClient(f)                ((void)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)


#else /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

#if     defined(_DLL) && defined(_M_IX86)
#define _crtAssertBusy   (*__p__crtAssertBusy())
_CRTIMP long * __cdecl __p__crtAssertBusy(void);
#else   /* !(defined(_DLL) && defined(_M_IX86)) */
_CRTIMP extern long _crtAssertBusy;
#endif  /* defined(_DLL) && defined(_M_IX86) */

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );

_CRTIMP int __cdecl _CrtDbgReport(
        int,
        const char *,
        int,
        const char *,
        const char *,
        ...);

/* Asserts */

#define _ASSERT(expr) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, NULL))) \
             _CrtDbgBreak(); } while (0)

#define _ASSERTE(expr) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, #expr))) \
             _CrtDbgBreak(); } while (0)


/* Reports with no file/line info */

#define _RPT0(rptno, msg) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, "%s", msg))) \
                _CrtDbgBreak(); } while (0)

#define _RPT1(rptno, msg, arg1) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1))) \
                _CrtDbgBreak(); } while (0)

#define _RPT2(rptno, msg, arg1, arg2) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2))) \
                _CrtDbgBreak(); } while (0)

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))) \
                _CrtDbgBreak(); } while (0)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))) \
                _CrtDbgBreak(); } while (0)


/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, "%s", msg))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF1(rptno, msg, arg1) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF2(rptno, msg, arg1, arg2) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))) \
                _CrtDbgBreak(); } while (0)

#if     defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif   defined(_M_ALPHA) && !defined(_CRT_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _CrtDbgBreak() _BPT()
#else
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef _CRTDBG_MAP_ALLOC

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)

#endif /* _CRTDBG_MAP_ALLOC */

#if     defined(_DLL) && defined(_M_IX86)
#define _crtBreakAlloc   (*__p__crtBreakAlloc())
_CRTIMP long * __cdecl __p__crtBreakAlloc(void);
#else   /* !(defined(_DLL) && defined(_M_IX86)) */
_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */
#endif  /* defined(_DLL) && defined(_M_IX86) */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_CRTIMP void * __cdecl _malloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _calloc_dbg(
        size_t,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _realloc_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _expand_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void __cdecl _free_dbg(
        void *,
        int
        );

_CRTIMP size_t __cdecl _msize_dbg (
        void *,
        int
        );


 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const char *, int);

_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK
        );


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

#if     defined(_DLL) && defined(_M_IX86)
#define _crtDbgFlag   (*__p__crtDbgFlag())
_CRTIMP int * __cdecl __p__crtDbgFlag(void);
#else   /* !(defined(_DLL) && defined(_M_IX86)) */
_CRTIMP extern int _crtDbgFlag;
#endif  /* defined(_DLL) && defined(_M_IX86) */

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

#define _CRTDBG_REPORT_FLAG     -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)       (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)    (block >> 16 & 0xFFFF)

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void *
        );

_CRTIMP int __cdecl _CrtIsValidPointer(
        const void *,
        unsigned int,
        int
        );

_CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void *
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void *,
        unsigned int,
        long *,
        char **,
        int *
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT
        );

typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        unsigned long lCounts[_MAX_BLOCKS];
        unsigned long lSizes[_MAX_BLOCKS];
        unsigned long lHighWaterCount;
        unsigned long lTotalCount;
} _CrtMemState;


_CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState *
        );

_CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState *,
        const _CrtMemState *,
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState *
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

#endif /* _DEBUG */

#ifdef __cplusplus
}

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

inline void* __cdecl operator new(size_t s, int, const char *, int)
        { return ::operator new(s); }

#else /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/

_CRTIMP void * __cdecl operator new(
        size_t,
        int,
        const char *,
        int
        );

#ifdef _CRTDBG_MAP_ALLOC

inline void* __cdecl operator new(size_t s)
        { return ::operator new(s, _NORMAL_BLOCK, __FILE__, __LINE__); }

#endif /* _CRTDBG_MAP_ALLOC */

#endif /* _DEBUG */

#endif /* __cplusplus */


#endif /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cred.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef _CRED_H

#define _CRED_H

#ifdef __cplusplus
extern "C" {
#endif

// Pre defined Credential Types
// 32 bit unsigned number
// Reserved range 0x00010000 - 0xffffffff

// Primitive
// LSB bit should be zero [even numbers]

#define CRED_TYPE_NTLM 						0x00010002	// 65538
#define CRED_TYPE_KERBEROS					0x00010004	// 65540
#define CRED_TYPE_PLAINTEXT_PASSWORD		0x00010006	// 65542
#define CRED_TYPE_CERTIFICATE	 			0x00010008	// 65544
#define CRED_TYPE_GENERIC		 			0x0001000a	// 65546

// Virtual
// LSB bit should be one [odd numbers]

#define CRED_TYPE_DOMAIN_PASSWORD		0x00010001	// 65537

// Credential Flags

// Taken values [0x1 - 0x1000]

// Read/Write
#define CRED_FLAG_PERSIST					0x00000001
#define CRED_FLAG_DEFAULT					0x00000002
#define CRED_FLAG_PRIVATE					0x00000010

#pragma deprecated ("CRED_FLAG_TRUSTED")
#define CRED_FLAG_TRUSTED                   CRED_FLAG_PRIVATE

// Read
#define CRED_FLAG_IMPLICIT_DEFAULT		0x00000020

// CredWrite Flags
#define CRED_FLAG_FAIL_IF_EXISTING		0x00000400

// CredRead Flags
#define CRED_FLAG_NO_DEFAULT			0x00000800
#pragma deprecated ("CRED_FLAG_NO_IMPLICIT_DEFAULT")
#define CRED_FLAG_NO_IMPLICIT_DEFAULT	0x00001000

// CredWrite Flags
#define CRED_FLAG_NO_BLOB_HANDLING		0x00000040

// Magic constants

#define CRED_VER_1 							1

// Length includes terminating null
#define CRED_MAX_TARGET_LEN			255

// UNLEN=256 + 1 (terminating null)
#define CRED_MAX_USERNAME_LEN 			257

// DNS_MAX_NAME_LENGTH=255 + 1(terminating null)
#define CRED_MAX_DOMAINNAME_LEN 			256

// domain/user (includes terminating null)
#define CRED_MAX_USER_LEN		CRED_MAX_USERNAME_LEN + \
								CRED_MAX_DOMAINNAME_LEN

#define CRED_MAX_DOMAINUSERNAME_LEN 	CRED_MAX_USER_LEN

// Assuming max password length of PWLEN (lmcons.h) = 256
// Our length includes NULL character hence adding space for 1 more character
// Also our lengths are byte size, hence doubling by 2 for WCHAR
// 2050 = (1024+1)*2
#define CRED_MAX_BLOB_SIZE					2050

// Error codes
// 16000-17999

#define ERROR_CREDMAN_ALL_FAILED 			16001L
#define ERROR_CREDMAN_SOME_FAILED		16002L

// Structures

typedef struct _CRED {
	DWORD 		dwVersion;
	DWORD 		dwType;
	PWCHAR 		wszUser;
	DWORD 		dwUserLen;
	PWCHAR 		wszTarget;
	DWORD 		dwTargetLen;
	PBYTE 		pBlob;
	DWORD 		dwBlobSize;
	DWORD 		dwFlags;
} CRED, *PCRED, **PPCRED;

#define CRED_MAX_CRED_SIZE (sizeof(CRED) + \
								(CRED_MAX_USER_LEN+CRED_MAX_TARGET_LEN)*sizeof(WCHAR) + \
								CRED_MAX_BLOB_SIZE)
								
// Functions

DWORD
CredWrite(
	IN	PCRED		pCred,
	IN	DWORD		dwFlags
);

DWORD
CredRead(
	IN 	PWCHAR		wszTarget,
	IN 	DWORD 		dwTargetLen,
	IN 	DWORD		dwType,
	IN 	DWORD		dwFlags,
	OUT PPCRED		ppCred
);

DWORD
CredDelete(
	IN	PWCHAR		wszTarget,
	IN 	DWORD 		dwTargetLen,	
	IN	DWORD		dwType,
	IN 	DWORD		dwFlags
);
	

DWORD
CredFree(
	IN	PBYTE 		pbBuffer
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\credentialprovider.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Tue Jan 23 14:30:39 2007
 */
/* Compiler settings for ..\CredentialProvider.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __CredentialProvider_h__
#define __CredentialProvider_h__

/* Forward Declarations */ 

#ifndef __ICredentialProviderCredential_FWD_DEFINED__
#define __ICredentialProviderCredential_FWD_DEFINED__
typedef interface ICredentialProviderCredential ICredentialProviderCredential;
#endif 	/* __ICredentialProviderCredential_FWD_DEFINED__ */


#ifndef __IQueryContinueWithStatus_FWD_DEFINED__
#define __IQueryContinueWithStatus_FWD_DEFINED__
typedef interface IQueryContinueWithStatus IQueryContinueWithStatus;
#endif 	/* __IQueryContinueWithStatus_FWD_DEFINED__ */


#ifndef __IConnectableCredentialProviderCredential_FWD_DEFINED__
#define __IConnectableCredentialProviderCredential_FWD_DEFINED__
typedef interface IConnectableCredentialProviderCredential IConnectableCredentialProviderCredential;
#endif 	/* __IConnectableCredentialProviderCredential_FWD_DEFINED__ */


#ifndef __ICredentialProviderCredentialEvents_FWD_DEFINED__
#define __ICredentialProviderCredentialEvents_FWD_DEFINED__
typedef interface ICredentialProviderCredentialEvents ICredentialProviderCredentialEvents;
#endif 	/* __ICredentialProviderCredentialEvents_FWD_DEFINED__ */


#ifndef __ICredentialProvider_FWD_DEFINED__
#define __ICredentialProvider_FWD_DEFINED__
typedef interface ICredentialProvider ICredentialProvider;
#endif 	/* __ICredentialProvider_FWD_DEFINED__ */


#ifndef __ICredentialProviderEvents_FWD_DEFINED__
#define __ICredentialProviderEvents_FWD_DEFINED__
typedef interface ICredentialProviderEvents ICredentialProviderEvents;
#endif 	/* __ICredentialProviderEvents_FWD_DEFINED__ */


#ifndef __ICredentialProviderFilter_FWD_DEFINED__
#define __ICredentialProviderFilter_FWD_DEFINED__
typedef interface ICredentialProviderFilter ICredentialProviderFilter;
#endif 	/* __ICredentialProviderFilter_FWD_DEFINED__ */


#ifndef __PasswordCredentialProvider_FWD_DEFINED__
#define __PasswordCredentialProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class PasswordCredentialProvider PasswordCredentialProvider;
#else
typedef struct PasswordCredentialProvider PasswordCredentialProvider;
#endif /* __cplusplus */

#endif 	/* __PasswordCredentialProvider_FWD_DEFINED__ */


#ifndef __NPCredentialProvider_FWD_DEFINED__
#define __NPCredentialProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class NPCredentialProvider NPCredentialProvider;
#else
typedef struct NPCredentialProvider NPCredentialProvider;
#endif /* __cplusplus */

#endif 	/* __NPCredentialProvider_FWD_DEFINED__ */


#ifndef __SmartcardCredentialProvider_FWD_DEFINED__
#define __SmartcardCredentialProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class SmartcardCredentialProvider SmartcardCredentialProvider;
#else
typedef struct SmartcardCredentialProvider SmartcardCredentialProvider;
#endif /* __cplusplus */

#endif 	/* __SmartcardCredentialProvider_FWD_DEFINED__ */


#ifndef __GenericCredentialProvider_FWD_DEFINED__
#define __GenericCredentialProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class GenericCredentialProvider GenericCredentialProvider;
#else
typedef struct GenericCredentialProvider GenericCredentialProvider;
#endif /* __cplusplus */

#endif 	/* __GenericCredentialProvider_FWD_DEFINED__ */


#ifndef __RASProvider_FWD_DEFINED__
#define __RASProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class RASProvider RASProvider;
#else
typedef struct RASProvider RASProvider;
#endif /* __cplusplus */

#endif 	/* __RASProvider_FWD_DEFINED__ */


#ifndef __OnexCredentialProvider_FWD_DEFINED__
#define __OnexCredentialProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class OnexCredentialProvider OnexCredentialProvider;
#else
typedef struct OnexCredentialProvider OnexCredentialProvider;
#endif /* __cplusplus */

#endif 	/* __OnexCredentialProvider_FWD_DEFINED__ */


#ifndef __OnexPlapSmartcardCredentialProvider_FWD_DEFINED__
#define __OnexPlapSmartcardCredentialProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class OnexPlapSmartcardCredentialProvider OnexPlapSmartcardCredentialProvider;
#else
typedef struct OnexPlapSmartcardCredentialProvider OnexPlapSmartcardCredentialProvider;
#endif /* __cplusplus */

#endif 	/* __OnexPlapSmartcardCredentialProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "shobjidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_CredentialProvider_0000 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum _CREDENTIAL_PROVIDER_USAGE_SCENARIO
    {	CPUS_INVALID	= 0,
	CPUS_LOGON	= CPUS_INVALID + 1,
	CPUS_UNLOCK_WORKSTATION	= CPUS_LOGON + 1,
	CPUS_CHANGE_PASSWORD	= CPUS_UNLOCK_WORKSTATION + 1,
	CPUS_CREDUI	= CPUS_CHANGE_PASSWORD + 1,
	CPUS_PLAP	= CPUS_CREDUI + 1
    }	CREDENTIAL_PROVIDER_USAGE_SCENARIO;

typedef /* [v1_enum] */ 
enum _CREDENTIAL_PROVIDER_FIELD_TYPE
    {	CPFT_INVALID	= 0,
	CPFT_LARGE_TEXT	= CPFT_INVALID + 1,
	CPFT_SMALL_TEXT	= CPFT_LARGE_TEXT + 1,
	CPFT_COMMAND_LINK	= CPFT_SMALL_TEXT + 1,
	CPFT_EDIT_TEXT	= CPFT_COMMAND_LINK + 1,
	CPFT_PASSWORD_TEXT	= CPFT_EDIT_TEXT + 1,
	CPFT_TILE_IMAGE	= CPFT_PASSWORD_TEXT + 1,
	CPFT_CHECKBOX	= CPFT_TILE_IMAGE + 1,
	CPFT_COMBOBOX	= CPFT_CHECKBOX + 1,
	CPFT_SUBMIT_BUTTON	= CPFT_COMBOBOX + 1
    }	CREDENTIAL_PROVIDER_FIELD_TYPE;

typedef /* [v1_enum] */ 
enum _CREDENTIAL_PROVIDER_FIELD_STATE
    {	CPFS_HIDDEN	= 0,
	CPFS_DISPLAY_IN_SELECTED_TILE	= CPFS_HIDDEN + 1,
	CPFS_DISPLAY_IN_DESELECTED_TILE	= CPFS_DISPLAY_IN_SELECTED_TILE + 1,
	CPFS_DISPLAY_IN_BOTH	= CPFS_DISPLAY_IN_DESELECTED_TILE + 1
    }	CREDENTIAL_PROVIDER_FIELD_STATE;

typedef /* [v1_enum] */ 
enum _CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE
    {	CPFIS_NONE	= 0,
	CPFIS_READONLY	= CPFIS_NONE + 1,
	CPFIS_DISABLED	= CPFIS_READONLY + 1,
	CPFIS_FOCUSED	= CPFIS_DISABLED + 1
    }	CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE;

typedef struct _CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR
    {
    DWORD dwFieldID;
    CREDENTIAL_PROVIDER_FIELD_TYPE cpft;
    LPWSTR pszLabel;
    GUID guidFieldType;
    }	CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR;

typedef /* [v1_enum] */ 
enum _CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE
    {	CPGSR_NO_CREDENTIAL_NOT_FINISHED	= 0,
	CPGSR_NO_CREDENTIAL_FINISHED	= CPGSR_NO_CREDENTIAL_NOT_FINISHED + 1,
	CPGSR_RETURN_CREDENTIAL_FINISHED	= CPGSR_NO_CREDENTIAL_FINISHED + 1
    }	CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE;

typedef /* [v1_enum] */ 
enum _CREDENTIAL_PROVIDER_STATUS_ICON
    {	CPSI_NONE	= 0,
	CPSI_ERROR	= CPSI_NONE + 1,
	CPSI_WARNING	= CPSI_ERROR + 1,
	CPSI_SUCCESS	= CPSI_WARNING + 1
    }	CREDENTIAL_PROVIDER_STATUS_ICON;

typedef struct _CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION
    {
    ULONG ulAuthenticationPackage;
    GUID clsidCredentialProvider;
    ULONG cbSerialization;
    /* [size_is] */ byte __RPC_FAR *rgbSerialization;
    }	CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION;

typedef LONG NTSTATUS;

#define CREDENTIAL_PROVIDER_NO_DEFAULT       ((DWORD)-1)



extern RPC_IF_HANDLE __MIDL_itf_CredentialProvider_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_CredentialProvider_0000_v0_0_s_ifspec;

#ifndef __ICredentialProviderCredential_INTERFACE_DEFINED__
#define __ICredentialProviderCredential_INTERFACE_DEFINED__

/* interface ICredentialProviderCredential */
/* [uuid][ref][object][local] */ 


EXTERN_C const IID IID_ICredentialProviderCredential;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63913a93-40c1-481a-818d-4072ff8c70cc")
    ICredentialProviderCredential : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ ICredentialProviderCredentialEvents __RPC_FAR *pcpce) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnAdvise( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSelected( 
            /* [out] */ BOOL __RPC_FAR *pbAutoLogon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeselected( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFieldState( 
            /* [in] */ DWORD dwFieldID,
            /* [out] */ CREDENTIAL_PROVIDER_FIELD_STATE __RPC_FAR *pcpfs,
            /* [out] */ CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE __RPC_FAR *pcpfis) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringValue( 
            /* [in] */ DWORD dwFieldID,
            /* [string][out] */ LPWSTR __RPC_FAR *ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBitmapValue( 
            /* [in] */ DWORD dwFieldID,
            /* [out] */ HBITMAP __RPC_FAR *phbmp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCheckboxValue( 
            /* [in] */ DWORD dwFieldID,
            /* [out] */ BOOL __RPC_FAR *pbChecked,
            /* [string][out] */ LPWSTR __RPC_FAR *ppszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubmitButtonValue( 
            /* [in] */ DWORD dwFieldID,
            /* [out] */ DWORD __RPC_FAR *pdwAdjacentTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComboBoxValueCount( 
            /* [in] */ DWORD dwFieldID,
            /* [out] */ DWORD __RPC_FAR *pcItems,
            /* [out] */ DWORD __RPC_FAR *pdwSelectedItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComboBoxValueAt( 
            /* [in] */ DWORD dwFieldID,
            DWORD dwItem,
            /* [string][out] */ LPWSTR __RPC_FAR *ppszItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStringValue( 
            /* [in] */ DWORD dwFieldID,
            /* [string][in] */ LPCWSTR psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCheckboxValue( 
            /* [in] */ DWORD dwFieldID,
            /* [in] */ BOOL bChecked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComboBoxSelectedValue( 
            /* [in] */ DWORD dwFieldID,
            /* [in] */ DWORD dwSelectedItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandLinkClicked( 
            /* [in] */ DWORD dwFieldID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSerialization( 
            /* [out] */ CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE __RPC_FAR *pcpgsr,
            /* [out] */ CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION __RPC_FAR *pcpcs,
            /* [out] */ LPWSTR __RPC_FAR *ppszOptionalStatusText,
            /* [out] */ CREDENTIAL_PROVIDER_STATUS_ICON __RPC_FAR *pcpsiOptionalStatusIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportResult( 
            /* [in] */ NTSTATUS ntsStatus,
            /* [in] */ NTSTATUS ntsSubstatus,
            /* [out] */ LPWSTR __RPC_FAR *ppszOptionalStatusText,
            /* [out] */ CREDENTIAL_PROVIDER_STATUS_ICON __RPC_FAR *pcpsiOptionalStatusIcon) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICredentialProviderCredentialVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICredentialProviderCredential __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICredentialProviderCredential __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ ICredentialProviderCredentialEvents __RPC_FAR *pcpce);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnAdvise )( 
            ICredentialProviderCredential __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSelected )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pbAutoLogon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDeselected )( 
            ICredentialProviderCredential __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFieldState )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [out] */ CREDENTIAL_PROVIDER_FIELD_STATE __RPC_FAR *pcpfs,
            /* [out] */ CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE __RPC_FAR *pcpfis);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStringValue )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [string][out] */ LPWSTR __RPC_FAR *ppsz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBitmapValue )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [out] */ HBITMAP __RPC_FAR *phbmp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCheckboxValue )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [out] */ BOOL __RPC_FAR *pbChecked,
            /* [string][out] */ LPWSTR __RPC_FAR *ppszLabel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubmitButtonValue )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [out] */ DWORD __RPC_FAR *pdwAdjacentTo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComboBoxValueCount )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [out] */ DWORD __RPC_FAR *pcItems,
            /* [out] */ DWORD __RPC_FAR *pdwSelectedItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComboBoxValueAt )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            DWORD dwItem,
            /* [string][out] */ LPWSTR __RPC_FAR *ppszItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStringValue )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [string][in] */ LPCWSTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCheckboxValue )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ BOOL bChecked);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComboBoxSelectedValue )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ DWORD dwSelectedItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandLinkClicked )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialization )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [out] */ CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE __RPC_FAR *pcpgsr,
            /* [out] */ CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION __RPC_FAR *pcpcs,
            /* [out] */ LPWSTR __RPC_FAR *ppszOptionalStatusText,
            /* [out] */ CREDENTIAL_PROVIDER_STATUS_ICON __RPC_FAR *pcpsiOptionalStatusIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReportResult )( 
            ICredentialProviderCredential __RPC_FAR * This,
            /* [in] */ NTSTATUS ntsStatus,
            /* [in] */ NTSTATUS ntsSubstatus,
            /* [out] */ LPWSTR __RPC_FAR *ppszOptionalStatusText,
            /* [out] */ CREDENTIAL_PROVIDER_STATUS_ICON __RPC_FAR *pcpsiOptionalStatusIcon);
        
        END_INTERFACE
    } ICredentialProviderCredentialVtbl;

    interface ICredentialProviderCredential
    {
        CONST_VTBL struct ICredentialProviderCredentialVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICredentialProviderCredential_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICredentialProviderCredential_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICredentialProviderCredential_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICredentialProviderCredential_Advise(This,pcpce)	\
    (This)->lpVtbl -> Advise(This,pcpce)

#define ICredentialProviderCredential_UnAdvise(This)	\
    (This)->lpVtbl -> UnAdvise(This)

#define ICredentialProviderCredential_SetSelected(This,pbAutoLogon)	\
    (This)->lpVtbl -> SetSelected(This,pbAutoLogon)

#define ICredentialProviderCredential_SetDeselected(This)	\
    (This)->lpVtbl -> SetDeselected(This)

#define ICredentialProviderCredential_GetFieldState(This,dwFieldID,pcpfs,pcpfis)	\
    (This)->lpVtbl -> GetFieldState(This,dwFieldID,pcpfs,pcpfis)

#define ICredentialProviderCredential_GetStringValue(This,dwFieldID,ppsz)	\
    (This)->lpVtbl -> GetStringValue(This,dwFieldID,ppsz)

#define ICredentialProviderCredential_GetBitmapValue(This,dwFieldID,phbmp)	\
    (This)->lpVtbl -> GetBitmapValue(This,dwFieldID,phbmp)

#define ICredentialProviderCredential_GetCheckboxValue(This,dwFieldID,pbChecked,ppszLabel)	\
    (This)->lpVtbl -> GetCheckboxValue(This,dwFieldID,pbChecked,ppszLabel)

#define ICredentialProviderCredential_GetSubmitButtonValue(This,dwFieldID,pdwAdjacentTo)	\
    (This)->lpVtbl -> GetSubmitButtonValue(This,dwFieldID,pdwAdjacentTo)

#define ICredentialProviderCredential_GetComboBoxValueCount(This,dwFieldID,pcItems,pdwSelectedItem)	\
    (This)->lpVtbl -> GetComboBoxValueCount(This,dwFieldID,pcItems,pdwSelectedItem)

#define ICredentialProviderCredential_GetComboBoxValueAt(This,dwFieldID,dwItem,ppszItem)	\
    (This)->lpVtbl -> GetComboBoxValueAt(This,dwFieldID,dwItem,ppszItem)

#define ICredentialProviderCredential_SetStringValue(This,dwFieldID,psz)	\
    (This)->lpVtbl -> SetStringValue(This,dwFieldID,psz)

#define ICredentialProviderCredential_SetCheckboxValue(This,dwFieldID,bChecked)	\
    (This)->lpVtbl -> SetCheckboxValue(This,dwFieldID,bChecked)

#define ICredentialProviderCredential_SetComboBoxSelectedValue(This,dwFieldID,dwSelectedItem)	\
    (This)->lpVtbl -> SetComboBoxSelectedValue(This,dwFieldID,dwSelectedItem)

#define ICredentialProviderCredential_CommandLinkClicked(This,dwFieldID)	\
    (This)->lpVtbl -> CommandLinkClicked(This,dwFieldID)

#define ICredentialProviderCredential_GetSerialization(This,pcpgsr,pcpcs,ppszOptionalStatusText,pcpsiOptionalStatusIcon)	\
    (This)->lpVtbl -> GetSerialization(This,pcpgsr,pcpcs,ppszOptionalStatusText,pcpsiOptionalStatusIcon)

#define ICredentialProviderCredential_ReportResult(This,ntsStatus,ntsSubstatus,ppszOptionalStatusText,pcpsiOptionalStatusIcon)	\
    (This)->lpVtbl -> ReportResult(This,ntsStatus,ntsSubstatus,ppszOptionalStatusText,pcpsiOptionalStatusIcon)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_Advise_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [in] */ ICredentialProviderCredentialEvents __RPC_FAR *pcpce);


void __RPC_STUB ICredentialProviderCredential_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_UnAdvise_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This);


void __RPC_STUB ICredentialProviderCredential_UnAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_SetSelected_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pbAutoLogon);


void __RPC_STUB ICredentialProviderCredential_SetSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_SetDeselected_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This);


void __RPC_STUB ICredentialProviderCredential_SetDeselected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_GetFieldState_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [in] */ DWORD dwFieldID,
    /* [out] */ CREDENTIAL_PROVIDER_FIELD_STATE __RPC_FAR *pcpfs,
    /* [out] */ CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE __RPC_FAR *pcpfis);


void __RPC_STUB ICredentialProviderCredential_GetFieldState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_GetStringValue_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [in] */ DWORD dwFieldID,
    /* [string][out] */ LPWSTR __RPC_FAR *ppsz);


void __RPC_STUB ICredentialProviderCredential_GetStringValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_GetBitmapValue_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [in] */ DWORD dwFieldID,
    /* [out] */ HBITMAP __RPC_FAR *phbmp);


void __RPC_STUB ICredentialProviderCredential_GetBitmapValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_GetCheckboxValue_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [in] */ DWORD dwFieldID,
    /* [out] */ BOOL __RPC_FAR *pbChecked,
    /* [string][out] */ LPWSTR __RPC_FAR *ppszLabel);


void __RPC_STUB ICredentialProviderCredential_GetCheckboxValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_GetSubmitButtonValue_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [in] */ DWORD dwFieldID,
    /* [out] */ DWORD __RPC_FAR *pdwAdjacentTo);


void __RPC_STUB ICredentialProviderCredential_GetSubmitButtonValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_GetComboBoxValueCount_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [in] */ DWORD dwFieldID,
    /* [out] */ DWORD __RPC_FAR *pcItems,
    /* [out] */ DWORD __RPC_FAR *pdwSelectedItem);


void __RPC_STUB ICredentialProviderCredential_GetComboBoxValueCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_GetComboBoxValueAt_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [in] */ DWORD dwFieldID,
    DWORD dwItem,
    /* [string][out] */ LPWSTR __RPC_FAR *ppszItem);


void __RPC_STUB ICredentialProviderCredential_GetComboBoxValueAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_SetStringValue_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [in] */ DWORD dwFieldID,
    /* [string][in] */ LPCWSTR psz);


void __RPC_STUB ICredentialProviderCredential_SetStringValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_SetCheckboxValue_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [in] */ DWORD dwFieldID,
    /* [in] */ BOOL bChecked);


void __RPC_STUB ICredentialProviderCredential_SetCheckboxValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_SetComboBoxSelectedValue_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [in] */ DWORD dwFieldID,
    /* [in] */ DWORD dwSelectedItem);


void __RPC_STUB ICredentialProviderCredential_SetComboBoxSelectedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_CommandLinkClicked_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [in] */ DWORD dwFieldID);


void __RPC_STUB ICredentialProviderCredential_CommandLinkClicked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_GetSerialization_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [out] */ CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE __RPC_FAR *pcpgsr,
    /* [out] */ CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION __RPC_FAR *pcpcs,
    /* [out] */ LPWSTR __RPC_FAR *ppszOptionalStatusText,
    /* [out] */ CREDENTIAL_PROVIDER_STATUS_ICON __RPC_FAR *pcpsiOptionalStatusIcon);


void __RPC_STUB ICredentialProviderCredential_GetSerialization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredential_ReportResult_Proxy( 
    ICredentialProviderCredential __RPC_FAR * This,
    /* [in] */ NTSTATUS ntsStatus,
    /* [in] */ NTSTATUS ntsSubstatus,
    /* [out] */ LPWSTR __RPC_FAR *ppszOptionalStatusText,
    /* [out] */ CREDENTIAL_PROVIDER_STATUS_ICON __RPC_FAR *pcpsiOptionalStatusIcon);


void __RPC_STUB ICredentialProviderCredential_ReportResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICredentialProviderCredential_INTERFACE_DEFINED__ */


#ifndef __IQueryContinueWithStatus_INTERFACE_DEFINED__
#define __IQueryContinueWithStatus_INTERFACE_DEFINED__

/* interface IQueryContinueWithStatus */
/* [uuid][ref][object][local] */ 


EXTERN_C const IID IID_IQueryContinueWithStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9090be5b-502b-41fb-bccc-0049a6c7254b")
    IQueryContinueWithStatus : public IQueryContinue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStatusMessage( 
            /* [string][in] */ LPCWSTR psz) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryContinueWithStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IQueryContinueWithStatus __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IQueryContinueWithStatus __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IQueryContinueWithStatus __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryContinue )( 
            IQueryContinueWithStatus __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusMessage )( 
            IQueryContinueWithStatus __RPC_FAR * This,
            /* [string][in] */ LPCWSTR psz);
        
        END_INTERFACE
    } IQueryContinueWithStatusVtbl;

    interface IQueryContinueWithStatus
    {
        CONST_VTBL struct IQueryContinueWithStatusVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryContinueWithStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQueryContinueWithStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IQueryContinueWithStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IQueryContinueWithStatus_QueryContinue(This)	\
    (This)->lpVtbl -> QueryContinue(This)


#define IQueryContinueWithStatus_SetStatusMessage(This,psz)	\
    (This)->lpVtbl -> SetStatusMessage(This,psz)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IQueryContinueWithStatus_SetStatusMessage_Proxy( 
    IQueryContinueWithStatus __RPC_FAR * This,
    /* [string][in] */ LPCWSTR psz);


void __RPC_STUB IQueryContinueWithStatus_SetStatusMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IQueryContinueWithStatus_INTERFACE_DEFINED__ */


#ifndef __IConnectableCredentialProviderCredential_INTERFACE_DEFINED__
#define __IConnectableCredentialProviderCredential_INTERFACE_DEFINED__

/* interface IConnectableCredentialProviderCredential */
/* [uuid][ref][object][local] */ 


EXTERN_C const IID IID_IConnectableCredentialProviderCredential;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9387928b-ac75-4bf9-8ab2-2b93c4a55290")
    IConnectableCredentialProviderCredential : public ICredentialProviderCredential
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ IQueryContinueWithStatus __RPC_FAR *pqcws) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConnectableCredentialProviderCredentialVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ ICredentialProviderCredentialEvents __RPC_FAR *pcpce);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnAdvise )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSelected )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pbAutoLogon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDeselected )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFieldState )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [out] */ CREDENTIAL_PROVIDER_FIELD_STATE __RPC_FAR *pcpfs,
            /* [out] */ CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE __RPC_FAR *pcpfis);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStringValue )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [string][out] */ LPWSTR __RPC_FAR *ppsz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBitmapValue )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [out] */ HBITMAP __RPC_FAR *phbmp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCheckboxValue )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [out] */ BOOL __RPC_FAR *pbChecked,
            /* [string][out] */ LPWSTR __RPC_FAR *ppszLabel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubmitButtonValue )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [out] */ DWORD __RPC_FAR *pdwAdjacentTo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComboBoxValueCount )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [out] */ DWORD __RPC_FAR *pcItems,
            /* [out] */ DWORD __RPC_FAR *pdwSelectedItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComboBoxValueAt )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            DWORD dwItem,
            /* [string][out] */ LPWSTR __RPC_FAR *ppszItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStringValue )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [string][in] */ LPCWSTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCheckboxValue )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ BOOL bChecked);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComboBoxSelectedValue )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ DWORD dwSelectedItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandLinkClicked )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ DWORD dwFieldID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialization )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [out] */ CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE __RPC_FAR *pcpgsr,
            /* [out] */ CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION __RPC_FAR *pcpcs,
            /* [out] */ LPWSTR __RPC_FAR *ppszOptionalStatusText,
            /* [out] */ CREDENTIAL_PROVIDER_STATUS_ICON __RPC_FAR *pcpsiOptionalStatusIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReportResult )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ NTSTATUS ntsStatus,
            /* [in] */ NTSTATUS ntsSubstatus,
            /* [out] */ LPWSTR __RPC_FAR *ppszOptionalStatusText,
            /* [out] */ CREDENTIAL_PROVIDER_STATUS_ICON __RPC_FAR *pcpsiOptionalStatusIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This,
            /* [in] */ IQueryContinueWithStatus __RPC_FAR *pqcws);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IConnectableCredentialProviderCredential __RPC_FAR * This);
        
        END_INTERFACE
    } IConnectableCredentialProviderCredentialVtbl;

    interface IConnectableCredentialProviderCredential
    {
        CONST_VTBL struct IConnectableCredentialProviderCredentialVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConnectableCredentialProviderCredential_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConnectableCredentialProviderCredential_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConnectableCredentialProviderCredential_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConnectableCredentialProviderCredential_Advise(This,pcpce)	\
    (This)->lpVtbl -> Advise(This,pcpce)

#define IConnectableCredentialProviderCredential_UnAdvise(This)	\
    (This)->lpVtbl -> UnAdvise(This)

#define IConnectableCredentialProviderCredential_SetSelected(This,pbAutoLogon)	\
    (This)->lpVtbl -> SetSelected(This,pbAutoLogon)

#define IConnectableCredentialProviderCredential_SetDeselected(This)	\
    (This)->lpVtbl -> SetDeselected(This)

#define IConnectableCredentialProviderCredential_GetFieldState(This,dwFieldID,pcpfs,pcpfis)	\
    (This)->lpVtbl -> GetFieldState(This,dwFieldID,pcpfs,pcpfis)

#define IConnectableCredentialProviderCredential_GetStringValue(This,dwFieldID,ppsz)	\
    (This)->lpVtbl -> GetStringValue(This,dwFieldID,ppsz)

#define IConnectableCredentialProviderCredential_GetBitmapValue(This,dwFieldID,phbmp)	\
    (This)->lpVtbl -> GetBitmapValue(This,dwFieldID,phbmp)

#define IConnectableCredentialProviderCredential_GetCheckboxValue(This,dwFieldID,pbChecked,ppszLabel)	\
    (This)->lpVtbl -> GetCheckboxValue(This,dwFieldID,pbChecked,ppszLabel)

#define IConnectableCredentialProviderCredential_GetSubmitButtonValue(This,dwFieldID,pdwAdjacentTo)	\
    (This)->lpVtbl -> GetSubmitButtonValue(This,dwFieldID,pdwAdjacentTo)

#define IConnectableCredentialProviderCredential_GetComboBoxValueCount(This,dwFieldID,pcItems,pdwSelectedItem)	\
    (This)->lpVtbl -> GetComboBoxValueCount(This,dwFieldID,pcItems,pdwSelectedItem)

#define IConnectableCredentialProviderCredential_GetComboBoxValueAt(This,dwFieldID,dwItem,ppszItem)	\
    (This)->lpVtbl -> GetComboBoxValueAt(This,dwFieldID,dwItem,ppszItem)

#define IConnectableCredentialProviderCredential_SetStringValue(This,dwFieldID,psz)	\
    (This)->lpVtbl -> SetStringValue(This,dwFieldID,psz)

#define IConnectableCredentialProviderCredential_SetCheckboxValue(This,dwFieldID,bChecked)	\
    (This)->lpVtbl -> SetCheckboxValue(This,dwFieldID,bChecked)

#define IConnectableCredentialProviderCredential_SetComboBoxSelectedValue(This,dwFieldID,dwSelectedItem)	\
    (This)->lpVtbl -> SetComboBoxSelectedValue(This,dwFieldID,dwSelectedItem)

#define IConnectableCredentialProviderCredential_CommandLinkClicked(This,dwFieldID)	\
    (This)->lpVtbl -> CommandLinkClicked(This,dwFieldID)

#define IConnectableCredentialProviderCredential_GetSerialization(This,pcpgsr,pcpcs,ppszOptionalStatusText,pcpsiOptionalStatusIcon)	\
    (This)->lpVtbl -> GetSerialization(This,pcpgsr,pcpcs,ppszOptionalStatusText,pcpsiOptionalStatusIcon)

#define IConnectableCredentialProviderCredential_ReportResult(This,ntsStatus,ntsSubstatus,ppszOptionalStatusText,pcpsiOptionalStatusIcon)	\
    (This)->lpVtbl -> ReportResult(This,ntsStatus,ntsSubstatus,ppszOptionalStatusText,pcpsiOptionalStatusIcon)


#define IConnectableCredentialProviderCredential_Connect(This,pqcws)	\
    (This)->lpVtbl -> Connect(This,pqcws)

#define IConnectableCredentialProviderCredential_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IConnectableCredentialProviderCredential_Connect_Proxy( 
    IConnectableCredentialProviderCredential __RPC_FAR * This,
    /* [in] */ IQueryContinueWithStatus __RPC_FAR *pqcws);


void __RPC_STUB IConnectableCredentialProviderCredential_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConnectableCredentialProviderCredential_Disconnect_Proxy( 
    IConnectableCredentialProviderCredential __RPC_FAR * This);


void __RPC_STUB IConnectableCredentialProviderCredential_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConnectableCredentialProviderCredential_INTERFACE_DEFINED__ */


#ifndef __ICredentialProviderCredentialEvents_INTERFACE_DEFINED__
#define __ICredentialProviderCredentialEvents_INTERFACE_DEFINED__

/* interface ICredentialProviderCredentialEvents */
/* [uuid][ref][object][local] */ 


EXTERN_C const IID IID_ICredentialProviderCredentialEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fa6fa76b-66b7-4b11-95f1-86171118e816")
    ICredentialProviderCredentialEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFieldState( 
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ CREDENTIAL_PROVIDER_FIELD_STATE cpfs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFieldInteractiveState( 
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE cpfis) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFieldString( 
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [unique][string][in] */ LPCWSTR psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFieldCheckbox( 
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ BOOL bChecked,
            /* [in] */ LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFieldBitmap( 
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ HBITMAP hbmp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFieldComboBoxSelectedItem( 
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ DWORD dwSelectedItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteFieldComboBoxItem( 
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ DWORD dwItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendFieldComboBoxItem( 
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [string][in] */ LPCWSTR pszItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFieldSubmitButton( 
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ DWORD dwAdjacentTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCreatingWindow( 
            /* [out] */ HWND __RPC_FAR *phwndOwner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICredentialProviderCredentialEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICredentialProviderCredentialEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICredentialProviderCredentialEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICredentialProviderCredentialEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFieldState )( 
            ICredentialProviderCredentialEvents __RPC_FAR * This,
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ CREDENTIAL_PROVIDER_FIELD_STATE cpfs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFieldInteractiveState )( 
            ICredentialProviderCredentialEvents __RPC_FAR * This,
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE cpfis);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFieldString )( 
            ICredentialProviderCredentialEvents __RPC_FAR * This,
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [unique][string][in] */ LPCWSTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFieldCheckbox )( 
            ICredentialProviderCredentialEvents __RPC_FAR * This,
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ BOOL bChecked,
            /* [in] */ LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFieldBitmap )( 
            ICredentialProviderCredentialEvents __RPC_FAR * This,
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ HBITMAP hbmp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFieldComboBoxSelectedItem )( 
            ICredentialProviderCredentialEvents __RPC_FAR * This,
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ DWORD dwSelectedItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteFieldComboBoxItem )( 
            ICredentialProviderCredentialEvents __RPC_FAR * This,
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ DWORD dwItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendFieldComboBoxItem )( 
            ICredentialProviderCredentialEvents __RPC_FAR * This,
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [string][in] */ LPCWSTR pszItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFieldSubmitButton )( 
            ICredentialProviderCredentialEvents __RPC_FAR * This,
            /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
            /* [in] */ DWORD dwFieldID,
            /* [in] */ DWORD dwAdjacentTo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCreatingWindow )( 
            ICredentialProviderCredentialEvents __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwndOwner);
        
        END_INTERFACE
    } ICredentialProviderCredentialEventsVtbl;

    interface ICredentialProviderCredentialEvents
    {
        CONST_VTBL struct ICredentialProviderCredentialEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICredentialProviderCredentialEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICredentialProviderCredentialEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICredentialProviderCredentialEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICredentialProviderCredentialEvents_SetFieldState(This,pcpc,dwFieldID,cpfs)	\
    (This)->lpVtbl -> SetFieldState(This,pcpc,dwFieldID,cpfs)

#define ICredentialProviderCredentialEvents_SetFieldInteractiveState(This,pcpc,dwFieldID,cpfis)	\
    (This)->lpVtbl -> SetFieldInteractiveState(This,pcpc,dwFieldID,cpfis)

#define ICredentialProviderCredentialEvents_SetFieldString(This,pcpc,dwFieldID,psz)	\
    (This)->lpVtbl -> SetFieldString(This,pcpc,dwFieldID,psz)

#define ICredentialProviderCredentialEvents_SetFieldCheckbox(This,pcpc,dwFieldID,bChecked,pszLabel)	\
    (This)->lpVtbl -> SetFieldCheckbox(This,pcpc,dwFieldID,bChecked,pszLabel)

#define ICredentialProviderCredentialEvents_SetFieldBitmap(This,pcpc,dwFieldID,hbmp)	\
    (This)->lpVtbl -> SetFieldBitmap(This,pcpc,dwFieldID,hbmp)

#define ICredentialProviderCredentialEvents_SetFieldComboBoxSelectedItem(This,pcpc,dwFieldID,dwSelectedItem)	\
    (This)->lpVtbl -> SetFieldComboBoxSelectedItem(This,pcpc,dwFieldID,dwSelectedItem)

#define ICredentialProviderCredentialEvents_DeleteFieldComboBoxItem(This,pcpc,dwFieldID,dwItem)	\
    (This)->lpVtbl -> DeleteFieldComboBoxItem(This,pcpc,dwFieldID,dwItem)

#define ICredentialProviderCredentialEvents_AppendFieldComboBoxItem(This,pcpc,dwFieldID,pszItem)	\
    (This)->lpVtbl -> AppendFieldComboBoxItem(This,pcpc,dwFieldID,pszItem)

#define ICredentialProviderCredentialEvents_SetFieldSubmitButton(This,pcpc,dwFieldID,dwAdjacentTo)	\
    (This)->lpVtbl -> SetFieldSubmitButton(This,pcpc,dwFieldID,dwAdjacentTo)

#define ICredentialProviderCredentialEvents_OnCreatingWindow(This,phwndOwner)	\
    (This)->lpVtbl -> OnCreatingWindow(This,phwndOwner)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICredentialProviderCredentialEvents_SetFieldState_Proxy( 
    ICredentialProviderCredentialEvents __RPC_FAR * This,
    /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
    /* [in] */ DWORD dwFieldID,
    /* [in] */ CREDENTIAL_PROVIDER_FIELD_STATE cpfs);


void __RPC_STUB ICredentialProviderCredentialEvents_SetFieldState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredentialEvents_SetFieldInteractiveState_Proxy( 
    ICredentialProviderCredentialEvents __RPC_FAR * This,
    /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
    /* [in] */ DWORD dwFieldID,
    /* [in] */ CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE cpfis);


void __RPC_STUB ICredentialProviderCredentialEvents_SetFieldInteractiveState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredentialEvents_SetFieldString_Proxy( 
    ICredentialProviderCredentialEvents __RPC_FAR * This,
    /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
    /* [in] */ DWORD dwFieldID,
    /* [unique][string][in] */ LPCWSTR psz);


void __RPC_STUB ICredentialProviderCredentialEvents_SetFieldString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredentialEvents_SetFieldCheckbox_Proxy( 
    ICredentialProviderCredentialEvents __RPC_FAR * This,
    /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
    /* [in] */ DWORD dwFieldID,
    /* [in] */ BOOL bChecked,
    /* [in] */ LPCWSTR pszLabel);


void __RPC_STUB ICredentialProviderCredentialEvents_SetFieldCheckbox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredentialEvents_SetFieldBitmap_Proxy( 
    ICredentialProviderCredentialEvents __RPC_FAR * This,
    /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
    /* [in] */ DWORD dwFieldID,
    /* [in] */ HBITMAP hbmp);


void __RPC_STUB ICredentialProviderCredentialEvents_SetFieldBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredentialEvents_SetFieldComboBoxSelectedItem_Proxy( 
    ICredentialProviderCredentialEvents __RPC_FAR * This,
    /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
    /* [in] */ DWORD dwFieldID,
    /* [in] */ DWORD dwSelectedItem);


void __RPC_STUB ICredentialProviderCredentialEvents_SetFieldComboBoxSelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredentialEvents_DeleteFieldComboBoxItem_Proxy( 
    ICredentialProviderCredentialEvents __RPC_FAR * This,
    /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
    /* [in] */ DWORD dwFieldID,
    /* [in] */ DWORD dwItem);


void __RPC_STUB ICredentialProviderCredentialEvents_DeleteFieldComboBoxItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredentialEvents_AppendFieldComboBoxItem_Proxy( 
    ICredentialProviderCredentialEvents __RPC_FAR * This,
    /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
    /* [in] */ DWORD dwFieldID,
    /* [string][in] */ LPCWSTR pszItem);


void __RPC_STUB ICredentialProviderCredentialEvents_AppendFieldComboBoxItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredentialEvents_SetFieldSubmitButton_Proxy( 
    ICredentialProviderCredentialEvents __RPC_FAR * This,
    /* [in] */ ICredentialProviderCredential __RPC_FAR *pcpc,
    /* [in] */ DWORD dwFieldID,
    /* [in] */ DWORD dwAdjacentTo);


void __RPC_STUB ICredentialProviderCredentialEvents_SetFieldSubmitButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderCredentialEvents_OnCreatingWindow_Proxy( 
    ICredentialProviderCredentialEvents __RPC_FAR * This,
    /* [out] */ HWND __RPC_FAR *phwndOwner);


void __RPC_STUB ICredentialProviderCredentialEvents_OnCreatingWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICredentialProviderCredentialEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_CredentialProvider_0468 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_CredentialProvider_0468_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_CredentialProvider_0468_v0_0_s_ifspec;

#ifndef __ICredentialProvider_INTERFACE_DEFINED__
#define __ICredentialProvider_INTERFACE_DEFINED__

/* interface ICredentialProvider */
/* [uuid][ref][object][local] */ 


EXTERN_C const IID IID_ICredentialProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d27c3481-5a1c-45b2-8aaa-c20ebbe8229e")
    ICredentialProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetUsageScenario( 
            /* [in] */ CREDENTIAL_PROVIDER_USAGE_SCENARIO cpus,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSerialization( 
            /* [in] */ const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION __RPC_FAR *pcpcs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ ICredentialProviderEvents __RPC_FAR *pcpe,
            /* [in] */ UINT_PTR upAdviseContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnAdvise( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFieldDescriptorCount( 
            /* [out] */ DWORD __RPC_FAR *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFieldDescriptorAt( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR __RPC_FAR *__RPC_FAR *ppcpfd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCredentialCount( 
            /* [out] */ DWORD __RPC_FAR *pdwCount,
            /* [out] */ DWORD __RPC_FAR *pdwDefault,
            /* [out] */ BOOL __RPC_FAR *pbAutoLogonWithDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCredentialAt( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICredentialProviderCredential __RPC_FAR *__RPC_FAR *ppcpc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICredentialProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICredentialProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICredentialProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICredentialProvider __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUsageScenario )( 
            ICredentialProvider __RPC_FAR * This,
            /* [in] */ CREDENTIAL_PROVIDER_USAGE_SCENARIO cpus,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSerialization )( 
            ICredentialProvider __RPC_FAR * This,
            /* [in] */ const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION __RPC_FAR *pcpcs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            ICredentialProvider __RPC_FAR * This,
            /* [in] */ ICredentialProviderEvents __RPC_FAR *pcpe,
            /* [in] */ UINT_PTR upAdviseContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnAdvise )( 
            ICredentialProvider __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFieldDescriptorCount )( 
            ICredentialProvider __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFieldDescriptorAt )( 
            ICredentialProvider __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR __RPC_FAR *__RPC_FAR *ppcpfd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCredentialCount )( 
            ICredentialProvider __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount,
            /* [out] */ DWORD __RPC_FAR *pdwDefault,
            /* [out] */ BOOL __RPC_FAR *pbAutoLogonWithDefault);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCredentialAt )( 
            ICredentialProvider __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICredentialProviderCredential __RPC_FAR *__RPC_FAR *ppcpc);
        
        END_INTERFACE
    } ICredentialProviderVtbl;

    interface ICredentialProvider
    {
        CONST_VTBL struct ICredentialProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICredentialProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICredentialProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICredentialProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICredentialProvider_SetUsageScenario(This,cpus,dwFlags)	\
    (This)->lpVtbl -> SetUsageScenario(This,cpus,dwFlags)

#define ICredentialProvider_SetSerialization(This,pcpcs)	\
    (This)->lpVtbl -> SetSerialization(This,pcpcs)

#define ICredentialProvider_Advise(This,pcpe,upAdviseContext)	\
    (This)->lpVtbl -> Advise(This,pcpe,upAdviseContext)

#define ICredentialProvider_UnAdvise(This)	\
    (This)->lpVtbl -> UnAdvise(This)

#define ICredentialProvider_GetFieldDescriptorCount(This,pdwCount)	\
    (This)->lpVtbl -> GetFieldDescriptorCount(This,pdwCount)

#define ICredentialProvider_GetFieldDescriptorAt(This,dwIndex,ppcpfd)	\
    (This)->lpVtbl -> GetFieldDescriptorAt(This,dwIndex,ppcpfd)

#define ICredentialProvider_GetCredentialCount(This,pdwCount,pdwDefault,pbAutoLogonWithDefault)	\
    (This)->lpVtbl -> GetCredentialCount(This,pdwCount,pdwDefault,pbAutoLogonWithDefault)

#define ICredentialProvider_GetCredentialAt(This,dwIndex,ppcpc)	\
    (This)->lpVtbl -> GetCredentialAt(This,dwIndex,ppcpc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICredentialProvider_SetUsageScenario_Proxy( 
    ICredentialProvider __RPC_FAR * This,
    /* [in] */ CREDENTIAL_PROVIDER_USAGE_SCENARIO cpus,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICredentialProvider_SetUsageScenario_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProvider_SetSerialization_Proxy( 
    ICredentialProvider __RPC_FAR * This,
    /* [in] */ const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION __RPC_FAR *pcpcs);


void __RPC_STUB ICredentialProvider_SetSerialization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProvider_Advise_Proxy( 
    ICredentialProvider __RPC_FAR * This,
    /* [in] */ ICredentialProviderEvents __RPC_FAR *pcpe,
    /* [in] */ UINT_PTR upAdviseContext);


void __RPC_STUB ICredentialProvider_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProvider_UnAdvise_Proxy( 
    ICredentialProvider __RPC_FAR * This);


void __RPC_STUB ICredentialProvider_UnAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProvider_GetFieldDescriptorCount_Proxy( 
    ICredentialProvider __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCount);


void __RPC_STUB ICredentialProvider_GetFieldDescriptorCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProvider_GetFieldDescriptorAt_Proxy( 
    ICredentialProvider __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR __RPC_FAR *__RPC_FAR *ppcpfd);


void __RPC_STUB ICredentialProvider_GetFieldDescriptorAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProvider_GetCredentialCount_Proxy( 
    ICredentialProvider __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCount,
    /* [out] */ DWORD __RPC_FAR *pdwDefault,
    /* [out] */ BOOL __RPC_FAR *pbAutoLogonWithDefault);


void __RPC_STUB ICredentialProvider_GetCredentialCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProvider_GetCredentialAt_Proxy( 
    ICredentialProvider __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ ICredentialProviderCredential __RPC_FAR *__RPC_FAR *ppcpc);


void __RPC_STUB ICredentialProvider_GetCredentialAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICredentialProvider_INTERFACE_DEFINED__ */


#ifndef __ICredentialProviderEvents_INTERFACE_DEFINED__
#define __ICredentialProviderEvents_INTERFACE_DEFINED__

/* interface ICredentialProviderEvents */
/* [uuid][ref][object] */ 


EXTERN_C const IID IID_ICredentialProviderEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34201e5a-a787-41a3-a5a4-bd6dcf2a854e")
    ICredentialProviderEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CredentialsChanged( 
            /* [in] */ UINT_PTR upAdviseContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICredentialProviderEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICredentialProviderEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICredentialProviderEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICredentialProviderEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CredentialsChanged )( 
            ICredentialProviderEvents __RPC_FAR * This,
            /* [in] */ UINT_PTR upAdviseContext);
        
        END_INTERFACE
    } ICredentialProviderEventsVtbl;

    interface ICredentialProviderEvents
    {
        CONST_VTBL struct ICredentialProviderEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICredentialProviderEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICredentialProviderEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICredentialProviderEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICredentialProviderEvents_CredentialsChanged(This,upAdviseContext)	\
    (This)->lpVtbl -> CredentialsChanged(This,upAdviseContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICredentialProviderEvents_CredentialsChanged_Proxy( 
    ICredentialProviderEvents __RPC_FAR * This,
    /* [in] */ UINT_PTR upAdviseContext);


void __RPC_STUB ICredentialProviderEvents_CredentialsChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICredentialProviderEvents_INTERFACE_DEFINED__ */


#ifndef __ICredentialProviderFilter_INTERFACE_DEFINED__
#define __ICredentialProviderFilter_INTERFACE_DEFINED__

/* interface ICredentialProviderFilter */
/* [uuid][ref][object][local] */ 


EXTERN_C const IID IID_ICredentialProviderFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a5da53f9-d475-4080-a120-910c4a739880")
    ICredentialProviderFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Filter( 
            /* [in] */ CREDENTIAL_PROVIDER_USAGE_SCENARIO cpus,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ GUID __RPC_FAR *rgclsidProviders,
            /* [size_is][out][in] */ BOOL __RPC_FAR *rgbAllow,
            /* [in] */ DWORD cProviders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateRemoteCredential( 
            /* [in] */ const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION __RPC_FAR *pcpcsIn,
            /* [out] */ CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION __RPC_FAR *pcpcsOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICredentialProviderFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICredentialProviderFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICredentialProviderFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICredentialProviderFilter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Filter )( 
            ICredentialProviderFilter __RPC_FAR * This,
            /* [in] */ CREDENTIAL_PROVIDER_USAGE_SCENARIO cpus,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ GUID __RPC_FAR *rgclsidProviders,
            /* [size_is][out][in] */ BOOL __RPC_FAR *rgbAllow,
            /* [in] */ DWORD cProviders);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateRemoteCredential )( 
            ICredentialProviderFilter __RPC_FAR * This,
            /* [in] */ const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION __RPC_FAR *pcpcsIn,
            /* [out] */ CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION __RPC_FAR *pcpcsOut);
        
        END_INTERFACE
    } ICredentialProviderFilterVtbl;

    interface ICredentialProviderFilter
    {
        CONST_VTBL struct ICredentialProviderFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICredentialProviderFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICredentialProviderFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICredentialProviderFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICredentialProviderFilter_Filter(This,cpus,dwFlags,rgclsidProviders,rgbAllow,cProviders)	\
    (This)->lpVtbl -> Filter(This,cpus,dwFlags,rgclsidProviders,rgbAllow,cProviders)

#define ICredentialProviderFilter_UpdateRemoteCredential(This,pcpcsIn,pcpcsOut)	\
    (This)->lpVtbl -> UpdateRemoteCredential(This,pcpcsIn,pcpcsOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICredentialProviderFilter_Filter_Proxy( 
    ICredentialProviderFilter __RPC_FAR * This,
    /* [in] */ CREDENTIAL_PROVIDER_USAGE_SCENARIO cpus,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ GUID __RPC_FAR *rgclsidProviders,
    /* [size_is][out][in] */ BOOL __RPC_FAR *rgbAllow,
    /* [in] */ DWORD cProviders);


void __RPC_STUB ICredentialProviderFilter_Filter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICredentialProviderFilter_UpdateRemoteCredential_Proxy( 
    ICredentialProviderFilter __RPC_FAR * This,
    /* [in] */ const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION __RPC_FAR *pcpcsIn,
    /* [out] */ CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION __RPC_FAR *pcpcsOut);


void __RPC_STUB ICredentialProviderFilter_UpdateRemoteCredential_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICredentialProviderFilter_INTERFACE_DEFINED__ */



#ifndef __CredentialProviders_LIBRARY_DEFINED__
#define __CredentialProviders_LIBRARY_DEFINED__

/* library CredentialProviders */
/* [uuid] */ 


EXTERN_C const IID LIBID_CredentialProviders;

EXTERN_C const CLSID CLSID_PasswordCredentialProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("6f45dc1e-5384-457a-bc13-2cd81b0d28ed")
PasswordCredentialProvider;
#endif

EXTERN_C const CLSID CLSID_NPCredentialProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("3dd6bec0-8193-4ffe-ae25-e08e39ea4063")
NPCredentialProvider;
#endif

EXTERN_C const CLSID CLSID_SmartcardCredentialProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("8bf9a910-a8ff-457f-999f-a5ca10b4a885")
SmartcardCredentialProvider;
#endif

EXTERN_C const CLSID CLSID_GenericCredentialProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("25CBB996-92ED-457e-B28C-4774084BD562")
GenericCredentialProvider;
#endif

EXTERN_C const CLSID CLSID_RASProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("5537E283-B1E7-4EF8-9C6E-7AB0AFE5056D")
RASProvider;
#endif

EXTERN_C const CLSID CLSID_OnexCredentialProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("07AA0886-CC8D-4e19-A410-1C75AF686E62")
OnexCredentialProvider;
#endif

EXTERN_C const CLSID CLSID_OnexPlapSmartcardCredentialProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("33c86cd6-705f-4ba1-9adb-67070b837775")
OnexPlapSmartcardCredentialProvider;
#endif
#endif /* __CredentialProviders_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\crtdefs.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/

/* Lack of pragma once is deliberate */

/* Define _CRTIMP */
#ifndef _CRTIMP
#define _CRTIMP
#endif  /* _CRTIMP */

/* Define _INTRIMP for functions which are always intrinsics */
#ifndef _INTRIMP
#define _INTRIMP
#endif

/* Define _INTRIMP2 for functions which are intrinsic for RISC, but not x86 */
#ifndef _INTRIMP2
#define _INTRIMP2
#endif

#ifndef _INC_CRTDEFS
#define _INC_CRTDEFS



#if defined(__midl)
/* MIDL does not want to see this stuff */
#undef _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
#undef _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT
#undef _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 0
#endif

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#include <sal.h>

#ifdef  _MSC_VER
#undef _CRT_PACKING
#define _CRT_PACKING 8

#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

/* preprocessor string helpers */
#ifndef _CRT_STRINGIZE
#define __CRT_STRINGIZE(_Value) #_Value
#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)
#endif

#ifndef _CRT_WIDE
#define __CRT_WIDE(_String) L ## _String
#define _CRT_WIDE(_String) __CRT_WIDE(_String)
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif


/* Define _CRTIMP2 */

#ifndef _CRTIMP2
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP2 */

/* Define _CRTIMP_ALTERNATIVE */

#ifndef _CRTIMP_ALTERNATIVE
#ifdef  _DLL
#ifdef _CRT_ALTERNATIVE_INLINES
#define _CRTIMP_ALTERNATIVE
#else
#define _CRTIMP_ALTERNATIVE _CRTIMP
#define _CRT_ALTERNATIVE_IMPORTED
#endif
#else   /* ndef _DLL */
#define _CRTIMP_ALTERNATIVE
#endif  /* _DLL */
#endif  /* _CRTIMP_ALTERNATIVE */


/* Define __STDC_SECURE_LIB__ */
#define __STDC_SECURE_LIB__ 200411L

/* Default value for __STDC_WANT_SECURE_LIB__ is 1 */
#ifndef __STDC_WANT_SECURE_LIB__
#define __STDC_WANT_SECURE_LIB__ 1
#endif

/* Turn off deprecation if __STDC_WANT_SECURE_LIB__ is 0 */
#if !__STDC_WANT_SECURE_LIB__ && !defined(_CRT_SECURE_NO_DEPRECATE)
#define _CRT_SECURE_NO_DEPRECATE
#endif

#if !defined(__midl) && !defined(MIDL_PASS)
#if _MSC_FULL_VER >= 140050320
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated(_Text))
#else
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated)
#endif
#else // !defined(__midl) && !defined(MIDL_PASS)
#define _CRT_DEPRECATE_TEXT(_Text)
#endif

/* Define _CRT_INSECURE_DEPRECATE */
#ifndef _CRT_INSECURE_DEPRECATE
#ifdef _CRT_SECURE_NO_DEPRECATE
#define _CRT_INSECURE_DEPRECATE(_Replacement)
#else
#define _CRT_INSECURE_DEPRECATE(_Replacement) _CRT_DEPRECATE_TEXT("This function or variable may be unsafe. Consider using " #_Replacement " instead. To disable deprecation, use _CRT_SECURE_NO_DEPRECATE. See online help for details.")
#endif
#endif

/* Define _CRT_INSECURE_DEPRECATE_MEMORY */
#ifndef _CRT_INSECURE_DEPRECATE_MEMORY
#if !defined(_CRT_SECURE_DEPRECATE_MEMORY)
#define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement)
#else
#define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement) _CRT_INSECURE_DEPRECATE(_Replacement)
#endif
#endif

/* Define _CRT_INSECURE_DEPRECATE_GLOBALS */
#ifndef _CRT_INSECURE_DEPRECATE_GLOBALS
#if defined (RC_INVOKED)
#define _CRT_INSECURE_DEPRECATE_GLOBALS(_Replacement)
#else
#if defined(_CRT_SECURE_NO_DEPRECATE_GLOBALS)
#define _CRT_INSECURE_DEPRECATE_GLOBALS(_Replacement)
#else
#define _CRT_INSECURE_DEPRECATE_GLOBALS(_Replacement) _CRT_INSECURE_DEPRECATE(_Replacement)
#endif
#endif
#endif

/* _SECURECRT_FILL_BUFFER_PATTERN is the same as _bNoMansLandFill */
#define _SECURECRT_FILL_BUFFER_PATTERN 0xFD

/* obsolete stuff */

/* Define _CRT_OBSOLETE */
#ifndef _CRT_OBSOLETE
#ifdef _CRT_OBSOLETE_NO_DEPRECATE
#define _CRT_OBSOLETE(_NewItem)
#else
#define _CRT_OBSOLETE(_NewItem) _CRT_DEPRECATE_TEXT("This function or variable has been superceded by newer library or operating system functionality. Consider using" #_NewItem "instead. See online help for details.")
#endif
#endif

/* Define overload switches */
#if !defined (RC_INVOKED)
 #if !defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)
  #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
 #else
  #if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
   #error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
  #endif
 #endif
#endif

#if !defined (RC_INVOKED)
 #if !defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT)
  /* _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT is ignored if _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES is set to 0 */
  #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
 #else
  #if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT
   #error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
  #endif
 #endif
#endif

#if !defined (RC_INVOKED)
 #if !defined(_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES)
  #if __STDC_WANT_SECURE_LIB__
   #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
  #else
   #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 0
  #endif
 #else
  #if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES
   #error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
  #endif
 #endif
#endif

/* Define _CRT_NONSTDC_DEPRECATE */
#if !defined(_CRT_NONSTDC_DEPRECATE)
#if defined(_CRT_NONSTDC_NO_DEPRECATE) || defined(_POSIX_)
#define _CRT_NONSTDC_DEPRECATE(_NewName)
#else
#define _CRT_NONSTDC_DEPRECATE(_NewName) _CRT_DEPRECATE_TEXT("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " #_NewName ". See online help for details.")
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#if __STDC_WANT_SECURE_LIB__
#ifndef _RSIZE_T_DEFINED
typedef size_t rsize_t;
#define _RSIZE_T_DEFINED
#endif
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _PTRDIFF_T_DEFINED
#ifdef  _WIN64
typedef __int64             ptrdiff_t;
#else
typedef _W64 int            ptrdiff_t;
#endif
#define _PTRDIFF_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
#ifdef _M_CEE_PURE
typedef System::ArgIterator va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#if     _INTEGRAL_MAX_BITS < 64
// The resource compiler doesn't like this being set twice and public\common\oak\misc\makefile.def already sets it
#undef _USE_32BIT_TIME_T
#define _USE_32BIT_TIME_T
#endif

#ifndef _ERRCODE_DEFINED
#define _ERRCODE_DEFINED
typedef int errno_t;
#endif

#ifndef _TIME32_T_DEFINED
typedef _W64 unsigned long __time32_t;   /* 32-bit time value */
#define _TIME32_T_DEFINED
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef _USE_32BIT_TIME_T
typedef __time32_t time_t;      /* time value */
#else
typedef __time64_t time_t;      /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _CONST_RETURN
#ifdef  __cplusplus
#define _CONST_RETURN  const
#define _CRT_CONST_CORRECT_OVERLOADS
#else
#define _CONST_RETURN
#endif
#endif

#if !defined(UNALIGNED)
#if defined(_M_IX86)
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif

#if !defined(_CRT_ALIGN)
#if defined(__midl)
#define _CRT_ALIGN(x)
#else
#define _CRT_ALIGN(x) __declspec(align(x))
#endif
#endif

/* Define _CRTNOALIAS, _CRTRESTRICT, _CRTNORETURN */

#if (_MSC_VER >= 1400) && !defined(__midl) && !defined(MIDL_PASS)

#ifndef _CRTNOALIAS
#define _CRTNOALIAS __declspec(noalias)
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT __declspec(restrict)
#endif  /* _CRTRESTRICT */

#ifndef _CRTNORETURN
#define _CRTNORETURN __declspec(noreturn)
#endif  /* _CRTNORETURN */

#else

#ifndef _CRTNOALIAS
#define _CRTNOALIAS
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT
#endif  /* _CRTRESTRICT */

#ifndef _CRTNORETURN
#define _CRTNORETURN
#endif  /* _CRTNORETURN */

#endif

/* Define __cdecl for non-Microsoft compilers */
#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(__CRTDECL)
#if defined(_M_CEE_PURE)
#define __CRTDECL
#else
#define __CRTDECL   __cdecl
#endif
#endif

#if !defined(_CRTAPI1)
#define _CRTAPI1 __cdecl
#endif


#define _ARGMAX 100

/* _TRUNCATE */
#if !defined(_TRUNCATE)
#define _TRUNCATE ((size_t)-1)
#endif

/* helper macros for cpp overloads */
#if !defined(RC_INVOKED)
#if defined(__cplusplus) && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(_ReturnType, _FuncName, _DstType, _Dst) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size]) \
    { \
        return _FuncName(_Dst, _Size); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1) \
    { \
        return _FuncName(_Dst, _Size, _TArg1); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return _FuncName(_Dst, _Size, _TArg1, _TArg2); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return _FuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        return _FuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3, _TArg4); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1) \
    { \
        return _FuncName(_HArg1, _Dst, _Size, _TArg1); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return _FuncName(_HArg1, _Dst, _Size, _TArg1, _TArg2); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return _FuncName(_HArg1, _Dst, _Size, _TArg1, _TArg2, _TArg3); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(_ReturnType, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType (&_Dst)[_Size]) \
    { \
        return _FuncName(_HArg1, _HArg2, _Dst, _Size); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1) \
    extern "C++" \
    { \
    __pragma(warning(push)); \
    __pragma(warning(disable: 4793)); \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg1); \
        return _VFuncName(_Dst, _Size, _TArg1, _ArgList); \
    } \
    __pragma(warning(pop)); \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    extern "C++" \
    { \
    __pragma(warning(push)); \
    __pragma(warning(disable: 4793)); \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg2); \
        return _VFuncName(_Dst, _Size, _TArg1, _TArg2, _ArgList); \
    } \
    __pragma(warning(pop)); \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(_ReturnType, _FuncName, _DstType, _Src) \
    extern "C++" \
    { \
    template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> \
    inline \
    _ReturnType __CRTDECL _FuncName(__in const _DstType *_Src, __out_ecount_opt(_DriveSize) _DstType (&_Drive)[_DriveSize], __out_ecount_opt(_DirSize) _DstType (&_Dir)[_DirSize], __out_ecount_opt(_NameSize) _DstType (&_Name)[_NameSize], __out_ecount_opt(_ExtSize) _DstType (&_Ext)[_ExtSize]) \
    { \
        return _FuncName(_Src, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); \
    } \
    }

#else

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(_ReturnType, _FuncName, _DstType, _Dst)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(_ReturnType, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(_ReturnType, _FuncName, _DstType, _Src)

#endif /* _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES */
#endif

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _VFuncName, _VFuncName##_s, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _VFuncName##_s, _DstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE(_DeclSpec, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE(_DeclSpec, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _Dst) \

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _VFuncName, _VFuncName##_s, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(_DeclSpec, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(_DeclSpec, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)


#if !defined(RC_INVOKED)
#if defined(__cplusplus) && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES

#define __RETURN_POLICY_SAME(_FunctionCall, _Dst) return (_FunctionCall)
#define __RETURN_POLICY_DST(_FunctionCall, _Dst) return ((_FunctionCall) == 0 ? _Dst : 0)
#define __RETURN_POLICY_VOID(_FunctionCall, _Dst) (_FunctionCall); return
#define __EMPTY_DECLSPEC

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_DstType *); \
        return _FuncName(_Dst); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst) \
    { \
        return __insecure_##_FuncName(_Dst); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size]) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1]) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _DstType, _Dst) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_DstType *); \
        return _FuncName(_Dst); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst) \
    { \
        return __insecure_##_FuncName(_Dst); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size]) \
    { \
        size_t _SizeRead = 0; \
        errno_t _Err = _FuncName##_s(_Dst + 2, (_Size - 2) < ((size_t)_Dst[0]) ? (_Size - 2) : ((size_t)_Dst[0]), &_SizeRead); \
        _Dst[1] = (_DstType)(_SizeRead); \
        return (_Err == 0 ? _Dst + 2 : 0); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1]) \
    { \
        return __insecure_##_FuncName((_DstType *)_Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName<2>(_DstType (&_Dst)[2]) \
    { \
        return __insecure_##_FuncName((_DstType *)_Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_DstType *, _TType1); \
        return _FuncName(_Dst, _TArg1); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_DstType *, _TType1, _TType2); \
        return _FuncName(_Dst, _TArg1, _TArg2); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1, _TArg2); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_DstType *, _TType1, _TType2, _TType3); \
        return _FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2, _TArg3), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_DstType *, _TType1, _TType2, _TType3, _TType4); \
        return _FuncName(_Dst, _TArg1, _TArg2, _TArg3, _TArg4); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3, _TArg4); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3, _TArg4); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3, _TArg4); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3, _TArg4), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2, _TArg3, _TArg4), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_HType1 _HArg1, _DstType *_Dst, _TType1 _TArg1) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_HType1, _DstType *, _TType1); \
        return _FuncName(_HArg1, _Dst, _TArg1); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _T &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(_HArg1, static_cast<_DstType *>(_Dst), _TArg1); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, const _T &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(_HArg1, static_cast<_DstType *>(_Dst), _TArg1); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType * &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(_HArg1, _Dst, _TArg1); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1) \
    { \
        _ReturnPolicy(_SecureFuncName(_HArg1, _Dst, _Size, _TArg1), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_HType1 _HArg1, _DstType (&_Dst)[1], _TType1 _TArg1) \
    { \
        _ReturnPolicy(_SecureFuncName(_HArg1, _Dst, 1, _TArg1), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType *_Dst) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_HType1, _HType2, _DstType *); \
        return _FuncName(_HArg1, _HArg2, _Dst); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _T &_Dst) \
    { \
        return __insecure_##_FuncName(_HArg1, _HArg2, static_cast<_DstType *>(_Dst)); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, const _T &_Dst) \
    { \
        return __insecure_##_FuncName(_HArg1, _HArg2, static_cast<_DstType *>(_Dst)); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType * &_Dst) \
    { \
        return __insecure_##_FuncName(_HArg1, _HArg2, _Dst); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType (&_Dst)[_Size]) \
    { \
        _ReturnPolicy(_SecureFuncName(_HArg1, _HArg2, _Dst, _Size), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_HType1 _HArg1, _HType2 _HArg2, _DstType (&_Dst)[1]) \
    { \
        _ReturnPolicy(_SecureFuncName(_HArg1, _HArg2, _Dst, 1), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _DstType, _Dst, _TType1, _TArg1) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_VFuncName(_DstType *_Dst, _TType1 _TArg1, va_list _ArgList) \
    { \
        _DeclSpec _ReturnType __cdecl _VFuncName(_DstType *, _TType1, va_list); \
        return _VFuncName(_Dst, _TArg1, _ArgList); \
    } \
    extern "C++" \
    { \
    __pragma(warning(push)); \
    __pragma(warning(disable: 4793)); \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg1); \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg1); \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
    } \
    __pragma(warning(pop)); \
    \
    __pragma(warning(push)); \
    __pragma(warning(disable: 4793)); \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg1); \
        return __insecure_##_VFuncName(_Dst, _TArg1, _ArgList); \
    } \
    __pragma(warning(pop)); \
    \
    __pragma(warning(push)); \
    __pragma(warning(disable: 4793)); \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg1); \
        _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _ArgList), _Dst); \
    } \
    __pragma(warning(pop)); \
    \
    __pragma(warning(push)); \
    __pragma(warning(disable: 4793)); \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg1); \
        _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _ArgList), _Dst); \
    } \
    __pragma(warning(pop)); \
    \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName(_T &_Dst, _TType1 _TArg1, va_list _ArgList) \
    { \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName(const _T &_Dst, _TType1 _TArg1, va_list _ArgList) \
    { \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName(_DstType *&_Dst, _TType1 _TArg1, va_list _ArgList) \
    { \
        return __insecure_##_VFuncName(_Dst, _TArg1, _ArgList); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _VFuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, va_list _ArgList) \
    { \
        _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _ArgList), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, va_list _ArgList) \
    { \
        _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _ArgList), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SecureVFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_VFuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
    { \
        _DeclSpec _ReturnType __cdecl _VFuncName(_DstType *, _TType1, _TType2, va_list); \
        return _VFuncName(_Dst, _TArg1, _TArg2, _ArgList); \
    } \
    extern "C++" \
    { \
    __pragma(warning(push)); \
    __pragma(warning(disable: 4793)); \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg2); \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg2); \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
    } \
    __pragma(warning(pop)); \
    \
    __pragma(warning(push)); \
    __pragma(warning(disable: 4793)); \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg2); \
        return __insecure_##_VFuncName(_Dst, _TArg1, _TArg2, _ArgList); \
    } \
    __pragma(warning(pop)); \
    \
    __pragma(warning(push)); \
    __pragma(warning(disable: 4793)); \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg2); \
        _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _TArg2, _ArgList), _Dst); \
    } \
    __pragma(warning(pop)); \
    \
    __pragma(warning(push)); \
    __pragma(warning(disable: 4793)); \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg2); \
        _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _TArg2, _ArgList), _Dst); \
    } \
    __pragma(warning(pop)); \
    \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
    { \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
    { \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName(_DstType *&_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
    { \
        return __insecure_##_VFuncName(_Dst, _TArg1, _TArg2, _ArgList); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _VFuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
    { \
        _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _TArg2, _ArgList), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
    { \
        _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _TArg2, _ArgList), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __inline \
    size_t __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        _DeclSpec size_t __cdecl _FuncName(_DstType *, _TType1, _TType2); \
        return _FuncName(_Dst, _TArg1, _TArg2); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1, _TArg2); \
    } \
    template <size_t _Size> \
    inline \
    size_t __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        size_t _Ret = 0; \
        _SecureFuncName(&_Ret, _Dst, _Size, _TArg1, _TArg2); \
        return (_Ret > 0 ? (_Ret - 1) : _Ret); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        size_t _Ret = 0; \
        _SecureFuncName(&_Ret, _Dst, 1, _TArg1, _TArg2); \
        return (_Ret > 0 ? (_Ret - 1) : _Ret); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __inline \
    size_t __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        _DeclSpec size_t __cdecl _FuncName(_DstType *, _TType1, _TType2, _TType3); \
        return _FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
    } \
    template <size_t _Size> \
    inline \
    size_t __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        size_t _Ret = 0; \
        _SecureFuncName(&_Ret, _Dst, _Size, _TArg1, _TArg2, _TArg3); \
        return (_Ret > 0 ? (_Ret - 1) : _Ret); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        size_t _Ret = 0; \
        _SecureFuncName(&_Ret, _Dst, 1, _TArg1, _TArg2, _TArg3); \
        return (_Ret > 0 ? (_Ret - 1) : _Ret); \
    } \
    }

#if !defined(RC_INVOKED) && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _VFuncName##_s, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#else

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst) \
        _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName,_VFuncName, _SecureVFuncName, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, ...); \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_DstType *_Dst, _TType1 _TArg1, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
    _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
    _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#endif /* _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT */

#else

#define __RETURN_POLICY_SAME(_FunctionCall)
#define __RETURN_POLICY_DST(_FunctionCall)
#define __RETURN_POLICY_VOID(_FunctionCall)
#define __EMPTY_DECLSPEC

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, ...); \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_DstType *_Dst, _TType1 _TArg1, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SecureVFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, ...); \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_DstType *_Dst, _TType1 _TArg1, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
    _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
    _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#endif /* _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES */
#endif

struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
typedef struct threadmbcinfostruct * pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct
{
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
} _locale_tstruct, *_locale_t;

#ifndef _TAGLC_ID_DEFINED
typedef struct tagLC_ID {
        unsigned short wLanguage;
        unsigned short wCountry;
        unsigned short wCodePage;
} LC_ID, *LPLC_ID;
#define _TAGLC_ID_DEFINED
#endif  /* _TAGLC_ID_DEFINED */

#ifndef _THREADLOCALEINFO
typedef struct threadlocaleinfostruct {
        int refcount;
        unsigned int lc_codepage;
        unsigned int lc_collate_cp;
        unsigned long lc_handle[6]; /* LCID */
        LC_ID lc_id[6];
        struct {
            char *locale;
            wchar_t *wlocale;
            int *refcount;
            int *wrefcount;
        } lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
#ifndef _WIN32_WCE
        const unsigned char * pclmap;
        const unsigned char * pcumap;
#endif /* _WIN32_WCE */
        struct __lc_time_data * lc_time_curr;
} threadlocinfo;
#define _THREADLOCALEINFO
#endif

#ifdef  __cplusplus
}
#endif

#if defined(_PREFAST_) && defined(_PFT_SHOULD_CHECK_RETURN)
#define __checkReturn_opt __checkReturn
#else
#define __checkReturn_opt
#endif

#if defined(_PREFAST_) && defined(_PFT_SHOULD_CHECK_RETURN_WAT)
#define __checkReturn_wat __checkReturn
#else
#define __checkReturn_wat
#endif

#if !defined(__midl) && !defined(MIDL_PASS) && defined(_PREFAST_)
#define __crt_typefix(ctype)              __declspec("SAL_typefix(" __CRT_STRINGIZE(ctype) ")")
#else
#define __crt_typefix(ctype)
#endif

#if (defined(__midl))
/* suppress tchar inlines */
#ifndef _NO_INLINING
#define _NO_INLINING
#endif
#endif

#ifndef _CRT_UNUSED
#define _CRT_UNUSED(x) (void)x
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_CRTDEFS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cryptdlg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptdlg.h
//
//  Contents:   Common Cryptographic Dialog API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __CRYPTDLG_H__
#define __CRYPTDLG_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef _CRYPTDLG_
#define CRYPTDLGAPI
#else
#define CRYPTDLGAPI DECLSPEC_IMPORT
#endif

#if (_WIN32_WINNT >= 0x0400) || defined(_MAC) || defined(WIN16)

#include <prsht.h>

#ifdef __cplusplus
extern "C" {
#endif

// Master flags to control how revocation is managed

#define CRYTPDLG_FLAGS_MASK                 0xff000000
#define CRYPTDLG_REVOCATION_DEFAULT         0x00000000
#define CRYPTDLG_REVOCATION_ONLINE          0x80000000
#define CRYPTDLG_REVOCATION_CACHE           0x40000000
#define CRYPTDLG_REVOCATION_NONE            0x20000000


// Policy flags which control how we deal with user's certificates

#define CRYPTDLG_POLICY_MASK                0x0000FFFF
#define POLICY_IGNORE_NON_CRITICAL_BC       0x00000001

#define CRYPTDLG_ACTION_MASK                0xFFFF0000
#define ACTION_REVOCATION_DEFAULT_ONLINE    0x00010000
#define ACTION_REVOCATION_DEFAULT_CACHE     0x00020000

//
//  Many of the common dialogs can be passed a filter proc to reduce
//      the set of certificates displayed.  A generic filter proc has been
//      provided to cover many of the generic cases.
//  Return TRUE to display and FALSE to hide

typedef BOOL (WINAPI * PFNCMFILTERPROC)(
        IN PCCERT_CONTEXT pCertContext,
        IN LPARAM,  // lCustData, a cookie
        IN DWORD,   // dwFlags
        IN DWORD);  // dwDisplayWell

//  Display Well Values
#define CERT_DISPWELL_SELECT                    1
#define CERT_DISPWELL_TRUST_CA_CERT             2
#define CERT_DISPWELL_TRUST_LEAF_CERT           3
#define CERT_DISPWELL_TRUST_ADD_CA_CERT         4
#define CERT_DISPWELL_TRUST_ADD_LEAF_CERT       5
#define CERT_DISPWELL_DISTRUST_CA_CERT          6
#define CERT_DISPWELL_DISTRUST_LEAF_CERT        7
#define CERT_DISPWELL_DISTRUST_ADD_CA_CERT      8
#define CERT_DISPWELL_DISTRUST_ADD_LEAF_CERT    9

//
typedef UINT (WINAPI * PFNCMHOOKPROC)(
        IN HWND hwndDialog,
        IN UINT message,
        IN WPARAM wParam,
        IN LPARAM lParam);

//
#define CSS_SELECTCERT_MASK             0x00ffffff
#define CSS_HIDE_PROPERTIES             0x00000001
#define CSS_ENABLEHOOK                  0x00000002
#define CSS_ALLOWMULTISELECT            0x00000004
#define CSS_SHOW_HELP                   0x00000010
#define CSS_ENABLETEMPLATE              0x00000020
#define CSS_ENABLETEMPLATEHANDLE        0x00000040

#define SELCERT_OK                      IDOK
#define SELCERT_CANCEL                  IDCANCEL
#define SELCERT_PROPERTIES              100
#define SELCERT_FINEPRINT               101
#define SELCERT_CERTLIST                102
#define SELCERT_HELP                    IDHELP
#define SELCERT_ISSUED_TO               103
#define SELCERT_VALIDITY                104
#define SELCERT_ALGORITHM               105
#define SELCERT_SERIAL_NUM              106
#define SELCERT_THUMBPRINT              107

typedef struct tagCSSA {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCSTR              pTemplateName;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    LPARAM              lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_STRUCT_A, *PCERT_SELECT_STRUCT_A;

typedef struct tagCSSW {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCWSTR             pTemplateName;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    LPARAM              lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_STRUCT_W, *PCERT_SELECT_STRUCT_W;

#ifdef UNICODE
typedef CERT_SELECT_STRUCT_W CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_W PCERT_SELECT_STRUCT;
#else
typedef CERT_SELECT_STRUCT_A CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_A PCERT_SELECT_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateA(
        IN OUT PCERT_SELECT_STRUCT_A pCertSelectInfo
        );
#ifdef MAC
#define CertSelectCertificate CertSelectCertificateA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateW(
        IN OUT PCERT_SELECT_STRUCT_W pCertSelectInfo
        );
#ifdef UNICODE
#define CertSelectCertificate CertSelectCertificateW
#else
#define CertSelectCertificate CertSelectCertificateA
#endif
#endif  // MAC

/////////////////////////////////////////////////////////////

#define CM_VIEWFLAGS_MASK       0x00ffffff
#define CM_ENABLEHOOK           0x00000001
#define CM_SHOW_HELP            0x00000002
#define CM_SHOW_HELPICON        0x00000004
#define CM_ENABLETEMPLATE       0x00000008
#define CM_HIDE_ADVANCEPAGE     0x00000010
#define CM_HIDE_TRUSTPAGE       0x00000020
#define CM_NO_NAMECHANGE        0x00000040
#define CM_NO_EDITTRUST         0x00000080
#define CM_HIDE_DETAILPAGE      0x00000100
#define CM_ADD_CERT_STORES      0x00000200
#define CERTVIEW_CRYPTUI_LPARAM 0x00800000

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    LPARAM              lCustData;
    DWORD               dwPad;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_A, *PCERT_VIEWPROPERTIES_STRUCT_A;

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_W {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    LPARAM              lCustData;
    DWORD               dwPad;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_W, *PCERT_VIEWPROPERTIES_STRUCT_W;

#ifdef UNICODE
typedef CERT_VIEWPROPERTIES_STRUCT_W CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_W PCERT_VIEWPROPERTIES_STRUCT;
#else
typedef CERT_VIEWPROPERTIES_STRUCT_A CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_A PCERT_VIEWPROPERTIES_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesA(
        PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo
        );
#ifdef MAC
#define CertViewProperties CertViewPropertiesA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesW(
        PCERT_VIEWPROPERTIES_STRUCT_W pCertViewInfo
        );

#ifdef UNICODE
#define CertViewProperties CertViewPropertiesW
#else
#define CertViewProperties CertViewPropertiesA
#endif
#endif  // MAC


//
//  We provide a default filter function that people can use to do some
//      of the most simple things.
//

#define CERT_FILTER_OP_EXISTS           1
#define CERT_FILTER_OP_NOT_EXISTS       2
#define CERT_FILTER_OP_EQUALITY         3

typedef struct tagCMOID {
    LPCSTR              szExtensionOID;         // Extension to filter on
    DWORD               dwTestOperation;
    LPBYTE              pbTestData;
    DWORD               cbTestData;
} CERT_FILTER_EXTENSION_MATCH;

#define CERT_FILTER_INCLUDE_V1_CERTS    0x0001
#define CERT_FILTER_VALID_TIME_RANGE    0x0002
#define CERT_FILTER_VALID_SIGNATURE     0x0004
#define CERT_FILTER_LEAF_CERTS_ONLY     0x0008
#define CERT_FILTER_ISSUER_CERTS_ONLY   0x0010
#define CERT_FILTER_KEY_EXISTS          0x0020

typedef struct tagCMFLTR {
    DWORD               dwSize;
    DWORD               cExtensionChecks;
    CERT_FILTER_EXTENSION_MATCH * arrayExtensionChecks;
    DWORD               dwCheckingFlags;
} CERT_FILTER_DATA;

//
//  Maybe this should not be here -- but until it goes into wincrypt.h
//

//
//   Get a formatted friendly name for a certificate

CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertA(
    __in PCCERT_CONTEXT pccert,
    __out_ecount_part_opt(cch, return) LPSTR pch,
    __in DWORD cch
    );
CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertW(
    __in PCCERT_CONTEXT pccert,
    __out_ecount_part_opt(cwch, return) LPWSTR pwch,
    __in DWORD cwch
    );

#ifdef UNICODE
#define GetFriendlyNameOfCert GetFriendlyNameOfCertW
#else
#define GetFriendlyNameOfCert GetFriendlyNameOfCertA
#endif


//
//  We also provide a WinTrust provider which performs the same set of
//      parameter checking that we do in order to validate certificates.
//

#define CERT_CERTIFICATE_ACTION_VERIFY  \
  { /* 7801ebd0-cf4b-11d0-851f-0060979387ea */  \
    0x7801ebd0, \
    0xcf4b,     \
    0x11d0,     \
    {0x85, 0x1f, 0x00, 0x60, 0x97, 0x93, 0x87, 0xea} \
  }
#define szCERT_CERTIFICATE_ACTION_VERIFY    \
    "{7801ebd0-cf4b-11d0-851f-0060979387ea}"  

typedef HRESULT (WINAPI * PFNTRUSTHELPER)(
        IN PCCERT_CONTEXT       pCertContext,
        IN LPARAM               lCustData,
        IN BOOL                 fLeafCertificate,
        IN LPBYTE               pbTrustBlob);
//
//  Failure Reasons:
//

#define CERT_VALIDITY_BEFORE_START              0x00000001
#define CERT_VALIDITY_AFTER_END                 0x00000002
#define CERT_VALIDITY_SIGNATURE_FAILS           0x00000004
#define CERT_VALIDITY_CERTIFICATE_REVOKED       0x00000008
#define CERT_VALIDITY_KEY_USAGE_EXT_FAILURE     0x00000010
#define CERT_VALIDITY_EXTENDED_USAGE_FAILURE    0x00000020
#define CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE  0x00000040
#define CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION 0x00000080
#define CERT_VALIDITY_ISSUER_INVALID            0x00000100
#define CERT_VALIDITY_OTHER_EXTENSION_FAILURE   0x00000200
#define CERT_VALIDITY_PERIOD_NESTING_FAILURE    0x00000400
#define CERT_VALIDITY_OTHER_ERROR               0x00000800
#define CERT_VALIDITY_ISSUER_DISTRUST           0x02000000
#define CERT_VALIDITY_EXPLICITLY_DISTRUSTED     0x01000000
#define CERT_VALIDITY_NO_ISSUER_CERT_FOUND      0x10000000
#define CERT_VALIDITY_NO_CRL_FOUND              0x20000000
#define CERT_VALIDITY_CRL_OUT_OF_DATE           0x40000000
#define CERT_VALIDITY_NO_TRUST_DATA             0x80000000
#define CERT_VALIDITY_MASK_TRUST                0xffff0000
#define CERT_VALIDITY_MASK_VALIDITY             0x0000ffff

#define CERT_TRUST_MASK                         0x00ffffff
#define CERT_TRUST_DO_FULL_SEARCH               0x00000001
#define CERT_TRUST_PERMIT_MISSING_CRLS          0x00000002
#define CERT_TRUST_DO_FULL_TRUST                0x00000005
#define CERT_TRUST_ADD_CERT_STORES              CM_ADD_CERT_STORES

//
//  Trust data structure
//
//      Returned data arrays will be allocated using LocalAlloc and must
//      be freed by the caller.  The data in the TrustInfo array are individually
//      allocated and must be freed.  The data in rgChain must be freed by
//      calling CertFreeCertificateContext.
//
//  Defaults:
//      pszUsageOid == NULL     indicates that no trust validation should be done
//      cRootStores == 0        Will default to User's Root store
//      cStores == 0            Will default to User's CA and system's SPC stores
//      cTrustStores == 0       Will default to User's TRUST store
//      hprov == NULL           Will default to RSABase
//      any returned item which has a null pointer will not return that item.
//  Notes:
//      pfnTrustHelper is nyi

typedef struct _CERT_VERIFY_CERTIFICATE_TRUST {
    DWORD               cbSize;         // Size of this structure
    PCCERT_CONTEXT      pccert;         // Certificate to be verified
    DWORD               dwFlags;        // CERT_TRUST_*
    DWORD               dwIgnoreErr;    // Errors to ignore (CERT_VALIDITY_*)
    DWORD *             pdwErrors;      // Location to return error flags
    LPSTR               pszUsageOid;    // Extended Usage OID for Certificate
    HCRYPTPROV          hprov;          // Crypt Provider to use for validation
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    LPARAM              lCustData;      //
    PFNTRUSTHELPER      pfnTrustHelper; // Callback function for cert validation
    DWORD *             pcChain;        // Count of items in the chain array
    PCCERT_CONTEXT **   prgChain;       // Chain of certificates used
    DWORD **            prgdwErrors;    // Errors on a per certificate basis
    DATA_BLOB **        prgpbTrustInfo; // Array of trust information used
} CERT_VERIFY_CERTIFICATE_TRUST, * PCERT_VERIFY_CERTIFICATE_TRUST;

//
//  Trust list manipulation routine
//
//  CertModifyCertificatesToTrust can be used to do modifications to the set of certificates
//      on trust lists for a given purpose.
//      if hcertstoreTrust is NULL, the System Store TRUST in Current User will be used
//      if pccertSigner is specified, it will be used to sign the resulting trust lists,
//              it also restricts the set of trust lists that may be modified.
//

#define CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED      1
#define CTL_MODIFY_REQUEST_REMOVE               2
#define CTL_MODIFY_REQUEST_ADD_TRUSTED          3

typedef struct _CTL_MODIFY_REQUEST {
    PCCERT_CONTEXT      pccert;         // Certificate to change trust on
    DWORD               dwOperation;    // Operation to be performed
    DWORD               dwError;        // Operation error code
} CTL_MODIFY_REQUEST, * PCTL_MODIFY_REQUEST;

CRYPTDLGAPI
HRESULT
WINAPI
CertModifyCertificatesToTrust(
        int cCerts,                     // Count of modifications to be done
        PCTL_MODIFY_REQUEST rgCerts,    // Array of modification requests
        LPCSTR szPurpose,               // Purpose OID to for modifications
        HWND hwnd,                      // HWND for any dialogs
        HCERTSTORE hcertstoreTrust,     // Cert Store to store trust information in
        PCCERT_CONTEXT pccertSigner);   // Certificate to be used in signing trust list

#ifdef WIN16
// Need to define export functions in WATCOM.
BOOL
WINAPI CertConfigureTrustA(void);

BOOL
WINAPI FormatVerisignExtension(
    DWORD /*dwCertEncodingType*/,
    DWORD /*dwFormatType*/,
    DWORD /*dwFormatStrType*/,
    void * /*pFormatStruct*/,
    LPCSTR /*lpszStructType*/,
    const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/,
    void * pbFormat,
    DWORD * pcbFormat);
#endif // !WIN16

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // (_WIN32_WINNT >= 0x0400)

#endif // _CRYPTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cs.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    cs.h

Abstract:

    Windows CE Camera Driver Model/Connection and Streaming Architecture core definitions.

--*/

#if !defined(_CS_)
#define _CS_


#if defined(__TCS__)
#define _CS_NO_ANONYMOUS_STRUCTURES_ 1
#endif

#if !defined(_NTRTL_)
    #ifndef DEFINE_GUIDEX
        #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
    #endif // !defined(DEFINE_GUIDEX)

    #ifndef STATICGUIDOF
        #define STATICGUIDOF(guid) STATIC_##guid
    #endif // !defined(STATICGUIDOF)
#endif // !defined(_NTRTL_)

#ifndef SIZEOF_ARRAY
// Prefer to use _countof() directly, replacing SIZEOF_ARRAY()
#pragma deprecated("SIZEOF_ARRAY")
#define SIZEOF_ARRAY(x) _countof(x)
#endif

#if defined(__cplusplus) && _MSC_VER >= 1100
#define DEFINE_GUIDSTRUCT(g, n) struct __declspec(uuid(g)) n
#define DEFINE_GUIDNAMED(n) __uuidof(struct n)
#else // !defined(__cplusplus)
#define DEFINE_GUIDSTRUCT(g, n) DEFINE_GUIDEX(n)
#define DEFINE_GUIDNAMED(n) n
#endif // !defined(__cplusplus)

//===========================================================================

#define STATIC_GUID_NULL \
    0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

DEFINE_GUIDSTRUCT("00000000-0000-0000-0000-000000000000", GUID_NULL);
#define GUID_NULL DEFINE_GUIDNAMED(GUID_NULL)

//===========================================================================

#define IOCTL_CS_PROPERTY               CTL_CODE(FILE_DEVICE_KS, 0x000, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_CS_READ_STREAM            CTL_CODE(FILE_DEVICE_KS, 0x005, METHOD_NEITHER, FILE_READ_ACCESS)
#define IOCTL_CS_BUFFERS                CTL_CODE(FILE_DEVICE_KS, 0x007, METHOD_NEITHER, FILE_READ_ACCESS)

#ifndef UNDER_CE
#define IOCTL_CS_ENABLE_EVENT           CTL_CODE(FILE_DEVICE_KS, 0x001, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_CS_DISABLE_EVENT          CTL_CODE(FILE_DEVICE_KS, 0x002, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_CS_METHOD                 CTL_CODE(FILE_DEVICE_KS, 0x003, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_CS_WRITE_STREAM           CTL_CODE(FILE_DEVICE_KS, 0x004, METHOD_NEITHER, FILE_WRITE_ACCESS)
#define IOCTL_CS_RESET_STATE            CTL_CODE(FILE_DEVICE_KS, 0x006, METHOD_NEITHER, FILE_ANY_ACCESS)
#endif //#ifndef UNDER_CE





//===========================================================================
#ifndef UNDER_CE
typedef enum {
    CSRESET_BEGIN,
    CSRESET_END
} CSRESET;
#endif //#ifndef UNDER_CE

typedef enum {
    CSSTATE_STOP,
#ifndef UNDER_CE
    CSSTATE_ACQUIRE,
#endif //#ifndef UNDER_CE
    CSSTATE_PAUSE,
    CSSTATE_RUN
} CSSTATE, *PCSSTATE;

#ifndef UNDER_CE
#define CSPRIORITY_LOW        0x00000001
#define CSPRIORITY_NORMAL     0x40000000
#define CSPRIORITY_HIGH       0x80000000
#define CSPRIORITY_EXCLUSIVE  0xFFFFFFFF

typedef struct {
    ULONG   PriorityClass;
    ULONG   PrioritySubClass;
} CSPRIORITY, *PCSPRIORITY;

#endif //#ifndef UNDER_CE
typedef struct {
    union {
#if defined( _CS_NO_ANONYMOUS_STRUCTURES_ )
        struct _IDENTIFIER {
#else        
        struct {
#endif        
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        };
        LONGLONG    Alignment;
    };
} CSIDENTIFIER, *PCSIDENTIFIER;

typedef CSIDENTIFIER CSPROPERTY, *PCSPROPERTY, CSMETHOD, *PCSMETHOD, CSEVENT, *PCSEVENT;

#ifndef UNDER_CE
#define CSMETHOD_TYPE_NONE                  0x00000000
#define CSMETHOD_TYPE_READ                  0x00000001
#define CSMETHOD_TYPE_WRITE                 0x00000002
#define CSMETHOD_TYPE_MODIFY                0x00000003
#define CSMETHOD_TYPE_SOURCE                0x00000004

#define CSMETHOD_TYPE_SEND                  0x00000001
#define CSMETHOD_TYPE_SETSUPPORT            0x00000100
#define CSMETHOD_TYPE_BASICSUPPORT          0x00000200

#define CSMETHOD_TYPE_TOPOLOGY 0x10000000
#endif //#ifndef UNDER_CE

#define CSPROPERTY_TYPE_GET                 0x00000001
#define CSPROPERTY_TYPE_SET                 0x00000002
#define CSPROPERTY_TYPE_SETSUPPORT          0x00000100
#define CSPROPERTY_TYPE_BASICSUPPORT        0x00000200

#ifndef UNDER_CE
#define CSPROPERTY_TYPE_RELATIONS           0x00000400
#define CSPROPERTY_TYPE_SERIALIZESET        0x00000800
#define CSPROPERTY_TYPE_UNSERIALIZESET      0x00001000
#define CSPROPERTY_TYPE_SERIALIZERAW        0x00002000
#define CSPROPERTY_TYPE_UNSERIALIZERAW      0x00004000
#define CSPROPERTY_TYPE_SERIALIZESIZE       0x00008000
#endif //#ifndef UNDER_CE

#define CSPROPERTY_TYPE_DEFAULTVALUES       0x00010000

#ifndef UNDER_CE
#define CSPROPERTY_TYPE_TOPOLOGY 0x10000000

typedef struct {
    CSPROPERTY      Property;
    ULONG           NodeId;
    ULONG           Reserved;
} CSP_NODE, *PCSP_NODE;


typedef struct {
    CSMETHOD        Method;
    ULONG           NodeId;
    ULONG           Reserved;
} CSM_NODE, *PCSM_NODE;

typedef struct {
    CSEVENT         Event;
    ULONG           NodeId;
    ULONG           Reserved;
} CSE_NODE, *PCSE_NODE;

#endif //#ifndef UNDER_CE

#define STATIC_CSPROPTYPESETID_General \
    0x97E99BA0L, 0xBDEA, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("97E99BA0-BDEA-11CF-A5D6-28DB04C10000", CSPROPTYPESETID_General);
#define CSPROPTYPESETID_General DEFINE_GUIDNAMED(CSPROPTYPESETID_General)

#if defined(_NTDDK_) && !defined(__wtypes_h__)
enum VARENUM {
    VT_EMPTY = 0,
    VT_NULL = 1,
    VT_I2 = 2,
    VT_I4 = 3,
    VT_R4 = 4,
    VT_R8 = 5,
    VT_CY = 6,
    VT_DATE = 7,
    VT_BSTR = 8,
    VT_DISPATCH = 9,
    VT_ERROR = 10,
    VT_BOOL = 11,
    VT_VARIANT = 12,
    VT_UNKNOWN = 13,
    VT_DECIMAL = 14,
    VT_I1 = 16,
    VT_UI1 = 17,
    VT_UI2 = 18,
    VT_UI4 = 19,
    VT_I8 = 20,
    VT_UI8 = 21,
    VT_INT = 22,
    VT_UINT = 23,
    VT_VOID = 24,
    VT_HRESULT  = 25,
    VT_PTR = 26,
    VT_SAFEARRAY = 27,
    VT_CARRAY = 28,
    VT_USERDEFINED = 29,
    VT_LPSTR = 30,
    VT_LPWSTR = 31,
    VT_FILETIME = 64,
    VT_BLOB = 65,
    VT_STREAM = 66,
    VT_STORAGE = 67,
    VT_STREAMED_OBJECT = 68,
    VT_STORED_OBJECT = 69,
    VT_BLOB_OBJECT = 70,
    VT_CF = 71,
    VT_CLSID = 72,
    VT_VECTOR = 0x1000,
    VT_ARRAY = 0x2000,
    VT_BYREF = 0x4000,
    VT_RESERVED = 0x8000,
    VT_ILLEGAL = 0xffff,
    VT_ILLEGALMASKED = 0xfff,
    VT_TYPEMASK = 0xfff
};
#endif // _NTDDK_ && !__wtypes_h__

typedef struct {
    ULONG    Size;
    ULONG    Count;
} CSMULTIPLE_ITEM, *PCSMULTIPLE_ITEM;

typedef struct {
    ULONG           AccessFlags;
    ULONG           DescriptionSize;
    CSIDENTIFIER    PropTypeSet;
    ULONG           MembersListCount;
    ULONG           Reserved;
} CSPROPERTY_DESCRIPTION, *PCSPROPERTY_DESCRIPTION;

#define CSPROPERTY_MEMBER_RANGES            0x00000001
#define CSPROPERTY_MEMBER_STEPPEDRANGES     0x00000002
#define CSPROPERTY_MEMBER_VALUES            0x00000003

#define CSPROPERTY_MEMBER_FLAG_DEFAULT                      0x00000001
#define CSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL    0x00000002
#define CSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM         0x00000004

typedef struct {
    ULONG   MembersFlags;
    ULONG   MembersSize;
    ULONG   MembersCount;
    ULONG   Flags;
} CSPROPERTY_MEMBERSHEADER, *PCSPROPERTY_MEMBERSHEADER;

typedef union {
#if defined( _CS_NO_ANONYMOUS_STRUCTURES_ )
    struct _SIGNED {
#else
    struct {
#endif    
        LONG    SignedMinimum;
        LONG    SignedMaximum;
    };
#if defined( _CS_NO_ANONYMOUS_STRUCTURES_ )
    struct _UNSIGNED {
#else
    struct {
#endif    
        ULONG   UnsignedMinimum;
        ULONG   UnsignedMaximum;
    };
} CSPROPERTY_BOUNDS_LONG, *PCSPROPERTY_BOUNDS_LONG;

typedef union {
#if defined( _CS_NO_ANONYMOUS_STRUCTURES_ )
    struct _SIGNED64 {
#else
    struct {
#endif    
        LONGLONG    SignedMinimum;
        LONGLONG    SignedMaximum;
    };
#if defined( _CS_NO_ANONYMOUS_STRUCTURES_ )
    struct _UNSIGNED64 {
#else
    struct {
#endif    
#if defined(_NTDDK_)
        ULONGLONG   UnsignedMinimum;
        ULONGLONG   UnsignedMaximum;
#else // !_NTDDK_
        DWORDLONG   UnsignedMinimum;
        DWORDLONG   UnsignedMaximum;
#endif // !_NTDDK_
    };
} CSPROPERTY_BOUNDS_LONGLONG, *PCSPROPERTY_BOUNDS_LONGLONG;

typedef struct {
    ULONG                       SteppingDelta;
    ULONG                       Reserved;
    CSPROPERTY_BOUNDS_LONG      Bounds;
} CSPROPERTY_STEPPING_LONG, *PCSPROPERTY_STEPPING_LONG;

typedef struct {
#if defined(_NTDDK_)
    ULONGLONG                   SteppingDelta;
#else // !_NTDDK_
    DWORDLONG                   SteppingDelta;
#endif // !_NTDDK_
    CSPROPERTY_BOUNDS_LONGLONG  Bounds;
} CSPROPERTY_STEPPING_LONGLONG, *PCSPROPERTY_STEPPING_LONGLONG;

//===========================================================================
#ifndef UNDER_CE
#if defined(_NTDDK_)
//
// Structure forward declarations.
//
typedef struct _CSDEVICE_DESCRIPTOR
CSDEVICE_DESCRIPTOR, *PCSDEVICE_DESCRIPTOR;
typedef struct _CSDEVICE_DISPATCH
CSDEVICE_DISPATCH, *PCSDEVICE_DISPATCH;
typedef struct _CSDEVICE 
CSDEVICE, *PCSDEVICE;
typedef struct _CSFILTERFACTORY 
CSFILTERFACTORY, *PCSFILTERFACTORY;
typedef struct _CSFILTER_DESCRIPTOR
CSFILTER_DESCRIPTOR, *PCSFILTER_DESCRIPTOR;
typedef struct _CSFILTER_DISPATCH
CSFILTER_DISPATCH, *PCSFILTER_DISPATCH;
typedef struct _CSFILTER 
CSFILTER, *PCSFILTER;
typedef struct _CSPIN_DESCRIPTOR_EX
CSPIN_DESCRIPTOR_EX, *PCSPIN_DESCRIPTOR_EX;
typedef struct _CSPIN_DISPATCH
CSPIN_DISPATCH, *PCSPIN_DISPATCH;
typedef struct _CSCLOCK_DISPATCH
CSCLOCK_DISPATCH, *PCSCLOCK_DISPATCH;
typedef struct _CSALLOCATOR_DISPATCH
CSALLOCATOR_DISPATCH, *PCSALLOCATOR_DISPATCH;
typedef struct _CSPIN 
CSPIN, *PCSPIN;
typedef struct _CSNODE_DESCRIPTOR
CSNODE_DESCRIPTOR, *PCSNODE_DESCRIPTOR;
typedef struct _CSSTREAM_POINTER_OFFSET
CSSTREAM_POINTER_OFFSET, *PCSSTREAM_POINTER_OFFSET;
typedef struct _CSSTREAM_POINTER
CSSTREAM_POINTER, *PCSSTREAM_POINTER;
typedef struct _CSMAPPING
CSMAPPING, *PCSMAPPING;
typedef struct _CSPROCESSPIN
CSPROCESSPIN, *PCSPROCESSPIN;
typedef struct _CSPROCESSPIN_INDEXENTRY
CSPROCESSPIN_INDEXENTRY, *PCSPROCESSPIN_INDEXENTRY;
#endif // _NTDDK_

typedef PVOID PCSWORKER;

typedef struct {
    ULONG       NotificationType;
    union {
        struct {
            HANDLE              Event;
            ULONG_PTR           Reserved[2];
        } EventHandle;
        struct {
            HANDLE              Semaphore;
            ULONG               Reserved;
            LONG                Adjustment;
        } SemaphoreHandle;
#if defined(_NTDDK_)
        struct {
            PVOID               Event;
            KPRIORITY           Increment;
            ULONG_PTR           Reserved;
        } EventObject;
        struct {
            PVOID               Semaphore;
            KPRIORITY           Increment;
            LONG                Adjustment;
        } SemaphoreObject;
        struct {
            PKDPC               Dpc;
            ULONG               ReferenceCount;
            ULONG_PTR           Reserved;
        } Dpc;
        struct {
            PWORK_QUEUE_ITEM    WorkQueueItem;
            WORK_QUEUE_TYPE     WorkQueueType;
            ULONG_PTR           Reserved;
        } WorkItem;
        struct {
            PWORK_QUEUE_ITEM    WorkQueueItem;
            PCSWORKER           CsWorkerObject;
            ULONG_PTR           Reserved;
        } CsWorkItem;
// @@BEGIN_DDCSPLIT
        struct {
            PCSFILTER           Filter;
            ULONG_PTR           Reserved[2];
        } CsFilterProcessing;
        struct {
            PCSPIN              Pin;
            ULONG_PTR           Reserved[2];
        } CsPinProcessing;
// @@END_DDCSPLIT
#endif // defined(_NTDDK_)
        struct {
            PVOID               Unused;
            LONG_PTR            Alignment[2];
        } Alignment;
    };
} CSEVENTDATA, *PCSEVENTDATA;


#define CSEVENTF_EVENT_HANDLE       0x00000001
#define CSEVENTF_SEMAPHORE_HANDLE   0x00000002
#if defined(_NTDDK_)
#define CSEVENTF_EVENT_OBJECT       0x00000004
#define CSEVENTF_SEMAPHORE_OBJECT   0x00000008
#define CSEVENTF_DPC                0x00000010
#define CSEVENTF_WORKITEM           0x00000020
#define CSEVENTF_CSWORKITEM         0x00000080
// @@BEGIN_DDCSPLIT
#define CSEVENTF_CSFILTERPROCESSING 0x00000100
#define CSEVENTF_CSPINPROCESSING    0x00000200
// @@END_DDCSPLIT
#endif // defined(_NTDDK_)

#define CSEVENT_TYPE_ENABLE         0x00000001
#define CSEVENT_TYPE_ONESHOT        0x00000002
#define CSEVENT_TYPE_ENABLEBUFFERED 0x00000004
#define CSEVENT_TYPE_SETSUPPORT     0x00000100
#define CSEVENT_TYPE_BASICSUPPORT   0x00000200
#define CSEVENT_TYPE_QUERYBUFFER    0x00000400

#define CSEVENT_TYPE_TOPOLOGY 0x10000000

typedef struct {
    CSEVENT         Event;
    PCSEVENTDATA    EventData;
    PVOID           Reserved;
} CSQUERYBUFFER, *PCSQUERYBUFFER;

typedef struct {
    ULONG Size;
    ULONG Flags;
    union {
        HANDLE ObjectHandle;
        PVOID ObjectPointer;
    };
    PVOID Reserved;
    CSEVENT Event;
    CSEVENTDATA EventData;
} CSRELATIVEEVENT;

#define CSRELATIVEEVENT_FLAG_HANDLE 0x00000001
#define CSRELATIVEEVENT_FLAG_POINTER 0x00000002

//===========================================================================

typedef struct {
    CSEVENTDATA     EventData;
    LONGLONG        MarkTime;
} CSEVENT_TIME_MARK, *PCSEVENT_TIME_MARK;

typedef struct {
    CSEVENTDATA     EventData;
    LONGLONG        TimeBase;
    LONGLONG        Interval;
} CSEVENT_TIME_INTERVAL, *PCSEVENT_TIME_INTERVAL;

typedef struct {
    LONGLONG        TimeBase;
    LONGLONG        Interval;
} CSINTERVAL, *PCSINTERVAL;

#endif //#ifndef UNDER_CE
//===========================================================================
                
#define STATIC_CSPROPSETID_General\
    0x1464EDA5L, 0x6A8F, 0x11D1, 0x9A, 0xA7, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("1464EDA5-6A8F-11D1-9AA7-00A0C9223196", CSPROPSETID_General);
#define CSPROPSETID_General DEFINE_GUIDNAMED(CSPROPSETID_General)

typedef enum {
    CSPROPERTY_GENERAL_COMPONENTID
} CSPROPERTY_GENERAL;

#ifndef UNDER_CE
typedef struct {
    GUID    Manufacturer;
    GUID    Product;
    GUID    Component;
    GUID    Name;
    ULONG   Version;
    ULONG   Revision;
} CSCOMPONENTID, *PCSCOMPONENTID;

#define DEFINE_CSPROPERTY_ITEM_GENERAL_COMPONENTID(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_GENERAL_COMPONENTID,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(CSCOMPONENTID),\
        NULL, NULL, 0, NULL, NULL, 0)

#define STATIC_CSMETHODSETID_StreamIo\
    0x65D003CAL, 0x1523, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65D003CA-1523-11D2-B27A-00A0C9223196", CSMETHODSETID_StreamIo);
#define CSMETHODSETID_StreamIo DEFINE_GUIDNAMED(CSMETHODSETID_StreamIo)

typedef enum {
    CSMETHOD_STREAMIO_READ,
    CSMETHOD_STREAMIO_WRITE
} CSMETHOD_STREAMIO;

#define DEFINE_CSMETHOD_ITEM_STREAMIO_READ(Handler)\
    DEFINE_CSMETHOD_ITEM(\
        CSMETHOD_STREAMIO_READ,\
        CSMETHOD_TYPE_WRITE,\
        (Handler),\
        sizeof(CSMETHOD),\
        0,\
        NULL)

#define DEFINE_CSMETHOD_ITEM_STREAMIO_WRITE(Handler)\
    DEFINE_CSMETHOD_ITEM(\
        CSMETHOD_STREAMIO_WRITE,\
        CSMETHOD_TYPE_READ,\
        (Handler),\
        sizeof(CSMETHOD),\
        0,\
        NULL)

#define STATIC_CSPROPSETID_MediaSeeking\
    0xEE904F0CL, 0xD09B, 0x11D0, 0xAB, 0xE9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("EE904F0C-D09B-11D0-ABE9-00A0C9223196", CSPROPSETID_MediaSeeking);
#define CSPROPSETID_MediaSeeking DEFINE_GUIDNAMED(CSPROPSETID_MediaSeeking)

typedef enum {
    CSPROPERTY_MEDIASEEKING_CAPABILITIES,
    CSPROPERTY_MEDIASEEKING_FORMATS,
    CSPROPERTY_MEDIASEEKING_TIMEFORMAT,
    CSPROPERTY_MEDIASEEKING_POSITION,
    CSPROPERTY_MEDIASEEKING_STOPPOSITION,
    CSPROPERTY_MEDIASEEKING_POSITIONS,
    CSPROPERTY_MEDIASEEKING_DURATION,
    CSPROPERTY_MEDIASEEKING_AVAILABLE,
    CSPROPERTY_MEDIASEEKING_PREROLL,
    CSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT
} CSPROPERTY_MEDIASEEKING;

typedef enum {
    CS_SEEKING_NoPositioning,
    CS_SEEKING_AbsolutePositioning,
    CS_SEEKING_RelativePositioning,
    CS_SEEKING_IncrementalPositioning,
    CS_SEEKING_PositioningBitsMask = 0x3,
    CS_SEEKING_SeekToKeyFrame,
    CS_SEEKING_ReturnTime = 0x8
} CS_SEEKING_FLAGS;

typedef enum {
    CS_SEEKING_CanSeekAbsolute = 0x1,
    CS_SEEKING_CanSeekForwards = 0x2,
    CS_SEEKING_CanSeekBackwards = 0x4,
    CS_SEEKING_CanGetCurrentPos = 0x8,
    CS_SEEKING_CanGetStopPos = 0x10,
    CS_SEEKING_CanGetDuration = 0x20,
    CS_SEEKING_CanPlayBackwards = 0x40
} CS_SEEKING_CAPABILITIES;

typedef struct {
    LONGLONG            Current;
    LONGLONG            Stop;
    CS_SEEKING_FLAGS    CurrentFlags;
    CS_SEEKING_FLAGS    StopFlags;
} CSPROPERTY_POSITIONS, *PCSPROPERTY_POSITIONS;

typedef struct {
    LONGLONG    Earliest;
    LONGLONG    Latest;
} CSPROPERTY_MEDIAAVAILABLE, *PCSPROPERTY_MEDIAAVAILABLE;

typedef struct {
    CSPROPERTY  Property;
    GUID        SourceFormat;
    GUID        TargetFormat;
    LONGLONG    Time;
} CSP_TIMEFORMAT, *PCSP_TIMEFORMAT;

#define DEFINE_CSPROPERTY_ITEM_MEDIASEEKING_CAPABILITIES(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_MEDIASEEKING_CAPABILITIES,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(CS_SEEKING_CAPABILITIES),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_MEDIASEEKING_FORMATS(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_MEDIASEEKING_FORMATS,\
        (Handler),\
        sizeof(CSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_MEDIASEEKING_TIMEFORMAT(GetHandler, SetHandler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_MEDIASEEKING_TIMEFORMAT,\
        (GetHandler),\
        sizeof(CSPROPERTY),\
        sizeof(GUID),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_MEDIASEEKING_POSITION(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_MEDIASEEKING_POSITION,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_MEDIASEEKING_STOPPOSITION(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_MEDIASEEKING_STOPPOSITION,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_MEDIASEEKING_POSITIONS(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_MEDIASEEKING_POSITIONS,\
        NULL,\
        sizeof(CSPROPERTY),\
        sizeof(CSPROPERTY_POSITIONS),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_MEDIASEEKING_DURATION(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_MEDIASEEKING_DURATION,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_MEDIASEEKING_AVAILABLE(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_MEDIASEEKING_AVAILABLE,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(CSPROPERTY_MEDIAAVAILABLE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_MEDIASEEKING_PREROLL(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_MEDIASEEKING_PREROLL,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_MEDIASEEKING_CONVERTTIMEFORMAT(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT,\
        (Handler),\
        sizeof(CSP_TIMEFORMAT),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

//===========================================================================

#define STATIC_CSPROPSETID_Topology\
    0x720D4AC0L, 0x7533, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("720D4AC0-7533-11D0-A5D6-28DB04C10000", CSPROPSETID_Topology);
#define CSPROPSETID_Topology DEFINE_GUIDNAMED(CSPROPSETID_Topology)

typedef enum {
    CSPROPERTY_TOPOLOGY_CATEGORIES,
    CSPROPERTY_TOPOLOGY_NODES,
    CSPROPERTY_TOPOLOGY_CONNECTIONS,
    CSPROPERTY_TOPOLOGY_NAME
} CSPROPERTY_TOPOLOGY;

#define DEFINE_CSPROPERTY_ITEM_TOPOLOGY_CATEGORIES(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_TOPOLOGY_CATEGORIES,\
        (Handler),\
        sizeof(CSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_TOPOLOGY_NODES(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_TOPOLOGY_NODES,\
        (Handler),\
        sizeof(CSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_TOPOLOGY_CONNECTIONS(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_TOPOLOGY_CONNECTIONS,\
        (Handler),\
        sizeof(CSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_TOPOLOGY_NAME(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_TOPOLOGY_NAME,\
        (Handler),\
        sizeof(CSP_NODE),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_TOPOLOGYSET(TopologySet, Handler)\
DEFINE_CSPROPERTY_TABLE(TopologySet) {\
    DEFINE_CSPROPERTY_ITEM_TOPOLOGY_CATEGORIES(Handler),\
    DEFINE_CSPROPERTY_ITEM_TOPOLOGY_NODES(Handler),\
    DEFINE_CSPROPERTY_ITEM_TOPOLOGY_CONNECTIONS(Handler),\
    DEFINE_CSPROPERTY_ITEM_TOPOLOGY_NAME(Handler)\
}

//=============================================================================

//
// properties used by graph manager to talk to particular filters
//
#if defined(_NTDDK_)

#define STATIC_CSPROPSETID_GM \
    0xAF627536L, 0xE719, 0x11D2, 0x8A, 0x1D, 0x00, 0x60, 0x97, 0xD2, 0xDF, 0x5D    
DEFINE_GUIDSTRUCT("AF627536-E719-11D2-8A1D-006097D2DF5D", CSPROPSETID_GM);
#define CSPROPSETID_GM DEFINE_GUIDNAMED(CSPROPSETID_GM)

typedef VOID (*PFNCSGRAPHMANAGER_NOTIFY)(IN PFILE_OBJECT GraphManager,
                                         IN ULONG EventId,
                                         IN PVOID Filter,
                                         IN PVOID Pin,
                                         IN PVOID Frame,
                                         IN ULONG Duration);

typedef struct CSGRAPHMANAGER_FUNCTIONTABLE {
    PFNCSGRAPHMANAGER_NOTIFY NotifyEvent;
} CSGRAPHMANAGER_FUNCTIONTABLE, PCSGRAPHMANAGER_FUNCTIONTABLE;

typedef struct _CSPROPERTY_GRAPHMANAGER_INTERFACE {
    PFILE_OBJECT                 GraphManager;
    CSGRAPHMANAGER_FUNCTIONTABLE FunctionTable;
} CSPROPERTY_GRAPHMANAGER_INTERFACE, *PCSPROPERTY_GRAPHMANAGER_INTERFACE;


//
// Commands
//
typedef enum {
    CSPROPERTY_GM_GRAPHMANAGER,    
    CSPROPERTY_GM_TIMESTAMP_CLOCK, 
    CSPROPERTY_GM_RATEMATCH,       
    CSPROPERTY_GM_RENDER_CLOCK,    
} CSPROPERTY_GM;

#endif

//===========================================================================


#define STATIC_CSCATEGORY_BRIDGE \
    0x085AFF00L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("085AFF00-62CE-11CF-A5D6-28DB04C10000", CSCATEGORY_BRIDGE);
#define CSCATEGORY_BRIDGE DEFINE_GUIDNAMED(CSCATEGORY_BRIDGE)

#define STATIC_CSCATEGORY_CAPTURE \
    0x65E8773DL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65E8773D-8F56-11D0-A3B9-00A0C9223196", CSCATEGORY_CAPTURE);
#define CSCATEGORY_CAPTURE DEFINE_GUIDNAMED(CSCATEGORY_CAPTURE)

#define STATIC_CSCATEGORY_RENDER \
    0x65E8773EL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65E8773E-8F56-11D0-A3B9-00A0C9223196", CSCATEGORY_RENDER);
#define CSCATEGORY_RENDER DEFINE_GUIDNAMED(CSCATEGORY_RENDER)

#define STATIC_CSCATEGORY_MIXER \
    0xAD809C00L, 0x7B88, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("AD809C00-7B88-11D0-A5D6-28DB04C10000", CSCATEGORY_MIXER);
#define CSCATEGORY_MIXER DEFINE_GUIDNAMED(CSCATEGORY_MIXER)

#define STATIC_CSCATEGORY_SPLITTER \
    0x0A4252A0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("0A4252A0-7E70-11D0-A5D6-28DB04C10000", CSCATEGORY_SPLITTER);
#define CSCATEGORY_SPLITTER DEFINE_GUIDNAMED(CSCATEGORY_SPLITTER)

#define STATIC_CSCATEGORY_DATACOMPRESSOR \
    0x1E84C900L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1E84C900-7E70-11D0-A5D6-28DB04C10000", CSCATEGORY_DATACOMPRESSOR);
#define CSCATEGORY_DATACOMPRESSOR DEFINE_GUIDNAMED(CSCATEGORY_DATACOMPRESSOR)

#define STATIC_CSCATEGORY_DATADECOMPRESSOR \
    0x2721AE20L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2721AE20-7E70-11D0-A5D6-28DB04C10000", CSCATEGORY_DATADECOMPRESSOR);
#define CSCATEGORY_DATADECOMPRESSOR DEFINE_GUIDNAMED(CSCATEGORY_DATADECOMPRESSOR)

#define STATIC_CSCATEGORY_DATATRANSFORM \
    0x2EB07EA0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2EB07EA0-7E70-11D0-A5D6-28DB04C10000", CSCATEGORY_DATATRANSFORM);
#define CSCATEGORY_DATATRANSFORM DEFINE_GUIDNAMED(CSCATEGORY_DATATRANSFORM)

#define STATIC_CSCATEGORY_COMMUNICATIONSTRANSFORM \
    0xCF1DDA2CL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("CF1DDA2C-9743-11D0-A3EE-00A0C9223196", CSCATEGORY_COMMUNICATIONSTRANSFORM);
#define CSCATEGORY_COMMUNICATIONSTRANSFORM DEFINE_GUIDNAMED(CSCATEGORY_COMMUNICATIONSTRANSFORM)

#define STATIC_CSCATEGORY_INTERFACETRANSFORM \
    0xCF1DDA2DL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("CF1DDA2D-9743-11D0-A3EE-00A0C9223196", CSCATEGORY_INTERFACETRANSFORM);
#define CSCATEGORY_INTERFACETRANSFORM DEFINE_GUIDNAMED(CSCATEGORY_INTERFACETRANSFORM)

#define STATIC_CSCATEGORY_MEDIUMTRANSFORM \
    0xCF1DDA2EL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("CF1DDA2E-9743-11D0-A3EE-00A0C9223196", CSCATEGORY_MEDIUMTRANSFORM);
#define CSCATEGORY_MEDIUMTRANSFORM DEFINE_GUIDNAMED(CSCATEGORY_MEDIUMTRANSFORM)

#define STATIC_CSCATEGORY_FILESYSTEM \
    0x760FED5EL, 0x9357, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("760FED5E-9357-11D0-A3CC-00A0C9223196", CSCATEGORY_FILESYSTEM);
#define CSCATEGORY_FILESYSTEM DEFINE_GUIDNAMED(CSCATEGORY_FILESYSTEM)

// CSNAME_Clock
#define STATIC_CSCATEGORY_CLOCK \
    0x53172480L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("53172480-4791-11D0-A5D6-28DB04C10000", CSCATEGORY_CLOCK);
#define CSCATEGORY_CLOCK DEFINE_GUIDNAMED(CSCATEGORY_CLOCK)

#define STATIC_CSCATEGORY_PROXY \
    0x97EBAACAL, 0x95BD, 0x11D0, 0xA3, 0xEA, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("97EBAACA-95BD-11D0-A3EA-00A0C9223196", CSCATEGORY_PROXY);
#define CSCATEGORY_PROXY DEFINE_GUIDNAMED(CSCATEGORY_PROXY)

#define STATIC_CSCATEGORY_QUALITY \
    0x97EBAACBL, 0x95BD, 0x11D0, 0xA3, 0xEA, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("97EBAACB-95BD-11D0-A3EA-00A0C9223196", CSCATEGORY_QUALITY);
#define CSCATEGORY_QUALITY DEFINE_GUIDNAMED(CSCATEGORY_QUALITY)

typedef struct {
    ULONG   FromNode;
    ULONG   FromNodePin;
    ULONG   ToNode;
    ULONG   ToNodePin;
} CSTOPOLOGY_CONNECTION, *PCSTOPOLOGY_CONNECTION;

typedef struct {
    ULONG                           CategoriesCount;
    const GUID*                     Categories;
    ULONG                           TopologyNodesCount;
    const GUID*                     TopologyNodes;
    ULONG                           TopologyConnectionsCount;
    const CSTOPOLOGY_CONNECTION*    TopologyConnections;
    const GUID*                     TopologyNodesNames;
    ULONG                           Reserved;
} CSTOPOLOGY, *PCSTOPOLOGY;

#define CSFILTER_NODE   ((ULONG)-1)
#define CSALL_NODES     ((ULONG)-1)

typedef struct {
    ULONG       CreateFlags;
    ULONG       Node;
} CSNODE_CREATE, *PCSNODE_CREATE;

//===========================================================================

// TIME_FORMAT_NONE
#define STATIC_CSTIME_FORMAT_NONE       STATIC_GUID_NULL
#define CSTIME_FORMAT_NONE              GUID_NULL

// TIME_FORMAT_FRAME
#define STATIC_CSTIME_FORMAT_FRAME\
    0x7b785570L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785570-8c82-11cf-bc0c-00aa00ac74f6", CSTIME_FORMAT_FRAME);
#define CSTIME_FORMAT_FRAME DEFINE_GUIDNAMED(CSTIME_FORMAT_FRAME)

// TIME_FORMAT_BYTE             
#define STATIC_CSTIME_FORMAT_BYTE\
    0x7b785571L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785571-8c82-11cf-bc0c-00aa00ac74f6", CSTIME_FORMAT_BYTE);
#define CSTIME_FORMAT_BYTE DEFINE_GUIDNAMED(CSTIME_FORMAT_BYTE)

// TIME_FORMAT_SAMPLE
#define STATIC_CSTIME_FORMAT_SAMPLE\
    0x7b785572L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785572-8c82-11cf-bc0c-00aa00ac74f6", CSTIME_FORMAT_SAMPLE);
#define CSTIME_FORMAT_SAMPLE DEFINE_GUIDNAMED(CSTIME_FORMAT_SAMPLE)

// TIME_FORMAT_FIELD
#define STATIC_CSTIME_FORMAT_FIELD\
    0x7b785573L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785573-8c82-11cf-bc0c-00aa00ac74f6", CSTIME_FORMAT_FIELD);
#define CSTIME_FORMAT_FIELD DEFINE_GUIDNAMED(CSTIME_FORMAT_FIELD)

// TIME_FORMAT_MEDIA_TIME
#define STATIC_CSTIME_FORMAT_MEDIA_TIME\
    0x7b785574L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785574-8c82-11cf-bc0c-00aa00ac74f6", CSTIME_FORMAT_MEDIA_TIME);
#define CSTIME_FORMAT_MEDIA_TIME DEFINE_GUIDNAMED(CSTIME_FORMAT_MEDIA_TIME)


//===========================================================================

typedef CSIDENTIFIER CSPIN_INTERFACE, *PCSPIN_INTERFACE;

#define STATIC_CSINTERFACESETID_Standard \
    0x1A8766A0L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1A8766A0-62CE-11CF-A5D6-28DB04C10000", CSINTERFACESETID_Standard);
#define CSINTERFACESETID_Standard DEFINE_GUIDNAMED(CSINTERFACESETID_Standard)

typedef enum {
    CSINTERFACE_STANDARD_STREAMING,
    CSINTERFACE_STANDARD_LOOPED_STREAMING,
    CSINTERFACE_STANDARD_CONTROL
} CSINTERFACE_STANDARD;

#define STATIC_CSINTERFACESETID_FileIo \
    0x8C6F932CL, 0xE771, 0x11D0, 0xB8, 0xFF, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("8C6F932C-E771-11D0-B8FF-00A0C9223196", CSINTERFACESETID_FileIo);
#define CSINTERFACESETID_FileIo DEFINE_GUIDNAMED(CSINTERFACESETID_FileIo)

typedef enum {
    CSINTERFACE_FILEIO_STREAMING
} CSINTERFACE_FILEIO;

//===========================================================================

#define CSMEDIUM_TYPE_ANYINSTANCE       0

#define STATIC_CSMEDIUMSETID_Standard \
    0x4747B320L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("4747B320-62CE-11CF-A5D6-28DB04C10000", CSMEDIUMSETID_Standard);
#define CSMEDIUMSETID_Standard DEFINE_GUIDNAMED(CSMEDIUMSETID_Standard)

//For compatibility only
#define CSMEDIUM_STANDARD_DEVIO     CSMEDIUM_TYPE_ANYINSTANCE
#endif  //#ifndef UNDER_CE
//===========================================================================


#define STATIC_CSPROPSETID_VERSION\
    0x84FF1B03L, 0x2D79, 0x4BFC, 0x8A, 0xEA, 0xBE, 0x85, 0xF4, 0xB9, 0xF4, 0x64
DEFINE_GUIDSTRUCT("84FF1B03-2D79-4BFC-8AEA-BE85F4B9F464", CSPROPSETID_VERSION);
#define CSPROPSETID_VERSION DEFINE_GUIDNAMED(CSPROPSETID_VERSION)


#define STATIC_CSPROPSETID_Pin\
    0x8C134960L, 0x51AD, 0x11CF, 0x87, 0x8A, 0x94, 0xF8, 0x01, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("8C134960-51AD-11CF-878A-94F801C10000", CSPROPSETID_Pin);
#define CSPROPSETID_Pin DEFINE_GUIDNAMED(CSPROPSETID_Pin)

typedef enum {
    CSPROPERTY_PIN_CINSTANCES=0,
    CSPROPERTY_PIN_CTYPES,
#ifndef UNDER_CE
    CSPROPERTY_PIN_DATAFLOW,
#endif //#ifndef UNDER_CE
    CSPROPERTY_PIN_DATARANGES,
    CSPROPERTY_PIN_DATAINTERSECTION,
#ifndef UNDER_CE
    CSPROPERTY_PIN_INTERFACES,
    CSPROPERTY_PIN_MEDIUMS,
    CSPROPERTY_PIN_COMMUNICATION,
    CSPROPERTY_PIN_GLOBALCINSTANCES,
    CSPROPERTY_PIN_NECESSARYINSTANCES,
    CSPROPERTY_PIN_PHYSICALCONNECTION,
#endif //#ifndef UNDER_CE
    CSPROPERTY_PIN_CATEGORY,
    CSPROPERTY_PIN_NAME,
#ifdef UNDER_CE
    CSPROPERTY_PIN_DEVICENAME
#endif // UNDER_CE
#ifndef UNDER_CE
    ,
    CSPROPERTY_PIN_CONSTRAINEDDATARANGES,
    CSPROPERTY_PIN_PROPOSEDATAFORMAT
#endif //#ifndef UNDER_CE
} CSPROPERTY_PIN;

typedef struct {
    CSPROPERTY      Property;
    ULONG           PinId;
    ULONG           Reserved;
} CSP_PIN, *PCSP_PIN;

#define CSINSTANCE_INDETERMINATE    ((ULONG)-1)

typedef struct {
    ULONG  PossibleCount;
    ULONG  CurrentCount;
} CSPIN_CINSTANCES, *PCSPIN_CINSTANCES;

#ifndef UNDER_CE
typedef enum {
    CSPIN_DATAFLOW_IN = 1,
    CSPIN_DATAFLOW_OUT
} CSPIN_DATAFLOW, *PCSPIN_DATAFLOW;
#endif //#ifndef UNDER_CE

#define CSDATAFORMAT_BIT_TEMPORAL_COMPRESSION   0
#define CSDATAFORMAT_TEMPORAL_COMPRESSION       (1 << CSDATAFORMAT_BIT_TEMPORAL_COMPRESSION)
#define CSDATAFORMAT_BIT_ATTRIBUTES 1
#define CSDATAFORMAT_ATTRIBUTES (1 << CSDATAFORMAT_BIT_ATTRIBUTES)

#define CSDATARANGE_BIT_ATTRIBUTES 1
#define CSDATARANGE_ATTRIBUTES (1 << CSDATARANGE_BIT_ATTRIBUTES)
#define CSDATARANGE_BIT_REQUIRED_ATTRIBUTES 2
#define CSDATARANGE_REQUIRED_ATTRIBUTES (1 << CSDATARANGE_BIT_REQUIRED_ATTRIBUTES)

#if !defined( _MSC_VER ) 
typedef struct {
    ULONG   FormatSize;
    ULONG   Flags;
    ULONG   SampleSize;
    ULONG   Reserved;
    GUID    MajorFormat;
    GUID    SubFormat;
    GUID    Specifier;
} CSDATAFORMAT, *PCSDATAFORMAT, CSDATARANGE, *PCSDATARANGE;
#else
typedef union {
    struct {
        ULONG   FormatSize;
        ULONG   Flags;
        ULONG   SampleSize;
        ULONG   Reserved;
        GUID    MajorFormat;
        GUID    SubFormat;
        GUID    Specifier;
    };
    LONGLONG    Alignment;
} CSDATAFORMAT, *PCSDATAFORMAT, CSDATARANGE, *PCSDATARANGE;
#endif

#define CSATTRIBUTE_REQUIRED 0x00000001

#ifndef UNDER_CE
typedef struct {
    ULONG Size;
    ULONG Flags;
    GUID Attribute;
} CSATTRIBUTE, *PCSATTRIBUTE;

typedef enum {
    CSPIN_COMMUNICATION_NONE,
    CSPIN_COMMUNICATION_SINK,
    CSPIN_COMMUNICATION_SOURCE,
    CSPIN_COMMUNICATION_BOTH,
    CSPIN_COMMUNICATION_BRIDGE
} CSPIN_COMMUNICATION, *PCSPIN_COMMUNICATION;

typedef CSIDENTIFIER CSPIN_MEDIUM, *PCSPIN_MEDIUM;

typedef struct {
    CSPIN_INTERFACE Interface;
    CSPIN_MEDIUM    Medium;
    ULONG           PinId;
    HANDLE          PinToHandle;
    CSPRIORITY      Priority;
} CSPIN_CONNECT, *PCSPIN_CONNECT;

typedef struct {
    ULONG   Size;
    ULONG   Pin;
    WCHAR   SymbolicLinkName[1];
} CSPIN_PHYSICALCONNECTION, *PCSPIN_PHYSICALCONNECTION;

#if defined(_NTDDK_)
typedef
NTSTATUS
(*PFNCSINTERSECTHANDLER)(
    IN PIRP Irp,
    IN PCSP_PIN Pin,
    IN PCSDATARANGE DataRange,
    OUT PVOID Data OPTIONAL
    );
typedef
NTSTATUS
(*PFNCSINTERSECTHANDLEREX)(
    IN PVOID Context,
    IN PIRP Irp,
    IN PCSP_PIN Pin,
    IN PCSDATARANGE DataRange,
    IN PCSDATARANGE MatchingDataRange,
    IN ULONG DataBufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    );
#endif // _NTDDK_

#define DEFINE_CSPIN_INTERFACE_TABLE(tablename)\
    const CSPIN_INTERFACE tablename[] =

#define DEFINE_CSPIN_INTERFACE_ITEM(guid, interface)\
    {\
        STATICGUIDOF(guid),\
        (interface),\
        0\
    }

#endif //#ifndef UNDER_CE

#define DEFINE_CSPROPERTY_ITEM_PIN_CINSTANCES(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_CINSTANCES,\
        (Handler),\
        sizeof(CSP_PIN),\
        sizeof(CSPIN_CINSTANCES),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_PIN_CTYPES(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_CTYPES,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#ifndef UNDER_CE
#define DEFINE_CSPROPERTY_ITEM_PIN_DATAFLOW(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_DATAFLOW,\
        (Handler),\
        sizeof(CSP_PIN),\
        sizeof(CSPIN_DATAFLOW),\
        NULL, NULL, 0, NULL, NULL, 0)
#endif //#ifndef UNDER_CE

#define DEFINE_CSPROPERTY_ITEM_PIN_DATARANGES(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_DATARANGES,\
        (Handler),\
        sizeof(CSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_PIN_DATAINTERSECTION(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_DATAINTERSECTION,\
        (Handler),\
        sizeof(CSP_PIN) + sizeof(CSMULTIPLE_ITEM),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#ifndef UNDER_CE
#define DEFINE_CSPROPERTY_ITEM_PIN_INTERFACES(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_INTERFACES,\
        (Handler),\
        sizeof(CSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_PIN_MEDIUMS(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_MEDIUMS,\
        (Handler),\
        sizeof(CSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_PIN_COMMUNICATION(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_COMMUNICATION,\
        (Handler),\
        sizeof(CSP_PIN),\
        sizeof(CSPIN_COMMUNICATION),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_PIN_GLOBALCINSTANCES(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_GLOBALCINSTANCES,\
        (Handler),\
        sizeof(CSP_PIN),\
        sizeof(CSPIN_CINSTANCES),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_NECESSARYINSTANCES,\
        (Handler),\
        sizeof(CSP_PIN),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_PIN_PHYSICALCONNECTION(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_PHYSICALCONNECTION,\
        (Handler),\
        sizeof(CSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#endif //#ifndef UNDER_CE

#define DEFINE_CSPROPERTY_ITEM_PIN_CATEGORY(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_CATEGORY,\
        (Handler),\
        sizeof(CSP_PIN),\
        sizeof(GUID),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_PIN_NAME(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_NAME,\
        (Handler),\
        sizeof(CSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#ifndef UNDER_CE
#define DEFINE_CSPROPERTY_ITEM_PIN_CONSTRAINEDDATARANGES(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_CONSTRAINEDDATARANGES,\
        (Handler),\
        sizeof(CSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_PIN_PROPOSEDATAFORMAT(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_PIN_PROPOSEDATAFORMAT,\
        NULL,\
        sizeof(CSP_PIN),\
        sizeof(CSDATAFORMAT),\
        (Handler), NULL, 0, NULL, NULL, 0)

#endif //#ifndef UNDER_CE

#define DEFINE_CSPROPERTY_PINSET(PinSet,\
    PropGeneral, PropInstances, PropIntersection) \
DEFINE_CSPROPERTY_TABLE(PinSet) {\
    DEFINE_CSPROPERTY_ITEM_PIN_CINSTANCES(PropInstances),\
    DEFINE_CSPROPERTY_ITEM_PIN_CTYPES(PropGeneral),\
    DEFINE_CSPROPERTY_ITEM_PIN_DATARANGES(PropGeneral),\
    DEFINE_CSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropIntersection),\
    DEFINE_CSPROPERTY_ITEM_PIN_CATEGORY(PropGeneral),\
    DEFINE_CSPROPERTY_ITEM_PIN_NAME(PropGeneral)\
}

#ifndef UNDER_CE
#define DEFINE_CSPROPERTY_PINSETCONSTRAINED(PinSet,\
    PropGeneral, PropInstances, PropIntersection)\
DEFINE_CSPROPERTY_TABLE(PinSet) {\
    DEFINE_CSPROPERTY_ITEM_PIN_CINSTANCES(PropInstances),\
    DEFINE_CSPROPERTY_ITEM_PIN_CTYPES(PropGeneral),\
    DEFINE_CSPROPERTY_ITEM_PIN_DATAFLOW(PropGeneral),\
    DEFINE_CSPROPERTY_ITEM_PIN_DATARANGES(PropGeneral),\
    DEFINE_CSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropIntersection),\
    DEFINE_CSPROPERTY_ITEM_PIN_INTERFACES(PropGeneral),\
    DEFINE_CSPROPERTY_ITEM_PIN_MEDIUMS(PropGeneral),\
    DEFINE_CSPROPERTY_ITEM_PIN_COMMUNICATION(PropGeneral),\
    DEFINE_CSPROPERTY_ITEM_PIN_CATEGORY(PropGeneral),\
    DEFINE_CSPROPERTY_ITEM_PIN_NAME(PropGeneral),\
    DEFINE_CSPROPERTY_ITEM_PIN_CONSTRAINEDDATARANGES(PropGeneral)\
}

#define STATIC_CSNAME_Filter\
    0x9b365890L, 0x165f, 0x11d0, 0xa1, 0x95, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("9b365890-165f-11d0-a195-0020afd156e4", CSNAME_Filter);
#define CSNAME_Filter DEFINE_GUIDNAMED(CSNAME_Filter)

#define CSSTRING_Filter L"{9B365890-165F-11D0-A195-0020AFD156E4}"

#define STATIC_CSNAME_Pin\
    0x146F1A80L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("146F1A80-4791-11D0-A5D6-28DB04C10000", CSNAME_Pin);
#define CSNAME_Pin DEFINE_GUIDNAMED(CSNAME_Pin)

#define CSSTRING_Pin L"{146F1A80-4791-11D0-A5D6-28DB04C10000}"

#define STATIC_CSNAME_Clock\
    0x53172480L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("53172480-4791-11D0-A5D6-28DB04C10000", CSNAME_Clock);
#define CSNAME_Clock DEFINE_GUIDNAMED(CSNAME_Clock)

#define CSSTRING_Clock L"{53172480-4791-11D0-A5D6-28DB04C10000}"

#define STATIC_CSNAME_Allocator\
    0x642F5D00L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("642F5D00-4791-11D0-A5D6-28DB04C10000", CSNAME_Allocator);
#define CSNAME_Allocator DEFINE_GUIDNAMED(CSNAME_Allocator)

#define CSSTRING_Allocator L"{642F5D00-4791-11D0-A5D6-28DB04C10000}"

#define CSSTRING_AllocatorEx L"{091BB63B-603F-11D1-B067-00A0C9062802}"

#define STATIC_CSNAME_TopologyNode\
    0x0621061AL, 0xEE75, 0x11D0, 0xB9, 0x15, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("0621061A-EE75-11D0-B915-00A0C9223196", CSNAME_TopologyNode);
#define CSNAME_TopologyNode DEFINE_GUIDNAMED(CSNAME_TopologyNode)

#define CSSTRING_TopologyNode L"{0621061A-EE75-11D0-B915-00A0C9223196}"

#if defined(_NTDDK_)

typedef struct {
    ULONG                   InterfacesCount;
    const CSPIN_INTERFACE*  Interfaces;
    ULONG                   MediumsCount;
    const CSPIN_MEDIUM*     Mediums;
    ULONG                   DataRangesCount;
    const PCSDATARANGE*     DataRanges;
    CSPIN_DATAFLOW          DataFlow;
    CSPIN_COMMUNICATION     Communication;
    const GUID*             Category;
    const GUID*             Name;
    union {
        LONGLONG            Reserved;
        struct {
            ULONG           ConstrainedDataRangesCount;
            PCSDATARANGE*   ConstrainedDataRanges;
        };
    };
} CSPIN_DESCRIPTOR, *PCSPIN_DESCRIPTOR;
typedef const CSPIN_DESCRIPTOR *PCCSPIN_DESCRIPTOR;

#define DEFINE_CSPIN_DESCRIPTOR_TABLE(tablename)\
    const CSPIN_DESCRIPTOR tablename[] =

#define DEFINE_CSPIN_DESCRIPTOR_ITEM(\
    InterfacesCount, Interfaces,\
    MediumsCount, Mediums,\
    DataRangesCount, DataRanges,\
    DataFlow, Communication)\
{\
    InterfacesCount, Interfaces, MediumsCount, Mediums,\
    DataRangesCount, DataRanges, DataFlow, Communication,\
    NULL, NULL, 0\
}
#define DEFINE_CSPIN_DESCRIPTOR_ITEMEX(\
    InterfacesCount, Interfaces,\
    MediumsCount, Mediums,\
    DataRangesCount, DataRanges,\
    DataFlow, Communication,\
    Category, Name)\
{\
    InterfacesCount, Interfaces, MediumsCount, Mediums,\
    DataRangesCount, DataRanges, DataFlow, Communication,\
    Category, Name, 0\
}

#endif // defined(_NTDDK_)
#endif //#ifndef UNDER_CE
//===========================================================================

// MEDIATYPE_NULL
#define STATIC_CSDATAFORMAT_TYPE_WILDCARD       STATIC_GUID_NULL
#define CSDATAFORMAT_TYPE_WILDCARD              GUID_NULL

// MEDIASUBTYPE_NULL
#define STATIC_CSDATAFORMAT_SUBTYPE_WILDCARD    STATIC_GUID_NULL
#define CSDATAFORMAT_SUBTYPE_WILDCARD           GUID_NULL

// MEDIATYPE_Stream
#define STATIC_CSDATAFORMAT_TYPE_STREAM\
    0xE436EB83L, 0x524F, 0x11CE, 0x9F, 0x53, 0x00, 0x20, 0xAF, 0x0B, 0xA7, 0x70
DEFINE_GUIDSTRUCT("E436EB83-524F-11CE-9F53-0020AF0BA770", CSDATAFORMAT_TYPE_STREAM);
#define CSDATAFORMAT_TYPE_STREAM DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_STREAM)

// MEDIASUBTYPE_None
#define STATIC_CSDATAFORMAT_SUBTYPE_NONE\
    0xE436EB8EL, 0x524F, 0x11CE, 0x9F, 0x53, 0x00, 0x20, 0xAF, 0x0B, 0xA7, 0x70
DEFINE_GUIDSTRUCT("E436EB8E-524F-11CE-9F53-0020AF0BA770", CSDATAFORMAT_SUBTYPE_NONE);
#define CSDATAFORMAT_SUBTYPE_NONE DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_NONE)

#define STATIC_CSDATAFORMAT_SPECIFIER_WILDCARD  STATIC_GUID_NULL
#define CSDATAFORMAT_SPECIFIER_WILDCARD         GUID_NULL

#define STATIC_CSDATAFORMAT_SPECIFIER_FILENAME\
    0xAA797B40L, 0xE974, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("AA797B40-E974-11CF-A5D6-28DB04C10000", CSDATAFORMAT_SPECIFIER_FILENAME);
#define CSDATAFORMAT_SPECIFIER_FILENAME DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_FILENAME)

#define STATIC_CSDATAFORMAT_SPECIFIER_FILEHANDLE\
    0x65E8773CL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65E8773C-8F56-11D0-A3B9-00A0C9223196", CSDATAFORMAT_SPECIFIER_FILEHANDLE);
#define CSDATAFORMAT_SPECIFIER_FILEHANDLE DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_FILEHANDLE)

// FORMAT_None
#define STATIC_CSDATAFORMAT_SPECIFIER_NONE\
    0x0F6417D6L, 0xC318, 0x11D0, 0xA4, 0x3F, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("0F6417D6-C318-11D0-A43F-00A0C9223196", CSDATAFORMAT_SPECIFIER_NONE);
#define CSDATAFORMAT_SPECIFIER_NONE DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_NONE)

#ifndef UNDER_CE
//===========================================================================

#define STATIC_CSPROPSETID_Quality \
    0xD16AD380L, 0xAC1A, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("D16AD380-AC1A-11CF-A5D6-28DB04C10000", CSPROPSETID_Quality);
#define CSPROPSETID_Quality DEFINE_GUIDNAMED(CSPROPSETID_Quality)

typedef enum {
    CSPROPERTY_QUALITY_REPORT,
    CSPROPERTY_QUALITY_ERROR
} CSPROPERTY_QUALITY;

#define DEFINE_CSPROPERTY_ITEM_QUALITY_REPORT(GetHandler, SetHandler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_QUALITY_REPORT,\
        (GetHandler),\
        sizeof(CSPROPERTY),\
        sizeof(CSQUALITY),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_QUALITY_ERROR(GetHandler, SetHandler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_QUALITY_ERROR,\
        (GetHandler),\
        sizeof(CSPROPERTY),\
        sizeof(CSERROR),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#endif //#ifndef UNDER_CE
//===========================================================================

#define STATIC_CSPROPSETID_Connection \
    0x1D58C920L, 0xAC9B, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1D58C920-AC9B-11CF-A5D6-28DB04C10000", CSPROPSETID_Connection);
#define CSPROPSETID_Connection DEFINE_GUIDNAMED(CSPROPSETID_Connection)

typedef enum {
    CSPROPERTY_CONNECTION_STATE,
#ifndef UNDER_CE
    CSPROPERTY_CONNECTION_PRIORITY,
#endif //#ifndef UNDER_CE
    CSPROPERTY_CONNECTION_DATAFORMAT,
    CSPROPERTY_CONNECTION_ALLOCATORFRAMING,
    CSPROPERTY_CONNECTION_PROPOSEDATAFORMAT,
#ifndef UNDER_CE
    CSPROPERTY_CONNECTION_ACQUIREORDERING,
#endif //#ifndef UNDER_CE    
    CSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX
#ifndef UNDER_CE
    ,
    CSPROPERTY_CONNECTION_STARTAT
#endif //#ifndef UNDER_CE
} CSPROPERTY_CONNECTION;

#define DEFINE_CSPROPERTY_ITEM_CONNECTION_STATE(GetHandler, SetHandler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CONNECTION_STATE,\
        (GetHandler),\
        sizeof(CSPROPERTY),\
        sizeof(CSSTATE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#ifndef UNDER_CE
#define DEFINE_CSPROPERTY_ITEM_CONNECTION_PRIORITY(GetHandler, SetHandler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CONNECTION_PRIORITY,\
        (GetHandler),\
        sizeof(CSPROPERTY),\
        sizeof(CSPRIORITY),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)
#endif //#ifndef UNDER_CE

#define DEFINE_CSPROPERTY_ITEM_CONNECTION_DATAFORMAT(GetHandler, SetHandler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CONNECTION_DATAFORMAT,\
        (GetHandler),\
        sizeof(CSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CONNECTION_ALLOCATORFRAMING,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(CSALLOCATOR_FRAMING),\
        NULL, NULL, 0, NULL, NULL, 0)
        
#define DEFINE_CSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING_EX(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX,\
        (Handler),\
        sizeof(CSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#ifndef UNDER_CE
#define DEFINE_CSPROPERTY_ITEM_CONNECTION_PROPOSEDATAFORMAT(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CONNECTION_PROPOSEDATAFORMAT,\
        NULL,\
        sizeof(CSPROPERTY),\
        sizeof(CSDATAFORMAT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_CONNECTION_ACQUIREORDERING(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CONNECTION_ACQUIREORDERING,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(int),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_CONNECTION_STARTAT(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CONNECTION_STARTAT,\
        NULL,\
        sizeof(CSPROPERTY),\
        sizeof(CSRELATIVEEVENT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)
#endif //#ifndef UNDER_CE

//===========================================================================
//
// pins flags
//
#define CSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER   0x00000001
#define CSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY      0x00000002
#define CSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY    0x00000004
#define CSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE      0x00000008
#define CSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY   0x80000000

#define CSALLOCATOR_OPTIONF_COMPATIBLE              0x00000001
#define CSALLOCATOR_OPTIONF_SYSTEM_MEMORY           0x00000002
#define CSALLOCATOR_OPTIONF_VALID                   0x00000003
// 
// pins extended framing flags
//
#define CSALLOCATOR_FLAG_PARTIAL_READ_SUPPORT       0x00000010
#define CSALLOCATOR_FLAG_DEVICE_SPECIFIC            0x00000020
#define CSALLOCATOR_FLAG_CAN_ALLOCATE               0x00000040
#define CSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO  0x00000080
//
// allocator pipes flags
//
// there is at least one data modification in a pipe
#define CSALLOCATOR_FLAG_NO_FRAME_INTEGRITY         0x00000100
#define CSALLOCATOR_FLAG_MULTIPLE_OUTPUT            0x00000200
#define CSALLOCATOR_FLAG_CYCLE                      0x00000400
#define CSALLOCATOR_FLAG_ALLOCATOR_EXISTS           0x00000800
// there is no framing dependency between neighbouring pipes.
#define CSALLOCATOR_FLAG_INDEPENDENT_RANGES         0x00001000
#define CSALLOCATOR_FLAG_ATTENTION_STEPPING         0x00002000


//
// old Framing structure
//
typedef struct {
    union {
        ULONG       OptionsFlags;       // allocator options (create)
        ULONG       RequirementsFlags;  // allocation requirements (query)
    };
#if defined(_NTDDK_)
    POOL_TYPE   PoolType;
#else // !_NTDDK_
    ULONG       PoolType;
#endif // !_NTDDK_
    ULONG       Frames;     // total number of allowable outstanding frames
    ULONG       FrameSize;  // total size of frame
    ULONG       FileAlignment;
    ULONG       Reserved;
} CSALLOCATOR_FRAMING, *PCSALLOCATOR_FRAMING;

#ifndef UNDER_CE
#if defined(_NTDDK_)
typedef
PVOID
(*PFNCSDEFAULTALLOCATE)(
    IN PVOID Context
    );

typedef
VOID
(*PFNCSDEFAULTFREE)(
    IN PVOID Context,
    IN PVOID Buffer
    );

typedef
NTSTATUS
(*PFNCSINITIALIZEALLOCATOR)(
    IN PVOID InitialContext,
    IN PCSALLOCATOR_FRAMING AllocatorFraming,
    OUT PVOID* Context
    );

typedef
VOID
(*PFNCSDELETEALLOCATOR)(
    IN PVOID Context
    );
#endif // !_NTDDK_

#endif //#ifndef UNDER_CE

//
// new Framing structure, eventually will replace CSALLOCATOR_FRAMING.
// 
typedef struct {
    ULONG   MinFrameSize;
    ULONG   MaxFrameSize;
    ULONG   Stepping;
} CS_FRAMING_RANGE, *PCS_FRAMING_RANGE;


typedef struct {
    CS_FRAMING_RANGE  Range;
    ULONG             InPlaceWeight;
    ULONG             NotInPlaceWeight;
} CS_FRAMING_RANGE_WEIGHTED, *PCS_FRAMING_RANGE_WEIGHTED;


typedef struct {
    ULONG   RatioNumerator;      // compression/expansion ratio
    ULONG   RatioDenominator; 
    ULONG   RatioConstantMargin;
} CS_COMPRESSION, *PCS_COMPRESSION;


//
// Memory Types and Buses are repeated in each entry.
// Easiest to use but takes a little more memory than the varsize layout Pin\Memories\Buses\Ranges.
//
typedef struct {
    GUID                        MemoryType;
    GUID                        BusType;
    ULONG                       MemoryFlags;
    ULONG                       BusFlags;   
    ULONG                       Flags;   
    ULONG                       Frames;              // total number of allowable outstanding frames
    ULONG                       FileAlignment;
    ULONG                       MemoryTypeWeight;    // this memory type Weight pin-wide
    CS_FRAMING_RANGE            PhysicalRange;
    CS_FRAMING_RANGE_WEIGHTED   FramingRange; 
} CS_FRAMING_ITEM, *PCS_FRAMING_ITEM;


typedef struct {
    ULONG               CountItems;         // count of FramingItem-s below.
    ULONG               PinFlags;
    CS_COMPRESSION      OutputCompression;
    ULONG               PinWeight;          // this pin framing's Weight graph-wide
    CS_FRAMING_ITEM     FramingItem[1]; 
} CSALLOCATOR_FRAMING_EX, *PCSALLOCATOR_FRAMING_EX;


#ifndef UNDER_CE
//
// define memory type GUIDs
//
#define CSMEMORY_TYPE_WILDCARD          GUID_NULL
#define STATIC_CSMEMORY_TYPE_WILDCARD   STATIC_GUID_NULL

#define CSMEMORY_TYPE_DONT_CARE         GUID_NULL
#define STATIC_CSMEMORY_TYPE_DONT_CARE  STATIC_GUID_NULL

#define CS_TYPE_DONT_CARE           GUID_NULL
#define STATIC_CS_TYPE_DONT_CARE    STATIC_GUID_NULL
     
#define STATIC_CSMEMORY_TYPE_SYSTEM \
    0x091bb638L, 0x603f, 0x11d1, 0xb0, 0x67, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("091bb638-603f-11d1-b067-00a0c9062802", CSMEMORY_TYPE_SYSTEM);
#define CSMEMORY_TYPE_SYSTEM  DEFINE_GUIDNAMED(CSMEMORY_TYPE_SYSTEM)

#define STATIC_CSMEMORY_TYPE_USER \
    0x8cb0fc28L, 0x7893, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("8cb0fc28-7893-11d1-b069-00a0c9062802", CSMEMORY_TYPE_USER);
#define CSMEMORY_TYPE_USER  DEFINE_GUIDNAMED(CSMEMORY_TYPE_USER)

#define STATIC_CSMEMORY_TYPE_KERNEL_PAGED \
    0xd833f8f8L, 0x7894, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("d833f8f8-7894-11d1-b069-00a0c9062802", CSMEMORY_TYPE_KERNEL_PAGED);
#define CSMEMORY_TYPE_KERNEL_PAGED  DEFINE_GUIDNAMED(CSMEMORY_TYPE_KERNEL_PAGED)

#define STATIC_CSMEMORY_TYPE_KERNEL_NONPAGED \
    0x4a6d5fc4L, 0x7895, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("4a6d5fc4-7895-11d1-b069-00a0c9062802", CSMEMORY_TYPE_KERNEL_NONPAGED);
#define CSMEMORY_TYPE_KERNEL_NONPAGED  DEFINE_GUIDNAMED(CSMEMORY_TYPE_KERNEL_NONPAGED)

// old CS clients did not specify the device memory type
#define STATIC_CSMEMORY_TYPE_DEVICE_UNKNOWN \
    0x091bb639L, 0x603f, 0x11d1, 0xb0, 0x67, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("091bb639-603f-11d1-b067-00a0c9062802", CSMEMORY_TYPE_DEVICE_UNKNOWN);
#define CSMEMORY_TYPE_DEVICE_UNKNOWN DEFINE_GUIDNAMED(CSMEMORY_TYPE_DEVICE_UNKNOWN)

#endif //#ifndef UNDER_CE

//
// Helper framing macros.
//
#define DECLARE_SIMPLE_FRAMING_EX(FramingExName, MemoryType, Flags, Frames, Alignment, MinFrameSize, MaxFrameSize) \
    const CSALLOCATOR_FRAMING_EX FramingExName = \
    {\
        1, \
        0, \
        {\
            1, \
            1, \
            0 \
        }, \
        0, \
        {\
            {\
                MemoryType, \
                STATIC_CS_TYPE_DONT_CARE, \
                0, \
                0, \
                Flags, \
                Frames, \
                Alignment, \
                0, \
                {\
                    0, \
                    (ULONG)-1, \
                    1 \
                }, \
                {\
                    {\
                        MinFrameSize, \
                        MaxFrameSize, \
                        1 \
                    }, \
                    0, \
                    0  \
                }\
            }\
        }\
    }

#define SetDefaultCsCompression(CsCompressionPointer) \
{\
    CsCompressionPointer->RatioNumerator = 1;\
    CsCompressionPointer->RatioDenominator = 1;\
    CsCompressionPointer->RatioConstantMargin = 0;\
}

#define SetDontCareCsFramingRange(CsFramingRangePointer) \
{\
    CsFramingRangePointer->MinFrameSize = 0;\
    CsFramingRangePointer->MaxFrameSize = (ULONG) -1;\
    CsFramingRangePointer->Stepping = 1;\
}

#define SetCsFramingRange(CsFramingRangePointer, P_MinFrameSize, P_MaxFrameSize) \
{\
    CsFramingRangePointer->MinFrameSize = P_MinFrameSize;\
    CsFramingRangePointer->MaxFrameSize = P_MaxFrameSize;\
    CsFramingRangePointer->Stepping = 1;\
}

#define SetCsFramingRangeWeighted(CsFramingRangeWeightedPointer, P_MinFrameSize, P_MaxFrameSize) \
{\
    CS_FRAMING_RANGE *CsFramingRange = &CsFramingRangeWeightedPointer->Range;\
    SetCsFramingRange(CsFramingRange, P_MinFrameSize, P_MaxFrameSize);\
    CsFramingRangeWeightedPointer->InPlaceWeight = 0;\
    CsFramingRangeWeightedPointer->NotInPlaceWeight = 0;\
}

#define INITIALIZE_SIMPLE_FRAMING_EX(FramingExPointer, P_MemoryType, P_Flags, P_Frames, P_Alignment, P_MinFrameSize, P_MaxFrameSize) \
{\
    CS_COMPRESSION *CsCompression = &FramingExPointer->OutputCompression;\
    CS_FRAMING_RANGE *CsFramingRange = &FramingExPointer->FramingItem[0].PhysicalRange;\
    CS_FRAMING_RANGE_WEIGHTED *CsFramingRangeWeighted = &FramingExPointer->FramingItem[0].FramingRange;\
    FramingExPointer->CountItems = 1;\
    FramingExPointer->PinFlags = 0;\
    SetDefaultCsCompression(CsCompression);\
    FramingExPointer->PinWeight = 0;\
    FramingExPointer->FramingItem[0].MemoryType = P_MemoryType;\
    FramingExPointer->FramingItem[0].BusType = CS_TYPE_DONT_CARE;\
    FramingExPointer->FramingItem[0].MemoryFlags = 0;\
    FramingExPointer->FramingItem[0].BusFlags = 0;\
    FramingExPointer->FramingItem[0].Flags = P_Flags;\
    FramingExPointer->FramingItem[0].Frames = P_Frames;\
    FramingExPointer->FramingItem[0].FileAlignment = P_Alignment;\
    FramingExPointer->FramingItem[0].MemoryTypeWeight = 0;\
    SetDontCareCsFramingRange(CsFramingRange);\
    SetCsFramingRangeWeighted(CsFramingRangeWeighted, P_MinFrameSize, P_MaxFrameSize);\
}

#define STATIC_CSPROPSETID_Metadata \
    0x582157c2, 0xc999, 0x4a7d, 0x89, 0x4c, 0x14, 0x75, 0x6a, 0x82, 0x15, 0xad
DEFINE_GUIDSTRUCT("582157C2-C999-4a7d-894C-14756A8215AD", CSPROPSETID_Metadata);
#define CSPROPSETID_Metadata DEFINE_GUIDNAMED(CSPROPSETID_Metadata)

typedef enum {
    CSPROPERTY_METADATA_ALL
} CSPROPERTY_METADATA;

// CS_PROPERTYITEM structure. This is essentially equivalent to the PropertyItem
// class defined in gdiplusimaging.h. The exception is the ulDataOffset member
// which holds the offset from the beginning of the CSMETADATA_S structure to the
// data associated with the PropertyItem.
typedef struct
{
    PROPID          propId;
    ULONG           ulLength;
    WORD            wType;
    ULONG           ulDataOffset;
} CS_PROPERTYITEM, *PCS_PROPERTYITEM;

typedef struct
{
    ULONG           ulCount;
    CS_PROPERTYITEM rgitemMetadata[1];
} CSMETADATA_S, *PCSMETADATA_S;

#define CS_PROPID_MAKE              271
#define CS_PROPID_MODEL             272
#define CS_PROPID_MAKER_NOTE        37500
#define CS_PROPID_SENSING_METHOD    41495
#define CS_PROPID_CFA_PATTERN       41730

typedef enum
{
    CS_PROPITEM_TYPE_BYTE = 1,
    CS_PROPITEM_TYPE_ASCII,
    CS_PROPITEM_TYPE_SHORT,
    CS_PROPITEM_TYPE_LONG,
    CS_PROPITEM_TYPE_RATIONAL,
    CS_PROPITEM_TYPE_UNDEFINED = 7,
    CS_PROPITEM_TYPE_SLONG = 9,
    CS_PROPITEM_TYPE_SRATIONAL = 10
} CS_PROPITEM_TYPE;

#define DEFINE_CSPROPERTY_ITEM_METADATA_ALL(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_METADATA_ALL,\
        (Handler),\
        sizeof(CSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#ifndef UNDER_CE
// CSEVENTSETID_StreamAllocator: {75D95571-073C-11d0-A161-0020AFD156E4}

#define STATIC_CSEVENTSETID_StreamAllocator\
    0x75d95571L, 0x073c, 0x11d0, 0xa1, 0x61, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("75d95571-073c-11d0-a161-0020afd156e4", CSEVENTSETID_StreamAllocator);
#define CSEVENTSETID_StreamAllocator DEFINE_GUIDNAMED(CSEVENTSETID_StreamAllocator)

typedef enum {
    CSEVENT_STREAMALLOCATOR_INTERNAL_FREEFRAME,
    CSEVENT_STREAMALLOCATOR_FREEFRAME
} CSEVENT_STREAMALLOCATOR;

#define STATIC_CSMETHODSETID_StreamAllocator\
    0xcf6e4341L, 0xec87, 0x11cf, 0xa1, 0x30, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("cf6e4341-ec87-11cf-a130-0020afd156e4", CSMETHODSETID_StreamAllocator);
#define CSMETHODSETID_StreamAllocator DEFINE_GUIDNAMED(CSMETHODSETID_StreamAllocator)

typedef enum {
    CSMETHOD_STREAMALLOCATOR_ALLOC,
    CSMETHOD_STREAMALLOCATOR_FREE
} CSMETHOD_STREAMALLOCATOR;

#define DEFINE_CSMETHOD_ITEM_STREAMALLOCATOR_ALLOC(Handler)\
    DEFINE_CSMETHOD_ITEM(\
        CSMETHOD_STREAMALLOCATOR_ALLOC,\
        CSMETHOD_TYPE_WRITE,\
        (Handler),\
        sizeof(CSMETHOD),\
        sizeof(PVOID),\
        NULL)

#define DEFINE_CSMETHOD_ITEM_STREAMALLOCATOR_FREE(Handler)\
    DEFINE_CSMETHOD_ITEM(\
        CSMETHOD_STREAMALLOCATOR_FREE,\
        CSMETHOD_TYPE_READ,\
        (Handler),\
        sizeof(CSMETHOD),\
        sizeof(PVOID),\
        NULL)

#define DEFINE_CSMETHOD_ALLOCATORSET(AllocatorSet, MethodAlloc, MethodFree)\
DEFINE_CSMETHOD_TABLE(AllocatorSet) {\
    DEFINE_CSMETHOD_ITEM_STREAMALLOCATOR_ALLOC(MethodAlloc),\
    DEFINE_CSMETHOD_ITEM_STREAMALLOCATOR_FREE(MethodFree)\
}

#define STATIC_CSPROPSETID_StreamAllocator\
    0xcf6e4342L, 0xec87, 0x11cf, 0xa1, 0x30, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("cf6e4342-ec87-11cf-a130-0020afd156e4", CSPROPSETID_StreamAllocator);
#define CSPROPSETID_StreamAllocator DEFINE_GUIDNAMED(CSPROPSETID_StreamAllocator)

#if defined(_NTDDK_)
typedef enum {
    CSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE,
    CSPROPERTY_STREAMALLOCATOR_STATUS
} CSPROPERTY_STREAMALLOCATOR;

#define DEFINE_CSPROPERTY_ITEM_STREAMALLOCATOR_FUNCTIONTABLE(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(CSSTREAMALLOCATOR_FUNCTIONTABLE),\
        NULL, NULL, 0, NULL, NULL, 0)
        
#define DEFINE_CSPROPERTY_ITEM_STREAMALLOCATOR_STATUS(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAMALLOCATOR_STATUS,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(CSSTREAMALLOCATOR_STATUS),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ALLOCATORSET(AllocatorSet, PropFunctionTable, PropStatus)\
DEFINE_CSPROPERTY_TABLE(AllocatorSet) {\
    DEFINE_CSPROPERTY_ITEM_STREAMALLOCATOR_STATUS(PropStatus),\
    DEFINE_CSPROPERTY_ITEM_STREAMALLOCATOR_FUNCTIONTABLE(PropFunctionTable)\
}

typedef
NTSTATUS
(*PFNALLOCATOR_ALLOCATEFRAME)(
    IN PFILE_OBJECT FileObject,
    PVOID *Frame
    );

typedef
VOID
(*PFNALLOCATOR_FREEFRAME)(
    IN PFILE_OBJECT FileObject,
    IN PVOID Frame
    );

typedef struct {
    PFNALLOCATOR_ALLOCATEFRAME  AllocateFrame;
    PFNALLOCATOR_FREEFRAME      FreeFrame;
} CSSTREAMALLOCATOR_FUNCTIONTABLE, *PCSSTREAMALLOCATOR_FUNCTIONTABLE;
#endif // defined(_NTDDK_)

typedef struct {
    CSALLOCATOR_FRAMING Framing;
    ULONG               AllocatedFrames;
    ULONG               Reserved;
} CSSTREAMALLOCATOR_STATUS, *PCSSTREAMALLOCATOR_STATUS;

typedef struct {
    CSALLOCATOR_FRAMING_EX Framing;
    ULONG                  AllocatedFrames;
    ULONG                  Reserved;
} CSSTREAMALLOCATOR_STATUS_EX, *PCSSTREAMALLOCATOR_STATUS_EX;

#endif //#ifndef UNDER_CE

#define CSSTREAM_HEADER_OPTIONSF_SPLICEPOINT        0x00000001
#define CSSTREAM_HEADER_OPTIONSF_PREROLL            0x00000002
#define CSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY  0x00000004
#define CSSTREAM_HEADER_OPTIONSF_TYPECHANGED        0x00000008
#define CSSTREAM_HEADER_OPTIONSF_TIMEVALID          0x00000010
#define CSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY  0x00000040
#define CSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE       0x00000080
#define CSSTREAM_HEADER_OPTIONSF_DURATIONVALID      0x00000100
#define CSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM        0x00000200
#define CSSTREAM_HEADER_OPTIONSF_LOOPEDDATA         0x80000000

typedef struct {
    LONGLONG    Time;
    ULONG       Numerator;
    ULONG       Denominator;
} CSTIME, *PCSTIME;


typedef struct {
    ULONG       Size;
    ULONG       TypeSpecificFlags;
    CSTIME      PresentationTime;
    LONGLONG    Duration;
    ULONG       FrameExtent;
    ULONG       DataUsed;
    PVOID       Data;
    ULONG       OptionsFlags;
    DWORD       Handle;
#if _WIN64
    ULONG       Reserved;
#endif
} CSSTREAM_HEADER, *PCSSTREAM_HEADER;

#ifndef UNDER_CE
#define STATIC_CSPROPSETID_StreamInterface\
    0x1fdd8ee1L, 0x9cd3, 0x11d0, 0x82, 0xaa, 0x00, 0x00, 0xf8, 0x22, 0xfe, 0x8a
DEFINE_GUIDSTRUCT("1fdd8ee1-9cd3-11d0-82aa-0000f822fe8a", CSPROPSETID_StreamInterface);
#define CSPROPSETID_StreamInterface DEFINE_GUIDNAMED(CSPROPSETID_StreamInterface)

typedef enum {
    CSPROPERTY_STREAMINTERFACE_HEADERSIZE
} CSPROPERTY_STREAMINTERFACE;

#define DEFINE_CSPROPERTY_ITEM_STREAMINTERFACE_HEADERSIZE( GetHandler )\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAMINTERFACE_HEADERSIZE,\
        (GetHandler),\
        sizeof(CSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)
        
#define DEFINE_CSPROPERTY_STREAMINTERFACESET(StreamInterfaceSet,\
    HeaderSizeHandler)\
DEFINE_CSPROPERTY_TABLE(StreamInterfaceSet) {\
    DEFINE_CSPROPERTY_ITEM_STREAMINTERFACE_HEADERSIZE( HeaderSizeHandler )\
}
#endif //#ifndef UNDER_CE

#define STATIC_CSPROPSETID_Stream\
    0x65aaba60L, 0x98ae, 0x11cf, 0xa1, 0x0d, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("65aaba60-98ae-11cf-a10d-0020afd156e4", CSPROPSETID_Stream);
#define CSPROPSETID_Stream DEFINE_GUIDNAMED(CSPROPSETID_Stream)

typedef enum {
    CSPROPERTY_STREAM_ALLOCATOR
#ifndef UNDER_CE
    ,
    CSPROPERTY_STREAM_QUALITY,
    CSPROPERTY_STREAM_DEGRADATION,
    CSPROPERTY_STREAM_MASTERCLOCK,
    CSPROPERTY_STREAM_TIMEFORMAT,
    CSPROPERTY_STREAM_PRESENTATIONTIME,
    CSPROPERTY_STREAM_PRESENTATIONEXTENT,
    CSPROPERTY_STREAM_FRAMETIME,
    CSPROPERTY_STREAM_RATECAPABILITY,
    CSPROPERTY_STREAM_RATE,
    CSPROPERTY_STREAM_PIPE_ID
#endif //#ifndef UNDER_CE
} CSPROPERTY_STREAM;


#define DEFINE_CSPROPERTY_ITEM_STREAM_ALLOCATOR(GetHandler, SetHandler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAM_ALLOCATOR,\
        (GetHandler),\
        sizeof(CSPROPERTY),\
        sizeof(HANDLE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#ifndef UNDER_CE
#define DEFINE_CSPROPERTY_ITEM_STREAM_QUALITY(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAM_QUALITY,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(CSQUALITY_MANAGER),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_STREAM_DEGRADATION(GetHandler, SetHandler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAM_DEGRADATION,\
        (GetHandler),\
        sizeof(CSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_STREAM_MASTERCLOCK(GetHandler, SetHandler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAM_MASTERCLOCK,\
        (GetHandler),\
        sizeof(CSPROPERTY),\
        sizeof(HANDLE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_STREAM_TIMEFORMAT(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAM_TIMEFORMAT,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(GUID),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_STREAM_PRESENTATIONTIME(GetHandler, SetHandler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAM_PRESENTATIONTIME,\
        (GetHandler),\
        sizeof(CSPROPERTY),\
        sizeof(CSTIME),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_STREAM_PRESENTATIONEXTENT(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAM_PRESENTATIONEXTENT,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_STREAM_FRAMETIME(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAM_FRAMETIME,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(CSFRAMETIME),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_STREAM_RATECAPABILITY(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAM_RATECAPABILITY,\
        (Handler),\
        sizeof(CSRATE_CAPABILITY),\
        sizeof(CSRATE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_STREAM_RATE(GetHandler, SetHandler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAM_RATE,\
        (GetHandler),\
        sizeof(CSPROPERTY),\
        sizeof(CSRATE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_STREAM_PIPE_ID(GetHandler, SetHandler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_STREAM_PIPE_ID,\
        (GetHandler),\
        sizeof(CSPROPERTY),\
        sizeof(HANDLE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

typedef struct {
    HANDLE      QualityManager;
    PVOID       Context;
} CSQUALITY_MANAGER, *PCSQUALITY_MANAGER;

typedef struct {
    LONGLONG    Duration;
    ULONG       FrameFlags;
    ULONG       Reserved;
} CSFRAMETIME, *PCSFRAMETIME;

#define CSFRAMETIME_VARIABLESIZE    0x00000001

typedef struct {
    LONGLONG        PresentationStart;
    LONGLONG        Duration;
    CSPIN_INTERFACE Interface;
    LONG            Rate;
    ULONG           Flags;
} CSRATE, *PCSRATE;

#define CSRATE_NOPRESENTATIONSTART      0x00000001
#define CSRATE_NOPRESENTATIONDURATION   0x00000002

typedef struct {
    CSPROPERTY      Property;
    CSRATE          Rate;
} CSRATE_CAPABILITY, *PCSRATE_CAPABILITY;

#define STATIC_CSPROPSETID_Clock \
    0xDF12A4C0L, 0xAC17, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("DF12A4C0-AC17-11CF-A5D6-28DB04C10000", CSPROPSETID_Clock);
#define CSPROPSETID_Clock DEFINE_GUIDNAMED(CSPROPSETID_Clock)

//
// Performs a x*y/z operation on 64 bit quantities by splitting the operation. The equation
// is simplified with respect to adding in the remainder for the upper 32 bits.
//
// (xh * 10000000 / Frequency) * 2^32 + ((((xh * 10000000) % Frequency) * 2^32 + (xl * 10000000)) / Frequency)
//
#define NANOSECONDS 10000000
#define CSCONVERT_PERFORMANCE_TIME(Frequency, PerformanceTime) \
    ((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS / (Frequency)) << 32) + \
    ((((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS) % (Frequency)) << 32) + \
    ((ULONGLONG)(PerformanceTime).LowPart * NANOSECONDS)) / (Frequency)))

typedef struct {
    ULONG       CreateFlags;
} CSCLOCK_CREATE, *PCSCLOCK_CREATE;

typedef struct {
    LONGLONG    Time;
    LONGLONG    SystemTime;
} CSCORRELATED_TIME, *PCSCORRELATED_TIME;

typedef struct {
    LONGLONG    Granularity;
    LONGLONG    Error;
} CSRESOLUTION, *PCSRESOLUTION;

typedef enum {
    CSPROPERTY_CLOCK_TIME,
    CSPROPERTY_CLOCK_PHYSICALTIME,
    CSPROPERTY_CLOCK_CORRELATEDTIME,
    CSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME,
    CSPROPERTY_CLOCK_RESOLUTION,
    CSPROPERTY_CLOCK_STATE,
#if defined(_NTDDK_)
    CSPROPERTY_CLOCK_FUNCTIONTABLE
#endif // defined(_NTDDK_)
} CSPROPERTY_CLOCK;

#if defined(_NTDDK_)

typedef
LONGLONG
(FASTCALL *PFNCSCLOCK_GETTIME)(
    IN PFILE_OBJECT FileObject
    );
typedef
LONGLONG
(FASTCALL *PFNCSCLOCK_CORRELATEDTIME)(
    IN PFILE_OBJECT FileObject,
    OUT PLONGLONG SystemTime);

typedef struct {
    PFNCSCLOCK_GETTIME GetTime;
    PFNCSCLOCK_GETTIME GetPhysicalTime;
    PFNCSCLOCK_CORRELATEDTIME GetCorrelatedTime;
    PFNCSCLOCK_CORRELATEDTIME GetCorrelatedPhysicalTime;
} CSCLOCK_FUNCTIONTABLE, *PCSCLOCK_FUNCTIONTABLE;

typedef
BOOLEAN
(*PFNCSSETTIMER)(
    IN PVOID Context,
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc
    );

typedef
BOOLEAN
(*PFNCSCANCELTIMER)(
    IN PVOID Context,
    IN PKTIMER Timer
    );

typedef
LONGLONG
(FASTCALL *PFNCSCORRELATEDTIME)(
    IN PVOID Context,
    OUT PLONGLONG SystemTime);

typedef PVOID   PCSDEFAULTCLOCK;

#define DEFINE_CSPROPERTY_ITEM_CLOCK_TIME(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CLOCK_TIME,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_CLOCK_PHYSICALTIME(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CLOCK_PHYSICALTIME,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CLOCK_CORRELATEDTIME,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(CSCORRELATED_TIME),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(CSCORRELATED_TIME),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_CLOCK_RESOLUTION(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CLOCK_RESOLUTION,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(CSRESOLUTION),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_CLOCK_STATE(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CLOCK_STATE,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(CSSTATE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_CLOCK_FUNCTIONTABLE,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(CSCLOCK_FUNCTIONTABLE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_CLOCCSET(ClockSet,\
    PropTime, PropPhysicalTime,\
    PropCorrelatedTime, PropCorrelatedPhysicalTime,\
    PropResolution, PropState, PropFunctionTable)\
DEFINE_CSPROPERTY_TABLE(ClockSet) {\
    DEFINE_CSPROPERTY_ITEM_CLOCK_TIME(PropTime),\
    DEFINE_CSPROPERTY_ITEM_CLOCK_PHYSICALTIME(PropPhysicalTime),\
    DEFINE_CSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(PropCorrelatedTime),\
    DEFINE_CSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(PropCorrelatedPhysicalTime),\
    DEFINE_CSPROPERTY_ITEM_CLOCK_RESOLUTION(PropResolution),\
    DEFINE_CSPROPERTY_ITEM_CLOCK_STATE(PropState),\
    DEFINE_CSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(PropFunctionTable),\
}

#endif // defined(_NTDDK_)

#define STATIC_CSEVENTSETID_Clock \
    0x364D8E20L, 0x62C7, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("364D8E20-62C7-11CF-A5D6-28DB04C10000", CSEVENTSETID_Clock);
#define CSEVENTSETID_Clock DEFINE_GUIDNAMED(CSEVENTSETID_Clock)

typedef enum {
    CSEVENT_CLOCK_INTERVAL_MARK,
    CSEVENT_CLOCK_POSITION_MARK
} CSEVENT_CLOCK_POSITION;

#define STATIC_CSEVENTSETID_Connection\
    0x7f4bcbe0L, 0x9ea5, 0x11cf, 0xa5, 0xd6, 0x28, 0xdb, 0x04, 0xc1, 0x00, 0x00
DEFINE_GUIDSTRUCT("7f4bcbe0-9ea5-11cf-a5d6-28db04c10000", CSEVENTSETID_Connection);
#define CSEVENTSETID_Connection DEFINE_GUIDNAMED(CSEVENTSETID_Connection)


#if defined(_NTDDK_)


#define CSSTREAM_READ           CSPROBE_STREAMREAD
#define CSSTREAM_WRITE          CSPROBE_STREAMWRITE
#define CSSTREAM_PAGED_DATA     0x00000000
#define CSSTREAM_NONPAGED_DATA  0x00000100
#define CSSTREAM_SYNCHRONOUS    0x00001000
#define CSSTREAM_FAILUREEXCEPTION 0x00002000

typedef
NTSTATUS
(*PFNCSHANDLER)(
//    IN PIRP Irp,
    IN PCSIDENTIFIER Request,
    IN OUT PVOID Data
    );

typedef
BOOLEAN
(*PFNCSFASTHANDLER)(
//    IN PFILE_OBJECT FileObject,
    IN PCSIDENTIFIER Request,
    IN ULONG RequestLength,
    IN OUT PVOID Data,
    IN ULONG DataLength //, 
//    OUT PIO_STATUS_BLOCK IoStatus
    );

typedef
NTSTATUS
(*PFNCSALLOCATOR)(
//    IN PIRP Irp,
    IN ULONG BufferSize,
    IN BOOLEAN InputOperation
    );
#endif 
#endif //#ifndef UNDER_CE

typedef struct {
    CSPROPERTY_MEMBERSHEADER    MembersHeader;
    const VOID*                 Members;
} CSPROPERTY_MEMBERSLIST, *PCSPROPERTY_MEMBERSLIST;

typedef struct {
    CSIDENTIFIER                    PropTypeSet;
    ULONG                           MembersListCount;
    const CSPROPERTY_MEMBERSLIST*   MembersList;
} CSPROPERTY_VALUES, *PCSPROPERTY_VALUES;

#define DEFINE_CSPROPERTY_TABLE(tablename)\
    const CSPROPERTY_ITEM tablename[] =

#ifndef UNDER_CE
#define DEFINE_CSPROPERTY_ITEM(PropertyId, GetHandler,\
                               MinProperty,\
                               MinData,\
                               SetHandler,\
                               Values, RelationsCount, Relations, SupportHandler,\
                               SerializedSize)\
{\
    PropertyId, (PFNCSHANDLER)GetHandler, MinProperty, MinData,\
    (PFNCSHANDLER)SetHandler,\
    (PCSPROPERTY_VALUES)Values, RelationsCount, (PCSPROPERTY)Relations,\
    (PFNCSHANDLER)SupportHandler, (ULONG)SerializedSize\
}
#else
#define DEFINE_CSPROPERTY_ITEM(PropertyId, GetHandler,\
                               MinProperty,\
                               MinData,\
                               SetHandler,\
                               Values, RelationsCount, Relations, SupportHandler,\
                               SerializedSize)\
{\
    PropertyId, (BOOL)GetHandler, MinProperty, MinData,\
    (BOOL)SetHandler,\
    (PCSPROPERTY_VALUES)Values, RelationsCount, (PCSPROPERTY)Relations,\
    NULL,0\
}
#endif //#ifndef UNDER_CE

typedef struct {
    ULONG                   PropertyId;
#ifndef UNDER_CE
    union {
        PFNCSHANDLER            GetPropertyHandler;
#endif //#ifndef UNDER_CE
        BOOLEAN                 GetSupported;
#ifndef UNDER_CE
    };
#endif //#ifndef UNDER_CE
    ULONG                   MinProperty;
    ULONG                   MinData;
#ifndef UNDER_CE
    union {
        PFNCSHANDLER            SetPropertyHandler;
#endif //#ifndef UNDER_CE
        BOOLEAN                 SetSupported;
#ifndef UNDER_CE
       };
#endif //#ifndef UNDER_CE
    const CSPROPERTY_VALUES*Values;
    ULONG                   RelationsCount;
    const CSPROPERTY*       Relations;
#ifndef UNDER_CE
    PFNCSHANDLER            SupportHandler;
    ULONG                   SerializedSize;
#else
    LPVOID                  Reserved1;      //Must be NULL
    ULONG                   Reserved2;      //Must be 0
#endif //#ifndef UNDER_CE
    
} CSPROPERTY_ITEM, *PCSPROPERTY_ITEM;

#ifndef UNDER_CE

typedef struct {
    ULONG                       PropertyId;
    union {
        PFNCSFASTHANDLER            GetPropertyHandler;
        BOOLEAN                     GetSupported;
    };
    union {
        PFNCSFASTHANDLER            SetPropertyHandler;
        BOOLEAN                     SetSupported;
    };
    ULONG                       Reserved;
} CSFASTPROPERTY_ITEM, *PCSFASTPROPERTY_ITEM;
#endif //#ifndef UNDER_CE

#define DEFINE_CSPROPERTY_SET(Set,\
                              PropertiesCount,\
                              PropertyItem,\
                              FastIoCount,\
                              FastIoTable)\
{\
    Set,\
    PropertiesCount,\
    PropertyItem,\
    FastIoCount,\
    FastIoTable\
}

#define DEFINE_CSPROPERTY_SET_TABLE(tablename)\
    const CSPROPERTY_SET tablename[] =

typedef struct {
    const GUID*                 Set;
    ULONG                       PropertiesCount;
    const CSPROPERTY_ITEM*      PropertyItem;
    ULONG                       FastIoCount;
#ifndef UNDER_CE
    const CSFASTPROPERTY_ITEM*  FastIoTable;
#else
    LPVOID                      Reserved;
#endif //#ifndef UNDER_CE
} CSPROPERTY_SET, *PCSPROPERTY_SET;

#ifndef UNDER_CE
#define DEFINE_CSMETHOD_TABLE(tablename)\
    const CSMETHOD_ITEM tablename[] =

#define DEFINE_CSMETHOD_ITEM(MethodId, Flags,\
                             MethodHandler,\
                             MinMethod, MinData, SupportHandler)\
{\
    MethodId, (PFNCSHANDLER)MethodHandler, MinMethod, MinData,\
    SupportHandler, Flags\
}

typedef struct {
    ULONG                   MethodId;
    union {
        PFNCSHANDLER            MethodHandler;
        BOOLEAN                 MethodSupported;
    };
    ULONG                   MinMethod;
    ULONG                   MinData;
    PFNCSHANDLER            SupportHandler;
    ULONG                   Flags;
} CSMETHOD_ITEM, *PCSMETHOD_ITEM;

#define DEFINE_CSFASTMETHOD_ITEM(MethodId, MethodHandler)\
{\
    MethodId, (PFNCSFASTHANDLER)MethodHandler\
}

typedef struct {
    ULONG                   MethodId;
    union {
        PFNCSFASTHANDLER        MethodHandler;
        BOOLEAN                 MethodSupported;
    };
} CSFASTMETHOD_ITEM, *PCSFASTMETHOD_ITEM;

#define DEFINE_CSMETHOD_SET(Set,\
                            MethodsCount,\
                            MethodItem,\
                            FastIoCount,\
                            FastIoTable)\
{\
    Set,\
    MethodsCount,\
    MethodItem,\
    FastIoCount,\
    FastIoTable\
}

#define DEFINE_CSMETHOD_SET_TABLE(tablename)\
    const CSMETHOD_SET tablename[] =

typedef struct {
    const GUID*             Set;
    ULONG                   MethodsCount;
    const CSMETHOD_ITEM*    MethodItem;
    ULONG                   FastIoCount;
    const CSFASTMETHOD_ITEM*FastIoTable;
} CSMETHOD_SET, *PCSMETHOD_SET;

typedef struct _CSEVENT_ENTRY
CSEVENT_ENTRY, *PCSEVENT_ENTRY;
#endif //#ifndef UNDER_CE


typedef enum {
    CS_ALLOCATE,
    CS_ENQUEUE,
    CS_DEALLOCATE
} BUFFER_COMMANDS;

#endif // !_CS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ctype.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma once

#include "stdlib.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\csmedia.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

/*++

Module Name:

    csmedia.h

Abstract:

    WDM-CSA Multimedia Definitions.

--*/

#if !defined(_CS_)
#error CS.H must be included before CSMEDIA.H
#endif // !defined(_CS_)

#if !defined(_CSMEDIA_)
#define _CSMEDIA_

typedef struct {
    CSPROPERTY      Property;
    CSMULTIPLE_ITEM MultipleItem;
} CSMULTIPLE_DATA_PROP, *PCSMULTIPLE_DATA_PROP;

#ifndef UNDER_CE

#define STATIC_CSMEDIUMSETID_MidiBus \
    0x05908040L, 0x3246, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("05908040-3246-11D0-A5D6-28DB04C10000", CSMEDIUMSETID_MidiBus);
#define CSMEDIUMSETID_MidiBus DEFINE_GUIDNAMED(CSMEDIUMSETID_MidiBus)

#define STATIC_CSMEDIUMSETID_VPBus \
    0xA18C15ECL, 0xCE43, 0x11D0, 0xAB, 0xE7, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("A18C15EC-CE43-11D0-ABE7-00A0C9223196", CSMEDIUMSETID_VPBus);
#define CSMEDIUMSETID_VPBus DEFINE_GUIDNAMED(CSMEDIUMSETID_VPBus)

#define STATIC_CSINTERFACESETID_Media \
    0x3A13EB40L, 0x30A7, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("3A13EB40-30A7-11D0-A5D6-28DB04C10000", CSINTERFACESETID_Media);
#define CSINTERFACESETID_Media DEFINE_GUIDNAMED(CSINTERFACESETID_Media)

typedef enum {
    CSINTERFACE_MEDIA_MUSIC,
    CSINTERFACE_MEDIA_WAVE_BUFFERED,
    CSINTERFACE_MEDIA_WAVE_QUEUED
} CSINTERFACE_MEDIA;


#if !defined(INIT_USBAUDIO_MID)
// {4e1cecd2-1679-463b-a72f-a5bf64c86eba}
#define INIT_USBAUDIO_MID(guid, id)\
{\
    (guid)->Data1 = 0x4e1cecd2 + (USHORT)(id);\
    (guid)->Data2 = 0x1679;\
    (guid)->Data3 = 0x463b;\
    (guid)->Data4[0] = 0xa7;\
    (guid)->Data4[1] = 0x2f;\
    (guid)->Data4[2] = 0xa5;\
    (guid)->Data4[3] = 0xbf;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xc8;\
    (guid)->Data4[6] = 0x6e;\
    (guid)->Data4[7] = 0xba;\
}

#define INIT_EXBUS_MANUFACTURER_ID INIT_USBAUDIO_MID

#define EXTRACT_USBAUDIO_MID(guid)\
    (USHORT)((guid)->Data1 - 0x4e1cecd2)
#define DEFINE_USBAUDIO_MID_GUID(id)\
    0x4e1cecd2+(USHORT)(id), 0x1679, 0x463b, 0xa7, 0x2f, 0xa5, 0xbf, 0x64, 0xc8, 0x6e, 0xba

#define IS_COMPATIBLE_USBAUDIO_MID(guid)\
    (((guid)->Data1 >= 0x4e1cecd2) &&\
    ((guid)->Data1 < 0x4e1cecd2 + 0xffff) &&\
    ((guid)->Data2 == 0x1679) &&\
    ((guid)->Data3 == 0x463b) &&\
    ((guid)->Data4[0] == 0xa7) &&\
    ((guid)->Data4[1] == 0x2f) &&\
    ((guid)->Data4[2] == 0xa5) &&\
    ((guid)->Data4[3] == 0xbf) &&\
    ((guid)->Data4[4] == 0x64) &&\
    ((guid)->Data4[5] == 0xc8) &&\
    ((guid)->Data4[6] == 0x6e) &&\
    ((guid)->Data4[7] == 0xba))
#endif // !defined(INIT_USBAUDIO_MID)

#if !defined(INIT_USBAUDIO_PID)
// {abcc5a5e-c263-463b-a72f-a5bf64c86eba}
#define INIT_USBAUDIO_PID(guid, id)\
{\
    (guid)->Data1 = 0xabcc5a5e + (USHORT)(id);\
    (guid)->Data2 = 0xc263;\
    (guid)->Data3 = 0x463b;\
    (guid)->Data4[0] = 0xa7;\
    (guid)->Data4[1] = 0x2f;\
    (guid)->Data4[2] = 0xa5;\
    (guid)->Data4[3] = 0xbf;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xc8;\
    (guid)->Data4[6] = 0x6e;\
    (guid)->Data4[7] = 0xba;\
}

#define INIT_EXBUS_PRODUCT_ID INIT_USBAUDIO_PID

#define EXTRACT_USBAUDIO_PID(guid)\
    (USHORT)((guid)->Data1 - 0xabcc5a5e)
#define DEFINE_USBAUDIO_PID_GUID(id)\
    0xabcc5a5e+(USHORT)(id), 0xc263, 0x463b, 0xa7, 0x2f, 0xa5, 0xbf, 0x64, 0xc8, 0x6e, 0xba

#define IS_COMPATIBLE_USBAUDIO_PID(guid)\
    (((guid)->Data1 >= 0xabcc5a5e) &&\
    ((guid)->Data1 < 0xabcc5a5e + 0xffff) &&\
    ((guid)->Data2 == 0xc263) &&\
    ((guid)->Data3 == 0x463b) &&\
    ((guid)->Data4[0] == 0xa7) &&\
    ((guid)->Data4[1] == 0x2f) &&\
    ((guid)->Data4[2] == 0xa5) &&\
    ((guid)->Data4[3] == 0xbf) &&\
    ((guid)->Data4[4] == 0x64) &&\
    ((guid)->Data4[5] == 0xc8) &&\
    ((guid)->Data4[6] == 0x6e) &&\
    ((guid)->Data4[7] == 0xba))
#endif // !defined(INIT_USBAUDIO_PID)

#if !defined(INIT_USBAUDIO_PRODUCT_NAME)
// {FC575048-2E08-463B-A72F-A5BF64C86EBA}
#define INIT_USBAUDIO_PRODUCT_NAME(guid, vid, pid, strIndex)\
{\
    (guid)->Data1 = 0XFC575048 + (USHORT)(vid);\
    (guid)->Data2 = 0x2E08     + (USHORT)(pid);\
    (guid)->Data3 = 0x463B     + (USHORT)(strIndex);\
    (guid)->Data4[0] = 0xA7;\
    (guid)->Data4[1] = 0x2F;\
    (guid)->Data4[2] = 0xA5;\
    (guid)->Data4[3] = 0xBF;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xC8;\
    (guid)->Data4[6] = 0x6E;\
    (guid)->Data4[7] = 0xBA;\
}

#define INIT_EXBUS_PRODUCT_NAME INIT_USBAUDIO_PRODUCT_NAME

#define DEFINE_USBAUDIO_PRODUCT_NAME(vid, pid, strIndex)\
    0xFC575048+(USHORT)(vid), 0x2E08+(USHORT)(pid), 0x463B+(USHORT)(strIndex), 0xA7, 0x2F, 0xA5, 0xBF, 0x64, 0xC8, 0x6E, 0xBA
#endif // !defined(INIT_USBAUDIO_PRODUCT_NAME)


// USB Audio Component ID
#define STATIC_CSCOMPONENTID_USBAUDIO \
    0x8F1275F0, 0x26E9, 0x4264, 0xBA, 0x4D, 0x39, 0xFF, 0xF0, 0x1D, 0x94, 0xAA
DEFINE_GUIDSTRUCT("8F1275F0-26E9-4264-BA4D-39FFF01D94AA", CSCOMPONENTID_USBAUDIO);
#define CSCOMPONENTID_USBAUDIO DEFINE_GUIDNAMED(CSCOMPONENTID_USBAUDIO)

// AV/C Audio Component ID
#define STATIC_CSCOMPONENTID_AVCAUDIO \
    0xc1ca31ed, 0xbe33, 0x4924, 0xa3, 0xf5, 0x53, 0x92, 0x54, 0x31, 0xf1, 0x92
DEFINE_GUIDSTRUCT("C1CA31ED-BE33-4924-A3F5-53925431F192", CSCOMPONENTID_AVCAUDIO);
#define CSCOMPONENTID_AVCAUDIO DEFINE_GUIDNAMED(CSCOMPONENTID_AVCAUDIO)

// USB Terminals
#define INIT_USB_TERMINAL(guid, id)\
{\
    (guid)->Data1 = 0xDFF219E0 + (USHORT)(id);\
    (guid)->Data2 = 0xF70F;\
    (guid)->Data3 = 0x11D0;\
    (guid)->Data4[0] = 0xb9;\
    (guid)->Data4[1] = 0x17;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_USB_TERMINAL(guid)\
    (USHORT)((guid)->Data1 - 0xDFF219E0)
#define DEFINE_USB_TERMINAL_GUID(id)\
    0xDFF219E0+(USHORT)(id), 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_CSNODETYPE_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0201)
DEFINE_GUIDSTRUCT("DFF21BE1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_MICROPHONE);
#define CSNODETYPE_MICROPHONE DEFINE_GUIDNAMED(CSNODETYPE_MICROPHONE)

#define STATIC_CSNODETYPE_DESKTOP_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0202)
DEFINE_GUIDSTRUCT("DFF21BE2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DESKTOP_MICROPHONE);
#define CSNODETYPE_DESKTOP_MICROPHONE DEFINE_GUIDNAMED(CSNODETYPE_DESKTOP_MICROPHONE)

#define STATIC_CSNODETYPE_PERSONAL_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0203)
DEFINE_GUIDSTRUCT("DFF21BE3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_PERSONAL_MICROPHONE);
#define CSNODETYPE_PERSONAL_MICROPHONE DEFINE_GUIDNAMED(CSNODETYPE_PERSONAL_MICROPHONE)

#define STATIC_CSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0204)
DEFINE_GUIDSTRUCT("DFF21BE4-F70F-11D0-B917-00A0C9223196", CSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE);
#define CSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE DEFINE_GUIDNAMED(CSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE)

#define STATIC_CSNODETYPE_MICROPHONE_ARRAY\
    DEFINE_USB_TERMINAL_GUID(0x0205)
DEFINE_GUIDSTRUCT("DFF21BE5-F70F-11D0-B917-00A0C9223196", CSNODETYPE_MICROPHONE_ARRAY);
#define CSNODETYPE_MICROPHONE_ARRAY DEFINE_GUIDNAMED(CSNODETYPE_MICROPHONE_ARRAY)

#define STATIC_CSNODETYPE_PROCESSING_MICROPHONE_ARRAY\
    DEFINE_USB_TERMINAL_GUID(0x0206)
DEFINE_GUIDSTRUCT("DFF21BE6-F70F-11D0-B917-00A0C9223196", CSNODETYPE_PROCESSING_MICROPHONE_ARRAY);
#define CSNODETYPE_PROCESSING_MICROPHONE_ARRAY DEFINE_GUIDNAMED(CSNODETYPE_PROCESSING_MICROPHONE_ARRAY)

#define STATIC_CSCATEGORY_MICROPHONE_ARRAY_PROCESSOR \
    0x830a44f2, 0xa32d, 0x476b,  0xbe, 0x97, 0x42, 0x84, 0x56, 0x73, 0xb3, 0x5a
DEFINE_GUIDSTRUCT("830a44f2-a32d-476b-be97-42845673b35a", CSCATEGORY_MICROPHONE_ARRAY_PROCESSOR);
#define CSCATEGORY_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(CSCATEGORY_MICROPHONE_ARRAY_PROCESSOR)

#define STATIC_CSNODETYPE_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0301)
DEFINE_GUIDSTRUCT("DFF21CE1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_SPEAKER);
#define CSNODETYPE_SPEAKER DEFINE_GUIDNAMED(CSNODETYPE_SPEAKER)

#define STATIC_CSNODETYPE_HEADPHONES\
    DEFINE_USB_TERMINAL_GUID(0x0302)
DEFINE_GUIDSTRUCT("DFF21CE2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_HEADPHONES);
#define CSNODETYPE_HEADPHONES DEFINE_GUIDNAMED(CSNODETYPE_HEADPHONES)

#define STATIC_CSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x0303)
DEFINE_GUIDSTRUCT("DFF21CE3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO);
#define CSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO)

#define STATIC_CSNODETYPE_DESKTOP_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0304)
DEFINE_GUIDSTRUCT("DFF21CE4-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DESKTOP_SPEAKER);
#define CSNODETYPE_DESKTOP_SPEAKER DEFINE_GUIDNAMED(CSNODETYPE_DESKTOP_SPEAKER)

#define STATIC_CSNODETYPE_ROOM_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0305)
DEFINE_GUIDSTRUCT("DFF21CE5-F70F-11D0-B917-00A0C9223196", CSNODETYPE_ROOM_SPEAKER);
#define CSNODETYPE_ROOM_SPEAKER DEFINE_GUIDNAMED(CSNODETYPE_ROOM_SPEAKER)

#define STATIC_CSNODETYPE_COMMUNICATION_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0306)
DEFINE_GUIDSTRUCT("DFF21CE6-F70F-11D0-B917-00A0C9223196", CSNODETYPE_COMMUNICATION_SPEAKER);
#define CSNODETYPE_COMMUNICATION_SPEAKER DEFINE_GUIDNAMED(CSNODETYPE_COMMUNICATION_SPEAKER)

#define STATIC_CSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0307)
DEFINE_GUIDSTRUCT("DFF21CE7-F70F-11D0-B917-00A0C9223196", CSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER);
#define CSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER DEFINE_GUIDNAMED(CSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER)

#define STATIC_CSNODETYPE_HANDSET\
    DEFINE_USB_TERMINAL_GUID(0x0401)
DEFINE_GUIDSTRUCT("DFF21DE1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_HANDSET);
#define CSNODETYPE_HANDSET DEFINE_GUIDNAMED(CSNODETYPE_HANDSET)

#define STATIC_CSNODETYPE_HEADSET\
    DEFINE_USB_TERMINAL_GUID(0x0402)
DEFINE_GUIDSTRUCT("DFF21DE2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_HEADSET);
#define CSNODETYPE_HEADSET DEFINE_GUIDNAMED(CSNODETYPE_HEADSET)

#define STATIC_CSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION\
    DEFINE_USB_TERMINAL_GUID(0x0403)
DEFINE_GUIDSTRUCT("DFF21DE3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION);
#define CSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION DEFINE_GUIDNAMED(CSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION)

#define STATIC_CSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0404)
DEFINE_GUIDSTRUCT("DFF21DE4-F70F-11D0-B917-00A0C9223196", CSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE);
#define CSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE DEFINE_GUIDNAMED(CSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE)

#define STATIC_CSNODETYPE_ECHO_CANCELING_SPEAKERPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0405)
DEFINE_GUIDSTRUCT("DFF21DE5-F70F-11D0-B917-00A0C9223196", CSNODETYPE_ECHO_CANCELING_SPEAKERPHONE);
#define CSNODETYPE_ECHO_CANCELING_SPEAKERPHONE DEFINE_GUIDNAMED(CSNODETYPE_ECHO_CANCELING_SPEAKERPHONE)

#define STATIC_CSNODETYPE_PHONE_LINE\
    DEFINE_USB_TERMINAL_GUID(0x0501)
DEFINE_GUIDSTRUCT("DFF21EE1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_PHONE_LINE);
#define CSNODETYPE_PHONE_LINE DEFINE_GUIDNAMED(CSNODETYPE_PHONE_LINE)

#define STATIC_CSNODETYPE_TELEPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0502)
DEFINE_GUIDSTRUCT("DFF21EE2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_TELEPHONE);
#define CSNODETYPE_TELEPHONE DEFINE_GUIDNAMED(CSNODETYPE_TELEPHONE)

#define STATIC_CSNODETYPE_DOWN_LINE_PHONE\
    DEFINE_USB_TERMINAL_GUID(0x0503)
DEFINE_GUIDSTRUCT("DFF21EE3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DOWN_LINE_PHONE);
#define CSNODETYPE_DOWN_LINE_PHONE DEFINE_GUIDNAMED(CSNODETYPE_DOWN_LINE_PHONE)

#define STATIC_CSNODETYPE_ANALOG_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x601)
DEFINE_GUIDSTRUCT("DFF21FE1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_ANALOG_CONNECTOR);
#define CSNODETYPE_ANALOG_CONNECTOR DEFINE_GUIDNAMED(CSNODETYPE_ANALOG_CONNECTOR)

#define STATIC_CSNODETYPE_DIGITAL_AUDIO_INTERFACE\
    DEFINE_USB_TERMINAL_GUID(0x0602)
DEFINE_GUIDSTRUCT("DFF21FE2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DIGITAL_AUDIO_INTERFACE);
#define CSNODETYPE_DIGITAL_AUDIO_INTERFACE DEFINE_GUIDNAMED(CSNODETYPE_DIGITAL_AUDIO_INTERFACE)

#define STATIC_CSNODETYPE_LINE_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x0603)
DEFINE_GUIDSTRUCT("DFF21FE3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_LINE_CONNECTOR);
#define CSNODETYPE_LINE_CONNECTOR DEFINE_GUIDNAMED(CSNODETYPE_LINE_CONNECTOR)

#define STATIC_CSNODETYPE_LEGACY_AUDIO_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x0604)
DEFINE_GUIDSTRUCT("DFF21FE4-F70F-11D0-B917-00A0C9223196", CSNODETYPE_LEGACY_AUDIO_CONNECTOR);
#define CSNODETYPE_LEGACY_AUDIO_CONNECTOR DEFINE_GUIDNAMED(CSNODETYPE_LEGACY_AUDIO_CONNECTOR)

#define STATIC_CSNODETYPE_SPDIF_INTERFACE\
    DEFINE_USB_TERMINAL_GUID(0x0605)
DEFINE_GUIDSTRUCT("DFF21FE5-F70F-11D0-B917-00A0C9223196", CSNODETYPE_SPDIF_INTERFACE);
#define CSNODETYPE_SPDIF_INTERFACE DEFINE_GUIDNAMED(CSNODETYPE_SPDIF_INTERFACE)

#define STATIC_CSNODETYPE_1394_DA_STREAM\
    DEFINE_USB_TERMINAL_GUID(0x0606)
DEFINE_GUIDSTRUCT("DFF21FE6-F70F-11D0-B917-00A0C9223196", CSNODETYPE_1394_DA_STREAM);
#define CSNODETYPE_1394_DA_STREAM DEFINE_GUIDNAMED(CSNODETYPE_1394_DA_STREAM)

#define STATIC_CSNODETYPE_1394_DV_STREAM_SOUNDTRACK\
    DEFINE_USB_TERMINAL_GUID(0x0607)
DEFINE_GUIDSTRUCT("DFF21FE7-F70F-11D0-B917-00A0C9223196", CSNODETYPE_1394_DV_STREAM_SOUNDTRACK);
#define CSNODETYPE_1394_DV_STREAM_SOUNDTRACK DEFINE_GUIDNAMED(CSNODETYPE_1394_DV_STREAM_SOUNDTRACK)

#define STATIC_CSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE\
    DEFINE_USB_TERMINAL_GUID(0x0701)
DEFINE_GUIDSTRUCT("DFF220E1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE);
#define CSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE DEFINE_GUIDNAMED(CSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE)

#define STATIC_CSNODETYPE_EQUALIZATION_NOISE\
    DEFINE_USB_TERMINAL_GUID(0x0702)
DEFINE_GUIDSTRUCT("DFF220E2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_EQUALIZATION_NOISE);
#define CSNODETYPE_EQUALIZATION_NOISE DEFINE_GUIDNAMED(CSNODETYPE_EQUALIZATION_NOISE)

#define STATIC_CSNODETYPE_CD_PLAYER\
    DEFINE_USB_TERMINAL_GUID(0x0703)
DEFINE_GUIDSTRUCT("DFF220E3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_CD_PLAYER);
#define CSNODETYPE_CD_PLAYER DEFINE_GUIDNAMED(CSNODETYPE_CD_PLAYER)

#define STATIC_CSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE\
    DEFINE_USB_TERMINAL_GUID(0x0704)
DEFINE_GUIDSTRUCT("DFF220E4-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE);
#define CSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE DEFINE_GUIDNAMED(CSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE)

#define STATIC_CSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE\
    DEFINE_USB_TERMINAL_GUID(0x0705)
DEFINE_GUIDSTRUCT("DFF220E5-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE);
#define CSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE DEFINE_GUIDNAMED(CSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE)

#define STATIC_CSNODETYPE_MINIDISK\
    DEFINE_USB_TERMINAL_GUID(0x0706)
DEFINE_GUIDSTRUCT("DFF220E6-F70F-11D0-B917-00A0C9223196", CSNODETYPE_MINIDISK);
#define CSNODETYPE_MINIDISK DEFINE_GUIDNAMED(CSNODETYPE_MINIDISK)

#define STATIC_CSNODETYPE_ANALOG_TAPE\
    DEFINE_USB_TERMINAL_GUID(0x0707)
DEFINE_GUIDSTRUCT("DFF220E7-F70F-11D0-B917-00A0C9223196", CSNODETYPE_ANALOG_TAPE);
#define CSNODETYPE_ANALOG_TAPE DEFINE_GUIDNAMED(CSNODETYPE_ANALOG_TAPE)

#define STATIC_CSNODETYPE_PHONOGRAPH\
    DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E8-F70F-11D0-B917-00A0C9223196", CSNODETYPE_PHONOGRAPH);
#define CSNODETYPE_PHONOGRAPH DEFINE_GUIDNAMED(CSNODETYPE_PHONOGRAPH)

#define STATIC_CSNODETYPE_VCR_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E9-F70F-11D0-B917-00A0C9223196", CSNODETYPE_VCR_AUDIO);
#define CSNODETYPE_VCR_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_VCR_AUDIO)

#define STATIC_CSNODETYPE_VIDEO_DISC_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070A)
DEFINE_GUIDSTRUCT("DFF220EA-F70F-11D0-B917-00A0C9223196", CSNODETYPE_VIDEO_DISC_AUDIO);
#define CSNODETYPE_VIDEO_DISC_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_VIDEO_DISC_AUDIO)

#define STATIC_CSNODETYPE_DVD_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070B)
DEFINE_GUIDSTRUCT("DFF220EB-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DVD_AUDIO);
#define CSNODETYPE_DVD_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_DVD_AUDIO)

#define STATIC_CSNODETYPE_TV_TUNER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070C)
DEFINE_GUIDSTRUCT("DFF220EC-F70F-11D0-B917-00A0C9223196", CSNODETYPE_TV_TUNER_AUDIO);
#define CSNODETYPE_TV_TUNER_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_TV_TUNER_AUDIO)

#define STATIC_CSNODETYPE_SATELLITE_RECEIVER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070D)
DEFINE_GUIDSTRUCT("DFF220ED-F70F-11D0-B917-00A0C9223196", CSNODETYPE_SATELLITE_RECEIVER_AUDIO);
#define CSNODETYPE_SATELLITE_RECEIVER_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_SATELLITE_RECEIVER_AUDIO)

#define STATIC_CSNODETYPE_CABLE_TUNER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070E)
DEFINE_GUIDSTRUCT("DFF220EE-F70F-11D0-B917-00A0C9223196", CSNODETYPE_CABLE_TUNER_AUDIO);
#define CSNODETYPE_CABLE_TUNER_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_CABLE_TUNER_AUDIO)

#define STATIC_CSNODETYPE_DSS_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070F)
DEFINE_GUIDSTRUCT("DFF220EF-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DSS_AUDIO);
#define CSNODETYPE_DSS_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_DSS_AUDIO)

#define STATIC_CSNODETYPE_RADIO_RECEIVER\
    DEFINE_USB_TERMINAL_GUID(0x0710)
DEFINE_GUIDSTRUCT("DFF220F0-F70F-11D0-B917-00A0C9223196", CSNODETYPE_RADIO_RECEIVER);
#define CSNODETYPE_RADIO_RECEIVER DEFINE_GUIDNAMED(CSNODETYPE_RADIO_RECEIVER)

#define STATIC_CSNODETYPE_RADIO_TRANSMITTER\
    DEFINE_USB_TERMINAL_GUID(0x0711)
DEFINE_GUIDSTRUCT("DFF220F1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_RADIO_TRANSMITTER);
#define CSNODETYPE_RADIO_TRANSMITTER DEFINE_GUIDNAMED(CSNODETYPE_RADIO_TRANSMITTER)

#define STATIC_CSNODETYPE_MULTITRACK_RECORDER\
    DEFINE_USB_TERMINAL_GUID(0x0712)
DEFINE_GUIDSTRUCT("DFF220F2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_MULTITRACK_RECORDER);
#define CSNODETYPE_MULTITRACK_RECORDER DEFINE_GUIDNAMED(CSNODETYPE_MULTITRACK_RECORDER)

#define STATIC_CSNODETYPE_SYNTHESIZER\
    DEFINE_USB_TERMINAL_GUID(0x0713)
DEFINE_GUIDSTRUCT("DFF220F3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_SYNTHESIZER);
#define CSNODETYPE_SYNTHESIZER DEFINE_GUIDNAMED(CSNODETYPE_SYNTHESIZER)

// USB MIDI Nodes
#define STATIC_CSNODETYPE_MIDI_JACK\
    0x265e0c3f, 0xfa39, 0x4df3, 0xab, 0x04, 0xbe, 0x01, 0xb9, 0x1e, 0x29, 0x9a
DEFINE_GUIDSTRUCT("265E0C3F-FA39-4df3-AB04-BE01B91E299A", CSNODETYPE_MIDI_JACK);
#define CSNODETYPE_MIDI_JACK DEFINE_GUIDNAMED(CSNODETYPE_MIDI_JACK)

#define STATIC_CSNODETYPE_MIDI_ELEMENT\
    0x01c6fe66, 0x6e48, 0x4c65, 0xac, 0x9b, 0x52, 0xdb, 0x5d, 0x65, 0x6c, 0x7e
DEFINE_GUIDSTRUCT("01C6FE66-6E48-4c65-AC9B-52DB5D656C7E", CSNODETYPE_MIDI_ELEMENT);
#define CSNODETYPE_MIDI_ELEMENT DEFINE_GUIDNAMED(CSNODETYPE_MIDI_ELEMENT)

// Microsoft's WDMAUD virtual swsynth pin name guid

#define STATIC_CSNODETYPE_SWSYNTH\
    0x423274A0L, 0x8B81, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("423274A0-8B81-11D1-A050-0000F8004788", CSNODETYPE_SWSYNTH);
#define CSNODETYPE_SWSYNTH DEFINE_GUIDNAMED(CSNODETYPE_SWSYNTH)

// Microsoft's SWMIDI midi pin and node name guid

#define STATIC_CSNODETYPE_SWMIDI\
    0xCB9BEFA0L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("CB9BEFA0-A251-11D1-A050-0000F8004788", CSNODETYPE_SWMIDI);
#define CSNODETYPE_SWMIDI DEFINE_GUIDNAMED(CSNODETYPE_SWMIDI)

#define STATIC_CSNODETYPE_DRM_DESCRAMBLE\
    0xFFBB6E3FL, 0xCCFE, 0x4D84, 0x90, 0xD9, 0x42, 0x14, 0x18, 0xB0, 0x3A, 0x8E
DEFINE_GUIDSTRUCT("FFBB6E3F-CCFE-4D84-90D9-421418B03A8E", CSNODETYPE_DRM_DESCRAMBLE);
#define CSNODETYPE_DRM_DESCRAMBLE DEFINE_GUIDNAMED(CSNODETYPE_DRM_DESCRAMBLE)

// General categories
#define STATIC_CSCATEGORY_AUDIO \
    0x6994AD04L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD04-93EF-11D0-A3CC-00A0C9223196", CSCATEGORY_AUDIO);
#define CSCATEGORY_AUDIO DEFINE_GUIDNAMED(CSCATEGORY_AUDIO)

#define STATIC_CSCATEGORY_VIDEO \
    0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD05-93EF-11D0-A3CC-00A0C9223196", CSCATEGORY_VIDEO);
#define CSCATEGORY_VIDEO DEFINE_GUIDNAMED(CSCATEGORY_VIDEO)

#define STATIC_CSCATEGORY_REALTIME \
    0xEB115FFCL, 0x10C8, 0x4964, 0x83, 0x1D, 0x6D, 0xCB, 0x02, 0xE6, 0xF2, 0x3F
DEFINE_GUIDSTRUCT("EB115FFC-10C8-4964-831D-6DCB02E6F23F", CSCATEGORY_REALTIME);
#define CSCATEGORY_REALTIME DEFINE_GUIDNAMED(CSCATEGORY_REALTIME)

#define STATIC_CSCATEGORY_TEXT \
    0x6994AD06L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD06-93EF-11D0-A3CC-00A0C9223196", CSCATEGORY_TEXT);
#define CSCATEGORY_TEXT DEFINE_GUIDNAMED(CSCATEGORY_TEXT)

#define STATIC_CSCATEGORY_NETWORK \
    0x67C9CC3CL, 0x69C4, 0x11D2, 0x87, 0x59, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("67C9CC3C-69C4-11D2-8759-00A0C9223196", CSCATEGORY_NETWORK);
#define CSCATEGORY_NETWORK DEFINE_GUIDNAMED(CSCATEGORY_NETWORK)

#define STATIC_CSCATEGORY_TOPOLOGY \
    0xDDA54A40L, 0x1E4C, 0x11D1, 0xA0, 0x50, 0x40, 0x57, 0x05, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("DDA54A40-1E4C-11D1-A050-405705C10000", CSCATEGORY_TOPOLOGY);
#define CSCATEGORY_TOPOLOGY DEFINE_GUIDNAMED(CSCATEGORY_TOPOLOGY)

#define STATIC_CSCATEGORY_VIRTUAL \
    0x3503EAC4L, 0x1F26, 0x11D1, 0x8A, 0xB0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("3503EAC4-1F26-11D1-8AB0-00A0C9223196", CSCATEGORY_VIRTUAL);
#define CSCATEGORY_VIRTUAL DEFINE_GUIDNAMED(CSCATEGORY_VIRTUAL)

#define STATIC_CSCATEGORY_ACOUSTIC_ECHO_CANCEL \
    0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("BF963D80-C559-11D0-8A2B-00A0C9255AC1", CSCATEGORY_ACOUSTIC_ECHO_CANCEL);
#define CSCATEGORY_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(CSCATEGORY_ACOUSTIC_ECHO_CANCEL)

#define STATIC_CSCATEGORY_SYSAUDIO \
    0xA7C7A5B1L, 0x5AF3, 0x11D1, 0x9C, 0xED, 0x00, 0xA0, 0x24, 0xBF, 0x04, 0x07
DEFINE_GUIDSTRUCT("A7C7A5B1-5AF3-11D1-9CED-00A024BF0407", CSCATEGORY_SYSAUDIO);
#define CSCATEGORY_SYSAUDIO DEFINE_GUIDNAMED(CSCATEGORY_SYSAUDIO)

#define STATIC_CSCATEGORY_WDMAUD \
    0x3E227E76L, 0x690D, 0x11D2, 0x81, 0x61, 0x00, 0x00, 0xF8, 0x77, 0x5B, 0xF1
DEFINE_GUIDSTRUCT("3E227E76-690D-11D2-8161-0000F8775BF1", CSCATEGORY_WDMAUD);
#define CSCATEGORY_WDMAUD DEFINE_GUIDNAMED(CSCATEGORY_WDMAUD)

#define STATIC_CSCATEGORY_AUDIO_GFX \
    0x9BAF9572L, 0x340C, 0x11D3, 0xAB, 0xDC, 0x00, 0xA0, 0xC9, 0x0A, 0xB1, 0x6F
DEFINE_GUIDSTRUCT("9BAF9572-340C-11D3-ABDC-00A0C90AB16F", CSCATEGORY_AUDIO_GFX);
#define CSCATEGORY_AUDIO_GFX DEFINE_GUIDNAMED(CSCATEGORY_AUDIO_GFX)

#define STATIC_CSCATEGORY_AUDIO_SPLITTER \
    0x9EA331FAL, 0xB91B, 0x45F8, 0x92, 0x85, 0xBD, 0x2B, 0xC7, 0x7A, 0xFC, 0xDE
DEFINE_GUIDSTRUCT("9EA331FA-B91B-45F8-9285-BD2BC77AFCDE", CSCATEGORY_AUDIO_SPLITTER);
#define CSCATEGORY_AUDIO_SPLITTER DEFINE_GUIDNAMED(CSCATEGORY_AUDIO_SPLITTER)

#define STATIC_CSCATEGORY_SYNTHESIZER STATIC_CSNODETYPE_SYNTHESIZER
#define CSCATEGORY_SYNTHESIZER CSNODETYPE_SYNTHESIZER

#define STATIC_CSCATEGORY_DRM_DESCRAMBLE STATIC_CSNODETYPE_DRM_DESCRAMBLE
#define CSCATEGORY_DRM_DESCRAMBLE CSNODETYPE_DRM_DESCRAMBLE

#define STATIC_CSCATEGORY_AUDIO_DEVICE \
    0xFBF6F530L, 0x07B9, 0x11D2, 0xA7, 0x1E, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("FBF6F530-07B9-11D2-A71E-0000F8004788", CSCATEGORY_AUDIO_DEVICE);
#define CSCATEGORY_AUDIO_DEVICE DEFINE_GUIDNAMED(CSCATEGORY_AUDIO_DEVICE)

#define STATIC_CSCATEGORY_PREFERRED_WAVEOUT_DEVICE \
    0xD6C5066EL, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C5066E-72C1-11D2-9755-0000F8004788", CSCATEGORY_PREFERRED_WAVEOUT_DEVICE);
#define CSCATEGORY_PREFERRED_WAVEOUT_DEVICE DEFINE_GUIDNAMED(CSCATEGORY_PREFERRED_WAVEOUT_DEVICE)

#define STATIC_CSCATEGORY_PREFERRED_WAVEIN_DEVICE \
    0xD6C50671L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C50671-72C1-11D2-9755-0000F8004788", CSCATEGORY_PREFERRED_WAVEIN_DEVICE);
#define CSCATEGORY_PREFERRED_WAVEIN_DEVICE DEFINE_GUIDNAMED(CSCATEGORY_PREFERRED_WAVEIN_DEVICE)

#define STATIC_CSCATEGORY_PREFERRED_MIDIOUT_DEVICE \
    0xD6C50674L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C50674-72C1-11D2-9755-0000F8004788", CSCATEGORY_PREFERRED_MIDIOUT_DEVICE);
#define CSCATEGORY_PREFERRED_MIDIOUT_DEVICE DEFINE_GUIDNAMED(CSCATEGORY_PREFERRED_MIDIOUT_DEVICE)

// Special pin category for wdmaud

#define STATIC_CSCATEGORY_WDMAUD_USE_PIN_NAME \
    0x47A4FA20L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("47A4FA20-A251-11D1-A050-0000F8004788", CSCATEGORY_WDMAUD_USE_PIN_NAME);
#define CSCATEGORY_WDMAUD_USE_PIN_NAME DEFINE_GUIDNAMED(CSCATEGORY_WDMAUD_USE_PIN_NAME)

// Escalante Platform Interface

#define STATIC_CSCATEGORY_ESCALANTE_PLATFORM_DRIVER \
    0x74f3aea8L, 0x9768, 0x11d1, 0x8e, 0x07, 0x00, 0xa0, 0xc9, 0x5e, 0xc2, 0x2e
DEFINE_GUIDSTRUCT("74f3aea8-9768-11d1-8e07-00a0c95ec22e", CSCATEGORY_ESCALANTE_PLATFORM_DRIVER);
#define CSCATEGORY_ESCALANTE_PLATFORM_DRIVER DEFINE_GUIDNAMED(CSCATEGORY_ESCALANTE_PLATFORM_DRIVER)

#endif //#ifndef UNDER_CE

// -- major types ---

// 'vids' == MEDIATYPE_Video,
#define STATIC_CSDATAFORMAT_TYPE_VIDEO\
    0x73646976L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73646976-0000-0010-8000-00aa00389b71", CSDATAFORMAT_TYPE_VIDEO);
#define CSDATAFORMAT_TYPE_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_VIDEO)

// 'auds' == MEDIATYPE_Audio
#define STATIC_CSDATAFORMAT_TYPE_AUDIO\
    0x73647561L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73647561-0000-0010-8000-00aa00389b71", CSDATAFORMAT_TYPE_AUDIO);
#define CSDATAFORMAT_TYPE_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_AUDIO)

#ifndef UNDER_CE

// 'txts' == MEDIATYPE_Text
#define STATIC_CSDATAFORMAT_TYPE_TEXT\
    0x73747874L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73747874-0000-0010-8000-00aa00389b71", CSDATAFORMAT_TYPE_TEXT);
#define CSDATAFORMAT_TYPE_TEXT DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_TEXT)

#if !defined( DEFINE_WAVEFORMATEX_GUID )
#define DEFINE_WAVEFORMATEX_GUID(x) (USHORT)(x), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
#endif

#define STATIC_CSDATAFORMAT_SUBTYPE_WAVEFORMATEX\
    0x00000000L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000000-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_WAVEFORMATEX);
#define CSDATAFORMAT_SUBTYPE_WAVEFORMATEX DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_WAVEFORMATEX)

#define INIT_WAVEFORMATEX_GUID(Guid, x)\
{\
    *(Guid) = CSDATAFORMAT_SUBTYPE_WAVEFORMATEX;\
    (Guid)->Data1 = (USHORT)(x);\
}

#define EXTRACT_WAVEFORMATEX_ID(Guid)\
    (USHORT)((Guid)->Data1)

#define IS_VALID_WAVEFORMATEX_GUID(Guid)\
    (!memcmp(((PUSHORT)&CSDATAFORMAT_SUBTYPE_WAVEFORMATEX) + 1, ((PUSHORT)(Guid)) + 1, sizeof(GUID) - sizeof(USHORT)))

#if !defined(INIT_MMREG_MID)
//{d5a47fa7-6d98-11d1-a21a-00a0c9223196}
#define INIT_MMREG_MID(guid, id)\
{\
    (guid)->Data1 = 0xd5a47fa7 + (USHORT)(id);\
    (guid)->Data2 = 0x6d98;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_MID(guid)\
    (USHORT)((guid)->Data1 - 0xd5a47fa7)
#define DEFINE_MMREG_MID_GUID(id)\
    0xd5a47fa7+(USHORT)(id), 0x6d98, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_MID(guid)\
    (((guid)->Data1 >= 0xd5a47fa7) &&\
    ((guid)->Data1 < 0xd5a47fa7 + 0xffff) &&\
    ((guid)->Data2 == 0x6d98) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_MID)

#if !defined(INIT_MMREG_PID)
//{e36dc2ac-6d9a-11d1-a21a-00a0c9223196}
#define INIT_MMREG_PID(guid, id)\
{\
    (guid)->Data1 = 0xe36dc2ac + (USHORT)(id);\
    (guid)->Data2 = 0x6d9a;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_PID(guid)\
    (USHORT)((guid)->Data1 - 0xe36dc2ac)
#define DEFINE_MMREG_PID_GUID(id)\
    0xe36dc2ac+(USHORT)(id), 0x6d9a, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_PID(guid)\
    (((guid)->Data1 >= 0xe36dc2ac) &&\
    ((guid)->Data1 < 0xe36dc2ac + 0xffff) &&\
    ((guid)->Data2 == 0x6d9a) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_PID)

#define STATIC_CSDATAFORMAT_SUBTYPE_ANALOG\
    0x6dba3190L, 0x67bd, 0x11cf, 0xa0, 0xf7, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("6dba3190-67bd-11cf-a0f7-0020afd156e4", CSDATAFORMAT_SUBTYPE_ANALOG);
#define CSDATAFORMAT_SUBTYPE_ANALOG DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_ANALOG)

#define STATIC_CSDATAFORMAT_SUBTYPE_PCM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_PCM)
DEFINE_GUIDSTRUCT("00000001-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_PCM);
#define CSDATAFORMAT_SUBTYPE_PCM DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_PCM)

#if defined(_INC_MMREG)
#define STATIC_CSDATAFORMAT_SUBTYPE_IEEE_FLOAT\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_IEEE_FLOAT)
DEFINE_GUIDSTRUCT("00000003-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_IEEE_FLOAT);
#define CSDATAFORMAT_SUBTYPE_IEEE_FLOAT DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_IEEE_FLOAT)

#define STATIC_CSDATAFORMAT_SUBTYPE_DRM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_DRM)
DEFINE_GUIDSTRUCT("00000009-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_DRM);
#define CSDATAFORMAT_SUBTYPE_DRM DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_DRM)

#define STATIC_CSDATAFORMAT_SUBTYPE_ALAW\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ALAW)
DEFINE_GUIDSTRUCT("00000006-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_ALAW);
#define CSDATAFORMAT_SUBTYPE_ALAW DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_ALAW)

#define STATIC_CSDATAFORMAT_SUBTYPE_MULAW\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MULAW)
DEFINE_GUIDSTRUCT("00000007-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_MULAW);
#define CSDATAFORMAT_SUBTYPE_MULAW DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MULAW)

#define STATIC_CSDATAFORMAT_SUBTYPE_ADPCM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ADPCM)
DEFINE_GUIDSTRUCT("00000002-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_ADPCM);
#define CSDATAFORMAT_SUBTYPE_ADPCM DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_ADPCM)

#endif //#ifndef UNDER_CE

#define STATIC_CSDATAFORMAT_SUBTYPE_MPEG\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MPEG)
DEFINE_GUIDSTRUCT("00000050-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_MPEG);
#define CSDATAFORMAT_SUBTYPE_MPEG DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MPEG)

#ifndef UNDER_CE
#endif // defined(_INC_MMREG)

#define STATIC_CSDATAFORMAT_SPECIFIER_VC_ID\
    0xAD98D184L, 0xAAC3, 0x11D0, 0xA4, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("AD98D184-AAC3-11D0-A41C-00A0C9223196", CSDATAFORMAT_SPECIFIER_VC_ID);
#define CSDATAFORMAT_SPECIFIER_VC_ID DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_VC_ID)

#define STATIC_CSDATAFORMAT_SPECIFIER_WAVEFORMATEX\
    0x05589f81L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f81-c356-11ce-bf01-00aa0055595a", CSDATAFORMAT_SPECIFIER_WAVEFORMATEX);
#define CSDATAFORMAT_SPECIFIER_WAVEFORMATEX DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_WAVEFORMATEX)

#define STATIC_CSDATAFORMAT_SPECIFIER_DSOUND\
    0x518590a2L, 0xa184, 0x11d0, 0x85, 0x22, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("518590a2-a184-11d0-8522-00c04fd9baf3", CSDATAFORMAT_SPECIFIER_DSOUND);
#define CSDATAFORMAT_SPECIFIER_DSOUND DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_DSOUND)

#if defined(_INC_MMSYSTEM) || defined(_INC_MMREG)
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif
typedef struct {
    CSDATAFORMAT    DataFormat;
    WAVEFORMATEX    WaveFormatEx;
} CSDATAFORMAT_WAVEFORMATEX, *PCSDATAFORMAT_WAVEFORMATEX;

#ifndef _WAVEFORMATEXTENSIBLE_
#define _WAVEFORMATEXTENSIBLE_
typedef struct {
    WAVEFORMATEX    Format;
    union {
        WORD wValidBitsPerSample;       /* bits of precision  */
        WORD wSamplesPerBlock;          /* valid if wBitsPerSample==0 */
        WORD wReserved;                 /* If neither applies, set to zero. */
    } Samples;
    DWORD           dwChannelMask;      /* which channels are */
                                        /* present in stream  */
    GUID            SubFormat;
} WAVEFORMATEXTENSIBLE, *PWAVEFORMATEXTENSIBLE;
#endif // !_WAVEFORMATEXTENSIBLE_

#if !defined(WAVE_FORMAT_EXTENSIBLE)
#define  WAVE_FORMAT_EXTENSIBLE                 0xFFFE
#endif // !defined(WAVE_FORMAT_EXTENSIBLE)

// DirectSound buffer description
typedef struct {
    ULONG               Flags;
    ULONG               Control;
    WAVEFORMATEX        WaveFormatEx;
} CSDSOUND_BUFFERDESC, *PCSDSOUND_BUFFERDESC;

// DirectSound format
typedef struct {
    CSDATAFORMAT        DataFormat;
    CSDSOUND_BUFFERDESC BufferDesc;
} CSDATAFORMAT_DSOUND, *PCSDATAFORMAT_DSOUND;

#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif
#endif // defined(_INC_MMSYSTEM) || defined(_INC_MMREG)



// DirectSound buffer flags
#define CSDSOUND_BUFFER_PRIMARY             0x00000001
#define CSDSOUND_BUFFER_STATIC              0x00000002
#define CSDSOUND_BUFFER_LOCHARDWARE         0x00000004
#define CSDSOUND_BUFFER_LOCSOFTWARE         0x00000008

// DirectSound buffer control flags
#define CSDSOUND_BUFFER_CTRL_3D             0x00000001
#define CSDSOUND_BUFFER_CTRL_FREQUENCY      0x00000002
#define CSDSOUND_BUFFER_CTRL_PAN            0x00000004
#define CSDSOUND_BUFFER_CTRL_VOLUME         0x00000008
#define CSDSOUND_BUFFER_CTRL_POSITIONNOTIFY 0x00000010

typedef struct {
#if defined(_NTDDK_)
    ULONGLONG        PlayOffset;
    ULONGLONG        WriteOffset;
#else // !_NTDDK_
    DWORDLONG        PlayOffset;
    DWORDLONG        WriteOffset;
#endif // !_NTDDK_
} CSAUDIO_POSITION, *PCSAUDIO_POSITION;

//===========================================================================
// DirectSound3D HAL


typedef struct _DS3DVECTOR {
    union {
        FLOAT x;
        FLOAT dvX;
    };
    union {
        FLOAT y;
        FLOAT dvY;
    };
    union {
        FLOAT z;
        FLOAT dvZ;
    };
} DS3DVECTOR, *PDS3DVECTOR;


//===========================================================================
//===========================================================================

// CSPROPSETID_DirectSound3DListener : {437B3414-D060-11d0-8583-00C04FD9BAF3}

#define STATIC_CSPROPSETID_DirectSound3DListener\
    0x437b3414L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("437b3414-d060-11d0-8583-00c04fd9baf3",CSPROPSETID_DirectSound3DListener);
#define CSPROPSETID_DirectSound3DListener DEFINE_GUIDNAMED(CSPROPSETID_DirectSound3DListener)

typedef enum {
    CSPROPERTY_DIRECTSOUND3DLISTENER_ALL,
    CSPROPERTY_DIRECTSOUND3DLISTENER_POSITION,
    CSPROPERTY_DIRECTSOUND3DLISTENER_VELOCITY,
    CSPROPERTY_DIRECTSOUND3DLISTENER_ORIENTATION,
    CSPROPERTY_DIRECTSOUND3DLISTENER_DISTANCEFACTOR,
    CSPROPERTY_DIRECTSOUND3DLISTENER_ROLLOFFFACTOR,
    CSPROPERTY_DIRECTSOUND3DLISTENER_DOPPLERFACTOR,
    CSPROPERTY_DIRECTSOUND3DLISTENER_BATCH,
    CSPROPERTY_DIRECTSOUND3DLISTENER_ALLOCATION
} CSPROPERTY_DIRECTSOUND3DLISTENER;

typedef struct {
    DS3DVECTOR  Position;
    DS3DVECTOR  Velocity;
    DS3DVECTOR  OrientFront;
    DS3DVECTOR  OrientTop;
    FLOAT       DistanceFactor;
    FLOAT       RolloffFactor;
    FLOAT       DopplerFactor;
} CSDS3D_LISTENER_ALL, *PCSDS3D_LISTENER_ALL;

typedef struct {
    DS3DVECTOR  Front;
    DS3DVECTOR  Top;
} CSDS3D_LISTENER_ORIENTATION, *PCSDS3D_LISTENER_ORIENTATION;


//===========================================================================
//===========================================================================
// CSPROPSETID_DirectSound3DBuffer : {437B3411-D060-11d0-8583-00C04FD9BAF3}

#define STATIC_CSPROPSETID_DirectSound3DBuffer\
    0x437b3411L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("437b3411-d060-11d0-8583-00c04fd9baf3", CSPROPSETID_DirectSound3DBuffer);
#define CSPROPSETID_DirectSound3DBuffer DEFINE_GUIDNAMED(CSPROPSETID_DirectSound3DBuffer)


typedef enum {
    CSPROPERTY_DIRECTSOUND3DBUFFER_ALL,
    CSPROPERTY_DIRECTSOUND3DBUFFER_POSITION,
    CSPROPERTY_DIRECTSOUND3DBUFFER_VELOCITY,
    CSPROPERTY_DIRECTSOUND3DBUFFER_CONEANGLES,
    CSPROPERTY_DIRECTSOUND3DBUFFER_CONEORIENTATION,
    CSPROPERTY_DIRECTSOUND3DBUFFER_CONEOUTSIDEVOLUME,
    CSPROPERTY_DIRECTSOUND3DBUFFER_MINDISTANCE,
    CSPROPERTY_DIRECTSOUND3DBUFFER_MAXDISTANCE,
    CSPROPERTY_DIRECTSOUND3DBUFFER_MODE
} CSPROPERTY_DIRECTSOUND3DBUFFER;


typedef struct {
    DS3DVECTOR  Position;
    DS3DVECTOR  Velocity;
    ULONG       InsideConeAngle;
    ULONG       OutsideConeAngle;
    DS3DVECTOR  ConeOrientation;
    LONG        ConeOutsideVolume;
    FLOAT       MinDistance;
    FLOAT       MaxDistance;
    ULONG       Mode;
} CSDS3D_BUFFER_ALL, *PCSDS3D_BUFFER_ALL;

typedef struct {
    ULONG  InsideConeAngle;
    ULONG  OutsideConeAngle;
} CSDS3D_BUFFER_CONE_ANGLES, *PCSDS3D_BUFFER_CONE_ANGLES;

#define CSAUDIO_STEREO_SPEAKER_GEOMETRY_HEADPHONE   (-1)
#define CSAUDIO_STEREO_SPEAKER_GEOMETRY_MIN         5
#define CSAUDIO_STEREO_SPEAKER_GEOMETRY_NARROW      10
#define CSAUDIO_STEREO_SPEAKER_GEOMETRY_WIDE        20
#define CSAUDIO_STEREO_SPEAKER_GEOMETRY_MAX         180

#define CSDSOUND_3D_MODE_NORMAL          0x00000000
#define CSDSOUND_3D_MODE_HEADRELATIVE    0x00000001
#define CSDSOUND_3D_MODE_DISABLE         0x00000002

//===========================================================================
// Definitions intended for hardware acceleration of the HRTF 3D algorithm
//===========================================================================

#define CSDSOUND_BUFFER_CTRL_HRTF_3D        0x40000000

typedef struct {
    ULONG                   Size;           // This is the size of the struct in bytes
    ULONG                   Enabled;
    BOOL                    SwapChannels;
    BOOL                    ZeroAzimuth;
    BOOL                    CrossFadeOutput;
    ULONG                   FilterSize;     // This is the additional size of the filter coeff in bytes
} CSDS3D_HRTF_PARAMS_MSG, *PCSDS3D_HRTF_PARAMS_MSG;

// HRTF filter quality levels
typedef enum {
    FULL_FILTER,
    LIGHT_FILTER,
    CSDS3D_FILTER_QUALITY_COUNT
} CSDS3D_HRTF_FILTER_QUALITY;

typedef struct {
    ULONG                       Size;       // This is the size of the struct in bytes
    CSDS3D_HRTF_FILTER_QUALITY  Quality;
    FLOAT                       SampleRate;
    ULONG                       MaxFilterSize;
    ULONG                       FilterTransientMuteLength;
    ULONG                       FilterOverlapBufferLength;
    ULONG                       OutputOverlapBufferLength;
    ULONG                       Reserved;
} CSDS3D_HRTF_INIT_MSG, *PCSDS3D_HRTF_INIT_MSG;

// Coefficient formats
typedef enum {
    FLOAT_COEFF,
    SHORT_COEFF,
    CSDS3D_COEFF_COUNT
} CSDS3D_HRTF_COEFF_FORMAT;

// Filter methods
typedef enum {
    DIRECT_FORM,
    CASCADE_FORM,
    CSDS3D_FILTER_METHOD_COUNT
} CSDS3D_HRTF_FILTER_METHOD;

// Filter methods
typedef enum {
    DS3D_HRTF_VERSION_1
} CSDS3D_HRTF_FILTER_VERSION;

typedef struct {
    CSDS3D_HRTF_FILTER_METHOD    FilterMethod;
    CSDS3D_HRTF_COEFF_FORMAT     CoeffFormat;
    CSDS3D_HRTF_FILTER_VERSION   Version;
    ULONG                        Reserved;
} CSDS3D_HRTF_FILTER_FORMAT_MSG, *PCSDS3D_HRTF_FILTER_FORMAT_MSG;

#define STATIC_CSPROPSETID_Hrtf3d\
    0xb66decb0L, 0xa083, 0x11d0, 0x85, 0x1e, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("b66decb0-a083-11d0-851e-00c04fd9baf3", CSPROPSETID_Hrtf3d);
#define CSPROPSETID_Hrtf3d DEFINE_GUIDNAMED(CSPROPSETID_Hrtf3d)

typedef enum {
    CSPROPERTY_HRTF3D_PARAMS = 0,
    CSPROPERTY_HRTF3D_INITIALIZE,
    CSPROPERTY_HRTF3D_FILTER_FORMAT
} CSPROPERTY_HRTF3D;


//===========================================================================
// Definitions related to the obsolete Interaural Time Delay 3D algorithm
//===========================================================================

// DirectSound3D FIR context
typedef struct {
    LONG                Channel;
    FLOAT               VolSmoothScale;
    FLOAT               TotalDryAttenuation;
    FLOAT               TotalWetAttenuation;
    LONG                SmoothFrequency;
    LONG                Delay;
} CSDS3D_ITD_PARAMS, *PCSDS3D_ITD_PARAMS;

typedef struct {
    ULONG                 Enabled;
    CSDS3D_ITD_PARAMS     LeftParams;
    CSDS3D_ITD_PARAMS     RightParams;
    ULONG                 Reserved;
} CSDS3D_ITD_PARAMS_MSG, *PCSDS3D_ITD_PARAMS_MSG;

#define STATIC_CSPROPSETID_Itd3d\
    0x6429f090L, 0x9fd9, 0x11d0, 0xa7, 0x5b, 0x00, 0xa0, 0xc9, 0x03, 0x65, 0xe3
DEFINE_GUIDSTRUCT("6429f090-9fd9-11d0-a75b-00a0c90365e3", CSPROPSETID_Itd3d);
#define CSPROPSETID_Itd3d DEFINE_GUIDNAMED(CSPROPSETID_Itd3d)

typedef enum {
    CSPROPERTY_ITD3D_PARAMS = 0
} CSPROPERTY_ITD3D;


typedef struct {
   CSDATARANGE              DataRange;
   ULONG                    MaximumChannels;
   ULONG                    MinimumBitsPerSample;
   ULONG                    MaximumBitsPerSample;
   ULONG                    MinimumSampleFrequency;
   ULONG                    MaximumSampleFrequency;
} CSDATARANGE_AUDIO, *PCSDATARANGE_AUDIO;

//---------------------------------------------------------------------------

#define STATIC_CSDATAFORMAT_SUBTYPE_RIFF\
    0x4995DAEEL, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4995DAEE-9EE6-11D0-A40E-00A0C9223196", CSDATAFORMAT_SUBTYPE_RIFF);
#define CSDATAFORMAT_SUBTYPE_RIFF DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_RIFF)

#define STATIC_CSDATAFORMAT_SUBTYPE_RIFFWAVE\
    0xe436eb8bL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb8b-524f-11ce-9f53-0020af0ba770", CSDATAFORMAT_SUBTYPE_RIFFWAVE);
#define CSDATAFORMAT_SUBTYPE_RIFFWAVE DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_RIFFWAVE)

//===========================================================================
//===========================================================================

#define STATIC_CSPROPSETID_Bibliographic \
    0x07BA150EL, 0xE2B1, 0x11D0, 0xAC, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("07BA150E-E2B1-11D0-AC17-00A0C9223196", CSPROPSETID_Bibliographic);
#define CSPROPSETID_Bibliographic DEFINE_GUIDNAMED(CSPROPSETID_Bibliographic)

//Repeatable tags contain all entries within the property, each preceeded by length
typedef enum {
    CSPROPERTY_BIBLIOGRAPHIC_LEADER = 'RDL ',
    CSPROPERTY_BIBLIOGRAPHIC_LCCN = '010 ',
    CSPROPERTY_BIBLIOGRAPHIC_ISBN = '020 ',
    CSPROPERTY_BIBLIOGRAPHIC_ISSN = '220 ',
    CSPROPERTY_BIBLIOGRAPHIC_CATALOGINGSOURCE = '040 ',
    CSPROPERTY_BIBLIOGRAPHIC_MAINPERSONALNAME = '001 ',
    CSPROPERTY_BIBLIOGRAPHIC_MAINCORPORATEBODY = '011 ',
    CSPROPERTY_BIBLIOGRAPHIC_MAINMEETINGNAME = '111 ',
    CSPROPERTY_BIBLIOGRAPHIC_MAINUNIFORMTITLE = '031 ',
    CSPROPERTY_BIBLIOGRAPHIC_UNIFORMTITLE = '042 ',
    CSPROPERTY_BIBLIOGRAPHIC_TITLESTATEMENT = '542 ',
    CSPROPERTY_BIBLIOGRAPHIC_VARYINGFORMTITLE = '642 ',
    CSPROPERTY_BIBLIOGRAPHIC_PUBLICATION = '062 ',
    CSPROPERTY_BIBLIOGRAPHIC_PHYSICALDESCRIPTION = '003 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTITLE = '044 ',
    CSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENT = '094 ',
    CSPROPERTY_BIBLIOGRAPHIC_GENERALNOTE = '005 ',
    CSPROPERTY_BIBLIOGRAPHIC_BIBLIOGRAPHYNOTE = '405 ',
    CSPROPERTY_BIBLIOGRAPHIC_CONTENTSNOTE = '505 ',
    CSPROPERTY_BIBLIOGRAPHIC_CREATIONCREDIT = '805 ',
    CSPROPERTY_BIBLIOGRAPHIC_CITATION = '015 ',
    CSPROPERTY_BIBLIOGRAPHIC_PARTICIPANT = '115 ',
    CSPROPERTY_BIBLIOGRAPHIC_SUMMARY = '025 ',
    CSPROPERTY_BIBLIOGRAPHIC_TARGETAUDIENCE = '125 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDFORMAVAILABLE = '035 ',
    CSPROPERTY_BIBLIOGRAPHIC_SYSTEMDETAILS = '835 ',
    CSPROPERTY_BIBLIOGRAPHIC_AWARDS = '685 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYPERSONALNAME = '006 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTOPICALTERM = '056 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYGEOGRAPHIC = '156 ',
    CSPROPERTY_BIBLIOGRAPHIC_INDEXTERMGENRE = '556 ',
    CSPROPERTY_BIBLIOGRAPHIC_INDEXTERMCURRICULUM = '856 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYUNIFORMTITLE = '037 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYRELATED = '047 ',
    CSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTPERSONALNAME = '008 ',
    CSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTUNIFORMTITLE = '038 '
} CSPROPERTY_BIBLIOGRAPHIC;

#define STATIC_CSPROPSETID_TopologyNode\
    0x45FFAAA1L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("45FFAAA1-6E1B-11D0-BCF2-444553540000", CSPROPSETID_TopologyNode);
#define CSPROPSETID_TopologyNode DEFINE_GUIDNAMED(CSPROPSETID_TopologyNode)

typedef enum {
    CSPROPERTY_TOPOLOGYNODE_ENABLE = 1,
    CSPROPERTY_TOPOLOGYNODE_RESET
} CSPROPERTY_TOPOLOGYNODE;

//===========================================================================

#if defined(_NTDDK_)
typedef NTSTATUS (CALLBACK *PRTAUDIOGETPOSITION)(IN PFILE_OBJECT PinFileObject,
                                                 OUT PUCHAR *ppPlayPosition,
                                                 OUT PLONG plOffset);
#endif // defined(_NTDDK_)

#define STATIC_CSPROPSETID_RtAudio\
    0xa855a48c, 0x2f78, 0x4729, 0x90, 0x51, 0x19, 0x68, 0x74, 0x6b, 0x9e, 0xef
DEFINE_GUIDSTRUCT("A855A48C-2F78-4729-9051-1968746B9EEF", CSPROPSETID_RtAudio);
#define CSPROPSETID_RtAudio DEFINE_GUIDNAMED(CSPROPSETID_RtAudio)

typedef enum {
    CSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION,
    CSPROPERTY_RTAUDIO_BUFFER
} CSPROPERTY_RTAUDIO;

typedef struct {
    PVOID   BaseAddress;
    ULONG   Size;
} RTAUDIO_BUFFER, *PRTAUDIO_BUFFER;

//===========================================================================
#define STATIC_CSPROPSETID_DrmAudioStream\
    0x2f2c8ddd, 0x4198, 0x4fac, 0xba, 0x29, 0x61, 0xbb, 0x5, 0xb7, 0xde, 0x6
DEFINE_GUIDSTRUCT("2F2C8DDD-4198-4fac-BA29-61BB05B7DE06", CSPROPSETID_DrmAudioStream);
#define CSPROPSETID_DrmAudioStream DEFINE_GUIDNAMED(CSPROPSETID_DrmAudioStream)

typedef enum {
    CSPROPERTY_DRMAUDIOSTREAM_CONTENTID
} CSPROPERTY_DRMAUDIOSTREAM;

//===========================================================================
#define STATIC_CSPROPSETID_Audio\
    0x45FFAAA0L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("45FFAAA0-6E1B-11D0-BCF2-444553540000", CSPROPSETID_Audio);
#define CSPROPSETID_Audio DEFINE_GUIDNAMED(CSPROPSETID_Audio)

typedef enum {
    CSPROPERTY_AUDIO_LATENCY = 1,
    CSPROPERTY_AUDIO_COPY_PROTECTION,
    CSPROPERTY_AUDIO_CHANNEL_CONFIG,
    CSPROPERTY_AUDIO_VOLUMELEVEL,
    CSPROPERTY_AUDIO_POSITION,
    CSPROPERTY_AUDIO_DYNAMIC_RANGE,
    CSPROPERTY_AUDIO_QUALITY,
    CSPROPERTY_AUDIO_SAMPLING_RATE,
    CSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE,
    CSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
    CSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
    CSPROPERTY_AUDIO_MUX_SOURCE,
    CSPROPERTY_AUDIO_MUTE,
    CSPROPERTY_AUDIO_BASS,
    CSPROPERTY_AUDIO_MID,
    CSPROPERTY_AUDIO_TREBLE,
    CSPROPERTY_AUDIO_BASS_BOOST,
    CSPROPERTY_AUDIO_EQ_LEVEL,
    CSPROPERTY_AUDIO_NUM_EQ_BANDS,
    CSPROPERTY_AUDIO_EQ_BANDS,
    CSPROPERTY_AUDIO_AGC,
    CSPROPERTY_AUDIO_DELAY,
    CSPROPERTY_AUDIO_LOUDNESS,
    CSPROPERTY_AUDIO_WIDE_MODE,
    CSPROPERTY_AUDIO_WIDENESS,
    CSPROPERTY_AUDIO_REVERB_LEVEL,
    CSPROPERTY_AUDIO_CHORUS_LEVEL,
    CSPROPERTY_AUDIO_DEV_SPECIFIC,
    CSPROPERTY_AUDIO_DEMUX_DEST,
    CSPROPERTY_AUDIO_STEREO_ENHANCE,
    CSPROPERTY_AUDIO_MANUFACTURE_GUID,
    CSPROPERTY_AUDIO_PRODUCT_GUID,
    CSPROPERTY_AUDIO_CPU_RESOURCES,
    CSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
    CSPROPERTY_AUDIO_SURROUND_ENCODE,
    CSPROPERTY_AUDIO_3D_INTERFACE,
    CSPROPERTY_AUDIO_PEAKMETER,
    CSPROPERTY_AUDIO_ALGORITHM_INSTANCE,
    CSPROPERTY_AUDIO_FILTER_STATE,
    CSPROPERTY_AUDIO_PREFERRED_STATUS,
    CSPROPERTY_AUDIO_PEQ_MAX_BANDS,
    CSPROPERTY_AUDIO_PEQ_NUM_BANDS,
    CSPROPERTY_AUDIO_PEQ_BAND_CENTER_FREQ,
    CSPROPERTY_AUDIO_PEQ_BAND_Q_FACTOR,
    CSPROPERTY_AUDIO_PEQ_BAND_LEVEL,
    CSPROPERTY_AUDIO_CHORUS_MODULATION_RATE,
    CSPROPERTY_AUDIO_CHORUS_MODULATION_DEPTH,
    CSPROPERTY_AUDIO_REVERB_TIME,
    CSPROPERTY_AUDIO_REVERB_DELAY_FEEDBACK
} CSPROPERTY_AUDIO;

// Audio quality constants
#define CSAUDIO_QUALITY_WORST               0x0
#define CSAUDIO_QUALITY_PC                  0x1
#define CSAUDIO_QUALITY_BASIC               0x2
#define CSAUDIO_QUALITY_ADVANCED            0x3

// Audio CPU resource constants
#define CSAUDIO_CPU_RESOURCES_NOT_HOST_CPU  0x00000000
#define CSAUDIO_CPU_RESOURCES_HOST_CPU      0x7FFFFFFF

typedef struct {
    BOOL    fCopyrighted;
    BOOL    fOriginal;
} CSAUDIO_COPY_PROTECTION, *PCSAUDIO_COPY_PROTECTION;

typedef struct {
    LONG    ActiveSpeakerPositions;
} CSAUDIO_CHANNEL_CONFIG, *PCSAUDIO_CHANNEL_CONFIG;

// Speaker Positions:
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000

// Bit mask locations reserved for future use
#define SPEAKER_RESERVED                0x7FFC0000

// Used to specify that any possible permutation of speaker configurations
#define SPEAKER_ALL                     0x80000000

// DirectSound Speaker Config
#define CSAUDIO_SPEAKER_DIRECTOUT       0
#define CSAUDIO_SPEAKER_MONO            (SPEAKER_FRONT_CENTER)
#define CSAUDIO_SPEAKER_STEREO          (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT)
#define CSAUDIO_SPEAKER_QUAD            (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_BACK_LEFT  | SPEAKER_BACK_RIGHT)
#define CSAUDIO_SPEAKER_SURROUND        (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER)
#define CSAUDIO_SPEAKER_5POINT1         (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT  | SPEAKER_BACK_RIGHT)
#define CSAUDIO_SPEAKER_7POINT1         (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | \
                                         SPEAKER_FRONT_LEFT_OF_CENTER | SPEAKER_FRONT_RIGHT_OF_CENTER)

// DVD Speaker Positions
#define CSAUDIO_SPEAKER_GROUND_FRONT_LEFT   SPEAKER_FRONT_LEFT
#define CSAUDIO_SPEAKER_GROUND_FRONT_CENTER SPEAKER_FRONT_CENTER
#define CSAUDIO_SPEAKER_GROUND_FRONT_RIGHT  SPEAKER_FRONT_RIGHT
#define CSAUDIO_SPEAKER_GROUND_REAR_LEFT    SPEAKER_BACK_LEFT
#define CSAUDIO_SPEAKER_GROUND_REAR_RIGHT   SPEAKER_BACK_RIGHT
#define CSAUDIO_SPEAKER_TOP_MIDDLE          SPEAKER_TOP_CENTER
#define CSAUDIO_SPEAKER_SUPER_WOOFER        SPEAKER_LOW_FREQUENCY

typedef struct {
    ULONG   QuietCompression;
    ULONG   LoudCompression;
} CSAUDIO_DYNAMIC_RANGE, *PCSAUDIO_DYNAMIC_RANGE;

typedef struct {
    BOOL    Mute;
    LONG    Level;
} CSAUDIO_MIXLEVEL, *PCSAUDIO_MIXLEVEL;

typedef struct {
    BOOL    Mute;
    LONG    Minimum;
    LONG    Maximum;
    union {
        LONG    Reset;
        LONG    Resolution;
    };
} CSAUDIO_MIX_CAPS, *PCSAUDIO_MIX_CAPS;

typedef struct {
    ULONG               InputChannels;
    ULONG               OutputChannels;
    CSAUDIO_MIX_CAPS    Capabilities[1];
} CSAUDIO_MIXCAP_TABLE, *PCSAUDIO_MIXCAP_TABLE;

typedef enum {
    SE_TECH_NONE,
    SE_TECH_ANALOG_DEVICES_PHAT,
    SE_TECH_CREATIVE,
    SE_TECH_NATIONAL_SEMI,
    SE_TECH_YAMAHA_YMERSION,
    SE_TECH_BBE,
    SE_TECH_CRYSTAL_SEMI,
    SE_TECH_QSOUND_QXPANDER,
    SE_TECH_SPATIALIZER,
    SE_TECH_SRS,
    SE_TECH_PLATFORM_TECH,
    SE_TECH_AKM,
    SE_TECH_AUREAL,
    SE_TECH_AZTECH,
    SE_TECH_BINAURA,
    SE_TECH_ESS_TECH,
    SE_TECH_HARMAN_VMAX,
    SE_TECH_NVIDEA,
    SE_TECH_PHILIPS_INCREDIBLE,
    SE_TECH_TEXAS_INST,
    SE_TECH_VLSI_TECH
} SE_TECHNIQUE;

typedef struct {
    SE_TECHNIQUE    Technique;
    ULONG   Center;
    ULONG   Depth;
    ULONG   Reserved;
} CSAUDIO_STEREO_ENHANCE, *PCSAUDIO_STEREO_ENHANCE;

typedef enum {              // preferred device index
    CSPROPERTY_SYSAUDIO_NORMAL_DEFAULT = 0,
    CSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT,
    CSPROPERTY_SYSAUDIO_RECORD_DEFAULT,
    CSPROPERTY_SYSAUDIO_MIDI_DEFAULT,
    CSPROPERTY_SYSAUDIO_MIXER_DEFAULT
} CSPROPERTY_SYSAUDIO_DEFAULT_TYPE;

typedef struct {
    BOOL                             Enable;
    CSPROPERTY_SYSAUDIO_DEFAULT_TYPE DeviceType;
    ULONG                            Flags;
    ULONG                            Reserved;
} CSAUDIO_PREFERRED_STATUS, *PCSAUDIO_PREFERRED_STATUS;
//===========================================================================
// Topology Node Type GUIDs

#define STATIC_CSNODETYPE_DAC\
    0x507AE360L, 0xC554, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("507AE360-C554-11D0-8A2B-00A0C9255AC1", CSNODETYPE_DAC);
#define CSNODETYPE_DAC DEFINE_GUIDNAMED(CSNODETYPE_DAC)

#define STATIC_CSNODETYPE_ADC\
    0x4D837FE0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("4D837FE0-C555-11D0-8A2B-00A0C9255AC1", CSNODETYPE_ADC);
#define CSNODETYPE_ADC DEFINE_GUIDNAMED(CSNODETYPE_ADC)

#define STATIC_CSNODETYPE_SRC\
    0x9DB7B9E0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("9DB7B9E0-C555-11D0-8A2B-00A0C9255AC1", CSNODETYPE_SRC);
#define CSNODETYPE_SRC DEFINE_GUIDNAMED(CSNODETYPE_SRC)

#define STATIC_CSNODETYPE_SUPERMIX\
    0xE573ADC0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("E573ADC0-C555-11D0-8A2B-00A0C9255AC1", CSNODETYPE_SUPERMIX);
#define CSNODETYPE_SUPERMIX DEFINE_GUIDNAMED(CSNODETYPE_SUPERMIX)

#define STATIC_CSNODETYPE_MUX\
    0x2CEAF780L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("2CEAF780-C556-11D0-8A2B-00A0C9255AC1", CSNODETYPE_MUX);
#define CSNODETYPE_MUX DEFINE_GUIDNAMED(CSNODETYPE_MUX)

#define STATIC_CSNODETYPE_DEMUX\
    0xC0EB67D4L, 0xE807, 0x11D0, 0x95, 0x8A, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("C0EB67D4-E807-11D0-958A-00C04FB925D3", CSNODETYPE_DEMUX);
#define CSNODETYPE_DEMUX DEFINE_GUIDNAMED(CSNODETYPE_DEMUX)

#define STATIC_CSNODETYPE_SUM\
    0xDA441A60L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("DA441A60-C556-11D0-8A2B-00A0C9255AC1", CSNODETYPE_SUM);
#define CSNODETYPE_SUM DEFINE_GUIDNAMED(CSNODETYPE_SUM)

#define STATIC_CSNODETYPE_MUTE\
    0x02B223C0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("02B223C0-C557-11D0-8A2B-00A0C9255AC1", CSNODETYPE_MUTE);
#define CSNODETYPE_MUTE DEFINE_GUIDNAMED(CSNODETYPE_MUTE)

#define STATIC_CSNODETYPE_VOLUME\
    0x3A5ACC00L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("3A5ACC00-C557-11D0-8A2B-00A0C9255AC1", CSNODETYPE_VOLUME);
#define CSNODETYPE_VOLUME DEFINE_GUIDNAMED(CSNODETYPE_VOLUME)

#define STATIC_CSNODETYPE_TONE\
    0x7607E580L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("7607E580-C557-11D0-8A2B-00A0C9255AC1", CSNODETYPE_TONE);
#define CSNODETYPE_TONE DEFINE_GUIDNAMED(CSNODETYPE_TONE)

#define STATIC_CSNODETYPE_EQUALIZER\
    0x9D41B4A0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("9D41B4A0-C557-11D0-8A2B-00A0C9255AC1", CSNODETYPE_EQUALIZER);
#define CSNODETYPE_EQUALIZER DEFINE_GUIDNAMED(CSNODETYPE_EQUALIZER)

#define STATIC_CSNODETYPE_AGC\
    0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("E88C9BA0-C557-11D0-8A2B-00A0C9255AC1", CSNODETYPE_AGC);
#define CSNODETYPE_AGC DEFINE_GUIDNAMED(CSNODETYPE_AGC)

#define STATIC_CSNODETYPE_NOISE_SUPPRESS\
    0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5
DEFINE_GUIDSTRUCT("E07F903F-62FD-4e60-8CDD-DEA7236665B5", CSNODETYPE_NOISE_SUPPRESS);
#define CSNODETYPE_NOISE_SUPPRESS DEFINE_GUIDNAMED(CSNODETYPE_NOISE_SUPPRESS)

#define STATIC_CSNODETYPE_DELAY\
    0x144981E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("144981E0-C558-11D0-8A2B-00A0C9255AC1", CSNODETYPE_DELAY);
#define CSNODETYPE_DELAY DEFINE_GUIDNAMED(CSNODETYPE_DELAY)

#define STATIC_CSNODETYPE_LOUDNESS\
    0x41887440L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("41887440-C558-11D0-8A2B-00A0C9255AC1", CSNODETYPE_LOUDNESS);
#define CSNODETYPE_LOUDNESS DEFINE_GUIDNAMED(CSNODETYPE_LOUDNESS)

#define STATIC_CSNODETYPE_PROLOGIC_DECODER\
    0x831C2C80L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("831C2C80-C558-11D0-8A2B-00A0C9255AC1", CSNODETYPE_PROLOGIC_DECODER);
#define CSNODETYPE_PROLOGIC_DECODER DEFINE_GUIDNAMED(CSNODETYPE_PROLOGIC_DECODER)

#define STATIC_CSNODETYPE_STEREO_WIDE\
    0xA9E69800L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("A9E69800-C558-11D0-8A2B-00A0C9255AC1", CSNODETYPE_STEREO_WIDE);
#define CSNODETYPE_STEREO_WIDE DEFINE_GUIDNAMED(CSNODETYPE_STEREO_WIDE)

#define STATIC_CSNODETYPE_STEREO_ENHANCE\
    0xAF6878ACL, 0xE83F, 0x11D0, 0x95, 0x8A, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("AF6878AC-E83F-11D0-958A-00C04FB925D3", CSNODETYPE_STEREO_ENHANCE);
#define CSNODETYPE_STEREO_ENHANCE DEFINE_GUIDNAMED(CSNODETYPE_STEREO_ENHANCE)

#define STATIC_CSNODETYPE_REVERB\
    0xEF0328E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("EF0328E0-C558-11D0-8A2B-00A0C9255AC1", CSNODETYPE_REVERB);
#define CSNODETYPE_REVERB DEFINE_GUIDNAMED(CSNODETYPE_REVERB)

#define STATIC_CSNODETYPE_CHORUS\
    0x20173F20L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("20173F20-C559-11D0-8A2B-00A0C9255AC1", CSNODETYPE_CHORUS);
#define CSNODETYPE_CHORUS DEFINE_GUIDNAMED(CSNODETYPE_CHORUS)

#define STATIC_CSNODETYPE_3D_EFFECTS\
    0x55515860L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("55515860-C559-11D0-8A2B-00A0C9255AC1", CSNODETYPE_3D_EFFECTS);
#define CSNODETYPE_3D_EFFECTS DEFINE_GUIDNAMED(CSNODETYPE_3D_EFFECTS)

#define STATIC_CSNODETYPE_PARAMETRIC_EQUALIZER\
    0x19bb3a6a, 0xce2b, 0x4442, 0x87, 0xec, 0x67, 0x27, 0xc3, 0xca, 0xb4, 0x77
DEFINE_GUIDSTRUCT("19BB3A6A-CE2B-4442-87EC-6727C3CAB477", CSNODETYPE_PARAMETRIC_EQUALIZER);
#define CSNODETYPE_PARAMETRIC_EQUALIZER DEFINE_GUIDNAMED(CSNODETYPE_PARAMETRIC_EQUALIZER)

#define STATIC_CSNODETYPE_UPDOWN_MIX\
    0xb7edc5cf, 0x7b63, 0x4ee2, 0xa1, 0x0, 0x29, 0xee, 0x2c, 0xb6, 0xb2, 0xde
DEFINE_GUIDSTRUCT("B7EDC5CF-7B63-4ee2-A100-29EE2CB6B2DE", CSNODETYPE_UPDOWN_MIX);
#define CSNODETYPE_UPDOWN_MIX DEFINE_GUIDNAMED(CSNODETYPE_UPDOWN_MIX)

#define STATIC_CSNODETYPE_DYN_RANGE_COMPRESSOR\
    0x8c8a6a8, 0x601f, 0x4af8, 0x87, 0x93, 0xd9, 0x5, 0xff, 0x4c, 0xa9, 0x7d
DEFINE_GUIDSTRUCT("08C8A6A8-601F-4af8-8793-D905FF4CA97D", CSNODETYPE_DYN_RANGE_COMPRESSOR);
#define CSNODETYPE_DYN_RANGE_COMPRESSOR DEFINE_GUIDNAMED(CSNODETYPE_DYN_RANGE_COMPRESSOR)

#define STATIC_CSNODETYPE_ACOUSTIC_ECHO_CANCEL STATIC_CSCATEGORY_ACOUSTIC_ECHO_CANCEL
#define CSNODETYPE_ACOUSTIC_ECHO_CANCEL CSCATEGORY_ACOUSTIC_ECHO_CANCEL

#define STATIC_CSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL\
    0x1c22c56dL, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10
DEFINE_GUIDSTRUCT("1C22C56D-9879-4f5b-A389-27996DDC2810", CSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL);
#define CSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(CSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL)

#define STATIC_CSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS\
    0x5ab0882eL, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0
DEFINE_GUIDSTRUCT("5AB0882E-7274-4516-877D-4EEE99BA4FD0", CSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS);
#define CSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS DEFINE_GUIDNAMED(CSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS)

#define STATIC_CSALGORITHMINSTANCE_SYSTEM_AGC\
    0x950e55b9L, 0x877c, 0x4c67, 0xbe, 0x8, 0xe4, 0x7b, 0x56, 0x11, 0x13, 0xa
DEFINE_GUIDSTRUCT("950E55B9-877C-4c67-BE08-E47B5611130A", CSALGORITHMINSTANCE_SYSTEM_AGC);
#define CSALGORITHMINSTANCE_SYSTEM_AGC DEFINE_GUIDNAMED(CSALGORITHMINSTANCE_SYSTEM_AGC)

#define STATIC_CSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR\
    0xB6F5A0A0L, 0x9E61, 0x4F8C, 0x91, 0xE3, 0x76, 0xCF, 0xF, 0x3C, 0x47, 0x1F
DEFINE_GUIDSTRUCT("B6F5A0A0-9E61-4f8c-91E3-76CF0F3C471F", CSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR);
#define CSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(CSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR)


#define STATIC_CSNODETYPE_MICROPHONE_ARRAY_PROCESSOR STATIC_CSCATEGORY_MICROPHONE_ARRAY_PROCESSOR
#define CSNODETYPE_MICROPHONE_ARRAY_PROCESSOR CSCATEGORY_MICROPHONE_ARRAY_PROCESSOR

#define STATIC_CSNODETYPE_DEV_SPECIFIC\
    0x941C7AC0L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("941C7AC0-C559-11D0-8A2B-00A0C9255AC1", CSNODETYPE_DEV_SPECIFIC);
#define CSNODETYPE_DEV_SPECIFIC DEFINE_GUIDNAMED(CSNODETYPE_DEV_SPECIFIC)

#define STATIC_CSNODETYPE_PROLOGIC_ENCODER\
    0x8074C5B2L, 0x3C66, 0x11D2, 0xB4, 0x5A, 0x30, 0x78, 0x30, 0x2C, 0x20, 0x30
DEFINE_GUIDSTRUCT("8074C5B2-3C66-11D2-B45A-3078302C2030", CSNODETYPE_PROLOGIC_ENCODER);
#define CSNODETYPE_PROLOGIC_ENCODER DEFINE_GUIDNAMED(CSNODETYPE_PROLOGIC_ENCODER)
#define CSNODETYPE_SURROUND_ENCODER CSNODETYPE_PROLOGIC_ENCODER

#define STATIC_CSNODETYPE_PEAKMETER\
    0xa085651eL, 0x5f0d, 0x4b36, 0xa8, 0x69, 0xd1, 0x95, 0xd6, 0xab, 0x4b, 0x9e
DEFINE_GUIDSTRUCT("A085651E-5F0D-4b36-A869-D195D6AB4B9E", CSNODETYPE_PEAKMETER);
#define CSNODETYPE_PEAKMETER DEFINE_GUIDNAMED(CSNODETYPE_PEAKMETER)

//===========================================================================
// Topology Node Name GUIDs for common audio nodes
#define STATIC_CSAUDFNAME_BASS\
    0x185FEDE0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE0-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_BASS);
#define CSAUDFNAME_BASS DEFINE_GUIDNAMED(CSAUDFNAME_BASS)

#define STATIC_CSAUDFNAME_TREBLE\
    0x185FEDE1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE1-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_TREBLE);
#define CSAUDFNAME_TREBLE DEFINE_GUIDNAMED(CSAUDFNAME_TREBLE)

#define STATIC_CSAUDFNAME_3D_STEREO\
    0x185FEDE2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE2-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_3D_STEREO);
#define CSAUDFNAME_3D_STEREO DEFINE_GUIDNAMED(CSAUDFNAME_3D_STEREO)

#define STATIC_CSAUDFNAME_MASTER_VOLUME\
    0x185FEDE3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE3-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MASTER_VOLUME);
#define CSAUDFNAME_MASTER_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MASTER_VOLUME)

#define STATIC_CSAUDFNAME_MASTER_MUTE\
    0x185FEDE4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE4-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MASTER_MUTE);
#define CSAUDFNAME_MASTER_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_MASTER_MUTE)

#define STATIC_CSAUDFNAME_WAVE_VOLUME\
    0x185FEDE5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE5-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_WAVE_VOLUME);
#define CSAUDFNAME_WAVE_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_WAVE_VOLUME)

#define STATIC_CSAUDFNAME_WAVE_MUTE\
    0x185FEDE6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE6-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_WAVE_MUTE);
#define CSAUDFNAME_WAVE_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_WAVE_MUTE)

#define STATIC_CSAUDFNAME_MIDI_VOLUME\
    0x185FEDE7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE7-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIDI_VOLUME);
#define CSAUDFNAME_MIDI_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MIDI_VOLUME)

#define STATIC_CSAUDFNAME_MIDI_MUTE\
    0x185FEDE8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE8-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIDI_MUTE);
#define CSAUDFNAME_MIDI_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_MIDI_MUTE)

#define STATIC_CSAUDFNAME_CD_VOLUME\
    0x185FEDE9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE9-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_CD_VOLUME);
#define CSAUDFNAME_CD_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_CD_VOLUME)

#define STATIC_CSAUDFNAME_CD_MUTE\
    0x185FEDEAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEA-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_CD_MUTE);
#define CSAUDFNAME_CD_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_CD_MUTE)

#define STATIC_CSAUDFNAME_LINE_VOLUME\
    0x185FEDEBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEB-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_LINE_VOLUME);
#define CSAUDFNAME_LINE_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_LINE_VOLUME)

#define STATIC_CSAUDFNAME_LINE_MUTE\
    0x185FEDECL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEC-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_LINE_MUTE);
#define CSAUDFNAME_LINE_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_LINE_MUTE)

#define STATIC_CSAUDFNAME_MIC_VOLUME\
    0x185FEDEDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDED-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIC_VOLUME);
#define CSAUDFNAME_MIC_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MIC_VOLUME)

#define STATIC_CSAUDFNAME_MIC_MUTE\
    0x185FEDEEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEE-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIC_MUTE);
#define CSAUDFNAME_MIC_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_MIC_MUTE)

#define STATIC_CSAUDFNAME_RECORDING_SOURCE\
    0x185FEDEFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEF-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_RECORDING_SOURCE);
#define CSAUDFNAME_RECORDING_SOURCE DEFINE_GUIDNAMED(CSAUDFNAME_RECORDING_SOURCE)

#define STATIC_CSAUDFNAME_PC_SPEAKER_VOLUME\
    0x185FEDF0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF0-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_PC_SPEAKER_VOLUME);
#define CSAUDFNAME_PC_SPEAKER_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_PC_SPEAKER_VOLUME)

#define STATIC_CSAUDFNAME_PC_SPEAKER_MUTE\
    0x185FEDF1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF1-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_PC_SPEAKER_MUTE);
#define CSAUDFNAME_PC_SPEAKER_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_PC_SPEAKER_MUTE)

#define STATIC_CSAUDFNAME_MIDI_IN_VOLUME\
    0x185FEDF2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF2-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIDI_IN_VOLUME);
#define CSAUDFNAME_MIDI_IN_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MIDI_IN_VOLUME)

#define STATIC_CSAUDFNAME_CD_IN_VOLUME\
    0x185FEDF3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF3-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_CD_IN_VOLUME);
#define CSAUDFNAME_CD_IN_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_CD_IN_VOLUME)

#define STATIC_CSAUDFNAME_LINE_IN_VOLUME\
    0x185FEDF4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF4-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_LINE_IN_VOLUME);
#define CSAUDFNAME_LINE_IN_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_LINE_IN_VOLUME)

#define STATIC_CSAUDFNAME_MIC_IN_VOLUME\
    0x185FEDF5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF5-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIC_IN_VOLUME);
#define CSAUDFNAME_MIC_IN_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MIC_IN_VOLUME)

#define STATIC_CSAUDFNAME_WAVE_IN_VOLUME\
    0x185FEDF6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF6-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_WAVE_IN_VOLUME);
#define CSAUDFNAME_WAVE_IN_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_WAVE_IN_VOLUME)

#define STATIC_CSAUDFNAME_VOLUME_CONTROL\
    0x185FEDF7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF7-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_VOLUME_CONTROL);
#define CSAUDFNAME_VOLUME_CONTROL DEFINE_GUIDNAMED(CSAUDFNAME_VOLUME_CONTROL)

#define STATIC_CSAUDFNAME_MIDI\
    0x185FEDF8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF8-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIDI);
#define CSAUDFNAME_MIDI DEFINE_GUIDNAMED(CSAUDFNAME_MIDI)

#define STATIC_CSAUDFNAME_LINE_IN\
    0x185FEDF9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF9-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_LINE_IN);
#define CSAUDFNAME_LINE_IN DEFINE_GUIDNAMED(CSAUDFNAME_LINE_IN)

#define STATIC_CSAUDFNAME_RECORDING_CONTROL\
    0x185FEDFAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFA-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_RECORDING_CONTROL);
#define CSAUDFNAME_RECORDING_CONTROL DEFINE_GUIDNAMED(CSAUDFNAME_RECORDING_CONTROL)

#define STATIC_CSAUDFNAME_CD_AUDIO\
    0x185FEDFBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFB-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_CD_AUDIO);
#define CSAUDFNAME_CD_AUDIO DEFINE_GUIDNAMED(CSAUDFNAME_CD_AUDIO)

#define STATIC_CSAUDFNAME_AUX_VOLUME\
    0x185FEDFCL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFC-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_AUX_VOLUME);
#define CSAUDFNAME_AUX_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_AUX_VOLUME)

#define STATIC_CSAUDFNAME_AUX_MUTE\
    0x185FEDFDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFD-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_AUX_MUTE);
#define CSAUDFNAME_AUX_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_AUX_MUTE)

#define STATIC_CSAUDFNAME_AUX\
    0x185FEDFEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFE-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_AUX);
#define CSAUDFNAME_AUX DEFINE_GUIDNAMED(CSAUDFNAME_AUX)

#define STATIC_CSAUDFNAME_PC_SPEAKER\
    0x185FEDFFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFF-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_PC_SPEAKER);
#define CSAUDFNAME_PC_SPEAKER DEFINE_GUIDNAMED(CSAUDFNAME_PC_SPEAKER)

#define STATIC_CSAUDFNAME_WAVE_OUT_MIX\
    0x185FEE00L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEE00-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_WAVE_OUT_MIX);
#define CSAUDFNAME_WAVE_OUT_MIX DEFINE_GUIDNAMED(CSAUDFNAME_WAVE_OUT_MIX)

#define STATIC_CSAUDFNAME_MONO_OUT\
    0xf9b41dc3L, 0x96e2, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("F9B41DC3-96E2-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MONO_OUT);
#define CSAUDFNAME_MONO_OUT DEFINE_GUIDNAMED(CSAUDFNAME_MONO_OUT)

#define STATIC_CSAUDFNAME_STEREO_MIX\
    0xdff077L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("00DFF077-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_STEREO_MIX);
#define CSAUDFNAME_STEREO_MIX DEFINE_GUIDNAMED(CSAUDFNAME_STEREO_MIX)

#define STATIC_CSAUDFNAME_MONO_MIX\
    0xdff078L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("00DFF078-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MONO_MIX);
#define CSAUDFNAME_MONO_MIX DEFINE_GUIDNAMED(CSAUDFNAME_MONO_MIX)

#define STATIC_CSAUDFNAME_MONO_OUT_VOLUME\
    0x1ad247ebL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247EB-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MONO_OUT_VOLUME);
#define CSAUDFNAME_MONO_OUT_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MONO_OUT_VOLUME)

#define STATIC_CSAUDFNAME_MONO_OUT_MUTE\
    0x1ad247ecL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247EC-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MONO_OUT_MUTE);
#define CSAUDFNAME_MONO_OUT_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_MONO_OUT_MUTE)

#define STATIC_CSAUDFNAME_STEREO_MIX_VOLUME\
    0x1ad247edL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247ED-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_STEREO_MIX_VOLUME);
#define CSAUDFNAME_STEREO_MIX_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_STEREO_MIX_VOLUME)

#define STATIC_CSAUDFNAME_STEREO_MIX_MUTE\
    0x22b0eafdL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("22B0EAFD-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_STEREO_MIX_MUTE);
#define CSAUDFNAME_STEREO_MIX_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_STEREO_MIX_MUTE)

#define STATIC_CSAUDFNAME_MONO_MIX_VOLUME\
    0x22b0eafeL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("22B0EAFE-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MONO_MIX_VOLUME);
#define CSAUDFNAME_MONO_MIX_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MONO_MIX_VOLUME)

#define STATIC_CSAUDFNAME_MONO_MIX_MUTE\
    0x2bc31d69L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D69-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MONO_MIX_MUTE);
#define CSAUDFNAME_MONO_MIX_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_MONO_MIX_MUTE)

#define STATIC_CSAUDFNAME_MICROPHONE_BOOST\
    0x2bc31d6aL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D6A-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MICROPHONE_BOOST);
#define CSAUDFNAME_MICROPHONE_BOOST DEFINE_GUIDNAMED(CSAUDFNAME_MICROPHONE_BOOST)

#define STATIC_CSAUDFNAME_ALTERNATE_MICROPHONE\
    0x2bc31d6bL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D6B-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_ALTERNATE_MICROPHONE);
#define CSAUDFNAME_ALTERNATE_MICROPHONE DEFINE_GUIDNAMED(CSAUDFNAME_ALTERNATE_MICROPHONE)

#define STATIC_CSAUDFNAME_3D_DEPTH\
    0x63ff5747L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("63FF5747-991F-11d2-AC4D-00C04F8EFB68", CSAUDFNAME_3D_DEPTH);
#define CSAUDFNAME_3D_DEPTH DEFINE_GUIDNAMED(CSAUDFNAME_3D_DEPTH)

#define STATIC_CSAUDFNAME_3D_CENTER\
    0x9f0670b4L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9F0670B4-991F-11d2-AC4D-00C04F8EFB68", CSAUDFNAME_3D_CENTER);
#define CSAUDFNAME_3D_CENTER DEFINE_GUIDNAMED(CSAUDFNAME_3D_CENTER)

#define STATIC_CSAUDFNAME_VIDEO_VOLUME\
    0x9b46e708L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9B46E708-992A-11d2-AC4D-00C04F8EFB68", CSAUDFNAME_VIDEO_VOLUME);
#define CSAUDFNAME_VIDEO_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_VIDEO_VOLUME)

#define STATIC_CSAUDFNAME_VIDEO_MUTE\
    0x9b46e709L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9B46E709-992A-11d2-AC4D-00C04F8EFB68", CSAUDFNAME_VIDEO_MUTE);
#define CSAUDFNAME_VIDEO_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_VIDEO_MUTE)

#define STATIC_CSAUDFNAME_VIDEO\
    0x915daec4L, 0xa434, 0x11d2, 0xac, 0x52, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("915DAEC4-A434-11d2-AC52-00C04F8EFB68", CSAUDFNAME_VIDEO);
#define CSAUDFNAME_VIDEO DEFINE_GUIDNAMED(CSAUDFNAME_VIDEO)

#define STATIC_CSAUDFNAME_PEAKMETER\
    0x57e24340L, 0xfc5b, 0x4612, 0xa5, 0x62, 0x72, 0xb1, 0x1a, 0x29, 0xdf, 0xae
DEFINE_GUIDSTRUCT("57E24340-FC5B-4612-A562-72B11A29DFAE", CSAUDFNAME_PEAKMETER);
#define CSAUDFNAME_PEAKMETER DEFINE_GUIDNAMED(CSAUDFNAME_PEAKMETER)

// Internal topology node pin definitions

#define CSNODEPIN_STANDARD_IN       1
#define CSNODEPIN_STANDARD_OUT      0

#define CSNODEPIN_SUM_MUX_IN        1   // can be >= 1
#define CSNODEPIN_SUM_MUX_OUT       0

#define CSNODEPIN_DEMUX_IN          0
#define CSNODEPIN_DEMUX_OUT         1   // can be >= 1

#define CSNODEPIN_AEC_RENDER_IN     1
#define CSNODEPIN_AEC_RENDER_OUT    0
#define CSNODEPIN_AEC_CAPTURE_IN    2
#define CSNODEPIN_AEC_CAPTURE_OUT   3

//===========================================================================
//===========================================================================

#define STATIC_CSMETHODSETID_Wavetable\
    0xDCEF31EBL, 0xD907, 0x11D0, 0x95, 0x83, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("DCEF31EB-D907-11D0-9583-00C04FB925D3", CSMETHODSETID_Wavetable);
#define CSMETHODSETID_Wavetable DEFINE_GUIDNAMED(CSMETHODSETID_Wavetable)

typedef enum {
    CSMETHOD_WAVETABLE_WAVE_ALLOC,
    CSMETHOD_WAVETABLE_WAVE_FREE,
    CSMETHOD_WAVETABLE_WAVE_FIND,
    CSMETHOD_WAVETABLE_WAVE_WRITE
} CSMETHOD_WAVETABLE;

typedef struct {
    CSIDENTIFIER        Identifier;                     // wave identifier
    ULONG               Size;                           // wave size
    BOOL                Looped;                         // wave looped flag
    ULONG               LoopPoint;                      // wave loop point
    BOOL                InROM;                          // wave InROM flag
    CSDATAFORMAT        Format;                         // wave format
} CSWAVETABLE_WAVE_DESC, *PCSWAVETABLE_WAVE_DESC;


//===========================================================================
//===========================================================================

/*
    Property sets and items
*/

//===========================================================================
//===========================================================================

#define STATIC_CSPROPSETID_Acoustic_Echo_Cancel\
    0xd7a4af8bL, 0x3dc1, 0x4902, 0x91, 0xea, 0x8a, 0x15, 0xc9, 0x0e, 0x05, 0xb2
DEFINE_GUIDSTRUCT("D7A4AF8B-3DC1-4902-91EA-8A15C90E05B2", CSPROPSETID_Acoustic_Echo_Cancel);
#define CSPROPSETID_Acoustic_Echo_Cancel DEFINE_GUIDNAMED(CSPROPSETID_Acoustic_Echo_Cancel)

typedef enum {
    CSPROPERTY_AEC_NOISE_FILL_ENABLE = 0,
    CSPROPERTY_AEC_STATUS,
    CSPROPERTY_AEC_MODE
} CSPROPERTY_AEC;

#define AEC_STATUS_FD_HISTORY_UNINITIALIZED             0x0
#define AEC_STATUS_FD_HISTORY_CONTINUOUSLY_CONVERGED    0x1
#define AEC_STATUS_FD_HISTORY_PREVIOUSLY_DIVERGED       0x2
#define AEC_STATUS_FD_CURRENTLY_CONVERGED               0x8

#define AEC_MODE_PASS_THROUGH           0x0
#define AEC_MODE_HALF_DUPLEX            0x1
#define AEC_MODE_FULL_DUPLEX            0x2

//===========================================================================
//===========================================================================

#define STATIC_CSPROPSETID_Wave\
    0x924e54b0L, 0x630f, 0x11cf, 0xad, 0xa7, 0x08, 0x00, 0x3e, 0x30, 0x49, 0x4a
DEFINE_GUIDSTRUCT("924e54b0-630f-11cf-ada7-08003e30494a", CSPROPSETID_Wave);
#define CSPROPSETID_Wave DEFINE_GUIDNAMED(CSPROPSETID_Wave)

typedef enum {
    CSPROPERTY_WAVE_COMPATIBLE_CAPABILITIES,
    CSPROPERTY_WAVE_INPUT_CAPABILITIES,
    CSPROPERTY_WAVE_OUTPUT_CAPABILITIES,
    CSPROPERTY_WAVE_BUFFER,
    CSPROPERTY_WAVE_FREQUENCY,
    CSPROPERTY_WAVE_VOLUME,
    CSPROPERTY_WAVE_PAN
} CSPROPERTY_WAVE;

typedef struct {
    ULONG        ulDeviceType;
} CSWAVE_COMPATCAPS, *PCSWAVE_COMPATCAPS;

#define CSWAVE_COMPATCAPS_INPUT                 0x00000000
#define CSWAVE_COMPATCAPS_OUTPUT                0x00000001

typedef struct {
    ULONG  MaximumChannelsPerConnection;
    ULONG  MinimumBitsPerSample;
    ULONG  MaximumBitsPerSample;
    ULONG  MinimumSampleFrequency;
    ULONG  MaximumSampleFrequency;
    ULONG  TotalConnections;
    ULONG  ActiveConnections;
} CSWAVE_INPUT_CAPABILITIES, *PCSWAVE_INPUT_CAPABILITIES;

typedef struct {
    ULONG  MaximumChannelsPerConnection;
    ULONG  MinimumBitsPerSample;
    ULONG  MaximumBitsPerSample;
    ULONG  MinimumSampleFrequency;
    ULONG  MaximumSampleFrequency;
    ULONG  TotalConnections;
    ULONG  StaticConnections;
    ULONG  StreamingConnections;
    ULONG  ActiveConnections;
    ULONG  ActiveStaticConnections;
    ULONG  ActiveStreamingConnections;
    ULONG  Total3DConnections;
    ULONG  Static3DConnections;
    ULONG  Streaming3DConnections;
    ULONG  Active3DConnections;
    ULONG  ActiveStatic3DConnections;
    ULONG  ActiveStreaming3DConnections;
    ULONG  TotalSampleMemory;
    ULONG  FreeSampleMemory;
    ULONG  LargestFreeContiguousSampleMemory;
} CSWAVE_OUTPUT_CAPABILITIES, *PCSWAVE_OUTPUT_CAPABILITIES;

typedef struct {
    LONG  LeftAttenuation;
    LONG  RightAttenuation;
} CSWAVE_VOLUME, *PCSWAVE_VOLUME;

#define CSWAVE_BUFFER_ATTRIBUTEF_LOOPING   0x00000001
#define CSWAVE_BUFFER_ATTRIBUTEF_STATIC    0x00000002

typedef struct {
    ULONG   Attributes;
    ULONG   BufferSize;
    PVOID   BufferAddress;
} CSWAVE_BUFFER, *PCSWAVE_BUFFER;

//===========================================================================
//===========================================================================

#define STATIC_CSMUSIC_TECHNOLOGY_PORT\
    0x86C92E60L, 0x62E8, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("86C92E60-62E8-11CF-A5D6-28DB04C10000", CSMUSIC_TECHNOLOGY_PORT);
#define CSMUSIC_TECHNOLOGY_PORT DEFINE_GUIDNAMED(CSMUSIC_TECHNOLOGY_PORT)

#define STATIC_CSMUSIC_TECHNOLOGY_SQSYNTH\
    0x0ECF4380L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("0ECF4380-62E9-11CF-A5D6-28DB04C10000", CSMUSIC_TECHNOLOGY_SQSYNTH);
#define CSMUSIC_TECHNOLOGY_SQSYNTH DEFINE_GUIDNAMED(CSMUSIC_TECHNOLOGY_SQSYNTH)

#define STATIC_CSMUSIC_TECHNOLOGY_FMSYNTH\
    0x252C5C80L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("252C5C80-62E9-11CF-A5D6-28DB04C10000", CSMUSIC_TECHNOLOGY_FMSYNTH);
#define CSMUSIC_TECHNOLOGY_FMSYNTH DEFINE_GUIDNAMED(CSMUSIC_TECHNOLOGY_FMSYNTH)

#define STATIC_CSMUSIC_TECHNOLOGY_WAVETABLE\
    0x394EC7C0L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("394EC7C0-62E9-11CF-A5D6-28DB04C10000", CSMUSIC_TECHNOLOGY_WAVETABLE);
#define CSMUSIC_TECHNOLOGY_WAVETABLE DEFINE_GUIDNAMED(CSMUSIC_TECHNOLOGY_WAVETABLE)

#define STATIC_CSMUSIC_TECHNOLOGY_SWSYNTH\
    0x37407736L, 0x3620, 0x11D1, 0x85, 0xD3, 0x00, 0x00, 0xF8, 0x75, 0x43, 0x80
DEFINE_GUIDSTRUCT("37407736-3620-11D1-85D3-0000F8754380", CSMUSIC_TECHNOLOGY_SWSYNTH);
#define CSMUSIC_TECHNOLOGY_SWSYNTH DEFINE_GUIDNAMED(CSMUSIC_TECHNOLOGY_SWSYNTH)

typedef struct {
   CSDATARANGE              DataRange;
   GUID                     Technology;
   ULONG                    Channels;
   ULONG                    Notes;
   ULONG                    ChannelMask;
} CSDATARANGE_MUSIC, *PCSDATARANGE_MUSIC;

//===========================================================================

#define STATIC_CSEVENTSETID_Cyclic\
    0x142C1AC0L, 0x072A, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("142C1AC0-072A-11D0-A5D6-28DB04C10000", CSEVENTSETID_Cyclic);
#define CSEVENTSETID_Cyclic DEFINE_GUIDNAMED(CSEVENTSETID_Cyclic)

typedef enum {
    CSEVENT_CYCLIC_TIME_INTERVAL,
} CSEVENT_CYCLIC_TIME;

//===========================================================================
#define STATIC_CSEVENTSETID_AudioControlChange\
    0xE85E9698L, 0xFA2F, 0x11D1, 0x95, 0xBD, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("E85E9698-FA2F-11D1-95BD-00C04FB925D3", CSEVENTSETID_AudioControlChange);
#define CSEVENTSETID_AudioControlChange DEFINE_GUIDNAMED(CSEVENTSETID_AudioControlChange)

typedef enum {
    CSEVENT_CONTROL_CHANGE,
} CSEVENT_AUDIO_CONTROL_CHANGE;

//===========================================================================
/*
#define STATIC_CSEVENTSETID_LoopedStreaming\
    0x4682B940L, 0xC6EF, 0x11D0, 0x96, 0xD8, 0x00, 0xAA, 0x00, 0x51, 0xE5, 0x1D
DEFINE_GUIDSTRUCT("4682B940-C6EF-11D0-96D8-00AA0051E51D", CSEVENTSETID_LoopedStreaming);
#define CSEVENTSETID_LoopedStreaming DEFINE_GUIDNAMED(CSEVENTSETID_LoopedStreaming)

typedef enum {
    CSEVENT_LOOPEDSTREAMING_POSITION,
} CSEVENT_LOOPEDSTREAMING;

typedef struct {
    CSEVENTDATA CsEventData;
#if defined(_NTDDK_)
    ULONGLONG   Position;
#else // !_NTDDK_
    DWORDLONG   Position;
#endif // !_NTDDK_
} LOOPEDSTREAMING_POSITION_EVENT_DATA, *PLOOPEDSTREAMING_POSITION_EVENT_DATA ;
*/

//===========================================================================
#define STATIC_CSPROPSETID_Sysaudio\
    0xCBE3FAA0L, 0xCC75, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
DEFINE_GUIDSTRUCT("CBE3FAA0-CC75-11D0-B465-00001A1818E6", CSPROPSETID_Sysaudio);
#define CSPROPSETID_Sysaudio DEFINE_GUIDNAMED(CSPROPSETID_Sysaudio)

typedef enum {
    CSPROPERTY_SYSAUDIO_DEVICE_COUNT = 1,
    CSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME = 2,
    CSPROPERTY_SYSAUDIO_DEVICE_INSTANCE = 3,
    CSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME = 4,
    CSPROPERTY_SYSAUDIO_SELECT_GRAPH = 5,
    CSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE = 6,
    CSPROPERTY_SYSAUDIO_DEVICE_DEFAULT = 7,
    CSPROPERTY_SYSAUDIO_INSTANCE_INFO = 14,
    CSPROPERTY_SYSAUDIO_COMPONENT_ID = 16,
} CSPROPERTY_SYSAUDIO;

typedef struct {
    CSPROPERTY Property;
    GUID PinCategory;
    GUID PinName;
} SYSAUDIO_CREATE_VIRTUAL_SOURCE, *PSYSAUDIO_CREATE_VIRTUAL_SOURCE;


typedef struct {
    CSPROPERTY Property;
    ULONG PinId;
    ULONG NodeId;
    ULONG Flags;
    ULONG Reserved;
} SYSAUDIO_SELECT_GRAPH, *PSYSAUDIO_SELECT_GRAPH;

typedef struct {
    CSPROPERTY Property;
    ULONG Flags;
    ULONG DeviceNumber;
} SYSAUDIO_INSTANCE_INFO, *PSYSAUDIO_INSTANCE_INFO;

#define SYSAUDIO_FLAGS_DONT_COMBINE_PINS        0x00000001


#define STATIC_CSPROPSETID_Sysaudio_Pin \
    0xA3A53220L, 0xC6E4, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
DEFINE_GUIDSTRUCT("A3A53220-C6E4-11D0-B465-00001A1818E6", CSPROPSETID_Sysaudio_Pin);
#define CSPROPSETID_Sysaudio_Pin DEFINE_GUIDNAMED(CSPROPSETID_Sysaudio_Pin)

typedef enum {
    CSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE = 1,
} CSPROPERTY_SYSAUDIO_PIN;

typedef struct {
    CSPROPERTY  Property;
    ULONG       MixerPinId;
    ULONG       Reserved;
} SYSAUDIO_ATTACH_VIRTUAL_SOURCE, *PSYSAUDIO_ATTACH_VIRTUAL_SOURCE;

//===========================================================================
typedef struct {
    CSPROPERTY  Property;
    ULONG       NodeId;
    ULONG       Reserved;
} CSNODEPROPERTY, *PCSNODEPROPERTY;

typedef struct {
    CSNODEPROPERTY NodeProperty;
    LONG           Channel;                   // value to get or set
    ULONG          Reserved;
} CSNODEPROPERTY_AUDIO_CHANNEL, *PCSNODEPROPERTY_AUDIO_CHANNEL;

typedef struct {
    CSNODEPROPERTY NodeProperty;
    ULONG   DevSpecificId;
    ULONG   DeviceInfo;
    ULONG   Length;
} CSNODEPROPERTY_AUDIO_DEV_SPECIFIC, *PCSNODEPROPERTY_AUDIO_DEV_SPECIFIC;

typedef struct {
    CSNODEPROPERTY   NodeProperty;
    PVOID            ListenerId;
#ifndef _WIN64
    ULONG            Reserved;
#endif // _WIN64
} CSNODEPROPERTY_AUDIO_3D_LISTENER, *PCSNODEPROPERTY_AUDIO_3D_LISTENER;

typedef struct {
    CSNODEPROPERTY   NodeProperty;
    PVOID            AppContext;
    ULONG            Length;
#ifndef _WIN64
    ULONG            Reserved;
#endif // _WIN64
} CSNODEPROPERTY_AUDIO_PROPERTY, *PCSNODEPROPERTY_AUDIO_PROPERTY;

//===========================================================================
// {79A9312E-59AE-43b0-A350-8B05284CAB24}
#define STATIC_CSPROPSETID_AudioGfx\
    0x79a9312eL, 0x59ae, 0x43b0, 0xa3, 0x50, 0x8b, 0x5, 0x28, 0x4c, 0xab, 0x24
DEFINE_GUIDSTRUCT("79A9312E-59AE-43b0-A350-8B05284CAB24", CSPROPSETID_AudioGfx);
#define CSPROPSETID_AudioGfx DEFINE_GUIDNAMED(CSPROPSETID_AudioGfx)

typedef enum {
    CSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID,
    CSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID
} CSPROPERTY_AUDIOGFX;

//===========================================================================

//
// Midi definitions
//

/*
    Formats
*/

#define STATIC_CSDATAFORMAT_TYPE_MUSIC\
    0xE725D360L, 0x62CC, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("E725D360-62CC-11CF-A5D6-28DB04C10000", CSDATAFORMAT_TYPE_MUSIC);
#define CSDATAFORMAT_TYPE_MUSIC DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_MUSIC)

// 'mids' == MEDIATYPE_Midi
#define STATIC_CSDATAFORMAT_TYPE_MIDI\
    0x7364696DL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("7364696D-0000-0010-8000-00aa00389b71", CSDATAFORMAT_TYPE_MIDI);
#define CSDATAFORMAT_TYPE_MIDI DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_MIDI)

#define STATIC_CSDATAFORMAT_SUBTYPE_MIDI\
    0x1D262760L, 0xE957, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1D262760-E957-11CF-A5D6-28DB04C10000", CSDATAFORMAT_SUBTYPE_MIDI);
#define CSDATAFORMAT_SUBTYPE_MIDI DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MIDI)

#define STATIC_CSDATAFORMAT_SUBTYPE_MIDI_BUS\
    0x2CA15FA0L, 0x6CFE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2CA15FA0-6CFE-11CF-A5D6-28DB04C10000", CSDATAFORMAT_SUBTYPE_MIDI_BUS);
#define CSDATAFORMAT_SUBTYPE_MIDI_BUS DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MIDI_BUS)

#define STATIC_CSDATAFORMAT_SUBTYPE_RIFFMIDI\
    0x4995DAF0L, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4995DAF0-9EE6-11D0-A40E-00A0C9223196", CSDATAFORMAT_SUBTYPE_RIFFMIDI);
#define CSDATAFORMAT_SUBTYPE_RIFFMIDI DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_RIFFMIDI)

/*
    CSDATAFORMAT_SUBTYPE_DIRECTMUSIC
    see DMusicCS.h
*/

// WARNING! This structure MUST be dword aligned
// regardless of the number of data bytes.

typedef struct {
    ULONG   TimeDeltaMs;        // Delta Milliseconds from the previous midiformat
                                // in the packet. The first midiformat in the packet
                                // is a delta from the PTS in the CSSTREAM_HEADER.
    ULONG   ByteCount;          // Number of bytes of data that follow this struct.
} CSMUSICFORMAT, *PCSMUSICFORMAT;

#endif //#ifndef UNDER_CE

//
// This entire set of MPEG Standard/Dialect Guids are obsolete. Do not use them.
//
//====================================================================================================
//====================================================================================================
// The following official MPEG Formats, Subtypes and Specifiers are listed as required or optional
// These official MPEG GUIDs are the preferred method of supporting MPEG/AC-3 media types in new code.
// Older MPEG GUIDs should also be supported for compatibilty, but these new modes are still required.
//====================================================================================================
//====================================================================================================

/*
This is a summary of what media types/specifiers will be required for all DVD+DSS+DVB+DTV MPEG decoders.
These media types are what the decoder driver must accept, hardware support for all of these media types
may or may not actually be provided by the decoder natively.  These media types are intended to define
the "officially" supported MPEG/AC-3 media types that all WHQL certified decoders must implement.  This
specifically includes driver and/or hardware support for all the required standards and dialects.

All MPEG video decoders must support all of the MPEG video modes shown as [required] below.
All MPEG audio decoders must support all of the MPEG audio modes shown as [required] below.
All AC-3 audio decoders must support all of the AC-3 audio modes shown as [required] below.
The line items shown as [optional] need not be implemented, but are possible formats that might be implemented.

Note that the input/output pin formats are defined by 2 or 3 GUIDs: TYPE, SUBTYPE, and maybe SPECIFIER.
The specifiers are included if the data format is a "dialect" that needs to be differentiated during decoding.
The decoder MUST be prepared to deal with ALL requests for _required_ "Standard" formats OR _required_ "Dialects".

STATIC_CSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM         [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_CSDATAFORMAT_TYPE_STANDARD_PES_PACKET                [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [optional]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [optional]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_CSDATAFORMAT_TYPE_STANDARD_PACK_HEADER               [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]

Note that the SPECIFIER GUIDs normally identify particular versions of MPEG such as DSS and DVD.
This approach was taken to minimize the number of DSS/DVB/DVD/DTV etc. media SUBTYPES.
These specifiers are currently required to disambiguate MPEG syntax _parsing_ by the decoder
using alternate parsing routines or downloadable firmware or hardware decode settings.

In the future these specifiers will be extended to cover new CS MPEG flavors such as DVB and DTV.
Thus, the optional specifiers will be subject to clarification and/or definition as they are needed.

Important note: Per the ITU MPEG specs, MPEG 2 media may contain pure MPEG 1 syntax and
any "MPEG 2" PES packets may actually contain MPEG 1 payloads and MPEG 1 syntax.  Some MPEG
broadcasts can revert from MPEG2 to MPEG1 format data at their discretion, without warning.

CAUTION: Decoders MUST attempt to process MPEG data AS SOON AS POSSIBLE after reception.
In particular, elementary MPEG or MPEG PES packet streams should not be aggregated into DVD
"pack headers" internally before submission to the codec hardware if AT ALL POSSIBLE.  The
reason is that mpeg data may need to be processed immediately but there may be no additional
MPEG data forthcoming to fill up the PES packet OR DVD "pack" in a timely fashion.  This is
particularly true of MPEG dialects that utilize "repeat field signally" to reuse the last
decoded MPEG video field.

*/

/////////////////////////////////////////////////////////////////////////
// The major data type GUIDs that define the data packet encapsulation //
/////////////////////////////////////////////////////////////////////////

// STATIC_CSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM
#define STATIC_CSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM \
    0x36523b11L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B11-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM );
#define CSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM)

// STATIC_CSDATAFORMAT_TYPE_STANDARD_PES_PACKET
#define STATIC_CSDATAFORMAT_TYPE_STANDARD_PES_PACKET \
    0x36523b12L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B12-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_TYPE_STANDARD_PES_PACKET );
#define CSDATAFORMAT_TYPE_STANDARD_PES_PACKET DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_STANDARD_PES_PACKET)

// STATIC_CSDATAFORMAT_TYPE_STANDARD_PACK_HEADER
#define STATIC_CSDATAFORMAT_TYPE_STANDARD_PACK_HEADER \
    0x36523b13L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B13-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_TYPE_STANDARD_PACK_HEADER );
#define CSDATAFORMAT_TYPE_STANDARD_PACK_HEADER DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_STANDARD_PACK_HEADER)

///////////////////////////////////////////////////////////////////////////////
// The minor data subtype GUIDs that define the exact class of the data type.//
///////////////////////////////////////////////////////////////////////////////

// STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO
#define STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO \
    0x36523b21L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B21-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO );
#define CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO)

// STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO
#define STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO \
    0x36523b22L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B22-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO );
#define CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO)

// STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO
#define STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO \
    0x36523b23L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B23-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO );
#define CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO)

// STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO
#define STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO \
    0x36523b24L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B24-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO );
#define CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO)

// STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO
#define STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO \
    0x36523b25L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B25-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO );
#define CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO)

///////////////////////////////////////////////////////////////////////////////
// The low-level specifier GUIDs that define the flavor of the data subtype. //
// Some SUBTYPES, notably MPEG2_VIDEO, MPEG2_AUDIO have different dialects.  //
// These specifiers are intended to be accompanied by a specifier structure. //
///////////////////////////////////////////////////////////////////////////////

// STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO
#define STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO \
    0x36523b31L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B31-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO );
#define CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO)

// STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO
#define STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO \
    0x36523b32L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B32-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO );
#define CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO)

// STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO    Associated with CS_MPEGVIDEOINFO2 defined later
#define STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO \
    0x36523b33L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B33-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO );
#define CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO)

// STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO    Associated with CS_MPEGAUDIOINFO defined later
#define STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO \
    0x36523b34L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B34-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO );
#define CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO)

// STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO
#define STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO \
    0x36523b35L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B35-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO );
#define CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO)

//====================================================================================================
//====================================================================================================
//                              *** COMPATIBILITY WARNING ***
// The *following* older DSS, MPEG, DVD & AC-3 GUID definitions are retained for backward compability.
// These MPEG GUIDs should also be supported for compatibilty, but the above newer modes are still required.
//====================================================================================================
//====================================================================================================

//
// DSS definitions
//

#define STATIC_CSDATAFORMAT_SUBTYPE_DSS_VIDEO\
    0xa0af4f81L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("a0af4f81-e163-11d0-bad9-00609744111a", CSDATAFORMAT_SUBTYPE_DSS_VIDEO);
#define CSDATAFORMAT_SUBTYPE_DSS_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_DSS_VIDEO)

#define STATIC_CSDATAFORMAT_SUBTYPE_DSS_AUDIO\
    0xa0af4f82L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("a0af4f82-e163-11d0-bad9-00609744111a", CSDATAFORMAT_SUBTYPE_DSS_AUDIO);
#define CSDATAFORMAT_SUBTYPE_DSS_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_DSS_AUDIO)

//
// End of obsolete MPEG definitions.
//

//
// mpeg 1 definitions
//
#define STATIC_CSDATAFORMAT_SUBTYPE_MPEG1Packet\
    0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb80-524f-11ce-9F53-0020af0ba770", CSDATAFORMAT_SUBTYPE_MPEG1Packet);
#define CSDATAFORMAT_SUBTYPE_MPEG1Packet DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MPEG1Packet)

#define STATIC_CSDATAFORMAT_SUBTYPE_MPEG1Payload\
    0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb81-524f-11ce-9F53-0020af0ba770", CSDATAFORMAT_SUBTYPE_MPEG1Payload);
#define CSDATAFORMAT_SUBTYPE_MPEG1Payload DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MPEG1Payload)

// MEDIASUBTYPE_MPEG1Video
#define STATIC_CSDATAFORMAT_SUBTYPE_MPEG1Video\
    0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb86-524f-11ce-9f53-0020af0ba770", CSDATAFORMAT_SUBTYPE_MPEG1Video);
#define CSDATAFORMAT_SUBTYPE_MPEG1Video DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MPEG1Video)

//FORMAT_MPEGVideo
#define STATIC_CSDATAFORMAT_SPECIFIER_MPEG1_VIDEO\
    0x05589f82L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f82-c356-11ce-bf01-00aa0055595a", CSDATAFORMAT_SPECIFIER_MPEG1_VIDEO);
#define CSDATAFORMAT_SPECIFIER_MPEG1_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_MPEG1_VIDEO)

//
// mpeg 2 definitions
//
#define STATIC_CSDATAFORMAT_TYPE_MPEG2_PES\
    0xe06d8020L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8020-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_TYPE_MPEG2_PES);
#define CSDATAFORMAT_TYPE_MPEG2_PES DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_MPEG2_PES)

#define STATIC_CSDATAFORMAT_TYPE_MPEG2_PROGRAM\
    0xe06d8022L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8022-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_TYPE_MPEG2_PROGRAM);
#define CSDATAFORMAT_TYPE_MPEG2_PROGRAM DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_MPEG2_PROGRAM)

#define STATIC_CSDATAFORMAT_TYPE_MPEG2_TRANSPORT\
    0xe06d8023L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8023-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_TYPE_MPEG2_TRANSPORT);
#define CSDATAFORMAT_TYPE_MPEG2_TRANSPORT DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_MPEG2_TRANSPORT)

#define STATIC_CSDATAFORMAT_SUBTYPE_MPEG2_VIDEO\
    0xe06d8026L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8026-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_MPEG2_VIDEO);
#define CSDATAFORMAT_SUBTYPE_MPEG2_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MPEG2_VIDEO)

// use MPEGVIDEOINFO2 (defined below) with CSDATAFORMAT_SPECIFIER_MPEG2_VIDEO
#define STATIC_CSDATAFORMAT_SPECIFIER_MPEG2_VIDEO\
    0xe06d80e3L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e3-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SPECIFIER_MPEG2_VIDEO);
#define CSDATAFORMAT_SPECIFIER_MPEG2_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_MPEG2_VIDEO)


//
// Mpeg2 video properties
//


#define STATIC_CSPROPSETID_Mpeg2Vid\
    0xC8E11B60L, 0x0CC9, 0x11D0, 0xBD, 0x69, 0x00, 0x35, 0x05, 0xC1, 0x03, 0xA9
DEFINE_GUIDSTRUCT("C8E11B60-0CC9-11D0-BD69-003505C103A9", CSPROPSETID_Mpeg2Vid);
#define  CSPROPSETID_Mpeg2Vid DEFINE_GUIDNAMED( CSPROPSETID_Mpeg2Vid )


typedef enum {
    CSPROPERTY_MPEG2VID_MODES,          // available output modes of decoder
    CSPROPERTY_MPEG2VID_CUR_MODE,       // current mode of the decoder
    CSPROPERTY_MPEG2VID_4_3_RECT,       // output coordinates for 4:3 source
    CSPROPERTY_MPEG2VID_16_9_RECT,      // output coordinates for 16:9 source
    CSPROPERTY_MPEG2VID_16_9_PANSCAN,   // pan and scan vectors
} CSPROPERTY_MPEG2VID;

//
// bit field definitions for MPEG2 VIDEO mode
//

#define CSMPEGVIDMODE_PANSCAN   0x0001
#define CSMPEGVIDMODE_LTRBOX    0x0002
#define CSMPEGVIDMODE_SCALE     0x0004

//
// rectangle definitions for the 4/3 and 16/9 cropping properties of
// the MPEG2Video decoder
//

typedef struct _CSMPEGVID_RECT {
    ULONG StartX;
    ULONG StartY;
    ULONG EndX;
    ULONG EndY;
} CSMPEGVID_RECT, *PCSMPEGVID_RECT;

//
// Params for pan / scan
//

#ifndef UNDER_CE
//
// MPEG2 Audio definition
//

#define STATIC_CSDATAFORMAT_SUBTYPE_MPEG2_AUDIO\
    0xe06d802bL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802b-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_MPEG2_AUDIO);
#define CSDATAFORMAT_SUBTYPE_MPEG2_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MPEG2_AUDIO)

#define STATIC_CSDATAFORMAT_SPECIFIER_MPEG2_AUDIO\
    0xe06d80e5L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e5-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SPECIFIER_MPEG2_AUDIO);
#define CSDATAFORMAT_SPECIFIER_MPEG2_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_MPEG2_AUDIO)

//
// DVD LPCM Audio definition
//

#define STATIC_CSDATAFORMAT_SUBTYPE_LPCM_AUDIO\
    0xe06d8032L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8032-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_LPCM_AUDIO);
#define CSDATAFORMAT_SUBTYPE_LPCM_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_LPCM_AUDIO)

#define STATIC_CSDATAFORMAT_SPECIFIER_LPCM_AUDIO\
    0xe06d80e6L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e6-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SPECIFIER_LPCM_AUDIO);
#define CSDATAFORMAT_SPECIFIER_LPCM_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_LPCM_AUDIO)

//
// AC-3 definition
//

#define STATIC_CSDATAFORMAT_SUBTYPE_AC3_AUDIO\
    0xe06d802cL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802c-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_AC3_AUDIO);
#define CSDATAFORMAT_SUBTYPE_AC3_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_AC3_AUDIO)

#define STATIC_CSDATAFORMAT_SPECIFIER_AC3_AUDIO\
    0xe06d80e4L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e4-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SPECIFIER_AC3_AUDIO);
#define CSDATAFORMAT_SPECIFIER_AC3_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_AC3_AUDIO)

#define STATIC_CSPROPSETID_AC3\
    0xBFABE720L, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("BFABE720-6E1F-11D0-BCF2-444553540000", CSPROPSETID_AC3);
#define CSPROPSETID_AC3 DEFINE_GUIDNAMED(CSPROPSETID_AC3)

typedef enum {
    CSPROPERTY_AC3_ERROR_CONCEALMENT = 1,
    CSPROPERTY_AC3_ALTERNATE_AUDIO,
    CSPROPERTY_AC3_DOWNMIX,
    CSPROPERTY_AC3_BIT_STREAM_MODE,
    CSPROPERTY_AC3_DIALOGUE_LEVEL,
    CSPROPERTY_AC3_LANGUAGE_CODE,
    CSPROPERTY_AC3_ROOM_TYPE
} CSPROPERTY_AC3;

typedef struct  {
    BOOL        fRepeatPreviousBlock;
    BOOL        fErrorInCurrentBlock;
} CSAC3_ERROR_CONCEALMENT, *PCSAC3_ERROR_CONCEALMENT;

typedef struct {
    BOOL    fStereo;
    ULONG   DualMode;
} CSAC3_ALTERNATE_AUDIO, *PCSAC3_ALTERNATE_AUDIO;

#define CSAC3_ALTERNATE_AUDIO_1     1
#define CSAC3_ALTERNATE_AUDIO_2     2
#define CSAC3_ALTERNATE_AUDIO_BOTH  3

typedef struct {
    BOOL        fDownMix;
    BOOL        fDolbySurround;
} CSAC3_DOWNMIX, *PCSAC3_DOWNMIX;

typedef struct {
    LONG        BitStreamMode;
} CSAC3_BIT_STREAM_MODE, *PCSAC3_BIT_STREAM_MODE;

#define CSAC3_SERVICE_MAIN_AUDIO            0
#define CSAC3_SERVICE_NO_DIALOG             1
#define CSAC3_SERVICE_VISUALLY_IMPAIRED     2
#define CSAC3_SERVICE_HEARING_IMPAIRED      3
#define CSAC3_SERVICE_DIALOG_ONLY           4
#define CSAC3_SERVICE_COMMENTARY            5
#define CSAC3_SERVICE_EMERGENCY_FLASH       6
#define CSAC3_SERVICE_VOICE_OVER            7

typedef struct {
    ULONG   DialogueLevel;
} CSAC3_DIALOGUE_LEVEL, *PCSAC3_DIALOGUE_LEVEL;

typedef struct {
    BOOL    fLargeRoom;
} CSAC3_ROOM_TYPE, *PCSAC3_ROOM_TYPE;


//
// DTS and SDDS definitions (media subtype GUIDs)
//
#define STATIC_CSDATAFORMAT_SUBTYPE_DTS_AUDIO\
    0xe06d8033L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8033-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_DTS_AUDIO);
#define CSDATAFORMAT_SUBTYPE_DTS_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_DTS_AUDIO)

#define STATIC_CSDATAFORMAT_SUBTYPE_SDDS_AUDIO\
    0xe06d8034L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8034-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_SDDS_AUDIO);
#define CSDATAFORMAT_SUBTYPE_SDDS_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_SDDS_AUDIO)


//
// audio decoder output properties
//

#define STATIC_CSPROPSETID_AudioDecoderOut\
    0x6ca6e020L, 0x43bd, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
DEFINE_GUIDSTRUCT("6ca6e020-43bd-11d0-bd6a-003505c103a9", CSPROPSETID_AudioDecoderOut);
#define CSPROPSETID_AudioDecoderOut DEFINE_GUIDNAMED(CSPROPSETID_AudioDecoderOut)

typedef enum {
    CSPROPERTY_AUDDECOUT_MODES,         // available output modes of decoder
    CSPROPERTY_AUDDECOUT_CUR_MODE,      // current mode of the decoder
} CSPROPERTY_AUDDECOUT;

#define CSAUDDECOUTMODE_STEREO_ANALOG   0x0001
#define CSAUDDECOUTMODE_PCM_51          0x0002
#define CSAUDDECOUTMODE_SPDIFF          0x0004



//
// subpicture definition
//

#define STATIC_CSDATAFORMAT_SUBTYPE_SUBPICTURE\
    0xe06d802dL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802d-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_SUBPICTURE);
#define CSDATAFORMAT_SUBTYPE_SUBPICTURE DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_SUBPICTURE)


#define STATIC_CSPROPSETID_DvdSubPic\
    0xac390460L, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
DEFINE_GUIDSTRUCT("ac390460-43af-11d0-bd6a-003505c103a9", CSPROPSETID_DvdSubPic);
#define CSPROPSETID_DvdSubPic DEFINE_GUIDNAMED(CSPROPSETID_DvdSubPic)

typedef enum {
    CSPROPERTY_DVDSUBPIC_PALETTE,
    CSPROPERTY_DVDSUBPIC_HLI,
    CSPROPERTY_DVDSUBPIC_COMPOSIT_ON,  // TRUE for subpicture is displayed
} CSPROPERTY_DVDSUBPIC;

typedef struct _CS_DVD_YCrCb {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   Cr;
    UCHAR   Cb;
} CS_DVD_YCrCb, *PCS_DVD_YCrCb;

/* The CS_DVD_YUV structure is now superseded by CS_DVD_YCrCb above and is
   here for backward compatibility only */

typedef struct _CS_DVD_YUV {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   V;
    UCHAR   U;
} CS_DVD_YUV, *PCS_DVD_YUV;

typedef struct _CSPROPERTY_SPPAL {
    CS_DVD_YUV sppal[16];
} CSPROPERTY_SPPAL, *PCSPROPERTY_SPPAL;

typedef struct _CS_COLCON {
    UCHAR emph1col:4;
    UCHAR emph2col:4;
    UCHAR backcol:4;
    UCHAR patcol:4;
    UCHAR emph1con:4;
    UCHAR emph2con:4;
    UCHAR backcon:4;
    UCHAR patcon:4;

} CS_COLCON, *PCS_COLCON;

typedef struct _CSPROPERTY_SPHLI {
    USHORT      HLISS;
    USHORT      Reserved;
    ULONG       StartPTM;   // start presentation time in x/90000
    ULONG       EndPTM;     // end PTM in x/90000
    USHORT      StartX;
    USHORT      StartY;
    USHORT      StopX;
    USHORT      StopY;
    CS_COLCON   ColCon;     // color contrast description (4 bytes as given in HLI)
} CSPROPERTY_SPHLI, *PCSPROPERTY_SPHLI;

typedef BOOL CSPROPERTY_COMPOSIT_ON, *PCSPROPERTY_COMPOSIT_ON;

#define STATIC_CSPROPSETID_CopyProt \
    0x0E8A0A40L, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3
DEFINE_GUIDSTRUCT("0E8A0A40-6AEF-11D0-9ED0-00A024CA19B3", CSPROPSETID_CopyProt);
#define CSPROPSETID_CopyProt DEFINE_GUIDNAMED(CSPROPSETID_CopyProt)

typedef enum {

    CSPROPERTY_DVDCOPY_CHLG_KEY = 0x01,
    CSPROPERTY_DVDCOPY_DVD_KEY1,
    CSPROPERTY_DVDCOPY_DEC_KEY2,
    CSPROPERTY_DVDCOPY_TITLE_KEY,
    CSPROPERTY_COPY_MACROVISION,
    CSPROPERTY_DVDCOPY_REGION,
    CSPROPERTY_DVDCOPY_SET_COPY_STATE,
    CSPROPERTY_DVDCOPY_DISC_KEY = 0x80

} CSPROPERTY_COPYPROT;

typedef struct _CS_DVDCOPY_CHLGKEY {
    BYTE ChlgKey[10];
    BYTE Reserved[2];
} CS_DVDCOPY_CHLGKEY, *PCS_DVDCOPY_CHLGKEY;

typedef struct _CS_DVDCOPY_BUSKEY {
    BYTE BusKey[5];
    BYTE Reserved[1];
} CS_DVDCOPY_BUSKEY, *PCS_DVDCOPY_BUSKEY;


typedef struct _CS_DVDCOPY_DISCKEY {
    BYTE DiscKey[2048];
} CS_DVDCOPY_DISCKEY, *PCS_DVDCOPY_DISCKEY;

typedef struct _CS_DVDCOPY_REGION {
    UCHAR   Reserved;
    UCHAR   RegionData;
    UCHAR   Reserved2[2];
} CS_DVDCOPY_REGION, *PCS_DVDCOPY_REGION;

typedef struct _CS_DVDCOPY_TITLEKEY {
    ULONG KeyFlags;
    ULONG ReservedNT[2];
    UCHAR TitleKey[6];
    UCHAR Reserved[2];
} CS_DVDCOPY_TITLEKEY, *PCS_DVDCOPY_TITLEKEY;

typedef struct _CS_COPY_MACROVISION {
    ULONG MACROVISIONLevel;
} CS_COPY_MACROVISION, *PCS_COPY_MACROVISION;

typedef struct _CS_DVDCOPY_SET_COPY_STATE {
    ULONG DVDCopyState;
} CS_DVDCOPY_SET_COPY_STATE, *PCS_DVDCOPY_SET_COPY_STATE;

typedef enum {
    CS_DVDCOPYSTATE_INITIALIZE,         // indicates we are starting a full
                                        // copy protection sequence.
    CS_DVDCOPYSTATE_INITIALIZE_TITLE,   // indicates we are starting a title
                                        // key copy protection sequence
    CS_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED,
    CS_DVDCOPYSTATE_AUTHENTICATION_REQUIRED,
    CS_DVDCOPYSTATE_DONE,
} CS_DVDCOPYSTATE;

typedef enum {
    CS_MACROVISION_DISABLED,
    CS_MACROVISION_LEVEL1,
    CS_MACROVISION_LEVEL2,
    CS_MACROVISION_LEVEL3
} CS_COPY_MACROVISION_LEVEL, *PCS_COPY_MACROVISION_LEVEL;

//
// CGMS Copy Protection Flags
//

#define CS_DVD_CGMS_RESERVED_MASK      0x00000078

#define CS_DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define CS_DVD_CGMS_COPY_PERMITTED     0x00000000
#define CS_DVD_CGMS_COPY_ONCE          0x00000010
#define CS_DVD_CGMS_NO_COPY            0x00000018

#define CS_DVD_COPYRIGHT_MASK          0x00000040
#define CS_DVD_NOT_COPYRIGHTED         0x00000000
#define CS_DVD_COPYRIGHTED             0x00000040

#define CS_DVD_SECTOR_PROTECT_MASK     0x00000020
#define CS_DVD_SECTOR_NOT_PROTECTED    0x00000000
#define CS_DVD_SECTOR_PROTECTED        0x00000020


//===========================================================================
// The following MUST match the structures in WinGDI.h and AMVideo.h
//===========================================================================

#define STATIC_CSCATEGORY_TVTUNER \
    0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a800-a46d-11d0-a18c-00a02401dcd4", CSCATEGORY_TVTUNER);
#define CSCATEGORY_TVTUNER DEFINE_GUIDNAMED(CSCATEGORY_TVTUNER)

#define STATIC_CSCATEGORY_CROSSBAR \
    0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a801-a46d-11d0-a18c-00a02401dcd4", CSCATEGORY_CROSSBAR);
#define CSCATEGORY_CROSSBAR DEFINE_GUIDNAMED(CSCATEGORY_CROSSBAR)

#define STATIC_CSCATEGORY_TVAUDIO \
    0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a802-a46d-11d0-a18c-00a02401dcd4", CSCATEGORY_TVAUDIO);
#define CSCATEGORY_TVAUDIO DEFINE_GUIDNAMED(CSCATEGORY_TVAUDIO)

#define STATIC_CSCATEGORY_VPMUX \
    0xa799a803L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a803-a46d-11d0-a18c-00a02401dcd4", CSCATEGORY_VPMUX);
#define CSCATEGORY_VPMUX DEFINE_GUIDNAMED(CSCATEGORY_VPMUX)

#define STATIC_CSCATEGORY_VBICODEC \
    0x07dad660L, 0x22f1, 0x11d1, 0xa9, 0xf4, 0x00, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("07dad660-22f1-11d1-a9f4-00c04fbbde8f", CSCATEGORY_VBICODEC);
#define CSCATEGORY_VBICODEC DEFINE_GUIDNAMED(CSCATEGORY_VBICODEC)

#endif //#ifndef UNDER_CE

// SUBTYPE_VPVideo
#define STATIC_CSDATAFORMAT_SUBTYPE_VPVideo\
    0x5a9b6a40L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("5a9b6a40-1a22-11d1-bad9-00609744111a", CSDATAFORMAT_SUBTYPE_VPVideo);
#define CSDATAFORMAT_SUBTYPE_VPVideo DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_VPVideo)

#ifndef UNDER_CE

// SUBTYPE_VPVBI
#define STATIC_CSDATAFORMAT_SUBTYPE_VPVBI\
    0x5a9b6a41L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("5a9b6a41-1a22-11d1-bad9-00609744111a", CSDATAFORMAT_SUBTYPE_VPVBI);
#define CSDATAFORMAT_SUBTYPE_VPVBI DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_VPVBI)

#endif //#ifndef UNDER_CE

// FORMAT_VideoInfo
#define STATIC_CSDATAFORMAT_SPECIFIER_VIDEOINFO\
    0x05589f80L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f80-c356-11ce-bf01-00aa0055595a", CSDATAFORMAT_SPECIFIER_VIDEOINFO);
#define CSDATAFORMAT_SPECIFIER_VIDEOINFO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_VIDEOINFO)

// FORMAT_VideoInfo2
#define STATIC_CSDATAFORMAT_SPECIFIER_VIDEOINFO2\
    0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76A0-eb0a-11d0-ace4-0000c0cc16ba", CSDATAFORMAT_SPECIFIER_VIDEOINFO2);
#define CSDATAFORMAT_SPECIFIER_VIDEOINFO2 DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_VIDEOINFO2)

// MEDIATYPE_AnalogVideo
#define STATIC_CSDATAFORMAT_TYPE_ANALOGVIDEO\
    0x0482dde1L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482dde1-7817-11cf-8a03-00aa006ecb65", CSDATAFORMAT_TYPE_ANALOGVIDEO);
#define CSDATAFORMAT_TYPE_ANALOGVIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_ANALOGVIDEO)

// FORMAT_AnalogVideo
#define STATIC_CSDATAFORMAT_SPECIFIER_ANALOGVIDEO\
    0x0482dde0L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482dde0-7817-11cf-8a03-00aa006ecb65", CSDATAFORMAT_SPECIFIER_ANALOGVIDEO);
#define CSDATAFORMAT_SPECIFIER_ANALOGVIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_ANALOGVIDEO)

// MEDIATYPE_AnalogAudio
#define STATIC_CSDATAFORMAT_TYPE_ANALOGAUDIO \
    0x0482dee1L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482DEE1-7817-11cf-8a03-00aa006ecb65", CSDATAFORMAT_TYPE_ANALOGAUDIO);
#define CSDATAFORMAT_TYPE_ANALOGAUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_ANALOGAUDIO)

// FORMAT_VBI
#define STATIC_CSDATAFORMAT_SPECIFIER_VBI\
    0xf72a76e0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e0-eb0a-11d0-ace4-0000c0cc16ba", CSDATAFORMAT_SPECIFIER_VBI);
#define CSDATAFORMAT_SPECIFIER_VBI DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_VBI)

// MEDIATYPE_VBI
#define STATIC_CSDATAFORMAT_TYPE_VBI\
    0xf72a76e1L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e1-eb0a-11d0-ace4-0000c0cc16ba", CSDATAFORMAT_TYPE_VBI);
#define CSDATAFORMAT_TYPE_VBI DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_VBI)

// SUBTYPE_RAW8
#define STATIC_CSDATAFORMAT_SUBTYPE_RAW8\
    0xca20d9a0, 0x3e3e, 0x11d1, 0x9b, 0xf9, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0xbf
DEFINE_GUIDSTRUCT("ca20d9a0-3e3e-11d1-9bf9-00c04fbbdebf", CSDATAFORMAT_SUBTYPE_RAW8);
#define CSDATAFORMAT_SUBTYPE_RAW8 DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_RAW8)

// MEDIASUBTYPE_CC
#define STATIC_CSDATAFORMAT_SUBTYPE_CC\
    0x33214cc1, 0x11f, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
DEFINE_GUIDSTRUCT("33214CC1-011F-11D2-B4B1-00A0D102CFBE", CSDATAFORMAT_SUBTYPE_CC);
#define CSDATAFORMAT_SUBTYPE_CC DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_CC)

// MEDIASUBTYPE_NABTS
#define STATIC_CSDATAFORMAT_SUBTYPE_NABTS\
    0xf72a76e2L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e2-eb0a-11d0-ace4-0000c0cc16ba", CSDATAFORMAT_SUBTYPE_NABTS);
#define CSDATAFORMAT_SUBTYPE_NABTS DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_NABTS)

// MEDIASUBTYPE_TELETEXT
#define STATIC_CSDATAFORMAT_SUBTYPE_TELETEXT\
    0xf72a76e3L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e3-eb0a-11d0-ace4-0000c0cc16ba", CSDATAFORMAT_SUBTYPE_TELETEXT);
#define CSDATAFORMAT_SUBTYPE_TELETEXT DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_TELETEXT)



/* constants for the biCompression field */
#define CS_BI_RGB        0L
#define CS_BI_RLE8       1L
#define CS_BI_RLE4       2L
#define CS_BI_BITFIELDS  3L

typedef struct tagCS_RGBQUAD { // rgbq
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} CS_RGBQUAD, *PCS_RGBQUAD;

/* constants for palettes */
#define CS_iPALETTE_COLORS 256     // Maximum colours in palette
#define CS_iEGA_COLORS 16          // Number colours in EGA palette
#define CS_iMASK_COLORS 3          // Maximum three components
#define CS_iTRUECOLOR 16           // Minimum true colour device
#define CS_iRED 0                  // Index position for RED mask
#define CS_iGREEN 1                // Index position for GREEN mask
#define CS_iBLUE 2                 // Index position for BLUE mask
#define CS_iPALETTE 8              // Maximum colour depth using a palette
#define CS_iMAXBITS 8              // Maximum bits per colour component
#define CS_SIZE_EGA_PALETTE (CS_iEGA_COLORS * sizeof(CS_RGBQUAD))
#define CS_SIZE_PALETTE (CS_iPALETTE_COLORS * sizeof(CS_RGBQUAD))

typedef struct tagCS_BITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} CS_BITMAPINFOHEADER, *PCS_BITMAPINFOHEADER;


// Used for true colour images that also have a palette

typedef struct tag_CS_TRUECOLORINFO {
    DWORD   dwBitMascs[CS_iMASK_COLORS];
    CS_RGBQUAD bmiColors[CS_iPALETTE_COLORS];
} CS_TRUECOLORINFO, *PCS_TRUECOLORINFO;


#define CS_WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define CS_DIBWIDTHBYTES(bi) (DWORD)CS_WIDTHBYTES((DWORD)(bi).biWidth * (DWORD)(bi).biBitCount)
#define CS__DIBSIZE(bi) (CS_DIBWIDTHBYTES(bi) * (DWORD)(bi).biHeight)
#define CS_DIBSIZE(bi) ((bi).biHeight < 0 ? (-1)*(CS__DIBSIZE(bi)) : CS__DIBSIZE(bi))

#define CS_DIBSTRIDEBYTES(bi) ((DWORD)(bi).biSizeImage/(DWORD)(bi).biHeight)

typedef LONGLONG REFERENCE_TIME;

// The BITMAPINFOHEADER contains all the details about the video stream such
// as the actual image dimensions and their pixel depth. A source filter may
// also request that the sink take only a section of the video by providing a
// clipping rectangle in rcSource. In the worst case where the sink filter
// forgets to check this on connection it will simply render the whole thing
// which isn't a disaster. Ideally a sink filter will check the rcSource and
// if it doesn't support image extraction and the rectangle is not empty then
// it will reject the connection. A filter should use SetRectEmpty to reset a
// rectangle to all zeroes (and IsRectEmpty to later check the rectangle).
// The rcTarget specifies the destination rectangle for the video, for most
// source filters they will set this to all zeroes, a downstream filter may
// request that the video be placed in a particular area of the buffers it
// supplies in which case it will call QueryAccept with a non empty target
typedef struct tagCS_VIDEOINFOHEADER {

    RECT                rcSource;          // The bit we really want to use
    RECT                rcTarget;          // Where the video should go
    DWORD               dwBitRate;         // Approximate bit data rate
    DWORD               dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME      AvgTimePerFrame;   // Average time per frame (100ns units)

    CS_BITMAPINFOHEADER bmiHeader;
    union 
    {
        DWORD               dwBitMasks[CS_iMASK_COLORS];       // True colour masks
        CS_TRUECOLORINFO    TrueColorInfo;                     // Both of the above
    };

} CS_VIDEOINFOHEADER, *PCS_VIDEOINFOHEADER;
// !!! WARNING !!!
// DO NOT use the following structure unless you are sure that the BITMAPINFOHEADER
// has a normal biSize == sizeof(BITMAPINFOHEADER) !
// !!! WARNING !!!

typedef struct tagCS_VIDEOINFO {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    CS_BITMAPINFOHEADER bmiHeader;

    union {
        DWORD               dwBitMasks[CS_iMASK_COLORS];       // True colour mascs
        CS_TRUECOLORINFO    TrueColorInfo;                     // Both of the above
    };

} CS_VIDEOINFO, *PCS_VIDEOINFO;


#define CS_SIZE_MASCS (CS_iMASK_COLORS * sizeof(DWORD))
#define CS_SIZE_PREHEADER (FIELD_OFFSET(CS_VIDEOINFOHEADER,bmiHeader))

// For normal size
// #define CS_SIZE_VIDEOHEADER (sizeof(CS_BITMAPINFOHEADER) + CS_SIZE_PREHEADER)
// !!! for abnormal biSizes
#define CS_SIZE_VIDEOHEADER(pbmi) ((pbmi)->bmiHeader.biSize + CS_SIZE_PREHEADER)

// VBI
// Used for NABTS, CC, Intercast, WST
typedef struct tagCS_VBIINFOHEADER {
    ULONG       StartLine;              // inclusive
    ULONG       EndLine;                // inclusive
    ULONG       SamplingFrequency;      // Hz.
    ULONG       MinLineStartTime;       // microSec * 100 from HSync LE
    ULONG       MaxLineStartTime;       // microSec * 100 from HSync LE
    ULONG       ActualLineStartTime;    // microSec * 100 from HSync LE
    ULONG       ActualLineEndTime;      // microSec * 100 from HSync LE
    ULONG       VideoStandard;          // CS_AnalogVideoStandard*
    ULONG       SamplesPerLine;
    ULONG       StrideInBytes;          // May be > SamplesPerLine
    ULONG       BufferSize;             // Bytes
} CS_VBIINFOHEADER, *PCS_VBIINFOHEADER;

// VBI Sampling Rates
#define CS_VBIDATARATE_NABTS            (5727272L)
#define CS_VBIDATARATE_CC               ( 503493L)    // ~= 1/1.986125e-6
#define CS_VBISAMPLINGRATE_4X_NABTS     ((long)(4*CS_VBIDATARATE_NABTS))
#define CS_VBISAMPLINGRATE_47X_NABTS    ((long)(27000000))
#define CS_VBISAMPLINGRATE_5X_NABTS     ((long)(5*CS_VBIDATARATE_NABTS))

#define CS_47NABTS_SCALER (CS_VBISAMPLINGRATE_47X_NABTS/(double)CS_VBIDATARATE_NABTS)

// Analog video variant - Use this when the format is FORMAT_AnalogVideo
//
// rcSource defines the portion of the active video signal to use
// rcTarget defines the destination rectangle
//    both of the above are relative to the dwActiveWidth and dwActiveHeight fields
// dwActiveWidth is currently set to 720 for all formats (but could change for HDTV)
// dwActiveHeight is 483 for NTSC and 575 for PAL/SECAM  (but could change for HDTV)

typedef struct tagCS_AnalogVideoInfo {
    RECT            rcSource;           // Width max is 720, height varies w/ TransmissionStd
    RECT            rcTarget;           // Where the video should go
    DWORD           dwActiveWidth;      // Always 720 (CCIR-601 active samples per line)
    DWORD           dwActiveHeight;     // 483 for NTSC, 575 for PAL/SECAM
    REFERENCE_TIME  AvgTimePerFrame;    // Normal ActiveMovie units (100 nS)
} CS_ANALOGVIDEOINFO, *PCS_ANALOGVIDEOINFO;

//===========================================================================
// Data packet passed on Analog video stream channel change
//===========================================================================

#define CS_TVTUNER_CHANGE_BEGIN_TUNE    0x0001L  // Starting a tuning operation
#define CS_TVTUNER_CHANGE_END_TUNE      0x0002L  // Ending a tuning operation

typedef struct tagCS_TVTUNER_CHANGE_INFO {
   DWORD                    dwFlags;                // CS_TVTUNER_CHANGE_*
   DWORD                    dwCountryCode;
   DWORD                    dwAnalogVideoStandard;  // CS_AnalogVideoStandard
   DWORD                    dwChannel;
} CS_TVTUNER_CHANGE_INFO, *PCS_TVTUNER_CHANGE_INFO;

//===========================================================================
// Video format bloccs
//===========================================================================

typedef enum {
    CS_MPEG2Level_Low,
    CS_MPEG2Level_Main,
    CS_MPEG2Level_High1440,
    CS_MPEG2Level_High
} CS_MPEG2Level;

typedef enum {
    CS_MPEG2Profile_Simple,
    CS_MPEG2Profile_Main,
    CS_MPEG2Profile_SNRScalable,
    CS_MPEG2Profile_SpatiallyScalable,
    CS_MPEG2Profile_High
} CS_MPEG2Profile;

#define CS_INTERLACE_IsInterlaced            0x00000001  // if 0, other interlace bits are irrelevent
#define CS_INTERLACE_1FieldPerSample         0x00000002  // else 2 fields per media sample
#define CS_INTERLACE_Field1First             0x00000004  // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
#define CS_INTERLACE_UNUSED                  0x00000008  //
#define CS_INTERLACE_FieldPatternMask        0x00000030  // use this mask with AMINTERLACE_FieldPat*
#define CS_INTERLACE_FieldPatField1Only      0x00000000  // Data never contains a Field2
#define CS_INTERLACE_FieldPatField2Only      0x00000010  // Data never contains a Field1
#define CS_INTERLACE_FieldPatBothRegular     0x00000020  // There will be a Field2 for every Field1 (required for Weave?)
#define CS_INTERLACE_FieldPatBothIrregular   0x00000030  // Random pattern of Field1s and Field2s
#define CS_INTERLACE_DisplayModeMask         0x000000c0
#define CS_INTERLACE_DisplayModeBobOnly      0x00000000
#define CS_INTERLACE_DisplayModeWeaveOnly    0x00000040
#define CS_INTERLACE_DisplayModeBobOrWeave   0x00000080



#define CS_MPEG2_DoPanScan           0x00000001  //if set, the MPEG-2 video decoder should crop output image
                                                //  based on pan-scan vectors in picture_display_extension
                                                //  and change the picture aspect ratio accordingly.
#define CS_MPEG2_DVDLine21Field1     0x00000002  //if set, the MPEG-2 decoder must be able to produce an output
                                                //  pin for DVD style closed caption data found in GOP layer of field 1
#define CS_MPEG2_DVDLine21Field2     0x00000004  //if set, the MPEG-2 decoder must be able to produce an output
                                                //  pin for DVD style closed caption data found in GOP layer of field 2
#define CS_MPEG2_SourceIsLetterboxed 0x00000008  //if set, indicates that black bars have been encoded in the top
                                                //  and bottom of the video.
#define CS_MPEG2_FilmCameraMode      0x00000010  //if set, indicates "film mode" used for 625/50 content.  If cleared,
                                                //  indicates that "camera mode" was used.
#define CS_MPEG2_LetterboxAnalogOut  0x00000020  //if set and this stream is sent to an analog output, it should
                        //  be letterboxed.  Streams sent to VGA should be letterboxed only by renderers.
#define CS_MPEG2_DSS_UserData        0x00000040  //if set, the MPEG-2 decoder must process DSS style user data
#define CS_MPEG2_DVB_UserData        0x00000080  //if set, the MPEG-2 decoder must process DVB style user data
#define CS_MPEG2_27MhzTimebase       0x00000100  //if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz

typedef struct tagCS_VIDEOINFOHEADER2 {
    RECT                rcSource;
    RECT                rcTarget;
    DWORD               dwBitRate;
    DWORD               dwBitErrorRate;
    REFERENCE_TIME      AvgTimePerFrame;
    DWORD               dwInterlaceFlags;   // use AMINTERLACE_* defines. Reject connection if undefined bits are not 0
    DWORD               dwCopyProtectFlags; // use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0
    DWORD               dwPictAspectRatioX; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display
    DWORD               dwPictAspectRatioY; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
    DWORD               dwReserved1;        // must be 0; reject connection otherwise
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    CS_BITMAPINFOHEADER bmiHeader;
    union 
    {
        DWORD               dwBitMasks[CS_iMASK_COLORS];       // True colour masks
        CS_TRUECOLORINFO    TrueColorInfo;                     // Both of the above
    };

} CS_VIDEOINFOHEADER2, *PCS_VIDEOINFOHEADER2;

typedef struct tagCS_MPEG1VIDEOINFO {
    CS_VIDEOINFOHEADER hdr; // Compatible with VIDEOINFO
    DWORD dwStartTimeCode; // 25-bit Group of pictures time code at start of data
    DWORD cbSequenceHeader; // Length in bytes of bSequenceHeader
    BYTE bSequenceHeader[1]; // Sequence header including quantization matrices if any
} CS_MPEG1VIDEOINFO, *PCS_MPEG1VIDEOINFO;

#define CS_MAX_SIZE_MPEG1_SEQUENCE_INFO 140
#define CS_SIZE_MPEG1VIDEOINFO(pv) (FIELD_OFFSET(CS_MPEG1VIDEOINFO, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define CS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

typedef struct tagCS_MPEGVIDEOINFO2 {
    CS_VIDEOINFOHEADER2 hdr;
    DWORD               dwStartTimeCode;        //  ?? not used for DVD ??
    DWORD               cbSequenceHeader;       // is 0 for DVD (no sequence header)
    DWORD               dwProfile;              // use enum MPEG2Profile
    DWORD               dwLevel;                // use enum MPEG2Level
    DWORD               dwFlags;                // use AMMPEG2_* defines.  Reject connection if undefined bits are not 0
    DWORD               bSequenceHeader[1];     // DWORD instead of Byte for alignment purposes
                                                //   For MPEG-2, if a sequence_header is included, the sequence_extension
                                                //   should also be included
} CS_MPEGVIDEOINFO2, *PCS_MPEGVIDEOINFO2;


#define CS_SIZE_MPEGVIDEOINFO2(pv) (FIELD_OFFSET(CS_MPEGVIDEOINFO2, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define CS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

//===========================================================================
// Audio format bloccs
//===========================================================================

//if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz
#define CS_MPEGAUDIOINFO_27MhzTimebase      0x00000001

typedef struct tagCS_MPEAUDIOINFO {
    DWORD               dwFlags;            // use CS_MPEGAUDIOINFO_* defines.  Reject connection if undefined bits are not 0
    DWORD               dwReserved1;        // must be 0; reject connection otherwise
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    DWORD               dwReserved3;        // must be 0; reject connection otherwise
} CS_MPEGAUDIOINFO, *PCS_MPEGAUDIOINFO;

//===========================================================================
// Video DATAFORMATs
//===========================================================================

typedef struct tagCS_DATAFORMAT_VIDEOINFOHEADER {
    CSDATAFORMAT            DataFormat;
    CS_VIDEOINFOHEADER      VideoInfoHeader;
} CS_DATAFORMAT_VIDEOINFOHEADER, *PCS_DATAFORMAT_VIDEOINFOHEADER;

typedef struct tagCS_DATAFORMAT_VIDEOINFOHEADER2 {
    CSDATAFORMAT            DataFormat;
    CS_VIDEOINFOHEADER2     VideoInfoHeader2;
} CS_DATAFORMAT_VIDEOINFOHEADER2, *PCS_DATAFORMAT_VIDEOINFOHEADER2;

#ifdef UNDER_CE
typedef struct tagCS_DATAFORMAT_MPEG1_VIDEO {
    CSDATAFORMAT            DataFormat;
    CS_MPEG1VIDEOINFO       VideoInfoHeader;
} CS_DATAFORMAT_MPEG1_VIDEO, *OCS_DATAFORMAT_MPEG1_VIDEO;

typedef struct tagCS_DATAFORMAT_MPEG2_VIDEO {
    CSDATAFORMAT            DataFormat;
    CS_MPEG1VIDEOINFO       VideoInfoHeader;
} CS_DATAFORMAT_MPEG2_VIDEO, *PCS_DATAFORMAT_MPEG2_VIDEO;

#endif

typedef struct tagCS_DATAFORMAT_VIDEOINFO_PALETTE {
    CSDATAFORMAT            DataFormat;
    CS_VIDEOINFO            VideoInfo;
} CS_DATAFORMAT_VIDEOINFO_PALETTE, *PCS_DATAFORMAT_VIDEOINFO_PALETTE;

typedef struct tagCS_DATAFORMAT_VBIINFOHEADER {
    CSDATAFORMAT            DataFormat;
    CS_VBIINFOHEADER        VBIInfoHeader;
} CS_DATAFORMAT_VBIINFOHEADER, *PCS_DATAFORMAT_VBIINFOHEADER;

typedef struct  _CS_VIDEO_STREAM_CONFIG_CAPS  {
    GUID guid;                  // will be MEDIATYPE_Video
    ULONG VideoStandard;        // logical OR of all AnalogVideoStandards
                                // supported
    SIZE InputSize;             // the inherent size of the incoming signal
                                // (every pixel unique)
    SIZE MinCroppingSize;       // smallest rcSrc cropping rect allowed
    SIZE MaxCroppingSize;       // largest rcSrc cropping rect allowed
    int CropGranularityX;       // granularity of cropping size
    int CropGranularityY;
    int CropAlignX;             // alignment of cropping rect
    int CropAlignY;
    SIZE MinOutputSize;         // smallest bitmap stream can produce
    SIZE MaxOutputSize;         // largest  bitmap stream can produce
    int OutputGranularityX;     // granularity of output bitmap size
    int OutputGranularityY;
    int StretchTapsX;           // 0, no stretch, 1 pix dup, 2 interp, ...
    int StretchTapsY;           //    Describes quality of hardware scaler
    int ShrinkTapsX;            //
    int ShrinkTapsY;            //
    LONGLONG MinFrameInterval;  // 100 nS units
    LONGLONG MaxFrameInterval;
    LONG MinBitsPerSecond;
    LONG MaxBitsPerSecond;
} CS_VIDEO_STREAM_CONFIG_CAPS, *PCS_VIDEO_STREAM_CONFIG_CAPS;

//===========================================================================
// Video DATARANGEs
//===========================================================================

typedef struct tagCS_DATARANGE_VIDEO {
   CSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // CS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // CS_VIDEO_ALLOC_*
   CS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   CS_VIDEOINFOHEADER           VideoInfoHeader;        // default format
} CS_DATARANGE_VIDEO, *PCS_DATARANGE_VIDEO;

typedef struct tagCS_DATARANGE_VIDEO2 {
   CSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // CS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // CS_VIDEO_ALLOC_*
   CS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   CS_VIDEOINFOHEADER2          VideoInfoHeader;        // default format
} CS_DATARANGE_VIDEO2, *PCS_DATARANGE_VIDEO2;

typedef struct tagCS_DATARANGE_MPEG1_VIDEO {
    CSDATARANGE DataRange;
    BOOL bFixedSizeSamples; // all samples same size?
    BOOL bTemporalCompression; // all I frames?
    DWORD StreamDescriptionFlags; // CS_VIDEO_DESC_*
    DWORD MemoryAllocationFlags; // CS_VIDEO_ALLOC_*
    CS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
    CS_MPEG1VIDEOINFO VideoInfoHeader; // default format
} CS_DATARANGE_MPEG1_VIDEO, *PCS_DATARANGE_MPEG1_VIDEO;

typedef struct tagCS_DATARANGE_MPEG2_VIDEO {
   CSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // CS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // CS_VIDEO_ALLOC_*
   CS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   CS_MPEGVIDEOINFO2            VideoInfoHeader;        // default format
} CS_DATARANGE_MPEG2_VIDEO, *PCS_DATARANGE_MPEG2_VIDEO;

typedef struct tagCS_DATARANGE_VIDEO_PALETTE {
   CSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // CS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // CS_VIDEO_ALLOC_*
   CS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   CS_VIDEOINFO                 VideoInfo;              // default format
} CS_DATARANGE_VIDEO_PALETTE, *PCS_DATARANGE_VIDEO_PALETTE;

typedef struct tagCS_DATARANGE_VIDEO_VBI {
   CSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // CS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // CS_VIDEO_ALLOC_*
   CS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   CS_VBIINFOHEADER             VBIInfoHeader;          // default format
} CS_DATARANGE_VIDEO_VBI, *PCS_DATARANGE_VIDEO_VBI;

typedef struct tagCS_DATARANGE_ANALOGVIDEO {
   CSDATARANGE                  DataRange;
   CS_ANALOGVIDEOINFO           AnalogVideoInfo;
} CS_DATARANGE_ANALOGVIDEO, *PCS_DATARANGE_ANALOGVIDEO;

//===========================================================================
// StreamDescriptionFlags
//
// These define the "purpose" of each video stream
//===========================================================================

#define CS_VIDEOSTREAM_PREVIEW          0x0001  // Preview stream
#define CS_VIDEOSTREAM_CAPTURE          0x0002  // Capture stream
#define CS_VIDEOSTREAM_VBI              0x0010  // Field1 VBI
#define CS_VIDEOSTREAM_NABTS            0x0020  // Field1 NABTS
#define CS_VIDEOSTREAM_CC               0x0100  // Closed Captioning
#define CS_VIDEOSTREAM_EDS              0x0200  // Extended Data Services
#define CS_VIDEOSTREAM_TELETEXT         0x0400  // Field1 Teletext only
#define CS_VIDEOSTREAM_STILL            0x1000  // Still image input
#define CS_VIDEOSTREAM_IS_VPE           0x8000  // Is a VPE based stream?

// MemoryAllocationFlags
#define CS_VIDEO_ALLOC_VPE_SYSTEM       0x0001  // VPE surface in system memory
#define CS_VIDEO_ALLOC_VPE_DISPLAY      0x0002  // VPE surface in display memory
#define CS_VIDEO_ALLOC_VPE_AGP          0x0004  // VPE surface in AGP memory


#ifndef UNDER_CE
//////////////////////////////////////////////////////////////
// Capture driver VBI property sets
//////////////////////////////////////////////////////////////

// {F162C607-7B35-496f-AD7F-2DCA3B46B718}
#define STATIC_CSPROPSETID_VBICAP_PROPERTIES\
    0xf162c607, 0x7b35, 0x496f, 0xad, 0x7f, 0x2d, 0xca, 0x3b, 0x46, 0xb7, 0x18
DEFINE_GUIDSTRUCT("F162C607-7B35-496f-AD7F-2DCA3B46B718", CSPROPSETID_VBICAP_PROPERTIES);
#define CSPROPSETID_VBICAP_PROPERTIES DEFINE_GUIDNAMED(CSPROPSETID_VBICAP_PROPERTIES)

typedef enum {
    CSPROPERTY_VBICAP_PROPERTIES_PROTECTION = 0x01,
} CSPROPERTY_VBICAP;

typedef struct _VBICAP_PROPERTIES_PROTECTION_S {
    CSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      Status;
} VBICAP_PROPERTIES_PROTECTION_S, *PVBICAP_PROPERTIES_PROTECTION_S;
#define CS_VBICAP_PROTECTION_MV_PRESENT     0x0001L
#define CS_VBICAP_PROTECTION_MV_HARDWARE    0x0002L
#define CS_VBICAP_PROTECTION_MV_DETECTED    0x0004L


/***************************************************************************/
/* VBI Related GUIDs, structs and properties for codecs(generic, cc, nabts)*/
/***************************************************************************/

///////////////////////////////////////////////////////////////////////////////////////
// IP/NABTS Protocol Reserved Group IDs - Overall Range 0x800-0x8FF [Decimal 2048-2079]
// Intervening values(0-F) are used if there are multiple providers at a particular tier
///////////////////////////////////////////////////////////////////////////////////////

// Used by individual content creators in show footage/data
#define CS_NABTS_GROUPID_ORIGINAL_CONTENT_BASE                 0x800
#define CS_NABTS_GROUPID_ORIGINAL_CONTENT_ADVERTISER_BASE      0x810

// Used by production company in finished show data
#define CS_NABTS_GROUPID_PRODUCTION_COMPANY_CONTENT_BASE       0x820
#define CS_NABTS_GROUPID_PRODUCTION_COMPANY_ADVERTISER_BASE    0x830

// Used by broadcast syndicates in syndicated show data
#define CS_NABTS_GROUPID_SYNDICATED_SHOW_CONTENT_BASE          0x840
#define CS_NABTS_GROUPID_SYNDICATED_SHOW_ADVERTISER_BASE       0x850

// Used by tv networcs in network television data
#define CS_NABTS_GROUPID_NETWORK_WIDE_CONTENT_BASE             0x860
#define CS_NABTS_GROUPID_NETWORK_WIDE_ADVERTISER_BASE          0x870

// Used by telvision stations in local programming data
#define CS_NABTS_GROUPID_TELEVISION_STATION_CONTENT_BASE       0x880
#define CS_NABTS_GROUPID_TELEVISION_STATION_ADVERTISER_BASE    0x890

// Used by cable system in cable head-end originated data
#define CS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_CONTENT_BASE       0x8A0
#define CS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_ADVERTISER_BASE    0x8B0

// The values between 0x8C0 - 0x8EF are reserved for future expansion

// Used by Microsoft for Testing purposes (0x8F0 - 0x8FF)
#define CS_NABTS_GROUPID_MICROSOFT_RESERVED_TEST_DATA_BASE     0x8F0

//////////////////////////////////////////////////////////////
// Stream Format FEC-corrected NABTS bundles
//////////////////////////////////////////////////////////////

#define STATIC_CSDATAFORMAT_TYPE_NABTS \
 0xe757bca0, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("E757BCA0-39AC-11d1-A9F5-00C04FBBDE8F", CSDATAFORMAT_TYPE_NABTS);
#define CSDATAFORMAT_TYPE_NABTS DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_NABTS)

#define STATIC_CSDATAFORMAT_SUBTYPE_NABTS_FEC \
 0xe757bca1, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("E757BCA1-39AC-11d1-A9F5-00C04FBBDE8F", CSDATAFORMAT_SUBTYPE_NABTS_FEC);
#define CSDATAFORMAT_SUBTYPE_NABTS_FEC DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_NABTS_FEC)


//////////////////////////////////////////////////////////////
// NABTS Bundle data structure definition
//////////////////////////////////////////////////////////////

#define MAX_NABTS_VBI_LINES_PER_FIELD   11
#define NABTS_LINES_PER_BUNDLE          16
#define NABTS_PAYLOAD_PER_LINE          28
#define NABTS_BYTES_PER_LINE            36

typedef struct _NABTSFEC_BUFFER {
    ULONG       dataSize;
    USHORT      groupID;
    USHORT      Reserved;
    UCHAR       data[NABTS_LINES_PER_BUNDLE * NABTS_PAYLOAD_PER_LINE];
} NABTSFEC_BUFFER, *PNABTSFEC_BUFFER;

//////////////////////////////////////////////////////////////
// vbi codec filtering pin properties
//////////////////////////////////////////////////////////////

#define STATIC_CSPROPSETID_VBICodecFiltering \
    0xcafeb0caL, 0x8715, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0xc0, 0xed, 0xba, 0xbe
DEFINE_GUIDSTRUCT("cafeb0ca-8715-11d0-bd6a-0035c0edbabe", CSPROPSETID_VBICodecFiltering);
#define CSPROPSETID_VBICodecFiltering DEFINE_GUIDNAMED(CSPROPSETID_VBICodecFiltering)

typedef enum {
    CSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY = 0x01,
    CSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
    CSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
    CSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
    CSPROPERTY_VBICODECFILTERING_STATISTICS,
} CSPROPERTY_VBICODECFILTERING;

typedef struct _VBICODECFILTERING_SCANLINES {
    DWORD   DwordBitArray[32];      // An array of scanline bits 0..1024(32*32)
} VBICODECFILTERING_SCANLINES, *PVBICODECFILTERING_SCANLINES;

typedef struct _VBICODECFILTERING_NABTS_SUBSTREAMS {
    DWORD   SubstreamMask[128];   // An array of 4096 bits (one for each NABTS GroupID)
} VBICODECFILTERING_NABTS_SUBSTREAMS, *PVBICODECFILTERING_NABTS_SUBSTREAMS;

typedef struct _VBICODECFILTERING_CC_SUBSTREAMS {
    DWORD   SubstreamMask;        // An array of 32 bits (see CS_CC_SUBSTREAM *)
} VBICODECFILTERING_CC_SUBSTREAMS, *PVBICODECFILTERING_CC_SUBSTREAMS;

// These CS_CC_SUBSTREAM_* bitmascs are used with VBICODECFILTERING_CC_SUBSTREAMS
#define CS_CC_SUBSTREAM_ODD               0x0001L // Unfiltered Field 1 Data
#define CS_CC_SUBSTREAM_EVEN              0x0002L // Unfiltered Field 2 Data

// The following flags describe CC field 1 substreams: CC1,CC2,TT1,TT2
#define CS_CC_SUBSTREAM_FIELD1_MASK    	  0x00F0L
#define CS_CC_SUBSTREAM_SERVICE_CC1       0x0010L
#define CS_CC_SUBSTREAM_SERVICE_CC2       0x0020L
#define CS_CC_SUBSTREAM_SERVICE_T1        0x0040L
#define CS_CC_SUBSTREAM_SERVICE_T2        0x0080L

// The following flags describe CC field 2 substreams: CC3,CC4,TT3,TT4,XDS
#define CS_CC_SUBSTREAM_FIELD2_MASK       0x1F00L
#define CS_CC_SUBSTREAM_SERVICE_CC3       0x0100L
#define CS_CC_SUBSTREAM_SERVICE_CC4       0x0200L
#define CS_CC_SUBSTREAM_SERVICE_T3        0x0400L
#define CS_CC_SUBSTREAM_SERVICE_T4        0x0800L
#define CS_CC_SUBSTREAM_SERVICE_XDS       0x1000L

// Special Note: field 1 or 2 substreams are usually on found on field 1 and 2 respectively
// If the VBI odd/even polarity is reversed, the correct filtered data will still be found.

///////////////////////////////////////////////////////////////////
// Hardware decoded CC stream format
///////////////////////////////////////////////////////////////////

#define CC_MAX_HW_DECODE_LINES 12
typedef struct _CC_BYTE_PAIR {
    BYTE        Decoded[2];
    USHORT      Reserved;
} CC_BYTE_PAIR, *PCC_BYTE_PAIR;

typedef struct _CC_HW_FIELD {
    VBICODECFILTERING_SCANLINES  ScanlinesRequested;
    ULONG                        fieldFlags;    // CS_VBI_FLAG_FIELD1,2
    LONGLONG                     PictureNumber;
    CC_BYTE_PAIR                 Lines[CC_MAX_HW_DECODE_LINES];
} CC_HW_FIELD, *PCC_HW_FIELD;

///////////////////////////////////////////////////////////////////
// Raw NABTS stream format (TYPE_NABTS, SUBTYPE_NABTS)
///////////////////////////////////////////////////////////////////

// These low-level structures are byte packed( -Zp1 )
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif
typedef struct _NABTS_BUFFER_LINE {
    BYTE                            Confidence;
    BYTE                            Bytes[NABTS_BYTES_PER_LINE];
} NABTS_BUFFER_LINE, *PNABTS_BUFFER_LINE;

#define NABTS_BUFFER_PICTURENUMBER_SUPPORT 1
typedef struct _NABTS_BUFFER {
    VBICODECFILTERING_SCANLINES     ScanlinesRequested;
    LONGLONG                        PictureNumber;
    NABTS_BUFFER_LINE               NabtsLines[MAX_NABTS_VBI_LINES_PER_FIELD];
} NABTS_BUFFER, *PNABTS_BUFFER;
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif

//////////////////////////////////////////////////////////////
// WST Codec Teletext Media Sample Format
//////////////////////////////////////////////////////////////

#define WST_TVTUNER_CHANGE_BEGIN_TUNE    0x1000L  // Starting a tuning operation
#define WST_TVTUNER_CHANGE_END_TUNE      0x2000L  // Ending a tuning operation

#define MAX_WST_VBI_LINES_PER_FIELD   17
#define WST_BYTES_PER_LINE            42

typedef struct _WST_BUFFER_LINE {
    BYTE                            Confidence;
    BYTE                            Bytes[WST_BYTES_PER_LINE];
} WST_BUFFER_LINE, *PWST_BUFFER_LINE;

typedef struct _WST_BUFFER {
    VBICODECFILTERING_SCANLINES        ScanlinesRequested;
    WST_BUFFER_LINE                    WstLines[MAX_WST_VBI_LINES_PER_FIELD];
} WST_BUFFER, *PWST_BUFFER;

//
// Common codec statistics
//

typedef struct _VBICODECFILTERING_STATISTICS_COMMON {
    DWORD   InputSRBsProcessed;         // upstream SRBs received
    DWORD   OutputSRBsProcessed;        // downstream SRBs sent
    DWORD   SRBsIgnored;                // SRBs ignored due to no requests
    DWORD   InputSRBsMissing;           // SRBs dropped upstream
    DWORD   OutputSRBsMissing;          // Output dropped because no SRB pending
    DWORD   OutputFailures;             // dropped because of other failure
    DWORD   InternalErrors;             // could not process due to int. failure
    DWORD   ExternalErrors;             // could not process due to ext. failure
    DWORD   InputDiscontinuities;       // discontinuities received
    DWORD   DSPFailures;                // DSP confidence failure
    DWORD   TvTunerChanges;             // number of received CS_TVTUNER_CHANGE_BEGIN_TUNE and CS_TVTUNER_CHANGE_END_TUNE pairs.
    DWORD   VBIHeaderChanges;           // number of received CS_VBI_FLAG_VBIINFOHEADER_CHANGE
    DWORD   LineConfidenceAvg;          // Average of all DSP confidence results
    DWORD   BytesOutput;                // Bytes sent downstream
} VBICODECFILTERING_STATISTICS_COMMON, *PVBICODECFILTERING_STATISTICS_COMMON;

typedef struct _VBICODECFILTERING_STATISTICS_COMMON_PIN {
    DWORD   SRBsProcessed;              // SRBs sent/received
    DWORD   SRBsIgnored;                // SRBs ignored due to filtering
    DWORD   SRBsMissing;                // SRBs not sent/received
    DWORD   InternalErrors;             // could not send/receive due to int. failure
    DWORD   ExternalErrors;             // could not send/receive due to ext. failure
    DWORD   Discontinuities;            // discontinuities received/sent
    DWORD   LineConfidenceAvg;          // Average of all DSP confidence results for this pin
    DWORD   BytesOutput;                // Bytes sent downstream
} VBICODECFILTERING_STATISTICS_COMMON_PIN, *PVBICODECFILTERING_STATISTICS_COMMON_PIN;

//
// Codec-specific statistics - NABTS
//

typedef struct _VBICODECFILTERING_STATISTICS_NABTS {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
    DWORD   FECBundleBadLines;          // Un-FEC-correctable lines
    DWORD   FECQueueOverflows;          // Number of times FEC queue overflowed
    DWORD   FECCorrectedLines;          // Lines CSUM corrected by FEC
    DWORD   FECUncorrectableLines;      // FEC input lines not CSUM correctable
    DWORD   BundlesProcessed;           // Bundles received from FEC
    DWORD   BundlesSent2IP;             // Bundles sent to IP driver
    DWORD   FilteredLines;              // Lines processed and then dropped
                                        // because no one was interested
} VBICODECFILTERING_STATISTICS_NABTS, *PVBICODECFILTERING_STATISTICS_NABTS;

typedef struct _VBICODECFILTERING_STATISTICS_NABTS_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_NABTS_PIN, *PVBICODECFILTERING_STATISTICS_NABTS_PIN;

//
// Codec-specific statistics - Closed Caption
//

typedef struct _VBICODECFILTERING_STATISTICS_CC {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
} VBICODECFILTERING_STATISTICS_CC, *PVBICODECFILTERING_STATISTICS_CC;


typedef struct _VBICODECFILTERING_STATISTICS_CC_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_CC_PIN, *PVBICODECFILTERING_STATISTICS_CC_PIN;

//
// Codec-specific statistics - Closed Caption
//

typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
} VBICODECFILTERING_STATISTICS_TELETEXT, *PVBICODECFILTERING_STATISTICS_TELETEXT;

typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_TELETEXT_PIN, *PVBICODECFILTERING_STATISTICS_TELETEXT_PIN;

////////////////////////////////////////////////////////////////////////////
// VBI codec property structures(based on CSPROPERTY_VBICODECFILTERING enum)
////////////////////////////////////////////////////////////////////////////

// *** Most codecs support this property
//    CSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY
//    CSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
typedef struct {
    CSPROPERTY                          Property;
    VBICODECFILTERING_SCANLINES         Scanlines;
} CSPROPERTY_VBICODECFILTERING_SCANLINES_S, *PCSPROPERTY_VBICODECFILTERING_SCANLINES_S;

// *** NABTS codecs support this property
//    CSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
//    CSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
typedef struct {
    CSPROPERTY                          Property;
    VBICODECFILTERING_NABTS_SUBSTREAMS  Substreams;
} CSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S, *PCSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S;

// *** Closed captioning codecs support this property
//    CSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
//    CSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_CC_SUBSTREAMS         Substreams;
} CSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S, *PCSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S;

// *** Most codecs support these versions of the global and pin properties
//    CSPROPERTY_VBICODECFILTERING_STATISTICS
typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_COMMON     Statistics;
} CSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S, *PCSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S;

typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_COMMON_PIN Statistics;
} CSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S, *PCSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S;

// *** NABTS codecs support this version of the global and pin properties
//    CSPROPERTY_VBICODECFILTERING_STATISTICS
typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_NABTS      Statistics;
} CSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S, *PCSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S;

typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_NABTS_PIN  Statistics;
} CSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S, *PCSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S;

// *** Closed captioning codecs support this version of the global and pin properties
//    CSPROPERTY_VBICODECFILTERING_STATISTICS

typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_CC         Statistics;
} CSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S, *PCSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S;

typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_CC_PIN     Statistics;
} CSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S, *PCSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S;

#endif //#ifndef UNDER_CE

// Standard Pin Names for the video capture filter
//===========================================================================

#define STATIC_PINNAME_VIDEO_CAPTURE \
    0xfb6c4281, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define STATIC_PINNAME_CAPTURE STATIC_PINNAME_VIDEO_CAPTURE
DEFINE_GUIDSTRUCT("FB6C4281-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CAPTURE);
#define PINNAME_VIDEO_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CAPTURE)
#define PINNAME_CAPTURE PINNAME_VIDEO_CAPTURE

#ifndef UNDER_CE
#define STATIC_PINNAME_VIDEO_CC_CAPTURE \
    0x1aad8061, 0x12d, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
#define STATIC_PINNAME_CC_CAPTURE STATIC_PINNAME_VIDEO_CC_CAPTURE
DEFINE_GUIDSTRUCT("1AAD8061-012D-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_CC_CAPTURE);
#define PINNAME_VIDEO_CC_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CC_CAPTURE)

#define STATIC_PINNAME_VIDEO_NABTS_CAPTURE \
    0x29703660, 0x498a, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
#define STATIC_PINNAME_NABTS_CAPTURE STATIC_PINNAME_VIDEO_NABTS_CAPTURE
DEFINE_GUIDSTRUCT("29703660-498A-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_NABTS_CAPTURE);
#define PINNAME_VIDEO_NABTS_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS_CAPTURE)
#endif //#ifndef UNDER_CE

#define STATIC_PINNAME_VIDEO_PREVIEW \
    0xfb6c4282, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define STATIC_PINNAME_PREVIEW STATIC_PINNAME_VIDEO_PREVIEW
DEFINE_GUIDSTRUCT("FB6C4282-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_PREVIEW);
#define PINNAME_VIDEO_PREVIEW DEFINE_GUIDNAMED(PINNAME_VIDEO_PREVIEW)
#define PINNAME_PREVIEW PINNAME_VIDEO_PREVIEW

#ifndef UNDER_CE
#define STATIC_PINNAME_VIDEO_ANALOGVIDEOIN \
    0xfb6c4283, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4283-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_ANALOGVIDEOIN);
#define PINNAME_VIDEO_ANALOGVIDEOIN DEFINE_GUIDNAMED(PINNAME_VIDEO_ANALOGVIDEOIN)

#define STATIC_PINNAME_VIDEO_VBI \
    0xfb6c4284, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4284-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VBI);
#define PINNAME_VIDEO_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VBI)

#endif //#ifndef UNDER_CE

#define STATIC_PINNAME_VIDEO_VIDEOPORT \
    0xfb6c4285, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4285-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT);
#define PINNAME_VIDEO_VIDEOPORT DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT)

#ifndef UNDER_CE

#define STATIC_PINNAME_VIDEO_NABTS \
    0xfb6c4286, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4286-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_NABTS);
#define PINNAME_VIDEO_NABTS DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS)

#define STATIC_PINNAME_VIDEO_EDS \
    0xfb6c4287, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4287-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_EDS);
#define PINNAME_VIDEO_EDS DEFINE_GUIDNAMED(PINNAME_VIDEO_EDS)

#define STATIC_PINNAME_VIDEO_TELETEXT \
    0xfb6c4288, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4288-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TELETEXT);
#define PINNAME_VIDEO_TELETEXT DEFINE_GUIDNAMED(PINNAME_VIDEO_TELETEXT)

#define STATIC_PINNAME_VIDEO_CC \
    0xfb6c4289, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4289-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CC);
#define PINNAME_VIDEO_CC DEFINE_GUIDNAMED(PINNAME_VIDEO_CC)
#endif //#ifndef UNDER_CE

#define STATIC_PINNAME_VIDEO_STILL \
    0xfb6c428A, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428A-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_STILL);
#define PINNAME_VIDEO_STILL DEFINE_GUIDNAMED(PINNAME_VIDEO_STILL)

#ifndef UNDER_CE
#define STATIC_PINNAME_VIDEO_TIMECODE \
    0xfb6c428B, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428B-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TIMECODE);
#define PINNAME_VIDEO_TIMECODE DEFINE_GUIDNAMED(PINNAME_VIDEO_TIMECODE)

#define STATIC_PINNAME_VIDEO_VIDEOPORT_VBI \
    0xfb6c428C, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428C-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT_VBI);
#define PINNAME_VIDEO_VIDEOPORT_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT_VBI)
#endif //#ifndef UNDER_CE

//===========================================================================
// CSSTREAM_HEADER extensions for digital video
//===========================================================================

#define CS_VIDEO_FLAG_FRAME      0x0000L        // Frame or Field (default is frame)
#define CS_VIDEO_FLAG_FIELD1     0x0001L
#define CS_VIDEO_FLAG_FIELD2     0x0002L

#define CS_VIDEO_FLAG_I_FRAME    0x0000L        // I, B, or P (default is I)
#define CS_VIDEO_FLAG_P_FRAME    0x0010L
#define CS_VIDEO_FLAG_B_FRAME    0x0020L

typedef struct tagCS_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;       // Field1, Field2, or Frame
    LONGLONG                PictureNumber;
    LONGLONG                DropCount;

    // The following are only set when using OverlayMixer
    HANDLE                  hDirectDraw;        // user mode DDraw handle
    HANDLE                  hSurfaceHandle;     // user mode surface handle
    RECT                    DirectDrawRect;     // portion of surface locked
    // Reserved fields, never reference these
    DWORD                   Reserved1;
    DWORD                   Reserved2;
    DWORD                   Reserved3;
    DWORD                   Reserved4;
} CS_FRAME_INFO, *PCS_FRAME_INFO;

#ifndef UNDER_CE
//===========================================================================
// CSSTREAM_HEADER extensions for VBI
//===========================================================================

#define CS_VBI_FLAG_FIELD1               0x0001L
#define CS_VBI_FLAG_FIELD2               0x0002L

#define CS_VBI_FLAG_MV_PRESENT           0x0100L
#define CS_VBI_FLAG_MV_HARDWARE          0x0200L
#define CS_VBI_FLAG_MV_DETECTED          0x0400L

#define CS_VBI_FLAG_TVTUNER_CHANGE       0x0010L // TvTunerChangeInfo is valid
#define CS_VBI_FLAG_VBIINFOHEADER_CHANGE 0x0020L // VBIInfoHeader is valid

typedef struct tagCS_VBI_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;  // Field1, Field2, or Frame; & etc
    LONGLONG                PictureNumber; // Test only?
    LONGLONG                DropCount;     // Test only?
    DWORD                   dwSamplingFrequency;
    CS_TVTUNER_CHANGE_INFO  TvTunerChangeInfo;
    CS_VBIINFOHEADER        VBIInfoHeader;
} CS_VBI_FRAME_INFO, *PCS_VBI_FRAME_INFO;


//===========================================================================
// Analog video formats, used with:
//      Analog Video Decoders
//      TVTuners
//      Analog Video Encoders
//
// XXX_STANDARDS_SUPPORTED returns a bitmask
//===========================================================================
#endif //#ifndef UNDER_CE
typedef enum
{
    CS_AnalogVideo_None     = 0x00000000  // This is a digital sensor
#ifndef UNDER_CE
	,
	CS_AnalogVideo_NTSC_M   = 0x00000001,  //        75 IRE Setup
    CS_AnalogVideo_NTSC_M_J = 0x00000002,  // Japan,  0 IRE Setup
    CS_AnalogVideo_NTSC_433 = 0x00000004,

    CS_AnalogVideo_PAL_B    = 0x00000010,
    CS_AnalogVideo_PAL_D    = 0x00000020,
    CS_AnalogVideo_PAL_G    = 0x00000040,
    CS_AnalogVideo_PAL_H    = 0x00000080,
    CS_AnalogVideo_PAL_I    = 0x00000100,
    CS_AnalogVideo_PAL_M    = 0x00000200,
    CS_AnalogVideo_PAL_N    = 0x00000400,

    CS_AnalogVideo_PAL_60   = 0x00000800,

    CS_AnalogVideo_SECAM_B  = 0x00001000,
    CS_AnalogVideo_SECAM_D  = 0x00002000,
    CS_AnalogVideo_SECAM_G  = 0x00004000,
    CS_AnalogVideo_SECAM_H  = 0x00008000,
    CS_AnalogVideo_SECAM_K  = 0x00010000,
    CS_AnalogVideo_SECAM_K1 = 0x00020000,
    CS_AnalogVideo_SECAM_L  = 0x00040000,
    CS_AnalogVideo_SECAM_L1 = 0x00080000,

    CS_AnalogVideo_PAL_N_COMBO
                            = 0x00100000
#endif //#ifndef UNDER_CE
} CS_AnalogVideoStandard;

#ifndef UNDER_CE
#define CS_AnalogVideo_NTSC_Mask  0x00000007
#define CS_AnalogVideo_PAL_Mask   0x00100FF0
#define CS_AnalogVideo_SECAM_Mask 0x000FF000

//===========================================================================
// Property set definitions
// The comments show whether a given property is:
//      R  : READ only
//      w  : WRITE only
//      RW : READ / WRITE
//      O  : Optional (return E_UNSUPPORTED if you don't handle this)
//===========================================================================

#define STATIC_PROPSETID_ALLOCATOR_CONTROL\
    0x53171960, 0x148e, 0x11d2, 0x99, 0x79, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("53171960-148E-11d2-9979-0000C0CC16BA", PROPSETID_ALLOCATOR_CONTROL);
#define PROPSETID_ALLOCATOR_CONTROL DEFINE_GUIDNAMED(PROPSETID_ALLOCATOR_CONTROL)
typedef enum {
    CSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,      // R O (will allocate exactly this number of buffers)
    CSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE,     // R O (return 2 DWORDs specifying surface size)
    // W I (informn a capture driver whether interleave capture is possible or
    //      not - a value of 1 means that interleaved capture is supported)
    CSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS,
 
    // R O (if value == 1, then the ovmixer will turn on the DDVP_INTERLEAVE
    //      flag thus allowing interleaved capture of the video)
    CSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE,
} CSPROPERTY_ALLOCATOR_CONTROL;

typedef struct {
    //CSPROPERTY Property;
    ULONG	CX;
	ULONG	CY;
} CSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S, *PCSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S; 
 
typedef struct {
    //CSPROPERTY Property;
    ULONG	InterleavedCapSupported;
} CSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S, *PCSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S;

 
typedef struct {
    //CSPROPERTY Property;
    ULONG	InterleavedCapPossible;
} CSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S, *PCSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S;

#endif //#ifndef UNDER_CE

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEOPROCAMP\
    0xC6E13360L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13360-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOPROCAMP);
#define PROPSETID_VIDCAP_VIDEOPROCAMP DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOPROCAMP)

typedef enum {
    CSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,            // RW O
    CSPROPERTY_VIDEOPROCAMP_CONTRAST,              // RW O
    CSPROPERTY_VIDEOPROCAMP_HUE,                   // RW O
    CSPROPERTY_VIDEOPROCAMP_SATURATION,            // RW O
    CSPROPERTY_VIDEOPROCAMP_SHARPNESS,             // RW O
    CSPROPERTY_VIDEOPROCAMP_GAMMA,                 // RW O
    CSPROPERTY_VIDEOPROCAMP_COLORENABLE,           // RW O
    CSPROPERTY_VIDEOPROCAMP_WHITEBALANCE,          // RW O
    CSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,// RW O
    CSPROPERTY_VIDEOPROCAMP_GAIN,                  // RW O
} CSPROPERTY_VIDCAP_VIDEOPROCAMP;

typedef struct {
    CSPROPERTY Property;
    LONG   Value;                       // Value to set or get
    ULONG  Flags;                       // CSPROPERTY_VIDEOPROCAMP_FLAGS_*
    ULONG  Capabilities;                // CSPROPERTY_VIDEOPROCAMP_FLAGS_*
} CSPROPERTY_VIDEOPROCAMP_S, *PCSPROPERTY_VIDEOPROCAMP_S;

#define CSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO        0X0001L
#define CSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL      0X0002L

//===========================================================================
#ifndef UNDER_CE
#define STATIC_PROPSETID_TUNER\
    0x6a2e0605L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0605-28e4-11d0-a18c-00a0c9118956", PROPSETID_TUNER);
#define PROPSETID_TUNER DEFINE_GUIDNAMED(PROPSETID_TUNER)

typedef enum {
    CSPROPERTY_TUNER_CAPS,              // R  -overall device capabilities
    CSPROPERTY_TUNER_MODE_CAPS,         // R  -capabilities in this mode
    CSPROPERTY_TUNER_MODE,              // RW -set a mode (TV, FM, AM, DSS)
    CSPROPERTY_TUNER_STANDARD,          // R  -get TV standard (only if TV mode)
    CSPROPERTY_TUNER_FREQUENCY,         // RW -set/get frequency
    CSPROPERTY_TUNER_INPUT,             // RW -select an input
    CSPROPERTY_TUNER_STATUS,            // R  -tuning status
    CSPROPERTY_TUNER_IF_MEDIUM          // R O-Medium for IF or Transport Pin
} CSPROPERTY_TUNER;

typedef enum {
    CSPROPERTY_TUNER_MODE_TV            = 0X0001,
    CSPROPERTY_TUNER_MODE_FM_RADIO      = 0X0002,
    CSPROPERTY_TUNER_MODE_AM_RADIO      = 0X0004,
    CSPROPERTY_TUNER_MODE_DSS           = 0X0008,
    CSPROPERTY_TUNER_MODE_ATSC          = 0X0010,  // also used for DVB-T, DVB-C
} CSPROPERTY_TUNER_MODES;

// Describes how the device tunes.  Only one of these flags may be set
// in CSPROPERTY_TUNER_MODE_CAPS_S.Strategy

// Describe how the driver should attempt to tune:
// EXACT:   just go to the frequency specified (no fine tuning)
// FINE:    (slow) do an exhaustive search for the best signal
// COARSE:  (fast) use larger frequency jumps to just determine if any signal

typedef enum {
    CS_TUNER_TUNING_EXACT = 1,        // No fine tuning
    CS_TUNER_TUNING_FINE,             // Fine grained search
    CS_TUNER_TUNING_COARSE,           // Coarse search
}CS_TUNER_TUNING_FLAGS;

typedef enum {
    CS_TUNER_STRATEGY_PLL             = 0X01, // Tune by PLL offset
    CS_TUNER_STRATEGY_SIGNAL_STRENGTH = 0X02, // Tune by signal strength
    CS_TUNER_STRATEGY_DRIVER_TUNES    = 0X04, // Driver does fine tuning
}CS_TUNER_STRATEGY;

typedef struct {
    CSPROPERTY Property;
    ULONG  ModesSupported;              // CS_PROPERTY_TUNER_MODES_*
    CSPIN_MEDIUM VideoMedium;           // GUID_NULL (no pin), or GUID
    CSPIN_MEDIUM TVAudioMedium;         // GUID_NULL (no pin), or GUID
    CSPIN_MEDIUM RadioAudioMedium;      // GUID_NULL (no pin), or GUID
} CSPROPERTY_TUNER_CAPS_S, *PCSPROPERTY_TUNER_CAPS_S;

typedef struct {
    CSPROPERTY Property;
    CSPIN_MEDIUM IFMedium;              // GUID_NULL (no pin), or GUID
} CSPROPERTY_TUNER_IF_MEDIUM_S, *PCSPROPERTY_TUNER_IF_MEDIUM_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  Mode;                        // IN: CSPROPERTY_TUNER_MODE
    ULONG  StandardsSupported;          // CS_AnalogVideo_* (if TV or DSS)
    ULONG  MinFrequency;                // Hz
    ULONG  MaxFrequency;                // Hz
    ULONG  TuningGranularity;           // Hz
    ULONG  NumberOfInputs;              // count of inputs
    ULONG  SettlingTime;                // milliSeconds
    ULONG  Strategy;                    // CS_TUNER_STRATEGY
} CSPROPERTY_TUNER_MODE_CAPS_S, *PCSPROPERTY_TUNER_MODE_CAPS_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  Mode;                        // IN: CSPROPERTY_TUNER_MODE
} CSPROPERTY_TUNER_MODE_S, *PCSPROPERTY_TUNER_MODE_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  Frequency;                   // Hz
    ULONG  LastFrequency;               // Hz (last known good)
    ULONG  TuningFlags;                 // CS_TUNER_TUNING_FLAGS
    ULONG  VideoSubChannel;             // DSS
    ULONG  AudioSubChannel;             // DSS
    ULONG  Channel;                     // VBI decoders
    ULONG  Country;                     // VBI decoders
} CSPROPERTY_TUNER_FREQUENCY_S, *PCSPROPERTY_TUNER_FREQUENCY_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  Standard;                    // CS_AnalogVideo_*
} CSPROPERTY_TUNER_STANDARD_S, *PCSPROPERTY_TUNER_STANDARD_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  InputIndex;                  // 0 to (n-1) inputs
} CSPROPERTY_TUNER_INPUT_S, *PCSPROPERTY_TUNER_INPUT_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  CurrentFrequency;            // Hz
    ULONG  PLLOffset;                   // if Strategy.CS_TUNER_STRATEGY_PLL
    ULONG  SignalStrength;              // if Stretegy.CS_TUNER_STRATEGY_SIGNAL_STRENGTH
    ULONG  Busy;                        // TRUE if in the process of tuning
} CSPROPERTY_TUNER_STATUS_S, *PCSPROPERTY_TUNER_STATUS_S;

#define STATIC_EVENTSETID_TUNER\
    0x6a2e0606L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0606-28e4-11d0-a18c-00a0c9118956", EVENTSETID_TUNER);
#define EVENTSETID_TUNER DEFINE_GUIDNAMED(EVENTSETID_TUNER)

typedef enum {
    CSEVENT_TUNER_CHANGED
} CSEVENT_TUNER;


//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEOENCODER\
    0x6a2e0610L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0610-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOENCODER);
#define PROPSETID_VIDCAP_VIDEOENCODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOENCODER)

typedef enum {
    CSPROPERTY_VIDEOENCODER_CAPS,                       // R
    CSPROPERTY_VIDEOENCODER_STANDARD,                   // RW
    CSPROPERTY_VIDEOENCODER_COPYPROTECTION,             // RW O
    CSPROPERTY_VIDEOENCODER_CC_ENABLE,                  // RW O
} CSPROPERTY_VIDCAP_VIDEOENCODER;

typedef struct {
    CSPROPERTY Property;
    LONG       Value;                   // value to get or set
    ULONG      Flags;                   //
    ULONG      Capabilities;            //
} CSPROPERTY_VIDEOENCODER_S, *PCSPROPERTY_VIDEOENCODER_S;

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEODECODER\
    0xC6E13350L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13350-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEODECODER);
#define PROPSETID_VIDCAP_VIDEODECODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEODECODER)

typedef enum {
    CSPROPERTY_VIDEODECODER_CAPS,                       // R
    CSPROPERTY_VIDEODECODER_STANDARD,                   // RW
    CSPROPERTY_VIDEODECODER_STATUS,                     // R
    CSPROPERTY_VIDEODECODER_OUTPUT_ENABLE,              // Rw O
    CSPROPERTY_VIDEODECODER_VCR_TIMING,                 // RW O
} CSPROPERTY_VIDCAP_VIDEODECODER;

typedef enum {
    CS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT  = 0X0001, // VP Output can tri-stae
    CS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING = 0X0002, // VCR PLL timings
    CS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED = 0X0004, // Can indicate valid signal
}CS_VIDEODECODER_FLAGS;

typedef struct {
    CSPROPERTY Property;
    ULONG      StandardsSupported;      // CS_AnalogVideo_*
    ULONG      Capabilities;            // CS_VIDEODECODER_FLAGS_*
    ULONG      SettlingTime;            // milliseconds
    ULONG      HSyncPerVSync;           // Number of HSync Pulses per VSync
} CSPROPERTY_VIDEODECODER_CAPS_S, *PCSPROPERTY_VIDEODECODER_CAPS_S;

typedef struct {
    CSPROPERTY Property;
    ULONG      NumberOfLines;           // 525 or 625 lines detected
    ULONG      SignalLocked;            // TRUE if signal is locked
} CSPROPERTY_VIDEODECODER_STATUS_S, *PCSPROPERTY_VIDEODECODER_STATUS_S;

typedef struct {
    CSPROPERTY Property;
    ULONG      Value;                   // Get or set a value
} CSPROPERTY_VIDEODECODER_S, *PCSPROPERTY_VIDEODECODER_S;

#define STATIC_EVENTSETID_VIDEODECODER\
    0x6a2e0621L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0621-28e4-11d0-a18c-00a0c9118956", EVENTSETID_VIDEODECODER);
#define EVENTSETID_VIDEODECODER DEFINE_GUIDNAMED(EVENTSETID_VIDEODECODER)

typedef enum {
    CSEVENT_VIDEODECODER_CHANGED
} CSEVENT_VIDEODECODER;
#endif //#ifndef UNDER_CE

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_CAMERACONTROL\
    0xC6E13370L, 0x30AC, 0x11d0, 0xa1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13370-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_CAMERACONTROL);
#define PROPSETID_VIDCAP_CAMERACONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CAMERACONTROL)

typedef enum {
    CSPROPERTY_CAMERACONTROL_PAN,                       // RW O
    CSPROPERTY_CAMERACONTROL_TILT,                      // RW O
    CSPROPERTY_CAMERACONTROL_ROLL,                      // RW O
    CSPROPERTY_CAMERACONTROL_ZOOM,                      // RW O
    CSPROPERTY_CAMERACONTROL_EXPOSURE,                  // RW O
    CSPROPERTY_CAMERACONTROL_IRIS,                      // RW O
    CSPROPERTY_CAMERACONTROL_FOCUS,                     // RW O
    CSPROPERTY_CAMERACONTROL_FLASH,                     // RW O
} CSPROPERTY_VIDCAP_CAMERACONTROL;

typedef struct {
    CSPROPERTY Property;
    LONG       Value;                   // value to get or set
    ULONG      Flags;                   // CSPROPERTY_CAMERACONTROL_FLAGS_*
    ULONG      Capabilities;            // CSPROPERTY_CAMERACONTROL_FLAGS_*
} CSPROPERTY_CAMERACONTROL_S, *PCSPROPERTY_CAMERACONTROL_S;

#define CSPROPERTY_CAMERACONTROL_FLAGS_AUTO        0X0001L
#define CSPROPERTY_CAMERACONTROL_FLAGS_MANUAL      0X0002L
#define CSPROPERTY_CAMERACONTROL_FLAGS_ASYNCHRONOUS_AUTO     0X0004L

#define CSPROPERTY_CAMERACONTROL_FLAGS_ABSOLUTE    0X0000L
#define CSPROPERTY_CAMERACONTROL_FLAGS_RELATIVE    0X0010L

typedef enum {
    CS_CAMCONTROL_AUTO_FOCUS_START  = 0x0001,
    CS_CAMCONTROL_AUTO_FOCUS_STOP   = 0x0002
} CS_CamControlAutoFocusOperation;


#ifndef UNDER_CE
#ifndef __EDevCtrl__
#define __EDevCtrl__
//===========================================================================

#define STATIC_PROPSETID_EXT_DEVICE\
    0xB5730A90L, 0x1A2C, 0x11cf, 0x8c, 0x23, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("B5730A90-1A2C-11cf-8C23-00AA006B6814", PROPSETID_EXT_DEVICE);
#define PROPSETID_EXT_DEVICE DEFINE_GUIDNAMED(PROPSETID_EXT_DEVICE)

typedef enum {
    CSPROPERTY_EXTDEVICE_ID,                // R
    CSPROPERTY_EXTDEVICE_VERSION,           // R
    CSPROPERTY_EXTDEVICE_POWER_STATE,       // RW
    CSPROPERTY_EXTDEVICE_PORT,              // R
    CSPROPERTY_EXTDEVICE_CAPABILITIES,      // R
} CSPROPERTY_EXTDEVICE;

typedef struct tagDEVCAPS{
    LONG CanRecord;
    LONG CanRecordStrobe;
    LONG HasAudio;
    LONG HasVideo;
    LONG UsesFiles;
    LONG CanSave;
    LONG DeviceType;
    LONG TCRead;
    LONG TCWrite;
    LONG CTLRead;
    LONG IndexRead;
    LONG Preroll;
    LONG Postroll;
    LONG SyncAcc;
    LONG NormRate;
    LONG CanPreview;
    LONG CanMonitorSrc;
    LONG CanTest;
    LONG VideoIn;
    LONG AudioIn;
    LONG Calibrate;
    LONG SeekType;
    LONG SimulatedHardware;        
} DEVCAPS, *PDEVCAPS;

typedef struct {
    CSPROPERTY Property;
    union {
        DEVCAPS  Capabilities;          // Device capabilities
        ULONG    DevPort;               // 1394, USB, etc.
        ULONG    PowerState;            // On, standby or off
        WCHAR    pawchString[MAX_PATH]; // Version
        DWORD    NodeUniqueID[2];       // Unique NodeID
    } u;
} CSPROPERTY_EXTDEVICE_S, *PCSPROPERTY_EXTDEVICE_S;

//===========================================================================

#define STATIC_PROPSETID_EXT_TRANSPORT\
    0xA03CD5F0L, 0x3045, 0x11cf, 0x8c, 0x44, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("A03CD5F0-3045-11cf-8C44-00AA006B6814", PROPSETID_EXT_TRANSPORT);
#define PROPSETID_EXT_TRANSPORT DEFINE_GUIDNAMED(PROPSETID_EXT_TRANSPORT)

typedef enum {
    CSPROPERTY_EXTXPORT_CAPABILITIES,       // (R)  Transport specific capability 
    CSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE,  // (RW) Input signal: e.g. dvsd/NTSC/PAL, dvsl/NTSC/PAL, MPEG2-TS etc
    CSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE, // (RW) Output signal: e.g. dvsd/NTSC/PAL, dvsl/NTSC/PAL, MPEG2-TS etc
    CSPROPERTY_EXTXPORT_LOAD_MEDIUM,        // (RW) Eject, open tray, close tray
    CSPROPERTY_EXTXPORT_MEDIUM_INFO,        // (R)  Cassettte type, tape grade and write protection
    CSPROPERTY_EXTXPORT_STATE,              // (RW) Current transport mode and state
    CSPROPERTY_EXTXPORT_STATE_NOTIFY,       // (RW) Notify of transport mode and state change
    CSPROPERTY_EXTXPORT_TIMECODE_SEARCH,    // (W)  Search to a specific timecode on a tape
    CSPROPERTY_EXTXPORT_ATN_SEARCH,         // (W)  Search to a specific absolute track number (ATN) on a tape
    CSPROPERTY_EXTXPORT_RTC_SEARCH,         // (W)  Search to a specific relative time counter (RTC) on a tape
    CSPROPERTY_RAW_AVC_CMD,                 // (RW) Issue a raw AVC commnad
} CSPROPERTY_EXTXPORT;

typedef struct tagTRANSPORTSTATUS{
    LONG Mode;
    LONG LastError;
    LONG RecordInhibit;
    LONG ServoLock;
    LONG MediaPresent;
    LONG MediaLength;
    LONG MediaSize;
    LONG MediaTrackCount;
    LONG MediaTrackLength;
    LONG MediaTrackSide;
    LONG MediaType;
    LONG LinkMode;
    LONG NotifyOn;
} TRANSPORTSTATUS, *PTRANSPORTSTATUS;

typedef struct tagTRANSPORTBASICPARMS{
    LONG TimeFormat;
    LONG TimeReference;
    LONG Superimpose;
    LONG EndStopAction;
    LONG RecordFormat;
    LONG StepFrames;
    LONG SetpField;
    LONG Preroll;
    LONG RecPreroll;
    LONG Postroll;
    LONG EditDelay;
    LONG PlayTCDelay;
    LONG RecTCDelay;
    LONG EditField;
    LONG FrameServo;
    LONG ColorFrameServo;
    LONG ServoRef;
    LONG WarnGenlock;
    LONG SetTracking;
    TCHAR VolumeName[40];
    LONG Ballistic[20];
    LONG Speed;
    LONG CounterFormat;
    LONG TunerChannel;
    LONG TunerNumber;
    LONG TimerEvent;
    LONG TimerStartDay;
    LONG TimerStartTime;
    LONG TimerStopDay;
    LONG TimerStopTime;
} TRANSPORTBASICPARMS, *PTRANSPORTBASICPARMS;

typedef struct tagTRANSPORTVIDEOPARMS{
    LONG OutputMode;
    LONG Input;
} TRANSPORTVIDEOPARMS, *PTRANSPORTVIDEOPARMS;

typedef struct tagTRANSPORTAUDIOPARMS{
    LONG EnableOutput;
    LONG EnableRecord;
    LONG EnableSelsync;
    LONG Input;
    LONG MonitorSource;
} TRANSPORTAUDIOPARMS, *PTRANSPORTAUDIOPARMS;

typedef struct {
    BOOL  MediaPresent;      
    ULONG MediaType;         
    BOOL  RecordInhibit;    
} MEDIUM_INFO, *PMEDIUM_INFO;

typedef struct {
    ULONG Mode;              
    ULONG State;
} TRANSPORT_STATE, *PTRANSPORT_STATE;

typedef struct {
    CSPROPERTY Property;
    union {    
        ULONG      Capabilities;
        ULONG      SignalMode;
        ULONG      LoadMedium;
        MEDIUM_INFO MediumInfo;
        TRANSPORT_STATE XPrtState;
        struct {
          BYTE frame;        
          BYTE second;
          BYTE minute;
          BYTE hour;
        } Timecode;
        DWORD dwTimecode;            
        DWORD dwAbsTrackNumber;      
        struct {
            ULONG   PayloadSize;
            BYTE    Payload[512];  
        } RawAVC;                    
    } u;
     
} CSPROPERTY_EXTXPORT_S, *PCSPROPERTY_EXTXPORT_S;

//===========================================================================

#define STATIC_PROPSETID_TIMECODE_READER\
    0x9B496CE1L, 0x811B, 0x11cf, 0x8C, 0x77, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("9B496CE1-811B-11cf-8C77-00AA006B6814", PROPSETID_TIMECODE_READER);
#define PROPSETID_TIMECODE_READER DEFINE_GUIDNAMED(PROPSETID_TIMECODE_READER)

typedef enum {
    CSPROPERTY_TIMECODE_READER,  // (R) Timecode for the current tape position
    CSPROPERTY_ATN_READER,       // (R) Absolute track number for the current tape position
    CSPROPERTY_RTC_READER,       // (R) Relative time counter for the current tape position
} CSPROPERTY_TIMECODE;

#ifndef TIMECODE_DEFINED
#define TIMECODE_DEFINED
typedef union _timecode {
    struct {
        WORD   wFrameRate;
        WORD   wFrameFract;
        DWORD  dwFrames;
        };
    DWORDLONG  qw;
} TIMECODE;
typedef TIMECODE *PTIMECODE;

typedef struct tagTIMECODE_SAMPLE {
    LONGLONG qwTick;
    TIMECODE timecode;
    DWORD dwUser;
    DWORD dwFlags;
} TIMECODE_SAMPLE;

typedef TIMECODE_SAMPLE *PTIMECODE_SAMPLE;

#endif /* TIMECODE_DEFINED */

typedef struct {
    CSPROPERTY Property;
    TIMECODE_SAMPLE TimecodeSamp;
} CSPROPERTY_TIMECODE_S, *PCSPROPERTY_TIMECODE_S;

//===========================================================================

#define STATIC_CSEVENTSETID_EXTDEV_Command\
    0x109c7988L, 0xb3cb, 0x11d2, 0xb4, 0x8e, 0x00, 0x60, 0x97, 0xb3, 0x39, 0x1b
DEFINE_GUIDSTRUCT("109c7988-b3cb-11d2-b48e-006097b3391b", CSEVENTSETID_EXTDEV_Command);
#define CSEVENTSETID_EXTDEV_Command DEFINE_GUIDNAMED(CSEVENTSETID_EXTDEV_Command)

typedef enum {
    CSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY,     // Final response is ready for notify command 
    CSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY,    // Final response is ready for control command.
    CSEVENT_EXTDEV_COMMAND_BUSRESET,                 // A bus reset has occured.
    CSEVENT_EXTDEV_TIMECODE_UPDATE,                  // Timecode has changed.
    CSEVENT_EXTDEV_OPERATION_MODE_UPDATE,            // Operting mode (VCR,Camera, etc.) has changed.
    CSEVENT_EXTDEV_TRANSPORT_STATE_UPDATE,           // Transport state has changed.
    CSEVENT_EXTDEV_NOTIFY_REMOVAL,                   // Device was surprise removal.
    CSEVENT_EXTDEV_NOTIFY_MEDIUM_CHANGE,             // Tape medium is removed or added.
} CSEVENT_DEVCMD;

#endif // __EDevCtrl__

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_CROSSBAR\
    0x6a2e0640L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0640-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_CROSSBAR);
#define PROPSETID_VIDCAP_CROSSBAR DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CROSSBAR)

typedef enum {
    CSPROPERTY_CROSSBAR_CAPS,                     // R
    CSPROPERTY_CROSSBAR_PININFO,                  // R
    CSPROPERTY_CROSSBAR_CAN_ROUTE,                // R
    CSPROPERTY_CROSSBAR_ROUTE,                    // RW
} CSPROPERTY_VIDCAP_CROSSBAR;

typedef struct {
    CSPROPERTY Property;
    ULONG  NumberOfInputs;      // the number of audio and video input pins
    ULONG  NumberOfOutputs;     // the number of audio and video output pins
} CSPROPERTY_CROSSBAR_CAPS_S, *PCSPROPERTY_CROSSBAR_CAPS_S;

typedef struct {
    CSPROPERTY Property;
    CSPIN_DATAFLOW Direction;     // CSPIN_DATAFLOW_IN or CSPIN_DATAFLOW_OUT?
    ULONG  Index;                 // Which pin to return data for?
    ULONG  PinType;               // CS_PhysConn_Video_* or CS_PhysConn_Audio_*
    ULONG  RelatedPinIndex;       // For video pins, this is the related audio pin
    CSPIN_MEDIUM  Medium;         // Identifies the hardware connection
} CSPROPERTY_CROSSBAR_PININFO_S, *PCSPROPERTY_CROSSBAR_PININFO_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  IndexInputPin;        // Zero based index of the input pin
    ULONG  IndexOutputPin;       // Zero based index of the output pin
    ULONG  CanRoute;             // returns non-zero on CAN_ROUTE if routing is possible
} CSPROPERTY_CROSSBAR_ROUTE_S, *PCSPROPERTY_CROSSBAR_ROUTE_S;

#define STATIC_EVENTSETID_CROSSBAR\
    0x6a2e0641L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0641-28e4-11d0-a18c-00a0c9118956", EVENTSETID_CROSSBAR);
#define EVENTSETID_CROSSBAR DEFINE_GUIDNAMED(EVENTSETID_CROSSBAR)

typedef enum {
    CSEVENT_CROSSBAR_CHANGED
} CSEVENT_CROSSBAR;

// The following IDs should match the AM equivalents
typedef enum {
    CS_PhysConn_Video_Tuner = 1,
    CS_PhysConn_Video_Composite,
    CS_PhysConn_Video_SVideo,
    CS_PhysConn_Video_RGB,
    CS_PhysConn_Video_YRYBY,
    CS_PhysConn_Video_SerialDigital,
    CS_PhysConn_Video_ParallelDigital,
    CS_PhysConn_Video_SCSI,
    CS_PhysConn_Video_AUX,
    CS_PhysConn_Video_1394,
    CS_PhysConn_Video_USB,
    CS_PhysConn_Video_VideoDecoder,
    CS_PhysConn_Video_VideoEncoder,
    CS_PhysConn_Video_SCART,

    CS_PhysConn_Audio_Tuner = 4096,
    CS_PhysConn_Audio_Line,
    CS_PhysConn_Audio_Mic,
    CS_PhysConn_Audio_AESDigital,
    CS_PhysConn_Audio_SPDIFDigital,
    CS_PhysConn_Audio_SCSI,
    CS_PhysConn_Audio_AUX,
    CS_PhysConn_Audio_1394,
    CS_PhysConn_Audio_USB,
    CS_PhysConn_Audio_AudioDecoder,
} CS_PhysicalConnectorType;


//===========================================================================

#define STATIC_PROPSETID_VIDCAP_TVAUDIO\
    0x6a2e0650L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0650-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_TVAUDIO);
#define PROPSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(PROPSETID_VIDCAP_TVAUDIO)

typedef enum {
    CSPROPERTY_TVAUDIO_CAPS,                            // R
    CSPROPERTY_TVAUDIO_MODE,                            // RW
    CSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES        // R
} CSPROPERTY_VIDCAP_TVAUDIO;

#define CS_TVAUDIO_MODE_MONO           0x0001          // Mono
#define CS_TVAUDIO_MODE_STEREO         0x0002          // Stereo
#define CS_TVAUDIO_MODE_LANG_A         0x0010          // Primary language
#define CS_TVAUDIO_MODE_LANG_B         0x0020          // 2nd avail language
#define CS_TVAUDIO_MODE_LANG_C         0x0040          // 3rd avail language

typedef struct {
    CSPROPERTY Property;
    ULONG      Capabilities;             // Bitmask of CS_TVAUDIO_MODE_*
    CSPIN_MEDIUM InputMedium;
    CSPIN_MEDIUM OutputMedium;
} CSPROPERTY_TVAUDIO_CAPS_S, *PCSPROPERTY_TVAUDIO_CAPS_S;

typedef struct {
    CSPROPERTY Property;
    ULONG      Mode;                     // CS_TVAUDIO_MODE_*
} CSPROPERTY_TVAUDIO_S, *PCSPROPERTY_TVAUDIO_S;


#define STATIC_CSEVENTSETID_VIDCAP_TVAUDIO\
    0x6a2e0651L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0651-28e4-11d0-a18c-00a0c9118956", CSEVENTSETID_VIDCAP_TVAUDIO);
#define CSEVENTSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(CSEVENTSETID_VIDCAP_TVAUDIO)

typedef enum {
    CSEVENT_TVAUDIO_CHANGED,
} CSEVENT_TVAUDIO;

#endif //#ifndef UNDER_CE

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_VIDEOCOMPRESSION\
    0xC6E13343L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13343-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOCOMPRESSION);
#define PROPSETID_VIDCAP_VIDEOCOMPRESSION DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCOMPRESSION)

typedef enum {
    CSPROPERTY_VIDEOCOMPRESSION_GETINFO,              // R
    CSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE,        // RW
    CSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME, // RW
    CSPROPERTY_VIDEOCOMPRESSION_QUALITY,              // RW
    CSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_KEYFRAME,    // W
    CSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_FRAME_SIZE,  // W
    CSPROPERTY_VIDEOCOMPRESSION_WINDOWSIZE,           // RW
} CSPROPERTY_VIDCAP_VIDEOCOMPRESSION;

typedef enum {
    CS_CompressionCaps_CanQuality = 1,
    CS_CompressionCaps_CanCrunch = 2,
    CS_CompressionCaps_CanKeyFrame = 4,
    CS_CompressionCaps_CanBFrame = 8,
    CS_CompressionCaps_CanWindow = 0x10,
} CS_CompressionCaps;

typedef struct {
    CSPROPERTY Property;
    // Note, no VersionString!
    // Note, no DescriptionString!
    ULONG      StreamIndex;             // zero based index of stream
    LONG       DefaultKeyFrameRate;     // Key frame rate
    LONG       DefaultPFrameRate;       // Predeicted frames per Key frame
    LONG       DefaultQuality;          // 0 to 10000
    LONG       NumberOfQualitySettings; // How many discreet quality settings?
    LONG       Capabilities;            // CS_CompressionCaps_*
} CSPROPERTY_VIDEOCOMPRESSION_GETINFO_S, *PCSPROPERTY_VIDEOCOMPRESSION_GETINFO_S;

typedef struct {
    CSPROPERTY Property;
    ULONG      StreamIndex;             // zero based index of stream
    LONG       Value;                   // value to get or set
} CSPROPERTY_VIDEOCOMPRESSION_S, *PCSPROPERTY_VIDEOCOMPRESSION_S;

//===========================================================================
// MEDIASUBTYPE_Overlay
#define STATIC_CSDATAFORMAT_SUBTYPE_OVERLAY\
    0xe436eb7fL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb7f-524f-11ce-9f53-0020af0ba770", CSDATAFORMAT_SUBTYPE_OVERLAY);
#define CSDATAFORMAT_SUBTYPE_OVERLAY DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_OVERLAY)

#define STATIC_CSPROPSETID_OverlayUpdate\
    0x490EA5CFL, 0x7681, 0x11D1, 0xA2, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("490EA5CF-7681-11D1-A21C-00A0C9223196", CSPROPSETID_OverlayUpdate);
#define CSPROPSETID_OverlayUpdate DEFINE_GUIDNAMED(CSPROPSETID_OverlayUpdate)

typedef enum {
    CSPROPERTY_OVERLAYUPDATE_INTERESTS,
    CSPROPERTY_OVERLAYUPDATE_CLIPLIST = 0x1,
    CSPROPERTY_OVERLAYUPDATE_PALETTE = 0x2,
    CSPROPERTY_OVERLAYUPDATE_COLORKEY = 0x4,
    CSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION = 0x8,
    CSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE = 0x10,
    CSPROPERTY_OVERLAYUPDATE_COLORREF = 0x10000000
} CSPROPERTY_OVERLAYUPDATE;

typedef struct {
    ULONG   PelsWidth;
    ULONG   PelsHeight;
    ULONG   BitsPerPel;
    WCHAR   DeviceID[1];
} CSDISPLAYCHANGE, *PCSDISPLAYCHANGE;

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_INTERESTS(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_INTERESTS,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_PALETTE(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_PALETTE,\
        NULL,\
        sizeof(CSPROPERTY),\
        0,\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_COLORKEY(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_COLORKEY,\
        NULL,\
        sizeof(CSPROPERTY),\
        sizeof(COLORKEY),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_CLIPLIST(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_CLIPLIST,\
        NULL,\
        sizeof(CSPROPERTY),\
        2 * sizeof(RECT) + sizeof(RGNDATAHEADER),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_VIDEOPOSITION(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION,\
        NULL,\
        sizeof(CSPROPERTY),\
        2 * sizeof(RECT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_DISPLAYCHANGE(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE,\
        NULL,\
        sizeof(CSPROPERTY),\
        sizeof(CSDISPLAYCHANGE),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_COLORREF(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_COLORREF,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(COLORREF),\
        NULL,\
        NULL, 0, NULL, NULL, 0)

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_VIDEOCONTROL\
    0x6a2e0670L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0670-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOCONTROL);
#define PROPSETID_VIDCAP_VIDEOCONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCONTROL)

typedef enum {
    CSPROPERTY_VIDEOCONTROL_CAPS,               // R
    CSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE,  // R O
    CSPROPERTY_VIDEOCONTROL_FRAME_RATES,        // R O
    CSPROPERTY_VIDEOCONTROL_MODE,               // RWO
} CSPROPERTY_VIDCAP_VIDEOCONTROL;

typedef enum {
    CS_VideoControlFlag_FlipHorizontal                  = 0x0001,
    CS_VideoControlFlag_FlipVertical                    = 0x0002,
    CS_Obsolete_VideoControlFlag_ExternalTriggerEnable  = 0x0010,   // ***WARNING *** Flag msimatch with DSHOW.
    CS_Obsolete_VideoControlFlag_Trigger                = 0x0020,   // ***WARNING *** Flag msimatch with DSHOW.
    CS_VideoControlFlag_ExternalTriggerEnable           = 0x0004,
    CS_VideoControlFlag_Trigger                         = 0x0008,
    CS_VideoControlFlag_Sample_Scanned_Notification	   	= 0x0040,
} CS_VideoControlFlags;

typedef struct {
    CSPROPERTY Property;
    ULONG      StreamIndex;
    ULONG      VideoControlCaps;                // CS_VideoControlFlags_*
} CSPROPERTY_VIDEOCONTROL_CAPS_S, *PCSPROPERTY_VIDEOCONTROL_CAPS_S;

typedef struct {
    CSPROPERTY Property;
    ULONG      StreamIndex;
    LONG       Mode;                            // CS_VideoControlFlags_*
} CSPROPERTY_VIDEOCONTROL_MODE_S, *PCSPROPERTY_VIDEOCONTROL_MODE_S;

typedef struct {
    CSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      RangeIndex;                      // Index of range
    SIZE       Dimensions;                      // Size of image
    LONGLONG   CurrentActualFrameRate;          // Only correct if pin is open
    LONGLONG   CurrentMaxAvailableFrameRate;    // Max Rate temporarily limited on USB or 1394?
} CSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S, *PCSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S;

// CSPROPERTY_VIDEOCONTROL_FRAME_RATES returns a list of available frame rates in 100 nS units
typedef struct {
    CSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      RangeIndex;                      // Index of range
    SIZE       Dimensions;                      // Size of image
} CSPROPERTY_VIDEOCONTROL_FRAME_RATES_S, *PCSPROPERTY_VIDEOCONTROL_FRAME_RATES_S;

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_DROPPEDFRAMES\
    0xC6E13344L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13344-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_DROPPEDFRAMES);
#define PROPSETID_VIDCAP_DROPPEDFRAMES DEFINE_GUIDNAMED(PROPSETID_VIDCAP_DROPPEDFRAMES)

typedef enum {
    CSPROPERTY_DROPPEDFRAMES_CURRENT            // R
} CSPROPERTY_VIDCAP_DROPPEDFRAMES;

typedef struct {
    CSPROPERTY Property;
    LONGLONG   PictureNumber;                   // Current Picture Number
    LONGLONG   DropCount;                       // Count of frames dropped
    ULONG      AverageFrameSize;                // Average size of frames captured
} CSPROPERTY_DROPPEDFRAMES_CURRENT_S, *PCSPROPERTY_DROPPEDFRAMES_CURRENT_S;

//===========================================================================
// VPE

#define STATIC_CSPROPSETID_VPConfig\
    0xbc29a660L, 0x30e3, 0x11d0, 0x9e, 0x69, 0x00, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b
DEFINE_GUIDSTRUCT("bc29a660-30e3-11d0-9e69-00c04fd7c15b", CSPROPSETID_VPConfig);
#define CSPROPSETID_VPConfig DEFINE_GUIDNAMED(CSPROPSETID_VPConfig)

#define STATIC_CSPROPSETID_VPVBIConfig\
    0xec529b00L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("ec529b00-1a1f-11d1-bad9-00609744111a", CSPROPSETID_VPVBIConfig);
#define CSPROPSETID_VPVBIConfig DEFINE_GUIDNAMED(CSPROPSETID_VPVBIConfig)

// Both of the above property sets use the same list of properties below

typedef enum {
    CSPROPERTY_VPCONFIG_NUMCONNECTINFO,
    CSPROPERTY_VPCONFIG_GETCONNECTINFO,
    CSPROPERTY_VPCONFIG_SETCONNECTINFO,
    CSPROPERTY_VPCONFIG_VPDATAINFO,
    CSPROPERTY_VPCONFIG_MAXPIXELRATE,
    CSPROPERTY_VPCONFIG_INFORMVPINPUT,
    CSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
    CSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
    CSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
    CSPROPERTY_VPCONFIG_INVERTPOLARITY,
    CSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,   // E_NOTIMPL for VBI
    CSPROPERTY_VPCONFIG_SCALEFACTOR,            // E_NOTIMPL for VBI
    CSPROPERTY_VPCONFIG_DDRAWHANDLE,
    CSPROPERTY_VPCONFIG_VIDEOPORTID,
    CSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
    CSPROPERTY_VPCONFIG_SURFACEPARAMS
} CSPROPERTY_VPCONFIG;

//=========================
// IBasicAudio
//
#define STATIC_CLSID_CsIBasicAudioInterfaceHandler\
    0xb9f8ac3e, 0x0f71, 0x11d2, 0xb7, 0x2c, 0x00, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d
DEFINE_GUIDSTRUCT("b9f8ac3e-0f71-11d2-b72c-00c04fb6bd3d", CLSID_CsIBasicAudioInterfaceHandler);
#define CLSID_CsIBasicAudioInterfaceHandler DEFINE_GUIDNAMED(CLSID_CsIBasicAudioInterfaceHandler)


#if defined(__IVPType__)

typedef struct {
    AMVPSIZE    Size;
    DWORD       MaxPixelsPerSecond;
    DWORD       Reserved;
} CSVPMAXPIXELRATE, *PCSVPMAXPIXELRATE;

typedef struct {
    CSPROPERTY      Property;
    AMVPSIZE        Size;
} CSVPSIZE_PROP, *PCSVPSIZE_PROP;

typedef struct {
    DWORD   dwPitch;
    DWORD   dwXOrigin;
    DWORD   dwYOrigin;
} CSVPSURFACEPARAMS, *PCSVPSURFACEPARAMS;

#else  // !defined(__IVPType__)

#if !defined(__DDRAW_INCLUDED__)

//==========================================================================
// The following definitions must be in sync with DDraw.h in DirectX SDK
//==========================================================================

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l


typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    union
    {
    DWORD   dwRGBBitCount;          // how many bits per pixel (BD_1,2,4,8,16,24,32)
    DWORD   dwYUVBitCount;          // how many bits per pixel (BD_4,8,16,24,32)
    DWORD   dwZBufferBitDepth;      // how many bits for z buffers (BD_8,16,24,32)
    DWORD   dwAlphaBitDepth;        // how many bits for alpha channels (BD_1,2,4,8)
    };
    union
    {
    DWORD   dwRBitMask;             // mask for red bit
    DWORD   dwYBitMask;             // mask for Y bits
    };
    union
    {
    DWORD   dwGBitMask;             // mask for green bits
    DWORD   dwUBitMask;             // mask for U bits
    };
    union
    {
    DWORD   dwBBitMask;             // mask for blue bits
    DWORD   dwVBitMask;             // mask for V bits
    };
    union
    {
    DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
    DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
    DWORD   dwRGBZBitMask;          // mask for Z channel
    DWORD   dwYUVZBitMask;          // mask for Z channel
    };
} DDPIXELFORMAT, * LPDDPIXELFORMAT;

#endif // !defined(__DDRAW_INCLUDED__)

//==========================================================================
// End of DDraw.h header info
//==========================================================================

//==========================================================================
// The following definitions must be in sync with DVP.h in DirectX SDK
//==========================================================================

#if !defined(__DVP_INCLUDED__)

typedef struct _DDVIDEOPORTCONNECT {
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags
    DWORD dwReserved1;      // Reserved, set to zero.
} DDVIDEOPORTCONNECT, * LPDDVIDEOPORTCONNECT;

#define DDVPTYPE_E_HREFH_VREFH  \
    0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#define DDVPTYPE_E_HREFL_VREFL  \
    0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#endif // !defined(__DVP_INCLUDED__)

//==========================================================================
// End of DVP.h header info
//==========================================================================


//==========================================================================
// The following definitions must be in sync with VPType.h in AM 2.0 SDK
//==========================================================================

// pixel aspect ratios corresponding to a 720x480 NTSC image or a 720x576 image
typedef enum // AMPixAspectRatio
{
    CS_PixAspectRatio_NTSC4x3,
    CS_PixAspectRatio_NTSC16x9,
    CS_PixAspectRatio_PAL4x3,
    CS_PixAspectRatio_PAL16x9,
} CS_AMPixAspectRatio ;

typedef enum // AMVP_SELECTFORMATBY
{
    CS_AMVP_DO_NOT_CARE,
    CS_AMVP_BEST_BANDWIDTH,
    CS_AMVP_INPUT_SAME_AS_OUTPUT
} CS_AMVP_SELECTFORMATBY;

typedef enum // AMVP_MODE
{
    CS_AMVP_MODE_WEAVE,
    CS_AMVP_MODE_BOBINTERLEAVED,
    CS_AMVP_MODE_BOBNONINTERLEAVED,
    CS_AMVP_MODE_SKIPEVEN,
    CS_AMVP_MODE_SKIPODD
} CS_AMVP_MODE ;

typedef struct tagCS_AMVPDIMINFO      // AMVPDIMINFO
{
    DWORD dwFieldWidth ;            // [out] field width
    DWORD dwFieldHeight ;           // [out] field height
    DWORD dwVBIWidth ;              // [out] VBI data width
    DWORD dwVBIHeight ;             // [out] VBI data height
    RECT  rcValidRegion ;           // [out] valid rect for data cropping
} CS_AMVPDIMINFO, *PCS_AMVPDIMINFO ;

typedef struct tagCS_AMVPDATAINFO   // AMVPDATAINFO
{
    DWORD           dwSize;                 // Size of the struct
    DWORD           dwMicrosecondsPerField; // Time taken by each field
    CS_AMVPDIMINFO  amvpDimInfo;            // Dimensional Information
    DWORD           dwPictAspectRatioX;     // Pict aspect ratio in X dimn
    DWORD           dwPictAspectRatioY;     // Pict aspect ratio in Y dimn
    BOOL            bEnableDoubleClock;     // Videoport should enable double clocking
    BOOL            bEnableVACT;            // Videoport should use an external VACT signal
    BOOL            bDataIsInterlaced;      // Indicates that the signal is interlaced
    LONG            lHalfLinesOdd;          // number of halflines in the odd field
    BOOL            bFieldPolarityInverted; // Device inverts the polarity by default
    DWORD           dwNumLinesInVREF;       // Number of lines of data in VREF
    LONG            lHalfLinesEven;         // number of halflines in the even field
    DWORD           dwReserved1;            // Reserved for future use
} CS_AMVPDATAINFO, *PCS_AMVPDATAINFO;

typedef struct tagCS_AMVPSIZE   // AMVPSIZE
{
    DWORD dwWidth ;                  // [in] width in pixels
    DWORD dwHeight ;                 // [in] height in pixels
} CS_AMVPSIZE, *PCS_AMVPSIZE ;

//==========================================================================
// End of VPType.h header info
//==========================================================================

typedef struct {
    CS_AMVPSIZE     Size;
    DWORD           MaxPixelsPerSecond;
    DWORD           Reserved;
} CSVPMAXPIXELRATE, *PCSVPMAXPIXELRATE;

typedef struct {
    CSPROPERTY      Property;
    CS_AMVPSIZE     Size;
} CSVPSIZE_PROP, *PCSVPSIZE_PROP;

typedef struct {
    DWORD   dwPitch;
    DWORD   dwXOrigin;
    DWORD   dwYOrigin;
} CSVPSURFACEPARAMS, *PCSVPSURFACEPARAMS;

#endif // !defined(__IVPType__)

//
//  IVPNotify event notification
//
#define STATIC_CSEVENTSETID_VPNotify\
    0x20c5598eL, 0xd3c8, 0x11d0, 0x8d, 0xfc, 0x00, 0xc0, 0x4f, 0xd7, 0xc0, 0x8b
DEFINE_GUIDSTRUCT("20c5598e-d3c8-11d0-8dfc-00c04fd7c08b", CSEVENTSETID_VPNotify);
#define CSEVENTSETID_VPNotify DEFINE_GUIDNAMED(CSEVENTSETID_VPNotify)

typedef enum {
    CSEVENT_VPNOTIFY_FORMATCHANGE,
} CSEVENT_VPNOTIFY;

//
//  VIDCAPTOSTI event notification
//
#define STATIC_CSEVENTSETID_VIDCAPTOSTI\
    0xdb47de20, 0xf628, 0x11d1, 0xba, 0x41, 0x0, 0xa0, 0xc9, 0xd, 0x2b, 0x5
DEFINE_GUIDSTRUCT("DB47DE20-F628-11d1-BA41-00A0C90D2B05", CSEVENTSETID_VIDCAPTOSTI);
#define CSEVENTSETID_VIDCAPNotify DEFINE_GUIDNAMED(CSEVENTSETID_VIDCAPTOSTI)

typedef enum {
    CSEVENT_VIDCAPTOSTI_EXT_TRIGGER,
} CSEVENT_VIDCAPTOSTI;


//
//  IVPVBINotify event notification
//
#define STATIC_CSEVENTSETID_VPVBINotify\
    0xec529b01L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("ec529b01-1a1f-11d1-bad9-00609744111a", CSEVENTSETID_VPVBINotify);
#define CSEVENTSETID_VPVBINotify DEFINE_GUIDNAMED(CSEVENTSETID_VPVBINotify)

typedef enum {
    CSEVENT_VPVBINOTIFY_FORMATCHANGE,
} CSEVENT_VPVBINOTIFY;


//
// closed caption information
//

#define STATIC_CSDATAFORMAT_TYPE_AUXLine21Data \
0x670aea80L, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("670aea80-3a82-11d0-b79b-00aa003767a7", CSDATAFORMAT_TYPE_AUXLine21Data);
#define CSDATAFORMAT_TYPE_AUXLine21Data DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_AUXLine21Data)

#define STATIC_CSDATAFORMAT_SUBTYPE_Line21_BytePair \
0x6e8d4a22L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("6e8d4a22-310c-11d0-b79a-00aa003767a7", CSDATAFORMAT_SUBTYPE_Line21_BytePair);
#define CSDATAFORMAT_SUBTYPE_Line21_BytePair DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_Line21_BytePair)

#define STATIC_CSDATAFORMAT_SUBTYPE_Line21_GOPPacket \
0x6e8d4a23L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("6e8d4a23-310c-11d0-b79a-00aa003767a7", CSDATAFORMAT_SUBTYPE_Line21_GOPPacket);
#define CSDATAFORMAT_SUBTYPE_Line21_GOPPacket DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_Line21_GOPPacket)

typedef struct _CSGOP_USERDATA {
    ULONG sc;
    ULONG reserved1;
    BYTE cFields;
    CHAR l21Data[3];
} CSGOP_USERDATA, *PCSGOP_USERDATA;

//
// DVD encrypted PACK format type definition
//

#define STATIC_CSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK\
    0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x4f, 0xc3, 0x1d, 0x60
DEFINE_GUIDSTRUCT("ed0b916a-044d-11d1-aa78-00c04fc31d60", CSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK);
#define CSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK)

#define CS_AM_UseNewCSSKey    0x1


// -----------------------------------------------------------------------
// CS_AM_CSPROPSETID_TSRateChange property set definitions for time stamp
// rate changes.
// -----------------------------------------------------------------------


#define STATIC_CSPROPSETID_TSRateChange\
    0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0

DEFINE_GUIDSTRUCT("A503C5C0-1D1D-11D1-AD80-444553540000", CSPROPSETID_TSRateChange);
#define CSPROPSETID_TSRateChange DEFINE_GUIDNAMED(CSPROPSETID_TSRateChange)
typedef enum {
    CS_AM_RATE_SimpleRateChange=1,  // rw, use CS_AM_SimpleRateChange
    CS_AM_RATE_ExactRateChange=2,   // rw, use CS_AM_ExactRateChange
    CS_AM_RATE_MaxFullDataRate=3,   // r, use CS_AM_MaxFullDataRate
    CS_AM_RATE_Step=4               // w, use CS_AM_Step
} CS_AM_PROPERTY_TS_RATE_CHANGE;

typedef struct {
    // this is the simplest mechanism to set a time stamp rate change on
    // a filter (simplest for the person setting the rate change, harder
    // for the filter doing the rate change).
    REFERENCE_TIME  StartTime;  //stream time at which to start this rate
    LONG        Rate;       //new rate * 10000 (decimal)
} CS_AM_SimpleRateChange, *PCS_AM_SimpleRateChange;

typedef struct {
    REFERENCE_TIME  OutputZeroTime; //input TS that maps to zero output TS
    LONG        Rate;       //new rate * 10000 (decimal)
} CS_AM_ExactRateChange, *PCS_AM_ExactRateChange;

typedef LONG CS_AM_MaxFullDataRate; //rate * 10000 (decimal)

typedef DWORD CS_AM_Step; // number of frame to step

//===========================================================================
//ENCODER API DEFINITIONS
//===========================================================================

#define STATIC_CSCATEGORY_ENCODER \
    0x19689bf6, 0xc384, 0x48fd, 0xad, 0x51, 0x90, 0xe5, 0x8c, 0x79, 0xf7, 0xb
DEFINE_GUIDSTRUCT("19689BF6-C384-48fd-AD51-90E58C79F70B", CSCATEGORY_ENCODER);
#define CSCATEGORY_ENCODER DEFINE_GUIDNAMED(CSCATEGORY_ENCODER)

#define STATIC_CSCATEGORY_MULTIPLEXER \
    0x7a5de1d3, 0x1a1, 0x452c, 0xb4, 0x81, 0x4f, 0xa2, 0xb9, 0x62, 0x71, 0xe8
DEFINE_GUIDSTRUCT("7A5DE1D3-01A1-452c-B481-4FA2B96271E8", CSCATEGORY_MULTIPLEXER);
#define CSCATEGORY_MULTIPLEXER DEFINE_GUIDNAMED(CSCATEGORY_MULTIPLEXER)

#ifndef __ENCODER_API_GUIDS__
#define __ENCODER_API_GUIDS__

#define STATIC_ENCAPIPARAM_BITRATE \
    0x49cc4c43, 0xca83, 0x4ad4, 0xa9, 0xaf, 0xf3, 0x69, 0x6a, 0xf6, 0x66, 0xdf
DEFINE_GUIDSTRUCT("49CC4C43-CA83-4ad4-A9AF-F3696AF666DF", ENCAPIPARAM_BITRATE);
#define ENCAPIPARAM_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE)

#define STATIC_ENCAPIPARAM_PEAK_BITRATE \
    0x703f16a9, 0x3d48, 0x44a1, 0xb0, 0x77, 0x1, 0x8d, 0xff, 0x91, 0x5d, 0x19
DEFINE_GUIDSTRUCT("703F16A9-3D48-44a1-B077-018DFF915D19", ENCAPIPARAM_PEAK_BITRATE);
#define ENCAPIPARAM_PEAK_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_PEAK_BITRATE)

#define STATIC_ENCAPIPARAM_BITRATE_MODE \
    0xee5fb25c, 0xc713, 0x40d1, 0x9d, 0x58, 0xc0, 0xd7, 0x24, 0x1e, 0x25, 0xf
DEFINE_GUIDSTRUCT("EE5FB25C-C713-40d1-9D58-C0D7241E250F", ENCAPIPARAM_BITRATE_MODE);
#define ENCAPIPARAM_BITRATE_MODE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE_MODE)

#define STATIC_CODECAPI_CHANGELISTS \
    0x62b12acf, 0xf6b0, 0x47d9, 0x94, 0x56, 0x96, 0xf2, 0x2c, 0x4e, 0x0b, 0x9d
DEFINE_GUIDSTRUCT("62B12ACF-F6B0-47D9-9456-96F22C4E0B9D", CODECAPI_CHANGELISTS );
#define CODECAPI_CHANGELISTS DEFINE_GUIDNAMED(CODECAPI_CHANGELISTS )

#define STATIC_CODECAPI_VIDEO_ENCODER \
    0x7112e8e1, 0x3d03, 0x47ef, 0x8e, 0x60, 0x03, 0xf1, 0xcf, 0x53, 0x73, 0x01
DEFINE_GUIDSTRUCT("7112E8E1-3D03-47EF-8E60-03F1CF537301", CODECAPI_VIDEO_ENCODER );
#define CODECAPI_VIDEO_ENCODER DEFINE_GUIDNAMED(CODECAPI_VIDEO_ENCODER )

#define STATIC_CODECAPI_AUDIO_ENCODER \
    0xb9d19a3e, 0xf897, 0x429c, 0xbc, 0x46, 0x81, 0x38, 0xb7, 0x27, 0x2b, 0x2d
DEFINE_GUIDSTRUCT("B9D19A3E-F897-429C-BC46-8138B7272B2D", CODECAPI_AUDIO_ENCODER );
#define CODECAPI_AUDIO_ENCODER DEFINE_GUIDNAMED(CODECAPI_AUDIO_ENCODER )

#define STATIC_CODECAPI_SETALLDEFAULTS \
    0x6c5e6a7c, 0xacf8, 0x4f55, 0xa9, 0x99, 0x1a, 0x62, 0x81, 0x09, 0x05, 0x1b
DEFINE_GUIDSTRUCT("6C5E6A7C-ACF8-4F55-A999-1A628109051B", CODECAPI_SETALLDEFAULTS );
#define CODECAPI_SETALLDEFAULTS DEFINE_GUIDNAMED(CODECAPI_SETALLDEFAULTS )

#define STATIC_CODECAPI_ALLSETTINGS \
    0x6a577e92, 0x83e1, 0x4113, 0xad, 0xc2, 0x4f, 0xce, 0xc3, 0x2f, 0x83, 0xa1
DEFINE_GUIDSTRUCT("6A577E92-83E1-4113-ADC2-4FCEC32F83A1", CODECAPI_ALLSETTINGS );
#define CODECAPI_ALLSETTINGS DEFINE_GUIDNAMED(CODECAPI_ALLSETTINGS )

#define STATIC_CODECAPI_SUPPORTSEVENTS \
    0x0581af97, 0x7693, 0x4dbd, 0x9d, 0xca, 0x3f, 0x9e, 0xbd, 0x65, 0x85, 0xa1 
DEFINE_GUIDSTRUCT("0581AF97-7693-4DBD-9DCA-3F9EBD6585A1", CODECAPI_SUPPORTSEVENTS );
#define CODECAPI_SUPPORTSEVENTS DEFINE_GUIDNAMED(CODECAPI_SUPPORTSEVENTS )

#define STATIC_CODECAPI_CURRENTCHANGELIST \
    0x1cb14e83, 0x7d72, 0x4657, 0x83, 0xfd, 0x47, 0xa2, 0xc5, 0xb9, 0xd1, 0x3d 
DEFINE_GUIDSTRUCT("1CB14E83-7D72-4657-83FD-47A2C5B9D13D", CODECAPI_CURRENTCHANGELIST );
#define CODECAPI_CURRENTCHANGELIST DEFINE_GUIDNAMED(CODECAPI_CURRENTCHANGELIST )

#endif // __ENCODER_API_GUIDS__

#ifndef __ENCODER_API_DEFINES__
#define __ENCODER_API_DEFINES__

typedef enum {

    //
    // Bit rate used for encoding is constant
    //
    ConstantBitRate = 0,

    //
    // Bit rate used for encoding is variable with the specified bitrate used
    // as a guaranteed average over a specified window.  The default window 
    // size is considered to be 5 minutes.
    //
    VariableBitRateAverage,

    //
    // Bit rate used for encoding is variable with the specified bitrate used
    // as an average with a peak not to exceed the specified peak bitrate over 
    // a specified window.  The default window size is considered to be 500ms 
    // (classically one GOP).
    //
    VariableBitRatePeak

} VIDEOENCODER_BITRATE_MODE;

#endif // __ENCODER_API_DEFINES__

#endif // !defined(_CSMEDIA_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\cutlist.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// CutList related definitions and interfaces for ActiveMovie

#ifndef __CUTLIST__
#define __CUTLIST__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define CL_DEFAULT_TIME			(-1L)

enum CL_ELEM_STATUS {
	CL_NOT_PLAYED = 0,
	CL_PLAYING = 1,
	CL_FINISHED = 2,
	CL_STATE_INVALID = 3,
	CL_STATE_MASK = CL_STATE_INVALID,
	CL_WAIT_FOR_STATE = 0xF0000000
};

enum CL_ELEM_FLAGS{
	CL_ELEM_FIRST = 1,
	CL_ELEM_LAST = 2,
	CL_ELEM_NULL = 4,
	CL_ELEM_ALL  = 0xFFFFFFFF,
	CL_ELEM_NONE = 0x0L
};


#ifndef __IAMCutListElement_INTERFACE_DEFINED__
#define __IAMCutListElement_INTERFACE_DEFINED__
#define __IAMFileCutListElement_INTERFACE_DEFINED__
#define __IAMVideoCutListElement_INTERFACE_DEFINED__
#define __IAMAudioCutListElement_INTERFACE_DEFINED__

interface IAMCutListElement : public IUnknown
{
public:
        virtual HRESULT __stdcall GetElementStartPosition( 
            /* [out] */ REFERENCE_TIME *pmtStart) = 0;
        
        virtual HRESULT __stdcall GetElementDuration( 
            /* [out] */ REFERENCE_TIME *pmtDuration) = 0;
        
        virtual HRESULT __stdcall IsFirstElement( void ) = 0;
        
        virtual HRESULT __stdcall IsLastElement( void ) = 0; 
        
        virtual HRESULT __stdcall IsNull( void ) = 0;
        
        virtual HRESULT __stdcall ElementStatus( 
            DWORD *pdwStatus,
            DWORD dwTimeoutMs) = 0;
        
};


interface IAMFileCutListElement : public IUnknown
{
public:
        virtual HRESULT __stdcall GetFileName( 
            /* [out] */ LPWSTR *ppwstrFileName) = 0;
        
        virtual HRESULT __stdcall GetTrimInPosition( 
            /* [out] */ REFERENCE_TIME *pmtTrimIn) = 0;
        
        virtual HRESULT __stdcall GetTrimOutPosition( 
            /* [out] */ REFERENCE_TIME *pmtTrimOut) = 0;
        
        virtual HRESULT __stdcall GetOriginPosition( 
            /* [out] */ REFERENCE_TIME *pmtOrigin) = 0;
        
        virtual HRESULT __stdcall GetTrimLength( 
            /* [out] */ REFERENCE_TIME *pmtLength) = 0;
        
        virtual HRESULT __stdcall GetElementSplitOffset( 
            /* [out] */ REFERENCE_TIME *pmtOffset) = 0;
        
};


interface IAMVideoCutListElement : public IUnknown
{
public:
        virtual HRESULT __stdcall IsSingleFrame( void) = 0;
        
        virtual HRESULT __stdcall GetStreamIndex( 
            /* [out] */ DWORD *piStream) = 0;
        
};
    

interface IAMAudioCutListElement : public IUnknown
{
public:
        virtual HRESULT __stdcall GetStreamIndex( 
            /* [out] */ DWORD *piStream) = 0;
        
        virtual HRESULT __stdcall HasFadeIn( void) = 0;
        
        virtual HRESULT __stdcall HasFadeOut( void) = 0;
        
};

#endif		// #ifndef IAMCutListElement


interface IStandardCutList : public IUnknown
{
	public:
		virtual HRESULT __stdcall AddElement(
			/* [in] */		IAMCutListElement	*pElement,
			/* [in] */		REFERENCE_TIME	mtStart,
			/* [in] */		REFERENCE_TIME	mtDuration)=0;

		virtual HRESULT __stdcall RemoveElement(
			/* [in] */		IAMCutListElement	*pElement) = 0;

		virtual HRESULT __stdcall GetFirstElement(
			/* [out] */		IAMCutListElement	**ppElement)=0;
		virtual HRESULT __stdcall GetLastElement(
			/* [out] */		IAMCutListElement	**ppElement)=0;
		virtual HRESULT __stdcall GetNextElement(
			/* [out] */		IAMCutListElement	**ppElement)=0;
		virtual HRESULT __stdcall GetPreviousElement(
			/* [out] */		IAMCutListElement	**ppElement)=0;
		
		virtual HRESULT __stdcall GetMediaType(
			/* [out] */		AM_MEDIA_TYPE *pmt)=0;
		virtual HRESULT __stdcall SetMediaType(
			/* [in] */		AM_MEDIA_TYPE *pmt)=0;
};


interface IFileClip : public IUnknown
{
	public:
		virtual HRESULT __stdcall SetFileAndStream(
			/* [in] */		LPWSTR	wstrFileName,
			/* [in] */		DWORD	streamNum) = 0;
		
		virtual HRESULT __stdcall CreateCut(
			/* [out] */		IAMCutListElement	**ppElement,
			/* [in] */		REFERENCE_TIME	mtTrimIn,
			/* [in] */		REFERENCE_TIME	mtTrimOut,
			/* [in] */		REFERENCE_TIME	mtOrigin,
			/* [in] */		REFERENCE_TIME	mtLength,
			/* [in] */		REFERENCE_TIME	mtOffset) = 0;

		virtual HRESULT __stdcall GetMediaType(
			/* [out] */		AM_MEDIA_TYPE	*pmt) = 0;
};

interface ICutListGraphBuilder : public IUnknown
{
public:
		virtual HRESULT __stdcall SetFilterGraph(
			/*[in]*/	IGraphBuilder	*pFilterGraph)=0;

		virtual HRESULT __stdcall GetFilterGraph(
			/*[out]*/	IGraphBuilder	**ppFilterGraph)=0;
		
		virtual HRESULT __stdcall AddCutList(
			/*[in]*/	IStandardCutList 	*pCutList,
			/*[out]*/	IPin			**ppPin)=0;
		
		virtual HRESULT __stdcall RemoveCutList(
			/*[in]*/	IStandardCutList 	*pCutList)=0;
		
		virtual HRESULT __stdcall SetOutputFileName(
			/*[in]*/	const GUID	*pType,
			/*[in]*/	LPCOLESTR	lpwstrFile,
			/*[in]*/	IBaseFilter	**ppf,
			/*[in]*/	IFileSinkFilter	**pSink) = 0;
		
		virtual HRESULT __stdcall Render(void) = 0;

		virtual HRESULT __stdcall GetElementFlags(
			/*[in]*/	IAMCutListElement *pElement,
			/*[out]*/	LPDWORD lpdwFlags) = 0;
		
};


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __CUTLIST__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ctlutil.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Base classes implementing IDispatch parsing for the basic control dual
// interfaces. Derive from these and implement just the custom method and
// property methods. We also implement CPosPassThru that can be used by
// renderers and transforms to pass by IMediaPosition and IMediaSeeking

#ifndef __CTLUTIL__
#define __CTLUTIL__

// OLE Automation has different ideas of TRUE and FALSE

#define OATRUE (-1)
#define OAFALSE (0)


// It's possible that we could replace this class with CreateStdDispatch

class CBaseDispatch
{
    ITypeInfo * m_pti;

public:

    CBaseDispatch() : m_pti(NULL) {}
    ~CBaseDispatch();

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      REFIID riid,
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);
};


class AM_NOVTABLE CMediaControl :
    public IMediaControl,
    public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CMediaControl(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);
};


class AM_NOVTABLE CMediaEvent :
    public IMediaEventEx,
    public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CMediaEvent(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);
};


class AM_NOVTABLE CMediaPosition :
    public IMediaPosition,
    public CUnknown
{
    CBaseDispatch m_basedisp;


public:

    CMediaPosition(const TCHAR *, LPUNKNOWN);
    CMediaPosition(const TCHAR *, LPUNKNOWN, HRESULT *phr);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);

};


// OA-compatibility means that we must use double as the RefTime value,
// and REFERENCE_TIME (essentially a LONGLONG) within filters.
// this class converts between the two

class COARefTime : public CRefTime {
public:

    COARefTime() {
    };

    COARefTime(CRefTime t)
        : CRefTime(t)
    {
    };

    COARefTime(REFERENCE_TIME t)
        : CRefTime(t)
    {
    };

    COARefTime(double d) {
        m_time = (LONGLONG) (d * 10000000);
    };

    operator double() {
        return double(m_time) / 10000000;
    };

    operator REFERENCE_TIME() {
        return m_time;
    };

    COARefTime& operator=(const double& rd)  {
        m_time = (LONGLONG) (rd * 10000000);
        return *this;
    }

    COARefTime& operator=(const REFERENCE_TIME& rt)  {
        m_time = rt;
        return *this;
    }

    inline BOOL operator==(const COARefTime& rt)
    {
        return m_time == rt.m_time;
    };

    inline BOOL operator!=(const COARefTime& rt)
    {
        return m_time != rt.m_time;
    };

    inline BOOL operator < (const COARefTime& rt)
    {
        return m_time < rt.m_time;
    };

    inline BOOL operator > (const COARefTime& rt)
    {
        return m_time > rt.m_time;
    };

    inline BOOL operator >= (const COARefTime& rt)
    {
        return m_time >= rt.m_time;
    };

    inline BOOL operator <= (const COARefTime& rt)
    {
        return m_time <= rt.m_time;
    };

    inline COARefTime operator+(const COARefTime& rt)
    {
        return COARefTime(m_time + rt.m_time);
    };

    inline COARefTime operator-(const COARefTime& rt)
    {
        return COARefTime(m_time - rt.m_time);
    };

    inline COARefTime operator*(LONG l)
    {
        return COARefTime(m_time * l);
    };

    inline COARefTime operator/(LONG l)
    {
        return COARefTime(m_time / l);
    };

private:
    //  Prevent bugs from constructing from LONG (which gets
    //  converted to double and then multiplied by 10000000
    COARefTime(LONG);
    int operator=(LONG);
};


// A utility class that handles IMediaPosition and IMediaSeeking on behalf
// of single-input pin renderers, or transform filters.
//
// Renderers will expose this from the filter; transform filters will
// expose it from the output pin and not the renderer.
//
// Create one of these, giving it your IPin* for your input pin, and delegate
// all IMediaPosition methods to it. It will query the input pin for
// IMediaPosition and respond appropriately.
//
// Call ForceRefresh if the pin connection changes.
//
// This class no longer caches the upstream IMediaPosition or IMediaSeeking
// it acquires it on each method call. This means ForceRefresh is not needed.
// The method is kept for source compatibility and to minimise the changes
// if we need to put it back later for performance reasons.

class CPosPassThru : public IMediaSeeking, public CMediaPosition
{
    IPin *m_pPin;

    HRESULT GetPeer(IMediaPosition **ppMP);
    HRESULT GetPeerSeeking(IMediaSeeking **ppMS);

public:

    CPosPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *);
    DECLARE_IUNKNOWN

    HRESULT ForceRefresh() {
        return S_OK;
    };

    // override to return an accurate current position
    virtual HRESULT GetMediaTime(LONGLONG *pStartTime,LONGLONG *pEndTime) {
        return E_FAIL;
    }

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // IMediaSeeking methods
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsFormatSupported( const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);
    STDMETHODIMP ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
                                   LONGLONG    Source, const GUID * pSourceFormat );
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetCurrentPosition( LONGLONG * pCurrent );
    STDMETHODIMP GetStopPosition( LONGLONG * pStop );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetDuration( LONGLONG *pDuration);
    STDMETHODIMP GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest );
    STDMETHODIMP GetPreroll( LONGLONG *pllPreroll );

    // IMediaPosition properties
    STDMETHODIMP get_Duration(REFTIME * plength);
    STDMETHODIMP put_CurrentPosition(REFTIME llTime);
    STDMETHODIMP get_StopTime(REFTIME * pllTime);
    STDMETHODIMP put_StopTime(REFTIME llTime);
    STDMETHODIMP get_PrerollTime(REFTIME * pllTime);
    STDMETHODIMP put_PrerollTime(REFTIME llTime);
    STDMETHODIMP get_Rate(double * pdRate);
    STDMETHODIMP put_Rate(double dRate);
    STDMETHODIMP get_CurrentPosition(REFTIME * pllTime);
    STDMETHODIMP CanSeekForward(LONG *pCanSeekForward);
    STDMETHODIMP CanSeekBackward(LONG *pCanSeekBackward);

private:
    HRESULT GetSeekingLongLong( HRESULT (__stdcall IMediaSeeking::*pMethod)( LONGLONG * ),
                                LONGLONG * pll );
};


// Adds the ability to return a current position

class CRendererPosPassThru : public CPosPassThru
{
    CCritSec m_PositionLock;    // Locks access to our position
    LONGLONG m_StartMedia;      // Start media time last seen
    LONGLONG m_EndMedia;        // And likewise the end media
    BOOL m_bReset;              // Have media times been set

public:

    // Used to help with passing media times through graph

    CRendererPosPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *);
    HRESULT RegisterMediaTime(IMediaSample *pMediaSample);
    HRESULT RegisterMediaTime(LONGLONG StartTime,LONGLONG EndTime);
    HRESULT GetMediaTime(LONGLONG *pStartTime,LONGLONG *pEndTime);
    HRESULT ResetMediaTime();
    HRESULT EOS();
};

STDAPI CreatePosPassThru(
    LPUNKNOWN pAgg,
    BOOL bRenderer,
    IPin *pPin,
    IUnknown **ppPassThru
);

// A class that handles the IDispatch part of IBasicAudio and leaves the
// properties and methods themselves pure virtual.

class AM_NOVTABLE CBasicAudio : public IBasicAudio, public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CBasicAudio(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);
};


// A class that handles the IDispatch part of IBasicVideo and leaves the
// properties and methods themselves pure virtual.

class AM_NOVTABLE CBaseBasicVideo : public IBasicVideo2, public IAMVideoTransform, public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CBaseBasicVideo(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);

    STDMETHODIMP GetPreferredAspectRatio(
      long *plAspectX,
      long *plAspectY)
    {
        return E_NOTIMPL;
    }

    // IAMVideoTransform
    STDMETHODIMP GetDestinationRotation(
      AM_ROTATION_ANGLE *pRotation)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP SetDestinationRotation(
      AM_ROTATION_ANGLE rotation)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP SetScalingMode(
      AM_TRANSFORM_SCALING_MODE scalingMode)
    {
        return E_NOTIMPL;
    }
    STDMETHODIMP GetScalingMode(
      AM_TRANSFORM_SCALING_MODE *pScalingMode)
    {
        return E_NOTIMPL;
    }
    STDMETHODIMP GetRotationCaps(
      DWORD *pdwRotationCapsMask)
    {
        return E_NOTIMPL;
    }
    STDMETHODIMP GetScalingCaps(
      BOOL bDirectDraw, DWORD *pdwScalingCapsMask, AMScalingRatio **ppRatios, ULONG *pCount)
    {
        return E_NOTIMPL;
    }
    STDMETHODIMP GetScalingModeCaps(
      DWORD *pdwScalingModeCaps)
    {
        return E_NOTIMPL;
    }
};


// A class that handles the IDispatch part of IVideoWindow and leaves the
// properties and methods themselves pure virtual.

class AM_NOVTABLE CBaseVideoWindow : public IVideoWindow, public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CBaseVideoWindow(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);
};


// abstract class to help source filters with their implementation
// of IMediaPosition. Derive from this and set the duration (and stop
// position). Also override NotifyChange to do something when the properties
// change.

class AM_NOVTABLE CSourcePosition : public CMediaPosition
{

public:
    CSourcePosition(const TCHAR *, LPUNKNOWN, HRESULT*, CCritSec *);

    // IMediaPosition methods
    STDMETHODIMP get_Duration(REFTIME * plength);
    STDMETHODIMP put_CurrentPosition(REFTIME llTime);
    STDMETHODIMP get_StopTime(REFTIME * pllTime);
    STDMETHODIMP put_StopTime(REFTIME llTime);
    STDMETHODIMP get_PrerollTime(REFTIME * pllTime);
    STDMETHODIMP put_PrerollTime(REFTIME llTime);
    STDMETHODIMP get_Rate(double * pdRate);
    STDMETHODIMP put_Rate(double dRate);
    STDMETHODIMP CanSeekForward(LONG *pCanSeekForward);
    STDMETHODIMP CanSeekBackward(LONG *pCanSeekBackward);

    // override if you can return the data you are actually working on
    STDMETHODIMP get_CurrentPosition(REFTIME * pllTime) {
        return E_NOTIMPL;
    };

protected:

    // we call this to notify changes. Override to handle them
    virtual HRESULT ChangeStart() PURE;
    virtual HRESULT ChangeStop() PURE;
    virtual HRESULT ChangeRate() PURE;

    COARefTime m_Duration;
    COARefTime m_Start;
    COARefTime m_Stop;
    double m_Rate;

    CCritSec * m_pLock;
};

class AM_NOVTABLE CSourceSeeking :
    public IMediaSeeking,
    public CUnknown
{

public:

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    
    // IMediaSeeking methods

    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
    STDMETHODIMP ConvertTimeFormat( LONGLONG * pTarget, const GUID * pTargetFormat,
                                    LONGLONG    Source, const GUID * pSourceFormat );

    STDMETHODIMP SetPositions( LONGLONG * pCurrent,  DWORD CurrentFlags
        , LONGLONG * pStop,  DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );

    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll);

    
protected:

    // ctor
    CSourceSeeking(const TCHAR *, LPUNKNOWN, HRESULT*, CCritSec *);
    
    // we call this to notify changes. Override to handle them
    virtual HRESULT ChangeStart() PURE;
    virtual HRESULT ChangeStop() PURE;
    virtual HRESULT ChangeRate() PURE;

    CRefTime m_rtDuration;      // length of stream
    CRefTime m_rtStart;         // source will start here
    CRefTime m_rtStop;          // source will stop here
    double m_dRateSeeking;

    // seeking capabilities 
    DWORD m_dwSeekingCaps;

    CCritSec * m_pLock;
};


// Base classes supporting Deferred commands.

// Deferred commands are queued by calls to methods on the IQueueCommand
// interface, exposed by the filtergraph and by some filters. A successful
// call to one of these methods will return an IDeferredCommand interface
// representing the queued command.
//
// A CDeferredCommand object represents a single deferred command, and exposes
// the IDeferredCommand interface as well as other methods permitting time
// checks and actual execution. It contains a reference to the CCommandQueue
// object on which it is queued.
//
// CCommandQueue is a base class providing a queue of CDeferredCommand
// objects, and methods to add, remove, check status and invoke the queued
// commands. A CCommandQueue object would be part of an object that
// implemented IQueueCommand.

class CCmdQueue;

// take a copy of the params and store them. Release any allocated
// memory in destructor

class CDispParams : public DISPPARAMS
{
public:
    CDispParams(UINT nArgs, VARIANT* pArgs);
    ~CDispParams();
};


// CDeferredCommand lifetime is controlled by refcounts. Caller of
// InvokeAt.. gets a refcounted interface pointer, and the CCmdQueue
// object also holds a refcount on us. Calling Cancel or Invoke takes
// us off the CCmdQueue and thus reduces the refcount by 1. Once taken
// off the queue we cannot be put back on the queue.

class CDeferredCommand
    : public CUnknown,
      public IDeferredCommand
{
public:

    CDeferredCommand(
        CCmdQueue * pQ,
        LPUNKNOWN   pUnk,               // aggregation outer unk
        HRESULT *   phr,
        LPUNKNOWN   pUnkExecutor,       // object that will execute this cmd
        REFTIME     time,
        GUID*       iid,
        long        dispidMethod,
        short       wFlags,
        long        cArgs,
        VARIANT*    pDispParams,
        VARIANT*    pvarResult,
        short*      puArgErr,
        BOOL        bStream
        );

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IDeferredCommand methods
    STDMETHODIMP Cancel();
    STDMETHODIMP Confidence(
                    LONG* pConfidence);
    STDMETHODIMP Postpone(
                    REFTIME newtime);
    STDMETHODIMP GetHResult(
                    HRESULT* phrResult);

    // other public methods

    HRESULT Invoke();

    // access methods

    // returns TRUE if streamtime, FALSE if presentation time
    BOOL IsStreamTime() {
       return m_bStream;
    };

    CRefTime GetTime() {
        return m_time;
    };

    REFIID GetIID() {
        return *m_iid;
    };

    long GetMethod() {
        return m_dispidMethod;
    };

    short GetFlags() {
        return m_wFlags;
    };

    DISPPARAMS* GetParams() {
        return &m_DispParams;
    };

    VARIANT* GetResult() {
        return m_pvarResult;
    };

protected:

    CCmdQueue* m_pQueue;

    // pUnk for the interface that we will execute the command on
    LPUNKNOWN   m_pUnk;

    // stored command data
    REFERENCE_TIME     m_time;
    GUID*       m_iid;
    long        m_dispidMethod;
    short       m_wFlags;
    VARIANT*    m_pvarResult;
    BOOL        m_bStream;
    CDispParams m_DispParams;
    DISPID      m_DispId;         //  For get and put

    // we use this for ITypeInfo access
    CBaseDispatch   m_Dispatch;

    // save retval here
    HRESULT     m_hrResult;
};


// a list of CDeferredCommand objects. this is a base class providing
// the basics of access to the list. If you want to use CDeferredCommand
// objects then your queue needs to be derived from this class.

class AM_NOVTABLE CCmdQueue
{
public:
    CCmdQueue();
    virtual ~CCmdQueue();

    // returns a new CDeferredCommand object that will be initialised with
    // the parameters and will be added to the queue during construction.
    // returns S_OK if successfully created otherwise an error and
    // no object has been queued.
    virtual HRESULT  New(
        CDeferredCommand **ppCmd,
        LPUNKNOWN   pUnk,
        REFTIME     time,
        GUID*       iid,
        long        dispidMethod,
        short       wFlags,
        long        cArgs,
        VARIANT*    pDispParams,
        VARIANT*    pvarResult,
        short*      puArgErr,
        BOOL        bStream
    );

    // called by the CDeferredCommand object to add and remove itself
    // from the queue
    virtual HRESULT Insert(CDeferredCommand* pCmd);
    virtual HRESULT Remove(CDeferredCommand* pCmd);

    // Command-Due Checking
    //
    // There are two schemes of synchronisation: coarse and accurate. In
    // coarse mode, you wait till the time arrives and then execute the cmd.
    // In accurate mode, you wait until you are processing the sample that
    // will appear at the time, and then execute the command. It's up to the
    // filter which one it will implement. The filtergraph will always
    // implement coarse mode for commands queued at the filtergraph.
    //
    // If you want coarse sync, you probably want to wait until there is a
    // command due, and then execute it. You can do this by calling
    // GetDueCommand. If you have several things to wait for, get the
    // event handle from GetDueHandle() and when this is signalled then call
    // GetDueCommand. Stream time will only advance between calls to Run and
    // EndRun. Note that to avoid an extra thread there is no guarantee that
    // if the handle is set there will be a command ready. Each time the
    // event is signalled, call GetDueCommand (probably with a 0 timeout);
    // This may return E_ABORT.
    //
    // If you want accurate sync, you must call GetCommandDueFor, passing
    // as a parameter the stream time of the samples you are about to process.
    // This will return:
    //   -- a stream-time command due at or before that stream time
    //   -- a presentation-time command due at or before the
    //      time that stream time will be presented (only between Run
    //      and EndRun calls, since outside of this, the mapping from
    //      stream time to presentation time is not known.
    //   -- any presentation-time command due now.
    // This means that if you want accurate synchronisation on samples that
    // might be processed during Paused mode, you need to use
    // stream-time commands.
    //
    // In all cases, commands remain queued until Invoked or Cancelled. The
    // setting and resetting of the event handle is managed entirely by this
    // queue object.

    // set the clock used for timing
    virtual HRESULT SetSyncSource(IReferenceClock*);

    // switch to run mode. Streamtime to Presentation time mapping known.
    virtual HRESULT Run(REFERENCE_TIME tStreamTimeOffset);

    // switch to Stopped or Paused mode. Time mapping not known.
    virtual HRESULT EndRun();

    // return a pointer to the next due command. Blocks for msTimeout
    // milliseconds until there is a due command.
    // Stream-time commands will only become due between Run and Endrun calls.
    // The command remains queued until invoked or cancelled.
    // Returns E_ABORT if timeout occurs, otherwise S_OK (or other error).
    // Returns an AddRef-ed object
    virtual HRESULT GetDueCommand(CDeferredCommand ** ppCmd, long msTimeout);

    // return the event handle that will be signalled whenever
    // there are deferred commands due for execution (when GetDueCommand
    // will not block).
    HANDLE GetDueHandle() {
        return HANDLE(m_evDue);
    };

    // return a pointer to a command that will be due for a given time.
    // Pass in a stream time here. The stream time offset will be passed
    // in via the Run method.
    // Commands remain queued until invoked or cancelled.
    // This method will not block. It will report VFW_E_NOT_FOUND if there
    // are no commands due yet.
    // Returns an AddRef-ed object
    virtual HRESULT GetCommandDueFor(REFERENCE_TIME tStream, CDeferredCommand**ppCmd);

    // check if a given time is due (TRUE if it is due yet)
    BOOL CheckTime(CRefTime time, BOOL bStream) {

        // if no clock, nothing is due!
        if (!m_pClock) {
            return FALSE;
        }

        // stream time
        if (bStream) {

            // not valid if not running
            if (!m_bRunning) {
                return FALSE;
            }
            // add on known stream time offset to get presentation time
            time += m_StreamTimeOffset;
        }

        CRefTime Now;
        m_pClock->GetTime((REFERENCE_TIME*)&Now);
        return (time <= Now);
    };

protected:

    // protect access to lists etc
    CCritSec m_Lock;

    // commands queued in presentation time are stored here
    CGenericList<CDeferredCommand> m_listPresentation;

    // commands queued in stream time are stored here
    CGenericList<CDeferredCommand> m_listStream;

    // set when any commands are due
    CAMEvent m_evDue;

    // creates an advise for the earliest time required, if any
    void SetTimeAdvise(void);

    // advise id from reference clock (0 if no outstanding advise)
    DWORD_PTR m_dwAdvise;

    // advise time is for this presentation time
    CRefTime m_tCurrentAdvise;

    // the reference clock we are using (addrefed)
    IReferenceClock* m_pClock;

    // true when running
    BOOL m_bRunning;

    // contains stream time offset when m_bRunning is true
    CRefTime m_StreamTimeOffset;
};

#endif // __CTLUTIL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dbgprint.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  

dbgprint.h

Abstract:

Debug Print macros used in the WCEDDK samples.

Notes: 


--*/

#ifndef __DBGPRINT_H__
#define __DBGPRINT_H__

#ifdef __cplusplus
extern "C" {
#endif

// For NT emulation, we include emulation header, and 
// let the debug macro to use wprintf function.
#ifdef _WIN32_WCE_EMULATION  
#include <wceemul.h>
#define DbgPrintfW wprintf
#endif // _WIN32_WCE_EMULATION

// Set debug macro.
extern int DbgPrintfW(LPWSTR lpszFmt, ...);
#ifdef DEBUG
#define DEBUGMSG(cond,printf_exp) ((void)((cond)?(DbgPrintfW printf_exp),1:0))
#else
#define DEBUGMSG(cond,printf_exp) ((void)0)
#endif // DEBUG

#ifdef __cplusplus
}
#endif

#endif //__DBGPRINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dbgapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name: dbgapi.h

Purpose: Debug Message and Zone APIs.

--*/

#pragma once

#ifndef __DBGAPI_H__
#define __DBGAPI_H__

#ifdef __cplusplus
extern "C" {
#endif
  
#ifndef WIDEN
#define WIDEN2(x) L ## x
#define WIDEN(x) WIDEN2(x)
#define __WFILE__ WIDEN(__FILE__)
#endif
 

#ifdef UNDER_CE
void WINAPIV NKDbgPrintfW(LPCWSTR lpszFmt, ...);
void WINAPI WriteDebugLED(WORD wIndex, DWORD dwPattern);
#else
#include <windows.h>
#include <wchar.h>
#include <stdlib.h>
#include <stdarg.h>
static __inline void WINAPIV NKDbgPrintfW(const wchar_t* szFmt, ...)
{
    wchar_t szBuffer[1024];
    va_list args;
    va_start(args, szFmt);
    vswprintf_s(szBuffer, _countof(szBuffer), szFmt, args);
    OutputDebugStringW(szBuffer);
    OutputDebugStringW(L"\n");
    va_end(args);
}
#endif // UNDER_CE


/*
@doc    EXTERNAL    KERNEL
@struct DBGPARAM | Debug zone information structure
@comm   The name of the module is used to look for zone initialization
        information in the host PC registry. Zone names are displayed by
        the control app (eg shell) which allows the user to dynamically
        set zones.
@xref   <f DEBUGREGISTER>
*/
typedef struct _DBGPARAM {
    WCHAR   lpszName[32];           // @field Name of module
    WCHAR   rglpszZones[16][32];    // @field names of zones for first 16 bits
    ULONG   ulZoneMask;             // @field Current zone Mask
} DBGPARAM, *LPDBGPARAM;

BOOL RegisterDbgZones(HMODULE hMod, LPDBGPARAM lpdbgparam);


/*
@func   BOOL | DEBUGZONE | Associates a mask bit with a zone
@parm   int | bitnum | Bitnumber being defined
@rdesc  A boolean which is TRUE if bitnum in '1' else is FALSE
@ex     Example of use is |
        // associate bit 0 with an info zone
        #define ZONE_INFO   DEBUGZONE(0)
        // we can now use ZONE_INFO as a boolean for anything.
        // We'd typically use it in a DEBUGMSG ...
*/
#define DEBUGZONE(n)  (dpCurSettings.ulZoneMask&(0x00000001<<(n)))

#ifdef DEBUG
#ifdef SHIP_BUILD
#undef SHIP_BUILD
#pragma message (__FILE__ ":WARNING: SHIP_BUILD turned off since DEBUG defined")
#endif
#endif

#ifdef SHIP_BUILD

#define ERRORMSG(cond,printf_exp) ((void)0)
#define RETAILMSG(cond,printf_exp) ((void)0)
#define DEBUGMSG(cond,printf_exp) ((void)0)
#define DEBUGLED(cond,parms) ((void)0)
#define DBGCHK(module,exp) ((void)0)
#define DEBUGCHK(exp) ((void)0)
#define DEBUGREGISTER(hMod) ((void)0)
#define RETAILREGISTERZONES(hMod) ((void)0)
#define DBGCHK_RETAIL(exp) ((void)0)
#define ASSERT_RETAIL(exp) ((void)0)

#else // SHIP_BUILD




#ifdef DEBUG

/*
@func BOOL | DEBUGMSG | Output a debug message conditionally
@parm BOOL | cond | The condition under which the message is printed
@parm <null> | (printf_exp) | A printf style expression to be output. Must be enclosed
      in parentheses. Gets passed on to the <f NKDbgPrintf> function.
@ex   Example of use |
      DEBUGMSG(ZONE_INFO, (L"DLLNAME: Entered func1. Param 1 = %d\r\n", par1));
@xref <f RETAILMSG> <tab> <f ERRORMSG> <tab> <f NKDbgPrintf>
*/
#define DEBUGMSG(cond,printf_exp)   \
   ((void)((cond)?(NKDbgPrintfW printf_exp),1:0))
#define DBGCHK(module,exp) \
   ((void)((exp)?1:(          \
       NKDbgPrintfW ( L"%s: DEBUGCHK failed in file %s at line %d \r\n", \
                 (LPWSTR)module, __WFILE__ ,__LINE__ ),    \
       DebugBreak(), \
       0  \
   )))

/*
@func BOOL | DEBUGLED | Output a debug LED pattern conditionally
@parm BOOL | cond | The condition under which the message is printed
@parm <null> | (parms) | The parameters to be passed to the WriteDebugLED
      function.  Must be in parentheses.  First parameter is wIndex and second
      parameter is dwPattern.
@ex   Example of use |
      DEBUGLED(ZONE_INFO, (3, 0x2345);
@xref <f RETAILMSG> <tab> <f ERRORMSG> <tab> <f WriteDebugLED>
*/
#define DEBUGLED(cond,parms)   \
   ((void)((cond)?(WriteDebugLED parms),1:0))    


/*
@func BOOL | DEBUGCHK | Asserts an expression
@parm BOOL | exp | Expression to be asserted
@comm If the expression is false, this will cause a DebugBreak to be hit which
      will cause you to enter the debugger if you are running with one. It will
      also give you the line number and file name where the assert failed.
*/
#define DEBUGCHK(exp) DBGCHK(dpCurSettings.lpszName, exp)
extern  DBGPARAM    dpCurSettings;
/*
@func  BOOL | DEBUGREGISTER | Registers debug settings for a process / module
@parm  HINSTANCE | hInstance | If target is a module this is it's hInstance. If
       target is a process this should be NULL.
@comm  This simply calls through to <f RegisterDebugZones>. It assumes that
       there is a variable of name <b dpCurSettings> visible in the code.
*/
#define DEBUGREGISTER(hMod)  RegisterDbgZones(hMod, &dpCurSettings)
#else // DEBUG

#define DEBUGMSG(cond,printf_exp) ((void)0)
#define DEBUGLED(cond,parms) ((void)0)
#define DBGCHK(module,exp) ((void)0)
#define DEBUGCHK(exp) ((void)0)
#define DEBUGREGISTER(hMod) ((void)0)

#endif // DEBUG


#define DBGCHK_RETAIL(exp) \
   ((void)((exp)?1:(          \
       NKDbgPrintfW ( TEXT("DBGCHK_RETAIL failed in file %s at line %d \r\n"), \
                 TEXT(__FILE__) ,__LINE__ ),    \
       DebugBreak(), \
       0  \
   )))


#define ASSERT_RETAIL(exp) DBGCHK_RETAIL(exp)


/*
@func BOOL | RETAILMSG | Output a message in retail builds
@parm BOOL | cond | The condition under which the message is printed
@parm <null> | (printf_exp) | A printf style expression to be output. Must be enclosed
      in parentheses. This is simply passed in to the <f NKDbgPrintf> function.
@comm This should be used in a very limited fashion since it can increase
      the size of your retail build.
@ex   Example of use |
      RETAILMSG(x==y, (L"DLLNAME: Expect. x==y = %d\r\n", x));
@xref <f DEBUGMSG> <tab> <f ERRORMSG> <tab> <f NKDbgPrintf>
*/
#define RETAILMSG(cond,printf_exp)   \
   ((cond)?(NKDbgPrintfW printf_exp),1:0)

/*
@func BOOL | ERRORMSG | Output an error msg
@parm BOOL | cond | The condition under which the message is printed
@parm <null> | (printf_exp) | A printf style expression to be output. Must be enclosed
      in parentheses. This is passed in to the <f NKDbgPrintf> function.
@comm Very similar to <f RETAILMSG> except that this will prefix the message
      with "ERROR" and give the file name & line number of the error.
@ex   Example of use |
      ERRORMSG(x==y, (L"DLLNAME: x===y = %d\r\n", x));
@xref <f DEBUGMSG> <tab> <f RETAILMSG> <tab> <f NKDbgPrintf>
*/
#define ERRORMSG(cond,printf_exp)	 \
   ((cond)?(NKDbgPrintfW(L"ERROR: %s line %d: ",__WFILE__,__LINE__), NKDbgPrintfW printf_exp),1:0)

/*
@func  BOOL | RETAILREGISTERZONES | Registers zone settings for a process / module
       (Same as DEBUGREGISTER except available in retail and debug builds)
@parm  HINSTANCE | hInstance | If target is a module this is it's hInstance. If
       target is a process this should be NULL.
@comm  This simply calls through to <f RegisterDebugZones>. It assumes that
       there is a variable of name <b dpCurSettings> visible in the code.
*/
#define RETAILREGISTERZONES(hMod)  RegisterDbgZones(hMod, &dpCurSettings)

#endif // SHIP_BUILD

/*
@func BOOL | RETAILLED | Output a LED code in retail builds
@parm BOOL | cond | The condition under which the message is printed
@parm <null> | (parms) | The parameters to be passed to the WriteDebugLED
      function.  Must be in parentheses.  First parameter is wIndex and second
      parameter is dwPattern.
@comm This should be used in a very limited fashion since it can increase
      the size of your retail build.
@ex   Example of use |
      RETAILLED(ZONE_INFO, (3, 0x2345);
@xref <f DEBUGMSG> <tab> <f ERRORMSG> <tab> <f WriteDebugLED>
*/
#define RETAILLED(cond,parms) \
   ((void)((cond)?(WriteDebugLED parms),1:0))    

// some alternate ways to get to these
#define ASSERTMSG(msg, exp) (DEBUGMSG(!exp,(msg)),DBGCHK(L"Unknown",exp))
#undef ASSERT
#define ASSERT( exp )   DBGCHK(L"Unknown", exp)
#define ASSERT_IMPLIES( cond, exp ) ASSERT( !(cond) || (exp) )
#ifdef DEBUG
#define VERIFY(exp)  ASSERT(exp)
#else
#define VERIFY(exp)  ((void)(exp))
#endif

// Enable providing a hint to prefast via __assume
// e.g.
//   PREFAST_ASSUME( pPointer); // we know pPointer can never be NULL
#ifdef _PREFAST_
#define PREFAST_ASSUME(exp) __assume(exp)
#else
#define PREFAST_ASSUME(exp)
#endif

// Simplify the cases where a PREFAST_ASSUME would be followed by an assertion
#define PREFAST_DEBUGCHK(exp) \
    { \
        PREFAST_ASSUME(exp);